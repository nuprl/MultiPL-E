language: scala
name: HumanEval_130_tri
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var result = new ArrayBuffer[Long]()\n        result += 1\n        result\
    \ += 3\n        var i = 3\n        while (i <= n) {\n            var v = result(i\
    \ - 1) + result(i - 2) + result(i - 3)\n            if (i % 2 == 0) v += i / 2\n\
    \            result += v\n            i += 1\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 2 is out of bounds (min 0, max 1)\n\
    \tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:99)\n\tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:43)\n\
    \tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\
    \tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\tat Problem$.tri(tmp0kjd7bs7.scala:26)\n\
    \tat Problem$.main(tmp0kjd7bs7.scala:34)\n\tat Problem.main(tmp0kjd7bs7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 1) List(1)\n        else {\n            val seq = ListBuffer[Long]()\n\
    \            seq += 1\n            seq += 3\n            seq += 2\n          \
    \  val arr = Array.fill(n.toInt)(0L)\n            seq.copyToBuffer(arr)\n    \
    \        for (i <- 3 to n.toInt) {\n                arr(i) = if (i % 2 == 0) 1\
    \ + i / 2 else arr(i - 1) + arr(i - 2) + arr(i + 1)\n            }\n         \
    \   arr.toList\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuuvl9jvw.scala:28:29\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            seq.copyToBuffer(arr)\n\
    \e[31m\e[31m   |\e[0m                             ^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Found:    (arr : Array[Long])\n\e[31m   |\e[0m       \
    \                  Required: scala.collection.mutable.Buffer[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def sub(n : Long, lst : List[Long]) : List[Long] = {\n            if\
    \ (n == 0) lst.reverse\n            else if (n % 2 == 0) sub(n - 1, n / 2 + 1\
    \ :: lst)\n            else sub(n - 1, lst(0) + lst(1) + lst(2) :: lst)\n    \
    \    }\n        sub(n, List(1, 3, 2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppt0egk91.scala:29)\n\tat Problem.main(tmppt0egk91.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 1) {\n            List(1l)\n        } else if (n == 1) {\n  \
    \          List(1l, 3l)\n        } else {\n            val result = new ListBuffer[Long]\n\
    \            result += 1l\n            result += 3l\n            result += 2l\n\
    \            var i = 1\n            while (i < n) {\n                if (i % 2\
    \ == 0) {\n                    result += 1 + i / 2\n                } else {\n\
    \                    result += result(i - 1) + result(i - 2) + result(i + 1)\n\
    \                }\n                i += 1\n            }\n            result.toList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri(tmpb7cdt185.scala:35)\n\tat Problem$.main(tmpb7cdt185.scala:43)\n\
    \tat Problem.main(tmpb7cdt185.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) return List(1)\n        val t = new Array[Long]((n + 1).toInt)\n\
    \        t(0) = 1\n        t(1) = 3\n        for (i <- 2 to (n - 1).toInt) {\n\
    \            if (i % 2 == 0) {\n                t(i) = 1 + i / 2\n           \
    \ } else {\n                t(i) = t(i - 1) + t(i - 2) + t(i + 1)\n          \
    \  }\n        }\n        t.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5n7ytnx9.scala:35)\n\tat Problem.main(tmp5n7ytnx9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val result = new ArrayBuffer[Long]()\n        result += 1\n        result\
    \ += 3\n        if (n == 1) return result.toList\n        result += 2\n      \
    \  if (n == 2) return result.toList\n        for (i <- 3 to n.toInt) {\n     \
    \       if (i % 2 == 0) result += (1 + i / 2)\n            else result += (result(i\
    \ - 1) + result(i - 2) + result(i + 1))\n        }\n        result.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4 is out of bounds (min 0, max 2)\n\
    \tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:99)\n\tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:43)\n\
    \tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\
    \tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\tat Problem$.tri$$anonfun$1(tmpems0i3ia.scala:29)\n\
    \tat Problem$.tri$$anonfun$adapted$1(tmpems0i3ia.scala:30)\n\tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\
    \tat Problem$.tri(tmpems0i3ia.scala:30)\n\tat Problem$.main(tmpems0i3ia.scala:34)\n\
    \tat Problem.main(tmpems0i3ia.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tval r = ListBuffer[Long]()\n    \tr += 1\n    \tr += 3\n    \tr += 2\n\
    \    \tdef f(i : Long) : Long = {\n    \t\tif (i == n) return r(r.length - 1)\n\
    \    \t\telse {\n    \t\t\tif (i % 2 == 0) r += (1 + i / 2)\n    \t\t\telse r\
    \ += (r(r.length - 1) + r(r.length - 2) + r(r.length + 1))\n    \t\t\tf(i + 1)\n\
    \    \t\t}\n    \t}\n    \tf(3)\n    \tr.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt63v538t.scala:37)\n\tat Problem.main(tmpt63v538t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // f(n) = 1 + n / 2 if n is even.\n        // f(n) = f(n - 1) + f(n -\
    \ 2) + f(n + 1) if n is odd.\n        def f(n : Long) : Long = {\n           \
    \ if (n == 1) 3\n            else if (n % 2 == 0) {\n                1 + n / 2\n\
    \            } else {\n                f(n - 1) + f(n - 2) + f(n + 1)\n      \
    \      }\n        }\n        List.range(1, n + 2).map(f(_)).toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpv93ekctl.scala:31:28 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        List.range(\e[31m1\e[0m, n + \e[31m2\e[0m).map(f(_)).toList\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       No implicit Ordering defined for AnyVal.\n1 error found\n"
  stdout: ''
  timestamp: 1659979569
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def rec(x : Long, l : List[Long]) : List[Long] = {\n            x match\
    \ {\n                case 1 => rec(x + 1, l :+ 3)\n                case x if x\
    \ > n => l\n                case x if x % 2 == 0 => rec(x + 1, l :+ (1 + x / 2))\n\
    \                case x => rec(x + 1, l :+ (l(x.toInt - 2) + l(x.toInt - 1) +\
    \ l(x.toInt + 1)))\n            }\n        }\n        rec(1, List[Long]())\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rec$1(tmpe_t7cl_h.scala:26)\n\tat Problem$.tri(tmpe_t7cl_h.scala:29)\n\
    \tat Problem$.main(tmpe_t7cl_h.scala:32)\n\tat Problem.main(tmpe_t7cl_h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // TODO\n        List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5s8wc15z.scala:25)\n\tat Problem.main(tmp5s8wc15z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var l = List[Long]()\n        var c = 0\n        while (c <= n) {\n \
    \           l = c match {\n                case 0 => List(0)\n               \
    \ case 1 => List(0, 1)\n                case 2 => List(0, 1, 3)\n            \
    \    case _ => l :+ (1 + c / 2)\n            }\n            c += 1\n        }\n\
    \        l\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpptnoebeh.scala:35)\n\tat Problem.main(tmpptnoebeh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\t\
    \t// Fill up this function body\n\t\t// You can add another function as well,\
    \ if required\n        var l = Array.fill(n.toInt+1)(0L)\n        l(0) = 1\n \
    \       l(1) = 3\n        if (n >= 2) {\n            l(2) = 2\n            for\
    \ (i <- 3 to n.toInt) {\n                if (i % 2 == 0) l(i) = (i / 2).toLong\n\
    \                else l(i) = l(i - 1) + l(i - 2) + l(i + 1)\n            }\n \
    \       }\n        l.toList\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmpsqf95kqb.scala:30)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpsqf95kqb.scala:31)\n\
    \tat Problem$.main(tmpsqf95kqb.scala:36)\n\tat Problem.main(tmpsqf95kqb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var lst = new ListBuffer[Long]\n        if (n == 0) {\n            lst\
    \ += 1\n            return lst.toList\n        }\n        lst += 1\n        if\
    \ (n == 1) return lst.toList\n        lst += 3\n        if (n == 2) return lst.toList\n\
    \        lst += 2\n        if (n == 3) return lst.toList\n        lst += 8\n \
    \       if (n == 4) return lst.toList\n        var i = 4\n        while (i < n)\
    \ {\n            lst += (if (i % 2 == 0) lst(i) + 1 else lst(i - 1) + lst(i -\
    \ 2) + lst(i + 1))\n            i += 1\n        }\n        return lst.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd2uf9t9a.scala:42)\n\tat Problem.main(tmpd2uf9t9a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // 'n' is the number of elements\
    \ in the Tribonacci sequence\n        List[Long]()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgc7nj52_.scala:26)\n\tat Problem.main(tmpgc7nj52_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List[Long]()\n        else if (n == 1) List[Long](1)\n  \
    \      else if (n == 2) List[Long](1, 3)\n        else {\n            var ans\
    \ = List[Long](1, 3, 2)\n            var k = 2\n            while (k < n) {\n\
    \                if (k % 2 == 0) ans = ans :+ (1 + k / 2)\n                else\
    \ ans = ans :+ (ans(k - 1) + ans(k - 2) + ans(k + 1))\n                k += 1\n\
    \            }\n            ans\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr7cpab89.scala:36)\n\tat Problem.main(tmpr7cpab89.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        ???\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.tri(tmp1l2_wldc.scala:21)\n\tat Problem$.main(tmp1l2_wldc.scala:24)\n\
    \tat Problem.main(tmp1l2_wldc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(1)\n        else {\n            val cache = new mutable.HashMap[Long,\
    \ Long]\n            def tri(n : Long) : Long = {\n                if (cache.contains(n))\
    \ cache(n)\n                else {\n                    val ans = if (n == 1)\
    \ 3\n                    else if (n % 2 == 0) 1 + n / 2\n                    else\
    \ tri(n - 1) + tri(n - 2) + tri(n + 1)\n                    cache += (n -> ans)\n\
    \                    ans\n                }\n            }\n            (1 to\
    \ n.toInt).map(tri(_)).toList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvo1nk539.scala:23:28 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mcache\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m \
    \                           ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979566
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triIter(n : Long, res : List[Long]) : List[Long] = {\n          \
    \  if (n == 1) res.reverse\n            else if (n % 2 == 0) triIter(n - 1, (n\
    \ / 2 + 1) :: res)\n            else triIter(n - 1, res.head + res.tail.head +\
    \ res.tail.tail.head :: res)\n        }\n        triIter(n, List[Long](1, 3, 2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp840t3l30.scala:29)\n\tat Problem.main(tmp840t3l30.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triHelp(n : Long, next : Long, list : List[Long]) : List[Long] =\
    \ {\n            if (n == 0) {\n                next :: list\n            } else\
    \ {\n                if (n % 2 == 0) {\n                    triHelp(n - 1, (1\
    \ + n / 2), next :: list)\n                } else {\n                    triHelp(n\
    \ - 1, next + list.head + list.tail.head, next :: list)\n                }\n \
    \           }\n        }\n        triHelp(n, 0, List(1, 3, 2))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph13ix2h1.scala:35)\n\tat Problem.main(tmph13ix2h1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val cached = new HashMap[Long, Long]\n        cached += (1l -> 3l)\n\
    \        def tri(n : Long) : Long = {\n            cached.get(n) match {\n   \
    \             case Some(x) => x\n                case None => {\n            \
    \        val value = if (n % 2 == 0) 1 + n / 2 else tri(n - 1) + tri(n - 2) +\
    \ tri(n + 1)\n                    cached += (n -> value)\n                   \
    \ value\n                }\n            }\n        }\n        (1l to n).map(tri(_)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmytxyh3w.scala:36)\n\tat Problem.main(tmpmytxyh3w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var list = List[Long]()\n        var a = 1l\n        var b = 3l\n   \
    \     var c = 2l\n        for (i <- 0 to n.toInt) {\n            i match {\n \
    \               case 0 => list = list :+ 1l\n                case 1 => list =\
    \ list :+ 3l\n                case 2 => list = list :+ 2l\n                case\
    \ _ => {\n                    var d = a + b + c\n                    a = b\n \
    \                   b = c\n                    c = d\n                    list\
    \ = list :+ d\n                }\n            }\n        }\n        list\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9u960_so.scala:42)\n\tat Problem.main(tmp9u960_so.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // 'n' is the number of elements\
    \ in Tribonacci sequence\n        def triRec(n : Long, acc : List[Long]) : List[Long]\
    \ = {\n            n match {\n                case 0 => 1L :: acc\n          \
    \      case 1 => 3L :: acc\n                case 2 => 2L :: acc\n            \
    \    case _ => if (n % 2 == 0) (1 + n / 2) :: acc else triRec(n - 1, triRec(n\
    \ - 2, triRec(n + 1, acc)))\n            }\n        }\n        triRec(n, List[Long]()).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_rxgp47a.scala:34)\n\tat Problem.main(tmp_rxgp47a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // `0` is the only number in Scala\
    \ that can be used to get the remainder of a division or a modulo operation.\n\
    \        // In other languages you might use `-1` or `1` to get the remainder\
    \ of division when the\n        // dividend is negative.\n        (for (i <- 1l\
    \ to n) yield if (i % 2 == 0) (1 + i / 2) else (1)).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp36d3w36x.scala:28)\n\tat Problem.main(tmp36d3w36x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var ans = List[Long]()\n        ans = ans.+:(3l)\n        ans = ans.+:(2l)\n\
    \        ans = ans.+:(1l)\n        for (i <- 3l to n) {\n            var t = ans(i.toInt\
    \ - 1) + ans(i.toInt - 2) + ans(i.toInt - 3)\n            if (i % 2 == 0) {\n\
    \                t = 1 + i / 2\n            }\n            ans = ans.+:(t)\n \
    \       }\n        ans.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw1hi7lc.scala:35)\n\tat Problem.main(tmpxw1hi7lc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979578
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def loop(n : Long, a : Long, b : Long, c : Long, list : List[Long]) :\
    \ List[Long] = {\n            if (n == 0) {\n                a :: list\n     \
    \       } else if (n % 2 == 0) {\n                loop(n - 1, a + 1 + n / 2, a,\
    \ b, list)\n            } else {\n                loop(n - 1, a + b + c, a, b,\
    \ list)\n            }\n        }\n        loop(n, 1, 3, 2, Nil)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf79qqe6d.scala:33)\n\tat Problem.main(tmpf79qqe6d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def t(i : Long) : Long = if (i < 2) 3 else if (i % 2 == 0) 1 + i / 2\
    \ else t(i - 1) + t(i - 2) + t(i + 1)\n        (1l to n).map(t).toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvgjb21fl.scala:25)\n\tat Problem.main(tmpvgjb21fl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        var a = 1L\n        var b = 3L\n        var c\
    \ = 2L\n        var temp = 0L\n        var ans = List[Long]()\n        ans = ans\
    \ :+ a\n        if (n > 0) ans = ans :+ b\n        if (n > 1) ans = ans :+ c\n\
    \        for (i <- 3L to n) {\n            if (i % 2 == 0) temp = (1 + i / 2)\n\
    \            else temp = a + b + c\n            a = b\n            b = c\n   \
    \         c = temp\n            ans = ans :+ temp\n        }\n        ans\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5j3bhi7p.scala:42)\n\tat Problem.main(tmp5j3bhi7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val cache = new HashMap[Long, Long]()\n        def triInner(n : Long)\
    \ : Long = {\n            if (n == 1) 3\n            else if (n == 2) 2\n    \
    \        else if (n == 3) 8\n            else if (cache.contains(n)) cache(n)\n\
    \            else {\n                val tmp = if (n % 2 == 0) (n / 2) + 1 else\
    \ triInner(n - 1) + triInner(n - 2) + triInner(n + 1)\n                cache +=\
    \ (n -> tmp)\n                tmp\n            }\n        }\n        val result\
    \ = new ListBuffer[Long]()\n        (1 to n + 1).foreach(x => result += triInner(x))\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9111b0ke.scala:34:14\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        (\e[31m1\e[0m to n +\
    \ \e[31m1\e[0m).foreach(\e[36mx\e[0m => result += triInner(x))\n\e[31m\e[31m \
    \  |\e[0m              ^^^^^\e[0m\n\e[31m   |\e[0m              Found:    Long\n\
    \e[31m   |\e[0m              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979580
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var list = new ListBuffer[Long]\n        list += 1\n        list += 3\n\
    \        var i = 2\n        while (i <= n) {\n            if (i % 2 == 0) {\n\
    \                list += 1 + i / 2\n            } else {\n                list\
    \ += list(i - 1) + list(i - 2) + list(i + 1)\n            }\n            i +=\
    \ 1\n        }\n        list.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri(tmpacpvzfvg.scala:29)\n\tat Problem$.main(tmpacpvzfvg.scala:36)\n\
    \tat Problem.main(tmpacpvzfvg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri_helper(count : Long, l : List[Long]) : List[Long] = {\n     \
    \       if (count > n) l.reverse\n            else if (count == 0) tri_helper(count\
    \ + 1, 1l :: l)\n            else if (count == 1) tri_helper(count + 1, 3l ::\
    \ l)\n            else if (count == 2) tri_helper(count + 1, 2l :: l)\n      \
    \      else if (count % 2 == 0) tri_helper(count + 1, (1 + count / 2) :: l)\n\
    \            else tri_helper(count + 1, (l(2) + l(1) + l(0)) :: l)\n        }\n\
    \        tri_helper(0, Nil)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcq2to4gh.scala:32)\n\tat Problem.main(tmpcq2to4gh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tif (n == 0) return List(1)\n    \tif (n == 1) return List(1, 3)\n    \t\
    if (n == 2) return List(1, 3, 2)\n    \tval tribonacci = new Array[Long](n.toInt\
    \ + 1)\n    \ttribonacci(0) = 1\n    \ttribonacci(1) = 3\n    \ttribonacci(2)\
    \ = 2\n    \tfor (i <- 3 to n.toInt) {\n    \t\tif (i % 2 == 0) tribonacci(i)\
    \ = 1 + i / 2\n    \t\telse tribonacci(i) = tribonacci(i - 1) + tribonacci(i -\
    \ 2) + tribonacci(i + 1)\n    \t}\n    \ttribonacci.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmp6fknhyym.scala:30)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp6fknhyym.scala:31)\n\
    \tat Problem$.main(tmp6fknhyym.scala:35)\n\tat Problem.main(tmp6fknhyym.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triInternal(n : Long, first : Long, second : Long, third : Long)\
    \ : List[Long] = {\n            if (n == 0) return List(first)\n            else\
    \ {\n                if (n % 2 == 0) return first :: triInternal(n - 1, second,\
    \ third, (1 + n / 2))\n                else return first :: triInternal(n - 1,\
    \ second, third, third + second + first)\n            }\n        }\n        return\
    \ triInternal(n, 1, 3, 2)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2q66e3ni.scala:31)\n\tat Problem.main(tmp2q66e3ni.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def loop(m : Long, l : List[Long]) : List[Long] = {\n            if (m\
    \ == 0) l\n            else if (m % 2 == 0) loop(m - 1, 1 + m / 2 :: l)\n    \
    \        else loop(m - 1, l.head + l.tail.head + l.tail.tail.head :: l)\n    \
    \    }\n        loop(n, 3 :: Nil)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.loop$1(tmp8by9w42d.scala:24)\n\
    \tat Problem$.tri(tmp8by9w42d.scala:26)\n\tat Problem$.main(tmp8by9w42d.scala:29)\n\
    \tat Problem.main(tmp8by9w42d.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Your code here\n        null\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.tri(long)\" is null\n\tat Problem$.main(tmpxwx7ktyh.scala:25)\n\
    \tat Problem.main(tmpxwx7ktyh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) return Nil\n        if (n == 1) return List(1)\n        if\
    \ (n == 2) return List(1, 3)\n        val array = new Array[Long](n.toInt + 1)\n\
    \        array(0) = 1\n        array(1) = 3\n        array(2) = 2\n        for\
    \ (i <- Range(3, n.toInt + 1)) {\n            if (i % 2 == 0) {\n            \
    \    array(i) = 1 + i / 2\n            } else {\n                array(i) = array(i\
    \ - 1) + array(i - 2) + array(i + 1)\n            }\n        }\n        array.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmpyme2wcr6.scala:32)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpyme2wcr6.scala:34)\n\
    \tat Problem$.main(tmpyme2wcr6.scala:38)\n\tat Problem.main(tmpyme2wcr6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // 'return List()' if you need\
    \ to return an empty list\n        if (n == 0) {\n            return List()\n\
    \        }\n        var l = List(1, 3, 2)\n        while (l.length < n + 1) {\n\
    \            val len = l.length\n            if (len % 2 == 0) {\n           \
    \     l = l :+ 1 + len / 2\n            } else {\n                l = l :+ l(len\
    \ - 1) + l(len - 2) + l(len + 1)\n            }\n        }\n        return l\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpte1lcb0f.scala:35:15\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mreturn\e[0m l\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (l : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n\t\tval seq = new scala.collection.mutable.ArrayBuffer[Long]\n\
    \t\tseq += 1\n\t\tseq += 3\n\t\tseq += 2\n\t\t\n\t\tvar j = 3\n\t\tfor ( i <-\
    \ 3l to n){\n\t\t\tif ( i % 2 == 0){\n\t\t\t\tseq += (1 + i / 2)\n\t\t\t}else{\n\
    \t\t\t\tseq += (seq(j - 1) + seq(j - 2) + seq(j))\n\t\t\t\tj += 1\n\t\t\t}\n\t\
    \t}\n\t\tseq.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqztv1z47.scala:38:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 2 tabs\n\e[31m   |\e[0m   Latest indent   :\
    \ 4 spaces\n1 error found\n"
  stdout: ''
  timestamp: 1659979578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tvar a = 1l\n    \tvar b = 3l\n    \tvar c = 2l\n    \tval result = new\
    \ ListBuffer[Long]\n    \tresult += 1l\n    \tresult += 3l\n    \tresult += 2l\n\
    \    \tfor (i <- 0 until n - 2) {\n    \t\tif (i % 2 == 0) {\n    \t\t\tresult\
    \ += 1 + c / 2\n    \t\t\ta = c\n    \t\t\tc = result(result.length - 1)\n   \
    \ \t\t} else {\n    \t\t\tresult += a + b + c\n    \t\t\tb = c\n    \t\t\tc =\
    \ result(result.length - 1)\n    \t\t}\n    \t}\n    \tresult.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprhw3lmyv.scala:28:26\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m    \t\e[33mfor\e[0m (i <- \e\
    [31m0\e[0m until n - \e[31m2\e[0m) {\n\e[31m\e[31m   |\e[0m    \t            \
    \      ^^^^^\e[0m\n\e[31m   |\e[0m    \t                  Found:    Long\n\e[31m\
    \   |\e[0m    \t                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979580
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        //return null\n        val sequence = ListBuffer[Long]()\n        sequence\
    \ += 1\n        sequence += 3\n        for (i <- 2 to n.toInt) {\n           \
    \ if (i % 2 == 0) {\n                sequence += (1 + i / 2)\n            } else\
    \ {\n                sequence += (sequence(i - 1) + sequence(i - 2) + sequence(i\
    \ + 1))\n            }\n        }\n        sequence.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpq3ycc8mb.scala:29)\n\tat Problem$.tri$$anonfun$adapted$1(tmpq3ycc8mb.scala:31)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpq3ycc8mb.scala:31)\n\
    \tat Problem$.main(tmpq3ycc8mb.scala:35)\n\tat Problem.main(tmpq3ycc8mb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Mai"
  stdout: ''
  timestamp: 1659979582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triI(n : Long, l : List[Long]) : List[Long] = {\n            if (n\
    \ == 0) l\n            else {\n                if (n % 2 == 0) triI(n - 1, (1\
    \ + n / 2) :: l)\n                else triI(n - 1, (l(0) + l(1) + l(2)) :: l)\n\
    \            }\n        }\n        triI(n, List(1))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.triI$1(tmp06h3jp5u.scala:25)\n\tat Problem$.tri(tmp06h3jp5u.scala:28)\n\
    \tat Problem$.main(tmp06h3jp5u.scala:31)\n\tat Problem.main(tmp06h3jp5u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) return List(1)\n        val list = new ListBuffer[Long]\n\
    \        list += 1\n        list += 3\n        list += 2\n        var nn = n\n\
    \        while (nn > 2) {\n            list += list(list.length - 1) + list(list.length\
    \ - 2) + list(list.length - 3)\n            nn -= 1\n        }\n        list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_3u77cuz.scala:34)\n\tat Problem.main(tmp_3u77cuz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val a = 1l\n        val b = 3l\n        val c = 2l\n        var d = 0l\n\
    \        var lst = List[Long](a, b, c)\n        for (i <- 3l to n) {\n       \
    \     if (i % 2 == 0) d = 1 + i / 2\n            else d = lst(i.toInt - 1) + lst(i.toInt\
    \ - 2) + lst(i.toInt + 1)\n            lst :+= d\n        }\n        lst\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$$anonfun$1(tmprtst9zc6.scala:28)\n\tat scala.runtime.java8.JFunction1$mcVJ$sp.apply(JFunction1$mcVJ$sp.scala:18)\n\
    \tat scala.collection.immutable.NumericRange.foreach(NumericRange.scala:115)\n\
    \tat Problem$.tri(tmprtst9zc6.scala:30)\n\tat Problem$.main(tmprtst9zc6.scala:34)\n\
    \tat Problem.main(tmprtst9zc6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var ret = List[Long]()\n        ret :+= 1\n        for (i <- 1 to n.toInt)\
    \ {\n            if (i == 1) ret :+= 3\n            else if (i == 2) ret :+= 2\n\
    \            else {\n                if (i % 2 == 0) ret :+= (1 + i / 2)\n   \
    \             else ret :+= (ret(i - 2) + ret(i - 1) + ret(i + 1))\n          \
    \  }\n        }\n        ret\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$$anonfun$1(tmp8d1s5086.scala:28)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp8d1s5086.scala:30)\n\
    \tat Problem$.main(tmp8d1s5086.scala:34)\n\tat Problem.main(tmp8d1s5086.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\t\
    \tif (n == 0) {\n\t\t\treturn List(1L)\n\t\t}\n\t\tif (n == 1) {\n\t\t\treturn\
    \ List(1L, 3L)\n\t\t}\n\t\tvar a = 1L\n\t\tvar b = 3L\n\t\tvar c = 2L\n\t\tvar\
    \ result = List(a, b, c)\n\t\tfor (i <- 3l to n) {\n\t\t\tval d = if (i % 2 ==\
    \ 0) (1 + i / 2) else (a + b + c)\n\t\t\tresult = result :+ d\n\t\t\ta = b\n\t\
    \t\tb = c\n\t\t\tc = d\n\t\t}\n\t\treturn result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp8y9c3zhc.scala:39:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 2 tabs\n\e[31m   |\e[0m   Latest indent   :\
    \ 4 spaces\n1 error found\n"
  stdout: ''
  timestamp: 1659979578
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // 'coffeescript' is not available\
    \ for this exercise.\n        null\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.tri(long)\" is null\n\tat Problem$.main(tmpi9xrkj9h.scala:26)\n\
    \tat Problem.main(tmpi9xrkj9h.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def f(i : Long, l : List[Long]) : List[Long] = {\n            if (i ==\
    \ n) l\n            else if (i % 2 == 0) f(i + 1, l :+ 1 + i / 2)\n          \
    \  else f(i + 1, l :+ l(i.toInt - 1).toLong + l(i.toInt - 2).toLong + l(i.toInt\
    \ + 1).toLong)\n        }\n        f(1, List(1))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.f$1(tmp05l60fvd.scala:24)\n\tat Problem$.tri(tmp05l60fvd.scala:26)\n\
    \tat Problem$.main(tmp05l60fvd.scala:29)\n\tat Problem.main(tmp05l60fvd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var l = ListBuffer[Long]()\n        var t1 = 1l\n        var t2 = 3l\n\
    \        var t3 = 2l\n        l += t1\n        l += t2\n        l += t3\n    \
    \    for (i <- 1l to n - 2) {\n            val t4 = if (i % 2 == 0) 1 + i / 2\
    \ else t1 + t2 + t3\n            l += t4\n            t1 = t2\n            t2\
    \ = t3\n            t3 = t4\n        }\n        l.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_p44ezsx.scala:38)\n\tat Problem.main(tmp_p44ezsx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979590
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You may also need to define\
    \ some auxillary functions or classes\n        if (n == 1) List(1)\n        else\
    \ if (n == 2) List(1, 3)\n        else if (n == 3) List(1, 3, 2)\n        else\
    \ {\n        \tval c = tri(n - 1)\n        \tc.+((if (n % 2 == 0) c(n.toInt -\
    \ 1) + c(n.toInt - 2) + c(n.toInt + 1) else 1 + n / 2))\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjdufjpo1.scala:28:10 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \tc.+((\e[33mif\e[0m (n % \e[31m2\e[0m == \e\
    [31m0\e[0m) c(n.toInt - \e[31m1\e[0m) + c(n.toInt - \e[31m2\e[0m) + c(n.toInt\
    \ + \e[31m1\e[0m) \e[33melse\e[0m \e[31m1\e[0m + n / \e[31m2\e[0m))\n\e[31m\e\
    [31m   |\e[0m        \t^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979589
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val memo = new Array[Long](n.toInt + 1)\n        def triHelper(m : Long)\
    \ : Long = {\n            if (m == 1) 1\n            else if (m == 2) 3\n    \
    \        else if (m == 3) 2\n            else if (memo(m.toInt) != 0) memo(m.toInt)\n\
    \            else {\n                val value = if (m % 2 == 0) 1 + m / 2\n \
    \               else triHelper(m - 1) + triHelper(m - 2) + triHelper(m + 1)\n\
    \                memo(m.toInt) = value\n                value\n            }\n\
    \        }\n        (1 to n.toInt).map(m => triHelper(m)).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpilobeve7.scala:37)\n\tat Problem.main(tmpilobeve7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979590
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def loop(l : List[Long], n : Long) : List[Long] = {\n            if (n\
    \ == 0) l\n            else if (n % 2 == 0) loop(1 + n / 2 :: l, n - 1)\n    \
    \        else loop(l.head + l.tail.head + l.tail.tail.head :: l, n - 1)\n    \
    \    }\n        loop(List(3), n).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.loop$1(tmp50tddsvm.scala:24)\n\
    \tat Problem$.tri(tmp50tddsvm.scala:26)\n\tat Problem$.main(tmp50tddsvm.scala:29)\n\
    \tat Problem.main(tmp50tddsvm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979591
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var t = ArrayBuffer[Long]()\n        for (i <- 0 to n.toInt) {\n    \
    \        if (i == 0) t += 1\n            else if (i == 1) t += 3\n           \
    \ else if (i == 2) t += 2\n            else if (i % 2 == 0) t += (1 + i / 2)\n\
    \            else t += (t(i - 1) + t(i - 2) + t(i + 1))\n        }\n        return\
    \ t.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4 is out of bounds (min 0, max 2)\n\
    \tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:99)\n\tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:43)\n\
    \tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\
    \tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\tat Problem$.tri$$anonfun$1(tmpsl5tku8o.scala:27)\n\
    \tat Problem$.tri$$anonfun$adapted$1(tmpsl5tku8o.scala:28)\n\tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\
    \tat Problem$.tri(tmpsl5tku8o.scala:28)\n\tat Problem$.main(tmpsl5tku8o.scala:32)\n\
    \tat Problem.main(tmpsl5tku8o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var list = List[Long]()\n        var i = 1l\n        var a = 1l\n   \
    \     var b = 3l\n        var c = 2l\n        while (i <= n) {\n            list\
    \ = i match {\n                case 1 => list :+ a\n                case 2 =>\
    \ list :+ b\n                case 3 => list :+ c\n                case _ => list\
    \ :+ (a + b + c)\n            }\n            a = b\n            b = c\n      \
    \      c = list.last\n            i += 1\n        }\n        list\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdksmqsc9.scala:41)\n\tat Problem.main(tmpdksmqsc9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(1)\n        else {\n            val xs = tri(n - 1)\n\
    \            if (n % 2 == 0) xs :+ (1 + n / 2)\n            else xs :+ (xs(xs.length\
    \ - 1) + xs(xs.length - 2) + xs(xs.length - 3))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri(tmpt08miy70.scala:25)\n\tat Problem$.tri(tmpt08miy70.scala:23)\n\
    \tat Problem$.tri(tmpt08miy70.scala:23)\n\tat Problem$.main(tmpt08miy70.scala:29)\n\
    \tat Problem.main(tmpt08miy70.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def iter(curr : Long, n : Long, list : List[Long]) : List[Long] = {\n\
    \        \tif (curr > n) list\n        \telse if (curr == 1) {\n        \t\tlist\
    \ :+ 3l\n        \t} else if (curr % 2 == 0) {\n        \t\titer(curr + 1, n,\
    \ list :+ (1 + curr / 2))\n        \t} else {\n        \t\titer(curr + 1, n, list\
    \ :+ (list(curr.toInt - 1) + list(curr.toInt - 2) + list(curr.toInt + 1)))\n \
    \       \t}\n        }\n        iter(1, n, List[Long]())\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps_nkkqwp.scala:34)\n\tat Problem.main(tmps_nkkqwp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979591
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var tribonacci = new Array[Long](n.toInt + 1)\n        for (i <- 0 to\
    \ n.toInt) tribonacci(i) = 0\n        tribonacci(0) = 1\n        tribonacci(1)\
    \ = 3\n        tribonacci(2) = 2\n        if (n <= 2) return tribonacci.toList\n\
    \        for (i <- 3 to n.toInt) tribonacci(i) = if (i % 2 == 0) 1 + i / 2 else\
    \ tribonacci(i - 1) + tribonacci(i - 2) + tribonacci(i + 1)\n        return tribonacci.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$2(tmpvy482fd2.scala:27)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpvy482fd2.scala:27)\n\
    \tat Problem$.main(tmpvy482fd2.scala:31)\n\tat Problem.main(tmpvy482fd2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979593
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // `0` is the only invalid input\n\
    \        0L :: (1L to n).toList.map(i => {\n            if (i == 1) 3L else if\
    \ (i % 2 == 0) 1L + i / 2 else tri(i - 1) + tri(i - 2) + tri(i + 1)\n        })\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpga72am54.scala:24:75 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m (i == \e[31m1\e[0m) \e[31m3L\e\
    [0m \e[33melse\e[0m \e[33mif\e[0m (i % \e[31m2\e[0m == \e[31m0\e[0m) \e[31m1L\e\
    [0m + i / \e[31m2\e[0m \e[33melse\e[0m tri(i - \e[31m1\e[0m) + tri(i - \e[31m2\e\
    [0m) + tri(i + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                          \
    \                                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      var result = ListBuffer[Long]()\n      result += 1\n      result += 3\n\
    \      result += 2\n      var i = 3\n      while (i <= n) {\n        var v = result(i\
    \ - 1) + result(i - 2) + result(i - 3)\n        if (i % 2 == 0) v = 1 + i / 2\n\
    \        result += v\n        i += 1\n      }\n      result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwae4c37t.scala:35)\n\tat Problem.main(tmpwae4c37t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You may also need to define\
    \ some helper functions\n        val L = new ListBuffer[Long]\n        def tri_helper(n\
    \ : Long, x : Long, y : Long, z : Long) : List[Long] = {\n            if (n ==\
    \ 1) L += z\n            else {\n                if (n % 2 == 0) L += z\n    \
    \            else {\n                    val t = x + y + z\n                 \
    \   L += t\n                    tri_helper(n - 1, y, z, t)\n                }\n\
    \            }\n            L.toList\n        }\n        tri_helper(n, 1, 3, 2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_4j7frlq.scala:39)\n\tat Problem.main(tmp_4j7frlq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 1) throw new Exception(\"n has to be positive.\")\n        val\
    \ res = new ArrayBuffer[Long]\n        def triHelper(curr : Long, prev1 : Long,\
    \ prev2 : Long, prev3 : Long) : Unit = {\n            if (curr == n + 1) return\n\
    \            if (curr == 1) res += 1\n            else if (curr == 2) res += 3\n\
    \            else if (curr == 3) res += 2\n            else if (curr % 2 == 0)\
    \ res += curr / 2\n            else res += prev1 + prev2 + prev3\n           \
    \ triHelper(curr + 1, res(res.length - 1), res(res.length - 2), res(res.length\
    \ - 3))\n        }\n        triHelper(1, 0, 0, 0)\n        res.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1 is out of bounds (min 0, max 0)\n\
    \tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:98)\n\tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:43)\n\
    \tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\
    \tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\tat Problem$.triHelper$1(tmp_f7iao4b.scala:30)\n\
    \tat Problem$.tri(tmp_f7iao4b.scala:32)\n\tat Problem$.main(tmp_f7iao4b.scala:36)\n\
    \tat Problem.main(tmp_f7iao4b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979592
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(1l)\n        else if (n == 1) List(1l, 3l)\n       \
    \ else if (n == 2) List(1l, 3l, 2l)\n        else {\n            val a = 1l\n\
    \            val b = 3l\n            val c = 2l\n            List(a, b, c) :::\
    \ (for (i <- 3 to n.toInt) yield {\n                if (i % 2 == 0) (i / 2) +\
    \ 1\n                else a + b + c\n            }).toList\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpknucayk_.scala:28:12\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            List(a, b, c) :::\
    \ (\e[33mfor\e[0m (i <- \e[31m3\e[0m to n.toInt) \e[33myield\e[0m {\n\e[31m\e\
    [31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0m            Found:    List[\e\
    [1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m            Required: List[\e[1m\e[32mLong\e\
    [0m]\n\e[31m29 |\e[0m                \e[33mif\e[0m (i % \e[31m2\e[0m == \e[31m0\e\
    [0m) (i / \e[31m2\e[0m) + \e[31m1\e[0m\n\e[31m30 |\e[0m                \e[33melse\e\
    [0m a + b + c\n\e[31m31 |\e[0m            }).toList\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979592
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def get(i : Long) : Long = {\n            if (i == 1) 3 else if (i %\
    \ 2 == 0) 1 + i / 2 else get(i - 1) + get(i - 2) + get(i + 1)\n        }\n   \
    \     if (n == 0) List[Long]() else (1 to n.toInt).map(i => get(i)).toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfdkwrhh.scala:27)\n\tat Problem.main(tmpnfdkwrhh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        null\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.tri(long)\" is null\n\tat Problem$.main(tmps8mnjx4i.scala:24)\n\
    \tat Problem.main(tmps8mnjx4i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Solution 1: use recursion\n        // def calculate(i : Long) : Long\
    \ = {\n        //     val base = 2l\n        //     if (i == 1) 3l\n        //\
    \     else if (i == base) 1l + i / base\n        //     else if (i == base + 1)\
    \ 1l + (base + 1) / base\n        //     else if (i % 2 == 0) {\n        //  \
    \       calculate(i - 1) + calculate(i - 2) + calculate(i + 1)\n        //   \
    \  } else {\n        //         1l + i / base\n        //     }\n        // }\n\
    \        // val result = new ListBuffer[Long]\n        // for (i <- 1 to n.toInt)\
    \ {\n        //     result += calculate(i)\n        // }\n        // result.toList\n\
    \        // Solution 2: use memoization\n        def calculate(i : Long) : Long\
    \ = {\n            val base = 2l\n            if (i == 1) 3l\n            else\
    \ if (i == base) 1l + i / base\n            else if (i == base + 1) 1l + (base\
    \ + 1) / base\n            else if (i % 2 == 0) {\n                calculate(i\
    \ - 1) + calculate(i - 2) + calculate(i + 1)\n            } else {\n         \
    \       1l + i / base\n            }\n        }\n        val cache = new HashMap[Long,\
    \ Long]\n        cache(1) = 3l\n        cache(2) = 1l + (2l / 2l)\n        cache(3)\
    \ = 1l + (3l / 2l)\n        def get(i : Long) : Long = {\n            if (cache.contains(i))\
    \ cache(i)\n            else {\n                val result = calculate(i)\n  \
    \              cache(i) = result\n                result\n            }\n    \
    \    }\n        val result = new ListBuffer[Long]\n        for (i <- 1 to n.toInt)\
    \ {\n            result += get(i)\n        }\n        result.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaumhpzyn.scala:69)\n\tat Problem.main(tmpaumhpzyn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triIter(n : Long, x : Long, y : Long, z : Long, acc : List[Long])\
    \ : List[Long] = {\n            if (n == 0) acc.reverse\n            else {\n\
    \                if (n % 2 == 0) triIter(n - 1, x, y, z, (x + y + z) :: acc)\n\
    \                else triIter(n - 1, x, y, z, (1 + n / 2) :: acc)\n          \
    \  }\n        }\n        triIter(n, 1, 3, 2, List())\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps0i1azje.scala:31)\n\tat Problem.main(tmps0i1azje.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var lst = ListBuffer(1l, 3l, 2l)\n        for (i <- 3l to n) {\n    \
    \        if (i % 2 == 0) lst += (1 + i / 2)\n            else lst += (lst(i.toInt\
    \ - 1) + lst(i.toInt - 2) + lst(i.toInt + 1))\n        }\n        lst.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpc8feta34.scala:24)\n\tat Problem$.tri$$anonfun$adapted$1(tmpc8feta34.scala:25)\n\
    \tat scala.collection.immutable.NumericRange.foreach(NumericRange.scala:115)\n\
    \tat Problem$.tri(tmpc8feta34.scala:25)\n\tat Problem$.main(tmpc8feta34.scala:29)\n\
    \tat Problem.main(tmpc8feta34.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat d"
  stdout: ''
  timestamp: 1659979593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        var list = new ListBuffer[Long]()\n        list\
    \ += 1\n        for (i <- 1 to n.toInt) {\n            if (i == 1) list += 3\n\
    \            else if (i % 2 == 0) list += (1 + i / 2)\n            else list +=\
    \ (list(i - 1) + list(i - 2) + list(i + 1))\n        }\n        list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpa4tagbps.scala:28)\n\tat Problem$.tri$$anonfun$adapted$1(tmpa4tagbps.scala:29)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpa4tagbps.scala:29)\n\
    \tat Problem$.main(tmpa4tagbps.scala:33)\n\tat Problem.main(tmpa4tagbps.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Mai"
  stdout: ''
  timestamp: 1659979593
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var i = 0l\n        var result = new ListBuffer[Long]\n        while\
    \ (i <= n) {\n            result += solve(i)\n            i += 1\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc8pd3dxw.scala:24:22 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            result += solve(i)\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ solve\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979589
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tval s = new Array[Long](n.toInt + 1)\n    \tfor (i <- 1 to n.toInt) {\n\
    \    \t\tif (i == 1) s(i) = 3\n    \t\telse if (i == 2) s(i) = 1\n    \t\telse\
    \ if (i == 3) s(i) = 2\n    \t\telse if (i % 2 == 0) s(i) = 1 + i / 2\n    \t\t\
    else s(i) = s(i - 1) + s(i - 2) + s(i + 1)\n    \t}\n    \ts.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3d04j6tn.scala:32)\n\tat Problem.main(tmp3d04j6tn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triR(n : Long, a : Long, b : Long, c : Long) : List[Long] = {\n \
    \           if (n == 0) Nil\n            else if (n == 1) List(a)\n          \
    \  else if (n == 2) List(a, b)\n            else if (n == 3) List(a, b, c)\n \
    \           else if (n % 2 == 0) {\n                val nn = n / 2\n         \
    \       val next = a + b + c + nn\n                next :: triR(n - 1, b, c, next)\n\
    \            } else {\n                val next = a + b + c\n                next\
    \ :: triR(n - 1, b, c, next)\n            }\n        }\n        triR(n, 1, 3,\
    \ 2)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7mbd0pqh.scala:38)\n\tat Problem.main(tmp7mbd0pqh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979594
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      ???\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.tri(tmpdkr4ocv3.scala:21)\n\tat Problem$.main(tmpdkr4ocv3.scala:24)\n\
    \tat Problem.main(tmpdkr4ocv3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979600
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(1)\n        else if (n == 1) List(1, 3)\n        else\
    \ if (n == 2) List(1, 3, 2)\n        else {\n            val list = tri(n - 1)\n\
    \            val m = list(list.length - 1)\n            val k = list(list.length\
    \ - 2)\n            val j = list(list.length - 3)\n            val result = List(m\
    \ + k + j)\n            list ::: result\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0t9uoj6z.scala:34)\n\tat Problem.main(tmp0t9uoj6z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979600
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var a = 1.toLong\n        var b = 3.toLong\n        var c = 2.toLong\n\
    \        var d = 0.toLong\n        var res = List[Long]()\n        for (i <- 1\
    \ to n.toInt) {\n            if (i % 2 == 0) d = a + i / 2\n            else d\
    \ = a + b + c\n            res = res :+ d\n            a = b\n            b =\
    \ c\n            c = d\n        }\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpko5k_z4r.scala:37)\n\tat Problem.main(tmpko5k_z4r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979601
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val a = new Array[Long](n.toInt + 1)\n        a(0) = 1\n        a(1)\
    \ = 3\n        for (i <- 2 to n.toInt) {\n            if (i % 2 == 0) a(i) = 1\
    \ + i / 2\n            else a(i) = a(i - 1) + a(i - 2) + a(i + 1)\n        }\n\
    \        a.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmppxzs_7ic.scala:26)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmppxzs_7ic.scala:27)\n\
    \tat Problem$.main(tmppxzs_7ic.scala:31)\n\tat Problem.main(tmppxzs_7ic.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979602
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(1)\n        else if (n == 1) List(1, 3)\n        else\
    \ if (n == 2) List(1, 3, 2)\n        else List(1, 3, 2) ::: (1l to n).map(i =>\
    \ {\n        \tif (i % 2 == 0) i / 2\n        \telse tri(i - 1).last + tri(i -\
    \ 2).last + tri(i + 1).last\n        }).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.math.Numeric$LongIsIntegral$.compare(Numeric.scala:139)\n\
    \tat scala.math.Numeric$LongIsIntegral$.compare(Numeric.scala:139)\n\tat scala.math.Ordering.lt(Ordering.scala:98)\n\
    \tat scala.math.Ordering.lt$(Ordering.scala:98)\n\tat scala.math.Numeric$LongIsIntegral$.lt(Numeric.scala:139)\n\
    \tat scala.collection.immutable.NumericRange$.count(NumericRange.scala:288)\n\t\
    at scala.collection.immutable.NumericRange.length$lzycompute(NumericRange.scala:75)\n\
    \tat scala.collection.immutable.NumericRange.length(NumericRange.scala:75)\n\t\
    at scala.collection.immutable.NumericRange.last(NumericRange.scala:83)\n\tat scala.collection.immutable.NumericRange$NumericRangeIterator.<init>(NumericRange.scala:421)\n\
    \tat scala.collection.immutable.NumericRange.iterator(NumericRange.scala:55)\n\
    \tat scala.collection.StrictOptimizedIterableOps.map(StrictOptimizedIterableOps.scala:98)\n\
    \tat scala.collection.StrictOptimizedIterableOps.map$(StrictOptimizedIterableOps.scala:87)\n\
    \tat scala.collection.immutable.NumericRange.map(NumericRange.scala:40)\n\tat\
    \ Problem$.tri(tmpg4jqaxvp.scala:27)\n\tat Problem$.tri$$anonfun$1(tmpg4jqaxvp.scala:26)\n\
    \tat scala.runtime.java8.JFunction1$mcJJ$sp.apply(JFunction1$mcJJ$sp.scala:17)\n\
    \tat scala.collection.StrictOptimizedIterableOps.map(StrictOptimizedIterableOps.scala:100)\n\
    \tat scala.collection.StrictOptimizedIterableOps.map$(StrictOptimizedIterableOps.scala:87)\n\
    \tat scala.collection.immutable.NumericRange.map(NumericRange.scala:40)\n\tat\
    \ Problem$.tri(tmpg4jqaxvp.scala:27)\n\tat Problem$.tri$$anonfun$1(tmpg4jqaxvp.scala:26)\n\
    \tat scala.runtime.java8.JFunction1$mcJJ$sp.apply(JFunction1$mcJJ$sp.scala:17)\n\
    \tat scala.collection.StrictOptimizedIterableOps.map(StrictOptimizedIterableOps.scala:100)\n\
    \tat scala.collection.StrictOptimizedIterableOps.map$(StrictOptimizedIterableOps.scala:87)\n\
    \tat scala.collection.immutable.NumericRange.map(NumericRange.scala:40)\n\tat\
    \ Problem$.tri(tmpg4jqaxvp.scala:27)\n\tat Problem$.tri$$anonfun$1(tmpg4jqaxvp.scala:26)\n\
    \tat scala.runtime.java8.JFunction1$mcJJ$sp.apply(JFun"
  stdout: ''
  timestamp: 1659979603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(1)\n        else if (n == 1) List(1, 3)\n        else\
    \ if (n == 2) List(1, 3, 2)\n        else List(1, 3, 2) ::: recursiveTri(n - 2,\
    \ 2, 1, 3)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8hiy419g.scala:24:31 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m List(\e[31m1\e[0m, \e[31m3\e\
    [0m, \e[31m2\e[0m) ::: recursiveTri(n - \e[31m2\e[0m, \e[31m2\e[0m, \e[31m1\e\
    [0m, \e[31m3\e[0m)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Not found: recursiveTri\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979598
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        var result = new ListBuffer[Long]()\n        result\
    \ += 1\n        result += 3\n        for (i <- 2 to n.toInt) {\n            if\
    \ (i % 2 == 0) result += (1 + i / 2)\n            else result += (result(i - 1)\
    \ + result(i - 2) + result(i + 1))\n        }\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmp4jueonv_.scala:28)\n\tat Problem$.tri$$anonfun$adapted$1(tmp4jueonv_.scala:29)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp4jueonv_.scala:29)\n\
    \tat Problem$.main(tmp4jueonv_.scala:33)\n\tat Problem.main(tmp4jueonv_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Mai"
  stdout: ''
  timestamp: 1659979603
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var triList = new ListBuffer[Long]\n        triList += 1l\n        triList\
    \ += 3l\n        for (i <- 2l to n) {\n            if (i % 2 == 0) {\n       \
    \         triList += (1 + i / 2)\n            } else {\n                triList\
    \ += (triList(i.toInt - 1) + triList(i.toInt - 2) + triList(i.toInt + 1))\n  \
    \          }\n        }\n        triList.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpwxgrzwtx.scala:28)\n\tat Problem$.tri$$anonfun$adapted$1(tmpwxgrzwtx.scala:30)\n\
    \tat scala.collection.immutable.NumericRange.foreach(NumericRange.scala:115)\n\
    \tat Problem$.tri(tmpwxgrzwtx.scala:30)\n\tat Problem$.main(tmpwxgrzwtx.scala:34)\n\
    \tat Problem.main(tmpwxgrzwtx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat d"
  stdout: ''
  timestamp: 1659979603
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def trib(n : Long, tri : Array[Long]) : Array[Long] = {\n           \
    \ if (n < 1) {\n                return tri\n            }\n            else {\n\
    \                if (n % 2 == 0) {\n                    tri(n.toInt) = 1 + n /\
    \ 2\n                }\n                else {\n                    tri(n.toInt)\
    \ = tri(n.toInt - 1) + tri(n.toInt - 2) + tri(n.toInt + 1)\n                }\n\
    \                trib(n - 1, tri)\n            }\n        }\n        trib(n, Array.fill(n.toInt\
    \ + 1)(0l)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.trib$1(tmpf4puqmy5.scala:30)\n\tat Problem$.tri(tmpf4puqmy5.scala:35)\n\
    \tat Problem$.main(tmpf4puqmy5.scala:38)\n\tat Problem.main(tmpf4puqmy5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979603
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri1(a : Long, b : Long, c : Long, n : Long) : List[Long] = {\n \
    \           if (n == 0) {\n                List(c)\n            } else {\n   \
    \             c :: tri1(b, c, \n                    if (n % 2 == 0) {\n      \
    \                  1 + n / 2\n                    } else {\n                 \
    \       a + b + c\n                    }, n - 1)\n            }\n        }\n \
    \       tri1(0, 1, 3, n)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0qwae135.scala:36)\n\tat Problem.main(tmp0qwae135.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Good Luck!\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpon4rctk6.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m    \e[33mdef\e[0m \e[36mtri\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e\
    [31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m\
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                             Required: List[Long]\n\e[31m21 |\e[0m        \e\
    [34m// Good Luck!\e[0m\n\e[31m22 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979601
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var l = new ListBuffer[Long]()\n        l += 1\n        l += 3\n    \
    \    for (i <- 2 to n.toInt) {\n            if (i % 2 == 0) l += (1 + i / 2)\n\
    \            else l += (l(i - 1) + l(i - 2) + l(i + 1))\n        }\n        l.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpr6bo4pjd.scala:26)\n\tat Problem$.tri$$anonfun$adapted$1(tmpr6bo4pjd.scala:27)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpr6bo4pjd.scala:27)\n\
    \tat Problem$.main(tmpr6bo4pjd.scala:31)\n\tat Problem.main(tmpr6bo4pjd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Mai"
  stdout: ''
  timestamp: 1659979604
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val result = ListBuffer[Long]()\n        var a = 1l\n        var b =\
    \ 3l\n        var c = 2l\n        var d = a + b + c\n        result += a\n   \
    \     result += b\n        result += c\n        result += d\n        while (result.length\
    \ < n + 1) {\n            a = b\n            b = c\n            c = d\n      \
    \      d = a + b + c\n            result += d\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyrsh_awq.scala:40)\n\tat Problem.main(tmpyrsh_awq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979603
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tvar cache = new HashMap[Long, Long]\n    \tcache(1) = 3\n    \tdef getTri(n\
    \ : Long) : Long = {\n    \t\tif (cache.contains(n)) cache(n)\n    \t\telse {\n\
    \    \t\t\tval v = if (n % 2 == 0) 1 + n / 2 else getTri(n - 1) + getTri(n - 2)\
    \ + getTri(n + 1)\n    \t\t\tcache(n) = v\n    \t\t\tv\n    \t\t}\n    \t}\n \
    \   \t(1 to n.toInt).map(x => getTri(x)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpghnqboz2.scala:34)\n\tat Problem.main(tmpghnqboz2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979604
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Solution 1: use 3 recursions\n        def helper(i : Long, x : Long,\
    \ y : Long, z : Long) : List[Long] = {\n            if (i == n) List(x, y, z)\n\
    \            else if (i % 2 == 0) helper(i + 1, x, y, z) ::: List(1 + i / 2)\n\
    \            else helper(i + 1, x, y, z) ::: List(helper(i + 1, x, y, z).takeRight(3).sum)\n\
    \        }\n        if (n < 3) List(1)\n        else helper(2, 1, 3, 2)\n    \
    \    // Solution 2: use recursion and ArrayBuffer\n        def helper(n : Long)\
    \ : ArrayBuffer[Long] = {\n            if (n == 1) ArrayBuffer(1)\n          \
    \  else if (n == 2) ArrayBuffer(1, 3)\n            else if (n == 3) ArrayBuffer(1,\
    \ 3, 2)\n            else {\n                val list = helper(n - 1)\n      \
    \          list += if (n % 2 == 0) 1 + n / 2 else list.takeRight(3).sum\n    \
    \            list\n            }\n        }\n        helper(n).toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_i_k_k1_.scala:36:24 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                list += \e[33mif\e[0m (n % \e[31m2\e\
    [0m == \e[31m0\e[0m) \e[31m1\e[0m + n / \e[31m2\e[0m \e[33melse\e[0m list.takeRight(\e\
    [31m3\e[0m).sum\n\e[31m\e[31m   |\e[0m                        ^^\e[0m\n\e[31m\
    \   |\e[0m                        expression expected but \e[31mif\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp_i_k_k1_.scala:35:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mval\e[0m \e[36mlist\e[0m = helper(n\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter x of \e[33mmethod\e[0m \e[35mhelper\e\
    [0m: (i: Long, x: Long, y: Long, z: Long): List[Long]\n\e[31m\e[31m-- Error: /tmp/tmp_i_k_k1_.scala:40:14\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m40 |\e[0m       \
    \ helper(n).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmissing argument for parameter x of \e[33mmethod\e[0m \e[35mhelper\e[0m: (i:\
    \ Long, x: Long, y: Long, z: Long): List[Long]\n3 errors found\n"
  stdout: ''
  timestamp: 1659979602
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        ???\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.tri(tmp1l2_wldc.scala:21)\n\tat Problem$.main(tmp1l2_wldc.scala:24)\n\
    \tat Problem.main(tmp1l2_wldc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        n match {\n            case x if x < 0 => throw new IllegalArgumentException\n\
    \            case 0 => List[Long](1)\n            case 1 => List[Long](1, 3)\n\
    \            case 2 => List[Long](1, 3, 2)\n            case _ => {\n        \
    \        var l = List[Long](1, 3, 2)\n                for (i <- 4l to n) {\n \
    \                   if (i % 2 == 0) l = l :+ (1 + i / 2)\n                   \
    \ else l = l :+ (l(l.length - 1) + l(l.length - 2) + l(l.length - 3))\n      \
    \          }\n                l\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcswm7cww.scala:37)\n\tat Problem.main(tmpcswm7cww.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979604
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) return List[Long](1)\n        val r = tri(n - 1)\n      \
    \  r :+ (if (n % 2 == 0) (1 + n / 2) else (r(r.length - 3) + r(r.length - 2) +\
    \ r(r.length - 1)))\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri(tmp11g7pmz_.scala:23)\n\tat Problem$.tri(tmp11g7pmz_.scala:22)\n\
    \tat Problem$.tri(tmp11g7pmz_.scala:22)\n\tat Problem$.main(tmp11g7pmz_.scala:26)\n\
    \tat Problem.main(tmp11g7pmz_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979603
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      var current = List[Long](1l, 3l, 2l)\n      if (n <= 2) return current.slice(0,\
    \ n.toInt + 1)\n      else {\n        while (current.length <= n.toInt) {\n  \
    \        if (current.length % 2 == 0) current = current :+ (current.length / 2\
    \ + 1)\n          else current = current :+ (current(current.length - 1) + current(current.length\
    \ - 2) + current(current.length - 3))\n        }\n        return current\n   \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp80aha8lj.scala:32)\n\tat Problem.main(tmp80aha8lj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979604
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // 'n' is the number of first\
    \ numbers of the Tribonacci sequence.\n        // Return a list of Long type.\n\
    \        if (n < 1) return List()\n        var l : List[Long] = List()\n     \
    \   l = l :+ 1\n        if (n == 1) return l\n        l = l :+ 3\n        if (n\
    \ == 2) return l\n        l = l :+ 2\n        for (i <- 3 to n.toInt) {\n    \
    \        if (i % 2 == 0) l = l :+ (1 + i / 2)\n            else l = l :+ (l(i\
    \ - 1) + l(i - 2) + l(i + 1))\n        }\n        return l\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$$anonfun$1(tmp8udi85dq.scala:33)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp8udi85dq.scala:34)\n\
    \tat Problem$.main(tmp8udi85dq.scala:38)\n\tat Problem.main(tmp8udi85dq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979604
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var arr = ArrayBuffer[Long]()\n        arr += 1\n        arr += 3\n \
    \       arr += 2\n        for (i <- 3 to n.toInt) {\n            if (i % 2 ==\
    \ 0) {\n                arr += (1 + i / 2)\n            } else {\n           \
    \     arr += (arr(i - 1) + arr(i - 2) + arr(i + 1))\n            }\n        }\n\
    \        arr.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4 is out of bounds (min 0, max 2)\n\
    \tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:99)\n\tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:43)\n\
    \tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\
    \tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\tat Problem$.tri$$anonfun$1(tmp4vs8rtb9.scala:29)\n\
    \tat Problem$.tri$$anonfun$adapted$1(tmp4vs8rtb9.scala:31)\n\tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\
    \tat Problem$.tri(tmp4vs8rtb9.scala:31)\n\tat Problem$.main(tmp4vs8rtb9.scala:35)\n\
    \tat Problem.main(tmp4vs8rtb9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979604
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) return List(1l)\n        var tri = List(1l, 3l)\n       \
    \ var i = 1\n        while (i < n) {\n            val next = if (i % 2 == 0) (1\
    \ + (i / 2)) else tri(i - 1) + tri(i - 2) + tri(i + 1)\n            tri = tri\
    \ :+ next\n            i += 1\n        }\n        tri\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpongk2kbz.scala:26:25\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            tri = tri :+ next\n\
    \e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                    Found:    (next : AnyVal)\n\e[31m   |\e[0m              \
    \           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979603
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def trii(n : Long, acc : List[Long]) : List[Long] = n match {\n     \
    \       case 0 => acc\n            case _ => if (n % 2 == 0) trii(n - 1, acc :+\
    \ (1 + n / 2)) else trii(n - 1, acc :+ (acc(acc.length - 1) + acc(acc.length -\
    \ 2) + acc(acc.length - 3)))\n        }\n        trii(n, List[Long](1, 3, 2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv4e9l0s9.scala:28)\n\tat Problem.main(tmpv4e9l0s9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979604
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var result = List[Long]()\n        if (n < 0) return result\n       \
    \ for (i <- 0l to n) {\n            if (i == 0) result = result :+ 1\n       \
    \     else if (i == 1) result = result :+ 3\n            else if (i == 2) result\
    \ = result :+ 2\n            else if (i % 2 == 0) result = result :+ (1 + i /\
    \ 2)\n            else result = result :+ (result(i.toInt - 1) + result(i.toInt\
    \ - 2) + result(i.toInt + 1))\n        }\n        return result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$$anonfun$1(tmpldm3ik9w.scala:28)\n\tat scala.runtime.java8.JFunction1$mcVJ$sp.apply(JFunction1$mcVJ$sp.scala:18)\n\
    \tat scala.collection.immutable.NumericRange.foreach(NumericRange.scala:115)\n\
    \tat Problem$.tri(tmpldm3ik9w.scala:29)\n\tat Problem$.main(tmpldm3ik9w.scala:33)\n\
    \tat Problem.main(tmpldm3ik9w.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979606
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Your code goes here.\n        // TODO: code it.\n        val seq =\
    \ List[Long](1, 3, 2)\n        val k = ceil(log(n + 1) / log(2))\n        val\
    \ a = List[Long](1, 3, 2)\n        var b = List[Long](1, 3, 2)\n        for (i\
    \ <- 0 until (k.toInt - 2)) {\n            val b0 = b(0) + b(1) + b(2)\n     \
    \       val b1 = b(1) + b(2) + b0\n            val b2 = b(2) + b0 + b1\n     \
    \       b = List[Long](b0, b1, b2)\n        }\n        val z = if (n < 3) 3 else\
    \ pow(2, k.toInt).toLong - 2 + (if (n % 2 == 0) n / 2 else n)\n        a ++ b\
    \ ++ List[Long](z)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpadydsyme.scala:37)\n\tat Problem.main(tmpadydsyme.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var cache = new Array[Long](n.toInt + 1)\n        cache(0) = 1\n    \
    \    cache(1) = 3\n        cache(2) = 2\n        def f(k : Int) : Long = {\n \
    \           if (cache(k) != 0) cache(k)\n            else {\n                if\
    \ (k % 2 == 0) cache(k) = (1 + k / 2)\n                else cache(k) = f(k - 1)\
    \ + f(k - 2) + f(k + 1)\n                cache(k)\n            }\n        }\n\
    \        for (i <- 0 to n.toInt) f(i)\n        cache.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.f$1(tmpy4y9jaqg.scala:26)\n\tat Problem$.f$1(tmpy4y9jaqg.scala:29)\n\
    \tat Problem$.tri$$anonfun$1(tmpy4y9jaqg.scala:33)\n\tat scala.runtime.java8.JFunction1$mcJI$sp.apply(JFunction1$mcJI$sp.scala:17)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpy4y9jaqg.scala:33)\n\
    \tat Problem$.main(tmpy4y9jaqg.scala:37)\n\tat Problem.main(tmpy4y9jaqg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) return List(1)\n        else if (n == 1) return List(1, 3)\n\
    \        else if (n == 2) return List(1, 3, 2)\n        var l = List(1l, 3l, 2l)\n\
    \        for (i <- 3l to n) {\n            if (i % 2 == 0) l = (1 + i / 2) ::\
    \ l\n            else l = (l(0) + l(1) + l(2)) :: l\n        }\n        return\
    \ l.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpek0qf8w1.scala:32)\n\tat Problem.main(tmpek0qf8w1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979612
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri_helper(n : Long, ls : List[Long]) : List[Long] = {\n        \
    \    if (n == 0) return ls\n            val x = if (n % 2 == 0) 1 + n / 2 else\
    \ ls(ls.length - 3) + ls(ls.length - 2) + ls(ls.length - 1)\n            tri_helper(n\
    \ - 1, ls :+ x)\n        }\n        tri_helper(n, List[Long](1))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri_helper$1(tmp_uq6fr7o.scala:23)\n\tat Problem$.tri(tmp_uq6fr7o.scala:26)\n\
    \tat Problem$.main(tmp_uq6fr7o.scala:29)\n\tat Problem.main(tmp_uq6fr7o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979611
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var l = ListBuffer[Long]()\n        var r = (1l to n).toList\n      \
    \  r.foreach(x => l += (\n            if (x == 1) {\n                3\n     \
    \       } else if (x % 2 == 0) {\n                1 + x / 2\n            } else\
    \ {\n                l(x.toInt - 2) + l(x.toInt - 1) + l(x.toInt + 1)\n      \
    \      }\n        ))\n        l.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpsph3dvqj.scala:29)\n\tat Problem$.tri$$anonfun$adapted$1(tmpsph3dvqj.scala:31)\n\
    \tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat Problem$.tri(tmpsph3dvqj.scala:31)\n\
    \tat Problem$.main(tmpsph3dvqj.scala:35)\n\tat Problem.main(tmpsph3dvqj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainG"
  stdout: ''
  timestamp: 1659979613
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var r = ArrayBuffer[Long]()\n        r += 1\n        if (n >= 1) r +=\
    \ 3\n        if (n >= 2) r += 2\n        for (i <- 3 to n.toInt) {\n         \
    \   if (i % 2 == 0) r += (1 + i / 2)\n            else r += (r(i - 1) + r(i -\
    \ 2) + r(i + 1))\n        }\n        r.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4 is out of bounds (min 0, max 2)\n\
    \tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:99)\n\tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:43)\n\
    \tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\
    \tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\tat Problem$.tri$$anonfun$1(tmph_0wf4xh.scala:27)\n\
    \tat Problem$.tri$$anonfun$adapted$1(tmph_0wf4xh.scala:28)\n\tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\
    \tat Problem$.tri(tmph_0wf4xh.scala:28)\n\tat Problem$.main(tmph_0wf4xh.scala:32)\n\
    \tat Problem.main(tmph_0wf4xh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val res = Array.fill(n.toInt + 1)(0l)\n        res(0) = 1\n        res(1)\
    \ = 3\n        res(2) = 2\n        for (i <- 3 to n.toInt) {\n            if (i\
    \ % 2 == 0) res(i) = 1 + i / 2\n            else res(i) = res(i - 1) + res(i -\
    \ 2) + res(i + 1)\n        }\n        res.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmp7wlzwy4d.scala:27)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp7wlzwy4d.scala:28)\n\
    \tat Problem$.main(tmp7wlzwy4d.scala:32)\n\tat Problem.main(tmp7wlzwy4d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979614
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        n match {\n            case 0 => List[Long](1)\n            case 1 =>\
    \ List[Long](1, 3)\n            case 2 => List[Long](1, 3, 2)\n            case\
    \ _ => {\n                val prev = tri(n - 1)\n                val a = prev(n.toInt\
    \ - 1)\n                val b = prev(n.toInt - 2)\n                val c = prev(n.toInt\
    \ - 3)\n                val d = if (n % 2 == 0) 1 + n / 2 else a + b + c\n   \
    \             prev :+ d\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvpxzb5e8.scala:36)\n\tat Problem.main(tmpvpxzb5e8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979614
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triAcc(iter : Long, list : List[Long]) : List[Long] = {\n       \
    \     if (iter > n) list\n            else {\n                if (iter == 1) triAcc(iter\
    \ + 1, list :+ 3)\n                else if (iter % 2 == 0) triAcc(iter + 1, list\
    \ :+ (1 + iter / 2))\n                else triAcc(iter + 1, list :+ (list(iter.toInt\
    \ - 1) + list(iter.toInt - 2) + list(iter.toInt + 1)))\n            }\n      \
    \  }\n        triAcc(1, List())\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.triAcc$1(tmp4c4wh231.scala:26)\n\tat Problem$.tri(tmp4c4wh231.scala:29)\n\
    \tat Problem$.main(tmp4c4wh231.scala:32)\n\tat Problem.main(tmp4c4wh231.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979614
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var result = new ListBuffer[Long]\n        var a = 1l\n        var b\
    \ = 3l\n        var c = 2l\n        result += a\n        result += b\n       \
    \ result += c\n        while (result.length < n + 1) {\n            result +=\
    \ a + b + c\n            a = b\n            b = c\n            c = result.last\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_qd52z64.scala:37)\n\tat Problem.main(tmp_qd52z64.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979614
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      var l = new ListBuffer[Long]()\n      l += 1\n      l += 3\n      var t\
    \ = 1\n      if (n >= 2) {\n        l += 2\n        t = 2\n      }\n      while\
    \ (t < n) {\n        var tmp = l(l.length - 1) + l(l.length - 2) + l(l.length\
    \ - 3)\n        l += tmp\n        t += 1\n      }\n      l.toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv1o3max0.scala:37)\n\tat Problem.main(tmpv1o3max0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979614
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var index = 1\n        var trib = ListBuffer[Long]()\n        trib +=\
    \ 1\n        trib += 3\n        trib += 2\n        while (index < n) {\n     \
    \       if (index % 2 == 0) {\n                trib += (1 + index / 2)\n     \
    \       } else {\n                trib += (trib(index - 1) + trib(index - 2) +\
    \ trib(index + 1))\n            }\n            index += 1\n        }\n       \
    \ trib.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri(tmp067s_9ss.scala:30)\n\tat Problem$.main(tmp067s_9ss.scala:37)\n\
    \tat Problem.main(tmp067s_9ss.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979614
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var result = List[Long]()\n        if (n >= 1) result = List[Long](1l.toLong)\n\
    \        if (n >= 2) result = List[Long](1l.toLong, 3l.toLong)\n        if (n\
    \ >= 3) result = List[Long](1l.toLong, 3l.toLong, 2l.toLong)\n        for (i <-\
    \ 3l to n) {\n            val v = if (i % 2 == 0) 1 + i / 2 else result(i.toInt\
    \ - 1) + result(i.toInt - 2) + result(i.toInt + 1)\n            result = result\
    \ :+ v\n        }\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$$anonfun$1(tmpb18qmbeg.scala:26)\n\tat scala.runtime.java8.JFunction1$mcVJ$sp.apply(JFunction1$mcVJ$sp.scala:18)\n\
    \tat scala.collection.immutable.NumericRange.foreach(NumericRange.scala:115)\n\
    \tat Problem$.tri(tmpb18qmbeg.scala:28)\n\tat Problem$.main(tmpb18qmbeg.scala:32)\n\
    \tat Problem.main(tmpb18qmbeg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val ans = new ListBuffer[Long]\n        ans += 1\n        ans += 3\n\
    \        if (n == 1) return ans.toList\n        ans += 2\n        if (n == 2)\
    \ return ans.toList\n        ans += 8\n        if (n == 3) return ans.toList\n\
    \        for (i <- 1 to n - 3) {\n            ans += ans(ans.length - 3) + ans(ans.length\
    \ - 2) + ans(ans.length - 1)\n        }\n        ans.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyqk7zjh4.scala:29:23\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m1\e[0m to n - \e[31m3\e[0m) {\n\e[31m\e[31m   |\e[0m                 \
    \      ^^^^^\e[0m\n\e[31m   |\e[0m                       Found:    Long\n\e[31m\
    \   |\e[0m                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979613
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You may also define new functions\
    \ as you wish\n        val map = new HashMap[Long, Long]\n        map(1) = 3\n\
    \        def get(n : Long) : Long = {\n            if (map.contains(n)) {\n  \
    \              map(n)\n            } else {\n                if (n % 2 == 0) {\n\
    \                    val tri = 1 + n / 2\n                    map(n) = tri\n \
    \                   tri\n                } else {\n                    val tri\
    \ = get(n - 1) + get(n - 2) + get(n + 1)\n                    map(n) = tri\n \
    \                   tri\n                }\n            }\n        }\n       \
    \ val list = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n         \
    \   list += get(i)\n        }\n        list.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx9q641s0.scala:47)\n\tat Problem.main(tmpx9q641s0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var list = List[Long]()\n        var i = 0\n        for (i <- 0 to n.toInt)\
    \ list :+= (if (i == 0) 1 else if (i == 1) 3 else if (i == 2) 2 else tri(n - 1)\
    \ + tri(n - 2) + tri(n + 1))\n        list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfzrfldsi.scala:23:37 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m to n.toInt)\
    \ list :+= (\e[33mif\e[0m (i == \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e\
    [33mif\e[0m (i == \e[31m1\e[0m) \e[31m3\e[0m \e[33melse\e[0m \e[33mif\e[0m (i\
    \ == \e[31m2\e[0m) \e[31m2\e[0m \e[33melse\e[0m tri(n - \e[31m1\e[0m) + tri(n\
    \ - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m            \
    \                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m   value :+= is not a member\
    \ of List[Long] - did you mean List[Long].:+?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpfzrfldsi.scala:23:110 -----------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m to n.toInt) list :+= (\e[33mif\e\
    [0m (i == \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e[33mif\e[0m (i == \e[31m1\e\
    [0m) \e[31m3\e[0m \e[33melse\e[0m \e[33mif\e[0m (i == \e[31m2\e[0m) \e[31m2\e\
    [0m \e[33melse\e[0m tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e\
    [31m1\e[0m))\n\e[31m\e[31m   |\e[0m                                          \
    \                                                         ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 1) Nil\n        else if (n == 1) List(3)\n        else {\n  \
    \          var result = List(1, 3, 2)\n            for (i <- 3 to n.toInt) {\n\
    \                if (i % 2 == 0) result = result :+ (i / 2).toLong\n         \
    \       else result = result :+ (result(i - 1) + result(i - 2) + result(i + 1))\n\
    \            }\n            result\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpys87us8x.scala:26:59\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                \e[33mif\e[0m\
    \ (i % \e[31m2\e[0m == \e[31m0\e[0m) result = result :+ (i / \e[31m2\e[0m).toLong\n\
    \e[31m\e[31m   |\e[0m                                                   ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                   Found:\
    \    Long\n\e[31m   |\e[0m                                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpys87us8x.scala:29:12\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            result\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (result\
    \ : List[Int])\n\e[31m   |\e[0m            Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val dp = HashMap[Long, Long]()\n        def triHelper(n : Long) : Long\
    \ = {\n        \tif (n <= 0) 1\n        \telse {\n        \t\tif (dp.contains(n))\
    \ dp(n)\n        \t\telse {\n        \t\t\tif (n % 2 == 0) {\n        \t\t\t\t\
    val ans = 1 + n / 2\n        \t\t\t\tdp += n -> ans\n        \t\t\t\tans\n   \
    \     \t\t\t}\n        \t\t\telse {\n        \t\t\t\tval ans = triHelper(n - 1)\
    \ + triHelper(n - 2) + triHelper(n + 1)\n        \t\t\t\tdp += n -> ans\n    \
    \    \t\t\t\tans\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n   \
    \     val result = for (i <- 1 to n.toInt) yield triHelper(i)\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb2a4_7xq.scala:44)\n\tat Problem.main(tmpb2a4_7xq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979616
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \t\tdef tri(n : Long, a : Long, b : Long, c : Long) : List[Long] = {\n  \
    \  \t\t\tif (n <= 0) List[Long]()\n    \t\t\telse if (n == 1) (1l +: tri(n - 1,\
    \ a, b, c))\n    \t\t\telse if (n == 2) (a +: tri(n - 1, a, b, c))\n    \t\t\t\
    else if (n == 3) (b +: tri(n - 1, a, b, c))\n    \t\t\telse if (n == 4) (c +:\
    \ tri(n - 1, a, b, c))\n    \t\t\telse (tri(n - 1, a, b, c).last + tri(n - 2,\
    \ a, b, c).last + tri(n + 1, a, b, c).last) +: tri(n - 1, a, b, c)\n    \t\t}\n\
    \    \t\ttri(n, 1, 3, 2)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2hkh5w02.scala:32)\n\tat Problem.main(tmp2hkh5w02.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(1)\n        else if (n == 1) List(1, 3)\n        else\
    \ if (n == 2) List(1, 3, 2)\n        else if (n % 2 == 0) List(1, 3, 2) ::: List(n\
    \ / 2 + 1)\n        else {\n            var result = tri(n - 3)\n            result\
    \ = result ::: List(result(result.length - 3) + result(result.length - 2) + result(result.length\
    \ - 1))\n            result\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri(tmpfhk20ihw.scala:27)\n\tat Problem$.main(tmpfhk20ihw.scala:32)\n\
    \tat Problem.main(tmpfhk20ihw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // 'n' is the number of elements\
    \ you have to return in the list\n        return List(1, 2, 3).slice(0, n.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4mguxigp.scala:23:34\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mreturn\e[0m List(\e\
    [31m1\e[0m, \e[31m2\e[0m, \e[31m3\e[0m).slice(\e[31m0\e[0m, n.toInt)\n\e[31m\e\
    [31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m               Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m       \
    \        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979614
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tval m = n + 1\n    \tval a = new Array[Long](m.toInt)\n    \ta(0) = 1\n\
    \    \ta(1) = 3\n    \tif (m == 1) {\n    \t    return List(a(0))\n    \t}\n \
    \   \telse if (m == 2) {\n    \t    return List(a(0), a(1))\n    \t}\n    \ta(2)\
    \ = 2\n    \tfor (i <- 3 until m.toInt) {\n    \t\tif (i % 2 == 0) {\n    \t\t\
    \ta(i) = 1 + i / 2\n    \t\t}\n    \t\telse {\n    \t\t\ta(i) = a(i - 1) + a(i\
    \ - 2) + a(i + 1)\n    \t\t}\n    \t}\n    \treturn a.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmpllmgd3gt.scala:37)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpllmgd3gt.scala:39)\n\
    \tat Problem$.main(tmpllmgd3gt.scala:43)\n\tat Problem.main(tmpllmgd3gt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979617
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var list = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n\
    \            if (i == 1) list += 3\n            else if (i == 2) list += 2\n \
    \           else if (i == 3) list += 8\n            else if (i % 2 == 0) list\
    \ += 1 + i / 2\n            else list += list(i - 1) + list(i - 2) + list(i -\
    \ 3)\n        }\n        list.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphn1q8w3h.scala:32)\n\tat Problem.main(tmphn1q8w3h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979618
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var arr = new Array[Long](n.toInt + 1)\n        arr(0) = 1\n        arr(1)\
    \ = 3\n        arr(2) = 2\n        for (i <- 3 to n.toInt) {\n            if (i\
    \ % 2 == 0) arr(i) = 1 + i / 2\n            else arr(i) = arr(i - 1) + arr(i -\
    \ 2) + arr(i + 1)\n        }\n        arr.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmpoxmp5zg7.scala:27)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpoxmp5zg7.scala:28)\n\
    \tat Problem$.main(tmpoxmp5zg7.scala:32)\n\tat Problem.main(tmpoxmp5zg7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tvar l = List[Long]()\n    \tl = l.::(1)\n    \tl = l.::(3)\n    \tl = l.::(2)\n\
    \    \tdef t(n : Long, prev3 : Long, prev2 : Long, prev1 : Long) : List[Long]\
    \ = {\n    \t\tif (n > 0) {\n    \t\t\tvar t = 0l\n    \t\t\tif (n % 2 == 0) t\
    \ = 1 + n / 2\n    \t\t\telse t = prev3 + prev2 + prev1\n    \t\t\tt(n - 1, prev2,\
    \ prev1, t)\n    \t\t\tl = l.::(t)\n    \t\t}\n    \t\telse l\n    \t}\n    \t\
    t(n, 2, 3, 1)\n    \tl.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp81hh28ik.scala:30:8 ------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    \t\t\tt(n - \e[31m1\e[0m, prev2, prev1, t)\n\e[31m\e\
    [31m   |\e[0m    \t\t\t^\e[0m\n\e[31m   |\e[0m    \t\t\t\e[33mvariable\e[0m \e\
    [35mt\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp81hh28ik.scala:31:10 --------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m    \t\t\tl = l.::(t)\n\e[31m\e[31m   |\e[0m    \t\t\t^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m    \t\t\tFound:    Unit\n\e[31m   |\e[0m    \t\t\tRequired: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979621
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Write your code here\n        null\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.tri(long)\" is null\n\tat Problem$.main(tmpr1n_gsja.scala:25)\n\
    \tat Problem.main(tmpr1n_gsja.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979623
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \t\tdef f(n : Long) : Long = {\n    \t\t\tif (n == 1) 1\n    \t\t\telse 1\
    \ + n / 2\n    \t\t}\n    \t\tdef fib(n : Long) : Long = {\n    \t\t\tif (n ==\
    \ 1) 3\n    \t\t\telse if (n == 2) f(1)\n    \t\t\telse f(n) + fib(n - 1) + fib(n\
    \ - 2)\n    \t\t}\n    \t\tif (n == 0) List(1)\n    \t\telse if (n == 1) List(1,\
    \ 3)\n    \t\telse if (n == 2) List(1, 3, 2)\n    \t\telse List(1, 3, 2) ::: (for\
    \ (i <- 3 to n.toInt) yield fib(i)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8sl0j1z8.scala:36)\n\tat Problem.main(tmp8sl0j1z8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979624
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val a = ListBuffer[Long]()\n        a += 1\n        a += 3\n        a\
    \ += 2\n        for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) a += (1\
    \ + i / 2)\n            else a += (a(i - 1) + a(i - 2) + a(i + 1))\n        }\n\
    \        a.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmp_dl9bhka.scala:27)\n\tat Problem$.tri$$anonfun$adapted$1(tmp_dl9bhka.scala:28)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp_dl9bhka.scala:28)\n\
    \tat Problem$.main(tmp_dl9bhka.scala:32)\n\tat Problem.main(tmp_dl9bhka.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Mai"
  stdout: ''
  timestamp: 1659979625
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Put your code here\n        List()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxkea0jxo.scala:25)\n\tat Problem.main(tmpxkea0jxo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(1)\n        else if (n == 1) List(1, 3)\n        else\
    \ if (n == 2) List(1, 3, 2)\n        else if (n % 2 == 0) (1 to n.toInt).map((x)\
    \ => 1 + (x / 2)).toList\n        else {\n            val t1 = tri(n - 1)\n  \
    \          val t2 = tri(n - 2)\n            val t3 = tri(n + 1)\n            val\
    \ v = t1.last + t2.last + t3.last\n            t1 :+ v\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvtpllb8w.scala:24:68\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (n % \e[31m2\e[0m == \e[31m0\e[0m) (\e[31m1\e[0m to n.toInt).map((x) => \e\
    [31m1\e[0m + (x / \e[31m2\e[0m)).toList\n\e[31m\e[31m   |\e[0m               \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                             Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m  \
    \ |\e[0m                             Required: List[\e[1m\e[32mLong\e[0m]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979623
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var seq = new ListBuffer[Long]\n        seq += 1\n        seq += 3\n\
    \        seq += 2\n        for (i <- 3 to n.toInt) {\n            if (i % 2 ==\
    \ 0) seq += (1 + i / 2)\n            else seq += (seq(i - 1) + seq(i - 2) + seq(i\
    \ + 1))\n        }\n        seq.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpyc1utgns.scala:27)\n\tat Problem$.tri$$anonfun$adapted$1(tmpyc1utgns.scala:28)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpyc1utgns.scala:28)\n\
    \tat Problem$.main(tmpyc1utgns.scala:32)\n\tat Problem.main(tmpyc1utgns.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Mai"
  stdout: ''
  timestamp: 1659979626
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var arr = Array.fill(n.toInt + 1)(0L)\n        arr(0) = 1\n        arr(1)\
    \ = 3\n        arr(2) = 2\n        for (i <- 3 to n.toInt) {\n            arr(i)\
    \ = if (i % 2 == 0) 1 + i / 2 else arr(i - 1) + arr(i - 2) + arr(i + 1)\n    \
    \    }\n        arr.toList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmpu962sbji.scala:26)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpu962sbji.scala:27)\n\
    \tat Problem$.main(tmpu962sbji.scala:31)\n\tat Problem.main(tmpu962sbji.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979625
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri(n : Long, cache : Map[Long, Long]) : Long = {\n            if\
    \ (cache.contains(n)) cache(n)\n            else {\n                val result\
    \ = n match {\n                    case 1 => 3\n                    case 2 =>\
    \ 1\n                    case 3 => 2\n                    case n if n % 2 == 0\
    \ => 1 + n / 2\n                    case n => tri(n - 1, cache) + tri(n - 2, cache)\
    \ + tri(n + 1, cache)\n                }\n                cache += (n -> result)\n\
    \                result\n            }\n        }\n        val cache = Map[Long,\
    \ Long]()\n        val result = for (i <- 1l to n) yield tri(i, cache)\n     \
    \   result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkggrgoqw.scala:40)\n\tat Problem.main(tmpkggrgoqw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979626
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri_(p : Long, q : Long, r : Long, n : Long) : List[Long] = n match\
    \ {\n            case 0 => List(1)\n            case 1 => List(3)\n          \
    \  case 2 => List(1, 2)\n            case _ => {\n                if (n % 2 ==\
    \ 0) {\n                    val next = 1 + n / 2\n                    tri_(q,\
    \ r, next, n - 1) :+ next\n                } else {\n                    val next\
    \ = p + q + r\n                    tri_(q, r, next, n - 1) :+ next\n         \
    \       }\n            }\n        }\n        tri_(0, 0, 0, n)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_lyujbz2.scala:38)\n\tat Problem.main(tmp_lyujbz2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // 'n' is the number given by\
    \ the problem\n        // You have to return a list of 'n'+1 size\n        //\
    \ Do not change the function name\n        if (n == 1) {\n            List(1l)\n\
    \        } else if (n == 2) {\n            List(1l, 3l)\n        } else {\n  \
    \          var ans = List(1l, 3l, 2l)\n            var i = 3\n            while\
    \ (i <= n) {\n                var x = if (i % 2 == 0) {\n                    1\
    \ + i / 2\n                } else {\n                    ans(i - 1) + ans(i -\
    \ 2) + ans(i + 1)\n                }\n                ans = ans :+ x\n       \
    \         i += 1\n            }\n            ans\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7srsl7oe.scala:38:29\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                ans = ans :+\
    \ x\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m\
    \                             Found:    (x : AnyVal)\n\e[31m   |\e[0m        \
    \                     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979624
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val result = ListBuffer[Long]()\n        def triHelper(n : Long) : Long\
    \ = {\n            if (n == 1) 3\n            else if (n % 2 == 0) 1 + n / 2\n\
    \            else triHelper(n - 1) + triHelper(n - 2) + triHelper(n + 1)\n   \
    \     }\n        for (i <- 0 to n.toInt) result += triHelper(i)\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979626
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        val result = ListBuffer[Long]()\n        var i\
    \ = 1\n        while (i <= n) {\n            i match {\n                case 1\
    \ => result += 3\n                case x if x % 2 == 0 => result += (1 + (x /\
    \ 2))\n                case _ => result += (result(i - 2) + result(i - 3) + result(i\
    \ - 1))\n            }\n            i += 1\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri(tmpqkj3t1ga.scala:29)\n\tat Problem$.main(tmpqkj3t1ga.scala:36)\n\
    \tat Problem.main(tmpqkj3t1ga.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979626
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long\
    \ = {\n            if (cache.contains(n)) cache(n)\n            else {\n     \
    \           val result = n match {\n                    case 0 => 1\n        \
    \            case 1 => 3\n                    case 2 => 2\n                  \
    \  case x if x % 2 == 0 => 1 + x / 2\n                    case x => tri(x - 1)\
    \ + tri(x - 2) + tri(x + 1)\n                }\n                cache += (n ->\
    \ result)\n                result\n            }\n        }\n        (0 to n.toInt).map(tri(_)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val (zero, one, two) = (0l, 1l, 2l)\n        //val (zero, one, two) =\
    \ (Long.MinValue, Long.MinValue + 1, Long.MinValue + 2)\n        def tri_rec(n\
    \ : Long, x : List[Long]) : List[Long] = {\n            if (n == 0) x.reverse\
    \ else {\n                if (n % 2 == 0)\n                    tri_rec(n - 1,\
    \ (1 + n / 2) :: x)\n                else {\n                    if (x.length\
    \ == 1) tri_rec(n - 1, (1 + 2 + 3) :: x)\n                    else if (x.length\
    \ == 2) tri_rec(n - 1, (x(zero) + x(one) + x(two)) :: x)\n                   \
    \ else tri_rec(n - 1, (x(zero) + x(one) + x(two)) :: x.dropRight(1))\n       \
    \         }\n            }\n        }\n        tri_rec(n, List(3l))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5g03hi6t.scala:29:62\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                    \e[33melse\e\
    [0m \e[33mif\e[0m (x.length == \e[31m2\e[0m) tri_rec(n - \e[31m1\e[0m, (x(zero)\
    \ + x(one) + x(two)) :: x)\n\e[31m\e[31m   |\e[0m                            \
    \                                  ^^^^\e[0m\n\e[31m   |\e[0m                \
    \                                 Found:    (zero : Long)\n\e[31m   |\e[0m   \
    \                                              Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5g03hi6t.scala:29:72 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    \e[33melse\e[0m \e[33mif\e[0m (x.length\
    \ == \e[31m2\e[0m) tri_rec(n - \e[31m1\e[0m, (x(zero) + x(one) + x(two)) :: x)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                ^^^\e[0m\n\e[31m   |\e[0m                                   \
    \               Found:    (one : Long)\n\e[31m   |\e[0m                      \
    \                            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp5g03hi6t.scala:29:81 --------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m                    \e[33melse\e[0m \e[33mif\e[0m (x.length\
    \ == \e[31m2\e[0m) tri_rec(n - \e[31m1\e[0m, (x(zero) + x(one) + x(two)) :: x)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                         ^^^\e[0m\n\e[31m   |\e[0m                          \
    \                        Found:    (two : Long)\n\e[31m   |\e[0m             \
    \                                     Required: Int\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp5g03hi6t.scala:30:43 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    \e[33melse\e[0m tri_rec(n - \e[31m1\e\
    [0m, (x(zero) + x(one) + x(two)) :: x.dropRight(\e[31m1\e[0m))\n\e[31m\e[31m \
    \  |\e[0m                                   "
  stdout: ''
  timestamp: 1659979626
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        List[Long]()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpavo4wwqb.scala:26)\n\tat Problem.main(tmpavo4wwqb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979626
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0)\n            return Nil\n        val list = new ListBuffer[Long]\n\
    \        list += 1l\n        list += 3l\n        if (n == 1)\n            return\
    \ list.toList\n        list += 2l\n        if (n == 2)\n            return list.toList\n\
    \        for (i <- 3l to n) {\n            if (i % 2 == 0)\n                list\
    \ += (1 + i / 2)\n            else\n                list += (list(i.toInt - 1)\
    \ + list(i.toInt - 2) + list(i.toInt + 1))\n        }\n        list.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmp8lzw5zkd.scala:35)\n\tat Problem$.tri$$anonfun$adapted$1(tmp8lzw5zkd.scala:36)\n\
    \tat scala.collection.immutable.NumericRange.foreach(NumericRange.scala:115)\n\
    \tat Problem$.tri(tmp8lzw5zkd.scala:36)\n\tat Problem$.main(tmp8lzw5zkd.scala:40)\n\
    \tat Problem.main(tmp8lzw5zkd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat d"
  stdout: ''
  timestamp: 1659979627
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var result = new ListBuffer[Long]\n        if (n == 0) return List()\n\
    \        var tri1 = 0l; var tri2 = 0l; var tri3 = 3l\n        for (i <- 1 to n.toInt)\
    \ {\n            if (i % 2 == 0) result += (i / 2)\n            else {\n     \
    \           result += (tri1 + tri2 + tri3)\n                tri1 = tri2; tri2\
    \ = tri3; tri3 = result(result.length - 1)\n            }\n        }\n       \
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp480yn3xt.scala:34)\n\tat Problem.main(tmp480yn3xt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979627
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triRec(n : Long, f : Long, s : Long, t : Long) : List[Long] = {\n\
    \            if (n < 0) List[Long]()\n            else if (n == 0) List[Long](f)\n\
    \            else if (n == 1) List[Long](f, s)\n            else if (n == 2) List[Long](f,\
    \ s, t)\n            else if (n % 2 == 0) triRec(n - 1, f, s, t + (n / 2))\n \
    \           else triRec(n - 1, f, s, t + f + s + t)\n        }\n        triRec(n,\
    \ 1, 3, 2)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvxjdar8z.scala:32)\n\tat Problem.main(tmpvxjdar8z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979627
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      if (n == 0) List(1)\n      else if (n == 1) List(1, 3)\n      else {\n\
    \        val l = tri(n - 1)\n        if (n % 2 == 0) l :+ (1 + n / 2)\n      \
    \  else l :+ (l(l.length - 3) + l(l.length - 2) + l(l.length - 1))\n      }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj_b9j1q2.scala:30)\n\tat Problem.main(tmpj_b9j1q2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You may add another function\
    \ as well, if required\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyl41azc7.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m    \e[33mdef\e[0m \e[36mtri\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e\
    [31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m\
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                             Required: List[Long]\n\e[31m21 |\e[0m        \e\
    [34m// Fill up this function body\e[0m\n\e[31m22 |\e[0m        \e[34m// You may\
    \ add another function as well, if required\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979627
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var list = ListBuffer[Long]()\n        list += 1\n        list += 3\n\
    \        if (n > 1) list += 2\n        for (i <- 3 to n.toInt) {\n           \
    \ if (i % 2 == 0) list += i / 2\n            else list += list(i - 2) + list(i\
    \ - 1) + list(i + 1)\n        }\n        list.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmp0pbzo52u.scala:27)\n\tat Problem$.tri$$anonfun$adapted$1(tmp0pbzo52u.scala:28)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp0pbzo52u.scala:28)\n\
    \tat Problem$.main(tmp0pbzo52u.scala:32)\n\tat Problem.main(tmp0pbzo52u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Mai"
  stdout: ''
  timestamp: 1659979630
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var seq = List[Long](1, 3, 2)\n        if (n == 0) return seq.take(1)\n\
    \        if (n == 1) return seq.take(2)\n        if (n == 2) return seq.take(3)\n\
    \        for (i <- 3 to n.toInt) {\n            val even = (i % 2 == 0)\n    \
    \        if (even) seq = seq :+ (1 + i / 2)\n            else seq = seq :+ (seq(i\
    \ - 1) + seq(i - 2) + seq(i + 1))\n        }\n        return seq\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$$anonfun$1(tmpeb20_wb5.scala:28)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpeb20_wb5.scala:29)\n\
    \tat Problem$.main(tmpeb20_wb5.scala:33)\n\tat Problem.main(tmpeb20_wb5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979633
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      var ans = List[Long]()\n      for (i <- 1 to n.toInt) {\n        if (i\
    \ == 1) ans ::= 1\n        else if (i == 2) ans ::= 3\n        else if (i == 3)\
    \ ans ::= 2\n        else if (i % 2 == 0) ans ::= ans(i - 1) / 2\n        else\
    \ ans ::= ans(i - 1) + ans(i - 2) + ans(i - 3)\n      }\n      ans.reverse\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi0qbwqks.scala:32)\n\tat Problem.main(tmpi0qbwqks.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979634
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val l = new ArrayBuffer[Long]\n        l += 1l\n        l += 3l\n   \
    \     var i = 2l\n        while (i <= n) {\n            if (i % 2 == 0) {\n  \
    \              l += 1 + i / 2\n            } else {\n                l += l(i.toInt\
    \ - 1) + l(i.toInt - 2) + l(i.toInt + 1)\n            }\n            i += 1\n\
    \        }\n        l.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4 is out of bounds (min 0, max 2)\n\
    \tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:99)\n\tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:43)\n\
    \tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\
    \tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\tat Problem$.tri(tmp_hs90pxb.scala:29)\n\
    \tat Problem$.main(tmp_hs90pxb.scala:36)\n\tat Problem.main(tmp_hs90pxb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979635
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def h(index : Long, lst : List[Long]) : List[Long] = {\n            if\
    \ (index == n) return lst\n            val newElem = if (index % 2 == 0) 1 + index\
    \ / 2 else lst(lst.length - 1) + lst(lst.length - 2) + lst(lst.length - 3)\n \
    \           h(index + 1, lst :+ newElem)\n        }\n        h(1, List(1))\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.h$1(tmpx5qu74bb.scala:23)\n\tat Problem$.tri(tmpx5qu74bb.scala:26)\n\
    \tat Problem$.main(tmpx5qu74bb.scala:29)\n\tat Problem.main(tmpx5qu74bb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979635
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tif (n == 0) List[Long]()\n    \telse if (n == 1) List[Long](1)\n    \t\
    else if (n == 2) List[Long](1, 3)\n    \telse if (n == 3) List[Long](1, 3, 2)\n\
    \    \telse {\n    \t\tval half = n / 2\n    \t\tval lower = tri(half)\n    \t\
    \tval upper = tri(n - half)\n    \t\t(1L +: lower ::: (lower.zip(upper).map(x\
    \ => x._1 + x._2) :+ upper.last))\n    \t}\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnqvd4prp.scala:33)\n\tat Problem.main(tmpnqvd4prp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979635
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 0) return List[Long]()\n        var a = List[Long](1, 3, 2)\n\
    \        var last = a.last\n        while (last < n) {\n            if (last %\
    \ 2 == 0) a = a :+ (1 + last / 2)\n            else a = a :+ (a(a.length - 1)\
    \ + a(a.length - 2) + a(a.length - 3))\n            last = a.last\n        }\n\
    \        return a\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659979638
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri(n : Long, acc : List[Long]) : List[Long] = {\n            if\
    \ (n == 1) {\n                3 :: acc\n            } else if (n % 2 == 0) {\n\
    \                tri(n - 1, 1 + n / 2 :: acc)\n            } else {\n        \
    \        tri(n - 1, acc.head + acc.tail.head + acc.tail.tail.head :: acc)\n  \
    \          }\n        }\n        tri(n, List[Long]())\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.tri$1(tmp5w3az96e.scala:27)\n\
    \tat Problem$.tri(tmp5w3az96e.scala:30)\n\tat Problem$.main(tmp5w3az96e.scala:33)\n\
    \tat Problem.main(tmp5w3az96e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979635
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Let f(n) be the result of the above recurrence. Then\n        // f(n)\
    \ = c1 * a^n + c2 * b^n + c3 * c^n\n        // where c1, c2, c3 are some constants\
    \ and a, b, c are the roots of the cubic equation\n        // a^3 - a^2 - a -\
    \ 1 = 0.\n        // a = (1 + 3 * sqrt(33)) / 6, b = (1 - 3 * sqrt(33)) / 6, c\
    \ = -1 / 2\n        // It's easy to see that c1, c2, c3 can be found using\n \
    \       // f(1) = c1 * a + c2 * b + c3 * c\n        // f(2) = c1 * a^2 + c2 *\
    \ b^2 + c3 * c^2\n        // f(3) = c1 * a^3 + c2 * b^3 + c3 * c^3\n        //\
    \ Which are three equations with three variables (c1, c2, c3)\n        // By solving\
    \ this system we get\n        // c1 = 3, c2 = -2 * 3^2 * sqrt(33) / 33, c3 = -3^3\
    \ / 33\n        // Now f(n) can be calculated in O(logn) time by the fast power\
    \ algorithm.\n        val a = (1 + 3 * sqrt(33)) / 6\n        val b = (1 - 3 *\
    \ sqrt(33)) / 6\n        val c = -1 / 2\n        val c1 = 3\n        val c2 =\
    \ -2 * 3 * 3 * sqrt(33) / 33\n        val c3 = -3 * 3 * 3 / 33\n        val power\
    \ = (x : Double, y : Long) => {\n            if (y == 0) {\n                1\n\
    \            } else if (y == 1) {\n                x\n            } else {\n \
    \               val t = power(x, y / 2)\n                t * t * (if (y % 2 ==\
    \ 0) 1 else x)\n            }\n        }\n        def f(n : Long) : Long = {\n\
    \            if (n == 0) 0\n            else if\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpyhlwz7b_.scala:52:19 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m\n\e[31m\e[31m\
    \   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpyhlwz7b_.scala:68:0 ----------------------------\e[0m\e[0m\n\e[31m68\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyhlwz7b_.scala:46:24 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                \e[33mval\e[0m \e[36mt\e[0m = power(x,\
    \ y / \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m\
    \   |\e[0m                        Recursive \e[33mvalue\e[0m \e[35mpower\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyhlwz7b_.scala:67:1\
    \ ---------------------\e[0m\e[0m\n\e[31m67 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpyhlwz7b_.scala:54:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m54 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659979636
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val memo = Array.fill(n.toInt + 1)(-1l)\n        memo(0) = 1l\n     \
    \   memo(1) = 3l\n        def solve(i : Int) : Long = {\n            if (memo(i)\
    \ != -1) memo(i)\n            else if (i % 2 == 0) {\n                memo(i)\
    \ = 1 + i / 2\n                memo(i)\n            }\n            else {\n  \
    \              memo(i) = solve(i - 1) + solve(i - 2) + solve(i + 1)\n        \
    \        memo(i)\n            }\n        }\n        (0 to n.toInt).map(solve(_)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.solve$1(tmp72l3dm0m.scala:25)\n\tat Problem$.solve$1(tmp72l3dm0m.scala:31)\n\
    \tat Problem$.tri$$anonfun$1(tmp72l3dm0m.scala:35)\n\tat scala.runtime.java8.JFunction1$mcJI$sp.apply(JFunction1$mcJI$sp.scala:17)\n\
    \tat scala.collection.immutable.Range.map(Range.scala:59)\n\tat Problem$.tri(tmp72l3dm0m.scala:35)\n\
    \tat Problem$.main(tmp72l3dm0m.scala:38)\n\tat Problem.main(tmp72l3dm0m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979637
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tif (n == 0) return List(1)\n    \tif (n == 1) return List(1, 3)\n    \t\
    if (n == 2) return List(1, 3, 2)\n    \tvar result = List[Long](1, 3, 2)\n   \
    \ \tvar i = 3l\n    \twhile (i <= n) {\n    \t\tresult = result :+ (if (i % 2\
    \ == 0) (1 + i / 2) else (result(i.toInt - 1) + result(i.toInt - 2) + result(i.toInt\
    \ + 1)))\n    \t\ti += 1\n    \t}\n    \tresult\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri(tmplv_9_j4k.scala:27)\n\tat Problem$.main(tmplv_9_j4k.scala:33)\n\
    \tat Problem.main(tmplv_9_j4k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979637
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        List()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppq4pmj7p.scala:26)\n\tat Problem.main(tmppq4pmj7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979637
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // 'List[Long]' constructor is\
    \ not that easy to write,\n        // so you might want to use it in your implementation.\n\
    \        // Don't forget to 'import scala.collection.mutable._'\n        // to\
    \ use 'ArrayBuffer' data structure.\n        val ans = new ArrayBuffer[Long]\n\
    \        ans += 1\n        if (n >= 1) ans += 3\n        for (i <- 2 to n.toInt)\
    \ {\n            if (i % 2 == 0) ans += 1 + i / 2\n            else ans += ans(i\
    \ - 1) + ans(i - 2) + ans(i + 1)\n        }\n        ans.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4 is out of bounds (min 0, max 2)\n\
    \tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:99)\n\tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:43)\n\
    \tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\
    \tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\tat Problem$.tri$$anonfun$1(tmp993k2c5p.scala:31)\n\
    \tat Problem$.tri$$anonfun$adapted$1(tmp993k2c5p.scala:32)\n\tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\
    \tat Problem$.tri(tmp993k2c5p.scala:32)\n\tat Problem$.main(tmp993k2c5p.scala:36)\n\
    \tat Problem.main(tmp993k2c5p.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979637
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You may add another function\
    \ as well, if required\n        var result = ListBuffer[Long]()\n        var a\
    \ = 1l\n        var b = 3l\n        var c = 2l\n        result += a\n        result\
    \ += b\n        result += c\n        for (i <- 3l to n) {\n            if (i %\
    \ 2 == 0) result += (1 + i / 2)\n            else {\n                result +=\
    \ (result(i.toInt - 1) + result(i.toInt - 2) + result(i.toInt + 1))\n        \
    \    }\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpy4pjlzex.scala:33)\n\tat Problem$.tri$$anonfun$adapted$1(tmpy4pjlzex.scala:35)\n\
    \tat scala.collection.immutable.NumericRange.foreach(NumericRange.scala:115)\n\
    \tat Problem$.tri(tmpy4pjlzex.scala:35)\n\tat Problem$.main(tmpy4pjlzex.scala:39)\n\
    \tat Problem.main(tmpy4pjlzex.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat d"
  stdout: ''
  timestamp: 1659979637
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var lst = new Array[Long](n.toInt + 1)\n        lst(0) = 1\n        lst(1)\
    \ = 3\n        for (i <- 2 to n.toInt) {\n            if (i % 2 == 0) {\n    \
    \            lst(i) = 1 + i / 2\n            } else {\n                lst(i)\
    \ = lst(i - 1) + lst(i - 2) + lst(i + 1)\n            }\n        }\n        lst.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmp8nrwk3b6.scala:28)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp8nrwk3b6.scala:30)\n\
    \tat Problem$.main(tmp8nrwk3b6.scala:34)\n\tat Problem.main(tmp8nrwk3b6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979637
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def loop(n : Long, dp : List[Long]) : List[Long] = {\n            if\
    \ (n == 0) dp\n            else {\n                if (n % 2 == 0) loop(n - 1,\
    \ dp :+ (1 + n / 2))\n                else loop(n - 1, dp :+ (dp(dp.length - 1)\
    \ + dp(dp.length - 2) + dp(dp.length - 3)))\n            }\n        }\n      \
    \  loop(n, List[Long](1))\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.loop$1(tmpkfhcaa2r.scala:25)\n\tat Problem$.tri(tmpkfhcaa2r.scala:28)\n\
    \tat Problem$.main(tmpkfhcaa2r.scala:31)\n\tat Problem.main(tmpkfhcaa2r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979637
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri_rec(i : Long, arr : List[Long]) : List[Long] = {\n          \
    \  if (i == n) arr\n            else if (i % 2 == 0) tri_rec(i + 1, arr :+ (1\
    \ + i / 2))\n            else tri_rec(i + 1, arr :+ (arr(i.toInt - 1) + arr(i.toInt\
    \ - 2) + arr(i.toInt + 1)))\n        }\n        tri_rec(1, List[Long](1))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri_rec$1(tmphv584chl.scala:24)\n\tat Problem$.tri(tmphv584chl.scala:26)\n\
    \tat Problem$.main(tmphv584chl.scala:29)\n\tat Problem.main(tmphv584chl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979638
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0)\n            List(1l)\n        else if (n == 1)\n       \
    \     List(1l, 3l)\n        else if (n == 2)\n            List(1l, 3l, 2l)\n \
    \       else {\n            val list = tri(n - 1)\n            if (n % 2 == 0)\n\
    \                list :+ (1 + n / 2)\n            else\n                list :+\
    \ (list(list.length - 1) + list(list.length - 2) + list(list.length - 3))\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp54u5zleu.scala:36)\n\tat Problem.main(tmp54u5zleu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979637
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var result = new ListBuffer[Long]\n        if (n == 0) return List[Long](1l)\n\
    \        if (n == 1) return List[Long](1l, 3l)\n        if (n == 2) return List[Long](1l,\
    \ 3l, 2l)\n        result += 1l\n        result += 3l\n        result += 2l\n\
    \        for (i <- 3l to n) {\n            var next = 0l\n            if (i %\
    \ 2 == 0) next = 1 + i / 2\n            else next = result(i.toInt - 1) + result(i.toInt\
    \ - 2) + result(i.toInt + 1)\n            result += next\n        }\n        return\
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpzm7eo2p_.scala:31)\n\tat Problem$.tri$$anonfun$adapted$1(tmpzm7eo2p_.scala:33)\n\
    \tat scala.collection.immutable.NumericRange.foreach(NumericRange.scala:115)\n\
    \tat Problem$.tri(tmpzm7eo2p_.scala:33)\n\tat Problem$.main(tmpzm7eo2p_.scala:37)\n\
    \tat Problem.main(tmpzm7eo2p_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat d"
  stdout: ''
  timestamp: 1659979638
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var a = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n     \
    \   \tif (i == 1) a += 3\n        \telse if (i == 2) a += 1\n        \telse if\
    \ (i == 3) a += 2\n        \telse {\n        \t\tif (i % 2 == 0) a += i / 2\n\
    \        \t\telse a += a(i - 2) + a(i - 3) + a(i - 1)\n        \t}\n        }\n\
    \        a.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxin21bwx.scala:34)\n\tat Problem.main(tmpxin21bwx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979638
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        var tri = List[Long](1, 3, 2)\n        while (tri.length\
    \ != n + 1) {\n            var cur = tri.length\n            if (cur % 2 == 0)\
    \ {\n                tri = tri :+ (1 + cur / 2)\n            } else {\n      \
    \          tri = tri :+ (tri(cur - 1) + tri(cur - 2) + tri(cur + 1))\n       \
    \     }\n        }\n        tri\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri(tmpjkb0a1qn.scala:29)\n\tat Problem$.main(tmpjkb0a1qn.scala:35)\n\
    \tat Problem.main(tmpjkb0a1qn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triR(n : Long, s : List[Long]) : List[Long] = {\n            if (n\
    \ == 0) s\n            else if (n == 1) s :+ 3\n            else if (n % 2 ==\
    \ 0) triR(n - 1, s :+ (1 + n / 2))\n            else triR(n - 1, s :+ (s(s.length\
    \ - 1) + s(s.length - 2) + s(s.length - 3)))\n        }\n        triR(n, List[Long]())\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.triR$1(tmpcb79dq16.scala:25)\n\tat Problem$.tri(tmpcb79dq16.scala:27)\n\
    \tat Problem$.main(tmpcb79dq16.scala:30)\n\tat Problem.main(tmpcb79dq16.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979639
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var a = 1l; var b = 1l; var c = 1l;\n        return List.range(0, n.toInt\
    \ + 1).map(x => {\n            var v = a + b + c;\n            if (v % 2 == 0)\
    \ v /= 2;\n            a = b; b = c; c = v;\n            return v;\n        }).toList;\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl2qmjps8.scala:26:19\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mreturn\e[0m\
    \ v;\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m        \
    \           Found:    (v : Long)\n\e[31m   |\e[0m                   Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979638
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val arr = new Array[Long](n.toInt + 1)\n        arr(0) = 1\n        arr(1)\
    \ = 3\n        for (i <- 2 to n.toInt) {\n            if (i % 2 == 0) arr(i) =\
    \ 1 + i / 2\n            else arr(i) = arr(i - 1) + arr(i - 2) + arr(i + 1)\n\
    \        }\n        arr.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmprikqn183.scala:26)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmprikqn183.scala:27)\n\
    \tat Problem$.main(tmprikqn183.scala:31)\n\tat Problem.main(tmprikqn183.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979641
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Good Luck!\n        val result = new ListBuffer[Long]()\n        result\
    \ += 1\n        result += 3\n        result += 2\n        for (i <- 4 to n.toInt)\
    \ {\n            if (i % 2 == 0) {\n                result += 1 + i / 2\n    \
    \        } else {\n                result += result(i - 2) + result(i - 1) + result(i\
    \ + 1)\n            }\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp5ilvz3q.scala:36)\n\tat Problem.main(tmpp5ilvz3q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979645
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri(n : Long, acc : List[Long]) : List[Long] = {\n            if\
    \ (n == 0) acc\n            else if (n == 1) tri(n - 1, 3 :: acc)\n          \
    \  else if (n % 2 == 0) tri(n - 1, (1 + n / 2) :: acc)\n            else tri(n\
    \ - 1, (acc(1) + acc(2) + acc(0)) :: acc)\n        }\n        tri(n, List())\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$1(tmpnkre8our.scala:25)\n\tat Problem$.tri(tmpnkre8our.scala:27)\n\
    \tat Problem$.main(tmpnkre8our.scala:30)\n\tat Problem.main(tmpnkre8our.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979645
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val fib = ArrayBuffer[Long](1, 3, 2)\n        if (n == 1) fib.take(2).toList\n\
    \        else {\n            (3l to n).foreach(x => fib += fib(x.toInt - 1) +\
    \ fib(x.toInt - 2) + fib(x.toInt + 1))\n            fib.toList\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4 is out of bounds (min 0, max 2)\n\
    \tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:99)\n\tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:43)\n\
    \tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\
    \tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\tat Problem$.tri$$anonfun$1(tmplopj4w7q.scala:24)\n\
    \tat Problem$.tri$$anonfun$adapted$1(tmplopj4w7q.scala:24)\n\tat scala.collection.immutable.NumericRange.foreach(NumericRange.scala:115)\n\
    \tat Problem$.tri(tmplopj4w7q.scala:24)\n\tat Problem$.main(tmplopj4w7q.scala:29)\n\
    \tat Problem.main(tmplopj4w7q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979646
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tif (n == 0) List(1)\n    \telse if (n == 1) List(1, 3)\n    \telse {\n\
    \    \t\tval lst = tri(n - 1)\n    \t\tval m = lst.length\n    \t\tvar x = lst(m\
    \ - 1) + lst(m - 2) + lst(m - 3)\n    \t\tif (n % 2 == 0) x = 1 + n / 2\n    \t\
    \tlst :+ x\n    \t}\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri(tmp8dgto3ei.scala:26)\n\tat Problem$.tri(tmp8dgto3ei.scala:24)\n\
    \tat Problem$.main(tmp8dgto3ei.scala:32)\n\tat Problem.main(tmp8dgto3ei.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979646
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var list = List[Long]()\n        var i = 1\n        while (i <= n) {\n\
    \            list :+= tri(i)\n            i += 1\n        }\n        list\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_17kdpoq.scala:24:17 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            list :+= tri(i)\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0m   value :+= is not a member of List[Long]\
    \ - did you mean List[Long].:+?\n1 error found\n"
  stdout: ''
  timestamp: 1659979645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri(a : Long, b : Long, c : Long, l : List[Long]) : List[Long] =\
    \ {\n            if (l.length == n + 1) l\n            else if (l.length % 2 ==\
    \ 0) tri(a, b, c, c +: l)\n            else tri(b, c, c + b + a, c + b + a +:\
    \ l)\n        }\n        tri(1, 3, 2, List[Long](1))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E041] Syntax Error: /tmp/tmp559j7vy9.scala:24:46 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33melse\e[0m tri(b, c, c + b + a, c +\
    \ b + a +: l)\n\e[31m\e[31m   |\e[0m                                         \
    \     ^\e[0m\n\e[31m   |\e[0m+ (which is left-associative) and +: (which is right-associative)\
    \ have same precedence and may not be mixed\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmp559j7vy9.scala:24:44 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33melse\e[0m tri(b, c, c + b + a, c +\
    \ b + a +: l)\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m+\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m\
    \ (x: String): String\n\e[31m   |\e[0mmatch arguments (List[Long])\n2 errors found\n"
  stdout: ''
  timestamp: 1659979642
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // your solution here\n        val result : ListBuffer[Long] = ListBuffer(1l)\n\
    \        for (i <- 1l to n) {\n            if (i == 1) {\n                result\
    \ += 3l\n            } else if (i % 2 == 0) {\n                result += (1 +\
    \ i / 2)\n            } else {\n                result += (result(i.toInt - 1)\
    \ + result(i.toInt - 2) + result(i.toInt + 1))\n            }\n        }\n   \
    \     result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpy41zpjvp.scala:29)\n\tat Problem$.tri$$anonfun$adapted$1(tmpy41zpjvp.scala:31)\n\
    \tat scala.collection.immutable.NumericRange.foreach(NumericRange.scala:115)\n\
    \tat Problem$.tri(tmpy41zpjvp.scala:31)\n\tat Problem$.main(tmpy41zpjvp.scala:35)\n\
    \tat Problem.main(tmpy41zpjvp.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat d"
  stdout: ''
  timestamp: 1659979648
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def helper(l : List[Long], n : Long) : List[Long] = {\n            if\
    \ (n == 0) l\n            else {\n                if (n % 2 == 0) helper(l :+\
    \ (1 + n / 2), n - 1)\n                else helper(l :+ (l(l.length - 1) + l(l.length\
    \ - 2) + l(l.length - 3)), n - 1)\n            }\n        }\n        helper(List(1,\
    \ 3, 2), n)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkey800xo.scala:31)\n\tat Problem.main(tmpkey800xo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979648
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      val l = new Array[Long]((n + 1).toInt)\n      l(0) = 1\n      l(1) = 3\n\
    \      if (n == 0) return List(1)\n      if (n == 1) return List(1, 3)\n     \
    \ for (i <- 2 to n.toInt) {\n        if (i % 2 == 0) l(i) = 1 + i / 2\n      \
    \  else l(i) = l(i - 1) + l(i - 2) + l(i + 1)\n      }\n      return l.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmp7k3g7mfr.scala:28)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp7k3g7mfr.scala:29)\n\
    \tat Problem$.main(tmp7k3g7mfr.scala:33)\n\tat Problem.main(tmp7k3g7mfr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Implements a fibonacci seq\n        // fib(n) = fib(n - 1) + fib(n\
    \ - 2)\n        def fib(n : Long) : Long = {\n            // If n is not in memory,\
    \ compute it\n            if (!fibonacci.contains(n)) {\n                fibonacci(n)\
    \ = if (n % 2 == 0) 1 + n / 2 else fib(n - 1) + fib(n - 2) + fib(n + 1)\n    \
    \        }\n            fibonacci(n)\n        }\n        var fibonacci = Map[Long,\
    \ Long]()\n        fibonacci(1) = 3\n        fibonacci(2) = 1\n        fibonacci(3)\
    \ = 2\n        (0 to n.toInt).map(x => fib(x)).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E039] Reference Error: /tmp/tmpjyee63an.scala:25:17 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mif\e[0m (!fibonacci.contains(n)) {\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^\e[0m\n\e[31m   |\e[0mfibonacci\
    \ is a forward reference extending over the definition of fibonacci\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979644
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var b1 = 0l\n        var b2 = 1l\n        var b3 = 3l\n        val res\
    \ = new ListBuffer[Long]\n        res += 0\n        res += 1\n        res += 3\n\
    \        for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) res += (i / 2\
    \ + 1)\n            else {\n                res += (res(i - 1) + res(i - 2) +\
    \ res(i + 1))\n            }\n        }\n        res.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpw3p3yaql.scala:31)\n\tat Problem$.tri$$anonfun$adapted$1(tmpw3p3yaql.scala:33)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpw3p3yaql.scala:33)\n\
    \tat Problem$.main(tmpw3p3yaql.scala:37)\n\tat Problem.main(tmpw3p3yaql.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Mai"
  stdout: ''
  timestamp: 1659979649
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tif (n == 0) return List(1)\n    \tif (n == 1) return List(1, 3)\n    \t\
    val result = new ListBuffer[Long]\n    \tresult += 1\n    \tresult += 3\n    \t\
    result += 2\n    \tfor (i <- 3l to n) {\n    \t\tif (i % 2 == 0) result += (1\
    \ + i / 2)\n    \t\telse result += (result(result.length - 1) + result(result.length\
    \ - 2) + result(result.length))\n    \t}\n    \tresult.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 3\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpfj59hsz7.scala:29)\n\tat Problem$.tri$$anonfun$adapted$1(tmpfj59hsz7.scala:30)\n\
    \tat scala.collection.immutable.NumericRange.foreach(NumericRange.scala:115)\n\
    \tat Problem$.tri(tmpfj59hsz7.scala:30)\n\tat Problem$.main(tmpfj59hsz7.scala:34)\n\
    \tat Problem.main(tmpfj59hsz7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat d"
  stdout: ''
  timestamp: 1659979649
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) return List(1)\n        if (n == 1) return List(1, 3)\n \
    \       val lst = tri(n - 1)\n        val newlst = lst :+ ((if (n % 2 == 0) 1\
    \ + n / 2 else lst(lst.length - 1) + lst(lst.length - 2) + lst(lst.length - 3)))\n\
    \        return newlst\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5cc7uk13.scala:28)\n\tat Problem.main(tmp5cc7uk13.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979648
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var cache = Array.fill(n.toInt + 1)(0)\n        var res = new ArrayBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            var x = 0l\n            if (i\
    \ == 1) x = 3\n            else if (i == 2) x = 1\n            else if (i == 3)\
    \ x = 2\n            else if (i % 2 == 0) x = i / 2\n            else x = 1 +\
    \ cache(i - 1) + cache(i - 2) + cache(i + 1)\n            cache(i) = x.toInt\n\
    \            res += x\n        }\n        res.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2llz1ncs.scala:36)\n\tat Problem.main(tmp2llz1ncs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979649
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tval a = new Array[Long](n.toInt + 1)\n    \ta(0) = 1\n    \ta(1) = 3\n\
    \    \ta(2) = 2\n    \tfor (i <- 3 to n.toInt) {\n    \t\tif (i % 2 == 0) a(i)\
    \ = (1 + i / 2)\n    \t\telse a(i) = a(i - 1) + a(i - 2) + a(i + 1)\n    \t}\n\
    \    \treturn a.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmpf_ejgj_o.scala:27)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpf_ejgj_o.scala:28)\n\
    \tat Problem$.main(tmpf_ejgj_o.scala:32)\n\tat Problem.main(tmpf_ejgj_o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979649
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var lst = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n \
    \           if (i == 1) lst += 3\n            else if (i == 2) lst += 1\n    \
    \        else if (i == 3) lst += 2\n            else if (i % 2 == 0) lst += 1\
    \ + i / 2\n            else lst += lst(i - 4) + lst(i - 3) + lst(i - 2)\n    \
    \    }\n        lst.toList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdsysoql7.scala:32)\n\tat Problem.main(tmpdsysoql7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979649
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triIter(n : Long, l : List[Long]) : List[Long] = {\n            if\
    \ (n <= 0) l\n            else if (n % 2 == 0) triIter(n - 1, 1 + n / 2 :: l)\n\
    \            else {\n                val x = l.head + l.tail.head + l.tail.tail.head\n\
    \                triIter(n - 1, x :: l)\n            }\n        }\n        triIter(n,\
    \ List())\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.triIter$1(tmpfd6glxtu.scala:25)\n\
    \tat Problem$.tri(tmpfd6glxtu.scala:29)\n\tat Problem$.main(tmpfd6glxtu.scala:32)\n\
    \tat Problem.main(tmpfd6glxtu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979648
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tif (n == 0) return List(1)\n    \tif (n == 1) return List(1, 3)\n    \t\
    if (n == 2) return List(1, 3, 2)\n    \tvar triList = tri(n - 1)\n    \tvar triCurr\
    \ = triList(triList.length - 1) + triList(triList.length - 2) + triList(triList.length\
    \ - 3)\n    \ttriList = triList :+ triCurr\n    \treturn triList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe5oxdwir.scala:30)\n\tat Problem.main(tmpe5oxdwir.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979649
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def f(n : Long) : Long = if (n == 1) 3 else if (n % 2 == 0) 1 + n / 2\
    \ else f(n - 1) + f(n - 2) + f(n + 1)\n        var l = List[Long]()\n        (0\
    \ to n.toInt).foreach(i => l :+= f(i))\n        l\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979650
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def helper(n : Long, lst : List[Long]) : List[Long] = n match {\n   \
    \         case 0 => lst\n            case _ => {\n                if (n % 2 ==\
    \ 0) {\n                    helper(n - 1, lst :+ (1 + n / 2))\n              \
    \  } else {\n                    helper(n - 1, lst :+ (lst(lst.length - 1) + lst(lst.length\
    \ - 2) + lst(lst.length - 3)))\n                }\n            }\n        }\n\
    \        helper(n, List(1))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.helper$1(tmpi_l16qye.scala:27)\n\tat Problem$.tri(tmpi_l16qye.scala:31)\n\
    \tat Problem$.main(tmpi_l16qye.scala:34)\n\tat Problem.main(tmpi_l16qye.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979650
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var t = new Array[Long](n.toInt + 1)\n        t(0) = 1; t(1) = 3; t(2)\
    \ = 2\n        for (i <- 3 to n.toInt) {\n            t(i) = if (i % 2 == 0) 1\
    \ + i / 2 else t(i - 1) + t(i - 2) + t(i + 1)\n        }\n        t.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmp0hdgv8_2.scala:24)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp0hdgv8_2.scala:25)\n\
    \tat Problem$.main(tmp0hdgv8_2.scala:29)\n\tat Problem.main(tmp0hdgv8_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979650
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri(n : Long, a : Long, b : Long, c : Long) : List[Long] = {\n  \
    \          if (n == 0) List[Long]()\n            else if (n == 1) List[Long](1)\n\
    \            else if (n == 2) List[Long](1, 3)\n            else if (n == 3) List[Long](1,\
    \ 3, 2)\n            else {\n                val d = if (n % 2 == 0) (n / 2) else\
    \ ((a + b + c) % 1000000007)\n                d :: tri(n - 1, b, c, d)\n     \
    \       }\n        }\n        tri(n, 0, 0, 0).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp77nsf4zc.scala:34)\n\tat Problem.main(tmp77nsf4zc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979649
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // 'return List()' if the result\
    \ is an empty list\n        // 'return List(1)' for a list with single element\
    \ '1'\n        List(1, 3, 2, 8)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyrda635z.scala:28)\n\tat Problem.main(tmpyrda635z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979652
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        n match {\n            case n if n == 0 => List(1)\n            case\
    \ n if n == 1 => List(1, 3)\n            case n if n == 2 => List(1, 3, 2)\n \
    \           case n if n > 2 => {\n                val list = tri(n - 1)\n    \
    \            val value = if (n % 2 == 0) {\n                    (1 + n / 2)\n\
    \                } else {\n                    list(list.length - 3) + list(list.length\
    \ - 2) + list(list.length - 1)\n                }\n                list :+ value\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx5_xpjp9.scala:37)\n\tat Problem.main(tmpx5_xpjp9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tvar list = new ListBuffer[Long]\n    \tlist += 1\n    \tlist += 3\n   \
    \ \tvar x = 2\n    \twhile (x <= n) {\n    \t\tvar tri = 1 + (x / 2)\n    \t\t\
    if (x % 2 == 1) {\n    \t\t\ttri = list(x - 1) + list(x - 2) + list(x + 1)\n \
    \   \t\t}\n    \t\tlist += tri\n    \t\tx += 1\n    \t}\n    \tlist.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz3f4hf6y.scala:28:14\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m    \t\t\ttri = list(x - \e[31m1\e\
    [0m) + list(x - \e[31m2\e[0m) + list(x + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m\
    \    \t\t\t      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \    \t\t\t      Found:    Long\n\e[31m   |\e[0m    \t\t\t      Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val memo = new Array[Long](n.toInt + 1)\n        memo(0) = 1\n      \
    \  memo(1) = 3\n        memo(2) = 2\n        def dp(x : Int) : Long = {\n    \
    \        if (memo(x) != 0) memo(x)\n            else {\n                val ans\
    \ = if (x % 2 == 0) 1 + x / 2 else dp(x - 1) + dp(x - 2) + dp(x + 1)\n       \
    \         memo(x) = ans\n                ans\n            }\n        }\n     \
    \   val l = new ListBuffer[Long]\n        for (i <- 0 to n.toInt) l += dp(i)\n\
    \        l.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphmx444s5.scala:29:26\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                memo(x) = ans\n\
    \e[31m\e[31m   |\e[0m                          ^^^\e[0m\n\e[31m   |\e[0m     \
    \                     Found:    (ans : AnyVal)\n\e[31m   |\e[0m              \
    \            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphmx444s5.scala:30:16 --------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m                ans\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e\
    [31m   |\e[0m                Found:    (ans : AnyVal)\n\e[31m   |\e[0m       \
    \         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        List()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppq4pmj7p.scala:26)\n\tat Problem.main(tmppq4pmj7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979637
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        //if (n == 0) return List[Long](1, 1, 1)\n        if (n == 1) return\
    \ List[Long](1, 3)\n        if (n == 2) return List[Long](1, 3, 2)\n        var\
    \ tri = new Array[Long](n.toInt + 1)\n        tri(0) = 1\n        tri(1) = 3\n\
    \        tri(2) = 2\n        for (i <- 3 to n.toInt) {\n            tri(i) = if\
    \ (i % 2 == 0) 1 + i / 2 else tri(i - 1) + tri(i - 2) + tri(i + 1)\n        }\n\
    \        tri.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmpul22sjlm.scala:29)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpul22sjlm.scala:30)\n\
    \tat Problem$.main(tmpul22sjlm.scala:34)\n\tat Problem.main(tmpul22sjlm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979655
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // 'n' is non-negative integer\n\
    \        if (n == 0) List(1)\n        else if (n == 1) List(1, 3)\n        else\
    \ {\n            var a = 1l\n            var b = 3l\n            var c = 2l\n\
    \            var lst = List[Long](a, b, c)\n            for (i <- 3l to n) {\n\
    \                val v = if (i % 2 == 0) {\n                    1 + i / 2\n  \
    \              } else {\n                    a + b + c\n                }\n  \
    \              a = b\n                b = c\n                c = v\n         \
    \       lst = lst :+ v\n            }\n            lst\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7768qyy9.scala:45)\n\tat Problem.main(tmp7768qyy9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979655
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def isEven(n : Long) : Boolean = n % 2 == 0\n        def findTri(n :\
    \ Long) : Long = {\n            if (n == 1) 3\n            else if (isEven(n))\
    \ n / 2 + 1\n            else {\n                val n1 = findTri(n - 1)\n   \
    \             val n2 = findTri(n - 2)\n                val n3 = findTri(n + 1)\n\
    \                n1 + n2 + n3\n            }\n        }\n        def find(n :\
    \ Long, list : List[Long]) : List[Long] = {\n            if (n <= 0) list\n  \
    \          else find(n - 1, findTri(n) :: list)\n        }\n        find(n, List())\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpea7s29vj.scala:39)\n\tat Problem.main(tmpea7s29vj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979655
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def run(x : Long, a : Long, b : Long, c : Long) : Long = {\n        \
    \    if (x == 0) 0\n            else if (x == 1) 1\n            else if (x ==\
    \ 2) 2\n            else if (x == 3) 3\n            else if (x % 2 == 0) run(x\
    \ - 1, a + b + c, a, b)\n            else run(x - 1, b, c, a + b + c)\n      \
    \  }\n        def loop(x : Long, l : List[Long]) : List[Long] = {\n          \
    \  if (x > n) l\n            else loop(x + 1, l :+ run(x, 0, 0, 0))\n        }\n\
    \        loop(0, List())\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8ag19xlw.scala:36)\n\tat Problem.main(tmp8ag19xlw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979655
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List[Long]()\n        else if (n == 1) List[Long](1)\n  \
    \      else if (n == 2) List[Long](1, 3)\n        else if (n == 3) List[Long](1,\
    \ 3, 2)\n        else {\n            var result = tri(n - 1)\n            var\
    \ value = 0l\n            if (n % 2 == 0) value = 1 + n / 2\n            else\
    \ value = result(result.length - 1) + result(result.length - 2) + result(result.length\
    \ - 3)\n            result :+ value\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpow1nwaot.scala:34)\n\tat Problem.main(tmpow1nwaot.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(1)\n        else if (n == 1) List(1, 3)\n        else\
    \ if (n == 2) List(1, 3, 2)\n        else if (n % 2 == 0) tri(n - 1) :+ (1 + n\
    \ / 2)\n        else tri(n - 1) :+ (tri(n - 1).last + tri(n - 2).last + tri(n\
    \ + 1).last)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.collection.immutable.List$.from(List.scala:684)\n\
    \tat scala.collection.immutable.List$.from(List.scala:681)\n\tat scala.collection.IterableFactory.apply(Factory.scala:103)\n\
    \tat scala.collection.IterableFactory.apply$(Factory.scala:103)\n\tat scala.collection.immutable.List$.apply(List.scala:681)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:23)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tri(tmpwls2py0u.scala:25)\n\
    \tat Problem$.tri(tmpwls2py0u.scala:24)\n\tat Problem$.tr"
  stdout: ''
  timestamp: 1659979655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // 'a' is the accumulator, it\
    \ is initialized with 1L which is base case\n        // 'b' is the base, which\
    \ is 1 in our case.\n        // 'f' is the function to be applied to every element\
    \ of the list to be generated.\n        // 'lt' is the list of elements to be\
    \ generated.\n        def f(a : Long, b : Long, f : (Long, Long) => Long, lt :\
    \ List[Long]) : List[Long] = {\n            // This function will generate elements\
    \ of the list by applying function 'f' to every element of 'lt'\n            lt\
    \ match {\n                case List() => Nil\n                case x :: xs =>\
    \ f(a, b, f, lt.tail) ::: List(f(a, b, f, lt))\n            }\n        }\n   \
    \     def g(a : Long, b : Long) : Long = {\n            // This function will\
    \ apply the function to the elements of the list to be generated\n           \
    \ // 'a' is the accumulator, it is initialized with 1L which is base case\n  \
    \          // 'b' is the element to be appended to the list.\n            val\
    \ ret = (b match {\n                case 1 => 3\n                case _ => a +\
    \ b\n            })\n            return ret\n        }\n        return f(1L, 1L,\
    \ g, (1L to n).toList)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp8eq5pnwl.scala:30:69 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mcase\e[0m x :: xs => f(a, b, f,\
    \ lt.tail) ::: List(f(a, b, f, lt))\n\e[31m\e[31m   |\e[0m                   \
    \                                                  ^\e[0m\n\e[31m   |\e[0mtoo\
    \ many arguments for \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e\
    [35mFunction2\e[0m: (v1: Long, v2: Long): Long\n\e[31m\e[31m-- Error: /tmp/tmp8eq5pnwl.scala:30:40\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \         \e[33mcase\e[0m x :: xs => f(a, b, f, lt.tail) ::: List(f(a, b, f, lt))\n\
    \e[31m\e[31m   |\e[0m                                        ^\e[0m\n\e[31m  \
    \ |\e[0mtoo many arguments for \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e\
    [0m \e[35mFunction2\e[0m: (v1: Long, v2: Long): Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Fill up this function body\n        // 'n' is the number to which\
    \ Tribonacci sequence is needed\n        // You have to return a list of the Tribonacci\
    \ sequence of first 'n + 1' numbers\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1rkajqnl.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m    \e[33mdef\e[0m \e[36mtri\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e\
    [31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m\
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                             Required: List[Long]\n\e[31m21 |\e[0m        \e\
    [34m// Fill up this function body\e[0m\n\e[31m22 |\e[0m        \e[34m// 'n' is\
    \ the number to which Tribonacci sequence is needed\e[0m\n\e[31m23 |\e[0m    \
    \    \e[34m// You have to return a list of the Tribonacci sequence of first 'n\
    \ + 1' numbers\e[0m\n\e[31m24 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979655
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var result = List[Long]()\n        if (n <= 0) return result\n      \
    \  result +:= 1\n        if (n == 1) return result\n        result +:= 3\n   \
    \     if (n == 2) return result\n        result +:= 2\n        if (n == 3) return\
    \ result\n        for (i <- (4l to n)) {\n            val last = result.length\
    \ - 1\n            val next = result(last - 2) + result(last - 1) + result(last)\n\
    \            result +:= next\n        }\n        result.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2o12ec4n.scala:37)\n\tat Problem.main(tmp2o12ec4n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979656
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var list = new ListBuffer[Long]()\n        list += 1\n        list +=\
    \ 3\n        list += 2\n        for (i <- 4l to n) {\n            var value =\
    \ 0l\n            if (i % 2 == 0) value = 1 + i / 2\n            else value =\
    \ list(i.toInt - 2) + list(i.toInt - 1) + list(i.toInt + 1)\n            list\
    \ += value\n        }\n        return list.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg6b0jgvw.scala:34)\n\tat Problem.main(tmpg6b0jgvw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979656
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var f : List[Long] = List(0, 1, 3)\n        def g(n : Long) : Long =\
    \ {\n            if (n <= 3) {\n                f(n.toInt)\n            } else\
    \ {\n                if (n % 2 == 0) 1 + n / 2\n                else {\n     \
    \               var a = g(n - 1)\n                    var b = g(n - 2)\n     \
    \               var c = g(n + 1)\n                    a + b + c\n            \
    \    }\n            }\n        }\n        (1l to n).map(i => g(i)).toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 3\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.g$1(tmpv_tg1s0c.scala:24)\n\tat Problem$.tri$$anonfun$1(tmpv_tg1s0c.scala:35)\n\
    \tat scala.runtime.java8.JFunction1$mcJJ$sp.apply(JFunction1$mcJJ$sp.scala:17)\n\
    \tat scala.collection.StrictOptimizedIterableOps.map(StrictOptimizedIterableOps.scala:100)\n\
    \tat scala.collection.StrictOptimizedIterableOps.map$(StrictOptimizedIterableOps.scala:87)\n\
    \tat scala.collection.immutable.NumericRange.map(NumericRange.scala:40)\n\tat\
    \ Problem$.tri(tmpv_tg1s0c.scala:35)\n\tat Problem$.main(tmpv_tg1s0c.scala:38)\n\
    \tat Problem.main(tmpv_tg1s0c.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Main"
  stdout: ''
  timestamp: 1659979656
