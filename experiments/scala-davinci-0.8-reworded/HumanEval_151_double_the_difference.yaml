name: HumanEval_151_double_the_difference
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a list of numbers, return the sum of squares of the numbers\n    //\
  \ in the list that are odd. Ignore numbers that are negative or not integers.\n\
  \    // >>> doubleTheDifference((List[Float](1l.toLong, 3l.toLong, 2l.toLong, 0l.toLong)))\n\
  \    // (10l)\n    // >>> doubleTheDifference((List[Float](-1l.toLong, -2l.toLong,\
  \ 0l.toLong)))\n    // (0l)\n    // >>> doubleTheDifference((List[Float](9l.toLong,\
  \ -2l.toLong)))\n    // (81l)\n    // >>> doubleTheDifference((List[Float](0l.toLong)))\n\
  \    // (0l)\n    // If the input list is empty, return 0.\n    def doubleTheDifference(lst\
  \ : List[Float]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(doubleTheDifference((List[Float]()))\
  \ == (0l));\n    assert(doubleTheDifference((List[Float](5.0f.toFloat, 4.0f.toFloat)))\
  \ == (25l));\n    assert(doubleTheDifference((List[Float](0.1f.toFloat, 0.2f.toFloat,\
  \ 0.3f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](-10.0f.toFloat,\
  \ -20.0f.toFloat, -30.0f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](-1.0f.toFloat,\
  \ -2.0f.toFloat, 8.0f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](0.2f.toFloat,\
  \ 3.0f.toFloat, 5.0f.toFloat))) == (34l));\n    assert(doubleTheDifference((List[Float](-9.0f.toFloat,\
  \ -7.0f.toFloat, -5.0f.toFloat, -3.0f.toFloat, -1.0f.toFloat, 1.0f.toFloat, 3.0f.toFloat,\
  \ 5.0f.toFloat, 7.0f.toFloat, 9.0f.toFloat))) == (165l));\n    }\n\n}\n"
completions: ["        val positiveList = lst.filter(x => x > 0l)\n        val evenList\
    \ = positiveList.filter(x => x % 2 == 0l)\n        val oddList = positiveList.filter(x\
    \ => x % 2 != 0l)\n        (((oddList.foldLeft(0l)((x, y) => x + pow(y, 2l).toLong))\
    \ * 2l) - (evenList.foldLeft(0l)((x, y) => x + pow(y, 2l).toLong)))", '        lst.reduceLeft((sum,
    elem) => if (elem.isValidInt && elem.toInt % 2 == 1) { sum + elem * elem } else
    { sum })', "        val squared = lst.map(scala.math.pow(_, 2).toLong)\n     \
    \   val squaredDifference = squared.sum - squared.max\n        squaredDifference\
    \ * 2", "        // RECURSIVE SOLUTION.\n        // sumOfSquaresOfOdd(lst, 0l,\
    \ 0l)\n        // ITERATIVE SOLUTION.\n        sumOfSquaresOfOddIter(lst, 0l,\
    \ 0l)", "        var sum = 0l.toLong\n        for (i <- lst) {\n            if\
    \ (i % 2 == 1) {\n                sum += Math.pow(i, 2).toLong\n            }\n\
    \        }\n        return 2l.toLong * sum", "        val isOdd = (number : Int)\
    \ => (number % 2) == 1\n        val isInteger = (number : Float) => {\n      \
    \      val modulo = number % 1\n            modulo == 0 || modulo == 1\n     \
    \   }\n        val lst2 = lst.filter(isInteger)\n        val lst3 = lst2.filter(isOdd)\n\
    \        val lst4 = lst3.map(pow(_, 2).toLong)\n        val sum = lst4.sum\n \
    \       2 * sum", "        if (lst.isEmpty) 0 else {\n            var max : Float\
    \ = 0.0f\n            var min : Float = 0.0f\n            for (e <- lst) {\n \
    \               if (e > max) max = e\n                if (e < min) min = e\n \
    \           }\n            (max - min) * 2l\n        }", '        ((((lst.foldLeft(0.0f)(((sum,
    i) => (sum + i))))) - ((lst.foldLeft(0.0f)(((sum, i) => (sum + i)))))) * 2l.toLong)',
  '        return 0l', "        var sum = 0l\n        for (i <- lst.indices) {\n \
    \           if (lst(i) >= 0) {\n                sum += pow(lst(i), 2).toLong\n\
    \            }\n        }\n        return sum * 2", "        if (lst.isEmpty)\
    \ 0l\n        else {\n            var max = 0f\n            var min = 0f\n   \
    \         for (i <- lst) {\n                if (i > max) max = i\n           \
    \     if (i < min) min = i\n            }\n            val difference = max -\
    \ min\n            (difference * difference).toLong\n        }", "        val\
    \ n = lst.length\n        if (n == 0) return 0\n        val positiveEven = lst.filter(x\
    \ => x >= 0 && x % 2 == 0)\n        var sum = 0\n        positiveEven.foreach(x\
    \ => sum += x)\n        val positiveOdd = lst.filter(x => x >= 0 && x % 2 == 1)\n\
    \        var sumSquare = 0\n        positiveOdd.foreach(x => sumSquare += x *\
    \ x)\n        return (sum - sumSquare) * 2", '        lst.filter((x) => (x.isValidInt)
    && (x > 0l.toLong)).map((x) => x * x).sum.toLong', "        var max = lst.max\n\
    \        var min = lst.min\n        return (max - min) * 2", "        def a(lst\
    \ : List[Float]) : Float = {\n            if (lst.isEmpty) {\n               \
    \ return 0f\n            }\n            if ((lst.head < 0f)) {\n             \
    \   return (a(lst.tail))\n            }\n            if (((lst.head.toInt.toFloat)\
    \ != (lst.head))) {\n                return (a(lst.tail))\n            }\n   \
    \         return (((lst.head * lst.head) + (a(lst.tail))))\n        }\n      \
    \  def b(lst : List[Float]) : Float = {\n            if (lst.isEmpty) {\n    \
    \            return 0f\n            }\n            if (((lst.head.toInt.toFloat)\
    \ != (lst.head))) {\n                return (b(lst.tail))\n            }\n   \
    \         if ((lst.head >= 0f)) {\n                return (b(lst.tail))\n    \
    \        }\n            return (((lst.head * lst.head) + (b(lst.tail))))\n   \
    \     }\n        return (((a(lst) - b(lst)) * 2l.toLong).toLong)", '        (lst.filter(n
    => ((n % 2) == 1)).map(n => pow(n, 2))).fold(0l)(_ + _).toLong', "        val\
    \ acc = 0l.toLong\n        var diff = acc\n        var counter = acc\n       \
    \ val listSize = lst.length\n        while(counter < listSize) {\n           \
    \ if(lst(counter) % 2 == 0) {\n                diff -= lst(counter)\n        \
    \    } else {\n                diff += lst(counter)\n            }\n         \
    \   counter += 1\n        }\n        diff * 2", '        return lst.filter(_.isValidInt).filter(_
    % 2 != 0).map(x => x * x).sum.toLong', "        var total : Long = 0l\n      \
    \  for (number <- lst) {\n            if (number > 0 && number % 1 == 0) {\n \
    \               if (number % 2 == 1) {\n                    total += (number *\
    \ number)\n                }\n            }\n        }\n        total * 2", '        return
    0l', "        // TODO: Write a solution here.\n        0l", '        lst.map(x
    => if (x > 0) pow(x, 2).toLong else 0).sum - 2 * lst.map(x => if (x > 0) x.toLong
    else 0).sum', "        def square(x : Float) : Long = {\n            return (x\
    \ * x).toLong\n        }\n        def sum_of_squares(lst : List[Float]) : Long\
    \ = {\n            lst match {\n                case Nil => 0l\n             \
    \   case x :: xs => {\n                    if (x % 2l.toLong == 0l.toLong) {\n\
    \                        return sum_of_squares(xs)\n                    }\n  \
    \                  else {\n                        return square(x) + sum_of_squares(xs)\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ 2l.toLong * sum_of_squares(lst)", "        def helper(lst : List[Float], current\
    \ : Long) : Long = {\n            if (lst.isEmpty) {\n                return current\n\
    \            }\n            val head = lst.head\n            if (floor(head) ==\
    \ head && head > 0l) {\n                helper(lst.tail, current + head * head)\n\
    \            } else {\n                helper(lst.tail, current)\n           \
    \ }\n        }\n        return helper(lst, 0l)", "        def f(lst : List[Float],\
    \ acc : Long) : Long = {\n            lst match {\n                case Nil =>\
    \ acc\n                case hd :: tl => if (hd % 2 == 0) f(tl, acc) else {\n \
    \                   val s = hd * hd\n                    val diff = s - acc\n\
    \                    f(tl, acc + 2 * diff)\n                }\n            }\n\
    \        }\n        f(lst, 0)", "        var sum : Long = 0l\n        var min\
    \ : Long = 0l\n        var max : Long = 0l\n        var ints : List[Long] = List()\n\
    \        for (i <- lst) {\n            if (i % 1 == 0) {\n                ints\
    \ = ints ++ List(i.toLong)\n            }\n        }\n        for (i <- ints)\
    \ {\n            if (i > 0) {\n                sum = sum + (i * i)\n         \
    \       if (min == 0) {\n                    min = i\n                }\n    \
    \            else if (i < min) {\n                    min = i\n              \
    \  }\n                if (i > max) {\n                    max = i\n          \
    \      }\n            }\n        }\n        return 2 * (max - min)", "       \
    \ val isPos = (x : Float) => x >= 0\n        val isInt = (x : Float) => x.isWhole\n\
    \        val a = lst.filter(isPos).filter(isInt).map(x => x * x).sum\n       \
    \ val b = lst.filter(isPos).filter(isInt).sum\n        (a - b * b).toLong", " \
    \       var sum : Long = 0l;\n        for (i <- lst) {\n            if (i > 0)\
    \ {\n                sum += (i * i).toLong;\n            }\n        }\n      \
    \  sum * 2l;", "        val squares = lst.map((x) => if (x % 2 == 0) x * x else\
    \ 0)\n        val sumSquares = squares.reduce((a, b) => a + b)\n        val smallestValue\
    \ = squares.min\n        (sumSquares - smallestValue) * 2", "        var sum :\
    \ Long = 0l\n        var sumOfSquares : Long = 0l\n        for (num <- lst) {\n\
    \            if (num % 2 == 1) {\n                sum += num\n               \
    \ sumOfSquares += num * num\n            }\n        }\n        val squareOfSum\
    \ : Long = sum * sum\n        return (squareOfSum - sumOfSquares)", "        //\
    \ your solution to Problem goes here\n        var list = lst.filter(_ > 0)\n \
    \       var sumofSquares = list.map(pow(_, 2)).reduce(_ + _)\n        return (sumofSquares\
    \ * 2).toLong", '        throw new NotImplementedError()', "        lst.map(x\
    \ =>\n            if (x > 0 && x.isValidInt)\n                pow(x.toInt, 2)\n\
    \            else 0.0\n        ).sum.toLong * 2", "        if (lst.length == 0)\
    \ 0 else {\n            val (evens, odds) = lst.partition(x => x % 2 == 0)\n \
    \           //println(evens)\n            //println(odds)\n            val eSq\
    \ = evens.map(x => x * x).sum\n            val oSq = odds.map(x => x * x).sum\n\
    \            (eSq - oSq) * 2\n        }", "        val a = lst.filter(i => (i\
    \ > 0l && i == Math.floor(i))).map(i => (i * i)).sum\n        val b = lst.filter(i\
    \ => (i > 0l && i == Math.floor(i))).sum\n        (a - (b * b)).toLong", "   \
    \     var sum : Long = 0l\n        var sqSum : Long = 0l\n        for (i <- lst)\
    \ {\n            val iInt : Int = i.toInt\n            if (iInt.isValidInt &&\
    \ iInt >= 0) {\n                sum += iInt\n                sqSum += iInt * iInt\n\
    \            }\n        }\n        val d : Long = (sum * sum) - sqSum\n      \
    \  d * 2", '        0l', "        val newList = ListBuffer[Long]()\n        val\
    \ sum = lst.foreach(x => if(x.isValidInt && x >= 0) newList += x.toLong)\n   \
    \     val average = newList.sum.toFloat / newList.length\n        val difference\
    \ = newList.map(x => (x - average) * (x - average))\n        (difference.sum *\
    \ 2).toLong", "        // your solution here\n        var sum1 = 0.0\n       \
    \ var sum2 = 0.0\n        var a = 0\n        while (a < lst.length) {\n      \
    \      if (lst(a) % 2 == 0) {\n                sum1 += lst(a) * lst(a)\n     \
    \       }\n            else {\n                sum2 += lst(a) * lst(a)\n     \
    \       }\n            a += 1\n        }\n        (2*(sum2 - sum1)).toLong", '        return
    0l', "        // Your answer here\n        lst.filter(x => x % 2 == 1).map(x =>\
    \ x * x).sum.toLong", '        // your code here', "        val lst2 = lst.filter(l\
    \ => (l > 0) && (l % 1 == 0))\n        if (lst2.length == 0) 0l else (lst2.max\
    \ - lst2.min) * 2", "        if (lst.isEmpty) return 0l\n        var lst2 = lst.filter(x\
    \ => x > 0 && x % 1 == 0 && x % 2 == 1)\n        var sum = lst2.foldLeft(0.0)((a,b)\
    \ => a + pow(b, 2))\n        2 * sum", "        var result : Long = 0l\n     \
    \   var max : Float = 0\n        var min : Float = 0\n        for (number <- lst)\
    \ {\n            if (number % 1 == 0 && number > 0) {\n                if (number\
    \ > max) {\n                    max = number\n                }\n            \
    \    if (number < min) {\n                    min = number\n                }\n\
    \            }\n        }\n        result = ((max - min) * 2).toLong\n       \
    \ return result", "        lst.foldLeft(0l)((a, b) => {\n                if (b\
    \ > 0 && b % 1 == 0) a + b * b\n                else a\n            })", "   \
    \     // your code here\n        var sumOfSquares : Long = 0\n        var sumOfNumbers\
    \ : Long = 0\n        for (i <- lst) {\n            if (i % 2 != 0 && i >= 0)\
    \ {\n                sumOfSquares += pow(i, 2).toLong\n                sumOfNumbers\
    \ += i.toLong\n            }\n        }\n        (sumOfSquares - (2 * sumOfNumbers))",
  "        var n = lst.length\n        if (n == 0) 0\n        else {\n           \
    \ var sum1 = lst.map(x => x.toLong).sum\n            var lst2 = lst.map(x => abs(x)).filter(x\
    \ => x % 1 == 0).map(x => x.toLong)\n            var sum2 = lst2.sum\n       \
    \     var diff = sum1 - sum2\n            2l * diff\n        }", "        // Your\
    \ code goes here.\n        // You can add helper functions as needed.\n      \
    \  var sum = 0l.toLong\n        var squared = 0l.toLong\n        var diff = 0l.toLong\n\
    \        var double = 0l.toLong\n        for (i <- lst) {\n            if (i.isValidInt\
    \ && (i % 2) == 1) {\n                sum += i.toInt\n                squared\
    \ += i * i\n            }\n        }\n        diff = sum * sum - squared\n   \
    \     double = diff * 2\n        return double", "        return lst.foldLeft(0l)((m,\
    \ item) => {\n            if (item >= 0 && (item % 1 == 0)){\n               \
    \ return m + (item * item)\n            } else {\n                return m\n \
    \           }\n        })", "        var ret : Long = 0\n        ret", "     \
    \   if (lst.length == 0) 0l\n        else {\n            val lst2 = lst.filter(x\
    \ => !(x < 0l.toLong) && (x - x.toLong == 0))\n            val lst3 = lst2.filter(x\
    \ => x.toLong % 2l.toLong == 1l.toLong)\n            (pow(lst3.sum, 2l.toLong)\
    \ - pow(lst3.sum, 1l.toLong)).toLong\n        }", "        if (lst.isEmpty) 0l\n\
    \        else {\n            var sum : Float = 0f\n            var squaredSum\
    \ : Float = 0f\n            for (i <- lst) {\n                if (i > 0 && i %\
    \ 1 == 0) {\n                    sum += i\n                    squaredSum += i\
    \ * i\n                }\n            }\n            (2 * squaredSum - sum * sum).toLong\n\
    \        }", "        val squared = lst.map((x) => x * x)\n        squared.sum.toLong",
  "        var sum = 0f\n        for (e <- lst) {\n            sum += pow(e, 2f)\n\
    \        }\n        sum.toLong", "        if (lst.isEmpty) 0\n        else {\n\
    \            val sum = lst.filter(x => x > 0 && x.isValidInt).map(x => x.toInt).map(x\
    \ => x * x).sum\n            sum * 2\n        }", "        val emptyList : List[Float]\
    \ = List[Float]()\n        lst match {\n            case emptyList => 0l\n   \
    \         case _ => {\n                val diffList : List[Float] = Problem.difference(lst)\n\
    \                val value : Long = Problem.squareSum(diffList).toLong\n     \
    \           value * 2l\n            }\n        }", "        if (lst.isEmpty) {\n\
    \            return 0l\n        }\n        else {\n            // Grab the minimum\
    \ and maximum.\n            val res = lst.min :: lst.max :: Nil\n            //\
    \ Compute the difference and return the result.\n            return 2 * (res(1)\
    \ - res(0))\n        }", '        lst.filter((_ < 0) == false).filter((_ % 1)
    == 0).map((_ * _)).reduceLeft((x, y) => x + y)', "        var sum : Long = 0l;\n\
    \        lst.foreach(elem => {\n            if ((floor(elem) == elem) && (elem\
    \ >= 0)) {\n                sum += pow(elem, 2).toLong;\n            }\n     \
    \   });\n        return sum;", "        var a : Long = 0\n        var b : Long\
    \ = 0\n        for (i <- lst.indices) {\n            if (lst(i) % 2l == 0l) {\n\
    \                b += lst(i).toLong\n            } else {\n                a +=\
    \ lst(i).toLong\n            }\n        }\n        (2l * (a - b))", "        //\
    \ Your answer here\n        return 0", "        val sum1 = lst.filter(p => p >\
    \ 0).filter(p => p % 1 == 0).map(p => p * p).sum\n        val sum2 = lst.filter(p\
    \ => p < 0).filter(p => p % 1 == 0).map(p => p * p).sum\n        return (sum1\
    \ - sum2) * 2", "        def isInteger(x : Float) : Boolean = {\n            if\
    \ (x == floor(x)) return true\n            return false\n        }\n        def\
    \ isOdd(x : Float) : Boolean = {\n            if (x % 2l == 1l) return true\n\
    \            return false\n        }\n        var d : Long = 0l\n        var s\
    \ : Long = 0l\n        for (x <- lst) {\n            if (isInteger(x) && x >=\
    \ 0l) {\n                if (isOdd(x)) {\n                    d += floor(x).toLong\
    \ * floor(x).toLong\n                } else {\n                    s += floor(x).toLong\
    \ * floor(x).toLong\n                }\n            }\n        }\n        return\
    \ (d - s) * 2l", '        0l', '        lst.filter(_.isValidInt).map(_.toInt).filter(_
    % 2 == 1).map(pow(_, 2)).sum.toLong', '        return lst.filter(x => (floor(x)
    == x) && (x >= 0.0f)).map(x => pow(x, 2.0f).toLong).reduceLeft((x, y) => x + y)',
  "        val counts = lst.foldLeft(0l.toLong, 0l.toLong)((x, y) => {\n         \
    \   y match {\n                case _ if y < 0f => (x._1, x._2)\n            \
    \    case _ if (y % 1f) != 0f => (x._1, x._2)\n                case _ if y.toLong\
    \ % 2l == 0l => (x._1, x._2 + y.toLong)\n                case _ => (x._1 + y.toLong,\
    \ x._2)\n            }\n        })\n        (counts._1 - counts._2) * 2l", " \
    \       var ans : Long = 0l\n        var fst : Long = 0l\n        var sec : Long\
    \ = 0l\n        if (lst.length == 0) {\n            ans = 0l\n        } else {\n\
    \            for (i <- 0 to lst.length - 1) {\n                if (lst(i) == 0)\
    \ {\n                    if (fst == 0) {\n                        fst = 0l\n \
    \                   } else {\n                        sec = 0l\n             \
    \       }\n                } else if (lst(i) >= 0 && lst(i) % 1 == 0) {\n    \
    \                if (fst == 0) {\n                        fst = lst(i).toLong\n\
    \                    } else {\n                        sec = lst(i).toLong\n \
    \                   }\n                }\n            }\n            ans = (fst\
    \ - sec) * (fst - sec)\n        }\n        return ans", "        var result :\
    \ Long = 0\n        lst.foreach((e : Float) => { if (e.isValidInt && e.toInt %\
    \ 2 == 1) result += (e.toInt * e.toInt) })\n        return result", "        //YOUR\
    \ CODE HERE\n        0", "        var s : Long = 0l;\n        for (i <- lst) {\n\
    \            if (i > 0l && i % 1l == 0l) {\n                s += i * i;\n    \
    \        }\n        }\n        return 2l * s;", "        // Your code here\n \
    \       var total_of_odds = 0l.toLong\n        var total_of_evens = 0l.toLong\n\
    \        var count = 0l.toLong\n        var is_even = true\n        for (x <-\
    \ lst) {\n          if (x.toInt % 2 == 0 && x.toInt >= 0) {\n            is_even\
    \ = true\n          } else if (x.toInt % 2 == 1 && x.toInt >= 0) {\n         \
    \   is_even = false\n          } else {\n            total_of_odds = total_of_odds\n\
    \            total_of_evens = total_of_evens\n          }\n          if (is_even\
    \ == true) {\n            total_of_evens = total_of_evens + x.toInt * x.toInt\n\
    \          } else {\n            total_of_odds = total_of_odds + x.toInt * x.toInt\n\
    \          }\n        }\n        count = total_of_evens - total_of_odds\n    \
    \    count = count * 2\n        return count", "        if(lst.isEmpty) 0l\n \
    \       else lst.map(elm => elm.toLong).filter(elm => elm > 0).filter(elm => elm\
    \ % 2 == 1).foldLeft(0l)((acc, elm) => acc + (elm * elm))", "        val positiveList\
    \ = lst.filter(x => x > 0 && x % 1 == 0)\n        if (positiveList.length == 0)\
    \ return 0l\n        (positiveList.map(x => pow(x, 2.0)).sum - pow(positiveList.sum,\
    \ 2.0)).toLong", "        if (lst.length < 2) {\n            0l\n        } else\
    \ {\n            2l * (abs(lst(0) - lst(1)))\n        }", '        return lst.filter(x
    => x > 0 && (x % 1 == 0)).map(x => x.toLong).foldLeft(0l)((acc, x) => acc + x
    * x)', "        // lst match {\n        //     case x :: Nil => x.intValue * x.intValue\n\
    \        //     case x :: xs => x.intValue * x.intValue + doubleTheDifference(xs)\n\
    \        //     case _ => 0l\n        // }\n        (for (x <- lst) yield { x.intValue\
    \ * x.intValue}).sum.toLong", "        var sum = 0l.toLong\n        for (i <-\
    \ lst) {\n            if (i.isValidInt) {\n                sum += pow(i.toInt,\
    \ 2).toLong\n            }\n        }\n        return sum * 2", '        (List[Long](0l.toLong)
    ::: lst.map(x => x.toLong)).filter(x => x % 2 == 1).map(x => x * x).sum', "  \
    \      // Write your code here\n        val l = lst.filter((x : Float) => isOdd(x)).map((x\
    \ : Float) => x * x)\n        return if (l.length == 0) 0 else 2 * l.sum", " \
    \       var sum : Long = 0\n        for (i <- lst) {\n            if (i > 0 &&\
    \ i % 1 == 0) {\n                sum += (i * i)\n            }\n        }\n  \
    \      return (sum * 2)", '        return lst.filter(x => x >= 0 && x % 1 == 0).map(x
    => x * x).sum.toLong * 2', "        var sum : Long = 0\n        for (i <- lst)\
    \ {\n            sum += pow(i, 2).toLong\n        }\n        return 2 * sum",
  '        lst.filter((x : Float) => (x > 0)).foldLeft(0l.toLong)((acc : Long, x :
    Float) => (x - acc).toLong).toLong', "        val sum = lst.foldLeft(0)((a, b)\
    \ => a + pow(b, 2).toLong)\n        sum", "        val r = 0l\n        r", " \
    \       // BEGIN SOLUTION\n        if (lst.length == 0) return 0\n        val\
    \ lst2 = lst.filter(x => x % 1 == 0 && x > 0)\n        val squares = lst2.map(x\
    \ => x * x)\n        squares.sum.toLong * 2\n        // END SOLUTION", "     \
    \   // Write your code here\n        return 0l", "        var largest : Long =\
    \ 0l;\n        var smallest : Long = 0l;\n        for (item <- lst) {\n      \
    \      val l : Long = item.toLong;\n            if (l < smallest) {\n        \
    \        smallest = l;\n            }\n            if (l > largest) {\n      \
    \          largest = l;\n            }\n        }\n        return ((largest *\
    \ largest) - (smallest * smallest));", "        var res = 0l\n        if (lst.length\
    \ != 0) {\n            val sortedLst = lst.sorted\n            val max = sortedLst(sortedLst.length\
    \ - 1)\n            val min = sortedLst(0)\n            res = (max - min) * 2\n\
    \        }\n        return res", '        (0l)', '        // YOUR CODE HERE',
  '        (lst).foldLeft(0)((sum, value) => sum + pow(value, 2).toLong)', "     \
    \   var sum : Long = 0\n        for (i <- lst) {\n            if (i % 2 == 1)\
    \ {\n                sum += i.toLong * i.toLong\n            }\n        }\n  \
    \      return sum", "        // your code here\n        var lst2 : List[Long]\
    \ = lst.filter(x => x > 0).map(x => x.toLong).filter(x => x % 2 == 1).map(x =>\
    \ x * x)\n        lst2.foldLeft(0l)((a, b) => a + b)", '        return 0l', " \
    \       val posNumbers = lst.filter(x => x > 0)\n        val doublePosNumbers\
    \ = posNumbers.map(x => x * 2)\n        val doubledNumbers = posNumbers.zip(doublePosNumbers)\n\
    \        val oddNumbers = doubledNumbers.filter(x => x._1 % 2 != 0)\n        return\
    \ oddNumbers.map(x => x._2).sum.toLong", '        throw new Exception("Not implemented
    yet")', "        // BEGIN SOLUTION\n        val filtered = lst.filter(e => e %\
    \ 1 == 0 && e > 0)\n        if (filtered.isEmpty) return 0\n        filtered.map(e\
    \ => pow(e, 2)).sum.toLong * 2\n        // END SOLUTION", "        val odds =\
    \ (lst.filter(x => x > 0 && x % 2 == 1 && x == x.floor)).map(math.pow(_, 2))\n\
    \        val evens = (lst.filter(x => x > 0 && x % 2 == 0 && x == x.floor)).map(math.pow(_,\
    \ 2))\n        val sumOfSquaresOfOdds = if (odds.isEmpty) 0 else odds.reduce(_\
    \ + _)\n        val sumOfSquaresOfEvens = if (evens.isEmpty) 0 else evens.reduce(_\
    \ + _)\n        ((sumOfSquaresOfOdds - sumOfSquaresOfEvens) * 2l).toLong", " \
    \       val oddSquares = lst.filter((num : Float) => (num >= 0) && (num % 1 ==\
    \ 0) && (num % 2 == 1)).map((num : Float) => num * num)\n        (oddSquares.sum\
    \ * 2).toLong", "        if (lst.isEmpty) {\n            0l\n        } else {\n\
    \            def iter(lst : List[Float], s : Long) : Long = {\n              \
    \  if (lst.isEmpty) {\n                    s\n                } else {\n     \
    \               val hd = lst.head\n                    if (hd > 0l && hd == hd.toLong)\
    \ {\n                        iter(lst.tail, s + (hd.toLong * hd.toLong))\n   \
    \                 } else {\n                        iter(lst.tail, s)\n      \
    \              }\n                }\n            }\n            val s = iter(lst,\
    \ 0l)\n            s * 2l\n        }", '        lst.filter(n => n % 2 != 0 &&
    n > 0).map(n => n * n).sum.toLong', '        lst.filter((x : Float) => ((x - (x.toLong))
    == 0)).filter((x : Float) => (x % 2) == 1).map((x : Float) => x*x).sum.toLong
    * 2', '        return 0l', "        // list of squares\n        // lst.map(x =>\
    \ x * x)\n        val sum_of_squares = (for (i <- lst if (i > 0) & (i % 1 == 0))\
    \ yield i * i).sum\n        sum_of_squares * 2", "        val (lp, ln) = lst.partition(_\
    \ >= 0)\n        val posit = lp.filter(_ == _.toLong).map(pow(_, 2).toLong).sum\n\
    \        val negat = ln.filter(_ == _.toLong).map(pow(_, 2).toLong).sum\n    \
    \    2 * (posit - negat)", "        // Now do the work\n        var sum : Long\
    \ = 0l\n        var squares : Long = 0l\n        for (element <- lst) {\n    \
    \        if (element > 0 && element == element.toLong) {\n                if (element\
    \ % 2 == 1) {\n                    sum += element.toLong\n                   \
    \ squares += element.toLong * element.toLong\n                }\n            }\n\
    \        }\n        return 2 * (squares - sum)", "        var temp = lst.filter((x)\
    \ => x % 1 == 0)\n        var answer = 0l\n        if (temp.size != 0) {\n   \
    \         var numbers = temp.map((x) => x.toLong)\n            var positive =\
    \ numbers.filter((x) => x > 0)\n            if (positive.size != 0) {\n      \
    \          var min = positive.min\n                var max = positive.max\n  \
    \              answer = pow(max - min, 2).toLong\n            }\n        }\n \
    \       return answer", "        // >>> doubleTheDifference((List[Float](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 0l.toLong)))\n        // (10l)\n        // >>> doubleTheDifference((List[Float](-1l.toLong,\
    \ -2l.toLong, 0l.toLong)))\n        // (0l)\n        // >>> doubleTheDifference((List[Float](9l.toLong,\
    \ -2l.toLong)))\n        // (81l)\n        // >>> doubleTheDifference((List[Float](0l.toLong)))\n\
    \        // (0l)\n        // If the input list is empty, return 0.\n        if\
    \ (lst.length == 0) {\n            0l\n        } else {\n            val map =\
    \ Map[Float, Float]()\n            var sum = 0l\n            for (i <- 0 to lst.length\
    \ - 1) {\n                if (lst(i) > 0 && floor(lst(i)) == lst(i)) {\n     \
    \               map += (lst(i) -> lst(i))\n                }\n            }\n\
    \            val lst1 = map.keys.toList\n            lst1.sort((a : Float, b :\
    \ Float) => a > b)\n            if (lst1.length == 0) {\n                0l\n\
    \            } else {\n                for (i <- 0 to lst1.length - 1) {\n   \
    \                 if (i == 0) {\n                        sum += 2 * pow(lst1(i),\
    \ 2).toLong\n                    } else {\n                        sum += pow(lst1(i),\
    \ 2).toLong\n                    }\n                }\n                sum\n \
    \           }\n        }", "        def loop(list: List[Float], result: Long)\
    \ : Long = {\n            if (list.isEmpty)\n                result\n        \
    \    else if (list.tail.isEmpty)\n                result\n            else if\
    \ (list.head % 1 == 0 && list.head >= 0)\n                loop(list.tail, result\
    \ + pow(list.head, 2).toLong)\n            else\n                loop(list.tail,\
    \ result)\n        }\n        loop(lst, 0)", "        // Your solution goes here\n\
    \        var result : Long = 0\n        var max_val : Long = 0\n        var min_val\
    \ : Long = 0\n        var i : Int = 0\n        while (i < lst.length) {\n    \
    \        {\n                if (lst(i) % 1 == 0 && lst(i) >= 0) {\n          \
    \          if (max_val < lst(i).toLong) max_val = lst(i).toLong\n            \
    \        if (min_val > lst(i).toLong) min_val = lst(i).toLong\n              \
    \  }\n            }\n            ({\n                i += 1; i - 1\n         \
    \   })\n        }\n        result = ((max_val - min_val) * 2)\n        return\
    \ result", "        // BEGIN SOLUTION\n        val filtered = lst.filter(x =>\
    \ x % 1 == 0 && x > 0)\n        val squared = filtered.map(x => pow(x, 2).toLong)\n\
    \        val doubled = 2 * squared.reduceLeft(_ + _)\n        doubled\n      \
    \  // END SOLUTION", "        var sum : Long = 0l\n        var squared : Long\
    \ = 0l\n        lst.foreach((x) => {\n                if (x.isValidInt) {\n  \
    \                  val t = x.toInt\n                    if (t > 0) {\n       \
    \                 sum += t\n                        squared += (t * t)\n     \
    \               }\n                }\n            })\n        2 * (squared - sum)",
  "\t\t\tvar tot = 0l.toLong\n\t\t\tvar t = 0l.toLong\n\t\t\tfor (e <- lst) {\n\t\t\
    \t\tif (e > 0 && (e % 1) == 0) {\n\t\t\t\t\tt += e * e\n\t\t\t\t}\n\t\t\t}\n\t\
    \t\treturn t * 2", "        lst.foldLeft(0l.toLong)((sum, number) => number match\
    \ {\n            case 0 => sum\n            case i if i % 2 == 0 => sum\n    \
    \        case i if i < 0 => sum\n            case _ => sum + (pow(number, 2).toLong\
    \ * 2)\n        })", '        lst.filter(num => num % 2 != 0).map(pow(_, 2)).sum.toLong',
  "        // your code goes here\n        if (lst.isEmpty) return 0l\n        else\
    \ return max(lst.head, lst.tail.head) * 2 - min(lst.head, lst.tail.head)", '        return
    0', "        if (lst.isEmpty) {\n            return 0\n        }\n        val\
    \ diff = lst.max - lst.min\n        return diff * 2", "        if (lst.length\
    \ == 0) return 0\n        val positives = lst.filter(x => (x > 0 && x == x.toLong))\n\
    \        val negatives = lst.filter(x => (x < 0 && x == x.toLong))\n        (positives.map(x\
    \ => x * x).sum - negatives.map(x => x * x).sum) * 2", '      lst.filter(_ > 0).map(x
    => x * x).sum.toLong', "        if (lst.isEmpty) return 0l.toLong\n        if\
    \ (lst.length == 1) {\n            if (lst(0) % 2 == 0) return 0l.toLong\n   \
    \         return lst(0) * lst(0)\n        }\n        var min = lst(0)\n      \
    \  var max = lst(0)\n        for (i <- 1 to lst.length - 1) {\n            if\
    \ (lst(i) % 2 == 0) continue\n            if (lst(i) < min) min = lst(i)\n   \
    \         if (lst(i) > max) max = lst(i)\n        }\n        return (max - min)\
    \ * (max - min)", "        def loop(lst : List[Float], res : Float) : Float =\
    \ {\n            if (lst.isEmpty) res\n            else {\n                val\
    \ elem = lst.head\n                if (elem > 0 && elem % 1 == 0) loop(lst.tail,\
    \ res + pow(elem, 2).toFloat)\n                else loop(lst.tail, res)\n    \
    \        }\n        }\n        loop(lst, 0).toLong", '        (lst.foldLeft(0l.toLong)((sum,
    v) => sum + Math.pow(v, 2).toLong)).toLong', '        lst.filter(x => x > 0 &&
    x.toLong == x).map(x => pow(x, 2).toLong).sum', "        {\n            var num\
    \ : Long = 0l.toLong\n            for (x <- lst) {\n                if ((x ==\
    \ (floor(x).toInt).toFloat) && (x >= 0l.toLong)) {\n                    num =\
    \ (num + (pow(x, 2).toLong)).toLong\n                }\n            }\n      \
    \      num\n        }", "        var sum = 0l.toLong\n        var mx = 0l.toLong\n\
    \        var mn = 0l.toLong\n        for (i <- lst) {\n            var e = i.toLong\n\
    \            if (e % 2 == 1) {\n                if (e > mx) mx = e\n         \
    \       if (e < mn) mn = e\n            }\n        }\n        if (mx > abs(mn))\
    \ {\n            sum = mx * mx\n        } else {\n            sum = mn * mn\n\
    \        }\n        sum = sum * 2\n        return sum", "        if (lst.isEmpty)\
    \ return 0l\n        val l = lst.filter((x) => (x >= 0 && x % 1 == 0))\n     \
    \   val l2 = l.filter((x) => (x % 2 == 1))\n        var sum = 0l\n        for\
    \ (x <- l2) sum += (x * x)\n        return 2 * sum", "        val a = lst.filter(x\
    \ => x > 0 && x % 1 == 0).map(y => y.toLong).map(z => z * z).reduce((a : Long,\
    \ b : Long) => a + b)\n        val b = lst.filter(x => x > 0 && x % 1 == 0).map(y\
    \ => y.toLong).reduce((a : Long, b : Long) => a + b)\n        (a - b * b).toLong",
  "        // Your Code Here\n        return 0l", "\treturn 0l;", "\t\t\t0", "   \
    \     // >>> doubleTheDifference((List[Float](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 0l.toLong)))\n        // doubleTheDifference(List[Float](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 0l.toLong))\n        // 1l.toLong + doubleTheDifference(List[Float](3l.toLong,\
    \ 2l.toLong, 0l.toLong))\n        // 1l.toLong + (3l.toLong + doubleTheDifference(List[Float](2l.toLong,\
    \ 0l.toLong)))\n        // 1l.toLong + (3l.toLong + (2l.toLong + doubleTheDifference(List[Float](0l.toLong))))\n\
    \        // 1l.toLong + (3l.toLong + (2l.toLong + (0l.toLong + doubleTheDifference(List[Float]()))))\n\
    \        // 1l.toLong + (3l.toLong + (2l.toLong + (0l.toLong + 0l)))\n       \
    \ // (1l.toLong) + (3l.toLong) + (2l.toLong) + (0l.toLong)\n        // (1l) +\
    \ (3l) + (2l) + (0l)\n        // (10l)\n        // doubleTheDifference: (lst:\
    \ List[Float])Long\n        if (lst.isEmpty) {\n            0l\n        } else\
    \ {\n            val x = lst.head;\n            val xs = lst.tail;\n         \
    \   x + doubleTheDifference(xs)\n        }", "        var diff = 0f\n        for\
    \ (i <- lst) {\n            if (i > 0 && i == i.toInt) {\n                diff\
    \ += i\n            }\n        }\n        diff * diff", "        // your solution\
    \ goes here\n        def square(x : Float) : Long = {\n            val result\
    \ = x.toLong * x.toLong\n            result\n        }\n        def inner(lst\
    \ : List[Float], result : Long) : Long = {\n            lst match {\n        \
    \        case Nil => result\n                case head :: tail => {\n        \
    \            if (floor(head).toLong % 2 == 0 || head < 0) {\n                \
    \        inner(tail, result)\n                    } else {\n                 \
    \       inner(tail, result + square(head))\n                    }\n          \
    \      }\n            }\n        }\n        inner(lst, 0)", "        var double\
    \ : Long = 0\n        for (i <- lst) {\n            if (i > 0 && i % 1 == 0) {\n\
    \                double += (i * i)\n            }\n        }\n        double *\
    \ 2", '        lst.filter(e => e.isValidInt && e % 2 == 1).map(x => x * x).sum.toLong',
  "        if (lst.isEmpty) {\n            0l\n        } else {\n            def getNumber(number\
    \ : Float) : Long = {\n                if (number % 1 == 0 && number > 0) {\n\
    \                    pow(number, 2).toLong\n                } else {\n       \
    \             0l\n                }\n            }\n            def getPairs(element\
    \ : Float, lst : List[Float]) : List[(Float, Float)] = {\n                if (lst.isEmpty)\
    \ {\n                    List[(Float, Float)]()\n                } else {\n  \
    \                  ((element, lst.head)) :: getPairs(element, lst.tail)\n    \
    \            }\n            }\n            def getDifferences(pairs : List[(Float,\
    \ Float)]) : List[Long] = {\n                if (pairs.isEmpty) {\n          \
    \          List[Long]()\n                } else {\n                    val result\
    \ = pairs.head._1 - pairs.head._2\n                    if (result > 0) {\n   \
    \                     (result * 2).toLong :: getDifferences(pairs.tail)\n    \
    \                } else {\n                        getDifferences(pairs.tail)\n\
    \                    }\n                }\n            }\n            def sumDifferences(lst\
    \ : List[Long]) : Long = {\n                if (lst.isEmpty) {\n             \
    \       0l\n                } else {\n                    lst.head + sumDifferences(lst.tail)\n\
    \                }\n            }\n            sumDifferences(getDifferences(getPairs(lst.head,\
    \ lst.tail)))\n        }", "      // your code goes here\n      return -1l", " \
    \       def inner_loop(nums : List[Float], accum : Float) : Float = {\n      \
    \      if (nums.length == 0) accum\n            else {\n                val num\
    \ = nums.head\n                if (num > 0) inner_loop(nums.tail, accum + pow(num,\
    \ 2).toFloat)\n                else inner_loop(nums.tail, accum)\n           \
    \ }\n        }\n        inner_loop(lst, 0l).toLong", '        // Implement this.',
  "        val newList = lst.filter { (x : Float) => (x % 2 == 1) && (x > 0) }\n \
    \       val sumOfSquares = newList.foldLeft(0l.toLong) { (a : Long, b : Float)\
    \ => a + b * b.toLong }\n        sumOfSquares * 2", '        return 0l', "   \
    \     lst.map(x => \n            if (x.isWhole && x > 0) pow(x, 2).toLong\n  \
    \          else 0l\n        ).sum * 2", "        val max = lst.reduceLeft[Float]((a,\
    \ b) => {if (a > b) a else b})\n        val min = lst.reduceLeft[Float]((a, b)\
    \ => {if (a < b) a else b})\n        ((max - min) * 2l).toLong", '        return
    0', '        lst.map(x => if (x > 0) x else 0).foldLeft(0)((sum, x) => sum + x
    * x).toLong', "        var sum : Long = 0l\n        var min : Long = -1l\n   \
    \     var max : Long = -1l\n        lst.map((x : Float) => {\n            val\
    \ i : Long = round(x)\n            if (i >= 0 && i == x) {\n                if\
    \ (min == -1 || i < min) {\n                    min = i\n                }\n \
    \               if (max == -1 || i > max) {\n                    max = i\n   \
    \             }\n            }\n        })\n        if (min != -1 && max != -1)\
    \ {\n            sum = pow(max - min, 2l).toLong\n        }\n        return sum",
  "        val tup = lst.foldLeft((0l, 0l))((acc, v) => {\n                      \
    \                      val v2 = scala.math.floor(v)\n                        \
    \                    if (v2 % 2 == 0) {\n                                    \
    \            (acc._1, acc._2 + scala.math.pow(v2, 2).toLong)\n               \
    \                             } else {\n                                     \
    \           (acc._1 + scala.math.pow(v2, 2).toLong, acc._2)\n                \
    \                            }\n                                        })\n \
    \       scala.math.pow(tup._1 - tup._2, 2).toLong", "        val t = lst.count((x\
    \ : Float) => true)\n        if (t == 0) return 0\n        val evens = (lst.count((x\
    \ : Float) => (x % 2 == 0)))\n        val odds = (lst.count((x : Float) => (x\
    \ % 2 == 1)))\n        return (odds * odds - evens * evens) * 2l", '        (lst.filter((x
    : Float) => ((x % 2l.toLong) == 1l.toLong)).map((x : Float) => (x * x)).sum *
    2l.toLong).toLong', "        // Fill in the code here, and return the appropriate\
    \ thing.\n        return 0", "        // Your Code Here\n        if (lst.isEmpty)\
    \ 0l\n        else {\n            val oddList = for {\n                i <- lst\n\
    \                if i % 2 == 1 && i >= 0\n            } yield i\n            (oddList.sum\
    \ * oddList.sum).toLong\n        }", "        if (lst.isEmpty) 0 else {\n    \
    \        val diff = (lst.map(x => if (x % 2 == 0) x else -x).sum).toLong\n   \
    \         diff * diff\n        }", '        lst.filter(x => x > 0 && x % 1 ==
    0).map(x => (x * x).toLong).sum', "        val positiveLst = lst.filter(x => x\
    \ > 0 && x.isValidInt).map(x => x.toInt)\n        val squares = positiveLst.map(x\
    \ => x * x)\n        squares.sum.toLong * 2", "        // >>> doubleTheDifference((List[Float](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 0l.toLong)))\n        // (10l)\n        // >>> doubleTheDifference((List[Float](-1l.toLong,\
    \ -2l.toLong, 0l.toLong)))\n        // (0l)\n        // >>> doubleTheDifference((List[Float](9l.toLong,\
    \ -2l.toLong)))\n        // (81l)\n        // >>> doubleTheDifference((List[Float](0l.toLong)))\n\
    \        // (0l)\n        // If the input list is empty, return 0.\n        val\
    \ x = for (i <- lst) yield i\n        val y = for (i <- lst) yield i\n       \
    \ val z = x.zip(y)\n        val a = (for (i <- z if (i._1 != i._2)) yield i._1\
    \ - i._2).sum.toLong\n        val b = a * 2l\n        return b", '        return
    0', '        return 0l', "        val pos : List[Float] = lst.filter(((x : Float)\
    \ => (x >= 0f)))\n        val neg : List[Float] = lst.filter(((x : Float) => (x\
    \ < 0f)))\n        val result : Long = pos.map(((x : Float) => (pow(x, 2f).toLong))).foldLeft(0l)(_\
    \ + _) - neg.map(((x : Float) => (pow(x, 2f).toLong))).foldLeft(0l)(_ + _)\n \
    \       2l * result", "        // your code goes here\n        return lst.filter(p\
    \ => (p % 2 == 1)).map(p => pow(p, 2)).sum.toLong", "        val squares = lst.filter(n\
    \ => n % 2 == 1 && n >= 0).map(m => pow(m, 2))\n        if (squares.isEmpty) return\
    \ 0l\n        val max = squares.max\n        val min = squares.min\n        val\
    \ squareDiff = pow(max - min, 2)\n        (squareDiff * 2).toLong", "        val\
    \ odds = lst.filter((x) => x > 0 && x.isValidInt && x.toInt % 2 == 1)\n      \
    \  val evens = lst.filter((x) => x > 0 && x.isValidInt && x.toInt % 2 == 0)\n\
    \        (odds.map((x) => pow(x, 2).toLong).sum - evens.map((x) => pow(x, 2).toLong).sum)\
    \ * 2", "        val (ls1, ls2) = lst.partition(_ > 0)\n        val (ss1, ss2)\
    \ = (ls1.map(x => x * x).sum, ls2.map(x => x * x).sum)\n        (ss1 - ss2) *\
    \ 2", '        return lst.filter(a => a.isValidInt).filter(a => a.toInt % 2 ==
    1).map(a => a.toInt * a.toInt).sum.toLong * 2', '        if (lst.isEmpty) 0l else
    lst.filter((x) => x > 0l.toLong && x.isValidInt).map((x) => x.toInt).map((x) =>
    pow(x, 2l.toLong).toLong).sum * 2l', "        if (lst.length == 0) return 0\n\
    \        var sum = 0.0f\n        for (n <- lst) {\n            if (n > 0 && (floor(n)\
    \ == n)) {\n                sum += pow(n, 2).toFloat\n            }\n        }\n\
    \        (sum * 2).toLong", "        val lst2 = lst.filter(x => x > 0 && x % 1\
    \ == 0)\n        val lst3 = lst2.filter(x => x % 2 == 1)\n        val lst4 = lst3.map(x\
    \ => x * x)\n        val lst5 = lst4.sum.toLong\n        val lst6 = lst5 * 2\n\
    \        return lst6", "        var n = 0l.toLong\n        var i = 0l.toLong\n\
    \        for (i <- lst) {\n            var s = i * i\n            if ((s > 0l.toLong)\
    \ && (s % 2l.toLong) == 1l.toLong) {\n                n = n + s\n            }\n\
    \        }\n        return n", "        // your code goes here\n        return\
    \ 0l", "        if (lst.isEmpty) {\n            return 0l;\n        }\n      \
    \  val new_lst = lst.filter((x : Float) => x > 0l.toLong);\n        val min =\
    \ new_lst.min;\n        val max = new_lst.max;\n        return (2l.toLong * (max\
    \ - min)).toLong;", "        if (lst.isEmpty) return 0\n        var diff = 0\n\
    \        var sum = 0\n        var first = true\n        for (num <- lst) {\n \
    \           if (num.isValidInt) {\n                if (first) {\n            \
    \        diff = num.toInt\n                    first = false\n               \
    \ }\n                else {\n                    diff = abs(diff - num.toInt)\n\
    \                }\n                sum += num.toInt\n            }\n        }\n\
    \        return (diff * 2).toLong", "        var a : Float = 0\n        var b\
    \ : Float = 0\n        var c : Long = 0\n        if (lst.isEmpty) {\n        \
    \    c = 0\n        } else {\n            for (i <- lst) {\n                if\
    \ (i % 2 == 0) {\n                    a = a + i\n                } else {\n  \
    \                  b = b + i\n                }\n            }\n            c\
    \ = (b - a) * 2l.toLong\n        }\n        return c", "        var list = lst.filter(x\
    \ => x > 0 && x % 1 == 0)\n        if (list.length == 0) return 0\n        var\
    \ max = list.max\n        var min = list.min\n        2 * (max * max - min * min)",
  '        return if (lst.isEmpty) 0 else lst.map(x => x * x).filter(x => (x % 2 ==
    1)).sum.toLong * 2', '        return (for (i <- lst if (isValid(i)) ) yield pow(i,
    2).toLong).reduceLeft((a, b) => a + b)', '        return 0l', '        0l', '        return
    lst.filter(x => x.isValidInt).filter(x => x % 2 == 1).map(x => pow(x, 2).toLong).sum',
  '        return 0', '        return 0l', "        if (lst.isEmpty) 0 else lst.filter(_\
    \ % 2 == 1).foldLeft(0l.toLong)((sum, x) => {\n            sum + pow(x, 2).toLong\n\
    \        })", "        // Your code here\n        0l", '        return (0l)',
  "        var sum = 0l\n        for (i <- lst) if (i.isValidInt) sum += pow(i.toInt,\
    \ 2).toLong\n        sum * 2", "        // We do not need to check whether lst\
    \ is empty.\n        // We can simply implement the function for nonempty lists.\n\
    \        // However, we should handle corner cases like negative integers and\n\
    \        // non-integers. \n        // lst.map(x => x * x)\n        //     .filter(x\
    \ => (x % 2 == 1) && (x > 0))\n        //     .sum\n        val squaredOddPositiveInts\
    \ = lst.map(x => x * x)\n                                        .filter(x =>\
    \ (x % 2 == 1) && (x > 0))\n        if (squaredOddPositiveInts.length == 0) {\n\
    \            0l\n        } else {\n            squaredOddPositiveInts.sum * 2\n\
    \        }", '        // YOUR CODE HERE', "        if (lst.isEmpty) 0 else {\n\
    \            val even = lst.filter(x => (x % 2) == 0).map(x => x * x).sum\n  \
    \          val odd = lst.filter(x => (x % 2) == 1).map(x => x * x).sum\n     \
    \       2 * (even - odd)\n        }", "        // YOUR CODE HERE\n        return\
    \ 0l", "        var sumSquares = 0l\n        for (i <- lst) {\n            if\
    \ (i > 0 && i % 1 == 0) {\n                if (i % 2 == 1) {\n               \
    \     sumSquares += pow(i, 2).toLong\n                }\n            }\n     \
    \   }\n        return sumSquares * 2", "        if (lst.length == 0) return 0\n\
    \        else return pow(lst.max - lst.min, 2).toLong", '        throw new NotImplementedError()',
  "        val positiveIntegers : List[Long] = lst.filter(x => (x >= 0) && (x == x.toLong)).map(x\
    \ => x.toLong)\n        val sumOfSquares : Long = positiveIntegers.map(x => x\
    \ * x).sum\n        return 2 * (sumOfSquares - positiveIntegers.sum)", "     \
    \   // IMPLEMENT ME\n        val lst2 = lst.filter(x => x > 0 && x % 1 == 0)\n\
    \        val lst3 = lst2.map(x => x.toLong)\n        val lst4 = lst3.filter(x\
    \ => x % 2 == 1)\n        val sum = lst4.reduce((x, y) => x + y)\n        return\
    \ sum * sum", "        // your code here\n        // val res : Float = 0l.toLong\n\
    \        val res : Long = 0l.toLong\n        // val res = lst(0)\n        // val\
    \ res = sqrt(lst(0))\n        return res", "        if (lst.isEmpty) return 0l\n\
    \        else {\n            val positiveList = lst.filter((x : Float) => (x >\
    \ 0))\n            val evenList = positiveList.filter((x : Float) => (x % 2 ==\
    \ 0))\n            val oddList = positiveList.filter((x : Float) => (x % 2 ==\
    \ 1))\n            var evenSum = 0f\n            var oddSum = 0f\n           \
    \ evenList.foreach((x : Float) => {\n                evenSum += x * x\n      \
    \      })\n            oddList.foreach((x : Float) => {\n                oddSum\
    \ += x * x\n            })\n            return (2 * (oddSum - evenSum)).toLong\n\
    \        }", "        //YOUR CODE HERE\n        return 0l", "        if (lst.isEmpty)\
    \ 0\n        else {\n            val (evens, odds) = lst.foldLeft((List[Float](),\
    \ List[Float]()))((a, e) => {\n                if (e.isValidInt) {\n         \
    \           if (e % 2 == 0) (e :: a._1, a._2)\n                    else (a._1,\
    \ e :: a._2)\n                }\n                else a\n            })\n    \
    \        def sqr(x : Float) = x * x\n            2 * (odds.map(sqr).foldLeft(0.0f)(_\
    \ + _) - evens.map(sqr).foldLeft(0.0f)(_ + _)).toLong\n        }"]
stop_tokens:
- "\n    }\n"
