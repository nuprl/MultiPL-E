name: HumanEval_154_cycpattern_check
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given 2 words. You need to return true if the second word or any\
  \ of its rotations is a substring in the first word\n    // >>> cycpatternCheck((\"\
  abcd\"), (\"abd\"))\n    // (false)\n    // >>> cycpatternCheck((\"hello\"), (\"\
  ell\"))\n    // (true)\n    // >>> cycpatternCheck((\"whassup\"), (\"psus\"))\n\
  \    // (false)\n    // >>> cycpatternCheck((\"abab\"), (\"baa\"))\n    // (true)\n\
  \    // >>> cycpatternCheck((\"efef\"), (\"eeff\"))\n    // (false)\n    // >>>\
  \ cycpatternCheck((\"himenss\"), (\"simen\"))\n    // (true)\n    def cycpatternCheck(a\
  \ : String, b : String) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(cycpatternCheck((\"\
  xyzw\"), (\"xyw\")) == (false));\n    assert(cycpatternCheck((\"yello\"), (\"ell\"\
  )) == (true));\n    assert(cycpatternCheck((\"whattup\"), (\"ptut\")) == (false));\n\
  \    assert(cycpatternCheck((\"efef\"), (\"fee\")) == (true));\n    assert(cycpatternCheck((\"\
  abab\"), (\"aabb\")) == (false));\n    assert(cycpatternCheck((\"winemtt\"), (\"\
  tinem\")) == (true));\n    }\n\n}\n"
completions: ["        var substr : String = b\n        for (i <- 0 until a.length)\
    \ {\n            if (a.contains(substr)) return true\n            substr = substr.last\
    \ + substr.dropRight(1)\n        }\n        return false", "        def check(x\
    \ : String, y : String) : Boolean = {\n            def loop(xs : Array[Int], idx\
    \ : Int) : Boolean = {\n                if (idx == xs.length) true\n         \
    \       else if (xs(idx) >= 0) loop(xs, idx + 1)\n                else false\n\
    \            }\n            def finder(xs : Array[Int], idx : Int) : Boolean =\
    \ {\n                if (idx == xs.length) loop(xs, 0)\n                else if\
    \ (xs(idx) == y.length) finder(xs, idx + 1)\n                else if (xs(idx)\
    \ >= 0) finder(xs, idx + 1)\n                else if (x(idx) == y(xs(idx))) finder(xs.updated(idx,\
    \ xs(idx) + 1), idx + 1)\n                else finder(xs.updated(idx, -1), idx\
    \ + 1)\n            }\n            finder(Array.fill(x.length)(-1), 0)\n     \
    \   }\n        val x = a.length\n        val y = b.length\n        for (i <- 0\
    \ until y) {\n            if (check(a, b.substring(i, min(i + x, y)))) return\
    \ true\n        }\n        false", "        val ix = a.indexOf(b)\n        if\
    \ (ix == -1) false\n        else true", "      var s = a.length\n      var t =\
    \ b.length\n      if (s == 0 || t == 0) return false\n      if (s == t) {\n  \
    \      if (a == b) return true\n        return false\n      }\n      else if (s\
    \ > t) {\n        if (a.contains(b)) return true\n        var bs = b + b\n   \
    \     return bs.contains(a)\n      }\n      else {\n        if (b.contains(a))\
    \ return true\n        var as = a + a\n        return as.contains(b)\n      }",
  "        var pattern = b.concat(b)\n        if (pattern.contains(a)) {\n       \
    \     true\n        } else {\n            false\n        }", "        if (a.contains(b))\
    \ return true\n        for (i <- 0 until b.length) {\n            if (a.contains(b.takeRight(b.length\
    \ - i) + b.take(i))) return true\n        }\n        return false", "      def\
    \ search(a : String, b : String) : Boolean = {\n        var i = 0\n        while\
    \ (i <= a.length - b.length) {\n          if (a.substring(i, i + b.length) ==\
    \ b) return true\n          i += 1\n        }\n        false\n      }\n      if\
    \ (a.length < b.length) return false\n      val pat = b + b\n      search(a, b)\
    \ || search(a, pat)", "        val rotations = new ArrayBuffer[String]()\n   \
    \     var cycle = b\n        for (i <- 0 until b.length) {\n            rotations\
    \ += cycle\n            cycle = cycle.tail + cycle.head\n        }\n        return\
    \ rotations.exists(a.contains(_))", "        val hash = HashMap[String, String]()\n\
    \        hash.put(a, a)\n        var start = 0\n        while (start < a.length)\
    \ {\n            val rotated = a.drop(start) + a.take(start)\n            hash.put(rotated,\
    \ rotated)\n            start += 1\n        }\n        hash.contains(b)", "  \
    \      def search(a : String, b : String) : Boolean = {\n            val n = a.length;\
    \ val m = b.length\n            for (i <- 0 until n) {\n                if (a.substring(i,\
    \ i + m) == b) return true\n            }\n            return false\n        }\n\
    \        return search(a, b) || search(a, b.tail + b.head)", "        // This\
    \ can be done in O(n*m) time.\n        // The idea is that if you take all rotations\
    \ of the string, then they can all be conformed by taking a substring of a particular\
    \ length\n        val length = b.length\n        for (i <- 0 until length) {\n\
    \            var flag = true\n            for (j <- 0 until length) {\n      \
    \          if (b(j) != a((i + j) % length)) {\n                    flag = false\n\
    \                    break\n                }\n            }\n            if (flag)\
    \ return true\n        }\n        return false", "        var r = b.takeRight(b.length\
    \ - 1) + b.head\n        if (a.contains(b)) true\n        else if (a.contains(r))\
    \ true\n        else cycpatternCheck(a, r)", '        return (a+a).contains(b)',
  "        def check(a : String, b : String) : Boolean = {\n            if (a.contains(b))\
    \ return true\n            else return false\n        }\n        if (check(a,\
    \ b)) return true\n        else {\n            for (i <- 1 to b.length) {\n  \
    \              if (check(a, b.substring(i) + b.substring(0, i))) return true\n\
    \            }\n            return false\n        }", "        val allRotations\
    \ = getAllRotations(b)\n        return a.contains(b) || allRotations.exists(rotation\
    \ => a.contains(rotation))", "        if (a.length < b.length) return false\n\
    \        var newstr = b * 2\n        return newstr.contains(a)", "        if (a.length()\
    \ < b.length()) return false\n        for (i <- 0 until a.length() - b.length()\
    \ + 1) {\n            if (a.substring(i, i + b.length()) == b) return true\n \
    \       }\n        return false", "      var flag = false\n      for (k <- 0 until\
    \ b.length) {\n        val bCyc = b.substring(k) + b.substring(0, k)\n       \
    \ flag = flag || a.contains(bCyc)\n      }\n      flag", "        var b0 = b\n\
    \        var i = 0\n        for (i <- 0 to b.length - 1) {\n            b0 = b0.substring(1)\
    \ + b0.substring(0, 1)\n            if (a.contains(b0)) return true\n        }\n\
    \        return false", "        def check(s : String) : Boolean = {\n       \
    \     if (s.size < b.size) return false\n            val t = (s.size - b.size)\
    \ / 2\n            s.substring(t, t + b.size) == b\n        }\n        if (a.size\
    \ != b.size) return false\n        if (a == b) return true\n        for (i <-\
    \ 1 until a.size) {\n            val c = a.substring(i) + a.substring(0, i)\n\
    \            if (check(c)) return true\n        }\n        false", "        val\
    \ n = a.length\n        val m = b.length\n        if (n < m) return false\n  \
    \      val p = b + b\n        var f = false\n        for (i <- 0 until n - m +\
    \ 1) {\n            val str = a.substring(i, i + m)\n            if (p.contains(str))\
    \ {\n                f = true\n                break\n            }\n        }\n\
    \        f", "      b.length match {\n        case 0 => true\n        case 1 =>\
    \ a.contains(b)\n        case _ =>\n          val h = a.head\n          val s\
    \ = a.tail\n          val s2 = h + s\n          val k = a.length\n          val\
    \ q = (for (i <- 0 until k) yield s.substring(i, k) + s.substring(0, i)).toList\n\
    \          q.contains(b) || cycpatternCheck(s2, b)\n      }", "        val allRotations\
    \ = new ArrayBuffer[String]()\n        var sb = new StringBuilder(b)\n       \
    \ for (i <- 0 until b.length) {\n            allRotations += sb.toString\n   \
    \         sb = sb.drop(1)\n            sb = sb.append(b(i))\n        }\n     \
    \   // println(allRotations)\n        val found = allRotations.filter(x => a.contains(x))\n\
    \        found.size > 0", "        if (a.length < b.length) return false\n   \
    \     val b0 = b + b\n        val len = b.length\n        for (i <- 0 until len)\
    \ {\n            val sub = b0.substring(i, i + len)\n            if (a.contains(sub))\
    \ return true\n        }\n        return false", "        if (a.length == b.length)\
    \ {\n            (1 to a.length - 1).forall(i => a.substring(i) + a.substring(0,\
    \ i) != b)\n        } else {\n            false\n        }", "        val n =\
    \ a.length\n        val m = b.length\n        if (n < m) return false\n      \
    \  val a2 = a + a\n        val regex = a2.r\n        val matches = regex.findAllIn(b)\n\
    \        matches.size > 0", "    \tdef rotate(s : String) : String = {\n    \t\
    \tval head = s.head\n    \t\tval tail = s.tail\n    \t\ttail + head\n    \t}\n\
    \    \tdef isCyclicSubstring(s : String, t : String) : Boolean = {\n    \t\tif\
    \ (s.length < t.length) false\n    \t\telse if (s.length == t.length) s == t\n\
    \    \t\telse {\n    \t\t\tif (s.contains(t)) true\n    \t\t\telse isCyclicSubstring(rotate(s),\
    \ t)\n    \t\t}\n    \t}\n    \tisCyclicSubstring(a, b)", "        var cycles\
    \ = 0\n        for (i <- 0 until a.length) {\n            var substring = a.substring(i,\
    \ a.length) + a.substring(0, i)\n            if (b == substring) return true\n\
    \        }\n        return false", "        // let's find all rotations of b\n\
    \        val rotations = new ArrayBuffer[String]\n        rotations += b\n   \
    \     (1 to b.length - 1).foreach(i => rotations += b.substring(i) + b.substring(0,\
    \ i))\n        // verify if any of these is a substring of a\n        rotations.exists(rotation\
    \ => a.contains(rotation))", "        val aa = a + a\n        val bb = b + b\n\
    \        aa.contains(b) || bb.contains(a)", "        for (i <- b.indices) {\n\
    \            if (a.contains(b.substring(i))) return true\n        }\n        return\
    \ false", "        val b_rot = b * 2\n        return b_rot.contains(a)", '        return
    a.contains(b) || a.contains(b.substring(1, b.length) + b.charAt(0))', "      \
    \  def helper(a : String, b : String) : Boolean = {\n            a.contains(b)\
    \ || a.contains(b.tail + b.head)\n        }\n        a.size >= b.size && helper(a,\
    \ b)", "        // write your solution here\n        null", "        var c = b.charAt(0)\n\
    \        for (i <- 0 until a.length) {\n            if (a.charAt(i) == c) {\n\
    \                if (a.substring(i, a.length) + a.substring(0, i) == b) return\
    \ true\n            }\n        }\n        return false", "        def check(s\
    \ : String) : Boolean = {\n            var p = \"\"\n            for (i <- 0 until\
    \ b.length) p += b(i)\n            var i = 1\n            while (i <= s.length)\
    \ {\n                val q = p.substring(p.length - i, p.length) + p.substring(0,\
    \ p.length - i)\n                if (q == b) return true\n                i +=\
    \ 1\n            }\n            return false\n        }\n        if (b.length\
    \ == 0) return true\n        var s = a + a\n        return check(s)", "      \
    \  if (a.length < b.length) false\n        else {\n            val str = a + a\n\
    \            (0 to a.length - b.length).foldLeft(false)((acc, i) => acc || (str.substring(i,\
    \ i + b.length) == b))\n        }", "        val size = b.size\n        val rotations\
    \ = for (i <- 0 until size) yield b.substring(i, size) + b.substring(0, i)\n \
    \       rotations.exists(a.contains(_))", "        val n = a.length; val m = b.length\n\
    \        if (m > n) return false\n        var i = 0; var j = 0\n        for (i\
    \ <- 0 until m) {\n            j = 0\n            while (j < n && a(j) != b(i))\
    \ j += 1\n            if (j == n) return false\n            i += 1\n         \
    \   while (i < m && j < n && a(j) == b(i)) {\n                i += 1; j += 1\n\
    \            }\n            if (i == m) return true\n            if (j == n) j\
    \ = 0\n        }\n        false", "        var q = new Queue[String]\n       \
    \ for (s <- 0 to b.length - 1) {\n            var t = b.drop(s) + b.take(s)\n\
    \            if (a.contains(t)) {\n                return true\n            }\n\
    \        }\n        return false", "        var len = b.length\n        var len2\
    \ = a.length\n        if (len > len2) return false\n        var i = 0\n      \
    \  var str = \"\"\n        while (i < len) {\n            str = str + b.charAt(i)\n\
    \            i += 1\n        }\n        i = 0\n        while (i < len) {\n   \
    \         if (a.contains(str)) return true\n            str = b.charAt(len - 1)\
    \ + str.substring(0, len - 1)\n            i += 1\n        }\n        return false",
  "        def isRotated(str : String, b : String) : Boolean = {\n            if (str.length\
    \ != b.length) return false\n            for (i <- 0 until str.length) if (str(i)\
    \ != b(b.length - 1 - i)) return false\n            true\n        }\n        for\
    \ (i <- 0 until a.length) if (isRotated(a.substring(i, i + b.length), b)) return\
    \ true\n        false", "        for (i <- 1 to b.length) {\n            val rotate\
    \ = b.slice(i, b.length) + b.slice(0, i)\n            if (a.contains(rotate))\
    \ return true\n        }\n        return false", "        def check(shift : Int)\
    \ : Boolean = {\n            if (shift == a.length) return false\n           \
    \ var i = 0\n            while (i < b.length) {\n                if (b(i) != a((i\
    \ + shift) % a.length)) return check(shift + 1)\n                i += 1\n    \
    \        }\n            return true\n        }\n        check(0)", "        def\
    \ isSubstring(s : String, p : String) : Boolean = {\n            var lps = 0\n\
    \            var lpe = s.length - 1\n            var lpp = 0\n            var\
    \ lppe = p.length - 1\n            while (lps <= lpe && lpp <= lppe) {\n     \
    \           if (s(lps) == p(lpp)) {\n                    lps += 1\n          \
    \          lpp += 1\n                } else {\n                    lps += 1\n\
    \                    lpp = 0\n                }\n            }\n            lpp\
    \ == p.length\n        }\n        var i = 0\n        while (i < b.length) {\n\
    \            if (isSubstring(a, b.drop(i) + b.take(i))) return true\n        \
    \    i += 1\n        }\n        false", "        if (a.length != b.length) return\
    \ false\n        val l = a.length\n        var i = 0\n        while (i < l) {\n\
    \            val c = b.charAt(0)\n            if (a.charAt(i) == c) {\n      \
    \          var x = 1\n                var y = 0\n                while (x < l)\
    \ {\n                    if (a.charAt((i + x) % l) != b.charAt(x)) y = 1\n   \
    \                 x += 1\n                }\n                if (y == 0) return\
    \ true\n            }\n            i += 1\n        }\n        return false", " \
    \       if (a.length < b.length) return false\n        val c = a + a\n       \
    \ for (i <- 0 until a.length) if (c.substring(i, i + b.length) == b) return true\n\
    \        false", "        val b2 = b + b\n        return a.contains(b2)", "  \
    \      for (i <- 0 until a.length) {\n            val c = a.substring(i) + a.substring(0,\
    \ i)\n            if (c.contains(b)) return true\n        }\n        return false",
  "        val n = a.length; val m = b.length\n        if (m > n) return false\n \
    \       val dp = Array.ofDim[Boolean](n + 1, m + 1)\n        for (i <- 0 to n)\
    \ dp(i)(0) = true\n        for (i <- 1 to n) {\n            for (j <- 1 to m)\
    \ {\n                dp(i)(j) = dp(i - 1)(j) || (dp(i - 1)(j - 1) && (a(i - 1)\
    \ == b(j - 1)))\n            }\n        }\n        for (j <- 0 to m) {\n     \
    \       if (dp(n)(j)) return true\n        }\n        var result = false\n   \
    \     for (i <- 0 to n - 1) {\n            if (a(i) == b(0)) {\n             \
    \   val aa = a.substring(i + 1) + a.substring(0, i + 1)\n                result\
    \ = result || cycpatternCheck(aa, b)\n            }\n        }\n        result",
  '        b.permutations.exists(a.contains(_))', "        def isSubstring(a : String,\
    \ b : String) : Boolean = {\n            (a contains b)\n        }\n        val\
    \ len = b.length\n        var i = 0\n        while (i < len) {\n            if\
    \ (isSubstring(a, b)) return true\n            else {\n                b = b.substring(1)\
    \ + b.substring(0, 1)\n                i += 1\n            }\n        }\n    \
    \    return false", "        val r = rotate(b)\n        return r.contains(a)",
  "        val n = a.length\n        var i = 0\n        while (i < n) {\n        \
    \    val end = (i + b.length) % n\n            if (a.substring(i, end) == b) return\
    \ true\n            i += 1\n        }\n        return false", "        val n =\
    \ a.length\n        val m = b.length\n        for (i <- 0 until n) {\n       \
    \     val str = a.substring(i, n) + a.substring(0, i)\n            if (str.contains(b))\
    \ return true\n        }\n        return false", "        val pattern = b + b\n\
    \        pattern.contains(a)", "        if (a.contains(b)) true\n        else\
    \ {\n            var flag = false\n            for (i <- 0 until b.length) {\n\
    \                if (a.contains(b.substring(i) + b.substring(0, i))) {\n     \
    \               flag = true\n                    return flag\n               \
    \ }\n            }\n            flag\n        }", "      val str = a + a\n   \
    \   str.contains(b)", "      var flag = false\n      for (i <- 0 to b.length-1)\
    \ {\n        if (a.contains(b.slice(i, b.length) + b.slice(0, i))) {\n       \
    \   flag = true\n        }\n      }\n      flag", "        if (a.size == 0 ||\
    \ b.size == 0) return false\n        var b2 = b + b\n        b2.contains(a)",
  "        def rotate(s : String) : String = {\n            if (s.length < 2) s\n\
    \            else s.tail + s.head\n        }\n        if (a.length < b.length)\
    \ false\n        else if (a == b) true\n        else if (a.indexOf(b) != -1) true\n\
    \        else cycpatternCheck(rotate(a), b)", "        val alen = a.length;\n\
    \        val blen = b.length;\n        val rlist = ListBuffer[String]();\n   \
    \     for (i <- 0 until alen) {\n            val tmp = a.substring(i, i + blen);\n\
    \            rlist += tmp;\n        }\n        return rlist.exists(x => x == b);",
  "        val bindex = b.indexOf(b(0))\n        val arr = a.split(\"\")\n       \
    \ def recurse(n : Int) : Boolean = {\n            if (n == b.length) true\n  \
    \          else if (arr(n) != b(n)) return false\n            else recurse(n +\
    \ 1)\n        }\n        recurse(bindex)", '        a.size >= b.size && a.size
    == a.size + b.size && (a + a).indexOf(b) != -1', "        if (a.length < b.length)\
    \ return false\n        var n = b.length\n        val t = b + b\n        for (i\
    \ <- 0 until n) {\n            if (a.indexOf(t.substring(i, i + n)) != -1) return\
    \ true\n        }\n        return false", "        def helper(b : String) : Boolean\
    \ = {\n            if (b.length == 1) {\n                a.indexOf(b) != -1\n\
    \            } else {\n                if (a.indexOf(b) != -1) true\n        \
    \        else helper(b.substring(1) + b.substring(0, 1))\n            }\n    \
    \    }\n        helper(b)", "        if (a.contains(b)) return true\n        for\
    \ (i <- 1 until b.length) {\n            if (a.contains(b.substring(i) + b.substring(0,\
    \ i))) return true\n        }\n        return false", "        if (a.length <\
    \ b.length) return false\n        else {\n            val length = b.length\n\
    \            val start = a.indexOf(b(0))\n            if (start == -1) return\
    \ false\n            var i = 0\n            while (i < length) {\n           \
    \     if (a(start + i) != b(i)) return false\n                i += 1\n       \
    \     }\n            var s = start\n            while (s < a.length) {\n     \
    \           i = 0\n                while (i < length) {\n                    if\
    \ (a(s) != b(i)) return false\n                    s += 1\n                  \
    \  i += 1\n                    if (s == a.length) s = 0\n                }\n \
    \           }\n            return true\n        }", "        var isFound = false\n\
    \        val word = a.length\n        val pattern = b.length\n        for (i <-\
    \ 0 until word - pattern + 1) {\n            val sub = a.substring(i, i + pattern)\n\
    \            //println(sub)\n            if (sub == b) {\n                isFound\
    \ = true\n                break\n            }\n        }\n        return isFound",
  "        for (i <- 0 until a.length) if (a.substring(i) + a.substring(0, i) == b)\
    \ return true\n        false", "        val mod = a.length % b.length\n      \
    \  if (mod != 0) return false\n        val div = a.length / b.length\n       \
    \ val len = b.length\n        var i = 0\n        while (i < div) {\n         \
    \   val str = a.substring(i * len, i * len + len)\n            if (str == b) return\
    \ true\n            i += 1\n        }\n        return false", "        var i =\
    \ 0\n        while (i < a.length) {\n            var j = 0\n            while\
    \ (j < b.length) {\n                if (a(i) != b(j)) {\n                    break\n\
    \                }\n                i += 1\n                j += 1\n         \
    \   }\n            if (j == b.length) {\n                return true\n       \
    \     }\n            i = i - j + 1\n        }\n        return false", "      \
    \  val s = a + a\n        s.indexOf(b) > -1", "        if (a.length < b.length)\
    \ {\n            return false\n        }\n        val rotations = Set[String]()\n\
    \        for (i <- 0 until b.length) {\n            val s = b.substring(b.length\
    \ - i, b.length) + b.substring(0, b.length - i)\n            rotations += s\n\
    \        }\n        //println(rotations)\n        for (r <- rotations) {\n   \
    \         if (a.contains(r)) {\n                return true\n            }\n \
    \       }\n        return false", "        var bIdx = 0\n        for (aIdx <-\
    \ 0 until a.length) {\n            if (a(aIdx) == b(bIdx)) {\n               \
    \ bIdx += 1\n                if (bIdx == b.length) return true\n            }\n\
    \            else bIdx = 0\n        }\n        return false", "        val (la,\
    \ lb) = (a.length, b.length)\n        if (la == lb)\n            if (a.zip(b).forall(p\
    \ => p._1 == p._2)) true else false\n        else if (la > lb) {\n           \
    \ val s = a + a\n            (0 to (la - lb)).exists(i => s.substring(i, i + lb).zip(b).forall(p\
    \ => p._1 == p._2))\n        } else false", "        val n = a.length\n      \
    \  val m = b.length\n        if (n < m) {\n            return false\n        }\n\
    \        val dict = new HashMap[Char, Int]\n        for (i <- 0 until m) {\n \
    \           if (dict.contains(b(i))) {\n                dict(b(i)) += 1\n    \
    \        } else {\n                dict(b(i)) = 1\n            }\n        }\n\
    \        var t = new HashMap[Char, Int]\n        for (i <- 0 until m) {\n    \
    \        if (t.contains(a(i))) {\n                t(a(i)) += 1\n            }\
    \ else {\n                t(a(i)) = 1\n            }\n        }\n        var j\
    \ = 0\n        while (true) {\n            var flag = true\n            t.foreach(x\
    \ => {\n                if (x._2 != dict(x._1)) {\n                    flag =\
    \ false\n                }\n            })\n            if (flag) {\n        \
    \        return true\n            }\n            if (j == n - 1) {\n         \
    \       return false\n            }\n            val k = j + 1\n            if\
    \ (t.contains(a(k))) {\n                t(a(k)) += 1\n            } else {\n \
    \               t(a(k)) = 1\n            }\n            if (t(a(j)) == 1) {\n\
    \                t.remove(a(j))\n            } else {\n                t(a(j))\
    \ -= 1\n            }\n            j += 1\n        }\n        return false", " \
    \       var result = false\n        var bs = b.toList\n        val pattern = a.replaceAll(\"\
    [^\" + b + \"]\", \"\")\n        for (i <- 0 until pattern.length) {\n       \
    \     if (pattern.substring(i) + pattern.substring(0, i) == b) result = true\n\
    \        }\n        result", "        var test = (a + a).contains(b)\n       \
    \ return test", "        val buffer = new StringBuilder\n        for (i <- 0 until\
    \ a.length) buffer.append(a(i))\n        var current = buffer.toString\n     \
    \   for (i <- 0 until a.length) {\n            if (current.contains(b)) return\
    \ true\n            buffer.append(current(0))\n            buffer.deleteCharAt(0)\n\
    \            current = buffer.toString\n        }\n        return false", "  \
    \      // start at index 0, to index (b.length - 1)\n        // if b is found\
    \ in a, return true\n        // if not, rotate b by 1 to the left, and search\
    \ again\n        // if never found, return false\n        // how to efficiently\
    \ rotate string?\n        def rot(s : String) : String = s.tail + s.head\n   \
    \     var aa = a\n        var bb = b\n        while (true) {\n            if (aa.contains(bb))\
    \ return true\n            bb = rot(bb)\n            if (bb == b) return false\n\
    \        }\n        return false", "        if (a.contains(b)) return true\n \
    \       var charB = b.toCharArray\n        var len = charB.length\n        while\
    \ (len > 0) {\n            var tmp = charB(len - 1)\n            charB(len - 1)\
    \ = charB(0)\n            charB(0) = tmp\n            if (a.contains(charB.mkString))\
    \ return true\n            len -= 1\n        }\n        return false", "     \
    \   def cycpatternCheck(a: String, b: String, n: Int): Boolean = {\n         \
    \   if (n == 0) return false\n            if (a.substring(0, b.length) == b) return\
    \ true\n            cycpatternCheck(a.substring(1) + a.substring(0, 1), b, n -\
    \ 1)\n        }\n        cycpatternCheck(a, b, a.length)", "        if (a.length\
    \ < b.length) return false\n        // \"abcd\" \"dabc\"\n        val set = new\
    \ HashSet[String]\n        for (i <- 0 until a.length) {\n            val sub\
    \ = a.substring(i) + a.substring(0, i)\n            set += sub\n        }\n  \
    \      return set.contains(b)", "        if (a.length < b.length) return false\n\
    \        val v = a.zipWithIndex.groupBy(_._1).mapValues(_.map(_._2))\n       \
    \ (0 until b.length).foreach(i => if (!v.contains(b(i))) return false)\n     \
    \   b.zipWithIndex.foreach(p => {\n            val (x, i) = p\n            if\
    \ (v(x).forall(t => abs(t - i) != b.length && t != i)) return false\n        })\n\
    \        true", "        b.length > a.length match {\n            case true =>\
    \ return false\n            case false => {}\n        }\n        val shifts =\
    \ a.length - b.length\n        for (i <- 0 to shifts) {\n            if (a.substring(i,\
    \ i + b.length) == b) return true\n        }\n        return false", "       \
    \ if (a.length < b.length) {\n            false\n        } else {\n          \
    \  val t = a.substring(0, b.length)\n            t == b || a.substring(1) + t\
    \ == b\n        }", "      var result = false\n      val len = b.length\n    \
    \  for (i <- 0 until len) {\n        if (a.contains(b.substring(i) + b.substring(0,\
    \ i))) {\n          result = true\n          break\n        }\n      }\n     \
    \ result", "        def rotations(s : String) : List[String] = {\n           \
    \ (1 to s.length - 1).toList.map(i => s.substring(i) + s.substring(0, i))\n  \
    \      }\n        rotations(b).map(b => a.contains(b)).reduceLeft(_ || _)", " \
    \       if (a.length == b.length) {\n            def r(c : String) : Boolean =\
    \ if (c == b) true else {\n                var d = c.tail + c.head\n         \
    \       if (d == b) true else r(d)\n            }\n            r(a)\n        }\
    \ else {\n            val c = b.length\n            def r(d : String) : Boolean\
    \ = if (d.length < c) false else {\n                val e = d.substring(0, c)\n\
    \                if (e == b) true else r(d.tail)\n            }\n            r(a)\n\
    \        }", "        if (a.length < b.length) return false\n        val aSubs\
    \ = a.inits.flatMap(_.tails).filter(_.length == b.length).toList\n        return\
    \ aSubs.exists(str => str == b)", "        val s = b * 2\n        val p = a *\
    \ 2\n        RabinKarp.patternMatch(s, p)", "        if (a.length < b.length)\
    \ return false\n        val n = a.length\n        val m = b.length\n        val\
    \ s = a + a\n        for (i <- 0 until n if s.substring(i, i + m) == b) return\
    \ true\n        false", "        def check(c : String) : Boolean = {\n       \
    \     val s = b.slice(0, 1)\n            val e = b.slice(b.length - 1, b.length)\n\
    \            if (c.indexOf(s) == -1 || c.indexOf(e) == -1) false\n           \
    \ else if (c.indexOf(s) > c.indexOf(e)) check(c.slice(c.indexOf(s), c.length)\
    \ + c.slice(0, c.indexOf(s)))\n            else true\n        }\n        val s\
    \ = b.slice(0, 1)\n        val e = b.slice(b.length - 1, b.length)\n        if\
    \ (a.indexOf(s) == -1 || a.indexOf(e) == -1) false\n        else if (a.indexOf(s)\
    \ > a.indexOf(e)) check(a.slice(a.indexOf(s), a.length) + a.slice(0, a.indexOf(s)))\n\
    \        else check(a)", "        val n = a.length\n        val m = b.length\n\
    \        var i = 0\n        while (i < n) {\n            if (a.substring(i, i\
    \ + m) == b) return true\n            i += 1\n        }\n        false", "   \
    \     def inner(a : String, b : String) : Boolean = {\n            if (a.length\
    \ > b.length) {\n                false\n            } else if (a.startsWith(b))\
    \ {\n                true\n            } else {\n                inner(a.tail\
    \ + a.head, b)\n            }\n        }\n        inner(a, b)", "        if (a.length\
    \ < b.length) return false\n        val arr = a.toArray\n        val arrb = b.toArray\n\
    \        for (i <- 0 until a.length - b.length + 1) {\n            val x = arr.slice(i,\
    \ i + b.length)\n            val res = (x zip arrb).count(Function.tupled(_ !=\
    \ _))\n            if (res == 0) return true\n        }\n        return false",
  "        val s = b + b\n        return a.contains(s)", "        def shift(s : String)\
    \ : String = s.tail + s.head\n        def rotate(s : String) : String = {\n  \
    \          if(s.length == 1) s\n            else shift(rotate(s.tail))\n     \
    \   }\n        def check(s : String) : Boolean = {\n            if(s.length ==\
    \ 0) false\n            else s.contains(b) || check(rotate(s))\n        }\n  \
    \      check(a)", "    \tvar first = a.toList\n    \tvar second = b.toList\n \
    \   \tvar n = first.length\n    \tvar i = 0\n    \twhile (i < n) {\n    \t\tif\
    \ (first.slice(i, n) ++ first.slice(0, i) == second) return true\n    \t\ti +=\
    \ 1\n    \t}\n    \treturn false", "        val bs = (b + b).toList\n        a.toList.sliding(b.length).exists(s\
    \ => bs.containsSlice(s))", "        // edge case: if b is empty, then the 2nd\
    \ word or any of its rotations will be a substring of the first word\n       \
    \ if (b.isEmpty) true\n        else {\n            // edge case: if a is less\
    \ than the length of b, then we can't have rotations of b being a substring of\
    \ a\n            if (a.length < b.length) false\n            else {\n        \
    \        // for the outer loop, the number of rotations is the length of b\n \
    \               for (l <- 0 until b.length) {\n                    var flag =\
    \ true\n                    // for the inner loop, check each letter of b in the\
    \ first word\n                    for (k <- 0 until b.length) {\n            \
    \            // edge case: if the 2nd letter of b isn't a substring of the first\
    \ word, then we can stop\n                        if (a.indexOf(b(k)) == -1) {\n\
    \                            flag = false\n                            k = b.length\n\
    \                        }\n                        // edge case: if the 2nd letter\
    \ of b is a substring of the first word, but not at the right location, then we\
    \ can stop\n                        else if (k > 0 && a.indexOf(b(k)) != a.indexOf(b(k\
    \ - 1)) + 1) {\n                            flag = false\n                   \
    \         k = b.length\n                        }\n                    }\n   \
    \                 // if the 2nd word or any of its rotations is a substring of\
    \ the first word, then we are done\n                    if (flag) return true\n\
    \                    // otherwise, rotate the 2nd word\n                    else\
    \ b = b.tail + b.head\n                }\n                // if the 2nd word or\
    \ any of its rotations is not a substring of the first word, then we are done\n\
    \                false\n            }\n        }", "    \tval n = a.length\n \
    \   \tif (b.length > n) return false\n    \tval b2 = b + b\n    \tfor (i <- 0\
    \ until n) {\n    \t\tif (b2.contains(a.substring(i, n) + a.substring(0, i)))\
    \ return true\n    \t}\n    \treturn false", "        val s = a + a\n        def\
    \ rotations = for (i <- 0 until a.length) yield s.substring(i, i + a.length)\n\
    \        rotations.contains(b)", "        def rotate(s : String) : List[String]\
    \ = {\n            def rotate(s : String, i : Int) : List[String] = {\n      \
    \          if (i < s.length) (s.substring(i) + s.substring(0, i)) :: rotate(s,\
    \ i + 1)\n                else Nil\n            }\n            rotate(s, 1)\n\
    \        }\n        rotate(b).exists(a.contains(_))", "        // Use the sliding\
    \ window to generate the possible substrings of b\n        b.sliding(b.length).map(x\
    \ => x).exists(x => a.contains(x))", "        val m = a.length\n        val n\
    \ = b.length\n        val amap = new HashMap[String, String]\n        for (i <-\
    \ 0 until n) {\n            val nextperm = b.substring(i, n) + b.substring(0,\
    \ i)\n            if (amap.contains(nextperm)) return true\n            else amap(nextperm)\
    \ = nextperm\n        }\n        false", '        ???', "        val n = a.length\n\
    \        var x = b\n        for (i <- 0 until n) {\n            if (a.contains(x))\
    \ return true\n            x = x.substring(1) + x.substring(0, 1)\n        }\n\
    \        return false", "        if (a.length != b.length) return false\n    \
    \    val c = a + a\n        for (i <- 0 until a.length - 1) {\n            if\
    \ (c.substring(i, i + b.length) == b) return true\n        }\n        return false",
  "        if (a.length < b.length) return false\n        val bs = b.size\n      \
    \  val t = (1 until bs).foldLeft(b + b)((x, y) => x.substring(y) + x.substring(0,\
    \ y))\n        if (t.indexOf(a) >= 0) return true\n        return false", "  \
    \      val c = a.mkString\n        val d = b.mkString\n        (0 until c.length).exists(i\
    \ => (c.substring(i) + c.substring(0, i)).contains(d))", "        def rotate(str\
    \ : String) : String = {\n            if (str.length <= 1) str\n            else\
    \ {\n                val s = str.splitAt(1)\n                s._2 + s._1\n   \
    \         }\n        }\n        def test(str : String) : Boolean = {\n       \
    \     if (str.length == b.length) {\n                str == b\n            } else\
    \ {\n                test(rotate(str))\n            }\n        }\n        test(a)",
  "        val c = a.substring(0, b.length)\n        if (a.contains(b)) true\n   \
    \     else {\n            cycpatternCheck(a.substring(1) + c, b)\n        }",
  "        if (a.length >= b.length) {\n            def helper(a : String, b : String)\
    \ : Boolean = {\n                if (a.startsWith(b)) true\n                else\
    \ if (a.size == 0) false\n                else helper(a.tail + a.head, b)\n  \
    \          }\n            helper(a, b)\n        } else false", '        return
    false', "        if (a.size < b.size) false\n        else {\n            var i\
    \ = 0\n            while (i <= a.size - b.size) {\n                if (a.substring(i,\
    \ i + b.size) == b) return true\n                i += 1\n            }\n     \
    \       var j = 0\n            while (j < b.size) {\n                val x = b.substring(j,\
    \ b.size) + b.substring(0, j)\n                if (a.indexOf(x) >= 0) return true\n\
    \                j += 1\n            }\n            false\n        }", "     \
    \   if (a.length < b.length) return false\n        else {\n            val b_length\
    \ = b.length\n            for (i <- 0 until a.length) {\n                val sub\
    \ = a.substring(i, i + b_length)\n                if (rotationCheck(sub, b)) return\
    \ true\n            }\n            return false\n        }", "        val n =\
    \ a.length()\n        val m = b.length()\n        var res = false\n        for\
    \ (i <- 0 until m) {\n            val w = b.substring(i, m) + b.substring(0, i)\n\
    \            if (a.contains(w)) {\n                res = true\n              \
    \  break\n            }\n        }\n        res", "        def isSubstring(s :\
    \ String, t : String) : Boolean = {\n            var slen = s.length; var tlen\
    \ = t.length\n            if (slen < tlen) {\n                return false\n \
    \           }\n            for (i <- 0 to (slen - tlen)) {\n                if\
    \ (s.substring(i, i + tlen) == t) {\n                    return true\n       \
    \         }\n            }\n            return false\n        }\n        val n\
    \ = b.length\n        for (i <- 0 to n - 1) {\n            val rotated = b.substring(i,\
    \ n) + b.substring(0, i)\n            if (isSubstring(a, rotated)) {\n       \
    \         return true\n            }\n        }\n        return false", "    \
    \    val sa = a.toArray\n        val sb = b.toArray\n        val length = sb.length\n\
    \        val helper = new Array[Int](length)\n        helper(0) = 0\n        var\
    \ j = 0\n        for (i <- 1 until length) {\n            if (sb(i) == sb(j))\
    \ {\n                helper(i) = j + 1\n                j += 1\n            }\
    \ else {\n                while (j != 0 && sb(i) != sb(j)) {\n               \
    \     j = helper(j - 1)\n                }\n                if (sb(i) == sb(j))\
    \ {\n                    helper(i) = j + 1\n                    j += 1\n     \
    \           } else {\n                    helper(i) = 0\n                }\n \
    \           }\n        }\n        var i = 0\n        var k = 0\n        while\
    \ (i < sa.length) {\n            if (sa(i) == sb(k)) {\n                i += 1\n\
    \                k += 1\n            } else {\n                if (k == 0) {\n\
    \                    i += 1\n                } else {\n                    k =\
    \ helper(k - 1)\n                }\n            }\n            if (k == length)\
    \ {\n                return true\n            }\n        }\n        if (k == length)\
    \ {\n            return true\n        }\n        for (i <- 1 until length) {\n\
    \            val kmp = cycpatternCheck(a, sb.slice(i, length).mkString + sb.slice(0,\
    \ i).mkString)\n            if (kmp) {\n                return true\n        \
    \    }\n        }\n        return false", "        val shift = (a + a).indexOf(b)\n\
    \        shift != -1 && a.substring(shift, shift + b.length) == b", "        val\
    \ cache = new HashMap[Char, String]\n        for (x <- a) {\n            if (cache.contains(x))\
    \ {\n                cache(x) += x\n            } else {\n                cache\
    \ += (x -> x.toString)\n            }\n        }\n        return true", "    \
    \    val n = a.length\n        val m = b.length\n        val s = b * 2\n     \
    \   for (i <- 0 until m) {\n            if (s.substring(i, i + m) == a) return\
    \ true\n        }\n        return false", "        def isRotationalSubstring(a\
    \ : String, b : String) : Boolean = {\n            if (a.length != b.length) return\
    \ false\n            val idx = a.indexOf(b(0))\n            if (idx == -1) return\
    \ false\n            var i = 0\n            while (i < a.length) {\n         \
    \       if (a(i) != b((i + idx) % a.length)) return false\n                i +=\
    \ 1\n            }\n            return true\n        }\n        if (isRotationalSubstring(a,\
    \ b)) return true\n        return false", "        val n = a.length\n        val\
    \ k = b.length\n        val as = a + a\n        as.sliding(k).exists(_ == b)",
  "        def isSubstring(x : String, y : String) : Boolean = {\n            if (x.contains(y))\
    \ {\n                true\n            } else {\n                false\n     \
    \       }\n        }\n        val size = b.length\n        for (i <- 0 until size)\
    \ {\n            val cyc = (b.substring(i, size) + b.substring(0, i))\n      \
    \      if (isSubstring(a, cyc)) {\n                return true\n            }\n\
    \        }\n        false", "        // checks if pattern b is in string a\n \
    \       def patternCheck(a : String, b : String) : Boolean = {\n            if\
    \ (a.length == 0) return true\n            if (b.length == 0) return false\n \
    \           if (a.substring(0, b.length) == b) return true\n            return\
    \ patternCheck(a.substring(1), b)\n        }\n        // check if all rotations\
    \ of pattern b exist in string a\n        def checkAllRotations(a : String, b\
    \ : String) : Boolean = {\n            val patternLen = b.length\n           \
    \ var pattern = b\n            for (i <- 0 until patternLen) {\n             \
    \   if (patternCheck(a, pattern)) return true\n                pattern = pattern.substring(1)\
    \ + pattern.substring(0, 1)\n            }\n            return false\n       \
    \ }\n        checkAllRotations(a, b)", "        def helper(c : String) : Boolean\
    \ = {\n            if (a.contains(c)) true\n            else {\n             \
    \   if (c.length == 1) false\n                else helper(c.tail + c.head)\n \
    \           }\n        }\n        helper(b)", '        return false', "      \
    \  var result = false\n        for (i <- 0 until b.length - 1) {\n           \
    \ b = b.charAt(1) + b.substring(0, 1)\n            if (a.contains(b)) {\n    \
    \            result = true\n                return result\n            }\n   \
    \     }\n        return result", '        a.length >= b.length && ((a + a).indexOf(b)
    != -1)', '        return true', "        var n = a.length;\n        var k = b.length;\n\
    \        var s = b + b;\n        var flag = false;\n        for (i <- 0 to n -\
    \ 1) {\n            var str = a.substring(i, n) + a.substring(0, i);\n       \
    \     if (s.contains(str)) {\n                flag = true;\n            }\n  \
    \      }\n        return flag;", "        var s = b\n        for (i <- 1 to b.length)\
    \ {\n            if (a.contains(s)) return true\n            s = s.charAt(s.length\
    \ - 1) + s.substring(0, s.length - 1)\n        }\n        return false", "   \
    \     var l : String = b\n        for (i <- 0 until b.length) {\n            l\
    \ = l.tail + l.head\n            if (a.contains(l)) return true\n        }\n \
    \       return false", "        if (a.contains(b)) return true\n        for (i\
    \ <- 0 until b.length) {\n            val newB = (b.substring(i, b.length) + b.substring(0,\
    \ i))\n            if (a.contains(newB)) return true\n        }\n        return\
    \ false", "        if (a.length == b.length) {\n            a.indexOf(b) >= 0\
    \ || a.indexOf(b.tail + b.head) >= 0\n        } else {\n            false\n  \
    \      }", "        val c = a + a\n        c.contains(b)", "        val n = a.length;\
    \ val m = b.length\n        var startIndex = 0\n        var index = 0\n      \
    \  while (index < n) {\n            if (a(index) == b(startIndex)) {\n       \
    \         var i = index; var j = startIndex\n                var count = 0\n \
    \               while (j < m && a(i) == b(j)) {\n                    i = (i +\
    \ 1) % n\n                    j += 1\n                    count += 1\n       \
    \         }\n                if (count == m) return true\n            }\n    \
    \        index += 1\n        }\n        return false", "    \tif (a.length !=\
    \ b.length) return false\n    \tfor (i <- 0 until a.length) {\n    \t\tif (a.substring(i,\
    \ a.length) + a.substring(0, i) == b) return true\n    \t}\n    \treturn false",
  "        def solve(s : String) : Boolean = {\n            if (s.length != b.length)\
    \ return false\n            else {\n                if (s == b) return true\n\
    \                else return solve(s.substring(1) + s.substring(0, 1))\n     \
    \       }\n        }\n        if (b.length > a.length) return false\n        else\
    \ {\n            for (i <- 0 until a.length - b.length + 1) {\n              \
    \  if (solve(a.substring(i, i + b.length))) return true\n            }\n     \
    \       return false\n        }", "    \tval (m, n) = (a.length, b.length)\n \
    \   \tif (m < n) return false\n    \tval rotated = new Array[String](n)\n    \t\
    for (i <- 0 until n) rotated(i) = a.substring(i, n) + a.substring(0, i)\n    \t\
    rotated.contains(b)", "        if (a.length < b.length) return false\n       \
    \ val l = a.length\n        val n = b.length\n        val m = a + a\n        var\
    \ i = 0\n        while (i < l) {\n            if (a.substring(i, i + n) == b)\
    \ return true\n            i += 1\n        }\n        return false", "    \tif\
    \ (a.length < b.length) return false\n    \tval m = b.length\n    \tfor (i <-\
    \ 0 until a.length) {\n    \t\tvar matchCount = 0\n    \t\tfor (j <- 0 until m)\
    \ {\n    \t\t\tif (a((i + j) % a.length) == b(j)) matchCount += 1\n    \t\t}\n\
    \    \t\tif (matchCount == m) return true\n    \t}\n    \treturn false", "   \
    \     if (a.length < b.length) return false\n        for (i <- 0 until a.length)\
    \ {\n            if (a.substring(i) + a.substring(0, i) == b) return true\n  \
    \      }\n        return false", "        var result = false\n        for (i <-\
    \ 0 until b.length) {\n            val rot = b.drop(i) + b.take(i)\n         \
    \   if (a.contains(rot)) result = true\n        }\n        result", '        return
    false', "        var z = a;\n        for (i <- 1 to a.length) {\n            if\
    \ (a.indexOf(b) != -1) return true;\n            z = z.last + z.dropRight(1);\n\
    \        }\n        return false;", "        val n = a.length;\n        val m\
    \ = b.length;\n        var count = 0;\n        val aa = a + a;\n        val queue\
    \ = new Queue[Int]();\n        val occurrences = new HashMap[Char, Queue[Int]]();\n\
    \        var i = 0;\n        while (i < m) {\n            if (!occurrences.contains(b(i)))\
    \ {\n                occurrences += (b(i) -> new Queue[Int]());\n            }\n\
    \            occurrences(b(i)) += (i);\n            i += 1;\n        }\n     \
    \   i = 0;\n        while (i < n) {\n            if (occurrences.contains(aa(i)))\
    \ {\n                val q = occurrences(aa(i));\n                var offset =\
    \ q.dequeue();\n                if (offset == 0) {\n                    queue.enqueue(i);\n\
    \                }\n                else {\n                    occurrences(aa(i))\
    \ += offset;\n                }\n                count += 1;\n               \
    \ if (count == m) {\n                    val start = queue.dequeue();\n      \
    \              return aa.substring(start, start + m) == b;\n                }\n\
    \            }\n            else {\n                count = 0;\n             \
    \   queue.clear();\n            }\n            i += 1;\n        }\n        return\
    \ false;", "        val n = a.length; val m = b.length\n        if (m > n) return\
    \ false\n        for (i <- 0 until n) {\n            if (a.substring(i, n) + a.substring(0,\
    \ i) == b) return true\n        }\n        return false", "        var n = b.length\n\
    \        var s = b + b\n        s.toCharArray.sliding(n).contains(a)", "     \
    \   val l1 = a.length\n        val l2 = b.length\n        val s = a + a\n    \
    \    var found = false\n        for (i <- 0 until l1) {\n            val sub =\
    \ s.substring(i, i + l2)\n            if (sub == b) {\n                found =\
    \ true\n                return found\n            }\n        }\n        return\
    \ found", "        // a = \"abcd\"\n        // b = \"abd\"\n        // is \"abd\"\
    \ in \"abcd\"\n        // is \"bda\" in \"abcd\"\n        // is \"dab\" in \"\
    abcd\"\n        // is \"adb\" in \"abcd\"\n        // is \"bda\" in \"abcd\"\n\
    \        // is \"abd\" in \"abcd\"\n        def loop(a : String, b : String) :\
    \ Boolean = {\n            if (a.contains(b)) return true\n            if (b.length\
    \ == 0) return false\n            return loop(a, b.substring(1) + b.substring(0,\
    \ 1))\n        }\n        if (a.length < b.length) return false\n        return\
    \ loop(a, b)", "        var pattern = a\n        for (i <- 0 until a.length) {\n\
    \            if (pattern.indexOf(b) >= 0) return true\n            pattern = pattern.last\
    \ + pattern.init\n        }\n        return false", "      if (a.length < b.length)\
    \ false\n      else {\n        if (a.contains(b)) true\n        else {\n     \
    \     cycpatternCheck(a.substring(1) + a.substring(0, 1), b)\n        }\n    \
    \  }", "        if (a.length != b.length) return false\n        var s = a + a\n\
    \        return s.indexOf(b) >= 0", "        // Find the rotation-pattern matches\n\
    \        var rotations = Map[String, Boolean]()\n        for (i <- 0 until b.length)\
    \ {\n            val rotation = b.slice(i, b.length) + b.slice(0, i)\n       \
    \     rotations += (rotation -> true)\n        }\n        // Find any substring\
    \ matches\n        for (i <- 0 until a.length) {\n            for (j <- 1 to a.length\
    \ - i) {\n                val substr = a.slice(i, i + j)\n                if (rotations.contains(substr))\
    \ {\n                    return true\n                }\n            }\n     \
    \   }\n        return false", "        val bs = new ArrayBuffer[String]()\n  \
    \      for (i <- 0 until b.length) {\n            val shiftb = b.substring(i)\
    \ + b.substring(0, i)\n            bs += shiftb\n        }\n        bs.contains(b)\
    \ || bs.exists(x => a.contains(x))", '        (a.contains(b)) || (a.contains(b.substring(1)
    + b.substring(0, 1))) || (a.contains(b.substring(2) + b.substring(0, 2))) || (a.contains(b.substring(3)
    + b.substring(0, 3)))', "        val rotations = b.indices.map(i => b.substring(i)\
    \ + b.substring(0, i))\n        rotations.exists(rot => a.contains(rot))", " \
    \     def hasCyclic(a : String, b : String) : Boolean = {\n        val n = a.length\n\
    \        val m = b.length\n        var i = 0\n        while (i < m) {\n      \
    \    if (a(i) != b(0)) i += 1\n          else {\n            var j = 1\n     \
    \       while (j < m && a((i + j) % n) == b(j)) j += 1\n            if (j == m)\
    \ return true\n            else i += 1\n          }\n        }\n        false\n\
    \      }\n      hasCyclic(a, b) || hasCyclic(a, b.reverse)", "        // first\
    \ approach is to simply rotate b using a buffer, get the first char out, then\
    \ put it at the back. Do this until b is the same as a\n        val aa = a.toCharArray\n\
    \        val bb = b.toCharArray\n        var aab = new ArrayBuffer[Char]\n   \
    \     var bbb = new ArrayBuffer[Char]\n        for (i <- 0 until aa.length) aab\
    \ += aa(i)\n        for (i <- 0 until bb.length) bbb += bb(i)\n        for (i\
    \ <- 0 until bbb.length) {\n            val c = bbb(0)\n            bbb += c\n\
    \            bbb.remove(0)\n            if (bbb.mkString == a) return true\n \
    \       }\n        return false", "        val pat = b\n        var s = a\n  \
    \      for (i <- 0 until a.length) {\n            if (s.substring(0, b.length)\
    \ == pat) return true\n            s = s.substring(1) + s.substring(0, 1)\n  \
    \      }\n        return false", "        val n = a.length\n        val m = b.length\n\
    \        var s = b + b\n        (0 until n).exists(i => {\n            val sub1\
    \ = a.substring(i, i + m)\n            val sub2 = a.substring(i + m)\n       \
    \     (sub1 + sub2).equals(s)\n        })", "        val k = b.length\n      \
    \  val n = a.length\n        for (i <- 0 until n - k + 1) {\n            val c\
    \ = a.substring(i, i + k)\n            var j = 0\n            while (j < k &&\
    \ b(j) == c(j)) j += 1\n            if (j == k) return true\n        }\n     \
    \   return false", "        //BAD CODE!\n        val len = b.length\n        val\
    \ len2 = a.length\n        var newA = a\n        for (i <- 0 until len) {\n  \
    \          if (newA.contains(b)) {\n                return true\n            }\n\
    \            newA = newA.substring(1, len2) + newA.substring(0, 1)\n        }\n\
    \        return false", "        if (a.length != b.length) {\n            return\
    \ false\n        }\n        val b2 = b + b\n        return b2.indexOf(a) != -1",
  "        if (a.length < b.length) return false\n        val bLen = b.length\n  \
    \      var i = 0\n        while (i < a.length) {\n            if (a.substring(i,\
    \ i + bLen) == b) return true\n            i += 1\n        }\n        return false",
  "        var copy = a;\n        for (i <- 1 to a.length) {\n            if (a.contains(copy))\
    \ return true;\n            copy = copy.tail + copy.head;\n        }\n       \
    \ return false;", "    \tval b1 = b * 2\n    \tval n = b.length\n    \tval m =\
    \ a.length\n    \tval a1 = a * 2\n    \tvar i = 0\n    \tvar j = 0\n    \twhile\
    \ (i < m) {\n    \t\tif (a1(i) == b1(j)) {\n    \t\t\ti += 1\n    \t\t\tj += 1\n\
    \    \t\t} else {\n    \t\t\ti = i - j + 1\n    \t\t\tj = 0\n    \t\t}\n    \t\
    \tif (j == n) return true\n    \t}\n    \treturn false", "        val rotations\
    \ = for (i <- 0 until b.length) yield b.substring(i) + b.substring(0, i)\n   \
    \     rotations.contains(a)", "        // Your Implementation Here\n        val\
    \ n = a.length\n        val m = b.length\n        if (n < m) return false\n  \
    \      val aRotation = b + b\n        val aList = a.toList\n        val aRotationList\
    \ = aRotation.toList\n        var shift = 0\n        while (shift < n) {\n   \
    \         val newList = aList.drop(shift) ++ aList.take(shift)\n            if\
    \ (newList.sameElements(aRotationList.take(n))) return true\n            shift\
    \ += 1\n        }\n        return false", "        var first = a.toList\n    \
    \    var second = b.toList\n        def rotate(a : List[Char], b : List[Char])\
    \ : List[Char] = {\n            return a.drop(1) ::: List(a.head)\n        }\n\
    \        var i = 0\n        while (i < first.length) {\n            var k = 0\n\
    \            var m = 0\n            while (k < second.length) {\n            \
    \    if (first(k) == second(m)) {\n                    k += 1\n              \
    \      m += 1\n                } else break\n            }\n            if (k\
    \ == second.length) return true\n            first = rotate(first, first)\n  \
    \          i += 1\n        }\n        return false", "        val aLen = a.length;\n\
    \        val bLen = b.length;\n        if (aLen < bLen) {\n            false\n\
    \        } else {\n            val as = a.split(\"\");\n            var first\
    \ = as.take(bLen);\n            var l = first.mkString;\n            if (l ==\
    \ b) return true;\n            for (i <- bLen until aLen) {\n                first\
    \ = first.drop(1);\n                first = first.+:(as(i));\n               \
    \ l = first.mkString;\n                if (l == b) return true;\n            }\n\
    \            false\n        }", "        var s = b\n        for (i <- 0 until\
    \ b.length) {\n            if (a.contains(s)) return true\n            s = s.substring(1)\
    \ + s.charAt(0)\n        }\n        return false", "        val n = a.length;\
    \ val m = b.length\n        val lps = new Array[Int](m)\n        lps(0) = 0\n\
    \        var i = 1; var j = 0\n        while (i < m) {\n            if (b(i) ==\
    \ b(j)) {\n                lps(i) = j + 1\n                i += 1; j += 1\n  \
    \          } else {\n                if (j != 0) j = lps(j - 1)\n            \
    \    else {\n                    lps(i) = 0\n                    i += 1\n    \
    \            }\n            }\n        }\n        i = 0; j = 0\n        while\
    \ (i < n) {\n            if (a(i) == b(j)) {\n                i += 1; j += 1\n\
    \            } else {\n                if (j != 0) j = lps(j - 1)\n          \
    \      else i += 1\n            }\n            if (j == m) return true\n     \
    \   }\n        i = 0; j = 0\n        while (i < n) {\n            if (a(i) ==\
    \ b(j)) {\n                i += 1; j += 1\n            } else {\n            \
    \    if (j != 0) j = lps[j - 1]\n                else i += 1\n            }\n\
    \            if (j == m) return true\n        }\n        false", "    \t(b.length\
    \ <= a.length) && (a.concat(a).indexOf(b) != -1)", "        val bLen = b.length\n\
    \        val c = b + b\n        return c.contains(a)", "        if (a.length <\
    \ b.length) false\n        else {\n            var matchCount = 0\n          \
    \  for (i <- 0 until a.length - b.length + 1) {\n                val aPart = a.substring(i,\
    \ i + b.length)\n                if (aPart == b) matchCount += 1\n           \
    \ }\n            if (matchCount == 0) false\n            else true\n        }",
  "        // stores the substring of b and the number of times it occurs in a\n \
    \       var substrings = Map[String, Int]()\n        // iterate through the 1st\
    \ word with a sliding window of length of the 2nd word\n        for (i <- 0 to\
    \ a.length - b.length) {\n            val newSubstring = a.substring(i, i + b.length)\n\
    \            // if we have already processed this substring then we have already\
    \ done the comparisons so continue to the next substring\n            if (substrings.contains(newSubstring))\
    \ {\n                substrings(newSubstring) += 1\n                continue\n\
    \            }\n            // iterate through the 2nd word and start a sliding\
    \ window of length of the 2nd word\n            for (j <- 0 to b.length - 1) {\n\
    \                val substring = newSubstring.substring(j, j + b.length)\n   \
    \             substrings(substring) = 1\n                // if the substring of\
    \ the 2nd word is a substring of the 1st word then return true\n             \
    \   if (b.contains(substring)) return true\n            }\n        }\n       \
    \ false", "        val rotate = (word : String) => {word.tail + word.head}\n \
    \       val sub = (a : String, b : String) => {\n            val arr = a.toCharArray\n\
    \            var index = 0\n            for (i <- 0 until arr.length) {\n    \
    \            if (arr(i) == b.head) {\n                    index = i\n        \
    \            break\n                }\n            }\n            val rotarr =\
    \ rotate(arr.mkString(\"\")).toCharArray\n            var rotindex = 0\n     \
    \       for (i <- 0 until rotarr.length) {\n                if (rotarr(i) == b.head)\
    \ {\n                    rotindex = i\n                    break\n           \
    \     }\n            }\n            index != rotindex\n        }\n        sub(a,\
    \ b)", "        val L = b.length\n        var t = b + b\n        return t.contains(a)",
  "        if (a.length < b.length) false\n        else {\n            val s = a.substring(0,\
    \ b.length)\n            if (s == b) true\n            else cycpatternCheck(a.substring(1)\
    \ + a.substring(0, 1), b)\n        }", "        var second : String = b\n    \
    \    for (i <- 0 until b.length) {\n            if (a.contains(second)) return\
    \ true\n            second = second.drop(1) + second.take(1)\n        }\n    \
    \    return false", "        val cycled = b.toList.tail ::: b.toList.head :: Nil\n\
    \        (b.toList.tails map {x => x.mkString}).toList contains (b) || (cycled.tails\
    \ map {x => x.mkString}).toList contains (b)", "        val n = a.length\n   \
    \     val m = b.length\n        val rotations = for (i <- 0 until m) yield {\n\
    \            val (front, back) = b.splitAt(i)\n            back + front\n    \
    \    }\n        rotations.exists(rotation => a.contains(rotation))", '        return
    false', "        // Write your code here\n        false", "        if (a.length\
    \ < b.length) false\n        else if (a.length == b.length) return (a == b)\n\
    \        else {\n            val (s1, s2) = if (a.length < b.length) (a, b) else\
    \ (b, a)\n            val rotations = (0 until s2.length).map(i => s2.slice(i,\
    \ s2.length) + s2.slice(0, i))\n            rotations.contains(s1)\n        }",
  "        def rotations(s : String) : List[String] = {\n            val l = s.length\n\
    \            (0 until l).map(i => {\n                var index = i\n         \
    \       val rot = new StringBuilder(l)\n                while (index < l) {\n\
    \                    rot.append(s(index))\n                    index += 1\n  \
    \              }\n                index = 0\n                while (index < i)\
    \ {\n                    rot.append(s(index))\n                    index += 1\n\
    \                }\n                rot.toString\n            }).toList\n    \
    \    }\n        for (rot <- rotations(b)) {\n            if (a.contains(rot))\
    \ return true\n        }\n        false", "        val bSize = b.size\n      \
    \  for (i <- 0 until bSize) {\n            val rotated = b.substring(i, bSize)\
    \ + b.substring(0, i)\n            if (a.contains(rotated)) return true\n    \
    \    }\n        return false", "        var c = b.charAt(0)\n        for (i <-\
    \ 0 until a.length) {\n            if (a.charAt(i) == c) {\n                var\
    \ j = 0\n                var k = i\n                while (j < b.length && a.charAt(k)\
    \ == b.charAt(j)) {\n                    j += 1\n                    k += 1\n\
    \                    if (k == a.length) k = 0\n                }\n           \
    \     if (j == b.length) return true\n            }\n        }\n        return\
    \ false", "        def helper(word : String, rotation : String) : Boolean = {\n\
    \            if (word == \"\") true\n            else if (word(0) == rotation(0))\
    \ {\n                var tmp = word.substring(1)\n                if (tmp == rotation.substring(1))\
    \ true\n                else helper(tmp, rotation.substring(1))\n            }\n\
    \            else helper(word.substring(1), rotation)\n        }\n        if (a.length\
    \ < b.length) false\n        else if (a.length == b.length) a == b\n        else\
    \ {\n            def rotation(i : Int) : String = {\n                if (i ==\
    \ b.length) \"\"\n                else b(i) + rotation(i + 1)\n            }\n\
    \            var tmp = a\n            if (helper(tmp, b)) true\n            else\
    \ {\n                def getRotation(i : Int) : Boolean = {\n                \
    \    if (i == b.length) false\n                    else if (helper(tmp, rotation(i)))\
    \ true\n                    else getRotation(i + 1)\n                }\n     \
    \           getRotation(0)\n            }\n        }", "        if (a.length ==\
    \ 0) return false\n        val looped = (a ++ a).substring(a.length, a.length\
    \ * 2)\n        looped.contains(b)", "        def isRot(i : Int) : Boolean = {\n\
    \            val fhalf = a.slice(0, i)\n            val shalf = a.slice(i, a.length)\n\
    \            (shalf + fhalf).contains(b)\n        }\n        val b0 = b(0)\n \
    \       val indicies = (0 until a.length).filter(i => a(i) == b0)\n        indicies.map(isRot).reduce(_\
    \ || _)", "    \tval aa = a.toList\n    \tval n = a.length\n    \tvar bb = b.toList\n\
    \    \tfor (i <- 0 until n) {\n    \t\tif (aa.containsSlice(bb)) return true\n\
    \    \t\tbb = bb.last :: bb.init\n    \t}\n    \treturn false", "        def check(a\
    \ : String, b : String) : Boolean = {\n            if (a.size == b.size) {\n \
    \               if (a == b) return true\n                var k = 1\n         \
    \       for (i <- 0 until a.size) {\n                    var str = \"\"\n    \
    \                for (j <- 0 until a.size) {\n                        str += a((i\
    \ + j * k) % a.size)\n                    }\n                    if (str == b)\
    \ return true\n                }\n                return false\n            }\n\
    \            else return false\n        }\n        return check(a, b) || check(b,\
    \ a)", "        val bmap = new HashMap[Char, Int]()\n        for (i <- 0 until\
    \ b.length) {\n            if (bmap.contains(b(i))) bmap(b(i)) += 1\n        \
    \    else bmap += b(i) -> 1\n        }\n        def canForm(s : String) : Boolean\
    \ = {\n            val smap = new HashMap[Char, Int]()\n            for (i <-\
    \ 0 until s.length) {\n                if (smap.contains(s(i))) smap(s(i)) +=\
    \ 1\n                else smap += s(i) -> 1\n            }\n            for (k\
    \ <- bmap.keys) {\n                if (!smap.contains(k) || smap(k) < bmap(k))\
    \ return false\n            }\n            true\n        }\n        for (i <-\
    \ 0 until a.length) {\n            if (canForm(a.substring(i) + a.substring(0,\
    \ i))) return true\n        }\n        false"]
stop_tokens:
- "\n    }\n"
