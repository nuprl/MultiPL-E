name: HumanEval_22_filter_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Filter given list of any scalathon values only for integers\n    // >>>\
  \ filterIntegers((List[Any](\"a\", 3.14f, 5l)))\n    // (List[Long](5l.toLong))\n\
  \    // >>> filterIntegers((List[Any](1l, 2l, 3l, \"abc\", Map[Long,Long](), List[Long]())))\n\
  \    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))\n    def filterIntegers(values\
  \ : List[Any]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(filterIntegers((List[Any]())).equals((List[Long]())));\n\
  \    assert(filterIntegers((List[Any](4l, Map[Long,Long](), List[Long](), 23.2f,\
  \ 9l, \"adasd\"))).equals((List[Long](4l.toLong, 9l.toLong))));\n    assert(filterIntegers((List[Any](3l,\
  \ \"c\", 3l, 3l, \"a\", \"b\"))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong))));\n\
  \    }\n\n}\n"
completions: ['        values.filter(x => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])',
  '        values.filter { _.isInstanceOf[Long] }.map { _.asInstanceOf[Long] }', "\t\
    values.filter(x => (x.isInstanceOf[Long] || x.isInstanceOf[Int])).map(x => x.asInstanceOf[Long])",
  "        val ret = new ArrayBuffer[Long]()\n        for (v <- values) {\n      \
    \      v match {\n                case v: Long => ret += v\n                case\
    \ _ =>\n            }\n        }\n        ret.toList", '        return Nil;',
  '        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])', '      values.filter(x
    => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])', '        for(value <-
    values; if value.isInstanceOf[Long]) yield value.asInstanceOf[Long]', "      \
    \  // YOUR CODE GOES HERE\n        def filtInteger(values : List[Any], integers\
    \ : List[Long]) : List[Long] = {\n            if (values.isEmpty) {\n        \
    \        integers\n            } else {\n                values.head match {\n\
    \                    case x : Long => filtInteger(values.tail, integers :+ x)\n\
    \                    case _ => filtInteger(values.tail, integers)\n          \
    \      }\n            }\n        }\n        filtInteger(values, List[Long]())",
  "        var integers: List[Long] = List[Long]()\n        // Fill in here\n    \
    \    return integers", "    \t//filterIntegers(values, List[Long]())\n    \t//\
    \ values.filter(e => e.isInstanceOf[Long]).asInstanceOf[List[Long]]\n    \tvalues.collect\
    \ { case x: Long => x }", '        values.filter(x => (x.isInstanceOf[Long] ||
    x.isInstanceOf[Int])).map(x => x.asInstanceOf[Long])', '        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])',
  "        val result = new ListBuffer[Long]\n        for (value <- values) {\n  \
    \          value match {\n                case l : Long => result += l\n     \
    \           case _ => ()\n            }\n        }\n        result.toList", '        values.filter
    { case i: Long => true; case _ => false }.asInstanceOf[List[Long]]', "       \
    \ var res = List[Long]()\n        for (i <- values) {\n            if (i.isInstanceOf[Long])\
    \ {\n                res = res :+ i.asInstanceOf[Long]\n            }\n      \
    \  }\n        return res", "        val listOfIntegers = ListBuffer[Long]()\n\
    \        for (a <- values) {\n            if (a.isInstanceOf[Long]) {\n      \
    \          listOfIntegers += a.asInstanceOf[Long]\n            }\n        }\n\
    \        listOfIntegers.toList", "        def fi(values : List[Any], acc : List[Long])\
    \ : List[Long] = values match {\n            case Nil => acc\n            case\
    \ head :: tail => head match {\n                case i : Long => fi(tail, i ::\
    \ acc)\n                case _ => fi(tail, acc)\n            }\n        }\n  \
    \      fi(values, Nil)", '        return values.filter(x => x.isInstanceOf[Long]).map(x
    => x.asInstanceOf[Long])', "\t    // fill-in here", "        val intList = new\
    \ ArrayBuffer[Long]()\n        values.foreach(x => if (x.isInstanceOf[Long]) intList\
    \ += x.asInstanceOf[Long])\n        intList.toList", "        var result : List[Long]\
    \ = List[Long]()\n        for ( v <- values ) {\n            v match {\n     \
    \           case i : Int => result = result :+ i.toLong\n                case\
    \ i : Long => result = result :+ i\n                case _ => ()\n           \
    \ }\n        }\n        return result", "        values.filter(v => (v match {\n\
    \            case i : Long => true\n            case i : Int => true\n       \
    \     case _ => false\n        })).map(v => (v match {\n            case i : Long\
    \ => i\n            case i : Int => i.toLong\n        }))", '        values.filter(p
    => p.isInstanceOf[Long]).map(p => p.asInstanceOf[Long])', "        // Write code\
    \ here.\n        val ret = ListBuffer[Long]()\n        for (value <- values) {\n\
    \            if (value.isInstanceOf[Long]) {\n                ret += value.asInstanceOf[Long]\n\
    \            }\n        }\n        ret.toList", "        values.filter {\n   \
    \         case value : Long => true\n            case _ => false\n        }.map(\
    \ _.asInstanceOf[Long] )", "        // Fill Up this method body\n        // `values`\
    \ is a list of mixed type values, so one should first\n        // filter out all\
    \ non-integer values and then cast the integer\n        // values to long (as\
    \ we want only long values in output)\n        // Hint: Use pattern matching and\
    \ isInstanceOf method to check\n        // whether a value is of type Integer\
    \ (or a primitive integer)\n        // Hint: Use asInstanceOf method to cast an\
    \ object to a required type\n        var newList = values.filter(x => (x.isInstanceOf[Int]\
    \ || x.isInstanceOf[Long]))\n        return newList.map(x => x.asInstanceOf[Long])",
  '        values.filter(p => p.isInstanceOf[Long]).map(_.asInstanceOf[Long])', '        return
    values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])', "\t\tvalues.filter((x\
    \ : Any) => x.isInstanceOf[Long]).map((x : Any) => x.asInstanceOf[Long])", " \
    \       def helper(orig : List[Any], res : List[Long]) : List[Long] = {\n    \
    \        if (orig.isEmpty) {\n                res\n            } else {\n    \
    \            if (orig.head.isInstanceOf[Long]) {\n                    helper(orig.tail,\
    \ res :+ orig.head.asInstanceOf[Long])\n                } else {\n           \
    \         helper(orig.tail, res)\n                }\n            }\n        }\n\
    \        helper(values, List[Long]())", '      values.filter(x => x.isInstanceOf[Long]).map(x
    => x.asInstanceOf[Long])', "        var result : List[Long] = Nil\n        for\
    \ (x <- values) {\n            if (x.isInstanceOf[Long]) {\n                result\
    \ = x.asInstanceOf[Long] :: result\n            }\n        }\n        result",
  "        var intList : List[Long] = Nil\n        for (v <- values) {\n         \
    \   if (v.isInstanceOf[Long]) {\n                intList = intList :+ v.asInstanceOf[Long]\n\
    \            }\n        }\n        return intList", "        var retVal = List[Long]()\n\
    \        values.foreach {\n            case value: Int => retVal = value.toLong\
    \ :: retVal\n            case value: Long => retVal = value :: retVal\n      \
    \      case _ => ()\n        }\n        retVal", "        // Write your solution\
    \ here\n        values.filter(x => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])",
  "        //println(\"In filterIntegers values: \" + values)\n        values.filter(a\
    \ => a.isInstanceOf[Long]).map(a => a.asInstanceOf[Long])", '        values.filter(x
    => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])', "        // TODO: implement\
    \ this\n        // Hint: use `isInstanceOf`\n        ???", '        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])',
  "        values.foldLeft(List[Long]())((list,x) => x match {\n            case x\
    \ : Int => list :+ x.toLong\n            case x : Long => list :+ x\n        \
    \    case _ => list\n        })", "\t    values.filter(_.isInstanceOf[Long]).map(x\
    \ => x.asInstanceOf[Long])", "        values.map(value => value match {\n    \
    \        case x: Long => x\n            case _ => 0l\n        }).filter(value\
    \ => value != 0l)", "        values.flatMap(x => x match {\n            case v\
    \ : Long => List(v)\n            case _ => Nil\n        })", "        def recur(values\
    \ : List[Any], result : List[Long]) : List[Long] = {\n            if (values.length\
    \ == 0) result\n            else if (values.head.isInstanceOf[Long]) {\n     \
    \           recur(values.tail, result :+ values.head.asInstanceOf[Long])\n   \
    \         }\n            else {\n                recur(values.tail, result)\n\
    \            }\n        }\n        recur(values, List[Long]())", "        (for\
    \ (value <- values) yield value match {\n            case i : Long => i\n    \
    \        case _ =>\n        }).filter(_ != null)", '        values.filter(i =>
    i.isInstanceOf[Long] || i.isInstanceOf[Int]).map(i => i.asInstanceOf[Long])',
  '        values.filter(v => v.isInstanceOf[Long]).map(v => v.asInstanceOf[Long])',
  '        values.filter(x => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])',
  "        // TODO\n        null", "        var result = new ListBuffer[Long]\n  \
    \      for (value <- values) {\n            value match {\n                case\
    \ i : Int => result += i.toLong\n                case l : Long => result += l\n\
    \                case _ =>\n            }\n        }\n        result.toList",
  "\t    def filterIntegersHelper(values : List[Any], filteredValues : List[Long])\
    \ : List[Long] = {\n\t\t    if (values.isEmpty)\n\t\t\t    filteredValues\n\t\t\
    \    else {\n\t\t\t    values.head match {\n\t\t\t\t    case x : Long => filterIntegersHelper(values.tail,\
    \ filteredValues :+ x)\n\t\t\t\t    case _ => filterIntegersHelper(values.tail,\
    \ filteredValues)\n\t\t\t    }\n\t\t    }\n\t    }\n\t    filterIntegersHelper(values,\
    \ List[Long]())", '        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])',
  "        var result : List[Long] = Nil\n        for (value <- values) {\n      \
    \      value match {\n                case a : Long => result = result :+ a\n\
    \                case _ => ()\n            }\n        }\n        return result",
  "        val result = ListBuffer[Long]()\n        values.foreach(x => {\n      \
    \      x match {\n                case x:Long => result += x\n               \
    \ case _ =>\n            }\n        })\n        result.toList", "      values.collect\
    \ {\n        case x: Long => x\n      }", '        return values.filter(x => x.isInstanceOf[Long]).map(x
    => x.asInstanceOf[Long])', "        // YOUR CODE HERE\n        List[Long]()",
  "    \t\t// returns a list of integer values if exists else returns empty list\n\
    \    \t\tvalues.filter(x => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])",
  "        def filterIntegersHelper(values : List[Any], result : List[Long]) : List[Long]\
    \ = values match {\n            case x :: xs => x match {\n                case\
    \ x:Long => filterIntegersHelper(xs, result :+ x)\n                case _ => filterIntegersHelper(xs,\
    \ result)\n            }\n            case _ => result\n        }\n        filterIntegersHelper(values,\
    \ List[Long]())", "        // we can use match or if else\n        values match\
    \ {\n            case Nil => Nil\n            case x :: xs => \n             \
    \   if (isInteger(x)) x.asInstanceOf[Long] :: filterIntegers(xs)\n           \
    \     else filterIntegers(xs)\n        }", "        val result = new ListBuffer[Long]\n\
    \        for (x <- values) {\n            x match {\n                case i :\
    \ Int => result += i.toLong\n                case l : Long => result += l\n  \
    \              case _ =>\n            }\n        }\n        result.toList", " \
    \       // TODO.\n        // 1. Apply filter (or something similar) on given values\
    \ and return only integers.\n        // 2. Make sure to cast them to Long for\
    \ easy conversion later.\n        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])",
  "      return (values.map {\n        case l:Long => l.toLong\n        case _ =>\
    \ 0\n      }.filter(_ > 0))", "        // put your code here\n        return List[Long]()",
  "        val nums = ListBuffer[Long]()\n        for (n <- values) {\n          \
    \  n match {\n                case x: Int => nums += x.toLong\n              \
    \  case x: Long => nums += x\n                case _ => ()\n            }\n  \
    \      }\n        nums.toList", '        values.filter(value => value.isInstanceOf[Long]).map(x
    => x.asInstanceOf[Long])', "        // Write code here...\n        return values.filter(x\
    \ => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])", '        values.filter(value
    => value.isInstanceOf[Long]).map(value => value.asInstanceOf[Long])', "      \
    \  // Insert your code here\n        null", '      ???', '        values.filter(x
    => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])', '        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])',
  "        var list : List[Long] = Nil;\n        for (e <- values) {\n           \
    \ if (e.isInstanceOf[Long]) {\n                list = e.asInstanceOf[Long] ::\
    \ list;\n            }\n        }\n        return list;", "        val filtered_values\
    \ = ListBuffer[Long]()\n        for (i <- values) {\n            if (i.isInstanceOf[Long])\
    \ {\n                filtered_values += i.asInstanceOf[Long]\n            }\n\
    \        }\n        filtered_values.toList", "        var l = List[Long]()\n \
    \       for (v <- values) {\n            v match {\n                case x : Long\
    \ => l = l :+ x\n                case x : Int => l = l :+ x.toLong\n         \
    \       case _ => {}\n            }\n        }\n        return l", "      val\
    \ result = new ListBuffer[Long]\n      for (value <- values) {\n        value\
    \ match {\n          case i : Long => result += i\n          case i : Int => result\
    \ += i.toLong\n          case i : Short => result += i.toLong\n          case\
    \ i : Byte => result += i.toLong\n          case _ => None\n        }\n      }\n\
    \      result.toList", '        return values.filter(x => (x.isInstanceOf[Long]
    || x.isInstanceOf[Int])).map(x => x.asInstanceOf[Long])', "        //TODO: Complete\
    \ the implementation to return list of integers only\n        //Steps:\n     \
    \   //1. Use isInstanceOf to match for Int, Long, Short and Char types.\n    \
    \    //2. Use toLong to cast the value to Long\n        ???", "        val integers\
    \ = for (i <- values if i.isInstanceOf[Long]) yield i.asInstanceOf[Long]\n   \
    \     integers", "        if (values.length == 0) {\n            return List[Long]()\n\
    \        }\n        values.head match {\n            case v : Long => List[Long](v)\
    \ ++ filterIntegers(values.tail)\n            case _ => filterIntegers(values.tail)\n\
    \        }", "        return values.filter {\n            case a : Long => true\n\
    \            case _ => false\n        }.map {\n            case a : Long => a\n\
    \        }", "        var longList : List[Long] = List[Long]()\n        values.foreach\
    \ {\n            case x : Long => longList = longList :+ x\n            case _\
    \ => Unit\n        }\n        longList", "        def loop(values : List[Any],\
    \ result : List[Long]) : List[Long] = {\n            values match {\n        \
    \        case List() => result\n                case head :: tail => head match\
    \ {\n                    case v : Long => loop(tail, v :: result)\n          \
    \          case _ => loop(tail, result)\n                }\n            }\n  \
    \      }\n        loop(values, List[Long]())", "        var list = new ListBuffer[Long]()\n\
    \        for (x <- values) {\n            x match {\n                case x :\
    \ Int => list += x.toLong\n                case x : Long => list += x\n      \
    \          case _ =>\n            }\n        }\n        list.toList", '        return
    values.filter(_.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])', "       \
    \ val result : ListBuffer[Long] = ListBuffer[Long]()\n        values.foreach((v\
    \ : Any) => if (v.isInstanceOf[Long]) result += v.asInstanceOf[Long])\n      \
    \  result.toList", "        var longList = List[Long]()\n        for (value <-\
    \ values) {\n            try {\n                val longVal = value.asInstanceOf[Long]\n\
    \                longList = longList :+ longVal\n            } catch {\n     \
    \           case _ : Throwable => Unit\n            }\n        }\n        longList",
  "        values.filter {\n            x => (x.isInstanceOf[Long] | x.isInstanceOf[Int])\n\
    \        }.map(x => x.asInstanceOf[Long])", "      //var f = ListBuffer[Long]()\n\
    \      var f = List[Long]()\n      for (value <- values) {\n          if (value.isInstanceOf[Long])\
    \ {\n              f = value.asInstanceOf[Long] :: f\n          }\n      }\n \
    \     return f", "        // Write your implementation here\n        values.filter(x\
    \ => (x.isInstanceOf[Int] || x.isInstanceOf[Long])).map(x => x.asInstanceOf[Long])",
  '        values.filter(_.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])', '        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])',
  '        values.filter { x => x.isInstanceOf[Long] }.map { x => x.asInstanceOf[Long]
    }', '        values.filter(_.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])',
  '        return Nil', "        var result = List[Long]()\n        for (value <-\
    \ values) {\n            if (value.isInstanceOf[Long]) {\n                result\
    \ = result :+ value.asInstanceOf[Long]\n            }\n        }\n        return\
    \ result", '        values.filter(x => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])',
  '        values.filter(value => value.isInstanceOf[Long]).map(value => value.asInstanceOf[Long])',
  "        val result = new ListBuffer[Long]()\n        for (value <- values) {\n\
    \            try {\n                result += value.asInstanceOf[Long]\n     \
    \       } catch {\n                case e : ClassCastException =>\n          \
    \  }\n        }\n        result.toList", '        values.filter(x => x.isInstanceOf[Long]).map(x
    => x.asInstanceOf[Long])', '        // Write implementation here', '      values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])',
  '        List[Long]()', "        // Check if the param is List of Any\n        if\
    \ (values.isInstanceOf[List[Any]]) {\n            // Type casted to List of Any\n\
    \            val listOfAny: List[Any] = values.asInstanceOf[List[Any]]\n     \
    \       var resultList = List[Long]()\n            for (value <- listOfAny) {\n\
    \                // Check if the object is Long Type\n                if (value.isInstanceOf[Long])\
    \ {\n                    val intValue: Long = value.asInstanceOf[Long]\n     \
    \               resultList = resultList :+ intValue\n                }\n     \
    \       }\n            resultList\n        } else {\n            throw new IllegalArgumentException(\"\
    Argument should be List of Any\")\n        }", "        values.filter{\n     \
    \       case x : Long => true\n            case _ => false\n        }.map{\n \
    \           case x : Long => x\n        }", "        val integers = for(v <- values\
    \ if v.isInstanceOf[Long]) yield v.asInstanceOf[Long]\n        return integers",
  '        values.filter(x => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])',
  '        // Add your code here', '      values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])',
  "        values.foldLeft(new ListBuffer[Long]())((l, n) => { n match {\n       \
    \     case l : Long => l.+=:(n.asInstanceOf[Long])\n            case i : Int =>\
    \ l.+=:(n.asInstanceOf[Int].toLong)\n            case _ => l\n        }\n    \
    \    }).toList", "        // Fill in here\n        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])",
  "        // >>> filterIntegers((List[Any](\"a\", 3.14f, 5l)))\n        // (List[Long](5l.toLong))\n\
    \        // >>> filterIntegers((List[Any](1l, 2l, 3l, \"abc\", Map[Long,Long](),\
    \ List[Long]())))\n        // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))\n\
    \        var intValues = List[Long]()\n        var i = 0\n        while (i < values.length)\
    \ {\n            var value = values(i)\n            value match {\n          \
    \      case intValue : Long => intValues = intValues :+ intValue\n           \
    \     case _ => \n            }\n            i += 1\n        }\n        intValues",
  '        values.filter(_.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])', '        values.filter(x
    => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])', "        def filterInteger(value\
    \ : Any) : Boolean = {\n            value match {\n                case value\
    \ : Long => true\n                case _ => false\n            }\n        }\n\
    \        values.filter(filterInteger).map(_.asInstanceOf[Long])", '        values.filter(v
    => v.isInstanceOf[Long]).map(v => v.asInstanceOf[Long])', "        var integers\
    \ = List[Long]()\n        for (value <- values) {\n            value match {\n\
    \                case int:Int => integers = integers :+ int.toLong\n         \
    \       case int:Long => integers = integers :+ int\n                case _ =>\
    \ ()\n            }\n        }\n        integers", "        // Start your code\
    \ here.\n        var intList: List[Long] = List()\n        for (a <- values) {\n\
    \            if (a.isInstanceOf[Long]) {\n                intList = a.asInstanceOf[Long]\
    \ :: intList\n            }\n        }\n        intList.reverse", '        values.filter(isInt).map(x
    => x.asInstanceOf[Long])', '        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])',
  '        values.filter(e => e.isInstanceOf[Long]).map(e => e.asInstanceOf[Long])',
  "      var value = values.filter(x => x.isInstanceOf[Long])\n      return value.map(_.asInstanceOf[Long])",
  "        var new_list : List[Long] = List()\n        values.foreach((i) => {\n \
    \           if (i.isInstanceOf[Long]) new_list = new_list.::(i.asInstanceOf[Long])\n\
    \        })\n        return new_list", '        throw new NotImplementedError("TODO:
    implement")', "        val res = ListBuffer[Long]()\n        for (value <- values)\n\
    \            if (value.isInstanceOf[Long])\n                res += value.asInstanceOf[Long]\n\
    \        res.toList", "        // TODO Implement this method.\n        // This\
    \ implementation returns the input\n        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])",
  '        values.filter(el => el.isInstanceOf[Long] || el.isInstanceOf[Int]).map(el
    => el.asInstanceOf[Long])', "        val emptyList = List[Long]()\n        return\
    \ values.filter(v => v.isInstanceOf[Long]).map(n => n.asInstanceOf[Long])", " \
    \       // TODO 1\n        Nil", "        var ret : List[Long] = List()\n    \
    \    for (v <- values) {\n            v match {\n                case i : Int\
    \ => ret = ret :+ i.toLong\n                case l : Long => ret = ret :+ l\n\
    \                case _ =>\n            }\n        }\n        ret", '      values.filter(x
    => x.isInstanceOf[Long]).map(_.asInstanceOf[Long])', '        values.filter(x
    => isInteger(x)).map(_.asInstanceOf[Long])', "        val filtered = for (a <-\
    \ values if a.isInstanceOf[Long]) yield a.asInstanceOf[Long]\n        filtered",
  "        if (values.isEmpty)\n            List[Long]()\n        else {\n       \
    \     val head = values.head\n            val tail = values.tail\n           \
    \ if (head.isInstanceOf[Long])\n                List[Long](head.asInstanceOf[Long])\
    \ ++ filterIntegers(tail)\n            else\n                filterIntegers(tail)\n\
    \        }", '      values.filter(v => v.isInstanceOf[Long]).map(v => v.asInstanceOf[Long])',
  "        // Complete this function.\n        values.filter(v => v.isInstanceOf[Long]).map(l\
    \ => l.asInstanceOf[Long])", '        throw new NotImplementedError("filterIntegers");',
  '      values.filter({ x => x.isInstanceOf[Long] }).map({ x => x.asInstanceOf[Long]
    })', "        values.foldLeft(List[Long]())((acc, v) => v match {\n          \
    \  case n : Long => n :: acc\n            case _ => acc\n        })", "      \
    \  values.filter{\n            case i : Int => true\n            case i : Long\
    \ => true\n            case _ => false\n        }.map{\n            case i : Int\
    \ => i.toLong\n            case i : Long => i\n        }", '        // your code
    goes here', "      var filteredInts : List[Long] = List()\n      values.foreach{\
    \ value =>\n          if (value.isInstanceOf[Long])\n            filteredInts\
    \ = filteredInts :+ value.asInstanceOf[Long]\n      }\n      filteredInts", " \
    \       // TODO: Complete the problem here\n        values.filter(v => v.isInstanceOf[Long]).map(x\
    \ => x.asInstanceOf[Long])", "        values.foldLeft(List[Long]())((accum, currentVal)\
    \ => {\n            currentVal match {\n                case curVal:Long => (accum\
    \ :+ curVal)\n                case _ => accum\n            }\n        })", '        //
    @todo', '        values.filter(isInt).map(_.asInstanceOf[Long])', "      values\
    \ match {\n        case Nil => Nil\n        case (head: Long) :: tail => head\
    \ :: filterIntegers(tail)\n        case _ :: tail => filterIntegers(tail)\n  \
    \    }", "        // TODO: Implement the function\n        return List[Long]()",
  '        ???', "        values.foldLeft(List[Long]())((a,b) => {\n            if\
    \ (b.isInstanceOf[Long]) a :+ b.asInstanceOf[Long]\n            else a\n     \
    \   })", "        var ints = List[Long]()\n        for (n <- values) {\n     \
    \       try {\n                ints = ints :+ n.asInstanceOf[Long]\n         \
    \   } catch {\n                case _ : Throwable => None\n            }\n   \
    \     }\n        return ints", '        return values.filter(isInteger).map(_.asInstanceOf[Long])',
  "      values.filter { x =>\n        x match {\n          case x : Long => true\n\
    \          case _ => false\n        }\n      }.map { _.asInstanceOf[Long] }",
  "        val filtered = values.filter(v => v.isInstanceOf[Long] || v.isInstanceOf[Int])\n\
    \        filtered.map(_.asInstanceOf[Long])", "      // TODO\n      return List[Long]()",
  '        values.filter(p => p.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])',
  "        val result = new ListBuffer[Long]()\n        values.foreach(x => {\n  \
    \          x match {\n                case x : Int => result += x.toLong\n   \
    \             case x : Long => result += x\n                case _ => // Do nothing\n\
    \            }\n        })\n        result.toList", '        return values.filter(v
    => v.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])', '        values.filter(x
    => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])', "        val integers\
    \ = new ListBuffer[Long]()\n        values.foreach(\n            i => i match\
    \ {\n                case i : Long => integers += i\n                case _ =>\n\
    \            }\n        )\n        integers.toList", "        var integers = ArrayBuffer[Long]()\n\
    \        values.foreach {\n            value =>\n                value match {\n\
    \                    case x : Long => integers += x\n                    case\
    \ x : Int => integers += x.toLong\n                    case _ =>\n           \
    \     }\n        }\n        integers.toList", "        // Write code here\n  \
    \      return (List[Long]())", "        val filtered = values.filter({case x:\
    \ Long => true case _ => false})\n        filtered.map(x => x.asInstanceOf[Long])",
  "        // your implementation here\n        var result = new ListBuffer[Long]()\n\
    \        for (elem <- values) {\n          elem match {\n            case elem:\
    \ Int => result += elem.toLong\n            case elem: Long => result += elem\n\
    \            case _ =>\n          }\n        }\n        result.toList", "    \
    \    // <<Complete this function>>\n        var l = List[Long]()\n        for\
    \ (v <- values) {\n            v match {\n                case x: Int => l = l\
    \ :+ x.toLong\n                case x: Long => l = l :+ x\n                case\
    \ _ =>\n            }\n        }\n        l", "        val numbers = values.collect{case\
    \ i:Long => i}\n        return numbers", "        // BEGIN SOLUTION\n        val\
    \ filtered = values.filter(x => x.isInstanceOf[Long])\n        val longs = filtered.map(x\
    \ => x.asInstanceOf[Long])\n        longs\n        // END SOLUTION", '        values.filter(x
    => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])', "      // TODO: Implement\
    \ me\n      values.filter(x => x.isInstanceOf[Long]).map(x => x.asInstanceOf[Long])",
  "        // Implement your code here\n        values.filter(x => x.isInstanceOf[Long]).map(x\
    \ => x.asInstanceOf[Long])", "        val integers = ListBuffer[Long]()\n    \
    \    for (value <- values) {\n            if (value.isInstanceOf[Long]) {\n  \
    \              integers += value.asInstanceOf[Long]\n            }\n        }\n\
    \        integers.toList", "        val integers : ListBuffer[Long] = ListBuffer[Long]()\n\
    \        for (value <- values) {\n            if (value.isInstanceOf[Long]) {\n\
    \                integers += value.asInstanceOf[Long]\n            }\n       \
    \ }\n        integers.toList", '        values.flatMap(x => if (x.isInstanceOf[Long])
    List(x.asInstanceOf[Long]) else List[Long]())', "        values.filter {\n   \
    \         case _: Int => true\n            case _: Long => true\n            case\
    \ _ => false\n        }.map(_.asInstanceOf[Long])", '        ???', "        var\
    \ l : List[Long] = List[Long]()\n        for (v <- values) {\n            v match\
    \ {\n                case x : Long => l = l :+ x.toLong\n                case\
    \ x : Int => l = l :+ x.toLong\n                case x : Short => l = l :+ x.toLong\n\
    \                case x : Byte => l = l :+ x.toLong\n                case _ =>\
    \ \n            }\n        }\n        return l", "        // TODO: Implement this\
    \ method\n        return null", '        values.filter(x => x.isInstanceOf[Long]).map(x
    => x.asInstanceOf[Long])', '        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])',
  "        // Given a list of integers and a number 'n', find 3 numbers in the list\
    \ that add up to 'n'\n        // >>> find3NumbersThatAddTo(List[Long](1l, 2l,\
    \ 3l, 4l, 5l, -1l, 6l, 7l, 8l, 9l, -4l, 10l), 3l)\n        // (List[(Long, Long,\
    \ Long)]((-1l.toLong, 2l.toLong, 1l.toLong), (-4l.toLong, 1l.toLong, 3l.toLong),\
    \ (-4l.toLong, 2l.toLong, 2l.toLong)))\n        def find3NumbersThatAddTo(numbers\
    \ : List[Long], num : Long) : List[(Long, Long, Long)] = {\n            numbers.combinations(3).filter(l\
    \ => (l(0) + l(1) + l(2)) == num).toList\n        }\n        // Given a list of\
    \ integers and a number 'n', find 3 numbers in the list that multiply to 'n'\n\
    \        // >>> find3NumbersThatMultiplyTo(List[Long](1l, 2l, 3l, 4l, 5l, -1l,\
    \ 6l, 7l, 8l, 9l, -4l, 10l), 4l)\n        // (List[(Long, Long, Long)]((-1l.toLong,\
    \ 4l.toLong, -1l.toLong), (-4l.toLong, 2l.toLong, 2l.toLong)))\n        def find3NumbersThatMultiplyTo(numbers\
    \ : List[Long], num : Long) : List[(Long, Long, Long)] = {\n            numbers.combinations(3).filter(l\
    \ => (l(0) * l(1) * l(2)) == num).toList\n        }\n        // Given a list of\
    \ integers and a number 'n', find 3 numbers in the list that add up to 'n' and\
    \ multiply to 'n'\n        // >>> find3NumbersThatAddAndMultiplyTo(List[Long](1l,\
    \ 2l, 3l, 4l, 5l, -1l, 6l, 7l, 8l, 9", "        values.map(x => {\n          \
    \  x match {\n                case i : Long => i\n                case i : Int\
    \ => i.toLong\n                case _ => 0l\n            }\n        }).filter(x\
    \ => x != 0l)", "        def filterIntegers0(values : List[Any], acc : List[Long])\
    \ : List[Long] = {\n            if (values.isEmpty) acc\n            else values.head\
    \ match {\n                case i : Long => filterIntegers0(values.tail, i ::\
    \ acc)\n                case _ => filterIntegers0(values.tail, acc)\n        \
    \    }\n        }\n        filterIntegers0(values, List[Long]())", '      values.filter(x
    => x.isInstanceOf[Long]).map(_.asInstanceOf[Long])', "        // Non-tail recursive\
    \ version\n        def filterIntegers0(values : List[Any], acc : List[Long]) :\
    \ List[Long] = values match {\n            case Nil => acc\n            case x\
    \ :: xs => {\n                if (x.isInstanceOf[Long]) {\n                  \
    \  filterIntegers0(xs, acc :+ x.asInstanceOf[Long])\n                } else {\n\
    \                    filterIntegers0(xs, acc)\n                }\n           \
    \ }\n        }\n        filterIntegers0(values, List())", "        var result\
    \ = List[Long]()\n        values.foreach {\n            (v) => v match {\n   \
    \             case l : Long => result = l :: result\n                case l :\
    \ Int => result = l.toLong :: result\n                case l : Short => result\
    \ = l.toLong :: result\n                case l : Byte => result = l.toLong ::\
    \ result\n                case _ =>\n            }\n        }\n        result",
  "        //list of longs\n        var list: List[Long] = List();\n        //iterate\
    \ over list\n        for(x <- values){\n            //check if type is long\n\
    \            if(x.isInstanceOf[Long]){\n                //add to list\n      \
    \          list = list :+ x.asInstanceOf[Long];\n            }\n        }\n  \
    \      return list;", '        values.filter(e => e.isInstanceOf[Long]).map(e
    => e.asInstanceOf[Long])', "        def parse(value : Any) : Option[Long] = {\n\
    \            value match {\n                case l : Long => Some(l)\n       \
    \         case i : Int => Some(i.toLong)\n                case s : Short => Some(s.toLong)\n\
    \                case c : Char => Some(c.toLong)\n                case b : Byte\
    \ => Some(b.toLong)\n                case _ => None\n            }\n        }\n\
    \        values.flatMap(parse(_))", "        values.filter {\n            _ match\
    \ {\n                case x : Long => true\n                case _ => false\n\
    \            }\n        }.map {\n            case x : Long => x\n        }", '        return
    values.filter(isLong(_)).map(toLong(_))', '        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])',
  '        List[Long]()', '        (for (e <- values) yield e.asInstanceOf[Number].longValue).toList',
  "        if (values.isEmpty) return values\n        val value = values.head\n  \
    \      val rest = values.tail\n        value match {\n            case i : Long\
    \ => i :: filterIntegers(rest)\n            case _ => filterIntegers(rest)\n \
    \       }", "        values.filter({\n            case x : Long => true\n    \
    \        case _ => false\n        }).map({\n            case x : Long => x\n \
    \       })", '        values.filter(a => a.isInstanceOf[Long] || a.isInstanceOf[Int]).map(a
    => a.asInstanceOf[Long])', '        return null', "        var filtered = List[Long]()\n\
    \        for (value <- values) {\n            value match {\n                case\
    \ v : Long => filtered = filtered :+ v\n                case _ =>\n          \
    \  }\n        }\n        filtered", "    \tvalues.filter(isAnyInteger(_)).map(x\
    \ => x.asInstanceOf[Long])"]
stop_tokens:
- "\n    }\n"
