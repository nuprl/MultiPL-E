name: HumanEval_88_sort_array
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a list of non-negative integers, return a coscala of the given list\
  \ after sorting,\n    // you will sort the given list in ascending order if the\
  \ sum( first index value, last index value) is odd,\n    // or sort it in descending\
  \ order if the sum( first index value, last index value) is even.\n    // Note:\n\
  \    // * don't change the given list.\n    // Examples:\n    // >>> sortArray((List[Long]()))\n\
  \    // (List[Long]())\n    // >>> sortArray((List[Long](5l.toLong)))\n    // (List[Long](5l.toLong))\n\
  \    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong,\
  \ 5l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
  \ 5l.toLong))\n    // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong,\
  \ 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](6l.toLong, 5l.toLong,\
  \ 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))\n    def sortArray(array\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
  \    assert(sortArray((List[Long](5l.toLong))).equals((List[Long](5l.toLong))));\n\
  \    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong,\
  \ 5l.toLong))).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
  \ 5l.toLong))));\n    assert(sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong,\
  \ 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](6l.toLong, 5l.toLong,\
  \ 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 0l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
  \ 1l.toLong))).equals((List[Long](1l.toLong, 2l.toLong))));\n    assert(sortArray((List[Long](15l.toLong,\
  \ 42l.toLong, 87l.toLong, 32l.toLong, 11l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
  \ 11l.toLong, 15l.toLong, 32l.toLong, 42l.toLong, 87l.toLong))));\n    assert(sortArray((List[Long](21l.toLong,\
  \ 14l.toLong, 23l.toLong, 11l.toLong))).equals((List[Long](23l.toLong, 21l.toLong,\
  \ 14l.toLong, 11l.toLong))));\n    }\n\n}\n"
completions: ["        // Write your code here\n        return array", "        //\
    \ Write your code here\n        array", "        if (array.length == 0) {\n  \
    \          return array\n        }\n        if (array.length == 1) {\n       \
    \     return array\n        }\n        val indexedArray = array.zipWithIndex\n\
    \        //val sortedArray = indexedArray.sorted(Ordering.by(_._1))\n        //sortedArray.map(_._1)\n\
    \        val sortedArray = indexedArray.sorted\n        var arrayBuffer = ArrayBuffer[Long]()\n\
    \        val size = sortedArray.length\n        var i = 0\n        while (i <\
    \ size) {\n            if (i < (size / 2) && (size % 2 == 0)) {\n            \
    \    arrayBuffer += sortedArray(i)._1\n            }\n            else if (i <\
    \ (size / 2) && (size % 2 == 1)) {\n                arrayBuffer += sortedArray(i)._1\n\
    \            }\n            else if (i > (size / 2) && (size % 2 == 0)) {\n  \
    \              arrayBuffer += sortedArray(size - i - 1)._1\n            }\n  \
    \          else if (i >= (size / 2) && (size % 2 == 1)) {\n                arrayBuffer\
    \ += sortedArray(size - i - 1)._1\n            }\n            i += 1\n       \
    \ }\n        arrayBuffer.toList", "        if (array.length <= 1) return array\n\
    \        val array2 = array.sorted\n        if ((array2.head + array2.last) %\
    \ 2 == 0) return array2.reverse\n        return array2", "        // Write your\
    \ code here\n        return array", "        if (array.isEmpty) {\n          \
    \  List[Long]()\n        } else if (array.length == 1) {\n            array\n\
    \        } else {\n            val (newArray, isAscending) = if (array.head +\
    \ array.last % 2 == 0) {\n                (array.sorted, true)\n            }\
    \ else {\n                (array.sorted.reverse, false)\n            }\n     \
    \       if (isAscending) {\n                newArray\n            } else {\n \
    \               List[Long](newArray.last) ++ newArray.slice(1, newArray.length\
    \ - 1) ++ List[Long](newArray.head)\n            }\n        }", "        if (array.isEmpty)\
    \ {\n            array\n        } else {\n            val size = array.size\n\
    \            val sum = array(0) + array(size - 1)\n            val sorted = array.sorted\n\
    \            if (sum % 2 == 0) {\n                sorted.reverse\n           \
    \ } else {\n                sorted\n            }\n        }", "        // Implement\
    \ your solution here\n        // array.toList.sort(_ < _)\n        if(array.length\
    \ < 2) {\n            array\n        } else {\n            val pivot = array(array.length\
    \ / 2)\n            sortArray(array.filter(_ < pivot)) ::: array.filter(_ == pivot)\
    \ ::: sortArray(array.filter(_ > pivot))\n        }", "        def sortArray(array\
    \ : List[Long], direction : Int) : List[Long] = {\n            if (array.length\
    \ < 2) array\n            else {\n                val head = array.head\n    \
    \            val tail = array.tail\n                val sortedTail = sortArray(tail,\
    \ -direction)\n                if (direction < 0) sortedTail :+ head\n       \
    \         else if (direction > 0) head :: sortedTail\n                else array\n\
    \            }\n        }\n        if (array.length > 1) {\n            val head\
    \ = array.head\n            val last = array.last\n            val direction =\
    \ if ((head + last) % 2 == 0) 1 else -1\n            sortArray(array, direction)\n\
    \        }\n        else array", "        // Change the code below\n        List[Long]()",
  "        // Write your code here\n        null", "        // Error Handling\n  \
    \      if (array.isEmpty) return array\n        // Create new List Buffer\n  \
    \      val newList : ListBuffer[Long] = new ListBuffer[Long]()\n        // Find\
    \ the first index value\n        val first : Long = array(0)\n        // Find\
    \ the last index value\n        val last : Long = array(array.length - 1)\n  \
    \      // Determine odd or even\n        val oddOrEven : Int = (first + last)\
    \ % 2\n        // Use the ListBuffer[Long]() method to add all the values of the\
    \ given list\n        for (i <- array) newList += i\n        // Sort the List\
    \ Buffer\n        val sortedList : ListBuffer[Long] = newList.sorted\n       \
    \ // If odd, return an ascending order list.\n        if (oddOrEven == 1) return\
    \ sortedList.toList\n        // If even, return a descending order list.\n   \
    \     else return sortedList.reverse.toList", "        // Write your solution\
    \ in this function\n        null", "        if (array.isEmpty)\n            return\
    \ List[Long]()\n        val sortedArray = array.sortWith((a, b) => a < b)\n  \
    \      if ((array.head + array.last) % 2 == 0)\n            return sortedArray.reverse\n\
    \        return sortedArray", "        // Your Code Here\n        if (array.length\
    \ <= 1) return array\n        var left = List[Long]()\n        var right = List[Long]()\n\
    \        var ret = List[Long]()\n        var pivot = array(0)\n        for (i\
    \ <- 1 until array.length) {\n            if (array(i) <= pivot) left = left :+\
    \ array(i)\n            else right = right :+ array(i)\n        }\n        ret\
    \ = ret ::: sortArray(left) :+ pivot ::: sortArray(right)\n        if ((ret(0)\
    \ + ret(ret.length - 1)) % 2 == 0) ret.reverse\n        else ret", "        var\
    \ array1 = array\n        if (array1.isEmpty || array1.length == 1) return array1\n\
    \        if ((array1.head + array1.last) % 2 == 0) {\n            array1 = array1.sorted(Ordering[Long].reverse)\n\
    \        } else {\n            array1 = array1.sorted\n        }\n        array1",
  "        // Implement this function and change \"null\" to the correct return value.\n\
    \        if(array.length == 0) {\n            return List()\n        }\n     \
    \   if(array.length == 1) {\n            return array\n        }\n        val\
    \ head = array.head\n        val tail = array.tail\n        val (left, right)\
    \ = tail.partition(x => x < head)\n        if(head + array.last % 2 == 0) {\n\
    \            return sortArray(left) ::: List(head) ::: sortArray(right)\n    \
    \    } else {\n            return sortArray(right) ::: List(head) ::: sortArray(left)\n\
    \        }", "        // Write your coscala here.\n        // It is recommended\
    \ to finish the problem with the following codes:\n        var a = array\n   \
    \     if (a.length % 2 == 0) a = a.sortWith((x, y) => x < y)\n        else a =\
    \ a.sortWith((x, y) => x > y)\n        a", "        // error case\n        if\
    \ (array.length == 0) {\n            return array\n        }\n        if (array.length\
    \ == 1) {\n            return array\n        }\n        // array.length >= 2\n\
    \        val sum = array(0) + array(array.length - 1)\n        if (sum % 2 ==\
    \ 0) {\n            return array.sortWith((a, b) => a > b)\n        } else {\n\
    \            return array.sortWith((a, b) => a < b)\n        }", "        // Write\
    \ your code here\n        val len = array.length\n        val sum = array(0) +\
    \ array(len - 1)\n        if (sum % 2 == 0) {\n            array.sortWith(_ >\
    \ _)\n        } else {\n            array.sortWith(_ < _)\n        }", "     \
    \   if (array.length == 0) array\n        else {\n            var a = array.sortWith(_\
    \ < _)\n            if ((a(0) + a(a.length - 1)) % 2 == 0) a = a.reverse\n   \
    \         a\n        }", "        // Write your code here\n        var result\
    \ = array.sorted\n        if (array.length > 0 && (array.head + array.last) %\
    \ 2 == 0) {\n            result = result.reverse\n        }\n        result",
  "        if (array.isEmpty)\n            return array\n        if (array.size ==\
    \ 1)\n            return array\n        if (array.size == 2) {\n            if\
    \ (array(0) < array(1))\n                return array\n            else\n    \
    \            return List(array(1), array(0))\n        }\n        var sum = array(0)\
    \ + array(array.size - 1)\n        if (sum % 2 == 0) {\n            return array.sortWith(_\
    \ > _)\n        } else {\n            return array.sortWith(_ < _)\n        }",
  "        if (array.length <= 1) return array\n        val first = array.head\n \
    \       val last = array.last\n        val mid = (first + last) % 2\n        val\
    \ result = array.sorted\n        if (mid == 0) result.reverse\n        else result",
  "        // your solution here\n        var sum = 0l\n        for (x <- array) {\n\
    \            sum += x\n        }\n        var sortedList = array.sorted\n    \
    \    if (sum % 2 == 0) {\n            return sortedList.reverse\n        }\n \
    \       else {\n            return sortedList\n        }", "        // Write your\
    \ code here\n        return array", "\t\tval x = array.size\n\t\tvar list = new\
    \ ArrayBuffer[Long]()\n\t\tvar l = 0l\n\t\tvar r = x - 1l\n\t\tvar sum = l + r\n\
    \t\tif(sum % 2 == 0) {\n\t\t\twhile(l < r) {\n\t\t\t\tlist += array(r.toInt)\n\
    \t\t\t\tlist += array(l.toInt)\n\t\t\t\tl += 1\n\t\t\t\tr -= 1\n\t\t\t}\n\t\t\t\
    if(l == r) list += array(l.toInt)\n\t\t} else {\n\t\t\twhile(l < r) {\n\t\t\t\t\
    list += array(l.toInt)\n\t\t\t\tlist += array(r.toInt)\n\t\t\t\tl += 1\n\t\t\t\
    \tr -= 1\n\t\t\t}\n\t\t\tif(l == r) list += array(l.toInt)\n\t\t}\n\t\tlist.toList",
  "        // check if the sum( first index value, last index value) is odd,\n   \
    \     if ((array.head + array.last) % 2 == 1) {\n            array.sorted\n  \
    \      } else {\n            array.sorted.reverse\n        }", "        // Write\
    \ your code here\n        // Sort the input array in ascending or descending order.\n\
    \        // You will sort the given list in ascending order if the sum( first\
    \ index value, last index value) is odd,\n        // or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n        //\
    \ Examples:\n        // >>> sortArray((List[Long]()))\n        // (List[Long]())\n\
    \        // >>> sortArray((List[Long](5l.toLong)))\n        // (List[Long](5l.toLong))\n\
    \        // >>> sortArray((List[Long](2l.toLong, 4l.toLong, 3l.toLong, 0l.toLong,\
    \ 1l.toLong, 5l.toLong)))\n        // (List[Long](0l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))\n        // >>> sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 3l.toLong, 0l.toLong, 1l.toLong, 5l.toLong, 6l.toLong)))\n      \
    \  // (List[Long](6l.toLong, 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong,\
    \ 0l.toLong))\n        if (array.size == 0) {\n            return array\n    \
    \    }\n        if (array.size == 1) {\n            return array\n        }\n\
    \        if (array.size == 2) {\n            val sum : Long = array(0) + array(1)\n\
    \            if (sum % 2 == 0) {\n                return List[Long](array(1),\
    \ array(0))\n            } else {\n                return array\n            }\n\
    \        }\n        if (array.size == 3) {\n            val sum : Long = array(0)\
    \ + array(2)\n            if (sum % 2 == 0) {\n                return List[Long](array(2),\
    \ array(1), array(0))\n            } else {\n                return array\n  \
    \          }\n        }\n        if (array.size == 4) {\n           ", "     \
    \   // Write your code here.\n        return array", '        array.sortWith(_
    < _)', "        //println(array)\n        // your code here\n        var result\
    \ : List[Long] = List[Long]()\n        var index : Long = 0l.toLong\n        var\
    \ left = 0\n        var right = array.length - 1\n        while (left <= right)\
    \ {\n            if (index % 2 == 0) {\n                result = result :+ array(left)\n\
    \                left += 1\n            } else {\n                result = result\
    \ :+ array(right)\n                right -= 1\n            }\n            index\
    \ += 1\n        }\n        result", '        array.sortWith((a, b) => (a + b).%(2l.toLong)
    == 0l.toLong)', "        // Write your code here\n        array", "        if\
    \ (array.length == 0) {\n            return array\n        }\n        if (array.length\
    \ == 1) {\n            return array\n        }\n        if ((array(0) + array(array.length\
    \ - 1)) % 2 == 0) {\n            return array.sortWith((a, b) => a > b)\n    \
    \    }\n        else {\n            return array.sortWith((a, b) => a < b)\n \
    \       }", "        // Write your code here\n        List[Long]()", "       \
    \ // Implementation here\n        null", "        if (array.isEmpty)\n       \
    \     array\n        else {\n            val asc = array.head < array.last\n \
    \           val sorted = array.sorted\n            if (asc)\n                sorted\n\
    \            else\n                sorted.reverse\n        }", "        // Write\
    \ your answer here\n        null", "        // Write your own algorithm here to\
    \ pass all test cases.\n        array", "        // No need to sort if array is\
    \ empty.\n        if (array.length == 0) return array\n        val sum = array(0)\
    \ + array(array.length - 1)\n        if (sum % 2 == 0) {\n            return array.sortWith(_\
    \ > _)\n        } else {\n            return array.sortWith(_ < _)\n        }",
  "        // TODO\n        return array", "        if (array.length <= 1) array\n\
    \        else {\n            if ((array.head + array.last) % 2 == 0) array.sorted.reverse\n\
    \            else array.sorted\n        }", "        // your code here\n     \
    \   array.sortWith((i, j) => i > j)", "      // your code here\n      array",
  "\t\tdef loop(array : List[Long], odd : Boolean) : List[Long] = {\n\t\t\tarray match\
    \ {\n\t\t\t\tcase head :: tail => {\n\t\t\t\t\tval (min, rest) = findMin(array)\n\
    \t\t\t\t\tif (odd) {\n\t\t\t\t\t\tmin :: loop(rest, false)\n\t\t\t\t\t} else {\n\
    \t\t\t\t\t\tmin :: loop(rest, true)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase Nil\
    \ => Nil\n\t\t\t}\n\t\t}\n\t\tdef findMin(array : List[Long]) : (Long, List[Long])\
    \ = {\n\t\t\tdef loop(min : Long, list : List[Long], rest : List[Long]) : (Long,\
    \ List[Long]) = {\n\t\t\t\tlist match {\n\t\t\t\t\tcase head :: tail => {\n\t\t\
    \t\t\t\tif (head < min) {\n\t\t\t\t\t\t\tloop(head, tail, rest :+ min)\n\t\t\t\
    \t\t\t} else {\n\t\t\t\t\t\t\tloop(min, tail, rest :+ head)\n\t\t\t\t\t\t}\n\t\
    \t\t\t\t}\n\t\t\t\t\tcase Nil => (min, rest)\n\t\t\t\t}\n\t\t\t}\n\t\t\tarray\
    \ match {\n\t\t\t\tcase head :: tail => loop(head, tail, Nil)\n\t\t\t\tcase Nil\
    \ => (0, Nil)\n\t\t\t}\n\t\t}\n\t\tif (array.length % 2 == 0) {\n\t\t\tloop(array,\
    \ false)\n\t\t} else {\n\t\t\tloop(array, true)\n\t\t}", "        if (array.isEmpty)\
    \ array\n        else {\n            if ((array.head + array.last) % 2 == 0) array.sortWith(_\
    \ > _)\n            else array.sortWith(_ < _)\n        }", "        // Fill up\
    \ this function body\n        // `0` is the only evaluation hint\n        if (array.length\
    \ == 0) return array\n        if (array.length == 1) return array\n        val\
    \ firstLast = array.head + array.last\n        val middle = array.tail.init\n\
    \        if (firstLast % 2 == 0) {\n            sortArray(middle) :+ array.last\
    \ :+ array.head\n        } else {\n            array.head +: sortArray(middle)\
    \ :+ array.last\n        }", "        if (array.length <= 1) return array\n  \
    \      if ((array.head + array.last) % 2 == 0) return array.sorted.reverse\n \
    \       else return array.sorted", "        if (array.length <= 1) {\n       \
    \     return array\n        }\n        if (array.length == 2) {\n            if\
    \ (array(0) > array(1)) {\n                return List(array(1), array(0))\n \
    \           }\n            return array\n        }\n        val left = array.take(array.length\
    \ / 2)\n        val right = array.drop(array.length / 2)\n        val sortedLeft\
    \ = sortArray(left)\n        val sortedRight = sortArray(right)\n        val sorted\
    \ = merge(sortedLeft, sortedRight)\n        val sortedReversed = merge(sortedLeft.reverse,\
    \ sortedRight.reverse)\n        if ((sorted(0) + sorted(sorted.length - 1)) %\
    \ 2 == 0) {\n            return sortedReversed\n        }\n        return sorted",
  "      array.sortWith((x : Long, y : Long) =>\n        array.indexOf(x) + array.indexOf(y)\
    \ % 2 == 0\n      )", "        // Your code here\n        array", "        var\
    \ result = array\n        // your code here\n        if (array != null && array.length\
    \ >= 2) {\n            val firstValue = array(0)\n            val lastValue =\
    \ array(array.length - 1)\n            if ((firstValue + lastValue) % 2 == 0)\
    \ {\n                result = result.sorted.reverse\n            } else {\n  \
    \              result = result.sorted\n            }\n        }\n        result",
  "        array match {\n            case (Nil) => {\n                Nil\n     \
    \       }\n            case (head :: tail) => {\n                if (tail.length\
    \ > 0) {\n                    val value = head + tail.last\n                 \
    \   val ordered = if (value % 2 == 0) true else false\n                    if\
    \ (ordered) {\n                        tail.sortWith(_ > _) ::: (head :: Nil)\n\
    \                    } else {\n                        tail.sortWith(_ < _) :::\
    \ (head :: Nil)\n                    }\n                } else {\n           \
    \         array\n                }\n            }\n        }", "        if (array.length\
    \ == 0) return List[Long]()\n        if (array.length == 1) return array\n   \
    \     var sum = 0l\n        for (i <- 0 until array.length) sum += array(i)\n\
    \        var sorted = array.sorted\n        if (sum % 2 == 0) sorted = sorted.reverse\n\
    \        return sorted", "        // your code here\n        array", "       \
    \ // Write your answer here\n        val array2 = array.sortWith(_<_)\n      \
    \  val size = array2.size\n        var a = 0\n        var b = 0\n        if (size\
    \ % 2 == 0) {\n            a = size / 2 - 1\n            b = size / 2\n      \
    \  } else {\n            a = size / 2\n            b = size / 2\n        }\n \
    \       var result : List[Long] = Nil\n        for (i <- 0 to b) {\n         \
    \   if (i == 0) {\n                result = result :+ array2(a)\n            }\
    \ else {\n                result = result :+ array2(a - i)\n                result\
    \ = result :+ array2(a + i)\n            }\n        }\n        result", "    \
    \    if (array.length < 2) {\n            return array\n        }\n        if\
    \ ((array(0) + array(array.length - 1)) % 2 == 0) {\n            array.sorted(Ordering[Long].reverse)\n\
    \        } else {\n            array.sorted\n        }", "        // Fill up this\
    \ function body\n        // 'array' will contain non-negative values\n       \
    \ // You can create new lists, like List(Long)\n        // The maximum size of\
    \ the output list will be 2000\n        // The maximum size of the array will\
    \ be 20000\n        array", "        var b = ArrayBuffer[Long]()\n        for\
    \ (i <- array) {\n            b += i\n        }\n        var result = List[Long]()\n\
    \        if (b.length == 0) return result\n        else if (b.length == 1) return\
    \ List[Long](b(0))\n        else {\n            var l = 0l\n            var r\
    \ = b.length - 1\n            if ((b(l) + b(r)) % 2 == 0) {\n                while\
    \ (l < r) {\n                    result = result :+ b(r)\n                   \
    \ result = result :+ b(l)\n                    l += 1\n                    r -=\
    \ 1\n                }\n                if (l == r) result = result :+ b(l)\n\
    \            }\n            else {\n                while (l < r) {\n        \
    \            result = result :+ b(l)\n                    result = result :+ b(r)\n\
    \                    l += 1\n                    r -= 1\n                }\n \
    \               if (l == r) result = result :+ b(l)\n            }\n        }\n\
    \        result", "        if (array.length == 0) array\n        else if (array.length\
    \ == 1) array\n        else {\n            var sortedArray = array.sorted\n  \
    \          if ((array(0) + array(array.length - 1)) % 2 == 0) sortedArray.reverse\n\
    \            else sortedArray\n        }", "        // Fill up this function body\n\
    \        // `array` is a list of non-negative integers\n        // You need to\
    \ return a coscala of the given list after sorting,\n        // you will sort\
    \ the given list in ascending order if the sum( first index value, last index\
    \ value) is odd,\n        // or sort it in descending order if the sum( first\
    \ index value, last index value) is even.\n        // Note:\n        // * don't\
    \ change the given list.\n        if (array.isEmpty) {\n            (List[Long]())\n\
    \        } else if (array.length == 1) {\n            (List[Long](array(0)))\n\
    \        } else {\n            val copyArray = array.map(x => x)\n           \
    \ if ((array(0) + array(array.length - 1)) % 2 == 0) {\n                copyArray.sortWith((a,\
    \ b) => a > b)\n            } else {\n                copyArray.sortWith((a, b)\
    \ => a < b)\n            }\n        }", "        // This will not work if the\
    \ first or last element is the largest.\n        var indexOfLargest = 0\n    \
    \    var largest = 0\n        var indexOfSmallest = 0\n        var smallest =\
    \ Int.MaxValue\n        for (i <- 0 until array.length) {\n            if (array(i)\
    \ > largest) {\n                largest = array(i).toInt\n                indexOfLargest\
    \ = i\n            }\n            if (array(i) < smallest) {\n               \
    \ smallest = array(i).toInt\n                indexOfSmallest = i\n           \
    \ }\n        }\n        if ((indexOfLargest + indexOfSmallest) % 2 == 0) {\n \
    \           var arrayArray = array.toArray\n            for (i <- 0 until array.length)\
    \ {\n                for (j <- i until array.length) {\n                    if\
    \ (arrayArray(i) < arrayArray(j)) {\n                        var temp = arrayArray(i)\n\
    \                        arrayArray(i) = arrayArray(j)\n                     \
    \   arrayArray(j) = temp\n                    }\n                }\n         \
    \   }\n            return arrayArray.toList\n        }\n        else {\n     \
    \       var arrayArray = array.toArray\n            for (i <- 0 until array.length)\
    \ {\n                for (j <- i until array.length) {\n                    if\
    \ (arrayArray(i) > arrayArray(j)) {\n                        var temp = arrayArray(i)\n\
    \                        arrayArray(i) = arrayArray(j)\n                     \
    \   arrayArray(j) = temp\n                    }\n                }\n         \
    \   }\n            return arrayArray.toList\n        }", "        // Fill up this\
    \ function body\n        // `0` is the code number for the operation \n      \
    \  // `1` is the code number for the operation \n        // `2` is the code number\
    \ for the operation \n        var result = (List[Long]())\n        var curNum\
    \ = (0l.toLong)\n        var pos = (0)\n        if(array.size == 0) {\n      \
    \      result = (List[Long]())\n        } else if(array.size == 1) {\n       \
    \     result = (List[Long](array(0)))\n        } else {\n            if((array(0)\
    \ + array(array.size - 1)) % 2 == 0) {\n                while(pos < array.size)\
    \ {\n                    curNum = array.max\n                    array = array\
    \ diff List(curNum)\n                    result = result :+ curNum\n         \
    \           pos = pos + 1\n                }\n            } else {\n         \
    \       while(pos < array.size) {\n                    curNum = array.min\n  \
    \                  array = array diff List(curNum)\n                    result\
    \ = result :+ curNum\n                    pos = pos + 1\n                }\n \
    \           }\n        }\n        return result", "        // Remember you can\
    \ use pattern matching in scala.\n        // (1) if the list is empty, then we\
    \ return an empty list.\n        // (2) if the list size is 1, then we return\
    \ the list.\n        // (3) if the list size is more than 1, then we need to check\
    \ the condition of the sum of first index value and last index value.\n      \
    \  // (4) if the sum is odd, then we need to sort the list in ascending order.\n\
    \        // (5) if the sum is even, then we need to sort the list in descending\
    \ order.\n        // I will show you how to sort the list in ascending order.\n\
    \        // Implement the function in step (4).\n        // Implement the function\
    \ in step (5).\n        ???", "        if (array.isEmpty) {\n            return\
    \ array\n        }\n        if (array.length == 1) {\n            return array\n\
    \        }\n        if (array.head + array.last % 2 == 0) {\n            return\
    \ array.sortWith((a, b) => a > b)\n        }\n        else {\n            return\
    \ array.sortWith((a, b) => a < b)\n        }", "        var n = array.length -\
    \ 1\n        if (n % 2 == 0) {\n            if (array(0) > array(n)) {\n     \
    \           var t = array(0)\n                array(0) = array(n)\n          \
    \      array(n) = t\n            }\n        } else {\n            if (array(0)\
    \ < array(n)) {\n                var t = array(0)\n                array(0) =\
    \ array(n)\n                array(n) = t\n            }\n        }\n        return\
    \ array", "        // Write your code here\n        (array.size match {\n    \
    \        case 0 => array\n            case 1 => array\n            case _ => {\n\
    \                // (first half, second half)\n                def divideArray(array\
    \ : List[Long]) : (List[Long], List[Long]) = {\n                    if (array.size\
    \ % 2 == 0)\n                        (array.take(array.size / 2), array.drop(array.size\
    \ / 2))\n                    else\n                        (array.take(array.size\
    \ / 2), array.drop(array.size / 2 + 1))\n                }\n                //\
    \ array[x] and array[y] are swapped\n                def swapArray(array : List[Long],\
    \ x : Int, y : Int) : List[Long] = {\n                    // Switch array[x] and\
    \ array[y]\n                    // array(0) to array(x-1)\n                  \
    \  // array(x) and array(y) are swapped\n                    // array(y+1) to\
    \ array(array.size-1)\n                    def swapArray(array : List[Long], x\
    \ : Int, y : Int, start : Int) : List[Long] = {\n                        if (start\
    \ == x) {\n                            array(y) :: swapArray(array, x, y, start\
    \ + 1)\n                        } else if (start == y) {\n                   \
    \         array(x) :: swapArray(array, x, y, start + 1)\n                    \
    \    } else {\n                            array(start) :: swapArray(array, x,\
    \ y, start + 1)\n                        }\n                    }\n          \
    \          swapArray(array, x, y, 0)\n                }\n                // all\
    \ arrays in first half and second half are sorted\n                // if the sum(\
    \ first index value, last index value) is odd,\n                // the given list\
    \ is sorted in ascending order\n                // or if the sum( first index\
    \ value, last index value) is even,\n                // the given list is sorted\
    \ in descending order\n                def sortArray(array : List[Long]) : List[Long]\
    \ = {\n                    // (first half, second half)\n                    val\
    \ (first, second) = divideArray(array)\n                    // Sorted the first\
    \ half\n                    val sortedFirst = sortArray(first)\n             \
    \       // S", "        //throw new NotImplementedError()\n        if (array.isEmpty)\n\
    \            array\n        else if (array.size == 1)\n            array\n   \
    \     else if ((array.head + array.last) % 2 == 0)\n            array.sortWith(_\
    \ < _)\n        else\n            array.sortWith(_ > _)", "        if (array.length\
    \ == 0) {\n            return array\n        }\n        if (array.length == 1)\
    \ {\n            return array\n        }\n        val list = array.sorted\n  \
    \      val (l0, l1) = list.splitAt(list.length / 2)\n        if ((l0.last + l1.head)\
    \ % 2 == 0) {\n            return l1 ++ l0\n        }\n        else {\n      \
    \      return l0 ++ l1\n        }", "        if (array.length <= 1) array\n  \
    \      else if ((array.head + array.last) % 2 == 0) array.sorted(Ordering[Long].reverse)\n\
    \        else array.sorted", "        if (array.isEmpty) array\n        else if\
    \ (array.length == 1) array\n        else if ((array.head + array.last) % 2 ==\
    \ 0) array.sortWith((x, y) => x < y)\n        else array.sortWith((x, y) => x\
    \ > y)", "        // Write your code here.\n        array.sortWith(if ((array.head\
    \ + array.last) % 2 == 0) (a, b) => a > b else (a, b) => a < b)", "        if\
    \ (array.length <= 1) {\n            return array\n        }\n        else {\n\
    \            // The task is to sort an array by the absolute difference between\
    \ the left most element and the right most element.\n            // Order the\
    \ elements in the array by their absolute difference with the right most element\
    \ in ascending order.\n            // If the absolute difference is equal, order\
    \ the elements by their absolute difference with the left most element.\n    \
    \        var leftMost = array(0)\n            var rightMost = array(array.length\
    \ - 1)\n            var leftMostDiff = array.map(element => abs(element - leftMost))\n\
    \            var rightMostDiff = array.map(element => abs(element - rightMost))\n\
    \            var resultArray = array.zip(leftMostDiff).zip(rightMostDiff).sortBy(element\
    \ => (element._2, element._1._2)).map(element => element._1._1)\n            if\
    \ ((leftMost + rightMost) % 2 == 0) {\n                return resultArray.reverse\n\
    \            }\n            else {\n                return resultArray\n     \
    \       }\n        }", "        // Your code here\n        // val i = array.indices\n\
    \        // val j = array.indices.map(j => j + 1)\n        // array.zip(j).map(x\
    \ => x._1 * x._2).sum\n\n        array.zipWithIndex.map(x => x._1 * x._2).sum\
    \ match {\n            case 0 => array\n            case x if x % 2 == 0 => array.sorted(Ordering[Long].reverse)\n\
    \            case x if x % 2 == 1 => array.sorted\n        }", "        // A scala\
    \ list might have a more efficient algorithm than this.\n        // Start.\n \
    \       var ascending = true\n        if (array.length > 0) {\n            if\
    \ ((array(0) + array(array.length - 1)) % 2 == 0) {\n                ascending\
    \ = false\n            }\n        }\n        if (ascending) {\n            var\
    \ descending = false\n            for (i <- 0 until array.length - 1) {\n    \
    \            for (j <- i + 1 until array.length) {\n                    if (array(i)\
    \ > array(j)) {\n                        var t = array(i)\n                  \
    \      array(i) = array(j)\n                        array(j) = t\n           \
    \             descending = true\n                    }\n                }\n  \
    \          }\n            if (descending) {\n                sortArray(array)\n\
    \            } else {\n                array\n            }\n        } else {\n\
    \            var ascending = false\n            for (i <- 0 until array.length\
    \ - 1) {\n                for (j <- i + 1 until array.length) {\n            \
    \        if (array(i) < array(j)) {\n                        var t = array(i)\n\
    \                        array(i) = array(j)\n                        array(j)\
    \ = t\n                        ascending = true\n                    }\n     \
    \           }\n            }\n            if (ascending) {\n                sortArray(array)\n\
    \            } else {\n                array\n            }\n        }\n     \
    \   // End.", "        // If array length is 0, just return the array\n      \
    \  if (array.length == 0) return array\n        // We need a special case for\
    \ array length 1 and 2, because the logic will not work for them\n        if (array.length\
    \ == 1) return array\n        if (array.length == 2) {\n            if ((array(0)\
    \ + array(1)) % 2 == 0) return array.sortWith(_ > _)\n            else return\
    \ array.sortWith(_ < _)\n        }\n        // Here we need to find which side\
    \ of the array will end up being the larger one\n        val leftSum = array.take(array.length\
    \ / 2).sum\n        val rightSum = array.takeRight(array.length / 2).sum\n   \
    \     val largerSideSum = if (leftSum > rightSum) leftSum else rightSum\n    \
    \    // The last element of the array that will be passed to the smaller side\n\
    \        val largerSideLastElement = if (leftSum > rightSum) array(array.length\
    \ / 2 - 1) else array(array.length - 1)\n        // The first element of the array\
    \ that will be passed to the smaller side\n        val largerSideFirstElement\
    \ = if (leftSum > rightSum) array(array.length / 2) else array(0)\n        //\
    \ Smaller side\n        val smallerSide = if (leftSum > rightSum) array.takeRight(array.length\
    \ / 2) else array.take(array.length / 2)\n        // Larger side\n        val\
    \ largerSide = if (leftSum > rightSum) array.take(array.length / 2) else array.takeRight(array.length\
    \ / 2)\n        // The smaller side that has to be sorted\n        val smallerSideSorted\
    \ = if ((largerSideSum + largerSideLastElement) % 2 == 0) smallerSide.sortWith(_\
    \ > _) else smallerSide.sortWith(_ < _)\n        // Return the concatenation of\
    \ larger side, smaller side sorted and the last value from the larger side\n \
    \       return largerSide ++ smallerSideSorted :+ largerSideLastElement", "  \
    \      var output = List[Long]()\n        val odds = ListBuffer[Long]()\n    \
    \    val evens = ListBuffer[Long]()\n        var i = 0\n        for (i <- 0 until\
    \ array.length) {\n            if (array(i) % 2 == 0) {\n                evens\
    \ += array(i)\n            } else {\n                odds += array(i)\n      \
    \      }\n        }\n        if (array.length > 0) {\n            if ((odds.length\
    \ + evens.length) % 2 == 0) {\n                output = odds.sorted.reverse.toList\
    \ ++ evens.sorted.reverse.toList\n            } else {\n                output\
    \ = odds.sorted.toList ++ evens.sorted.toList\n            }\n        }\n    \
    \    output", "        // Keep your mind on this problem.\n        if (array.isEmpty)\
    \ array\n        else if (array.length == 1) array\n        else if (array.length\
    \ == 2) if (array(0) <= array(1)) array else array.reverse\n        else {\n \
    \           val (left, right) = array.splitAt(array.length / 2)\n            merge(sortArray(left),\
    \ sortArray(right))\n        }", "        var sortedArray = List[Long]()\n   \
    \     var visited = HashSet[Long]()\n        for (i <- 0 until array.length) {\n\
    \            var sortedPair = array.filter(x => !visited.contains(x)).sorted\n\
    \            var index = sortedPair.length / 2\n            var num = sortedPair(index)\n\
    \            if (i % 2 == 0) {\n                sortedArray = num :: sortedArray\n\
    \            } else {\n                sortedArray = sortedArray :+ num\n    \
    \        }\n            visited.add(num)\n        }\n        sortedArray", " \
    \       // Write your submission here\n        array", "        var listBuffer\
    \ = ListBuffer[Long]()\n        if (array.isEmpty) return listBuffer.toList\n\
    \        val (x, y) = (array.head, array.last)\n        if ((x + y) % 2 == 0)\
    \ {\n            listBuffer.appendAll(array.reverse)\n        } else {\n     \
    \       listBuffer.appendAll(array.sorted)\n        }\n        listBuffer.toList",
  "      // Fill up this function body\n      // You can add another function as well,\
    \ if required\n      array", "        if (array.length <= 1) array\n        else\
    \ if ((array.head + array.last) % 2 == 0) array.sorted(Ordering[Long].reverse)\n\
    \        else array.sorted", "        // \n        // your code\n        // \n\
    \        array", "        if (array.length == 0) {\n            List[Long]()\n\
    \        } else if (array.length == 1) {\n            array\n        } else {\n\
    \            var result = new ListBuffer[Long]()\n            var sorted = array.sorted\n\
    \            var index : Int = 0\n            var lastIndex : Int = sorted.length\
    \ - 1\n            while (index < lastIndex) {\n                result += sorted(lastIndex)\n\
    \                result += sorted(index)\n                index += 1\n       \
    \         lastIndex -= 1\n            }\n            if (index == lastIndex) {\n\
    \                result += sorted(index)\n            }\n            result.toList\n\
    \        }", "        // your code here\n        (List[Long]())", "        //\
    \ Write your code here\n        if (array.length == 0) return array\n        else\
    \ if (array.length == 1) return array\n        else {\n            val first =\
    \ array.head\n            val last = array.last\n            val sum = first +\
    \ last\n            if (sum % 2 == 0) return array.sorted.reverse\n          \
    \  else return array.sorted\n        }", "        if (array.isEmpty) {\n     \
    \       array\n        } else {\n            val head = array.head\n         \
    \   val tail = array.tail\n            var sort_tail = sortArray(tail)\n     \
    \       if (head >= sort_tail.head) {\n                head :: sort_tail\n   \
    \         } else {\n                var index = 0\n                while (index\
    \ < sort_tail.length && head >= sort_tail(index)) {\n                    index\
    \ += 1\n                }\n                sort_tail.take(index) ::: (head ::\
    \ sort_tail.drop(index))\n            }\n        }", "        if(array.length\
    \ == 0) return array\n        if(array.length == 1) return array\n        if(array.length\
    \ == 2) return if(array(0) > array(1)) array else array.reverse\n        var i\
    \ : Int = 0\n        var j : Int = array.length - 1\n        var result : List[Long]\
    \ = List()\n        while(i <= j) {\n            if((i + j) % 2 == 0) {\n    \
    \            result = array(i) :: result\n                i += 1\n           \
    \ } else {\n                result = array(j) :: result\n                j -=\
    \ 1\n            }\n        }\n        return result", "        // Your code here\n\
    \        return null;", "        // Write your code here\n        array.sortWith(\n\
    \            (m, n) => {\n                if ((m + n) % 2 == 0) {\n          \
    \          n < m\n                } else {\n                    m < n\n      \
    \          }\n            }\n        )", "        // Write your code here\n  \
    \      val sums = array.indices.map(i => array(i) + array((array.length - 1 -\
    \ i) % array.length))\n        val sortedSum = sums.indices.sortBy(sums)\n   \
    \     sortedSum.map(index => array(index) + array((array.length - 1 - index) %\
    \ array.length))", "      // algorithm\n      // if (sum( first index value, last\
    \ index value) is odd)\n      //   sort( given list in ascending order)\n    \
    \  // else\n      //   sort( given list in descending order)\n      if (array.size\
    \ == 0) {\n        return array\n      }\n      else if (array.size == 1) {\n\
    \        return array\n      }\n      else {\n        val sum = array.head + array.last\n\
    \        val sorted = array.sorted\n        if (sum % 2 == 0) {\n          return\
    \ sorted.reverse\n        }\n        else {\n          return sorted\n       \
    \ }\n      }", "        // Write your code here\n        if (array.isEmpty) List()\n\
    \        else {\n            if ((array.head + array.last) % 2 == 0) (array.sorted.reverse)\n\
    \            else (array.sorted)\n        }", "        var array1 = array.sorted\n\
    \        if ((array1.length >= 1) && ((array1(0) + array1(array1.length - 1))\
    \ % 2 == 0))\n            array1 = array1.reverse\n        array1", "        if\
    \ (array.isEmpty) return array\n        val buf = new ListBuffer[Long]\n     \
    \   buf.appendAll(array)\n        if ((buf(0) + buf(buf.length - 1)) % 2 == 0)\
    \ buf.sorted(Ordering[Long].reverse)\n        else buf.sorted", "        val sortedList\
    \ = array.sorted\n        if (sortedList.isEmpty) sortedList\n        else {\n\
    \            val head = sortedList.head\n            val last = sortedList.last\n\
    \            if ((head + last) % 2 == 0) sortedList.reverse\n            else\
    \ sortedList\n        }", "        if (array.isEmpty) array\n        else {\n\
    \            val sum = array.head + array.last\n            if (sum % 2 == 0)\n\
    \                array.sorted.reverse\n            else\n                array.sorted\n\
    \        }", "        // Write your code here\n        List(0)", "        // The\
    \ case of empty list or single element list\n        if (array.size <= 1) {\n\
    \            return array\n        }\n        // The case of even-size list\n\
    \        if (array.size % 2 == 0) {\n            return sort(array)\n        }\n\
    \        // The case of odd-size list\n        if (array.size % 2 == 1) {\n  \
    \          return sort(array).reverse\n        }\n        return List[Long]()",
  "        val sum = array.head + array.last\n        val list : List[Long] = array.sorted\n\
    \        if (sum % 2 == 0) list.reverse else list", "        // Write your code\
    \ here\n        array", "        // Write your code here\n        // return the\
    \ result array which you want to return\n        return List[Long]()", "     \
    \   if (array.length <= 1) return array\n        else {\n            if ((array.head\
    \ + array.last) % 2 == 0) array.sortWith((a, b) => a > b)\n            else array.sortWith((a,\
    \ b) => a < b)\n        }", "        // Write your code here\n        if (array.length\
    \ <= 1) {\n            return array\n        }\n        val last = array.last\n\
    \        val init = array.init\n        val sorted = sortArray(init)\n       \
    \ return sorted.filter(_ > last) ::: List(last) ::: sorted.filter(_ <= last)",
  "        // Write your code here.\n        var first = array.first\n        var\
    \ last = array.last\n        var sum = first + last\n        var new_array = array\n\
    \        if (sum % 2 == 0) {\n            new_array = array.sortWith(_ > _)\n\
    \        } else {\n            new_array = array.sortWith(_ < _)\n        }\n\
    \        return new_array", '        array.sortWith((x, y) => ((x + y) % 2) ==
    1).sorted', "        if (array.length == 0) return array\n        else if (array.length\
    \ == 1) return array\n        else {\n            if ((array(0) + array(array.length\
    \ - 1)) % 2 == 0) {\n                return array.sortWith((left, right) => left\
    \ < right)\n            } else {\n                return array.sortWith((left,\
    \ right) => left > right)\n            }\n        }", "        if (array.length\
    \ == 0) return array\n        if (array.length == 1) return array\n        if\
    \ (array.length == 2) {\n            if (array(0) <= array(1)) return array\n\
    \            return List(array(1), array(0))\n        }\n        val originalArray\
    \ = ListBuffer[Long]()\n        originalArray ++= array\n        val newArray\
    \ = ListBuffer[Long]()\n        val sum = originalArray(0) + originalArray(originalArray.length\
    \ - 1)\n        val middle = if (sum % 2 == 0) 1 else 0\n        for (i <- 0 to\
    \ originalArray.length - 1) {\n            newArray +=\n                if (middle\
    \ == 0) {\n                    val top = originalArray.max\n                 \
    \   originalArray -= top\n                    top\n                } else {\n\
    \                    val top = originalArray.min\n                    originalArray\
    \ -= top\n                    top\n                }\n        }\n        newArray.toList",
  "        if(array.length == 0) return array\n        val last_index = array.length\
    \ - 1\n        if((array(0) + array(last_index)) % 2 == 0) array.sortWith(_ >\
    \ _)\n        else array.sortWith(_ < _)", "        // your code here\n      \
    \  if (array.length == 0) array\n        else if (array.length == 1) array\n \
    \       else if ((array.length % 2) == 0) sortArray(array.tail) ++ sortArray(array.take(1))\n\
    \        else {\n            val n = array.length / 2\n            sortArray(array.take(n))\
    \ ++ sortArray(array.takeRight(n))\n        }", "        if (array.length == 0)\
    \ array\n        else {\n            val (first, last) = (array.head, array.last)\n\
    \            if ((first + last) % 2 == 0) array.sortWith(_ > _)\n            else\
    \ array.sortWith(_ < _)\n        }", "        // Write your code here\n      \
    \  if (array.isEmpty) {\n            return array\n        }\n        var ans\
    \ = array.sorted\n        if (ans.head + ans.last % 2 == 0) {\n            ans\
    \ = ans.reverse\n        }\n        return ans", "        // Your code here \n\
    \        if(array.isEmpty || array.length == 1) return array\n        var sum\
    \ = array(0) + array(array.length - 1)\n        val sorted = array.sorted\n  \
    \      if(sum % 2 == 0) sorted.reverse\n        else sorted", "        val n =\
    \ array.length\n        if (n == 0) return List[Long]()\n        if (n == 1) return\
    \ array\n        val b = array.grouped(2).map(x => x.reverse).toList.flatten\n\
    \        b", "        var result : List[Long] = List[Long]()\n        if (array.length\
    \ == 0) {\n            result = array\n        } else if (array.length == 1) {\n\
    \            result = array\n        } else {\n            val firstValue : Long\
    \ = array(0)\n            val lastValue : Long = array(array.length - 1)\n   \
    \         if ((firstValue + lastValue) % 2 == 0) {\n                result = mergeSort(array).reverse\n\
    \            } else {\n                result = mergeSort(array)\n           \
    \ }\n        }\n        result", "        var res : List[Long] = array\n     \
    \   val length = array.length\n        if (length > 1) {\n            val sum\
    \ = array(0) + array(length - 1)\n            if (sum % 2 == 0) {\n          \
    \      res = array.sortWith(_ > _)\n            } else {\n                res\
    \ = array.sortWith(_ < _)\n            }\n        }\n        res", "        if\
    \ (array.isEmpty) {\n            return array\n        }\n        if (array.length\
    \ == 1) {\n            return array\n        }\n        val (list1, list2) = array.splitAt(array.length\
    \ / 2)\n        val (list1_sorted, list2_sorted) = (sortArray(list1), sortArray(list2))\n\
    \        val (list1_sorted_reversed, list2_sorted_reversed) = (list1_sorted.reverse,\
    \ list2_sorted.reverse)\n        val (list1_sorted_reversed_odd, list2_sorted_reversed_odd)\
    \ = (list1_sorted_reversed.head + list1_sorted_reversed.last, list2_sorted_reversed.head\
    \ + list2_sorted_reversed.last)\n        val (list1_sorted_reversed_even, list2_sorted_reversed_even)\
    \ = (list1_sorted_reversed.head - list1_sorted_reversed.last, list2_sorted_reversed.head\
    \ - list2_sorted_reversed.last)\n        val (list1_ordered, list2_ordered) =\
    \ ((if (list1_sorted_reversed_odd % 2 != 0) list1_sorted else list1_sorted.reverse),\
    \ (if (list2_sorted_reversed_odd % 2 != 0) list2_sorted else list2_sorted.reverse))\n\
    \        val (list1_ordered_reversed, list2_ordered_reversed) = (list1_ordered.reverse,\
    \ list2_ordered.reverse)\n        val (list1_ordered_reversed_odd, list2_ordered_reversed_odd)\
    \ = (list1_ordered_reversed.head + list1_ordered_reversed.last, list2_ordered_reversed.head\
    \ + list2_ordered_reversed.last)\n        val (list1_ordered_reversed_even, list2_ordered_reversed_even)\
    \ = (list1_ordered_reversed", "        // we are given a list and we will create\
    \ a new list sorted on the criteria given.\n        // I think that the best way\
    \ to accomplish this is to sort based on the sum of the first and last index values.\n\
    \        // This will make the sorting equal to a cascading sort as we will sort\
    \ based on the amount of difference between\n        // the first and last index\
    \ values. The smaller the difference the higher the list index.\n        val temp\
    \ = array.zipWithIndex.sortBy(index => abs(index._1 - array.last)).map(index =>\
    \ index._1)\n        if(temp.head + temp.last % 2 == 0) temp.reverse else temp",
  "        // Write your solution here\n        if (array.length == 0)\n         \
    \   array\n        else if (array.length == 1)\n            array\n        else\
    \ {\n            if ((array(0) + array(array.length - 1)) % 2 == 0)\n        \
    \        array.sortWith(_ > _)\n            else\n                array.sortWith(_\
    \ < _)\n        }", "        // array.sorted\n        // array.sortWith(_ > _)\n\
    \        val sum = array.head + array.last\n        if (sum % 2 == 0) array.sortWith(_\
    \ > _) else array.sorted", "        if (array.length % 2 == 0) {\n           \
    \ return array.sorted.reverse\n        } else {\n            return array.sorted\n\
    \        }", "        // Your code here\n        return array", "        // Fill\
    \ up this function body\n        // `array` is a list of Long type\n        //\
    \ Return the sorted array\n        // You don't need to print anything\n     \
    \   // Constraints:\n        //   * 1 <= length of the array <= 100000\n     \
    \   //   * 0 <= array[i] <= 10^9\n        array", "        if (array.length <=\
    \ 1) return array\n        var sortArray : List[Long] = array.sorted\n       \
    \ if (sortArray.head + sortArray.last % 2 == 0) sortArray = sortArray.reverse\n\
    \        return sortArray", "        val length = array.length\n        if (length\
    \ == 0) array\n        else if (length == 1) array\n        else {\n         \
    \   val firstLastIndexSum = array(0) + array(length - 1)\n            if (firstLastIndexSum\
    \ % 2 == 0) (array.sortWith(_ > _))\n            else (array.sortWith(_ < _))\n\
    \        }", "        val empty : List[Long] = List[Long]()\n        if (array.length\
    \ == 0) {\n            return empty\n        }\n        val head = array.head\n\
    \        val tail = array.tail\n        return (head + tail.last) % 2 match {\n\
    \            case 0 => tail.reverse ::: head :: empty\n            case _ => head\
    \ :: tail.sorted\n        }", "        var tmp : List[Long] = array\n        var\
    \ result : List[Long] = Nil\n        var even : List[Long] = Nil\n        var\
    \ odd : List[Long] = Nil\n        if (tmp.size == 0) {\n            return tmp\n\
    \        }\n        else if (tmp.size == 1) {\n            return tmp\n      \
    \  }\n        for (i <- tmp) {\n            if (i % 2 == 0) {\n              \
    \  even = even :+ i\n            }\n            else {\n                odd =\
    \ odd :+ i\n            }\n        }\n        even = even.sorted\n        odd\
    \ = odd.sorted\n        if ((even.head + odd.last) % 2 == 0) {\n            even\
    \ = even.reverse\n        }\n        result = odd ::: even\n        return result",
  "        // write your code here\n        return array", "        def quickSort(array\
    \ : List[Long]) : List[Long] = {\n            if (array.size <= 1) {\n       \
    \         array\n            } else {\n                val pivot = array(array.size\
    \ / 2)\n                quickSort(array.filter(_ < pivot)) ::: array.filter(_\
    \ == pivot) ::: quickSort(array.filter(_ > pivot))\n            }\n        }\n\
    \        val a = if (array.headOption == None) array else quickSort(array)\n \
    \       val b = if (a.size % 2 == 0) a.sortWith(_ > _) else a\n        b", " \
    \       // write your code here\n        array", "        return array.sortWith((a,\
    \ b) => {\n            if (array.indexOf(a) + array.indexOf(b) % 2 == 0) {\n \
    \               a > b\n            } else {\n                a < b\n         \
    \   }\n        })", "        // No need to sort the given list, thus return the\
    \ given list\n        // (List[Long]) array", "        // Write your code here\n\
    \        if (array.length == 0)\n            return array\n        if (array.length\
    \ == 1)\n            return array\n        val n = array.length\n        val x\
    \ = array(0)\n        val y = array(n - 1)\n        var ans = array.sorted\n \
    \       if ((x + y) % 2 == 0)\n            ans = ans.reverse\n        return ans",
  "        val a = array\n        // Define the function to decide the order\n   \
    \     val f = if ((a.head + a.last) % 2 == 0) false else true\n        // Use\
    \ sortBy to do the order\n        val b = a.sortBy(c => c)\n        // Turn the\
    \ result to descending order\n        val c = if (f) b else b.reverse\n      \
    \  c", "        // your code here\n        var array1 : List[Long] = List[Long]()\n\
    \        var array2 : List[Long] = List[Long]()\n        for (i <- 0 until array.length)\
    \ {\n            if (i % 2 == 0) array1 = array1 :+ array(i)\n            else\
    \ array2 = array2 :+ array(i)\n        }\n        var array1sort = array1.sorted\n\
    \        var array2sort = array2.sorted\n        var result : List[Long] = List[Long]()\n\
    \        for (i <- 0 until array.length) {\n            if (i % 2 == 0) result\
    \ = result :+ array1sort(i / 2)\n            else result = result :+ array2sort(i\
    \ / 2)\n        }\n        result", "        val (s1, s2) = array.splitAt(array.length/2)\n\
    \        merge(s1, s2)", "        if (array.length == 0) array\n        else {\n\
    \            val sum = array.head + array.last\n            val _sum = (s : Long)\
    \ => ((s % 2) == 0)\n            array.sorted(if (_sum(sum)) Ordering[Long].reverse\
    \ else Ordering[Long])\n        }", "        if (array.isEmpty) array\n      \
    \  else {\n            val newArray = array.sorted\n            if ((newArray.head\
    \ + newArray.last) % 2 == 0) newArray.reverse\n            else newArray\n   \
    \     }", "        // Write your code here\n        val solution = array\n   \
    \     if (solution.isEmpty) {\n            solution\n        } else {\n      \
    \      var sum = 0\n            for (n <- solution) {\n                sum +=\
    \ n\n            }\n            if (sum % 2 == 0) {\n                solution.sorted.reverse\n\
    \            } else {\n                solution.sorted\n            }\n      \
    \  }", "        // match the given array\n        array match {\n            //\
    \ if given array is empty, return the given array\n            case List() =>\
    \ List()\n            // if given array is not empty, do the following\n     \
    \       case _ => {\n                // sort the given array\n               \
    \ val sortedArray = array.sorted\n                // if the sum of given array's\
    \ first index value and last index value is odd, return the sorted array\n   \
    \             if ((sortedArray.head + sortedArray.last) % 2 == 1) sortedArray\n\
    \                // else, return the reversed sorted array\n                else\
    \ sortedArray.reverse\n            }\n        }", "        // Write your solution\
    \ here.\n        var temp = array.clone\n        val n = temp.length\n       \
    \ if (n > 1) {\n            val index = temp.indices.toList\n            var ans\
    \ = List[Long]()\n            var i = 0\n            while (i < n) {\n       \
    \         if (i == 0) {\n                    if ((temp(i) + temp(n - 1 - i)) %\
    \ 2 == 0) ans = ans :+ temp(n - 1 - i) :+ temp(i)\n                    else ans\
    \ = ans :+ temp(i) :+ temp(n - 1 - i)\n                }\n                else\
    \ {\n                    if ((temp(i) + temp(n - 1 - i)) % 2 == 0) ans = ans :+\
    \ temp(n - 1 - i) :+ temp(i)\n                    else ans = ans :+ temp(i) :+\
    \ temp(n - 1 - i)\n                }\n                i += 1\n            }\n\
    \            ans\n        }\n        else temp", "        val newList = array.toArray\n\
    \        scala.util.Sorting.quickSort(newList)\n        if (newList.isEmpty ||\
    \ newList.length == 1) return array\n        if ((newList(0) + newList(newList.length\
    \ - 1)) % 2 == 0) newList.reverse.toList\n        else newList.toList", "    \
    \    // TODO: Please implement the method to pass the test\n        if (array.isEmpty)\
    \ return array\n        val s : Long = array.head\n        val e : Long = array.last\n\
    \        if ((s + e) % 2 == 0) {\n            return array.sortWith(_ > _)\n \
    \       } else {\n            return array.sortWith(_ < _)\n        }", "    \
    \    if (array.length == 0) array\n        else {\n            var tempArray =\
    \ ListBuffer[Long]()\n            val sortedArray = array.sorted\n           \
    \ var startIndex = 0\n            var endIndex = sortedArray.length - 1\n    \
    \        var isEven = false\n            if ((sortedArray(startIndex) + sortedArray(endIndex))\
    \ % 2 == 0) isEven = true\n            while (startIndex <= endIndex) {\n    \
    \            if (isEven) {\n                    tempArray += sortedArray(endIndex)\n\
    \                    endIndex -= 1\n                } else {\n               \
    \     tempArray += sortedArray(startIndex)\n                    startIndex +=\
    \ 1\n                }\n                isEven = !isEven\n            }\n    \
    \        tempArray.toList\n        }", "        val n = array.length\n       \
    \ if (n <= 1) array\n        else if (n == 2) {\n            if (array(0) <= array(1))\
    \ array\n            else List(array(1), array(0))\n        }\n        else {\n\
    \            val p = ((array(0), array(n - 1)) match {\n                case (x,\
    \ y) if (x + y) % 2 == 0 => -1\n                case _ => 1\n            })\n\
    \            if (p == 1) array.sorted\n            else array.sorted.reverse\n\
    \        }", "        // should be implemented\n        List[Long]()", "     \
    \   // array: List[Long] = List(2, 4, 3, 0, 1, 5, 6)\n        if (array.length\
    \ == 0) return List[Long]()\n        if (array.length == 1) return array\n   \
    \     var temp = 0L\n        var tempIndex = 0\n        var isEven = false\n \
    \       if ((array(0) + array(array.length - 1)) % 2 == 0) isEven = true\n   \
    \     for (i <- 0 until array.length - 1) {\n            for (j <- 0 until array.length\
    \ - 1 - i) {\n                if (isEven) {\n                    if (array(j)\
    \ < array(j + 1)) {\n                        temp = array(j)\n               \
    \         array(j) = array(j + 1)\n                        array(j + 1) = temp\n\
    \                    }\n                } else {\n                    if (array(j)\
    \ > array(j + 1)) {\n                        temp = array(j)\n               \
    \         array(j) = array(j + 1)\n                        array(j + 1) = temp\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ array", "        array match {\n            case Nil => Nil\n            case\
    \ x::Nil => x::Nil\n            case x::y::Nil => if ((x + y) % 2 == 0) y::x::Nil\
    \ else x::y::Nil\n            case x::xs => {\n                val sum = x + xs.last\n\
    \                if (sum % 2 == 0)\n                    (sortArray(xs) :+ x).sortWith(_\
    \ > _)\n                else\n                    (sortArray(xs) :+ x).sortWith(_\
    \ < _)\n            }\n        }", '        return array', "        val x = array.size\n\
    \        val y = array.foldLeft(0l.toLong)((sum,i) => sum + i)\n        if (x\
    \ == 0) List[Long]()\n        else if (x == 1) array\n        else if ((x + y)\
    \ % 2 == 0) array.sortWith(_ > _)\n        else array.sortWith(_ < _)", "    \
    \    // if `array` is empty, return it directly.\n        if (array.isEmpty) return\
    \ array\n        // if `array` is a singleton, return it directly.\n        if\
    \ (array.length == 1) return array\n        // sort `array` in ascending order,\
    \ then\n        // convert `array` to `ListBuffer`.\n        var sortedList =\
    \ array.sorted.to[ListBuffer]\n        // sum the last and first values of `sortedList`.\n\
    \        var sumValue = sortedList.head + sortedList.last\n        // if `sumValue`\
    \ is odd, return `sortedList` directly.\n        if (sumValue % 2 == 1) return\
    \ sortedList.toList\n        // if `sumValue` is even, reverse `sortedList`, then\
    \ return it.\n        sortedList = sortedList.reverse\n        return sortedList.toList",
  "        if (array.isEmpty) {\n            return array\n        }\n        if (array.length\
    \ == 1) {\n            return array\n        }\n        val co = (array.head.toLong,\
    \ array.last.toLong)\n        if (co._1 + co._2 % 2 == 0) {\n            return\
    \ array.sortWith((a, b) => a > b)\n        }\n        return array.sortWith((a,\
    \ b) => a < b)", "        // write your code here\n        if (array.length <=\
    \ 1) return array\n        val sum = array(0) + array(array.length - 1)\n    \
    \    if (sum % 2 == 0)\n            array.sortWith(_ > _)\n        else\n    \
    \        array.sortWith(_ < _)", "        // your code here\n        val a = array\n\
    \        (array, array.size) match {\n            case (Nil, _) => Nil\n     \
    \       case (hd :: tl, n) => {\n                val hdv = hd\n              \
    \  val tlv = tl\n                if (n == 1) {\n                    List(hdv)\n\
    \                } else {\n                    if (hdv > tlv.head) {\n       \
    \                 hdv :: sortArray(tlv)\n                    } else {\n      \
    \                  tlv.head :: sortArray(hdv :: tlv.tail)\n                  \
    \  }\n                }\n            }\n        }", "        // Fill up this function\
    \ body\n        // You may add another function as well, if required\n       \
    \ if (array.length > 0) {\n            if ((array.head + array.last) % 2 == 0)\
    \ array.sortWith(_ > _)\n            else array.sortWith(_ < _)\n        } else\
    \ {\n            array\n        }", "        // if the given list is empty or\
    \ it just has one item,\n        // return the given list.\n        if (array.isEmpty\
    \ || array.length == 1) return array\n        // if the sum of first index value\
    \ and last index value is even,\n        // sort the given list in descending\
    \ order,\n        // then return it.\n        else if ((array.head + array.last)\
    \ % 2 == 0) {\n            return array.sortWith(_ > _)\n        }\n        //\
    \ if the sum of first index value and last index value is odd,\n        // sort\
    \ the given list in ascending order,\n        // then return it.\n        else\
    \ {\n            return array.sortWith(_ < _)\n        }", "        if (array.length\
    \ == 0) array\n        else if (array.length == 1) array\n        else if ((array.head\
    \ + array.last) % 2 == 0) array.sortWith(_ > _)\n        else array.sortWith(_\
    \ < _)", "        val length = array.length\n        def getValue(index : Int)\
    \ : Long = {\n            if (index >= 0 && index < length) array(index)\n   \
    \         else 0\n        }\n        val sum = getValue(0) + getValue(length -\
    \ 1)\n        if (sum % 2 == 0) array.sortWith((a, b) => a > b)\n        else\
    \ array.sortWith((a, b) => a < b)", "        var sortedArray = array.sorted\n\
    \        val firstValue = sortedArray.head\n        val lastValue = sortedArray.last\n\
    \        if ((firstValue + lastValue) % 2 == 0) {\n            sortedArray = sortedArray.reverse\n\
    \        }\n        sortedArray", "        // Write your own implementation here...\n\
    \        if (array.length == 0) {\n            array\n        } else if (array.length\
    \ == 1) {\n            array\n        } else {\n            var firstIndex = 0\n\
    \            var lastIndex = array.length - 1\n            var firstValue = array(firstIndex)\n\
    \            var lastValue = array(lastIndex)\n            var sum = firstValue\
    \ + lastValue\n            if (sum % 2 == 0) {\n                array.sortWith(_\
    \ > _)\n            } else {\n                array.sortWith(_ < _)\n        \
    \    }\n        }", "        // Fill up this function body\n        // f(x)\n\
    \        (array.head + array.last) % 2 match {\n            case 0 => array.sortWith(_>_)\n\
    \            case 1 => array.sortWith(_<_)\n        }", "        if (array.length\
    \ == 0) {\n            array\n        } else if (array.length == 1) {\n      \
    \      array\n        } else {\n            if ((array(0) + array(array.length\
    \ - 1)) % 2 == 0) {\n                val sortedArray = array.sorted\n        \
    \        sortedArray.reverse\n            } else {\n                array.sorted\n\
    \            }\n        }", "        // your code here\n        null", "     \
    \ if (array.length > 0) {\n        var result = array.toArray.sorted\n       \
    \ if (result.head + result.last % 2 == 0) result = result.reverse\n        result.toList\n\
    \      } else array", "        // Implement this function to return the correct\
    \ answer.\n        if (array.isEmpty) {\n            return array\n        }\n\
    \        val sortedArray = array.sorted\n        if ((array.head + array.last)\
    \ % 2 == 0) {\n            return sortedArray.reverse\n        }\n        return\
    \ sortedArray", "        // Your code and logic here\n        (array.toBuffer.sortWith(_\
    \ < _)).toList", "        var sorted : List[Long] = array.sorted\n        if (array.length\
    \ > 0 && (array.head + array.last) % 2 == 0) sorted = sorted.reverse\n       \
    \ sorted", "        // A simple way is to traverse the array and store the count\
    \ of each value in a counting array.\n        // Then traverse the counting array\
    \ and print all the values whose count is not zero.\n        // The time complexity\
    \ of this approach is O(n) because each element is traversed at most 2 times.\n\
    \        // Space complexity of this approach is O(n).\n        // We can reduce\
    \ the space complexity to O(1) by replacing counting array with a single number.\n\
    \        // We can use the index of the array as the value.\n        // For example,\
    \ consider an array arr[] = {2, 3, 3, 2, 5}.\n        // Instead of creating a\
    \ counting array (where the array index represents the value),\n        // we\
    \ can directly store the count of arr[0] at arr[0] (2).\n        // The array\
    \ will now look like (0, 2, 0, 2, 0, 1).\n        // Here, we have subtracted\
    \ 1 from the count of arr[0].\n        // Next, we store the count of arr[1] (3)\
    \ at arr[1] \u2013 1 (2).\n        // The array will now look like (0, 2, 3, 2,\
    \ 0, 1).\n        // We continue this process.\n        // When we are done, each\
    \ index will store the count of the index.\n        // We traverse the counting\
    \ array, and print the index that count of that index is not zero.\n        val\
    \ countingArray = new Array[Long](array.length)\n        for (i <- 0 until array.length)\
    \ {\n            countingArray(array(i).toInt) += 1\n        }\n        val result\
    \ = ListBuffer[Long]()\n        for (i <- 0 until countingArray.length) {\n  \
    \          for (j <- 0 until countingArray(i)) {\n                result += i\n\
    \            }\n        }\n        result.toList", "\t\tif (array.length == 0)\
    \ return array\n\t\tval order = array.head + array.last\n\t\tif (order % 2 ==\
    \ 0) array.sorted.reverse\n\t\telse array.sorted", "        if (array.isEmpty)\
    \ {\n            List[Long]()\n        } else if (array.length == 1) {\n     \
    \       array\n        } else {\n            val sum = array.head + array.last\n\
    \            if (sum % 2 == 0) {\n                array.sorted(Ordering[Long].reverse)\n\
    \            } else {\n                array.sorted\n            }\n        }",
  "        if (array.length < 2) return array\n        else if ((array.head + array.last)\
    \ % 2 == 0) array.sortWith((a, b) => a > b)\n        else array.sortWith((a, b)\
    \ => a < b)", "        if (array.isEmpty) (array)\n        else {\n          \
    \  if ((array.head + array.last) % 2 == 0) {\n                (List[Long](array.last))\
    \ ++ sortArray(array.init)\n            } else {\n                (List[Long](array.head))\
    \ ++ sortArray(array.tail)\n            }\n        }", "        //\n        if\
    \ (array.length <= 1) array\n        else {\n            var x = array(0)\n  \
    \          var y = array(array.length - 1)\n            var l = array.length\n\
    \            var (left, right) = array.partition(_ < y)\n            sortArray(left)\
    \ ::: sortArray(right)\n        }", "        def sort(array : List[Long], result\
    \ : List[Long]) : List[Long] = {\n            if (array.isEmpty) result\n    \
    \        else if (array.length == 1) result :+ array.head\n            else {\n\
    \                val min = array.min\n                val max = array.max\n  \
    \              if ((min + max) % 2 == 0) {\n                    val head = array.slice(0,\
    \ array.indexOf(max))\n                    val tail = array.slice(array.indexOf(max)\
    \ + 1, array.length)\n                    sort(head ::: tail, result :+ max)\n\
    \                }\n                else {\n                    val head = array.slice(0,\
    \ array.indexOf(min))\n                    val tail = array.slice(array.indexOf(min)\
    \ + 1, array.length)\n                    sort(head ::: tail, result :+ min)\n\
    \                }\n            }\n        }\n        sort(array, List[Long]())",
  "        def recur(array : List[Long], result : List[Long]) : List[Long] = {\n \
    \           if (array.length <= 1) result\n            else if (array.head + array.last\
    \ % 2 == 0) recur(array.slice(1, array.length - 1), result :+ array.last :+ array.head)\n\
    \            else recur(array.slice(1, array.length - 1), result :+ array.head\
    \ :+ array.last)\n        }\n        recur(array, List[Long]())", "        var\
    \ result : List[Long] = List()\n        if (array.size == 0) {\n            result\
    \ = array\n        } else if (array.size == 1) {\n            result = array\n\
    \        } else {\n            var direction : Long = (array(0) + array(array.size\
    \ - 1)) % 2\n            var newArray : List[Long] = List()\n            for (i\
    \ <- 0 until array.size) {\n                if (i == 0) {\n                  \
    \  newArray = array(i) :: newArray\n                } else {\n               \
    \     var flag : Long = (array(i) + array(0)) % 2\n                    var needInsert\
    \ : Boolean = false\n                    if (direction == 0 && flag == 0) {\n\
    \                        for (j <- 0 until newArray.size) {\n                \
    \            if (array(i) > newArray(j)) {\n                                newArray\
    \ = newArray.take(j) ::: array(i) :: newArray.drop(j)\n                      \
    \          needInsert = true\n                                break\n        \
    \                    }\n                        }\n                    } else\
    \ if (direction == 0 && flag == 1) {\n                        for (j <- 0 until\
    \ newArray.size) {\n                            if (array(i) < newArray(j)) {\n\
    \                                newArray = newArray.take(j) ::: array(i) :: newArray.drop(j)\n\
    \                                needInsert = true\n                         \
    \       break\n                            }\n                        }\n    \
    \                } else if (direction == 1 && flag == 0) {\n                 \
    \       for (j <- 0 until newArray.size) {\n                            if (array(i)\
    \ < newArray(j)) {\n                                newArray = newArray.take(j)\
    \ ::: array(i) :: newArray.drop(j)\n                                needInsert\
    \ = true\n                                break\n                            }\n\
    \                        }\n                    } else if (direction == 1 && flag\
    \ == 1) {\n                        for (j <- 0 until newArray.size) {\n      \
    \                      if (array(i) > newArray(j)) {\n                       \
    \         newArray = newArray.take(j) ::: array(i) :: newArray.drop(j)\n     \
    \                           needInsert = true\n                              \
    \  break\n                            }\n                        }", "       \
    \ // Write your code here\n        val sum = array.head + array.last\n       \
    \ if(sum % 2 == 0) array.sortWith((x, y) => x < y)\n        else array.sortWith((x,\
    \ y) => x > y)", "        var result : List[Long] = List[Long]()\n        if (array.size\
    \ == 0) {\n            result = array\n        } else if (array.size == 1) {\n\
    \            result = array\n        } else {\n            var first : Long =\
    \ array(0)\n            var last : Long = array(array.size - 1)\n            if\
    \ ((first + last) % 2 == 0) {\n                result = array.sortWith((a, b)\
    \ => a > b)\n            } else {\n                result = array.sortWith((a,\
    \ b) => a < b)\n            }\n        }\n        return result", "        //\
    \ your code here\n        return array", "        // Your code here\n        if\
    \ (array.isEmpty) return array\n        val merged = array.zipWithIndex.sortBy(_._1)\n\
    \        val sum = merged.head._1 + merged.last._1\n        if (sum % 2 == 0)\
    \ merged.map(_._1).reverse else merged.map(_._1)", '        array.sortWith((a,
    b) => if ((a + b) % 2 == 0) a > b else a < b)', "        // Implement this solution\n\
    \        if (array.isEmpty) return array\n        val index = 0 + ((array.length\
    \ - 1 - 0) / 2)\n        val (first, last) = (array(0), array(array.length - 1))\n\
    \        val (f, l) = ((first + last) % 2, array.length % 2)\n        val temp\
    \ = (array.slice(0, index + 1).sorted ++ array.slice(index + 1, array.length).sorted).toBuffer\n\
    \        val result = for ( i <- 0 until array.length) yield {\n            if\
    \ (i < index) temp(i)\n            else if (i == index) {\n                if\
    \ (f == l) temp(i)\n                else temp(array.length - 1 - i)\n        \
    \    }\n            else {\n                if (f == l) temp(array.length - 1\
    \ - i)\n                else temp(i)\n            }\n        }\n        result.toList",
  "        // Write your codescala here.\n        // array.sorted\n        array.sortWith(_\
    \ < _)", "        // Write your cose here\n        array", "        def sortArray0(array\
    \ : List[Long], result : List[Long]) : List[Long] = {\n            if (array.isEmpty)\
    \ result\n            else {\n                if (result.isEmpty) sortArray0(array.tail,\
    \ result :+ array.head)\n                else {\n                    val f = array.head\n\
    \                    val r = result.last\n                    val s = f + r\n\
    \                    if (s % 2 == 0) sortArray0(array.tail, result :+ array.head)\n\
    \                    else {\n                        var r2 = result.reverse\n\
    \                        var a = array.tail\n                        var f1 =\
    \ true\n                        while (f1) {\n                            val\
    \ t = a.head\n                            val r1 = r2.head\n                 \
    \           val s1 = t + r1\n                            if (s1 % 2 == 0) {\n\
    \                                r2 = r2.tail\n                              \
    \  a = a.tail\n                            }\n                            else\
    \ {\n                                r2 = r2.tail :+ r1\n                    \
    \            a = t :: a.tail\n                                f1 = false\n   \
    \                         }\n                        }\n                     \
    \   sortArray0(a, r2.reverse :+ f)\n                    }\n                }\n\
    \            }\n        }\n        def sortArray1(array : List[Long], result :\
    \ List[Long]) : List[Long] = {\n            if (array.isEmpty) result\n      \
    \      else {\n                if (result.isEmpty) sortArray1(array.tail, result\
    \ :+ array.head)\n                else {\n                    val f = array.head\n\
    \                    val r = result.last\n                    val s = f + r\n\
    \                    if (s % 2 == 0) sortArray1(array.tail, result :+ array.head)\n\
    \                    else {\n                        var r2 = result.reverse\n\
    \                        var a = array.tail\n                        var f1 =\
    \ true\n                        while (f1) {\n                            val\
    \ t = a.head\n                            val r1 = r2.head\n                 \
    \           val s1 = t + r1\n                            if (s1 % 2 == 0) {\n\
    \                                r2 = r2.tail\n                              \
    \  a = a.tail\n                            }\n                           ", " \
    \       // Your Code Here\n        array", "        if (array.length <= 1) return\
    \ array\n        var i = 0\n        var res = array\n        if ((res(0) + res(res.length\
    \ - 1)) % 2 == 0) {\n            while (i < res.length / 2) {\n              \
    \  val temp = res(i)\n                res = res.updated(i, res(res.length - 1\
    \ - i))\n                res = res.updated(res.length - 1 - i, temp)\n       \
    \         i += 1\n            }\n        }\n        return res", "        // Write\
    \ your solution here\n        array.sorted", "        def recur(left : List[Long],\
    \ right : List[Long], result : List[Long]) : List[Long] = {\n            if (left.isEmpty\
    \ && right.isEmpty) result\n            else if (left.isEmpty) result ++ right\n\
    \            else if (right.isEmpty) result ++ left\n            else {\n    \
    \            if (left.head > right.head) recur(left.tail, right, result :+ left.head)\n\
    \                else recur(left, right.tail, result :+ right.head)\n        \
    \    }\n        }\n        def mergeSort(array : List[Long]) : List[Long] = {\n\
    \            if (array.length < 2) array\n            else {\n               \
    \ val n = array.length / 2\n                val left = mergeSort(array.slice(0,\
    \ n))\n                val right = mergeSort(array.slice(n, array.length))\n \
    \               recur(left, right, List[Long]())\n            }\n        }\n \
    \       def sort(array : List[Long]) : List[Long] = {\n            if (array.isEmpty)\
    \ array\n            else {\n                val sorted = mergeSort(array)\n \
    \               if ((sorted.head + sorted.last) % 2 == 0) sorted.reverse\n   \
    \             else sorted\n            }\n        }\n        sort(array)", " \
    \       // Fill up this function body\n        // `0` is the value that you want\
    \ to test with\n        return null", "        // Fill up this function body\n\
    \        // `val` is immutable, `var` is mutable.\n        array.sortWith(_ <\
    \ _)", "        // this is a trick, if you have a List, then call array.sum, you\
    \ will get a Long value\n        // and if you have a ListBuffer, then call array.sum,\
    \ you will get a Int value\n        // you need to convert List to ListBuffer\
    \ before call sum()\n        val temp = array.to[ListBuffer]\n        if ((temp.sum\
    \ % 2) == 0) temp.sorted.reverse.toList else temp.sorted.toList", "        //\
    \ Your code here (Part I).\n        array.sortWith((x, y) => (x+y)%2==0)", " \
    \       // Write your code here\n        if (array.length == 0) {\n          \
    \  return array\n        }\n        if (array.length == 1) {\n            return\
    \ array\n        }\n        if (array.length == 2) {\n            if ((array(0)\
    \ + array(1)) % 2 == 0) {\n                return List(array(1), array(0))\n \
    \           } else {\n                return array\n            }\n        }\n\
    \        var (prelist, afterlist) = array.splitAt(array.length / 2)\n        prelist\
    \ = sortArray(prelist)\n        afterlist = sortArray(afterlist)\n        var\
    \ res = List[Long]()\n        var (p1, p2) = (0, 0)\n        while (p1 < prelist.length\
    \ && p2 < afterlist.length) {\n            if ((prelist(p1) + afterlist(p2)) %\
    \ 2 == 0) {\n                res = res :+ afterlist(p2)\n                p2 +=\
    \ 1\n            } else {\n                res = res :+ prelist(p1)\n        \
    \        p1 += 1\n            }\n        }\n        if (p1 == prelist.length)\
    \ {\n            res = res ::: afterlist.slice(p2, afterlist.length)\n       \
    \ } else {\n            res = res ::: prelist.slice(p1, prelist.length)\n    \
    \    }\n        return res", "        val arrayLength = array.length\n       \
    \ if (arrayLength == 0) return array\n        else if (arrayLength == 1) return\
    \ array\n        else {\n            val sortedArray = array.sorted\n        \
    \    if ((array(0) + array(arrayLength - 1)) % 2 == 0) return sortedArray.reverse\n\
    \            else return sortedArray\n        }", "        var result = List[Long]()\n\
    \        if(array.length == 0) return result\n        if(array.length == 1) return\
    \ array\n        val first = array.head\n        val last = array.last\n     \
    \   var sorted = array.sorted\n        if((first + last) % 2 == 0) sorted = sorted.reverse\n\
    \        return sorted", "        // f: ((List[Long]))List[Long]\n        array\
    \ match {\n            case Nil => List[Long]()\n            case _ => \n    \
    \            if (array.head + array.last % 2 == 0) array.sorted.reverse else array.sorted\n\
    \        }", "        if (array.length <= 1) return array\n        val s = array.head\n\
    \        val e = array.last\n        if ((s + e) % 2 == 0) return array.sorted.reverse\n\
    \        else return array.sorted"]
stop_tokens:
- "\n    }\n"
