name: HumanEval_34_unique
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return sorted unique elements in a list\n    // >>> unique((List[Long](5l.toLong,\
  \ 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n\
  \    // (List[Long](0l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))\n\
  \    def unique(l : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(unique((List[Long](5l.toLong,\
  \ 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](0l.toLong,\
  \ 2l.toLong, 3l.toLong, 5l.toLong, 9l.toLong, 123l.toLong))));\n    }\n\n}\n"
completions: ["        var a = l.sortWith(_ > _)\n        var a1 = 0l.toLong\n   \
    \     var b = new ListBuffer[Long]\n        for (a1 <- a) {\n            if (b.length\
    \ == 0 || b(b.length - 1) != a1) {\n                b += a1\n            }\n \
    \       }\n        b.toList", "        var m = Map[Long, Int]()\n        for (i\
    \ <- l) m += i -> 1\n        m.keys.toList.sorted", "        // Return sorted\
    \ unique elements in a list\n        return l.distinct.sorted", '        l.distinct.sorted',
  "      val res = new ListBuffer[Long]\n      for (x <- l) {\n        if (!res.contains(x))\
    \ res += x\n      }\n      return res.toList.sorted", "        var d = new HashSet[Long]()\n\
    \        for (e <- l) {\n            d += e\n        }\n        d.toList.sorted",
  "        if (l.length == 0) {\n            return List[Long]()\n        }\n    \
    \    else {\n            val e = l.head\n            val n = unique(l.tail.filter(x\
    \ => x != e))\n            return e :: n\n        }", '        l.foldLeft(List[Long]())((result,
    x) => if (result.contains(x)) result else x :: result).sorted', '        l.toSet.toList.sorted',
  "        var set = Set[Long]()\n        l.foreach(i => set += i)\n        return\
    \ set.toList.sorted", '        l.toSet.toList.sorted', '        l.distinct.sorted',
  '        return l.distinct.sorted', "        val set = scala.collection.mutable.Set[Long]()\n\
    \        set ++= l\n        val list = set.toList\n        list.sortWith(_ < _)",
  "        val sorted = l.sortWith(_ < _)\n        sorted.foldLeft(List[Long]())((a,\
    \ b) => a match {\n            case List() => List(b)\n            case x::xs\
    \ => {\n                if (x == b) a\n                else x::a\n           \
    \ }\n        }).reverse", '        l.distinct.sorted', '        l.distinct.sorted',
  "        var s = new TreeSet[Long]()\n        l.foreach(s.add(_))\n        s.toList",
  "        val set = SortedSet[Long]()\n        for (i <- l) set += i\n        return\
    \ set.toList", '        l.distinct.sorted', '        l.sortWith(_ < _).distinct',
  '        l.foldLeft(List[Long]())((list, elem) => if (list.contains(elem)) list
    else list :+ elem).sorted', '        l.toSet.toList.sorted', '        l.toSet.toList.sorted',
  "        val m = scala.collection.mutable.LinkedHashMap[Long, Boolean]()\n     \
    \   for (x <- l) m += x -> true\n        m.keys.toList", '        l.toSet.toList.sorted',
  "        val set = l.toSet\n        val array = ArrayBuffer[Long]()\n        for\
    \ (a <- set) array += a\n        array.sorted.toList", "        val ans = SortedSet[Long]()\n\
    \        for (x <- l) ans += x\n        return ans.toList", '        l.toSet.toList.sorted',
  '        l.distinct.sorted', "        var result = new ListBuffer[Long]\n      \
    \  var set = new HashSet[Long]\n        for (e <- l) {\n            if (!set.contains(e))\
    \ {\n                set += e\n                result += e\n            }\n  \
    \      }\n        result.toList.sorted", "        val sorted = l.sorted\n    \
    \    var unique = List[Long]()\n        if (sorted.length > 0) {\n           \
    \ unique = unique :+ sorted(0)\n            for (i <- 1 until sorted.length) {\n\
    \                if (sorted(i) != sorted(i - 1)) {\n                    unique\
    \ = unique :+ sorted(i)\n                }\n            }\n        }\n       \
    \ return unique", "        val s = SortedSet[Long]()\n        for (i <- l) {\n\
    \            s += i\n        }\n        return s.toList", '        return l.distinct.sorted',
  "        val m = scala.collection.mutable.HashSet[Long]()\n        for (v <- l)\
    \ m += v\n        val n = scala.collection.mutable.ListBuffer[Long]()\n      \
    \  for (v <- m) n += v\n        return n.toList.sorted", '        l.toSet.toList.sorted',
  '        l.toSet.toList.sorted', "        val t = l.sortWith(_ < _)\n        val\
    \ r = new ListBuffer[Long]\n        for (i <- 0 until t.length) {\n          \
    \  if (i == 0 || t(i) != t(i - 1)) r += t(i)\n        }\n        r.toList", '        l.toSet.toList.sorted',
  '        l.distinct.sorted', "        val s = SortedSet[Long]()\n        l.foreach(x\
    \ => s += x)\n        s.toList", '      l.sortWith(_<_).foldLeft(List[Long]())((a,b)
    => if (a.length == 0 || a.last != b) a :+ b else a)', "        var result = List[Long]()\n\
    \        var seen = Set[Long]()\n        for (i <- l) {\n            if (!seen.contains(i))\
    \ {\n                result = i :: result\n                seen += i\n       \
    \     }\n        }\n        return result.sorted", "        val s = Set[Long]()\n\
    \        var r = List[Long]()\n        for (e <- l) {\n            if (!s.contains(e))\
    \ {\n                s += e\n                r = e :: r\n            }\n     \
    \   }\n        r.sortWith(_ < _)", '        return l.toSet.toList.sorted', " \
    \       if (l.isEmpty) List[Long]()\n        else l.head :: unique(l.tail.filter(_\
    \ != l.head))", '        l.distinct.sorted', "        val set = HashSet[Long]()\n\
    \        for (n <- l) {\n            set += n\n        }\n        set.toList.sorted",
  '        return l.distinct.sorted', '        l.toSet.toList.sorted', '        l.distinct.sorted',
  "        val n = l.size\n        if (n == 0) {\n            return List[Long]()\n\
    \        }\n        else if (n == 1) {\n            return List[Long](l(0))\n\
    \        }\n        else {\n            val m = n / 2\n            val left =\
    \ unique(l.slice(0, m))\n            val right = unique(l.slice(m, n))\n     \
    \       val (l1, l2) = combine(left, right)\n            l1 ::: l2\n        }",
  '        l.distinct.sorted', "        var ret = List[Long]()\n        for (i <-\
    \ l) {\n            if (!ret.contains(i)) {\n                ret = ret :+ i\n\
    \            }\n        }\n        return ret.sorted", "        var result = List[Long]()\n\
    \        for (x <- l) {\n            if (!result.contains(x)) result = x :: result\n\
    \        }\n        result.sortWith(_ < _)", '        l.distinct.sorted', "  \
    \      var ret : List[Long] = List[Long]()\n        for (e <- l) {\n         \
    \   if (!ret.contains(e)) {\n                ret = ret :+ e\n            }\n \
    \       }\n        return ret.sorted", '        l.distinct.sorted', '        l.sortWith(_<_).distinct',
  '        l.sortWith(_ < _).foldLeft(List[Long]())((res, x) => if (res.length ==
    0 || res.last != x) res :+ x else res)', '        l.sortWith(_ < _).distinct',
  '        return l.sortWith(_ < _).distinct', '        return l.distinct.sorted',
  '        l.distinct.sorted', "        if (l.isEmpty) List[Long]()\n        else\
    \ {\n            val h = l.head\n            h :: unique(l.filter(_ != h))\n \
    \       }", "        var o : List[Long] = List[Long]()\n        for (i <- l) {\n\
    \            if (!o.contains(i)) o = o :+ i\n        }\n        o.sorted", '        return
    l.distinct.sorted', "        val map = new HashMap[Long, Int]\n        val res\
    \ = ListBuffer[Long]()\n        for (x <- l) {\n            if (!map.contains(x))\
    \ {\n                map(x) = 1\n                res += x\n            }\n   \
    \     }\n        res.sorted.toList", '        l.distinct.sorted', '        l.distinct.sorted',
  "        var m = new TreeSet[Long]\n        for (i <- l) {\n            m += i\n\
    \        }\n        var ret = List[Long]()\n        for (i <- m) {\n         \
    \   ret = i :: ret\n        }\n        ret.reverse", '        l.distinct.sorted',
  '        l.sortWith(_ < _).distinct', '        l.distinct.sorted', "        val\
    \ sl = SortedSet[Long]() ++ l\n        sl.toList", '        return l.distinct.sorted',
  "        val s = new SortedSet[Long]\n        for (i <- l) s += i\n        s.toList",
  "        var list = List[Long]()\n        for (x <- l) {\n            if (!list.contains(x))\
    \ list = list :+ x\n        }\n        list.sorted", '        l.distinct.sorted',
  '        l.toSet.toList.sorted', "        var hm = HashMap[Long, Boolean]()\n  \
    \      l.foreach(x => hm += (x -> true))\n        return hm.keys.toList.sorted",
  '        l.distinct.sorted', '        return l.toSet.toList.sorted', "        val\
    \ s = HashSet[Long]()\n        for (i <- l) s += i\n        return s.toList.sorted",
  '        return l.toSet.toList.sorted', '        l.toSet.toList.sorted', "     \
    \   val set = Set[Long]()\n        l.foreach(set += _)\n        set.toList.sorted",
  '        l.distinct.sorted', '        l.sorted.distinct', "        val s = l.toSet\n\
    \        val r = (for (x <- s) yield x).toList\n        return r.sorted", "  \
    \      val s = l.toSet\n        val l2 = s.toList\n        l2.sortWith((a, b)\
    \ => a < b)", "        var result = new ListBuffer[Long]\n        for (i <- l)\
    \ {\n            if (!result.contains(i)) result += i\n        }\n        result.toList.sorted",
  "        l.foldLeft((List[Long]()))((r, c) =>\n            if (r.exists(_ == c))\
    \ r else r :+ c\n        ).sorted", '        l.distinct.sorted', "        var\
    \ result = List[Long]()\n        for (i <- l) {\n            if (!result.contains(i))\
    \ result = i :: result\n        }\n        result.sortWith(_ < _)", '        l.sortWith(_
    < _).distinct', '        l.sortWith(_ < _).foldLeft(List[Long]())((acc, x) =>
    if (acc.isEmpty || x != acc.last) acc :+ x else acc)', "        val l2 = l.sortWith(_\
    \ < _)\n        val s = l2.toSet\n        s.toList", "        if (l.isEmpty) return\
    \ List[Long]()\n        var r : Long = l.head\n        var rlist : List[Long]\
    \ = List(r)\n        var rest = l.tail\n        while (!rest.isEmpty) {\n    \
    \        if (rest.head != r) {\n                r = rest.head\n              \
    \  rlist = rlist :+ r\n            }\n            rest = rest.tail\n        }\n\
    \        return rlist", "        val s = SortedSet[Long]()\n        l.foreach(e\
    \ => s += e)\n        s.toList", '        l.toSet.toList.sorted', "        val\
    \ m = Map[Long, Long]()\n        for (i <- l) {\n            m(i) = m.getOrElse(i,\
    \ 0l.toLong) + 1l.toLong\n        }\n        return m.toList.sortWith((a, b) =>\
    \ a._1 < b._1).map(x => x._1)", "        val sl = l.sorted\n        val rl = ListBuffer[Long]()\n\
    \        for (x <- sl) {\n            if (rl.isEmpty || rl.last != x) rl += x\n\
    \        }\n        rl.toList", "        if (l.isEmpty) l\n        else {\n  \
    \          val hd = l.head\n            val set = unique(l.tail)\n           \
    \ if (set.contains(hd)) set\n            else hd :: set\n        }", '        l.distinct.sorted',
  "        val buf = ListBuffer[Long]()\n        for (e <- l) {\n            if (!buf.contains(e))\
    \ {\n                buf += e\n            }\n        }\n        buf.toList.sorted",
  '        l.sortWith(_ < _).distinct', '        return l.distinct.sorted', "    \
    \    var m = new HashMap[Long, Long]()\n        for (i <- l) m(i) = i\n      \
    \  return m.keys.toList.sorted", '        l.sortWith(_ < _).reverse.filter((x
    : Long) => l.count(_ == x) == 1).reverse', "        if (l.length < 2) l\n    \
    \    else {\n            val sortedList = l.sorted\n            val first = sortedList.head\n\
    \            sortedList.tail.foldLeft(List[Long](first))((acc, n) => {\n     \
    \           if (n == acc.head) acc\n                else n :: acc\n          \
    \  }).reverse\n        }", "        val l2 = l.distinct\n        l2.sortWith(_\
    \ < _)", "        val set = HashSet[Long]()\n        l.foreach(e => set += e)\n\
    \        val array = new Array[Long](set.size)\n        var i = 0\n        set.foreach(e\
    \ => {\n            array(i) = e\n            i += 1\n        })\n        array.sorted.toList",
  '        return l.distinct.sorted', '        return l.distinct.sorted', '        l.distinct.sorted',
  '        l.toSet.toList.sorted', '        return l.toSet.toList.sorted', "     \
    \   l.foldLeft(List[Long]())((ret, x) => {\n            if (!ret.contains(x))\
    \ x :: ret\n            else ret\n        }).sortWith(_ < _)", '        return
    l.toSet.toList.sorted', '        l.distinct.sorted', '        l.sortWith(_ < _).distinct',
  "        val u = l.toSet.toList\n        u.sortWith(_ < _)", '        l.toSet.toList.sorted',
  '        l.distinct.sorted', '        l.toSet.toList.sorted', '        l.toSet.toList.sorted',
  "        var uniques = List[Long]()\n        l.foreach(i => if (!uniques.contains(i))\
    \ uniques = uniques :+ i)\n        uniques.sorted", "        var d : List[Long]\
    \ = List()\n        for (i <- l) {\n            if (!d.contains(i)) {\n      \
    \          d = i :: d\n            }\n        }\n        d = d.sorted\n      \
    \  return d", '        l.sorted.distinct', "        val result = new ListBuffer[Long]()\n\
    \        for (e <- l)\n            if (!result.contains(e))\n                result\
    \ += e\n        result.toList.sorted", '        l.sorted.distinct', "        //\
    \ To get unique elements, we need to remove elements that\n        // already\
    \ appear in the list. We can take advantage of the\n        // fact that Set is\
    \ unique.\n        val s = Set() ++ l\n        (s.toList).sorted", '        l.sortWith(_
    < _).distinct', '        l.foldLeft(List[Long]())((r, c) => if (r.contains(c))
    r else r ::: List(c)).sorted', "        // return sorted, unique elements of l\n\
    \        l.sortWith(_ < _).reverse.foldLeft(List[Long]())((a, b) => {\n      \
    \      if (a.length == 0 || a.head != b) b :: a else a\n        }).reverse", " \
    \       var hash = new HashSet[Long]()\n        for (x <- l) hash += x\n     \
    \   return hash.toList.sorted", '        l.sorted.distinct', '        l.foldLeft(List[Long]())((a,
    b) => if (a.contains(b)) a else a :+ b).sorted', '        return (List[Long]()
    ++ l.distinct.sorted)', '        l.sortWith(_ < _).distinct', "        def unique0(l\
    \ : List[Long], acc : List[Long]) : List[Long] = l match {\n            case Nil\
    \ => acc\n            case h :: t => unique0(t.filter((e) => e != h), h :: acc)\n\
    \        }\n        unique0(l, List[Long]()).sortWith((a, b) => a < b)", '        l.toSet.toList.sorted',
  "        var result = List[Long]()\n        var hs = HashSet[Long]()\n        for\
    \ (i <- l) {\n            if (!hs.contains(i)) {\n                hs += i\n  \
    \              result = result :+ i\n            }\n        }\n        result.sorted",
  "        if (l.isEmpty) return List[Long]()\n        var result = new ListBuffer[Long]\n\
    \        result += l.head\n        for (i <- 1 until l.length) {\n           \
    \ if (l(i) != l(i - 1)) result += l(i)\n        }\n        return result.toList",
  '        return l.distinct.sorted', '        l.sortWith(_ < _).distinct', "    \
    \    val s = Set[Long]()\n        val l2 = ListBuffer[Long]()\n        for (i\
    \ <- l) {\n            if (!s.contains(i)) {\n                s += i\n       \
    \         l2 += i\n            }\n        }\n        l2.toList.sorted", '        return
    l.distinct.sorted', "        var s = new HashSet[Long]\n        for (x <- l) {\n\
    \            s += x\n        }\n        s.toList.sorted", '        l.distinct.sorted',
  "        var m = HashMap[Long, Long]()\n        for (i <- l) m(i) = 1\n        var\
    \ result = m.keys.toList\n        result.sortWith(_ < _)", "        val s = Set[Long]()\n\
    \        l.foreach(x => s.add(x))\n        s.toList.sorted", "        var lset\
    \ = Set[Long]()\n        for (e <- l) lset += e\n        lset.toList.sorted",
  "        val s = SortedSet[Long]()\n        for (i <- l) s += i\n        return\
    \ s.toList", '        l.toSet.toList.sorted', "        // sort the list and get\
    \ its unique elements\n        val list = l.sortWith(_ < _)\n        def loop(acc\
    \ : List[Long], prev : Long, rem : List[Long]) : List[Long] = rem match {\n  \
    \          case Nil => acc\n            case h :: t =>\n                if (h\
    \ == prev) loop(acc, prev, t)\n                else loop(acc :+ h, h, t)\n   \
    \     }\n        list match {\n            case Nil => List[Long]()\n        \
    \    case h :: t => loop(List[Long](h), h, t)\n        }", '        l.foldLeft(List[Long]())((x,
    y) => if (x.contains(y)) x else x :+ y).sorted', '        return l.distinct.sorted',
  "        var l2 = List[Long]()\n        for (e <- l) {\n            if (!l2.contains(e))\
    \ {\n                l2 = e :: l2\n            }\n        }\n        return l2.sorted",
  "        return l.sortWith(_ < _).foldLeft(List[Long]())((acc, i) => {\n       \
    \     if (acc.isEmpty || acc.last != i) acc :+ i\n            else acc\n     \
    \   })", '        l.distinct.sorted', '        l.toSet.toList.sorted', '        return
    l.sortWith(_<_).foldLeft(List[Long]())((result, current) => {if (result.isEmpty
    || result.last != current) result :+ current else result})', "        val r =\
    \ scala.collection.mutable.ListBuffer[Long]()\n        for (v <- l) {\n      \
    \      r += v\n        }\n        val e = r.toList.sortWith(_ < _)\n        if\
    \ (e.length == 0) {\n            return e\n        }\n        val r2 = scala.collection.mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < e.length) {\n            if (i == 0 ||\
    \ e(i) != e(i - 1)) {\n                r2 += e(i)\n            }\n           \
    \ i += 1\n        }\n        r2.toList", "        val hm = HashMap[Long, Int]()\n\
    \        l.foreach(x => hm(x) = 1)\n        hm.keys.toList.sorted", '        l.sortWith(_
    < _).distinct', "        def unique(l : List[Long], acc : List[Long]) : List[Long]\
    \ = {\n            if (l.isEmpty) acc\n            else if (acc.isEmpty) unique(l.tail,\
    \ acc :+ l.head)\n            else if (l.head == acc.head) unique(l.tail, acc)\n\
    \            else unique(l.tail, acc :+ l.head)\n        }\n        unique(l.sorted,\
    \ List[Long]())", '        l.sortWith(_ < _).distinct', '        l.toSet.toList.sorted',
  "        // Union all elements with itself\n        // Then remove all elements\
    \ that are not equal to itself (remove duplicates)\n        l.map((x : Long) =>\
    \ Set(x, x)).reduce((x : Set[Long], y : Set[Long]) => x union y).filter((x : Long)\
    \ => x == x)", "        val s = SortedSet[Long]()\n        for (x <- l) {\n  \
    \          s += x\n        }\n        s.toList", "        // Sort the list\n \
    \       val sorted = l.sortWith((a, b) => a < b)\n        var prev : Long = -1\n\
    \        var result : List[Long] = List[Long]()\n        for (i <- sorted) {\n\
    \            if (i != prev) {\n                result = result :+ i\n        \
    \        prev = i\n            }\n        }\n        return result", "       \
    \ // ??? What's going on here?\n        l.distinct.sorted", "        val h = HashSet[Long]()\n\
    \        l.foreach(x => h.add(x))\n        h.toList.sorted", '        return l.distinct.sorted',
  "      var ret = l.sorted\n      var hset = HashSet[Long]()\n      for (num <- ret)\
    \ {\n        hset += num\n      }\n      return hset.toList.sorted", '      return
    l.distinct.sorted', "        def uniqueH(l : List[Long], res : List[Long]) : List[Long]\
    \ = {\n            if (l.length == 0) res\n            else if (res.contains(l.head))\
    \ uniqueH(l.tail, res)\n            else uniqueH(l.tail, res ++ List(l.head))\n\
    \        }\n        uniqueH(l, List[Long]())", '        l.sortWith(_ < _).foldLeft(List[Long]())((r,
    c) => if (r.isEmpty || r.last != c) r ::: List(c) else r)', '        return l.toSet.toList.sorted',
  "        var sorted = l.sorted\n        var result = List[Long]()\n        var last\
    \ : Long = 0\n        for (i <- sorted) {\n            if (i != last) {\n    \
    \            result = result :+ i\n                last = i\n            }\n \
    \       }\n        return result", "        var a = ArrayBuffer[Long]()\n    \
    \    for (x <- l) {\n            if (!a.contains(x)) a += x\n        }\n     \
    \   return a.toList.sorted", "        var m = Map[Long, Boolean]()\n        for\
    \ (n <- l) {\n            m += (n -> true)\n        }\n        return m.keys.toList.sorted",
  "        var seen = HashSet[Long]()\n        var uniqueList = List[Long]()\n   \
    \     for (i <- l) {\n            if (!seen.contains(i)) {\n                seen\
    \ += i\n                uniqueList = i :: uniqueList\n            }\n        }\n\
    \        return uniqueList.sortWith(_<_)", '        l.sorted.distinct', '        return
    l.distinct.sorted', '        return (l.sortWith(_ < _)).distinct', '        return
    l.sortWith(_ < _).distinct', "        val l2 = (l.sortWith(_<_)).distinct\n  \
    \      return l2", '        l.distinct.sorted', "        val s = TreeSet[Long]()\n\
    \        for (x <- l) s += x\n        s.toList", "        var lp = List[Long]()\n\
    \        var m = Map[Long, Boolean]()\n        for (x <- l) {\n            if\
    \ (!m.contains(x)) {\n                m(x) = true\n                lp = x :: lp\n\
    \            }\n        }\n        return lp.sortWith(_ < _)", '        l.sortWith(_
    < _).foldLeft(List[Long]())((r,c) => if (r.isEmpty || r.last != c) r ::: List(c)
    else r)', "        var nl = List[Long]()\n        var prev : Long = 0\n      \
    \  for (num <- l.sorted) {\n            if (num != prev) nl = nl :+ num\n    \
    \        prev = num\n        }\n        return nl", "        val m = new TreeSet[Long]\n\
    \        for (x <- l) m += x\n        m.toList", '        l.distinct.sorted',
  "        return l.sortWith(_ < _).foldLeft(List[Long]())((a, b) => {\n         \
    \   if (a.isEmpty || b != a.last) {\n                a :+ b\n            } else\
    \ {\n                a\n            }\n        })", '        return l.sortWith(_<_).distinct',
  "        // In the list, swap elements at index1 and index2\n        def swap(l\
    \ : List[Long], index1 : Int, index2 : Int) : List[Long] = {\n            val\
    \ temp = l(index1)\n            l.updated(index1, l(index2)).updated(index2, temp)\n\
    \        }\n        // Partition list from left to right\n        def partition(l\
    \ : List[Long], left : Int, right : Int) : List[Long] = {\n            if (left\
    \ >= right) {\n                l\n            } else {\n                val pivot\
    \ = l(left)\n                var i = left\n                var j = right\n   \
    \             while (i < j) {\n                    while (i < j && l(j) >= pivot)\
    \ {\n                        j -= 1\n                    }\n                 \
    \   while (i < j && l(i) <= pivot) {\n                        i += 1\n       \
    \             }\n                    if (i < j) {\n                        l =\
    \ swap(l, i, j)\n                    }\n                }\n                l =\
    \ swap(l, left, i)\n                partition(l, left, i - 1)\n              \
    \  partition(l, i + 1, right)\n            }\n        }\n        // Quick sort\n\
    \        def quickSort(l : List[Long]) : List[Long] = {\n            partition(l,\
    \ 0, l.length - 1)\n        }\n        // Remove duplicate elements\n        quickSort(l).groupBy(x\
    \ => x).map(_._1).toList"]
stop_tokens:
- "\n    }\n"
