name: HumanEval_100_make_a_pile
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, you have to make a pile of n levels of stones.\n\
  \    // The first level has n stones.\n    // The number of stones in the next level\
  \ is:\n    // - the next odd number if n is odd.\n    // - the next even number\
  \ if n is even.\n    // Return the number of stones in each level in a list, where\
  \ element at index\n    // i represents the number of stones in the level (i+1).\n\
  \    // Examples:\n    // >>> makeAPile((3l))\n    // (List[Long](3l.toLong, 5l.toLong,\
  \ 7l.toLong))\n    def makeAPile(n : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(makeAPile((3l)).equals((List[Long](3l.toLong,\
  \ 5l.toLong, 7l.toLong))));\n    assert(makeAPile((4l)).equals((List[Long](4l.toLong,\
  \ 6l.toLong, 8l.toLong, 10l.toLong))));\n    assert(makeAPile((5l)).equals((List[Long](5l.toLong,\
  \ 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));\n    assert(makeAPile((6l)).equals((List[Long](6l.toLong,\
  \ 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));\n    assert(makeAPile((8l)).equals((List[Long](8l.toLong,\
  \ 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        val res = ArrayBuffer[Long]()\n        var i = 1\n        while\
    \ (i <= n) {\n            val x = n + i\n            i += 1\n            res +=\
    \ x\n        }\n        res.toList", "        if (n == 1) {\n            List(1)\n\
    \        } else {\n            val x = makeAPile(n - 1)\n            val y = if\
    \ (n % 2 == 0) x.last + 2 else x.last + 1\n            x ++ List(y)\n        }",
  "        var ret : List[Long] = List(n)\n        var current = n\n        while\
    \ (current > 1) {\n            current = if (current % 2 == 0) current - 1 else\
    \ current - 2\n            ret = ret :+ current\n        }\n        ret", "  \
    \      if (n == 1) return List(1l)\n        val l = ListBuffer[Long]()\n     \
    \   var k = n\n        while (k > 0) {\n            l += k\n            k = if\
    \ (k % 2 == 0) k / 2 else (k + 1) / 2\n        }\n        l.toList", "       \
    \ var piles = List[Long]()\n        var num = n\n        while (num > 0) {\n \
    \           piles = piles :+ num\n            if (num % 2 == 0) num = num + 1\
    \ else num = num + 2\n        }\n        piles", "      var ans = new ListBuffer[Long]\n\
    \      var temp = n\n      while (temp != 0) {\n        ans += temp\n        if\
    \ (temp % 2 == 0) temp -= 1\n        else temp -= 2\n      }\n      ans.toList",
  "        var stones = new ListBuffer[Long]\n        var count = n\n        while\
    \ (count > 0) {\n            stones += count\n            if (count % 2 == 0)\
    \ {\n                count -= 1\n            } else {\n                count -=\
    \ 2\n            }\n        }\n        stones.toList", "        var piles = ListBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) piles += i\n        for (i <- n.toInt + 1 to\
    \ 2 * n.toInt) {\n            piles += (i + ((i + 1) % 2))\n        }\n      \
    \  return piles.toList", "        var l = ListBuffer[Long]()\n        l += n\n\
    \        while (n > 1) {\n            if (n % 2 == 0) n /= 2\n            else\
    \ n = n * 3 + 1\n            l += n\n        }\n        l.toList", "        var\
    \ levels = new ListBuffer[Long]()\n        var currentLevel = n\n        while\
    \ (currentLevel != 0) {\n            levels += currentLevel\n            if (currentLevel\
    \ % 2 == 0) currentLevel -= 1\n            else currentLevel -= 2\n        }\n\
    \        levels.toList", "        n match {\n            case n if n < 0 => null\n\
    \            case n if n == 0 => List()\n            case n if n > 0 => {\n  \
    \              if (n % 2 == 0) n :: makeAPile(n - 1)\n                else n ::\
    \ makeAPile(n - 2)\n            }\n        }", "        def helper(n : Long, res\
    \ : List[Long]) : List[Long] = {\n            if (n == 0) res\n            else\
    \ if (n % 2 == 0) helper(n - 1, (res :+ n))\n            else helper(n - 1, (res\
    \ :+ n))\n        }\n        helper(n, List())", "        def makeAPile_helper(n\
    \ : Long, result : List[Long]) : List[Long] = {\n            if (n == 0) result\n\
    \            else {\n                makeAPile_helper(n - 1, (n % 2) match {\n\
    \                    case 0 => result :+ (n + 1)\n                    case 1 =>\
    \ result :+ (n + 2)\n                })\n            }\n        }\n        makeAPile_helper(n,\
    \ List())", "        var l = ListBuffer(n)\n        val a = if (n % 2 == 0) n\
    \ + 1 else n + 2\n        val b = if (a % 2 == 0) a + 1 else a + 2\n        l\
    \ += a; l += b\n        l.toList", "        val result = new ArrayBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            result += if (i % 2 == 0) 2 *\
    \ i else 2 * i - 1\n        }\n        result.toList", "      var l = n\n    \
    \  var pile = new ListBuffer[Long]\n      while (l > 0) {\n        pile += l\n\
    \        l = if (l % 2 == 0) l + 1 else l + 2\n      }\n      pile.reverse.toList",
  "        var lst = List[Long]()\n        var i = n\n        while (i > 0) {\n  \
    \          lst = lst :+ i\n            i = if (i % 2 == 0) i / 2 else (i + 1)\
    \ / 2\n        }\n        lst.reverse", "        if (n == 1) List(1)\n       \
    \ else List(n) ++ makeAPile(if (n % 2 == 0) n - 1 else n + 1)", "        val (a,\
    \ b) = (n, if (n % 2 == 0) n + 1 else n + 2)\n        List(n, b, b + 2, b + 4,\
    \ b + 6, b + 8, b + 10, b + 12, b + 14, b + 16, b + 18, b + 20, b + 22, b + 24,\
    \ b + 26, b + 28, b + 30, b + 32, b + 34, b + 36, b + 38, b + 40, b + 42, b +\
    \ 44, b + 46, b + 48, b + 50, b + 52, b + 54, b + 56, b + 58, b + 60, b + 62,\
    \ b + 64, b + 66, b + 68, b + 70, b + 72, b + 74, b + 76, b + 78, b + 80, b +\
    \ 82, b + 84, b + 86, b + 88, b + 90, b + 92, b + 94, b + 96, b + 98, b + 100,\
    \ b + 102, b + 104, b + 106, b + 108, b + 110, b + 112, b + 114, b + 116, b +\
    \ 118, b + 120, b + 122, b + 124, b + 126, b + 128, b + 130, b + 132, b + 134,\
    \ b + 136, b + 138, b + 140, b + 142, b + 144, b + 146, b + 148, b + 150, b +\
    \ 152, b + 154, b + 156, b + 158, b + 160, b + 162, b + 164, b + 166, b + 168,\
    \ b + 170, b + 172, b + 174, b + 176, b + 178, b + 180, b + 182, b + 184, b +\
    \ 186, b + 188, b + 190, b + 192, b + 194, b + 196, b + 198, b + 200, b + 202,\
    \ b + 204, b + 206, b + 208, b + 210, b + 212, b + 214, b + 216, b + 218, b +\
    \ 220, b + 222, b + 224, b + 226, b + 228, b + 230, b + 232, b + 234, b + 236,\
    \ b + 238,", "        // Base case:\n        if (n == 1) List(1)\n        else\
    \ makeAPile(n - 1) :+ {\n            if (n % 2 == 0) n + 1\n            else n\
    \ + 2\n        }", "        val l = ListBuffer[Long]()\n        var c = n\n  \
    \      l += c\n        while (c > 1) {\n            c = if (c % 2 == 0) c / 2\
    \ - 1 else c / 2\n            l += c\n        }\n        l.toList", "        if\
    \ (n == 1) {\n            List(1)\n        } else {\n            val l = makeAPile(n\
    \ - 1)\n            l :+ (if (n % 2 == 0) l.last + 2 else l.last + 1)\n      \
    \  }", "        def makeAPile(n : Long, accum : List[Long]) : List[Long] = {\n\
    \            val nextLevel = if (n % 2 == 0) n + 2 else n + 1\n            if\
    \ (nextLevel > n) accum else makeAPile(nextLevel, accum :+ nextLevel)\n      \
    \  }\n        makeAPile(n, List(n))", "        var result = ListBuffer[Long]()\n\
    \        result += n\n        var i = n\n        while (i > 0) {\n           \
    \ i = if (i % 2 == 0) i + 1 else i + 2\n            result += i\n        }\n \
    \       result.dropRight(1).toList", "        val odd = (1l to n by 2l).toList\n\
    \        val even = (2l to n by 2l).toList\n        List(n) ::: (if (n % 2 ==\
    \ 0) odd else even)", "        var a = n\n        var l = new ListBuffer[Long]\n\
    \        while (a > 0) {\n            l += a\n            a = (a%2==0) match {\n\
    \                case true => a + 1\n                case false => a + 2\n   \
    \         }\n        }\n        l.toList", "        val lst = ArrayBuffer[Long]()\n\
    \        var j = n\n        for (i <- 1 to n.toInt) {\n            lst += j\n\
    \            if (j % 2 == 0) j += 1 else j += 2\n        }\n        lst.toList",
  "        var list = List[Long]()\n        var i = n\n        while (i >= 1) {\n\
    \            list = list :+ i\n            i = (if (i % 2 == 0) i + 1 else i +\
    \ 2)\n        }\n        list", "        def loop(n : Long, l : List[Long]) :\
    \ List[Long] = {\n            n match {\n                case n if n <= 0 => l\n\
    \                case n if n == 1 => n :: l\n                case n if n % 2 ==\
    \ 0 => loop(n / 2, n :: l)\n                case n if n % 2 == 1 => loop((n +\
    \ 1) / 2, n :: l)\n            }\n        }\n        loop(n, List()).reverse",
  "        val lst = ListBuffer[Long]()\n        var a = n\n        while (a > 0)\
    \ {\n            lst += a\n            if (a % 2 == 0) {\n                a =\
    \ a + 1\n            } else {\n                a = a + 2\n            }\n    \
    \    }\n        lst.toList", "        var list = List[Long]()\n        var m =\
    \ n\n        while (m > 0) {\n            list = list :+ m\n            if (m\
    \ % 2 == 0) m -= 1\n            else m -= 2\n        }\n        list.reverse",
  "        var i = 0l\n        var j = n\n        var res = ListBuffer[Long]()\n \
    \       while (i < n) {\n            res += j\n            if (j % 2 == 0) j +=\
    \ 1 else j += 2\n            i += 1\n        }\n        res.toList", "       \
    \ val result = Buffer[Long]()\n        for (i <- (1 to n.toInt).toList) {\n  \
    \          result += i + (n - i)\n        }\n        result.toList", "       \
    \ if (n == 1) return List(1l)\n        val stones = new ArrayBuffer[Long]\n  \
    \      stones += n\n        var m = n\n        while (m > 1) {\n            if\
    \ (m % 2 == 0) {\n                m = m / 2\n                stones += m\n   \
    \         } else {\n                m = (m - 1) / 2\n                stones +=\
    \ m\n            }\n        }\n        stones.toList", "        var result = List[Long]()\n\
    \        result = result :+ n\n        var num = 0l\n        if (n % 2 == 0) {\n\
    \            num = n + 2\n        } else {\n            num = n + 1\n        }\n\
    \        while (num > 0) {\n            result = result :+ num\n            if\
    \ (num % 2 == 0) {\n                num = num + 2\n            } else {\n    \
    \            num = num + 1\n            }\n        }\n        result.reverse",
  "        def nextNumber(x : Long) : Long = {\n            if (x % 2 == 0) x + 2\n\
    \            else x + 1\n        }\n        def pile(a : Long, n : Long) : List[Long]\
    \ = {\n            if (n == 0) Nil\n            else {\n                a :: pile(nextNumber(a),\
    \ n - 1)\n            }\n        }\n        pile(n, n)", "        var a = n\n\
    \        var l = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n   \
    \         l += a\n            if (a % 2 == 0) a += 1 else a += 2\n        }\n\
    \        l.toList", "        var arr = List[Long]()\n        var curr = n\n  \
    \      while (curr != 0) {\n            arr = curr :: arr\n            if (curr\
    \ % 2 == 0) curr -= 1\n            curr = curr / 2\n        }\n        arr", " \
    \     var temp = n\n      var results = List[Long]()\n      while (temp > 0) {\n\
    \        results = temp :: results\n        if (temp % 2 == 0) temp = temp / 2\
    \ - 1\n        else temp = temp / 2\n      }\n      results", "    \tvar result\
    \ = List[Long]()\n    \tresult = result :+ n\n    \tfor (i <- 1 to (n-1).toInt)\
    \ {\n    \t\tif (n % 2 == 0) {\n    \t\t\tresult = result :+ (n + (2 * i))\n \
    \   \t\t} else {\n    \t\t\tresult = result :+ (n + (2 * i) - 1)\n    \t\t}\n\
    \    \t}\n    \tresult", "        val list = new ListBuffer[Long]\n        var\
    \ current = n\n        while (current != 0) {\n            list += current\n \
    \           current = if (current % 2 == 0) current + 1 else current + 2\n   \
    \     }\n        list.toList", "        var stones = List[Long]()\n        for\
    \ (i <- 1 to n.toInt) {\n            stones = stones :+ (2 * i - 1).toLong\n \
    \       }\n        stones", "        val result = ListBuffer[Long]()\n       \
    \ var curLevel = n\n        while (curLevel > 0) {\n            result += curLevel\n\
    \            curLevel = if (curLevel % 2 == 0) curLevel / 2 else curLevel / 2\
    \ + 1\n        }\n        result.toList", "        def makeAPileHelper(n : Long,\
    \ l : List[Long]) : List[Long] = {\n            if (n == 0) l else makeAPileHelper(n\
    \ - 1, n :: l)\n        }\n        makeAPileHelper(n, List[Long]())", "      if\
    \ (n == 1) List(1)\n      else List(n) ++ makeAPile(if (n % 2 == 0) n + 1 else\
    \ n + 2)", "        var list = ListBuffer[Long]()\n        var i = n\n       \
    \ while (i > 0) {\n            list += i\n            if (i % 2 == 0) i = i +\
    \ 1 else i = i + 2\n        }\n        list.toList", "        def loop(n : Long,\
    \ i : Long, acc : List[Long]) : List[Long] = {\n            if (i == n) acc\n\
    \            else {\n                if (acc.last % 2 == 0) loop(n, i + 1, acc\
    \ :+ acc.last + 2)\n                else loop(n, i + 1, acc :+ acc.last + 1)\n\
    \            }\n        }\n        loop(n, 1, List(n))", "        val l = new\
    \ ListBuffer[Long]\n        l += n\n        var m = n\n        while (m > 1) {\n\
    \            m = if (m % 2 == 0) m - 1 else m - 2\n            l += m\n      \
    \  }\n        l.toList", "        var levels = new ListBuffer[Long]()\n      \
    \  var stone = n\n        for (x <- 1 to n.toInt) {\n            levels += stone\n\
    \            if (stone % 2 == 0) stone += 1 else stone += 2\n        }\n     \
    \   levels.toList", "        def f(x : Long) : Long = if (x % 2 == 0) x + 1 else\
    \ x + 2\n        def g(x : Long) : List[Long] = if (x == 0) Nil else List(x) :::\
    \ g(f(x))\n        g(n).reverse", "        var level = n\n        var counter\
    \ = 1\n        var pile = List[Long]()\n        while (level > 0) {\n        \
    \    pile = level :: pile\n            if (counter % 2 == 0) level = level + 2\n\
    \            else level = level + 1\n            counter = counter + 1\n     \
    \   }\n        return pile", "        val result = ArrayBuffer[Long]()\n     \
    \   var level = n\n        while (level > 0) {\n            result += level\n\
    \            level = if (level % 2 == 0) level + 1 else level + 2\n        }\n\
    \        result.toList", "        def makePileIter(n : Long, result : List[Long])\
    \ : List[Long] = {\n            if (n == 0) result\n            else if (n % 2\
    \ == 0) makePileIter(n - 1, (n - 1) :: result)\n            else makePileIter(n\
    \ - 1, n :: result)\n        }\n        makePileIter(n, List[Long]())", "    \
    \    var i = n\n        var result = ListBuffer[Long]()\n        while (i > 0)\
    \ {\n            result += i\n            if (i % 2 == 0) i += 1 else i += 2\n\
    \        }\n        result.toList", "        var level = List[Long](n)\n     \
    \   while (level.head < n) {\n            level = List[Long](level.head + 2l)\
    \ ++ level\n        }\n        return level", "        def makeAPileRec(n : Long,\
    \ curr : Long, acc : List[Long]) : List[Long] = curr match {\n            case\
    \ `n` => acc.reverse\n            case _ => makeAPileRec(n, curr + 2, curr ::\
    \ acc)\n        }\n        makeAPileRec(n, n, List())", "        val buf = new\
    \ ListBuffer[Long]\n        buf += n\n        var p = n\n        var i = 0\n \
    \       while (i < n - 1) {\n            if (p % 2 == 0) p += 1\n            else\
    \ p += 2\n            buf += p\n            i += 1\n        }\n        buf.toList",
  "        if (n <= 0) {\n            return List[Long]()\n        }\n        var\
    \ result = List[Long](n)\n        var nextNum = n\n        for (i <- 0 until n.toInt\
    \ - 1) {\n            if (nextNum % 2 == 0) {\n                nextNum += 1\n\
    \            } else {\n                nextNum += 2\n            }\n         \
    \   result = result :+ nextNum\n        }\n        return result", "        var\
    \ result = ListBuffer[Long]()\n        result += n\n        var m = n\n      \
    \  while (m > 0) {\n            if (m % 2 == 0) m = m + 1\n            else m\
    \ = m + 2\n            result += m\n        }\n        result.toList", "     \
    \   var result = new ListBuffer[Long]()\n        var current = n\n        while\
    \ (current > 0) {\n            result += current\n            current = (if (current\
    \ % 2 == 0) current + 1 else current + 2)\n        }\n        result.toList",
  "        require(n > 0)\n        var nextLevelStones = n\n        var levels = new\
    \ ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            levels += nextLevelStones\n\
    \            if (nextLevelStones % 2 == 0) nextLevelStones += 1\n            else\
    \ nextLevelStones += 2\n        }\n        levels.toList", "        var result\
    \ = List[Long]()\n        var x = n\n        while (x > 0) {\n            result\
    \ = x :: result\n            if (x % 2 == 0) {\n                x -= 1\n     \
    \       } else {\n                x -= 2\n            }\n        }\n        result",
  "        var result = List[Long]()\n        var currLevel = n\n        var totalCount\
    \ = n\n        while (totalCount != 0) {\n            result ::= currLevel\n \
    \           totalCount -= currLevel\n            currLevel += 2 * signum(currLevel)\n\
    \        }\n        result", "        def help(l : List[Long], n : Long) : List[Long]\
    \ = {\n            if (n == 0) {\n                l\n            } else {\n  \
    \              val x = l.last\n                if (x % 2 == 0) {\n           \
    \         help(l :+ (x + 1), n - 1)\n                } else {\n              \
    \      help(l :+ (x + 2), n - 1)\n                }\n            }\n        }\n\
    \        help(List(n), n - 1)", "        // Brute force:\n        // We have n\
    \ stones to distribute across n levels.\n        // We start with the first level\
    \ with n stones.\n        // If we distribute x stones to the second level and\
    \ n-x stones to the first level,\n        // then we can distribute x+1 stones\
    \ to the third level and n-x-1 stones to the first\n        // and second levels,\
    \ for x = 1..n.\n        // We want to keep distributing stones in this way until\
    \ we reach level n.\n        // The maximum number of stones that we can distribute\
    \ to the current level is\n        // i.e. the number of stones in the previous\
    \ level.\n        // We know the number of stones in the previous level is the\
    \ number of stones in the\n        // level before the previous level plus one\
    \ more.\n        // n stones to distribute\n        // n levels to distribute\n\
    \        // n numbers to find\n        val xs = new ListBuffer[Long]\n       \
    \ var s = n\n        while (xs.length < n) {\n            xs += s\n          \
    \  s = if (s % 2 == 0) s + 1 else s + 2\n        }\n        xs.toList", "    \
    \    def helper(levelNum : Long, array : List[Long]) : List[Long] = {\n      \
    \      if (levelNum == 0) array.reverse\n            else helper(levelNum - 1,\
    \ (array.head + (if (array.head % 2 == 0) 2 else 1)) :: array)\n        }\n  \
    \      helper(n, List(n))", "    \tvar l = ListBuffer[Long]()\n    \tfor (i <-\
    \ 1 to n.toInt) {\n    \t\tl += (n + i)\n    \t}\n    \tl.toList", "        var\
    \ ret : List[Long] = List()\n        var c : Long = n\n        while (c > 0) {\n\
    \            ret = c :: ret\n            if (c % 2 == 0) c = c / 2 - 1\n     \
    \       else c = c / 2\n        }\n        ret", "        var res = new ListBuffer[Long]()\n\
    \        var x = n\n        while (x != 0) {\n            res += x\n         \
    \   if (x % 2 == 0) x += 1 else x += 2\n        }\n        res.toList", "    \
    \    var l = List[Long]()\n        var i = 1l\n        while (i <= n) {\n    \
    \        if (i % 2 == 0) l = (l :+ ((i - 1) * 2))\n            else l = (l :+\
    \ ((i - 1) * 2 + 1))\n            i += 1\n        }\n        return l", "    \
    \    val pile = ListBuffer[Long]()\n        var i = n\n        while (i >= 1)\
    \ {\n            pile += i\n            i = if (i % 2 == 0) i - 1 else i - 2\n\
    \        }\n        pile.toList", "        var res = ListBuffer[Long]()\n    \
    \    var c = n\n        res += c\n        for (i <- 1 until n.toInt) {\n     \
    \       c = if (c % 2 == 0) c + 1 else c + 2\n            res += c\n        }\n\
    \        res.toList", "        var ans = ArrayBuffer[Long]()\n        for (i <-\
    \ 1 to n.toInt) {\n            ans += i * 2 - 1\n        }\n        return ans.toList",
  "    \tvar r = new ListBuffer[Long]\n    \tr += n\n    \tvar a = n\n    \twhile\
    \ (a > 0) {\n    \t\ta -= 1\n    \t\tif (a % 2 == 0) {\n    \t\t\tr += a + 2\n\
    \    \t\t\ta -= 2\n    \t\t} else {\n    \t\t\tr += a + 1\n    \t\t\ta -= 1\n\
    \    \t\t}\n    \t}\n    \tr.toList", "        n match {\n            case 1 =>\
    \ List(1)\n            case _ => {\n                var lst = List[Long]()\n \
    \               var current = n\n                while (current >= 1) {\n    \
    \                lst = lst :+ current\n                    current = if (current\
    \ % 2 == 0) current / 2 else (current + 1) / 2\n                }\n          \
    \      lst.reverse\n            }\n        }", "        val result = new ListBuffer[Long]()\n\
    \        var i = n\n        while (i > 0) {\n            result += i\n       \
    \     i = if (i % 2 == 0) i / 2 else i / 2 + 1\n        }\n        result.reverse.toList",
  "        if (n == 1) return List(1l)\n        val next = if (n % 2 == 0) n + 2 else\
    \ n + 1\n        return n :: makeAPile(next)", "        if (n <= 0) return Nil\n\
    \        val n1 = if (n % 2 == 0) n + 1 else n + 2\n        return n :: makeAPile(n1\
    \ / 2)", "        val (S : ListBuffer[Long]) = new ListBuffer[Long]\n        var\
    \ x : Long = n\n        while (x != 0) {\n            S += x\n            x =\
    \ if (x % 2 == 0) x - 1 else x - 2\n        }\n        S.toList", "        var\
    \ lst = new ListBuffer[Long]()\n        lst += n\n        var k = n\n        while\
    \ (k >= 3) {\n            k = if (k % 2 == 0) k + 1 else k + 2\n            lst\
    \ += k\n        }\n        lst.toList", "        var l = new ListBuffer[Long]\n\
    \        var s = n\n        while (s > 0) {\n            l += s\n            s\
    \ = if (s % 2 == 0) s + 1 else s + 2\n        }\n        l.toList", "        val\
    \ l = new ListBuffer[Long]\n        var a = n\n        while (a > 0) {\n     \
    \       l += a\n            a = if (a % 2 == 0) a + 1 else a + 2\n        }\n\
    \        l.toList", "        var result = List[Long]()\n        for (i <- 1l to\
    \ n) result = result :+ (2 * i - 1)\n        result", "        var nStones = n\n\
    \        var stones = List[Long]()\n        while (nStones > 0) {\n          \
    \  stones = nStones :: stones\n            if (nStones % 2 == 0) nStones -= 1\n\
    \            else nStones -= 2\n        }\n        stones", "        // list of\
    \ numbers to store the odd/even numbers.\n        var numberList = ListBuffer[Long]()\n\
    \        // value that stores the number that was generated.\n        var value\
    \ = 0l\n        // copy of n is created and the starting number of n is added\
    \ to the list.\n        var n_copy = n\n        numberList += n_copy\n       \
    \ // loop that generates the odd/even number.\n        while (n_copy > 0) {\n\
    \            // if n is odd then the next odd number is generated.\n         \
    \   if (n_copy % 2 == 1) {\n                value = n_copy + 2\n             \
    \   numberList += value\n                n_copy = value\n            }\n     \
    \       // if n is even then the next even number is generated.\n            else\
    \ {\n                value = n_copy + 1\n                numberList += value\n\
    \                n_copy = value\n            }\n        }\n        // numberList\
    \ is converted from ListBuffer to List and returned.\n        numberList.toList",
  '        List.range(0, n.toInt).map(x => (2 * x + n - 1)).toList', "        var\
    \ ret = new ListBuffer[Long]()\n        var current = n\n        while (current\
    \ > 0) {\n            ret += current\n            current = if (current % 2 ==\
    \ 0) current + 1 else current + 2\n        }\n        ret.reverse.toList", " \
    \       var out = List[Long]()\n        var curr = n\n        while (curr > 0)\
    \ {\n            out = out :+ curr\n            curr = curr % 2 match {\n    \
    \            case 0 => curr / 2\n                case 1 => curr * 3 + 1\n    \
    \        }\n        }\n        out.reverse", "        val m = new Array[Long](n.toInt)\n\
    \        m(0) = n\n        for (i <- 1 until n.toInt) m(i) = if (m(i - 1) % 2\
    \ == 0) m(i - 1) + 1 else m(i - 1) + 2\n        m.toList", "        val lst =\
    \ new ListBuffer[Long]()\n        var i = n\n        while (i > 0) {\n       \
    \     lst += i\n            if (i % 2 == 0) i -= 1\n            else i -= 2\n\
    \        }\n        lst.toList", "        var lst = new ArrayBuffer[Long]\n  \
    \      lst += n\n        var k = n\n        while (k > 1) {\n            if (k\
    \ % 2 == 0) k = k / 2 + 1\n            else k = k - 1\n            lst += k\n\
    \        }\n        lst.toList", "        def levelStones(n : Long) : Long = {\n\
    \            if (n == 1) 1\n            else 2 * levelStones(n - 1) + n\n    \
    \    }\n        (1l to n).map(levelStones(_)).toList", "        var level = n\n\
    \        var result = new ArrayBuffer[Long]()\n        while (level > 0) {\n \
    \           result += level\n            level = level - (if (level % 2 == 0)\
    \ 2 else 1)\n        }\n        result.toList", "        def f(result : List[Long],\
    \ n : Long) : List[Long] = {\n            if (n < 1) result\n            else\
    \ if (n == 1) result :+ 1\n            else if (n % 2 == 0) f(result :+ (n + 1),\
    \ n / 2)\n            else f(result :+ (n + 2), (n - 1) / 2)\n        }\n    \
    \    f(List(), n)", "      require(n > 0)\n      val a = ArrayBuffer[Long]()\n\
    \      var x = n\n      while (x > 0) {\n        a += x\n        x = if (x % 2\
    \ == 0) x / 2 else x / 2 + 1\n      }\n      a.toList", "        val stones =\
    \ ListBuffer[Long]()\n        var i = n\n        while (i > 0) {\n           \
    \ stones += i\n            i = if (i % 2 == 0) i - 1 else i - 2\n        }\n \
    \       stones.toList", "        var stack = new Stack[Long]()\n        stack.push(n)\n\
    \        while (stack.head != 1) {\n            val newN = if (stack.head % 2\
    \ == 0) stack.head + 1 else stack.head - 1\n            stack.push(newN)\n   \
    \     }\n        stack.toList", "        var l = new ListBuffer[Long]()\n    \
    \    var cur = n\n        while (cur > 0) {\n            l += cur\n          \
    \  if (cur % 2 == 0) cur -= 1\n            cur /= 2\n        }\n        l.toList",
  "        def help(n : Long, acc : List[Long]) : List[Long] = {\n            if (n\
    \ == 0) acc.reverse\n            else help(n - 1, (if (n % 2 == 0) n + 1 else\
    \ n - 1) :: acc)\n        }\n        help(n, List())", "        var stones = List[Long]()\n\
    \        var cur = n\n        while (cur > 0) {\n            stones = cur :: stones\n\
    \            if (cur % 2 == 0) cur = cur + 1 else cur = cur + 2\n        }\n \
    \       stones", "        val levels = ListBuffer[Long]()\n        var current\
    \ = n\n        levels += current\n        while (current > 1) {\n            if\
    \ (current % 2 == 0) {\n                current = current - 1\n            } else\
    \ {\n                current = current - 2\n            }\n            levels\
    \ += current\n        }\n        levels.toList", "        val l = List[Long]()\n\
    \        if (n == 1) List[Long](1l)\n        else if (n % 2 == 0) makeAPile(n\
    \ - 1) :+ (n + 1)\n        else makeAPile(n - 1) :+ (n + 2)", "        var pile\
    \ = List[Long]()\n        var cnt = n\n        while (cnt > 0) {\n           \
    \ pile = cnt :: pile\n            cnt = (cnt + (if (cnt % 2 == 0) 1 else -1))\
    \ / 2\n        }\n        pile", "        var array = new ArrayBuffer[Long]()\n\
    \        array += n\n        var j = n\n        while (j > 0) {\n            if\
    \ (j % 2 == 0) {\n                j += 1\n            } else {\n             \
    \   j += 2\n            }\n            array += j\n        }\n        array.toList",
  "        def makeAPileRecursive(n : Long, level : Int, current : Long, result :\
    \ List[Long]) : List[Long] = {\n            if (level == n) result\n         \
    \   else {\n                val levelNumber =\n                    if (current\
    \ % 2 == 0) current + 1\n                    else current + 2\n              \
    \  makeAPileRecursive(n, level + 1, levelNumber, levelNumber :: result)\n    \
    \        }\n        }\n        makeAPileRecursive(n, 0, n, List(n))", "      \
    \  if (n == 1) return List(1l)\n        var i = n\n        var p = List[Long]()\n\
    \        while (i > 0) {\n            p = i :: p\n            i = if (i % 2 ==\
    \ 0) i / 2 else i / 2 + 1\n        }\n        p", "        val lst = MutableList[Long]()\n\
    \        var x = n\n        for (i <- 1 to n.toInt) {\n            lst += x\n\
    \            if (x % 2 == 0) {\n                x += 1\n            } else {\n\
    \                x += 2\n            }\n        }\n        lst.toList", "    \
    \    var l = new ListBuffer[Long]\n        var c = n\n        l += c\n       \
    \ while (c > 1) {\n            c = if (c % 2 == 0) c + 1 else c + 2\n        \
    \    l += c\n        }\n        l.toList", "        def helper(s : List[Long],\
    \ maxLevel : Long) : List[Long] = {\n            if (maxLevel < 0) s\n       \
    \     else {\n                if (s.length % 2 == 0)\n                    helper(s\
    \ :+ (s.last + 2), maxLevel - 1)\n                else\n                    helper(s\
    \ :+ (s.last + 1), maxLevel - 1)\n            }\n        }\n        helper(List(n),\
    \ n)", "        def cal(n : Long, ps : List[Long]) : List[Long] = {\n        \
    \    if (n == 0) ps.reverse\n            else {\n                val newLevel\
    \ = if (n % 2 == 0) n + 1 else n + 2\n                cal(newLevel, n :: ps)\n\
    \            }\n        }\n        cal(n, Nil)", "        val result = ListBuffer[Long]()\n\
    \        var i = n\n        while (i >= 1) {\n            result += i\n      \
    \      i = if (i % 2 == 0) i / 2 else i / 2 + 1\n        }\n        result.toList",
  "        if (n == 1) return List(1)\n        val x = if (n % 2 == 0) n + 1 else\
    \ n + 2\n        x :: makeAPile(x)", "      def makeAPile(m : Long, list : List[Long])\
    \ : List[Long] = {\n        if (m == 0) list\n        else if (m % 2 == 0) makeAPile(m\
    \ - 1, list :+ (m + 1))\n        else makeAPile(m - 1, list :+ (m + 2))\n    \
    \  }\n      makeAPile(n, List[Long](n))", "        var num = n\n        var result\
    \ = new ListBuffer[Long]()\n        while (num > 0) {\n            result += num\n\
    \            if (num % 2 == 0) {\n                num = num - 1\n            }\
    \ else {\n                num = num - 2\n            }\n        }\n        result.toList",
  "      var count = n\n      var lst = new ListBuffer[Long]\n      while (count >\
    \ 0) {\n        lst += count\n        if (count % 2 == 0) {\n          count -=\
    \ 1\n        } else {\n          count -= 2\n        }\n      }\n      return\
    \ lst.toList", "        var level = n\n        var l = List[Long]()\n        while\
    \ (level > 0) {\n            l = level :: l\n            level = level % 2 match\
    \ {\n                case 0 => level / 2\n                case 1 => (level + 1)\
    \ / 2\n            }\n        }\n        l", "        val list = new LinkedList[Long]\n\
    \        var s = n\n        while (s > 0) {\n            list.addFirst(s)\n  \
    \          s = if (s % 2 == 0) s + 1 else s + 2\n        }\n        list.toList",
  "        var result = List[Long]()\n        var level = n\n        while (level\
    \ > 0) {\n            result = level :: result\n            level = next(level)\n\
    \        }\n        result", "        def count(n : Long, x : Long) : List[Long]\
    \ = {\n            if (n == 0) Nil\n            else if (n % 2 == 0) (n + x) ::\
    \ count(n - 1, x + 2)\n            else (n + x - 1) :: count(n - 1, x + 2)\n \
    \       }\n        count(n, n)", "      require(n > 0)\n      val result = new\
    \ ListBuffer[Long]\n      var current = n\n      result += current\n      while\
    \ (current > 1) {\n        current = if (current % 2 == 0) current / 2 else (current\
    \ + 1) / 2\n        result += current\n      }\n      result.toList", "      \
    \  val ret = new ListBuffer[Long]\n        var cur = n\n        for (i <- 0 until\
    \ n.toInt) {\n            ret += cur\n            if (cur % 2 == 0) cur += 1 else\
    \ cur += 2\n        }\n        ret.toList", "        var answer = List[Long]()\n\
    \        var i = n\n        while (i > 0) {\n            answer = answer.::(i)\n\
    \            if (i % 2 == 0) i = i + 1 else i = i + 2\n        }\n        answer.reverse",
  "        def helper(n : Long, acc : List[Long]) : List[Long] = {\n            if\
    \ (n <= 0) acc\n            else if (n % 2 == 0) helper(n / 2, acc :+ (n + 1))\n\
    \            else helper((n - 1) / 2, acc :+ (n + 1))\n        }\n        helper(n,\
    \ List(n))", "        var result = List[Long]()\n        var curr = n\n      \
    \  while (curr != 0) {\n            result = curr :: result\n            if (curr\
    \ % 2 == 0) curr += 1\n            else curr += 2\n        }\n        result",
  "      var result = ListBuffer(n)\n      for (i <- n until n + n) result += (if\
    \ (i % 2 == 0) i + 1 else i + 2)\n      result.toList", "        var l = List[Long]()\n\
    \        var k = n\n        while (k > 0) {\n            l = k :: l\n        \
    \    if (k % 2 == 0) k -= 1 else k -= 2\n        }\n        l", "        var stones\
    \ = n;\n        var ret : List[Long] = List();\n        while (stones > 0) {\n\
    \            ret = stones :: ret;\n            if (stones % 2 == 0) stones -=\
    \ 1;\n            stones /= 2;\n        }\n        return ret;", "        var\
    \ list : List[Long] = List()\n        var stones = n\n        while (stones >\
    \ 0) {\n            list = stones :: list\n            if (stones % 2 == 0) {\n\
    \                stones = stones / 2 - 1\n            } else {\n             \
    \   stones = stones / 2\n            }\n        }\n        list", "        if\
    \ (n == 1) return List(1l)\n        val next = if (n % 2 == 0) n + 2 else n +\
    \ 1\n        return n :: makeAPile(next)", "        def makeAPile(n : Long, count\
    \ : Int, acc : List[Long]) : List[Long] = {\n            if (count == 0) acc\n\
    \            else {\n                val next = if (n % 2 == 0) n + 2 else n +\
    \ 1\n                makeAPile(next, count - 1, n :: acc)\n            }\n   \
    \     }\n        makeAPile(n, n.toInt, Nil)", "        def makeAPile(n : Long,\
    \ result : List[Long]) : List[Long] = {\n            if (n == 0) result\n    \
    \        else if (n % 2 == 0) makeAPile(n - 1, result :+ (n + 1))\n          \
    \  else makeAPile(n - 1, result :+ (n + 2))\n        }\n        makeAPile(n, List(n))",
  "        require(n > 0)\n        var level = n\n        var result = new ArrayBuffer[Long]()\n\
    \        for (i <- 0 until n.toInt) {\n            result += level\n         \
    \   if (level % 2 == 0) level += 1 else level += 2\n        }\n        result.toList",
  "        if (n < 1) throw new IllegalArgumentException(\"n must be positive\")\n\
    \        var res = List[Long]()\n        var x = n\n        while (x > 0) {\n\
    \            res = x :: res\n            if (x % 2 == 0) x = x / 2 - 1\n     \
    \       else x = x / 2\n        }\n        res", "        def go(n : Long, acc\
    \ : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else\
    \ {\n                val next = n - 2\n                if (next == 0) n :: acc\n\
    \                else if (n % 2 == 0) go(next, n :: acc)\n                else\
    \ go(next, n + 1 :: acc)\n            }\n        }\n        go(n, Nil)", "   \
    \     def go(pile : List[Long], level : Long) : List[Long] = {\n            if\
    \ (level == n) pile\n            else {\n                if (level % 2 == 0) go(pile\
    \ :+ (level + 2), level + 1)\n                else go(pile :+ (level + 1), level\
    \ + 1)\n            }\n        }\n        go(List(n), 1)", "        def makeAPile(n\
    \ : Long, level : Long, acc : List[Long]) : List[Long] = {\n            if (n\
    \ <= 0) acc\n            else if (n % 2 == 0) makeAPile(n / 2 - 1, level + 1,\
    \ acc :+ level * 2)\n            else makeAPile(n / 2, level + 1, acc :+ level\
    \ * 2 + 1)\n        }\n        makeAPile(n, 1, List[Long]())", "        def loop(n\
    \ : Long, res : List[Long]) : List[Long] = n match {\n            case 0 => res\n\
    \            case _ => {\n                if (n % 2 == 0) loop(n - 1, n :: res)\n\
    \                else loop(n - 2, n :: res)\n            }\n        }\n      \
    \  loop(n, List())", "      if (n == 1) List(1)\n      else {\n        val nextNum\
    \ = if (n % 2 == 0) n + 2 else n + 1\n        val nextLevel = makeAPile(nextNum\
    \ / 2)\n        n :: nextLevel\n      }", "        def next(current : Long) :\
    \ Long = current match {\n            case e if e % 2 == 0 => e + 1\n        \
    \    case e if e % 2 == 1 => e + 2\n        }\n        List.range(1, n.toInt +\
    \ 1).foldLeft(List(n) : List[Long])((a, x) => next(a.head) :: a).reverse", " \
    \       var levels = List[Long]()\n        var stones = n\n        while (stones\
    \ > 0) {\n            levels ::= stones\n            stones = if (stones % 2 ==\
    \ 0) stones + 1 else stones + 2\n        }\n        levels.reverse", "       \
    \ val result = new ListBuffer[Long]()\n        var i = n\n        while (i > 0)\
    \ {\n            result += i\n            i = if (i % 2 == 0) i + 1 else i + 2\n\
    \        }\n        result.toList", "        var result = ListBuffer[Long]()\n\
    \        var currentLevel = n\n        while (currentLevel > 0) {\n          \
    \  result += currentLevel\n            if (currentLevel % 2 == 0) currentLevel\
    \ -= 1\n            else currentLevel -= 2\n        }\n        result.toList",
  "        var result = List[Long]()\n        var currentLevel = 1\n        var stonesLeft\
    \ = n\n        while (stonesLeft > 0) {\n            val stonesToTake = currentLevel\n\
    \            result = stonesToTake :: result\n            stonesLeft -= stonesToTake\n\
    \            currentLevel = if (currentLevel % 2 == 0) currentLevel + 1 else currentLevel\
    \ + 2\n        }\n        result", "        var a = List[Long]()\n        var\
    \ i = n\n        var j = 1\n        while (i > 0) {\n            a = a :+ (i +\
    \ j)\n            if (i % 2 == 0) j += 2 else j += 1\n            i -= 1\n   \
    \     }\n        a", "        def helper(n : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (n == 0) acc\n            else if (n % 2 == 0) helper(n\
    \ - 1, (n - 1) :: acc)\n            else helper(n - 1, n :: acc)\n        }\n\
    \        helper(n, List[Long]())", "        var stones : List[Long] = List(n)\n\
    \        var nextStone = n\n        while (nextStone != 1) {\n            nextStone\
    \ = nextStone - 1\n            nextStone = if (nextStone % 2 == 0) nextStone /\
    \ 2 else nextStone\n            stones = stones ++ List(nextStone)\n        }\n\
    \        stones", "        var x = n\n        var y = n + (if (n % 2 == 0) 2 else\
    \ 1)\n        List(x, y) ++ makeAPile(y)", "        var l = ListBuffer[Long]()\n\
    \        var m = n\n        while (m > 0) {\n            l += m\n            if\
    \ (m % 2 == 0) {\n                m -= 1\n            } else {\n             \
    \   m -= 2\n            }\n        }\n        l.toList", "        var result =\
    \ new ListBuffer[Long]\n        result += n\n        var next = n % 2 match {\n\
    \            case 0 => n + 2\n            case 1 => n + 1\n        }\n       \
    \ while (next > 1) {\n            result += next\n            next = next % 2\
    \ match {\n                case 0 => next + 2\n                case 1 => next\
    \ + 1\n            }\n        }\n        result.toList", "        val lst = new\
    \ ArrayBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            lst += if\
    \ (i == 1) n else if (i % 2 == 1) lst(i - 2) + 2 else lst(i - 2) + 1\n       \
    \ }\n        lst.toList", "        var current = n\n        var l = new ListBuffer[Long]\n\
    \        while (current > 0) {\n            l += current\n            if (current\
    \ % 2 == 0) current = current / 2 else current = current / 2 + 1\n        }\n\
    \        l.toList", "        var res = ListBuffer[Long]()\n        for (j <- 1\
    \ to n.toInt) {\n            if (j % 2 == 1) res += (2 * j - 1)\n            else\
    \ res += (2 * j)\n        }\n        res.toList", "        var list : List[Long]\
    \ = List[Long]()\n        list +:= n\n        var p : Long = n\n        while\
    \ (p > 2) {\n            p -= 2\n            list +:= p\n        }\n        list",
  "        val (cur, prev) = Tuple2(n, List[Long]())\n        val res = new ListBuffer[Long]\n\
    \        res += cur\n        while (cur > 1) {\n            if (cur % 2 == 0)\
    \ {\n                res += cur / 2\n                cur /= 2\n            } else\
    \ {\n                res += (cur + 1) / 2\n                cur = (cur + 1) / 2\n\
    \            }\n        }\n        return res.toList", "        var l = List[Long]()\n\
    \        var i = 1l\n        while (i <= n) {\n            if (i % 2 == 0) {\n\
    \                l ::= i + 1\n            } else {\n                l ::= i +\
    \ 2\n            }\n            i += 1\n        }\n        l.reverse", "     \
    \   if (n == 1) List(1)\n        else if (n%2 == 0) n::makeAPile(n+1)\n      \
    \  else n::makeAPile(n+2)", "      def helper(n : Long, acc : List[Long]) : List[Long]\
    \ = {\n        if (n == 0) acc\n        else {\n          if (n % 2 == 0) helper(n\
    \ - 1, acc :+ (n + 1))\n          else helper(n - 1, acc :+ (n + 2))\n       \
    \ }\n      }\n      helper(n, List(n))", "        def makeAPileHelper(n : Long,\
    \ acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n          \
    \  else if (n % 2 == 0) makeAPileHelper(n - 1, n :: acc)\n            else makeAPileHelper(n\
    \ - 2, n :: acc)\n        }\n        makeAPileHelper(n, List()).reverse", "  \
    \      val a = ArrayBuffer[Long]()\n        var b = n\n        while (b > 0) {\n\
    \            a += b\n            b = if (b % 2 == 0) b / 2 - 1 else b / 2\n  \
    \      }\n        a.toList", "        var a = ArrayBuffer[Long]()\n        var\
    \ level = n\n        a += level\n        while (level > 1) {\n            level\
    \ = if (level % 2 == 0) level - 1 else level - 2\n            a += level\n   \
    \     }\n        a.toList", "        var pile = new ListBuffer[Long]()\n     \
    \   pile += n\n        for (i <- 1l to n - 1l) {\n            if (n - i == 0)\
    \ {\n                pile += 1l\n            } else if (n - i % 2 == 0) {\n  \
    \              pile += n - i + 1l\n            } else {\n                pile\
    \ += n - i\n            }\n        }\n        pile.toList", "        (1 to n.toInt).foldLeft(List[Long]())\
    \ {\n            case (acc, i) =>\n                if (i == 1) (n :: acc).reverse\n\
    \                else if (i % 2 == 0) (acc.head + 2) :: acc\n                else\
    \ (acc.head + 1) :: acc\n        }", "        def next(n : Long) : Long = n %\
    \ 2 match {\n            case 0 => n + 1\n            case 1 => n + 2\n      \
    \  }\n        List.iterate(n, (n - 1).toInt)(next).toList", "        val (s, e)\
    \ = if (n % 2 == 0) (n + 1, n + 2) else (n, n + 1)\n        List(n, s, e)", " \
    \       def makeLevel(stones : Long, i : Int) : List[Long] = {\n            if\
    \ (i == n) List(stones)\n            else stones :: makeLevel(if (stones % 2 ==\
    \ 0) stones + 1 else stones + 2, i + 1)\n        }\n        makeLevel(n, 0)",
  "        def makeAPileIter(n : Long, acc : List[Long]) : List[Long] = {\n      \
    \      if (n == 0) acc.reverse\n            else if (n % 2 == 0) makeAPileIter(n\
    \ / 2, acc :+ (n + 1))\n            else makeAPileIter((n - 1) / 2, acc :+ (n\
    \ + 1))\n        }\n        makeAPileIter(n, List())", "      var list = List[Long]()\n\
    \      for (i <- 1 to n.toInt) {\n        list = list :+ n\n        if (n % 2\
    \ == 0) n += 1 else n += 2\n      }\n      list", "        var result = List[Long]()\n\
    \        var counter = n\n        while (counter > 0) {\n            result =\
    \ counter :: result\n            counter = if (counter % 2 == 0) counter + 1 else\
    \ counter + 2\n        }\n        result", "        var result = new ListBuffer[Long]()\n\
    \        var level = n\n        var stones = n\n        result += stones\n   \
    \     while (level > 1) {\n            level -= 1\n            stones = stones\
    \ + 2 * (if (level % 2 == 0) 1 else -1)\n            result += stones\n      \
    \  }\n        result.toList", "        var l = List[Long]()\n        var curr\
    \ = n\n        while (curr > 0) {\n            l = curr :: l\n            if (curr\
    \ % 2 == 0) {\n                curr = curr + 1\n            } else {\n       \
    \         curr = curr + 2\n            }\n        }\n        l", "        val\
    \ result = new ListBuffer[Long]\n        var x = n\n        while (x > 0) {\n\
    \            result += x\n            x = if (x % 2 == 0) x / 2 else x / 2 + 1\n\
    \        }\n        result.toList", "        // If n == 1, then we don't need\
    \ a pile, so just return it.\n        if (n == 1) return List(1l)\n        //\
    \ Create empty list\n        var list = List[Long]()\n        // Create a new\
    \ list with the number of stones in each level, starting from\n        // level\
    \ 2\n        for (i <- (n - 1) to 1 by -1) {\n            // Look at the first\
    \ number\n            if (i % 2 == 0) {\n                // Add the next even\
    \ number\n                list = (i + 2) :: list\n            } else {\n     \
    \           // Add the next odd number\n                list = (i + 1) :: list\n\
    \            }\n        }\n        // Add the original n\n        list = n ::\
    \ list\n        // Return the list\n        return list", "        var stones\
    \ = n\n        var numStones = new ListBuffer[Long]\n        for (i <- 0 until\
    \ n.toInt) {\n            numStones += stones\n            if (stones % 2 == 0)\
    \ stones += 1\n            else stones += 2\n        }\n        numStones.toList",
  "        val l = new ListBuffer[Long]\n        var number = n\n        while (number\
    \ > 0) {\n            if (number % 2 == 0) {\n                l += number\n  \
    \              number = number - 2\n            } else {\n                l +=\
    \ number\n                number = number - 1\n            }\n        }\n    \
    \    l.toList", "        def makeAPile(n : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (n == 0) acc\n            else makeAPile(n - 1, acc :+ n)\n\
    \        }\n        val stones = makeAPile(n, List[Long]())\n        val ps =\
    \ stones.map(x => if (x % 2 == 0) x + 1 else x - 1)\n        (stones, ps).zipped.map(_\
    \ + _)", "        val lst = ListBuffer[Long]()\n        var cur = n\n        while\
    \ (cur > 0) {\n            lst += cur\n            cur -= 2 * floor(log(cur) /\
    \ log(2)).toLong\n        }\n        return lst.toList", "        if (n == 1)\
    \ List(1)\n        else {\n            val newN =\n                if (n % 2 ==\
    \ 0)\n                    n + 1\n                else\n                    n +\
    \ 2\n            List(n) ++ makeAPile(newN)\n        }", "        if (n == 1)\
    \ {\n            List(1)\n        } else {\n            (n + (if (n % 2 == 0)\
    \ 2 else 1)) :: makeAPile(n-1)\n        }", "        // Fill up this function\
    \ body\n        // 'n' is a positive integer\n        val lst = new ListBuffer[Long]()\n\
    \        lst += n\n        var i = n + (if (n % 2 == 0) 2 else 1)\n        while\
    \ (i < (n * 2)) {\n            lst += i\n            i += (if (i % 2 == 0) 2 else\
    \ 1)\n        }\n        lst.toList", "        // n, n + 2, n + 4\n        //\
    \ n, n + 2, n + 4, n + 6\n        // n - 1, n + 1, n + 3, n + 5\n        // n\
    \ - 1, n + 1, n + 3, n + 5, n + 7\n        // n - 2, n, n + 2, n + 4, n + 6\n\
    \        // n - 2, n, n + 2, n + 4, n + 6, n + 8\n        // n - 3, n - 1, n +\
    \ 1, n + 3, n + 5, n + 7\n        val (odd, even) = if (n % 2 == 0) (false, true)\
    \ else (true, false)\n        val upper = n + if (even) (n + 1) else n\n     \
    \   val lower = if (even) n - n else n - n - 1\n        val middle = n\n     \
    \   val step = if (even) 2 else 1\n        var k = 0\n        var result = List[Long]()\n\
    \        while (lower + k <= upper) {\n            result = (middle + k) :: result\n\
    \            k += step\n        }\n        result", "      val r = ListBuffer[Long]()\n\
    \      var a = n\n      while (a > 0) {\n        r += a\n        a -= 1\n    \
    \    if (a > 0) {\n          r += a\n          a -= 1\n        }\n      }\n  \
    \    return r.toList", "        def iter(i : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (i == 0) acc\n            else {\n                val next\
    \ = if (i % 2 == 0) i + 1 else i + 2\n                iter(next, i :: acc)\n \
    \           }\n        }\n        iter(n, Nil)", "        def rec(level : Int,\
    \ n : Long) : List[Long] = n match {\n            case 0 => Nil\n            case\
    \ _ => n :: rec(level + 1, \n                if (level % 2 == 0) n + 2 else n\
    \ + 1)\n        }\n        rec(1, n)", "        if (n == 1) {\n            List(1)\n\
    \        } else {\n            val tail = makeAPile(n - 1)\n            (n + tail.last)\
    \ :: tail\n        }", "        var result = new ListBuffer[Long]()\n        var\
    \ stonesInLevel = n\n        result += stonesInLevel\n        while (stonesInLevel\
    \ > 1) {\n            if (stonesInLevel % 2 == 0) stonesInLevel -= 1\n       \
    \     else stonesInLevel -= 2\n            result += stonesInLevel\n        }\n\
    \        result.toList", "        val counts = ListBuffer[Long]()\n        var\
    \ count = n\n        while (count > 0) {\n            counts += count\n      \
    \      count = if (count % 2 == 0) count + 1 else count + 2\n        }\n     \
    \   counts.toList", "        var list = List[Long]()\n        var num = n\n  \
    \      while (num > 0) {\n            list = num :: list\n            if (num\
    \ % 2 == 0) num = num / 2 else num = num / 2 + 1\n        }\n        list", '        List.iterate(n,
    3)((a) => a + (if (a % 2 == 0) 2 else 1)).toList', "      if (n < 1) Nil\n   \
    \   else {\n        val lastLevel = if (n % 2 == 0) n + 1 else n\n        val\
    \ level = (n to lastLevel by 2).toList\n        level ::: makeAPile(level.size)\n\
    \      }", "        if (n == 1) return List(1l)\n        else if (n == 2) return\
    \ List(2l, 4l)\n        else {\n            var m = n\n            var l = List[Long]()\n\
    \            while (m != 0) {\n                l = l :+ m\n                if\
    \ (m % 2 == 0) m = m / 2 else m = (m - 1) / 2\n            }\n            l =\
    \ l.reverse\n            var i = 0\n            while (i < l.length - 1) {\n \
    \               l = l.updated(i + 1, l(i + 1) + 2 * l(i))\n                i +=\
    \ 1\n            }\n            l\n        }", "        var list = List[Long]()\n\
    \        for (i <- n to 1 by -1) {\n            if (i % 2 == 0) list = i + 1 ::\
    \ list\n            else list = i + 2 :: list\n        }\n        list", "   \
    \     var lst = List[Long]()\n        var sum = n\n        while (sum > 0) {\n\
    \            lst = lst :+ sum\n            sum = if (sum % 2 == 0) sum - 1 else\
    \ sum - 2\n        }\n        lst.reverse", "        if (n == 1) List(1)\n   \
    \     else (n :: makeAPile(if (n % 2 == 0) n + 1 else n + 2))", "      val firstOdd\
    \ = \n        if(n % 2 == 0) n + 1 \n        else n\n      val start = 2l * n\
    \ - firstOdd\n      def step(n : Long) : Long = {\n        if(n % 2 == 0) n +\
    \ 2\n        else n + 1\n      }\n      (start to firstOdd by 2).map(step(_)).toList",
  "        var i = 1l\n        var stones = n\n        var levels = ListBuffer[Long]()\n\
    \        while (stones > 0) {\n            if (stones > i) {\n               \
    \ levels += i\n                stones -= i\n            } else {\n           \
    \     levels += stones\n                stones = 0\n            }\n          \
    \  i += 2\n        }\n        levels.toList", "        def helper(n : Long, acc\
    \ : List[Long]) : List[Long] = n match {\n            case 1 => acc.reverse\n\
    \            case _ => if (n % 2 == 0) helper(n - 1, n + 1 :: acc) else helper(n\
    \ - 1, n :: acc)\n        }\n        helper(n, List())", "        def mk(m : Long,\
    \ s : List[Long]) : List[Long] = {\n            if (m == 0) s\n            else\
    \ {\n                if (m % 2 == 0) mk(m - 1, m :: s)\n                else mk(m\
    \ - 2, m :: s)\n            }\n        }\n        mk(n, List())", "        if\
    \ (n == 1) return List(1l)\n        var result = List(n)\n        var current\
    \ = n - 1\n        while (current > 0) {\n            if (current % 2 == 0) {\n\
    \                current -= 1\n            }\n            result = current ::\
    \ result\n            current -= 1\n        }\n        return result", "     \
    \   val result = ListBuffer[Long]()\n        for (i <- (1 to n.toInt).toList)\
    \ {\n            result += (n + (if (n % 2 == 0) i else -i))\n        }\n    \
    \    result.toList", "        var l = List[Long]()\n        var i = n\n      \
    \  while (i > 0) {\n            l = i :: l\n            if (i % 2 == 0) i = i\
    \ + 1 else i = i + 2\n        }\n        l"]
stop_tokens:
- "\n    }\n"
