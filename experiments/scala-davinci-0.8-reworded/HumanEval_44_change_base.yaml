name: HumanEval_44_change_base
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Change numerical base of input number x to base.\n    // return string representation\
  \ after the conversion.\n    // base numbers are less than 10.\n    // >>> changeBase((8l),\
  \ (3l))\n    // (\"22\")\n    // >>> changeBase((8l), (2l))\n    // (\"1000\")\n\
  \    // >>> changeBase((7l), (2l))\n    // (\"111\")\n    def changeBase(x : Long,\
  \ base : Long) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(changeBase((8l),\
  \ (3l)).equals((\"22\")));\n    assert(changeBase((9l), (3l)).equals((\"100\")));\n\
  \    assert(changeBase((234l), (2l)).equals((\"11101010\")));\n    assert(changeBase((16l),\
  \ (2l)).equals((\"10000\")));\n    assert(changeBase((8l), (2l)).equals((\"1000\"\
  )));\n    assert(changeBase((7l), (2l)).equals((\"111\")));\n    assert(changeBase((2l),\
  \ (3l)).equals((\"2\")));\n    assert(changeBase((3l), (4l)).equals((\"3\")));\n\
  \    assert(changeBase((4l), (5l)).equals((\"4\")));\n    assert(changeBase((5l),\
  \ (6l)).equals((\"5\")));\n    assert(changeBase((6l), (7l)).equals((\"6\")));\n\
  \    assert(changeBase((7l), (8l)).equals((\"7\")));\n    }\n\n}\n"
completions: ["        var s = \"\"\n        var t = x\n        while (t > 0) {\n\
    \            s = (t % base).toString + s\n            t /= base\n        }\n \
    \       return s", "        if (x == 0) \"0\"\n        else {\n            val\
    \ ans = new StringBuilder()\n            var rem = x\n            while (rem >\
    \ 0) {\n                ans.append(rem % base)\n                rem /= base\n\
    \            }\n            ans.reverse.toString\n        }", "      var q = x\n\
    \      var s = \"\"\n      while (q != 0) {\n        s = (q % base).toString +\
    \ s\n        q /= base\n      }\n      s", "      // divide x by base, and find\
    \ the remainder\n      var (result, r) = (ListBuffer[Long](), x % base)\n    \
    \  var m = x / base\n      // r is the last remainder\n      result += r\n   \
    \   while (m > 0) {\n        r = m % base\n        m = m / base\n        result\
    \ += r\n      }\n      result.toList.reverse.mkString", "        var x1 = x\n\
    \        var result = \"\"\n        while (x1 > 0) {\n            result = (x1\
    \ % base).toString + result\n            x1 /= base\n        }\n        return\
    \ result", "        def changeBase(x : Long, base : Long, result : String) : String\
    \ = {\n            if (x == 0) result else changeBase(x / base, base, (x % base).toString\
    \ + result)\n        }\n        changeBase(x, base, \"\")", "        if (x ==\
    \ 0) \"0\"\n        else {\n            val b = new StringBuilder\n          \
    \  var y = x\n            while (y > 0) {\n                b.append(y % base)\n\
    \                y /= base\n            }\n            b.reverse.toString\n  \
    \      }", "        def changeBaseRec(x : Long, base : Long, res : List[Long])\
    \ : List[Long] = {\n            if (x < base) return x :: res\n            val\
    \ rem = x % base\n            changeBaseRec(x / base, base, rem :: res)\n    \
    \    }\n        changeBaseRec(x, base, Nil).mkString(\"\")", "        // change\
    \ to new base\n        val xs = new ListBuffer[Char]\n        var t = x\n    \
    \    while (t > 0) {\n            t % base match {\n                case i if\
    \ i < 10 => xs += ('0' + i.toInt)\n                case _ => xs += ('A' + (t %\
    \ base - 10).toInt)\n            }\n            t /= base\n        }\n       \
    \ xs.reverse.mkString", "        def calculate(x : Long, base : Long, s : String)\
    \ : String = {\n            if (x == 0) s\n            else calculate(x / base,\
    \ base, (x % base).toString + s)\n        }\n        calculate(x, base, \"\")",
  "        val digits = ListBuffer[Int]()\n        var n = x\n        while (n > 0)\
    \ {\n            digits += (n % base).toInt\n            n /= base\n        }\n\
    \        return digits.toList.reverse.mkString", "        var y = x\n        var\
    \ s = new Stack[Int]\n        while (y > 0) {\n            s.push((y % base).toInt)\n\
    \            y /= base\n        }\n        var r = new StringBuilder\n       \
    \ while (!s.isEmpty) {\n            r.append(s.pop.toString)\n        }\n    \
    \    return r.toString", "        var y = x\n        var s = \"\"\n        while\
    \ (y > 0) {\n            s = (y % base).toString + s\n            y /= base\n\
    \        }\n        s", "        var num = x\n        var res = new StringBuilder\n\
    \        while (num > 0) {\n            res.append(num % base)\n            num\
    \ /= base\n        }\n        res.reverse.toString", "        var remainder =\
    \ x\n        var result = \"\"\n        while (remainder > 0) {\n            var\
    \ digit = remainder % base\n            result = digit.toString + result\n   \
    \         remainder = remainder / base\n        }\n        return result", " \
    \     //println(x + \" \" + base)\n      if (x == 0) return \"\"\n      else {\n\
    \        val remainder = x % base\n        val quotient = x / base\n        if\
    \ (remainder != 0) changeBase(quotient, base) + remainder.toString\n        else\
    \ changeBase(quotient, base) + \"0\"\n      }", "        if (x == 0) return \"\
    0\"\n        var numList = List[Int]()\n        var num = x\n        while (num\
    \ > 0) {\n            numList = (num % base).toInt :: numList\n            num\
    \ /= base\n        }\n        var result = \"\"\n        for (i <- numList) result\
    \ += i.toString\n        return result", "        def aux(x : Long, base : Long,\
    \ result : String) : String = {\n            if (x < base) return x.toString +\
    \ result\n            else {\n                aux(x / base, base, (x % base).toString\
    \ + result)\n            }\n        }\n        aux(x, base, \"\")", "        if\
    \ (x <= 0) {\n            return \"0\"\n        }\n        val result = new ListBuffer[Long]()\n\
    \        var y = x\n        while (y > 0) {\n            result.append(y % base)\n\
    \            y /= base\n        }\n        result.reverse.mkString", "       \
    \ var l = ListBuffer[Int]()\n        while (x > 0) {\n            l += ((x % base).toInt)\n\
    \            x /= base\n        }\n        l.reverse.mkString", "        var res\
    \ = new ListBuffer[Char]()\n        var temp = x\n        while (temp > 0) {\n\
    \            var digit = (temp % base).toInt\n            temp /= base\n     \
    \       res += ('0' + digit).toChar\n        }\n        res.reverse.mkString",
  "        def changeBase(x : Long, base : Long, ans : String) : String = {\n    \
    \        if (x == 0) ans\n            else changeBase(x / base, base, (x % base).toString\
    \ + ans)\n        }\n        changeBase(x, base, \"\")", "        var ret = new\
    \ StringBuilder\n        var k = x\n        while (k > 0) {\n            ret.append(k\
    \ % base)\n            k /= base\n        }\n        ret.reverse.toString", " \
    \       if (x < base) {\n            return x.toString\n        }\n        else\
    \ {\n            return changeBase(x / base, base) + (x % base).toString\n   \
    \     }", "        def changeBaseHelper(x : Long, base : Long, result : List[Long])\
    \ : List[Long] = {\n            if (x == 0) result\n            else changeBaseHelper(x\
    \ / base, base, x % base :: result)\n        }\n        changeBaseHelper(x, base,\
    \ Nil).mkString", "        def g(x : Long, base : Long, s : String) : String =\
    \ if (x == 0) s else g(x / base, base, x % base + s)\n        g(x, base, \"\")",
  "        var n = x\n        var digits = List[Int]()\n        while (n > 0) {\n\
    \            digits = (n % base).toInt :: digits\n            n /= base\n    \
    \    }\n        digits.mkString", "        val N = x.toString.size\n        var\
    \ A = Array.fill(N)(0)\n        var rem = x\n        for (i <- 0 until N) {\n\
    \            A(i) = (rem % base).toInt\n            rem /= base\n        }\n \
    \       A.mkString", "        var r = x\n        var result = new StringBuilder\n\
    \        while (r > 0) {\n            result += ('0' + (r % base).toInt)\n   \
    \         r /= base\n        }\n        result.reverse.toString", '        return
    x.toString(base.toInt)', "        def solve(x : Long, base : Long, ans : String)\
    \ : String = {\n            val r = x % base\n            val q = x / base\n \
    \           if (q == 0) ans + r\n            else solve(q, base, ans + r)\n  \
    \      }\n        solve(x, base, \"\")", "        val result = new StringBuilder()\n\
    \        var rem = x\n        while (rem > 0) {\n            result.append(rem\
    \ % base)\n            rem /= base\n        }\n        result.reverse.toString",
  "        var res = \"\"\n        var y = x\n        while (y > 0) {\n          \
    \  res = (y % base).toString() + res\n            y /= base\n        }\n     \
    \   return res", "        // decompose x into numbers in base\n        var result\
    \ = new StringBuilder\n        var t = x\n        while (t > 0) {\n          \
    \  result.append(t % base)\n            t /= base\n        }\n        result.reverse.toString",
  "        if (x == 0)\n            return \"0\"\n        var res = new StringBuffer\n\
    \        var t = x\n        while (t > 0) {\n            res.append(t % base)\n\
    \            t /= base\n        }\n        res.reverse.toString", "        def\
    \ rec(x : Long, base : Long, s : String) : String = {\n            if (x == 0)\
    \ s\n            else rec(x / base, base, (x % base).toString + s)\n        }\n\
    \        rec(x, base, \"\")", "        val r = new StringBuilder\n        var\
    \ d = x\n        var y = base\n        while (d > 0) {\n            r.append((d\
    \ % y).toString)\n            d /= y\n        }\n        r.reverse.toString",
  "        if (x < base) return x.toString()\n        changeBase(x / base, base) +\
    \ (x % base).toString()", "        var s = \"\"\n        var remainder = x\n \
    \       while (remainder != 0) {\n            val d = remainder % base\n     \
    \       remainder = remainder / base\n            s = d.toString + s\n       \
    \ }\n        s", "        var result = \"\"\n        var y = x\n        while\
    \ (y > 0) {\n            result = y % base + result\n            y /= base\n \
    \       }\n        return result", "        var x2 = x\n        var s = \"\"\n\
    \        while (x2 > 0) {\n            s = (x2 % base).toString() + s\n      \
    \      x2 /= base\n        }\n        return s", "        var ans = \"\";\n  \
    \      var xCopy = x;\n        var baseCopy = base;\n        while (xCopy > 0)\
    \ {\n            var r = xCopy % baseCopy;\n            xCopy /= baseCopy;\n \
    \           ans = r.toString() + ans;\n        }\n        return ans;", "    \
    \    var a = new StringBuilder()\n        var xx = x\n        var b = base\n \
    \       while (xx > 0) {\n            a += (xx % b).toString\n            xx /=\
    \ b\n        }\n        a.reverse.toString", "        if (x == 0) return \"0\"\
    \n        var a = x\n        var s = \"\"\n        while (a > 0) {\n         \
    \   s = (a % base).toString + s\n            a /= base\n        }\n        return\
    \ s", "        var valOfX = x\n        var result = List[Int]()\n        while\
    \ (valOfX > 0) {\n            result ::= (valOfX % base).toInt\n            valOfX\
    \ /= base\n        }\n        result.mkString", "        var result = \"\"\n \
    \       var x = x\n        while (x > 0) {\n            result = (x % base).toString\
    \ + result\n            x /= base\n        }\n        return result", "      \
    \  val result = new StringBuilder\n        var a = x\n        while (a > 0) {\n\
    \            result.append(a % base)\n            a /= base\n        }\n     \
    \   result.reverse.toString", "        def toString(x : Long, y : Long) : String\
    \ = {\n            if (x == 0) {\n                return \"\"\n            }\n\
    \            else {\n                val n = x % y\n                return toString(x\
    \ / y, y) + n.toString\n            }\n        }\n        return toString(x, base)",
  "        val result = new StringBuilder\n        var y = x\n        while (y !=\
    \ 0) {\n            result.append(y % base)\n            y /= base\n        }\n\
    \        result.reverse.toString", "        val result = new StringBuilder\n \
    \       var remaining = x\n        while (remaining > 0) {\n            val digit\
    \ = remaining % base\n            result.append(digit)\n            remaining\
    \ = remaining / base\n        }\n        result.reverse.toString", "        var\
    \ tmp = x\n        var ret = \"\"\n        while (tmp > 0) {\n            val\
    \ r = tmp % base\n            ret = r.toString + ret\n            tmp = tmp /\
    \ base\n        }\n        return ret", "        if (x < base)\n            return\
    \ x.toString\n        else {\n            val d = x / base\n            val r\
    \ = x % base\n            return changeBase(d, base) + r.toString\n        }",
  "        def changeBaseInternal(x : Long, base : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (x == 0) acc else changeBaseInternal(x / base, base, (x\
    \ % base) :: acc)\n        }\n        changeBaseInternal(x, base, Nil).reverse.mkString",
  "        var result = new StringBuffer\n        var x = x\n        while (x > 0)\
    \ {\n            result.append(x % base)\n            x /= base\n        }\n \
    \       result.reverse.toString", "        var n = x\n        var b = base\n \
    \       var ans = List[Char]()\n        while (n != 0) {\n            var d =\
    \ n % b\n            ans = d.toChar :: ans\n            n = n / b\n        }\n\
    \        ans.mkString", "        var m = new scala.collection.mutable.Stack[Long]\n\
    \        var n = x\n        while (n != 0) {\n            m.push(n % base)\n \
    \           n /= base\n        }\n        return m.map(_.toString).mkString",
  "        var ans = \"\"\n        var tmp = x\n        while (tmp != 0) {\n     \
    \       ans = ((tmp % base).toString) + ans\n            tmp /= base\n       \
    \ }\n        return ans", "        var ans = new StringBuilder\n        var remain\
    \ = x\n        while (remain > 0) {\n            ans += (remain % base).toString\n\
    \            remain /= base\n        }\n        ans.reverse.toString", "     \
    \   def recur(x : Long, base : Long, acc : List[Char]) : List[Char] = {\n    \
    \        if (x == 0) acc\n            else recur(x / base, base, acc :+ ((x %\
    \ base).toInt.toChar))\n        }\n        recur(x, base, Nil).reverse.mkString",
  "      var y = x\n      var result = new StringBuilder\n      while (y != 0) {\n\
    \        result += (y % base).toInt.toString\n        y /= base\n      }\n   \
    \   result.reverse.toString", "        if (x <= 0) \"\"\n        else changeBase(x\
    \ / base, base) + (x % base).toString", "        val DIGITS = (List(0l, 1l, 2l,\
    \ 3l, 4l, 5l, 6l, 7l, 8l, 9l, 10l, 11l, 12l, 13l, 14l, 15l, 16l, 17l, 18l, 19l,\
    \ 20l, 21l, 22l, 23l, 24l, 25l, 26l, 27l, 28l, 29l, 30l, 31l, 32l, 33l, 34l, 35l))\n\
    \        //var result = \"0\"\n        var result = new StringBuilder\n      \
    \  var num = x\n        while (num > 0) {\n            val mod = num % base\n\
    \            //result = DIGITS(mod.toInt) + result\n            result.append(DIGITS(mod.toInt))\n\
    \            num = num / base\n        }\n        result.toString.reverse", " \
    \       def loop(x : Long, acc : String) : String = {\n            if (x == 0)\
    \ return acc\n            else return loop(x / base, acc + (x % base).toString)\n\
    \        }\n        return loop(x, \"\")", "        var y = new StringBuffer(\"\
    \")\n        var curr = x\n        while (curr > 0) {\n            var r = curr\
    \ % base\n            curr = curr / base\n            y.append(r.toString)\n \
    \       }\n        return y.reverse.toString", "        var result = \"\"\n  \
    \      var x2 = x\n        while (x2 > 0) {\n            result = (x2 % base).toString\
    \ + result\n            x2 /= base\n        }\n        return result", "     \
    \   def changeBaseIter(x : Long, base : Long, result : String) : String = x match\
    \ {\n            case 0 => result\n            case _ => changeBaseIter(x / base,\
    \ base, (x % base).toString + result)\n        }\n        changeBaseIter(x, base,\
    \ \"\")", "        var temp = x\n        var result = \"\"\n        while (temp\
    \ != 0) {\n            result = (temp % base).toString + result\n            temp\
    \ /= base\n        }\n        return result", "        require(base < 10 && base\
    \ > 1 && x > 0)\n        var res = \"\"\n        var x_ = x\n        while (x_\
    \ != 0) {\n            res = (x_ % base).toString + res\n            x_ /= base\n\
    \        }\n        return res", "        var n = x\n        var s = \"\"\n  \
    \      while (n > 0) {\n            s = (n % base).toString + s\n            n\
    \ /= base\n        }\n        s", "      val n = x\n      if (n < base) return\
    \ n.toString\n      return changeBase(n / base, base) + (n % base).toString",
  "        def changeBaseR(x : Long, base : Long, acc : String) : String = {\n   \
    \         if (x == 0) acc else changeBaseR(x / base, base, (x % base).toString\
    \ + acc)\n        }\n        changeBaseR(x, base, \"\")", "        val rep = new\
    \ StringBuilder\n        var n = x\n        while (n > 0) {\n            rep.append((n\
    \ % base).toString)\n            n /= base\n        }\n        rep.reverse.toString",
  "        def recur(x : Long, acc : String) : String = {\n            if (x == 0)\
    \ return acc\n            else recur(x / base, x % base + acc)\n        }\n  \
    \      recur(x, \"\")", "        var result = \"\"\n        var tmp = x\n    \
    \    while (tmp > 0) {\n            var digit = tmp % base\n            tmp /=\
    \ base\n            result = result + digit.toString\n        }\n        return\
    \ result.reverse", "        if (x <= 0) \"0\"\n        else {\n            var\
    \ x0 = x\n            var x1 = List[Int]()\n            while (x0 > 0) {\n   \
    \             x1 ::= (x0 % base).toInt\n                x0 /= base\n         \
    \   }\n            x1.reverse.mkString\n        }", "        var s : String =\
    \ \"\";\n        var (y, k) = (x, 0l);\n        while (y > 0) {\n            s\
    \ = ((y % base) + k).toString + s;\n            y = y / base;\n            k =\
    \ 0;\n        }\n        return s;", "        val n = x.toString.length\n    \
    \    val dp = Array.fill[Long](n)(0)\n        val dpstr = Array.fill[String](n)(\"\
    \")\n        dp(0) = 1\n        dpstr(0) = \"1\"\n        val dp2 = Array.fill[Long](n)(0)\n\
    \        val dpstr2 = Array.fill[String](n)(\"\")\n        dp2(0) = base\n   \
    \     dpstr2(0) = base.toString\n        for (i <- 1 until n) {\n            dp(i)\
    \ = dp(i - 1) * base\n            dpstr(i) = dpstr(i - 1) + base.toString\n  \
    \          dp2(i) = dp2(i - 1) * base * base\n            dpstr2(i) = dpstr2(i\
    \ - 1) + base.toString + base.toString\n        }\n        //println(dp.mkString(\"\
    \ \"))\n        //println(dpstr.mkString(\" \"))\n        //println(dp2.mkString(\"\
    \ \"))\n        //println(dpstr2.mkString(\" \"))\n        var k = n - 1\n   \
    \     var result = \"\"\n        while (k >= 0) {\n            var j = k\n   \
    \         while (j >= 0 && dp(j) * 2 > x) j -= 1\n            //println(j)\n \
    \           if (j >= 0) {\n                val v = dp(j)\n                val\
    \ u = dpstr(j)\n                //println(v + \" \" + u)\n                x -=\
    \ v\n                result += u\n            }\n            j = k\n         \
    \   while (j >= 0 && dp2(j) * 2 > x) j -= 1\n            //println(j)\n      \
    \      if (j >= 0) {\n                val v = dp2(j)\n                val u =\
    \ dpstr2(j)\n                //println(v + \" \" + u)\n                x -= v\n\
    \                result += u\n            }\n            k -= 1\n        }\n \
    \       result", "        def loop(x : Long, base : Long, s : String) : String\
    \ = {\n            val (d, m) = (x / base, x % base)\n            if (d == 0)\
    \ {\n                m.toString + s\n            } else {\n                loop(d,\
    \ base, m.toString + s)\n            }\n        }\n        loop(x, base, \"\")",
  "        var temp:Long = x\n        var convertedList = ArrayBuffer[Long]()\n  \
    \      while (temp != 0) {\n            convertedList += temp % base\n       \
    \     temp /= base\n        }\n        return convertedList.reverse.mkString",
  "        var n = x\n        var result = \"\"\n        while (n > 0) {\n       \
    \     result = (n % base).toString + result\n            n /= base\n        }\n\
    \        return result", "        var s : String = \"\"\n        while (x != 0)\
    \ {\n            s = (x % base).toString + s\n            x /= base\n        }\n\
    \        return s", "        var s = \"\"\n        var y = x\n        while (y\
    \ > 0) {\n            s = s + (y % base).toString\n            y = y / base\n\
    \        }\n        if (s == \"\") s = \"0\"\n        return s.reverse", "   \
    \     def count(t : Long, m : Int) : Int = {\n            if (t == 0) m else count(t\
    \ / base, m + 1)\n        }\n        def loop(t : Long, m : Array[Char]) : Array[Char]\
    \ = {\n            if (t == 0) m else {\n                m(m.length - count(t,\
    \ 0)) = ((t % base) + '0').toChar\n                loop(t / base, m)\n       \
    \     }\n        }\n        if (x == 0) \"0\" else {\n            val str = new\
    \ Array[Char](count(x, 0))\n            loop(x, str).mkString\n        }", " \
    \       def iter(n : Long, acc : List[Long]) : List[Long] = {\n            if\
    \ (n == 0) acc else iter(n / base, (n % base) :: acc)\n        }\n        iter(x,\
    \ Nil).mkString(\"\")", "        def f(x : Long, s : String) : String = {\n  \
    \          if (x == 0) return s\n            f(x / base, s + (x % base).toString)\n\
    \        }\n        f(x, \"\")", "        var output = \"\"\n        var xC =\
    \ x\n        while (xC > 0) {\n            output = (xC % base).toString + output\n\
    \            xC /= base\n        }\n        output", "        if (x == 0) return\
    \ \"0\"\n        var x1 = x\n        var base1 = base\n        var ret = new ListBuffer[Long]()\n\
    \        while (x1 != 0) {\n            ret += (x1 % base1)\n            x1 /=\
    \ base1\n        }\n        return ret.toList.reverse.mkString(\"\")", "     \
    \   def ch(x : Long, b : Long) : String = {\n            val div = x / b\n   \
    \         val mod = x % b\n            (if (div == 0) \"\" else ch(div, b)) +\
    \ mod.toString\n        }\n        ch(x, base)", "        var ret = \"\"\n   \
    \     var xx = x\n        while (xx > 0) {\n            ret = (xx % base).toString\
    \ + ret\n            xx /= base\n        }\n        return ret", "        val\
    \ result = new StringBuilder\n        var t = x\n        while (t > 0) {\n   \
    \         val r = t % base\n            result.append(r)\n            t = t /\
    \ base\n        }\n        result.reverse.toString", "        var result = \"\"\
    \n        var n = x\n        while (n > 0) {\n            result = (n % base).toString\
    \ + result\n            n /= base\n        }\n        return result", "      \
    \  if (x < base)\n            x.toString\n        else\n            changeBase(x\
    \ / base, base) + (x % base).toString", "        var result = \"\";\n        var\
    \ num = x;\n        while (num != 0) {\n            result = (num % base).toString\
    \ + result;\n            num /= base;\n        }\n        return result;", " \
    \       var binary = \"\"\n        var X = x\n        while (X > 0) {\n      \
    \      binary = (X % base).toString + binary\n            X /= base\n        }\n\
    \        return binary", "        val result = new StringBuilder\n        var\
    \ sx = x\n        while (sx != 0) {\n            val d = sx % base\n         \
    \   result.append(d)\n            sx /= base\n        }\n        result.reverse.toString",
  "        var n = x\n        var result = \"\"\n        while (n != 0) {\n      \
    \      result = (n % base).toString + result\n            n /= base\n        }\n\
    \        return result", "        var result = \"\"\n        var n = x\n     \
    \   while (n > 0) {\n            result = (n % base).toString + result\n     \
    \       n /= base\n        }\n        return result", "        var ans = \"\"\n\
    \        var t = x\n        while (t > 0) {\n            ans = (t % base).toString\
    \ + ans\n            t /= base\n        }\n        ans", "        def changeBaseInner(x\
    \ : Long, base : Long, s : String) : String = {\n            if (x < base) {\n\
    \                (x.toString) + s\n            } else {\n                changeBaseInner(x\
    \ / base, base, (x % base).toString + s)\n            }\n        }\n        changeBaseInner(x,\
    \ base, \"\")", "        var input = x\n        var baseNums = new ListBuffer[Int]()\n\
    \        while (input > 0) {\n            baseNums += (input % base).toInt\n \
    \           input /= base\n        }\n        baseNums.reverse.mkString", "  \
    \      var res = new StringBuilder\n        var cur = x\n        while (cur >\
    \ 0) {\n            res += cur % base\n            cur /= base\n        }\n  \
    \      res.reverse.toString", "        def changeBaseRecursive(x : Long, base\
    \ : Long, acc : List[Long]) : List[Long] = {\n            if (x == 0) acc\n  \
    \          else changeBaseRecursive(x / base, base, (x % base) :: acc)\n     \
    \   }\n        val arr = changeBaseRecursive(x, base, Nil)\n        arr.map(x\
    \ => x.toString).foldLeft(\"\")((b, a) => a + b)", "        var xx = x\n     \
    \   var r = List[Char]()\n        while (xx > 0) {\n            r = ((xx % base).toString()(0))\
    \ :: r\n            xx /= base\n        }\n        return r.mkString(\"\")", " \
    \       var n = x\n        var digits = List[Long]()\n        while (n > 0) {\n\
    \            digits = digits.+:(n % base)\n            n /= base\n        }\n\
    \        var result = \"\"\n        for (d <- digits) {\n            result +=\
    \ d.toString\n        }\n        return result", "        def helper(x : Long,\
    \ base : Long, acc : String) : String = x match {\n            case 0 => acc\n\
    \            case _ => {\n                val (q, r) = (x / base, x % base)\n\
    \                helper(q, base, r.toString + acc)\n            }\n        }\n\
    \        helper(x, base, \"\")", '        x.toString(base.toInt)', "        var\
    \ s = x\n        var res = \"\"\n        while (s > 0) {\n            res = s\
    \ % base + res\n            s /= base\n        }\n        res", "        if (x\
    \ == 0) {\n            return \"0\"\n        }\n        var result = new StringBuffer()\n\
    \        var tmp = x\n        while (tmp > 0) {\n            result.append(tmp\
    \ % base)\n            tmp /= base\n        }\n        return result.reverse.toString",
  "        val ans = new StringBuilder\n        var cur = x\n        while (cur >\
    \ 0) {\n            ans.append((cur % base).toString)\n            cur /= base\n\
    \        }\n        ans.reverse.toString", "        var result = \"\"\n      \
    \  var t = x\n        while (t != 0) {\n            result = (t % base).toString()\
    \ + result\n            t /= base\n        }\n        return result", "      \
    \  var r = x\n        var s = \"\"\n        while (r != 0) {\n            s =\
    \ (r % base).toString + s\n            r /= base\n        }\n        s", "   \
    \     var y = x\n        var s = \"\"\n        while (y > 0) {\n            val\
    \ (d, r) = y /% base\n            s = r.toString + s\n            y = d\n    \
    \    }\n        s", "        var s : String = \"\"\n        var t : Long = x\n\
    \        while (t > 0) {\n            s = (t % base).toString + s\n          \
    \  t /= base\n        }\n        return s", "        def char(d : Long) : Char\
    \ = {\n            if (d >= 0 && d <= 9)\n                (d + '0').toChar\n \
    \           else\n                '\\0'\n        }\n        if (x == 0)\n    \
    \        return \"0\"\n        var r : StringBuilder = new StringBuilder\n   \
    \     var n : Long = x\n        while (n > 0) {\n            r.append(char(n %\
    \ base))\n            n /= base\n        }\n        r.reverse.toString", "   \
    \     val nums = ListBuffer[Long]()\n        var x2 = x\n        while (x2 > 0)\
    \ {\n            nums += (x2 % base)\n            x2 /= base\n        }\n    \
    \    nums.toList.reverse.mkString", "        var (result, current) = (\"\", x)\n\
    \        while (current != 0) {\n            val remainder = current % base\n\
    \            current = current / base\n            result = remainder.toString\
    \ + result\n        }\n        result", "      def construct(x : Long, base :\
    \ Long, acc : List[Char]) : List[Char] = {\n        if (x == 0) acc\n        else\
    \ construct(x / base, base, (('0' + (x % base)).toChar) :: acc)\n      }\n   \
    \   construct(x, base, Nil).mkString", "        var num = x\n        var result\
    \ = \"\"\n        while (num > 0) {\n            result = ((num % base).toString)\
    \ + result\n            num /= base\n        }\n        return result", "    \
    \    var x = x\n        var result = \"\"\n        while (x > 0) {\n         \
    \   val d = x % base\n            x = x / base\n            result = d.toString\
    \ + result\n        }\n        return result", "        var s = \"\"\n       \
    \ var y = x\n        while (y > 0) {\n            s = (y % base).toString + s\n\
    \            y /= base\n        }\n        return s", "        def recur(x : Long,\
    \ base : Long, res : String) : String = {\n            if (x == 0) res\n     \
    \       else recur(x / base, base, (x % base).toString + res)\n        }\n   \
    \     recur(x, base, \"\")", "        def loop(x : Long, base : Long, r : String)\
    \ : String = {\n            if (x == 0) r\n            else loop(x / base, base,\
    \ (x % base).toString + r)\n        }\n        loop(x, base, \"\")", "      var\
    \ x1 = x\n      var result = \"\"\n      while (x1 > 0) {\n        result = (x1\
    \ % base).toString + result\n        x1 /= base\n      }\n      return result",
  "        var s = new StringBuilder\n        var y = x\n        while (y != 0) {\n\
    \            s.append(y % base)\n            y /= base\n        }\n        s.reverse.toString",
  "        var res = \"\"\n        var a = x\n        while (a > 0) {\n          \
    \  res = (a % base).toString + res\n            a /= base\n        }\n       \
    \ res", "        def rec(x : Long, result : List[Long]) : List[Long] = x match\
    \ {\n            case 0 => result\n            case _ => rec(x / base, x % base\
    \ :: result)\n        }\n        rec(x, Nil).mkString", "        var remainders\
    \ = List[Long]()\n        var curr = x\n        while (curr > 0) {\n         \
    \   remainders ::= curr % base\n            curr /= base\n        }\n        return\
    \ remainders.reverse.map(_.toString).mkString", "        var result = new ListBuffer[Int]\n\
    \        var n = x\n        while (n > 0) {\n            result += (n % base).toInt\n\
    \            n /= base\n        }\n        result.toList.reverse.mkString", " \
    \       var str = \"\";\n        var xx = x;\n        while (xx > 0) {\n     \
    \       str = (xx % base).toString + str;\n            xx /= base;\n        }\n\
    \        return str;", "        if (x == 0) \"0\"\n        else {\n          \
    \  var ans = \"\"\n            var x1 = x\n            while (x1 > 0) {\n    \
    \            ans = (x1 % base).toString + ans\n                x1 /= base\n  \
    \          }\n            ans\n        }", "        def changeBaseRec(x : Long,\
    \ rst : String) : String = {\n            if (x == 0) rst\n            else changeBaseRec(x\
    \ / base, (x % base).toString + rst)\n        }\n        changeBaseRec(x, \"\"\
    )", "        def changeBaseHelper(x : Long, base : Long, result : String) : String\
    \ = {\n            if (x == 0) result else {\n                val n = x % base\n\
    \                changeBaseHelper(x / base, base, n.toString + result)\n     \
    \       }\n        }\n        changeBaseHelper(x, base, \"\")", "        var s\
    \ = new StringBuilder\n        var y = x\n        var b = base\n        while\
    \ (y > 0) {\n            s.append((y % b).toInt)\n            y /= b\n       \
    \ }\n        s.reverse.toString", "        def changeBaseHelper(x : Long, base\
    \ : Long, output : String) : String = {\n            if (x == 0) return output\n\
    \            else return changeBaseHelper(x / base, base, (x % base).toString\
    \ + output)\n        }\n        return changeBaseHelper(x, base, \"\")", "   \
    \     var value = x\n        var output = \"\"\n        while (value != 0) {\n\
    \            val mod = value % base\n            output = String.valueOf(mod)\
    \ + output\n            value = value / base\n        }\n        output", "  \
    \      var result = new StringBuilder\n        var current = x\n        while\
    \ (current > 0) {\n            var rem = current % base\n            result.append(rem)\n\
    \            current /= base\n        }\n        result.reverse.toString", " \
    \       def changeBaseIter(x : Long, base : Long, acc : String) : String = {\n\
    \            x match {\n                case x if (x == 0) => acc\n          \
    \      case _ => {\n                    val d = x % base\n                   \
    \ val n = x / base\n                    changeBaseIter(n, base, d.toString + acc)\n\
    \                }\n            }\n        }\n        changeBaseIter(x, base,\
    \ \"\")", "        if (x == 0) return \"0\"\n        var ret = \"\"\n        var\
    \ k = x\n        while (k > 0) {\n            ret = (k % base).toString + ret\n\
    \            k /= base\n        }\n        return ret", "        def changeBaseIter(x\
    \ : Long, base : Long, ans : String) : String = {\n            if (x == 0) ans\
    \ else changeBaseIter(x / base, base, (x % base).toString + ans)\n        }\n\
    \        changeBaseIter(x, base, \"\")", "        def str(b : Long, acc : String)\
    \ : String = {\n            if (b == 0) acc else str(b / base, (b % base).toString\
    \ + acc)\n        }\n        str(x, \"\")", "        var baseString = \"\"\n \
    \       var baseCnt = 0\n        var n = x\n        while (n > 0) {\n        \
    \    baseString = (n % base).toString + baseString\n            n /= base\n  \
    \          baseCnt += 1\n        }\n        return baseString", "        val r\
    \ = ArrayBuffer[Long]()\n        var n = x\n        while (n > 0) {\n        \
    \    r += (n % base)\n            n /= base\n        }\n        r.reverse.mkString",
  "        if (x == 0) return \"0\"\n        var cur = x\n        var result = List[Long]()\n\
    \        while (cur > 0) {\n            result = (cur % base) :: result\n    \
    \        cur /= base\n        }\n        return result.map(i => '0' + i).mkString",
  "        var result = \"\"\n        for (i <- 0 until x.toString.length) {\n   \
    \         result = (x % base).toString + result\n            x /= base\n     \
    \   }\n        return result", "        if (x < base) return (x.toString)\n  \
    \      var result = \"\"\n        var y = x\n        while (y > 0) {\n       \
    \     result = (y % base).toString + result\n            y /= base\n        }\n\
    \        return result", "        var l = ListBuffer[Long]()\n        var temp\
    \ = x\n        while (temp != 0) {\n            l += temp % base\n           \
    \ temp /= base\n        }\n        l.mkString(\"\")", "        var s = \"\"\n\
    \        var y = x\n        while (y > 0) {\n            s = (y % base).toString\
    \ + s\n            y /= base\n        }\n        return s", "        var s = \"\
    \";\n        var curr = x;\n        while (curr > 0) {\n            s = (curr\
    \ % base).toString + s;\n            curr /= base;\n        }\n        return\
    \ s;", "        if (x < base) {\n            (x.toString())\n        } else {\n\
    \            changeBase((x / base), base) + (x % base).toString()\n        }",
  "        if (x == 0) return \"0\"\n        val ret = new StringBuilder()\n     \
    \   var x2 = x\n        while (x2 > 0) {\n            ret.append(x2 % base)\n\
    \            x2 /= base\n        }\n        ret.reverse.toString", "        var\
    \ r = new StringBuilder\n        var x = x\n        while (x > 0) {\n        \
    \    r.append(x % base)\n            x /= base\n        }\n        r.reverse.toString",
  "        val result = new StringBuilder\n        var xx = x\n        while (xx >\
    \ 0) {\n            result.append(xx % base)\n            xx /= base\n       \
    \ }\n        result.reverse.toString", "      var x_ = x\n      var result = \"\
    \"\n      while (x_ > 0) {\n        result = (x_ % base).toString + result\n \
    \       x_ /= base\n      }\n      result", "        // >>> changeBase((8l), (3l))\n\
    \        // (\"22\")\n        // >>> changeBase((8l), (2l))\n        // (\"1000\"\
    )\n        // >>> changeBase((7l), (2l))\n        // (\"111\")\n        var xs\
    \ = List[Long]()\n        var r = x\n        while (r > 0) {\n            xs =\
    \ (r % base) :: xs\n            r = r / base\n        }\n        return xs.map(_.toString).reduce(_+_)",
  "      // x is a number in the default base.\n      // base is the target base.\n\
    \      val digits = new scala.collection.mutable.StringBuilder()\n      // current\
    \ x value, decreasing by the change of the base.\n      var currX = x\n      var\
    \ currBase = base\n      while (currX > 0) {\n        digits.append((currX % currBase).toString)\n\
    \        currX /= currBase\n      }\n      digits.reverse.toString", "       \
    \ if (x == 0) return \"0\"\n        var n = x\n        var r = \"\"\n        while\
    \ (n > 0) {\n            val k = n % base\n            r = k.toString + r\n  \
    \          n = n / base\n        }\n        return r", "        var a = x\n  \
    \      var answer = \"\"\n        while (a > 0) {\n            answer = (a % base).toString\
    \ + answer\n            a /= base\n        }\n        answer", "        var result\
    \ = List[Long]()\n        var xCopy = x\n        while (xCopy != 0) {\n      \
    \      result = (xCopy % base) :: result\n            xCopy /= base\n        }\n\
    \        result.reverse.mkString", "        if (x == 0)\n            return \"\
    0\"\n        var res = \"\"\n        var xx = x\n        while (xx > 0) {\n  \
    \          res = (xx % base).toString + res\n            xx /= base\n        }\n\
    \        return res", "        // 6666666\n        var remainder = x\n       \
    \ var result = \"\"\n        while (remainder > 0) {\n            val division\
    \ = remainder / base\n            val remainder = remainder % base\n         \
    \   result = remainder.toString + result\n            remainder = division\n \
    \       }\n        result", "        var r = x\n        var rb = new StringBuilder()\n\
    \        var i = 0\n        while (r != 0) {\n            rb.append(r % base)\n\
    \            r /= base\n            i += 1\n        }\n        rb.reverse.toString",
  "        var result = new StringBuilder();\n        var x_ = x;\n        while (x_\
    \ > 0) {\n            result.append(x_ % base);\n            x_ /= base;\n   \
    \     }\n        result.reverse.toString;", "        var a = x\n        var b\
    \ = base\n        val sb = new StringBuilder()\n        while (a > 0) {\n    \
    \        sb.append(a % b)\n            a /= b\n        }\n        sb.reverse.toString",
  "        var dec = x\n        var b = base\n        var res = \"\"\n        while\
    \ (dec != 0) {\n            res = (dec % b).toString + res\n            dec /=\
    \ b\n        }\n        return res", "        var x2 = x\n        var v = List[Long]()\n\
    \        while (x2 != 0) {\n            val r = x2 % base\n            v = r ::\
    \ v\n            x2 = x2 / base\n        }\n        v.mkString", "        var\
    \ s : String = \"\"\n        var t : Long = x\n        while (t > 0) {\n     \
    \       s = (t % base).toString + s\n            t /= base\n        }\n      \
    \  s", "        var s = \"\"\n        var n = x\n        while (n > 0) {\n   \
    \         s = (n % base).toString + s\n            n /= base\n        }\n    \
    \    return s", "        var xTemp = x\n        var remainder = xTemp % base\n\
    \        var quotient = xTemp / base\n        var result = remainder.toString\n\
    \        while (quotient > 0) {\n            xTemp = quotient\n            remainder\
    \ = xTemp % base\n            quotient = xTemp / base\n            result = remainder.toString\
    \ + result\n        }\n        return result", "        val stack = new Stack[Long]()\n\
    \        var y = x\n        while (y != 0) {\n            stack.push(y % base)\n\
    \            y /= base\n        }\n        stack.mkString", "        if (x ==\
    \ 0) return \"0\"\n        else {\n            var xc = x\n            var s =\
    \ \"\"\n            while (xc > 0) {\n                s = s + xc % base\n    \
    \            xc = xc / base\n            }\n            s.reverse\n        }",
  "        var a = new StringBuilder(\"\")\n        var b = x\n        while (b >\
    \ 0) {\n            a += (b % base).toString\n            b /= base\n        }\n\
    \        a.reverse.toString", "        val ans = new StringBuilder()\n       \
    \ var xx = x\n        while (xx > 0) {\n            ans.append(xx % base)\n  \
    \          xx /= base\n        }\n        ans.reverse.toString", "        if (x\
    \ == 0) {\n            \"0\"\n        } else {\n            val converted = new\
    \ scala.collection.mutable.Stack[Char]\n            var rest = x\n           \
    \ while (rest > 0) {\n                val quotient = rest / base\n           \
    \     val remainder = rest % base\n                converted.push(remainder.toString.head)\n\
    \                rest = quotient\n            }\n            converted.mkString\n\
    \        }", "        var a = List[Long]()\n        var b = x\n        while (b\
    \ > 0) {\n            a = (b % base) :: a\n            b /= base\n        }\n\
    \        if (a.length == 0) return \"0\"\n        a.reverse.mkString", "     \
    \   var rx = x\n        var result = \"\"\n        while (rx > 0) {\n        \
    \    result = (rx % base).toString + result\n            rx /= base\n        }\n\
    \        return result", "        var sum = 0l\n        var rev = new StringBuilder\n\
    \        while (x > 0) {\n            rev.append(x % base)\n            x /= base\n\
    \        }\n        return rev.reverse.toString", "        def changeBaseIter(x\
    \ : Long, acc : String) : String = x match {\n            case _ if (x == 0) =>\
    \ acc\n            case _ => changeBaseIter(x / base, (x % base).toString + acc)\n\
    \        }\n        if (x == 0) \"0\" else changeBaseIter(x, \"\")", "       \
    \ val stack = Stack[Char]()\n        var y = x\n        while (y != 0) {\n   \
    \         val z = y % base\n            stack.push(z.toString.head)\n        \
    \    y = y / base\n        }\n        stack.mkString", "        var result = \"\
    \"\n        var num = x\n        while (num != 0) {\n            result = num\
    \ % base + result\n            num /= base\n        }\n        return result",
  "        val builder = new StringBuilder()\n        var x = x\n        while (x\
    \ > 0) {\n            builder.append(x % base)\n            x /= base\n      \
    \  }\n        builder.reverse.toString", "        //val baseChar = \"0123456789abcdefghijklmnopqrstuvwxyz\"\
    \n        //val baseChar = \"0123456789\"\n        def changeBase(x : Long, base\
    \ : Long, result : String) : String = {\n            if (x == 0) result\n    \
    \        else {\n                //val digit = baseChar(math.abs(x % base).toInt)\n\
    \                val digit = (math.abs(x % base)).toString\n                changeBase(x\
    \ / base, base, digit + result)\n            }\n        }\n        changeBase(x,\
    \ base, \"\")", "        if (x == 0) {\n            return \"0\"\n        }\n\
    \        var result = \"\"\n        var rest = x\n        while (rest > 0) {\n\
    \            result = ((rest % base) + '0').toChar + result\n            rest\
    \ /= base\n        }\n        return result", "        def changeBaseRec(x : Long,\
    \ base : Long, s : String) : String = {\n            if (x == 0) return s\n  \
    \          val d = x % base\n            return changeBaseRec(x / base, base,\
    \ d.toString + s)\n        }\n        return changeBaseRec(x, base, \"\")", " \
    \       def changeBase(x : Long, base : Long, y : String) : String = {\n     \
    \       if (x == 0) y\n            else changeBase(x / base, base, (x % base).toString\
    \ + y)\n        }\n        changeBase(x, base, \"\")", "        var tmp = x\n\
    \        var ret = \"\"\n        while (tmp > 0) {\n            ret = (tmp % base).toString()\
    \ + ret\n            tmp /= base\n        }\n        ret", "        val result\
    \ = ArrayBuffer[Char]()\n        var x2 = x\n        while (x2 != 0) {\n     \
    \       val digit = (x2 % base).toString.charAt(0)\n            result.append(digit)\n\
    \            x2 /= base\n        }\n        result.reverse.mkString", '        x.toString(base.toInt)',
  "        def changeBaseRecursive(input : Long, base : Long, result : List[Long])\
    \ : List[Long] = {\n            if (input == 0) result\n            else changeBaseRecursive(input\
    \ / base, base, (input % base) :: result)\n        }\n        changeBaseRecursive(x,\
    \ base, Nil).reverse.mkString", "        var value = x\n        var lst = List[Long]()\n\
    \        var ans = \"\"\n        while (value != 0) {\n            lst = (value\
    \ % base) :: lst\n            value /= base\n        }\n        for (digit <-\
    \ lst) ans += digit.toString\n        ans", "        if (x == 0) return \"\"\n\
    \        changeBase(x / base, base) + x % base", "        def go(x : Long, result\
    \ : String) : String = {\n            if (x == 0) result\n            else go(x\
    \ / base, result + (x % base).toString)\n        }\n        go(x, \"\")", "  \
    \      var result = \"\"\n        var div = x\n        while (div > 0) {\n   \
    \         result = (div % base).toString + result\n            div /= base\n \
    \       }\n        return result", "        def changeBase_sub(x : Long, base\
    \ : Long, output : String) : String = {\n            if (x == 0) return output\n\
    \            changeBase_sub(x / base, base, (x % base).toString + output)\n  \
    \      }\n        changeBase_sub(x, base, \"\")", "      val z = ArrayBuffer[Long]()\n\
    \      var y = x\n      while (y > 0) {\n        z += (y % base)\n        y /=\
    \ base\n      }\n      z.reverse.mkString", "        var t = x\n        var result\
    \ = \"\"\n        while (t != 0) {\n            result = (t % base).toString +\
    \ result\n            t /= base\n        }\n        return result", "        def\
    \ loop(y : Long, ans : String) : String = {\n            if (y == 0) ans\n   \
    \         else loop(y / base, y % base + ans)\n        }\n        loop(x, \"\"\
    )", "        var result = new StringBuffer()\n        var temp = x\n        while\
    \ (temp > 0) {\n            var digit = temp % base\n            result.append(digit)\n\
    \            temp = temp / base\n        }\n        result.reverse.toString",
  "        def recur(x : Long, base : Long, result : List[Int]) : List[Int] = {\n\
    \            if (x == 0) result\n            else recur(x / base, base, (x % base).toInt\
    \ :: result)\n        }\n        recur(x, base, Nil).mkString", "        var c\
    \ = x\n        var r = \"\"\n        while (c > 0) {\n            r = ((c % base).toString)\
    \ + r\n            c = c / base\n        }\n        r", "        if (x == 0) return\
    \ \"0\"\n        else {\n            var result = new StringBuffer(\"\")\n   \
    \         var xcopy = x\n            while (xcopy > 0) {\n                result.append(xcopy\
    \ % base)\n                xcopy /= base\n            }\n            return result.reverse.toString\n\
    \        }"]
stop_tokens:
- "\n    }\n"
