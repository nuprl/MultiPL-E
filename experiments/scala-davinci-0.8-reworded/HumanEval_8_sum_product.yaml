name: HumanEval_8_sum_product
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // For a given list of integers, return a tuple consisting of a sum and a product\
  \ of all the integers in a list.\n    // Empty sum should be equal to 0 and empty\
  \ product should be equal to 1.\n    // >>> sumProduct((List[Long]()))\n    // ((0l,\
  \ 1l))\n    // >>> sumProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)))\n\
  \    // ((10l, 24l))\n    def sumProduct(numbers : List[Long]) : Tuple2[Long, Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sumProduct((List[Long]())).equals(((0l,\
  \ 1l))));\n    assert(sumProduct((List[Long](1l.toLong, 1l.toLong, 1l.toLong))).equals(((3l,\
  \ 1l))));\n    assert(sumProduct((List[Long](100l.toLong, 0l.toLong))).equals(((100l,\
  \ 0l))));\n    assert(sumProduct((List[Long](3l.toLong, 5l.toLong, 7l.toLong))).equals(((15l,\
  \ 105l))));\n    assert(sumProduct((List[Long](10l.toLong))).equals(((10l, 10l))));\n\
  \    }\n\n}\n"
completions: ["        var sum = 0l\n        var product = 1l\n        for (number\
    \ <- numbers) {\n            sum += number\n            product *= number\n  \
    \      }\n        return (sum, product)", "        val (sum, product) = numbers.foldLeft((0l,\
    \ 1l))((a, e) => (a._1 + e, a._2 * e))\n        (sum, product)", "        var\
    \ sum : Long = 0l\n        var product : Long = 1l\n        for (number <- numbers)\
    \ {\n            sum += number\n            product *= number\n        }\n   \
    \     return (sum, product)", "        var total = 0l\n        var product = 1l\n\
    \        for (number <- numbers) {\n            total += number\n            product\
    \ *= number\n        }\n        (total, product)", '        numbers.foldLeft((0l,
    1l))((s, n) => (s._1 + n, s._2 * n))', "        var sum : Long = 0\n        var\
    \ product : Long = 1\n        for (number <- numbers) {\n            sum += number\n\
    \            product *= number\n        }\n        return (sum, product)", '        (numbers.sum,
    numbers.product)', '        numbers.foldLeft((0l, 1l))((a, i) => (a._1 + i, a._2
    * i))', '        (numbers.sum, numbers.product)', "      // Fill up this function\
    \ body\n      // You can add another function as well, if required\n      if (numbers.length\
    \ == 0) return (0, 1)\n      var a = 0L\n      var b = 1L\n      for (i <- numbers)\
    \ {\n        a += i\n        b *= i\n      }\n      (a, b)", '        ???', '        Tuple2(numbers.sum,
    numbers.product)', '        numbers.foldLeft((0l, 1l))((sumProduct, number) =>
    (sumProduct._1 + number, sumProduct._2 * number))', '        return (numbers.sum,
    numbers.product)', "        var sum = 0L\n        var product = 1L\n        for\
    \ (number <- numbers) {\n            sum += number\n            product *= number\n\
    \        }\n        (sum, product)", "        if (numbers.length == 0)\n     \
    \       (0l, 1l)\n        else\n            (numbers.sum, numbers.product)", '        (sum(numbers),
    product(numbers))', "        if (numbers.isEmpty) (0, 1)\n        else (numbers.sum,\
    \ numbers.product)", "      // Fill up this function body\n      // You can add\
    \ another function as well, if required", "        val x = numbers.foldLeft((0l,\
    \ 1l))((sumProd, number) => (sumProd._1 + number, sumProd._2 * number))\n    \
    \    return x", "        val res = numbers.foldLeft((0l, 1l))((a, b) => (a._1\
    \ + b, a._2 * b))\n        return res", "        var sum = 0l\n        var product\
    \ = 1l\n        for (i <- numbers) {\n            sum += i\n            product\
    \ *= i\n        }\n        Tuple2(sum, product)", "    \tif (numbers.isEmpty)\
    \ (0, 1)\n    \telse (numbers.sum, numbers.product)", '        numbers.foldLeft((0l,
    1l))((acc, n) => (acc._1 + n, acc._2 * n))', "        var sum = 0l\n        var\
    \ product = 1l\n        numbers.foreach(x => {\n            sum += x\n       \
    \     product *= x\n        })\n        Tuple2(sum, product)", '        (numbers.sum,
    numbers.product)', "        var sum : Long = 0\n        var product : Long = 1\n\
    \        for (number <- numbers) {\n            sum += number\n            product\
    \ *= number\n        }\n        return (sum, product)", "      var sum = 0l\n\
    \      var product = 1l\n      for (i <- numbers) {\n        sum += i\n      \
    \  product *= i\n      }\n      return (sum, product)", '        numbers.foldLeft((0L,
    1L))((a, b) => (a._1 + b, a._2 * b))', "      numbers.foldLeft((0l, 1l)) {\n \
    \       case ((s, p), n) => (s + n, p * n)\n      }", '        return (numbers.foldLeft(0l)(_
    + _), numbers.foldLeft(1l)(_ * _))', '        // Implement this function', " \
    \       var s : Long = 0\n        var p : Long = 1\n        for (i <- numbers)\
    \ {\n            s += i\n            p *= i\n        }\n        (s, p)", '        numbers.foldLeft((0l,
    1l))((x, y) => (x._1 + y, x._2 * y))', "        var sum : Long = 0\n        var\
    \ product : Long = 1\n        for (n <- numbers) {\n            sum += n\n   \
    \         product *= n\n        }\n        return (sum, product)", "        //\
    \ (Sum, Product)\n        return ((0l, 1l))", "        var product : Long = 1\n\
    \        var sum : Long = 0\n        for (num <- numbers) {\n            product\
    \ *= num\n            sum += num\n        }\n        (sum, product)", '        (numbers.sum,
    numbers.product)', "        val sum = numbers.sum\n        val product = numbers.product\n\
    \        (sum, product)", '        Tuple2(numbers.sum, numbers.product)', "  \
    \      var sum : Long = 0\n        var product : Long = 1\n        for (n <- numbers)\
    \ {\n            sum += n\n            product *= n\n        }\n        (sum,\
    \ product)", "        val zero : Tuple2[Long, Long] = (0l, 1l)\n        def mySumProduct(numbers\
    \ : List[Long], acc : Tuple2[Long, Long]) : Tuple2[Long, Long] = {\n         \
    \   numbers match {\n                case List() => acc\n                case\
    \ x :: rest => mySumProduct(rest, (acc._1 + x, acc._2 * x))\n            }\n \
    \       }\n        mySumProduct(numbers, zero)", "        // Implement your code\
    \ here...\n        var sum = 0l\n        var prod = 1l\n        for (number <-\
    \ numbers) {\n            sum += number\n            prod *= number\n        }\n\
    \        (sum, prod)", "        val sum = numbers.foldLeft(0L)(_ + _)\n      \
    \  val product = numbers.foldLeft(1L)(_ * _)\n        (sum, product)", "     \
    \   if (numbers.isEmpty) {\n            return (0, 1)\n        }\n        (numbers.sum,\
    \ numbers.product)", "        val s = numbers.foldLeft(0l)(_ + _)\n        val\
    \ p = numbers.foldLeft(1l)(_ * _)\n        (s, p)", "        val s = numbers.foldLeft(0l)(_\
    \ + _)\n        val p = numbers.foldLeft(1l)(_ * _)\n        (s, p)", "      \
    \  // Fill up this function body\n        // You can add another function as well,\
    \ if required", "        if (numbers.isEmpty) {\n            return ((0l, 1l))\n\
    \        }\n        var sum : Long = 0l\n        var product : Long = 1l\n   \
    \     for (number <- numbers) {\n            sum += number\n            product\
    \ *= number\n        }\n        return ((sum, product))", '        numbers.foldLeft(Tuple2(0l,
    1l))((acc, i) => (acc._1 + i, acc._2 * i))', '        numbers.foldLeft((0l, 1l))((t
    : Tuple2[Long, Long], a : Long) => (t._1 + a, t._2 * a))', "        if (numbers.isEmpty)\n\
    \            (0, 1)\n        else {\n            val tail_product = numbers.tail.foldLeft(1l)((current,\
    \ next) => current * next)\n            val tail_sum = numbers.tail.foldLeft(0l)((current,\
    \ next) => current + next)\n            (tail_sum + numbers.head, tail_product\
    \ * numbers.head)\n        }", "      // Fill up this function body\n      //\
    \ You can add another function as well, if required\n      var sum = 0l\n    \
    \  var product = 1l\n      for (number <- numbers) {\n        sum += number\n\
    \        product *= number\n      }\n      (sum, product)", '        numbers.foldLeft((0l,
    1l))((acc, x) => (acc._1 + x, acc._2 * x))', '        (numbers.sum, numbers.product)',
  "        var list = numbers.sortWith(_ < _)\n        var sum = 0l\n        var product\
    \ = 1l\n        list.foreach(l => {\n            sum += l\n            product\
    \ *= l\n        })\n        return (sum, product)", "        val sum = numbers.foldLeft(0l)\
    \ ((acc, x) => acc + x)\n        val product = numbers.foldLeft(1l) ((acc, x)\
    \ => acc * x)\n        return (sum, product)", '      numbers.foldLeft((0l, 1l))((tup,
    number) => (tup._1 + number, tup._2 * number))', "        if (numbers.isEmpty)\
    \ return (0, 1)\n        val product = numbers.reduceLeft((x, y) => x * y)\n \
    \       val sum = numbers.reduceLeft((x, y) => x + y)\n        (sum, product)",
  "        val sum = numbers.foldLeft(0L)(_ + _)\n        val product = numbers.foldLeft(1L)(_\
    \ * _)\n        (sum, product)", '        (numbers.sum, numbers.product)', " \
    \       def sumProductAcc(acc : (Long, Long), n : Long) : (Long, Long) = {\n \
    \           ((acc._1 + n), (acc._2 * n))\n        }\n        numbers.foldLeft((0l,\
    \ 1l))(sumProductAcc)", '      return (numbers.sum, numbers.product)', "     \
    \   val sum = numbers.sum\n        val product = numbers.product\n        (sum,\
    \ product)", "        val m = numbers.foldLeft((0l, 1l))((x, y) => (x._1 + y,\
    \ x._2 * y))\n        m", '        numbers.foldLeft((0l, 1l))((x, y) => (x._1
    + y, x._2 * y))', "        val sum = numbers.foldLeft(0l)(_ + _)\n        val\
    \ product = numbers.foldLeft(1l)(_ * _)\n        (sum, product)", "        //\
    \ WRITE CODE HERE\n        (0, 1)", "        var sum = 0l\n        var product\
    \ = 1l\n        for (i <- numbers) {\n            sum += i\n            product\
    \ *= i\n        }\n        return (sum, product)", "        def f(n : Long, tuple\
    \ : Tuple2[Long, Long]) : Tuple2[Long, Long] = Tuple2(tuple._1 + n, tuple._2 *\
    \ n)\n        val result = numbers.foldLeft(Tuple2(0l, 1l))(f)\n        result",
  "        var s = 0l\n        var p = 1l\n        numbers.foreach(s += _)\n     \
    \   numbers.foreach(p *= _)\n        Tuple2(s, p)", "        val sum = numbers.sum\n\
    \        val product = numbers.product\n        (sum, product)", "        if (numbers.isEmpty)\
    \ {\n            (0l, 1l)\n        } else {\n            (numbers.sum, numbers.product)\n\
    \        }", "      var a = 0l\n      var b = 1l\n      for (x <- numbers) {\n\
    \        a += x\n        b *= x\n      }\n      return ((a, b))", "        val\
    \ s = numbers.sum\n        val p = numbers.product\n        (s, p)", "       \
    \ val s = numbers.sum\n        val p = numbers.product\n        (s, p)", "   \
    \     val sum = numbers.sum\n        val product = numbers.product\n        (sum,\
    \ product)", "        var sum = 0l\n        var product = 1l\n        numbers.foreach(number\
    \ => {\n            sum += number\n            product *= number\n        })\n\
    \        (sum, product)", "    \tval s = numbers.foldLeft(0l)(_ + _)\n    \tval\
    \ p = numbers.foldLeft(1l)(_ * _)\n    \t(s, p)", '        (numbers.sum, if (numbers.length
    == 0) 1 else numbers.reduce((x, y) => x * y))', "    \t(numbers.sum, numbers.product)",
  '        (numbers.sum, numbers.product)', "        def add(x : Long, y : Long) =\
    \ x + y\n        def mul(x : Long, y : Long) = x * y\n        (numbers.foldLeft(0l)(add),\
    \ numbers.foldLeft(1l)(mul))", "        if (numbers.isEmpty) return (0, 1)\n \
    \       else return (numbers.sum, numbers.product)", '        return (numbers.sum,
    numbers.product)', "        if (numbers.isEmpty) return ((0l, 1l))\n        var\
    \ sum = 0l\n        var product = 1l\n        for (number <- numbers) {\n    \
    \        sum += number\n            product *= number\n        }\n        return\
    \ ((sum, product))", '        (numbers.sum, numbers.product)', '        numbers.foldLeft((0l,
    1l))((x, y) => (x._1 + y, x._2 * y))', "        var sum = 0l\n        var product\
    \ = 1l\n        numbers.foreach(x => {\n            sum += x\n            product\
    \ *= x\n        })\n        (sum, product)", '        return Tuple2(numbers.sum,
    numbers.product)', "        var result : Tuple2[Long, Long] = (0l, 1l)\n     \
    \   for (n <- numbers) {\n            result = (result._1 + n, result._2 * n)\n\
    \        }\n        result", "        val zero = (0l, 1l)\n        numbers.foldLeft(zero)\
    \ {(t, e) => (t._1 + e, t._2 * e)}", "        val sum = numbers.foldLeft(0l)(_\
    \ + _)\n        val product = numbers.foldLeft(1l)(_ * _)\n        (sum, product)",
  "        val sum = if (numbers.length == 0) 0 else numbers.reduceLeft(_ + _)\n \
    \       val product = if (numbers.length == 0) 1 else numbers.reduceLeft(_ * _)\n\
    \        (sum, product)", "        var sum : Long = 0\n        var product : Long\
    \ = 1\n        for (number <- numbers) {\n            sum += number\n        \
    \    product *= number\n        }\n        return (sum, product)", "        //\
    \ Your code goes here.\n        var sum : Long = 0\n        var product : Long\
    \ = 1\n        for (number <- numbers) {\n            sum += number\n        \
    \    product *= number\n        }\n        Tuple2(sum, product)", "        val\
    \ s = numbers.sum\n        val p = numbers.product\n        (s, p)", "       \
    \ // TODO: implement me\n        null", "        val zero = Tuple2(0, 1)\n   \
    \     numbers.foldLeft(zero)((x, y) => Tuple2(x._1 + y, x._2 * y))", "       \
    \ val sum = numbers.foldLeft(0l)(_ + _)\n        val product = numbers.foldLeft(1l)(_\
    \ * _)\n        (sum, product)", "      var sum = 0l\n      var product = 1l\n\
    \      numbers.foreach(n => {sum += n; product *= n})\n      (sum, product)",
  "        var sum = 0l\n        var prod = 1l\n        numbers.foreach(n => {\n \
    \           sum += n\n            prod *= n\n        })\n        return (sum,\
    \ prod)", "        var sum : Long = 0\n        var product : Long = 1\n      \
    \  for (number <- numbers) {\n            sum += number\n            product *=\
    \ number\n        }\n        (sum, product)", "        var totalSum = 0l\n   \
    \     var totalProduct = 1l\n        for (number <- numbers) {\n            totalSum\
    \ += number\n            totalProduct *= number\n        }\n        return (totalSum,\
    \ totalProduct)", "        if (numbers.isEmpty) return (0, 1)\n        var sum\
    \ = 0l\n        var product = 1l\n        for (number <- numbers) {\n        \
    \    sum += number\n            product *= number\n        }\n        (sum, product)",
  "        var s : Long = 0\n        var p : Long = 1\n        for (n <- numbers)\
    \ {\n            s += n\n            p *= n\n        }\n        return (s, p)",
  "        val acc = new Tuple2[Long, Long](0l, 1l)\n        numbers.foldLeft(acc)((acc,\
    \ num) => (acc._1 + num, acc._2 * num))", "        val sum = numbers.sum\n   \
    \     val product = numbers.foldLeft(1l)(_ * _)\n        (sum, product)", '        (numbers.foldLeft(0l){_
    + _}, numbers.foldLeft(1l){_ * _})', "        // replace this code with your own\
    \ one\n        (numbers.sum, numbers.product)", "        var sum = 0l\n      \
    \  var product = 1l\n        for (i <- numbers) {\n            sum += i\n    \
    \        product *= i\n        }\n        Tuple2(sum, product)", "        val\
    \ (sum, prod) = numbers.foldLeft(0L, 1L)((acc, item) => (acc._1 + item, acc._2\
    \ * item))\n        (sum, prod)", "        var sum: Long = 0\n        var product:\
    \ Long = 1\n        for (number <- numbers) {\n            sum += number\n   \
    \         product *= number\n        }\n        (sum, product)", '        (numbers.sum,
    numbers.product)', "        var sum : Long = 0\n        var product : Long = 1\n\
    \        for (number <- numbers) {\n            sum += number\n            product\
    \ *= number\n        }\n        return (sum, product)", '        return (numbers.sum,
    numbers.product)', "        def product(acc : Long, numbers : List[Long]) : Long\
    \ = {\n            if (numbers.isEmpty) acc\n            else product(acc * numbers.head,\
    \ numbers.tail)\n        }\n        def sum(acc : Long, numbers : List[Long])\
    \ : Long = {\n            if (numbers.isEmpty) acc\n            else sum(acc +\
    \ numbers.head, numbers.tail)\n        }\n        (sum(0, numbers), product(1,\
    \ numbers))", "        val (sum, prod) = numbers.foldLeft((0l, 1l))((acc, n) =>\
    \ (acc._1 + n, acc._2 * n))\n        (sum, prod)", '        (numbers.sum, numbers.product)',
  "        var sum : Long = 0\n        var product : Long = 1\n        for (i <- numbers)\
    \ {\n            sum += i\n            product *= i\n        }\n        return\
    \ (sum, product)", "    \tvar tuple : Tuple2[Long, Long] = Tuple2(0l, 1l)\n  \
    \  \tif (numbers.length == 0) return tuple\n    \tvar product : Long = 1l\n  \
    \  \tvar sum : Long = 0l\n    \tfor (number <- numbers) {\n    \t\tproduct *=\
    \ number\n    \t\tsum += number\n    \t}\n    \treturn Tuple2(sum, product)",
  "        def sumProduct(numbers : List[Long], acc : Tuple2[Long, Long]) : Tuple2[Long,\
    \ Long] = {\n            if (numbers.length == 0) acc\n            else {\n  \
    \              var new_acc = (acc._1 + numbers.head, acc._2 * numbers.head)\n\
    \                sumProduct(numbers.tail, new_acc)\n            }\n        }\n\
    \        sumProduct(numbers, (0l, 1l))", "        var product : Long = 1\n   \
    \     var sum : Long = 0\n        for (number <- numbers) {\n            product\
    \ *= number\n            sum += number\n        }\n        (sum, product)", '        return
    ((sum(numbers), product(numbers)))', "    \tvar sum = 0l\n    \tvar product =\
    \ 1l\n    \tfor (number <- numbers) {\n    \t\tsum += number\n    \t\tproduct\
    \ *= number\n    \t}\n    \t(sum, product)", '      numbers.foldLeft(0l, 1l)((acc,
    x) => (acc._1 + x, acc._2 * x))', "        def f(numbers : List[Long], accSum\
    \ : Long, accProduct : Long) : Tuple2[Long, Long] = {\n            if (numbers.length\
    \ == 0) return (accSum, accProduct)\n            else f(numbers.tail, accSum +\
    \ numbers.head, accProduct * numbers.head)\n        }\n        f(numbers, 0, 1)",
  "        var sum = 0l\n        var product = 1l\n        for (number <- numbers)\
    \ {\n            sum += number\n            product *= number\n        }\n   \
    \     (sum, product)", "        numbers.foldLeft(0l, 1l) {\n            case ((sum,\
    \ product), number) => (sum + number, product * number)\n        }", "       \
    \ var sum = 0l\n        var product = 1l\n        for (number <- numbers) {\n\
    \            sum += number\n            product *= number\n        }\n       \
    \ return (sum, product)", '        (numbers.sum, numbers.product)', "        //\
    \ TODO\n        (0, 0)", '        (numbers.sum, numbers.product)', '        (numbers.sum,
    numbers.product)', "        val (sum, prod) = numbers.foldLeft((0l, 1l))((n, m)\
    \ => (n._1 + m, n._2 * m))\n        (sum, prod)", "        var sum: Long = 0\n\
    \        var product: Long = 1\n        for (number <- numbers) {\n          \
    \  sum += number\n            product *= number\n        }\n        return (sum,\
    \ product)", "    \t(numbers.sum, numbers.product)", '        return (numbers.sum,
    numbers.product)', "        val sum = numbers.foldLeft(0l)(_ + _)\n        val\
    \ product = numbers.foldLeft(1l)(_ * _)\n        Tuple2(sum, product)", "    \
    \    val sum = numbers.foldLeft(0l)(_ + _)\n        val product = numbers.foldLeft(1l)(_\
    \ * _)\n        (sum, product)", "        if (numbers.isEmpty) (0l, 1l)\n    \
    \    else numbers.foldLeft((0l, 1l))((a, b) => (a._1 + b, a._2 * b))", "     \
    \   var s = 0l\n        var p = 1l\n        for (n <- numbers) {\n           \
    \ s += n\n            p *= n\n        }\n        (s, p)", '        return (numbers.sum,
    numbers.product)', '        (numbers.sum, numbers.product)', '      return (numbers.sum,
    numbers.product)', '        Tuple2((numbers.sum, numbers.product))', '        return
    ((numbers.sum, numbers.product))', "        val zeros = (0L, 1L)\n        val\
    \ reductions = numbers.foldLeft(zeros)((res, a) => (res._1 + a, res._2 * a))\n\
    \        return reductions", '        (numbers.sum, if (numbers.length == 0) 1l
    else numbers.product)', "        var sum = 0l\n        var product = 1l\n    \
    \    for (number <- numbers) {\n            sum += number\n            product\
    \ *= number\n        }\n        return (sum, product)", "        // put your code\
    \ here\n        (0, 1)", "        var sum : Long = 0l\n        var product : Long\
    \ = 1l\n        for (number <- numbers) {\n            sum += number\n       \
    \     product *= number\n        }\n        (sum, product)", "        var sum\
    \ = 0l\n        var product = 1l\n        for (n <- numbers) {\n            sum\
    \ += n\n            product *= n\n        }\n        return (sum, product)", '        (numbers.sum,
    numbers.product)', "        // >>> numbers.foldLeft((0, 1))((x, y) => (x._1 +\
    \ y, x._2 * y))\n        // ((10, 24))\n        numbers.foldLeft((0, 1))((x, y)\
    \ => (x._1 + y, x._2 * y))", "        def accumulate(accumulator : (Long, Long),\
    \ next : Long) : (Long, Long) = (accumulator._1 + next, accumulator._2 * next)\n\
    \        return numbers.foldLeft((0l, 1l))(accumulate)", "        var sum = 0l\n\
    \        var product = 1l\n        numbers.foreach {number => {\n            sum\
    \ += number\n            product *= number\n        }}\n        (sum, product)",
  '        return (numbers.sum, numbers.product)', '        (numbers.sum, numbers.product)',
  '        (numbers.sum, numbers.product)', "      val t = numbers.foldLeft((0l, 1l))((a,\
    \ b) => (a._1 + b, a._2 * b))\n      t", "        val result = (0l, 1l)\n    \
    \    if (numbers.isEmpty) return result\n        numbers.reduce((t1, t2) => (t1._1\
    \ + t2._1, t1._2 * t2._2))", "        var s : Long = 0\n        var p : Long =\
    \ 1\n        numbers.foreach {\n            n => {\n                s += n\n \
    \               p *= n\n            }\n        }\n        (s, p)", '        numbers.foldLeft((0l,
    1l))((p, n) => (p._1 + n, p._2 * n))', "        var sum = 0l\n        var product\
    \ = 1l\n        numbers.foreach(n => {sum += n; product *= n})\n        (sum,\
    \ product)", "        var sum = 0l\n        var product = 1l\n        for (number\
    \ <- numbers) {\n            sum += number\n            product *= number\n  \
    \      }\n        Tuple2(sum, product)", '        return (numbers.sum, numbers.product)',
  "        // Define a tuple with two values and use the tuple to return the result.\n\
    \        //var sum = 0l\n        //var product = 1l\n        numbers.foldLeft((0l,\
    \ 1l)) { case ((s, p), n) => (s + n, p * n) }", '        return (numbers.foldLeft(0l)(_
    + _), numbers.foldLeft(1l)(_ * _))', "        val s = numbers.foldLeft(0l)(_ +\
    \ _)\n        val p = numbers.foldLeft(1l)(_ * _)\n        (s, p)", '        numbers.foldLeft((0l,
    1l))((r, c) => (r._1 + c, r._2 * c))', "        var sum : Long = 0\n        var\
    \ product : Long = 1\n        for (number <- numbers) {\n            sum += number\n\
    \            product *= number\n        }\n        return (sum, product)", '        numbers.foldLeft((0l,
    1l))((x, y) => (x._1 + y, x._2 * y))', "    \tval tup = (0L, 1L)\n        numbers.foldLeft(tup)\
    \ { case ((s, p), n) => (s + n, p * n) }", "        val sum = numbers.foldLeft(0l)(_\
    \ + _)\n        val product = numbers.foldLeft(1l)(_ * _)\n        return (sum,\
    \ product)", "        if (numbers.length == 0) {\n            return (0, 1)\n\
    \        }\n        if (numbers.length == 1) {\n            return (numbers(0),\
    \ numbers(0))\n        }\n        var tmp = numbers.foldLeft((0l, 1l))((x, y)\
    \ => (x._1 + y, x._2 * y))\n        return tmp", "        // TODO\n        (0,\
    \ 1)", "      var product = 1l\n      var sum = 0l\n      for (x <- numbers) {\n\
    \        product *= x\n        sum += x\n      }\n      (sum, product)", "   \
    \     val sum = numbers.foldLeft(0l)(_ + _)\n        val product = numbers.foldLeft(1l)(_\
    \ * _)\n        Tuple2(sum, product)", "        var result = Tuple2(0l, 1l)\n\
    \        for (i <- numbers) {\n            result = (result._1 + i, result._2\
    \ * i)\n        }\n        result", "        numbers.foldLeft((0l, 1l)) {\n  \
    \          case ((sum, product), num) => (sum + num, product * num)\n        }",
  "        // Fill up this function body\n        // You may also define other functions\n\
    \        return (0l, 0l)", "        numbers.foldLeft(0L, 1L) {\n            case\
    \ ((sum, product), number) => (sum + number, product * number)\n        }", " \
    \       // STUDENT CODE BEGIN\n        return (0l, 1l)\n        // STUDENT CODE\
    \ END", '        return (numbers.sum, numbers.product)', "        if (numbers.length\
    \ == 0) return (0, 1)\n        (numbers.reduce(_ + _), numbers.reduce(_ * _))",
  "        if (numbers.isEmpty) {\n            return (0l, 1l)\n        }\n      \
    \  val i = numbers.foldLeft(0l)((x, y) => x + y)\n        val j = numbers.foldLeft(1l)((x,\
    \ y) => x * y)\n        return (i, j)", '        numbers.foldLeft((0L, 1L))((acc,
    c) => (acc._1 + c, acc._2 * c))', "        if (numbers.isEmpty) return (0, 1)\n\
    \        else return (numbers.sum, numbers.product)", '        return (numbers.foldLeft(0l){_
    + _}, numbers.foldLeft(1l){_ * _})', '        return (numbers.sum, numbers.product)',
  '        (numbers.foldLeft(0l)(_ + _), numbers.foldLeft(1l)(_ * _))', '        Tuple2(numbers.sum,
    numbers.product)', "        if (numbers.isEmpty) {\n            (0, 1)\n     \
    \   } else {\n            (numbers.sum, numbers.product)\n        }", "      \
    \  var sum = 0l\n        var product = 1l\n        for (n <- numbers) {\n    \
    \        sum += n\n            product *= n\n        }\n        (sum, product)",
  '        (numbers.sum, numbers.product)', '        (numbers.foldLeft(0l)(_ + _),
    numbers.foldLeft(1l)(_ * _))', "        // YOUR CODE HERE\n        throw new UnsupportedOperationException\
    \ // Remove this line and implement your own solution", "        // Write your\
    \ code here\n        null", "        var sum = 0l\n        var product = 1l\n\
    \        for (number <- numbers) {\n            sum += number\n            product\
    \ *= number\n        }\n        (sum, product)"]
stop_tokens:
- "\n    }\n"
