name: HumanEval_83_starts_one_ends
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return the count of the numbers of n-digit\n\
  \    // positive integers that start or end with 1.\n    def startsOneEnds(n : Long)\
  \ : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(startsOneEnds((1l))\
  \ == (1l));\n    assert(startsOneEnds((2l)) == (18l));\n    assert(startsOneEnds((3l))\
  \ == (180l));\n    assert(startsOneEnds((4l)) == (1800l));\n    assert(startsOneEnds((5l))\
  \ == (18000l));\n    }\n\n}\n"
completions: ["        val pow10 = (0 to (n - 1)).map(x => pow(10, x).toLong).toList\n\
    \        val sums = pow10.scanLeft(0L)(_ + _)\n        val numsOfDigits = pow10.map(x\
    \ => x / 10).toList\n        val numsStarting = pow10.map(x => (x - 1) / 9).toList\n\
    \        val numsEnding = pow10.map(x => x / 9).toList\n        val result = (0\
    \ to (n - 1)).map(x => numsOfDigits(x) * (numsStarting(x) + numsEnding(x) - 1)).toList\n\
    \        val resultSum = result.sum\n        resultSum", '        1', "      \
    \  if (n == 1) {\n            return 2\n        }\n        if (n == 2) {\n   \
    \         return 4\n        }\n        return (1 to 9).map(i => pow(10, n - 1).toLong).sum",
  "        if (n == 1) 1\n        else (BigInt(10).pow(n - 1) - 1).toLong * 10 + 11\
    \ - BigInt(10).pow(n - 2).toLong", '        (1 to 9).map(x => func(x, n)).sum',
  '        if (n == 1) 1 else (1 to 9).foldLeft(0L)((acc, x) => acc + startsOneEnds(n
    - 1, 0, x))', "        if (n == 1) 1\n        else {\n            val x = pow(10,\
    \ n - 1).toLong\n            val y = pow(10, n).toLong\n            (y - x) *\
    \ 2 - (x - (x / 10))\n        }", "      // All numbers between 1 and 9 of length\
    \ n have n digits\n      // All numbers between 10^(n-1) and 10^n have n digits\n\
    \      // All numbers between 10^(n-1) and 11(10^(n-2)-1) have n digits and end\
    \ with 1\n      // All numbers between 11(10^(n-2)) and 19(10^(n-2)) have n digits\
    \ and start with 1\n      // All numbers between 11(10^(n-2)) and 11(10^(n-2)+10^(n-2)-1)\
    \ have n digits and start with 1\n      // All numbers between 11(10^(n-2)) and\
    \ 11(10^(n-2)+10^(n-2)-1) have n digits and end with 1\n      // All numbers between\
    \ 11(10^(n-2)+10^(n-2)) and 11(10^(n-2)+10^(n-2)+10^(n-2)-1) have n digits and\
    \ start with 1\n      // All numbers between 11(10^(n-2)+10^(n-2)) and 11(10^(n-2)+10^(n-2)+10^(n-2)-1)\
    \ have n digits and end with 1\n      // ...\n      // All numbers between 11(10^(n-2)+10^(n-2)+...+10^(n-2))\
    \ and 11(10^(n-2)+10^(n-2)+...+10^(n-2)+10^(n-2)-1) have n digits and start with\
    \ 1\n      // All numbers between 11(10^(n-2)+10^(n-2)+...+10^(n-2)) and 11(10^(n-2)+10^(n-2)+...+10^(n-2)+10^(n-2)-1)\
    \ have n digits and end with 1\n      if (n == 1) return 9\n      val startEnds\
    \ = (1 to (n - 1) / 2) map {i => 10 * 9 * pow(10, i - 1).toLong} sum\n      val\
    \ ends = (1 to (n - 1) / 2) map {i => 10 * pow", "        if (n <= 0) 0\n    \
    \    else if (n == 1) 2\n        else (10 - 2) * pow(9, n - 1).toLong + startsOneEnds(n\
    \ - 1)", "        // First, count all n-digit numbers. \n        val total = BigInt(10).pow(n.toInt)\n\
    \        // Count numbers containing a 1.\n        val size = n.toInt\n      \
    \  val ret = if (size == 1) total else total - BigInt(10).pow(size - 1)\n    \
    \    ret.toLong", "        if (n == 1) return 10\n        else {\n           \
    \ val cur = startsOneEnds(n - 1)\n            val a = 4L * pow(10, n - 2).toLong\n\
    \            val b = cur - a\n            2 * a + b\n        }", "        val\
    \ end = pow(10, n).toLong\n        var length = 1\n        var sum = 1\n     \
    \   while (length < n) {\n            sum += end\n            length += 1\n  \
    \      }\n        sum", "        // If we start with 1, then there are 10**(n-1)\
    \ choices for the remaining\n        // digits. If we end with 1, then there are\
    \ 10**(n-1) choices for the\n        // remaining digits.\n        2 * (BigInt(10).pow(n\
    \ - 1)).toLong", "        def numberOfDigits(k : Long) : Long = {\n          \
    \  var n = k\n            var count = 0\n            while (n > 0) {\n       \
    \         n /= 10\n                count += 1\n            }\n            count\n\
    \        }\n        var count = 0\n        for (i <- 1 to n) {\n            val\
    \ lower = pow(10, i - 1).toLong\n            val upper = pow(10, i).toLong - 1\n\
    \            count += upper - lower + 1\n        }\n        count", "        def\
    \ count(n : Long) : Long = {\n            if (n == 1)\n                return\
    \ 2\n            var ret = 0L\n            ret += count(n - 1) * 9 // random digits\n\
    \            ret += pow(10, n - 1).toLong // all ones\n            ret\n     \
    \   }\n        if (n == 1)\n            return 2\n        return count(n)", " \
    \       assert(n >= 1)\n        if (n == 1) 1 else 9 + 10 * (n - 1)", "      \
    \  if (n == 1) return 2\n        else {\n            var result = 0L\n       \
    \     for (i <- 0 to n - 1) result += pow(10, i).toLong\n            result *\
    \ 2\n        }", "        def startsOneEnds(n : Long, digit : Long) : Long = {\n\
    \            if (n == 1) return 1\n            var total = 1 + 9 * pow(10, n -\
    \ 2).toLong\n            for (i <- 1 to (n - 2)) {\n                total += startsOneEnds(i,\
    \ 1) * pow(10, n - i - 1).toLong\n            }\n            total\n        }\n\
    \        startsOneEnds(n, 1)", "        val dp = new Array[Long](n.toInt)\n  \
    \      dp(0) = 2\n        for (i <- 1 until n.toInt) dp(i) = dp(i - 1) * 10 +\
    \ pow(10, i).toLong\n        dp(n.toInt - 1)", "        if (n == 1)\n        \
    \    return 2\n        var dp = Array.ofDim[Long](n + 1, 2)\n        dp(1)(0)\
    \ = 0\n        dp(1)(1) = 2\n        for (i <- 2 to n) {\n            dp(i)(0)\
    \ = (dp(i - 1)(0) + dp(i - 1)(1)) * 9\n            dp(i)(1) = dp(i - 1)(0) + dp(i\
    \ - 1)(1)\n        }\n        dp(n)(0) + dp(n)(1)"]
stop_tokens:
- "\n    }\n"
