name: HumanEval_83_starts_one_ends
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return the count of the numbers of n-digit\n\
  \    // positive integers that start or end with 1.\n    def startsOneEnds(n : Long)\
  \ : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(startsOneEnds((1l))\
  \ == (1l));\n    assert(startsOneEnds((2l)) == (18l));\n    assert(startsOneEnds((3l))\
  \ == (180l));\n    assert(startsOneEnds((4l)) == (1800l));\n    assert(startsOneEnds((5l))\
  \ == (18000l));\n    }\n\n}\n"
completions: ["        val pow10 = (0 to (n - 1)).map(x => pow(10, x).toLong).toList\n\
    \        val sums = pow10.scanLeft(0L)(_ + _)\n        val numsOfDigits = pow10.map(x\
    \ => x / 10).toList\n        val numsStarting = pow10.map(x => (x - 1) / 9).toList\n\
    \        val numsEnding = pow10.map(x => x / 9).toList\n        val result = (0\
    \ to (n - 1)).map(x => numsOfDigits(x) * (numsStarting(x) + numsEnding(x) - 1)).toList\n\
    \        val resultSum = result.sum\n        resultSum", '        1', "      \
    \  if (n == 1) {\n            return 2\n        }\n        if (n == 2) {\n   \
    \         return 4\n        }\n        return (1 to 9).map(i => pow(10, n - 1).toLong).sum",
  "        if (n == 1) 1\n        else (BigInt(10).pow(n - 1) - 1).toLong * 10 + 11\
    \ - BigInt(10).pow(n - 2).toLong", '        (1 to 9).map(x => func(x, n)).sum',
  '        if (n == 1) 1 else (1 to 9).foldLeft(0L)((acc, x) => acc + startsOneEnds(n
    - 1, 0, x))', "        if (n == 1) 1\n        else {\n            val x = pow(10,\
    \ n - 1).toLong\n            val y = pow(10, n).toLong\n            (y - x) *\
    \ 2 - (x - (x / 10))\n        }", "      // All numbers between 1 and 9 of length\
    \ n have n digits\n      // All numbers between 10^(n-1) and 10^n have n digits\n\
    \      // All numbers between 10^(n-1) and 11(10^(n-2)-1) have n digits and end\
    \ with 1\n      // All numbers between 11(10^(n-2)) and 19(10^(n-2)) have n digits\
    \ and start with 1\n      // All numbers between 11(10^(n-2)) and 11(10^(n-2)+10^(n-2)-1)\
    \ have n digits and start with 1\n      // All numbers between 11(10^(n-2)) and\
    \ 11(10^(n-2)+10^(n-2)-1) have n digits and end with 1\n      // All numbers between\
    \ 11(10^(n-2)+10^(n-2)) and 11(10^(n-2)+10^(n-2)+10^(n-2)-1) have n digits and\
    \ start with 1\n      // All numbers between 11(10^(n-2)+10^(n-2)) and 11(10^(n-2)+10^(n-2)+10^(n-2)-1)\
    \ have n digits and end with 1\n      // ...\n      // All numbers between 11(10^(n-2)+10^(n-2)+...+10^(n-2))\
    \ and 11(10^(n-2)+10^(n-2)+...+10^(n-2)+10^(n-2)-1) have n digits and start with\
    \ 1\n      // All numbers between 11(10^(n-2)+10^(n-2)+...+10^(n-2)) and 11(10^(n-2)+10^(n-2)+...+10^(n-2)+10^(n-2)-1)\
    \ have n digits and end with 1\n      if (n == 1) return 9\n      val startEnds\
    \ = (1 to (n - 1) / 2) map {i => 10 * 9 * pow(10, i - 1).toLong} sum\n      val\
    \ ends = (1 to (n - 1) / 2) map {i => 10 * pow", "        if (n <= 0) 0\n    \
    \    else if (n == 1) 2\n        else (10 - 2) * pow(9, n - 1).toLong + startsOneEnds(n\
    \ - 1)", "        // First, count all n-digit numbers. \n        val total = BigInt(10).pow(n.toInt)\n\
    \        // Count numbers containing a 1.\n        val size = n.toInt\n      \
    \  val ret = if (size == 1) total else total - BigInt(10).pow(size - 1)\n    \
    \    ret.toLong", "        if (n == 1) return 10\n        else {\n           \
    \ val cur = startsOneEnds(n - 1)\n            val a = 4L * pow(10, n - 2).toLong\n\
    \            val b = cur - a\n            2 * a + b\n        }", "        val\
    \ end = pow(10, n).toLong\n        var length = 1\n        var sum = 1\n     \
    \   while (length < n) {\n            sum += end\n            length += 1\n  \
    \      }\n        sum", "        // If we start with 1, then there are 10**(n-1)\
    \ choices for the remaining\n        // digits. If we end with 1, then there are\
    \ 10**(n-1) choices for the\n        // remaining digits.\n        2 * (BigInt(10).pow(n\
    \ - 1)).toLong", "        def numberOfDigits(k : Long) : Long = {\n          \
    \  var n = k\n            var count = 0\n            while (n > 0) {\n       \
    \         n /= 10\n                count += 1\n            }\n            count\n\
    \        }\n        var count = 0\n        for (i <- 1 to n) {\n            val\
    \ lower = pow(10, i - 1).toLong\n            val upper = pow(10, i).toLong - 1\n\
    \            count += upper - lower + 1\n        }\n        count", "        def\
    \ count(n : Long) : Long = {\n            if (n == 1)\n                return\
    \ 2\n            var ret = 0L\n            ret += count(n - 1) * 9 // random digits\n\
    \            ret += pow(10, n - 1).toLong // all ones\n            ret\n     \
    \   }\n        if (n == 1)\n            return 2\n        return count(n)", " \
    \       assert(n >= 1)\n        if (n == 1) 1 else 9 + 10 * (n - 1)", "      \
    \  if (n == 1) return 2\n        else {\n            var result = 0L\n       \
    \     for (i <- 0 to n - 1) result += pow(10, i).toLong\n            result *\
    \ 2\n        }", "        def startsOneEnds(n : Long, digit : Long) : Long = {\n\
    \            if (n == 1) return 1\n            var total = 1 + 9 * pow(10, n -\
    \ 2).toLong\n            for (i <- 1 to (n - 2)) {\n                total += startsOneEnds(i,\
    \ 1) * pow(10, n - i - 1).toLong\n            }\n            total\n        }\n\
    \        startsOneEnds(n, 1)", "        val dp = new Array[Long](n.toInt)\n  \
    \      dp(0) = 2\n        for (i <- 1 until n.toInt) dp(i) = dp(i - 1) * 10 +\
    \ pow(10, i).toLong\n        dp(n.toInt - 1)", "        if (n == 1)\n        \
    \    return 2\n        var dp = Array.ofDim[Long](n + 1, 2)\n        dp(1)(0)\
    \ = 0\n        dp(1)(1) = 2\n        for (i <- 2 to n) {\n            dp(i)(0)\
    \ = (dp(i - 1)(0) + dp(i - 1)(1)) * 9\n            dp(i)(1) = dp(i - 1)(0) + dp(i\
    \ - 1)(1)\n        }\n        dp(n)(0) + dp(n)(1)", '        (1L until n).map(i
    => pow(2, i).toLong).sum + pow(2, n).toLong', "        var answer = 0L\n     \
    \   val power = pow(10, n - 1).toLong\n        val limit = power * 10\n      \
    \  for (i <- 1L until limit) {\n            if (i / power == 1) {\n          \
    \      val j = i % power\n                if (j == 0) answer += 2\n          \
    \      else if (j % 10 == 1) answer += 1\n            }\n        }\n        answer",
  "        var x = new StringBuilder(n.toString)\n        x(0) = '1'\n        x(n.toInt\
    \ - 1) = '1'\n        var l = 1L\n        var r = 1L\n        for (i <- 1 to n.toInt\
    \ - 1) {\n            l = l * 10\n            r = r * 10 + 1\n        }\n    \
    \    r - l + 1", "        val digits = n.toString.toArray\n        val ending\
    \ = Array.fill(digits.length + 1)(0L)\n        val starting = Array.fill(digits.length\
    \ + 1)(0L)\n        ending(0) = 0\n        ending(1) = 1\n        starting(0)\
    \ = 0\n        starting(1) = 1\n        for (i <- 2 to digits.length) {\n    \
    \        starting(i) = 9 * ending(i - 1) + starting(i - 1)\n            ending(i)\
    \ = starting(i - 1)\n        }\n        starting(digits.length)", '        (n
    + 1) * math.pow(10, n - 1).toLong', "        def func(n : Long) : Long = {\n \
    \           if (n == 1)\n                return 3\n            else\n        \
    \        return 10 * func(n - 1) + 10\n        }\n        return func(n)", " \
    \       def f(n : Long) : Long = {\n            if (n == 1) 1\n            else\
    \ if (n == 2) 2\n            else {\n                var ret = 0L\n          \
    \      for (i <- 1 to 9) {\n                    var sub = 0L\n               \
    \     for (j <- 1 to 9) {\n                        sub += f(n - 1)\n         \
    \           }\n                    ret += sub\n                }\n           \
    \     ret\n            }\n        }\n        f(n)", "        if (n == 1) return\
    \ 2\n        var sum = 1\n        for (i <- 2 to n) sum = sum * 10\n        for\
    \ (i <- 2 to n) sum += sum * (n - 1)\n        return sum", "      var ten = 1L\n\
    \      for (i <- 1 to n - 1) ten *= 10\n      ten + (ten - 1) / 9 * n", "    \
    \    val n2 = pow(10, n - 1).toLong\n        val n1 = pow(10, n).toLong\n    \
    \    return n1 - 2 * n2", "        if (n == 1) return 1\n        if (n == 2) return\
    \ 2\n        var dp = ArrayBuffer.fill(n.toInt + 1)(0)\n        dp(1) = 1\n  \
    \      dp(2) = 2\n        for (i <- 3 to n.toInt) {\n            dp(i) = 2 * dp(i\
    \ - 1) - dp(i - 2)\n        }\n        return dp(n.toInt)", "        if (n ==\
    \ 1) return 2\n        val fact10 = (1 to 10).product\n        val fact9 = (1\
    \ to 9).product\n        // Count of numbers whose first digit is 1\n        val\
    \ first = fact10 / fact9\n        // Count of numbers whose last digit is 1\n\
    \        val last = (1 to (n - 1)).map(n => fact10 / fact9).sum\n        // Count\
    \ of numbers whose first or last digit is 1\n        first + last - 1", "    \
    \    if (n == 1) 1\n        else {\n            val ten : Long = pow(10, n).toLong\n\
    \            // Start with 1\n            val n1 : Long = ten - 1\n          \
    \  // End with 1\n            val n2 : Long = ten / 10\n            n1 + n2\n\
    \        }", "        // since the number starts and ends with 1, there will be\
    \ n-2 numbers in between\n        // Thus, the total number will be 9*10^(n-2)\n\
    \        return 9 * pow(10, n - 2).toLong", "        if (n == 1) 1\n        else\
    \ {\n            // The number of numbers with a given number of digits that start\
    \ with 1\n            // equals the number of combinations of digits that can\
    \ be used for the\n            // remaining digits. There are 9 such combinations\
    \ for each digit, so the\n            // total is 9 * 9 * ... * 9 (n-1 times).\n\
    \            // The same holds for numbers ending with 1.\n            var result\
    \ = 1L\n            for (i <- 1 to n - 1) {\n                result *= 9\n   \
    \         }\n            result * 2\n        }", "        var count = 0L\n   \
    \     var power = 1L\n        for (i <- 1 to n) {\n            count += 9 * power\n\
    \            power *= 10\n        }\n        count", "        if (n == 1) return\
    \ 10\n        val root = pow(10, n - 1).toLong\n        (root * 2 - 1) + root",
  "        def startsOneEnds(n : Long, m : Long) : Long = {\n            if (n ==\
    \ 0) return 1\n            if (n == 1) return m\n            return (10 * startsOneEnds(n\
    \ - 1, m) - startsOneEnds(n - 2, m) + m) % 1000000007\n        }\n        return\
    \ startsOneEnds(n, 10)", "        if (n == 1)\n        \treturn 2\n        val\
    \ dp = Array.ofDim[Long](2, n + 1)\n        dp(0)(1) = 1\n        dp(1)(1) = 1\n\
    \        for (i <- 2 to n) {\n            dp(0)(i) = dp(0)(i - 1) + dp(1)(i -\
    \ 1)\n            dp(1)(i) = dp(0)(i - 1)\n        }\n        dp(0)(n) + dp(1)(n)",
  "      var dp = Array.ofDim[Long](n.toInt + 1, 2)\n      dp(1)(0) = 1\n      dp(1)(1)\
    \ = 1\n      for (i <- 2 to n.toInt) {\n        dp(i)(0) = dp(i - 1)(0) + dp(i\
    \ - 1)(1)\n        dp(i)(1) = dp(i - 1)(0)\n      }\n      dp(n.toInt)(0) + dp(n.toInt)(1)",
  "        def countNumberOfDS(d : Long, s : Long) : Long = {\n            if (d ==\
    \ 0) s\n            else if (d == 1) s + 2\n            else {\n             \
    \   val digits = pow(10, d - 1).toLong\n                val near = pow(10, d -\
    \ 2).toLong\n                (near * 9 * countNumberOfDS(d - 2, 1)) + (digits\
    \ * countNumberOfDS(d - 1, 0))\n            }\n        }\n        val digits =\
    \ pow(10, n - 1).toLong\n        countNumberOfDS(n, 0) + (digits * countNumberOfDS(n\
    \ - 1, 0))", "        if (n == 1) return 2\n        var product = 1L\n       \
    \ for (i <- 1L to n) product *= 10\n        product", "        // We have 9 choices\
    \ for the first digit, 8 choices for the second, etc.\n        //\n        //\
    \ Our answer is 10^(n-1) - 9^(n-1) + 9^(n-2) - 9^(n-3) + ... + 9 - 9^0\n     \
    \   //         = 10^(n-1) - 9 * (9^(n-1) - 9^(n-2) + 9^(n-3) - ... + 9 - 9^0)\n\
    \        //         = 10^(n-1) - 9 * (9^(n-1) - 9 * (9^(n-2) - 9 * (9^(n-3) -\
    \ ... + 9 - 9^0)))\n        // We are essentially \"splitting\" 9^(n-1) in 9 different\
    \ ways, and picking\n        // one of the 9 ways to split 9^(n-2), etc.\n   \
    \     if (n <= 1) 0\n        else {\n            var sum = 0L\n            var\
    \ root = 9L\n            var product = pow(10, n - 1).toLong\n            var\
    \ term = pow(9, n - 1).toLong\n            for (i <- 2 to n) {\n             \
    \   sum += (product - term) * root\n                root = pow(9, i - 1).toLong\n\
    \                product = pow(10, n - i).toLong\n                term = pow(9,\
    \ n - i).toLong\n            }\n            sum + 10\n        }", "        var\
    \ sum = 0L\n        for (i <- 1L to n) {\n            sum += pow(10, i - 1).toLong\n\
    \        }\n        return sum * 2", "        if (n == 1) return 1\n        else\
    \ if (n == 2) return 3\n        var dp = new Array[Long](n.toInt + 1)\n      \
    \  dp(1) = 1\n        dp(2) = 3\n        var k = 2\n        while (k <= n) {\n\
    \            dp(k) = (dp(k - 1) + dp(k - 2)) * 2\n            k += 1\n       \
    \ }\n        dp(n.toInt)", "        if (n == 1) {\n            2\n        } else\
    \ {\n            // Count the numbers between 10...00 and 19...99 + the numbers\
    \ between 1\n            // and 9.\n            startsOneEnds(n - 1) + (9 * pow(10,\
    \ n - 2)).toLong\n        }", "        val (a, b) = (n / 2, n % 2)\n        pow(10,\
    \ a).toLong - pow(9, a).toLong + pow(9, a).toLong * b", "        require(n >=\
    \ 1)\n        var count = 10 * ((n - 1) / 2)\n        if (n % 2 == 1) {\n    \
    \        count += 9\n        }\n        count", "      if (n == 1) return 10\n\
    \      var dp : Array[Long] = new Array[Long](n.toInt + 1)\n      dp(1) = 10\n\
    \      for (i <- 2 to n.toInt) {\n        val last = pow(10, i - 1).toLong\n \
    \       dp(i) = dp(i - 1) * 9 + last\n      }\n      dp(n.toInt)", "        //\
    \ Let f(n) be the number of n-digit positive integers that start or end with 1.\n\
    \        // f(n) = 2f(n - 1) + 10^(n - 1) - 1 (f(1) = 2)\n        // f(n) = 2(2f(n\
    \ - 2) + 10^(n - 2) - 1) + 10^(n - 1) - 1\n        //      = 4f(n - 2) + 10^(n\
    \ - 1) + 10^(n - 2) - 2\n        // f(n) = 2^kf(n - k) + (1 + ... + 10^(k - 1))\
    \ - (k - 1)\n        //      = 2^kf(n - k) + 10^k - k\n        val f : Array[Long]\
    \ = Array.fill(n.toInt + 1)(0)\n        f(1) = 2\n        for (i <- 2 to n.toInt)\
    \ {\n            var tmp = 0L\n            for (j <- 1 to i - 1) {\n         \
    \       tmp += pow(10, j - 1).toLong\n            }\n            f(i) = 2 * f(i\
    \ - 1) + pow(10, i - 1).toLong - 1 - tmp\n        }\n        f(n.toInt)", "  \
    \      var nd = n.toString.size\n        var n10 = BigInt(10).pow(nd - 1)\n  \
    \      var result = BigInt(9) * BigInt(10).pow(nd - 2)\n        if (n % n10 ==\
    \ 0) result += 1\n        return result.toLong", "        if (n == 1)\n      \
    \      return 10\n        val b = ArrayBuffer[Long]()\n        for (i <- 0 to\
    \ n - 1) {\n            val v = n - i - 1\n            b += (v * (9 * pow(10,\
    \ v)).toLong)\n        }\n        b.sum", "        /*\n         * To simplify\
    \ the problem, consider the problem for n-1\n         * digit integers. Let the\
    \ count be X.\n         * For a given n-digit number, it can start with 1 iff\
    \ the\n         * remaining n-1 digits form a valid number. Thus,\n         *\
    \ the count of numbers starting with 1 is X.\n         * Similarly, the count\
    \ of numbers ending with 1 is X.\n         * For a given n-digit number, if neither\
    \ of the last two\n         * digits is 1, then the remaining n-2 digits must\
    \ form a\n         * valid number. Thus, the count of numbers not ending\n   \
    \      * or starting with 1 is 10 * X.\n         * Therefore, the total count\
    \ of numbers with n digits is\n         * 10X + 2X.\n         */\n        val\
    \ ans = if (n == 1) 10 else {\n            val last = startsOneEnds(n - 1)\n \
    \           10 * last + 2 * last\n        }\n        ans", "        // (1 + 10\
    \ + 10^2 + 10^3 + ... + 10^(n-1)) + (1 + 9 + 90 + 900 + ... + 9*10^(n-2))\n  \
    \      val first = pow(10, n - 1).toLong - 1\n        val second = first * (n\
    \ - 1)\n        first + second", "        var a : Long = (1 - pow(10, -n + 1))\
    \ / (1 - 10)\n        var b : Long = 10 * a - 9 * (1 - pow(10, -n)) / (1 - 10)\n\
    \        return a + b", "        if (n == 1) return 2\n        var result = n\n\
    \        for (p <- 2 to n) {\n            val r = pow(10, p - 1).toLong\n    \
    \        result += 9 * r\n        }\n        result", "        var f = BigInt(10).pow(n\
    \ - 1)\n        var c = 0\n        while (f > 0) {\n            c += 1\n     \
    \       f /= 10\n        }\n        c", "        def f(a : Long, b : Long, c :\
    \ Long, d : Long) : Long = if (n == 0) a + b + c + d else {\n            f(b,\
    \ a + b + c + d, d, a + b + c + d)\n        }\n        f(0, 1, 0, 0)", "     \
    \   var count = 0L\n        for (i <- 1 to 9) {\n            count += pow(10,\
    \ n - 1).toLong * (10 - i)\n        }\n        count += (pow(10, n - 1).toLong\
    \ * 10 - pow(10, n - 2).toLong)\n        count", "        var a = new Array[Long](n.toInt\
    \ + 1)\n        var b = new Array[Long](n.toInt + 1)\n        a(1) = 1\n     \
    \   b(1) = 1\n        for (i <- 2 to n.toInt) {\n            a(i) = a(i - 1) +\
    \ b(i - 1)\n            b(i) = a(i - 1)\n        }\n        a(n.toInt) + b(n.toInt)",
  "        var product = 1L\n        var total = 0L\n        for (i <- 1L to n) {\n\
    \            product *= 10\n            if (i == 1) total += 2\n            else\
    \ total += 9 * product / 10\n        }\n        total", "        def go(d : Long,\
    \ s : Long) : Long = {\n            if (d == 0) 1\n            else s + go(d -\
    \ 1, s * 10)\n        }\n        go(n - 1, 9)", "        if (n == 1) return 2\n\
    \        var result = 0L\n        var i = 0L\n        while (i < n) {\n      \
    \      val tem = pow(10, i).toLong\n            val count = pow(9, n - i - 1).toLong\n\
    \            result += tem * count\n            i += 1\n        }\n        result\
    \ * 2", "        def pow(x : Long, y : Long) : Long = if (y == 0) 1 else x * pow(x,\
    \ y - 1)\n        var right : Long = pow(10, n - 1)\n        var left : Long =\
    \ pow(10, n - 2)\n        var result : Long = 0\n        while (right != 0) {\n\
    \            result += (right - 1) * left + right\n            right /= 10\n \
    \           left /= 10\n        }\n        result", "        if (n == 1) return\
    \ 10;\n        // 1 ... i ... 9\n        val maxEnd = n - 1;\n        val maxStart\
    \ = n - 2;\n        var total = 0l;\n        // Start with one.\n        total\
    \ += pow(10, maxStart).toLong - pow(9, maxStart).toLong;\n        // End with\
    \ one.\n        total += pow(10, maxEnd).toLong - pow(9, maxEnd).toLong;\n   \
    \     total;", "        if (n == 1) return 1\n        var result = 0L\n      \
    \  for (i <- 1 to 9) {\n            var array = new Array[Int](n.toInt)\n    \
    \        array(0) = i\n            result += endsOne(array, 1, n)\n        }\n\
    \        result", "        if (n == 1) return 2\n        val max = (n - 1) / 2\n\
    \        // how many ways to fill in the middle digits\n        val count = (2\
    \ to max).map(n => n - 1).reduce(_ * _)\n        // ways to add extra digits to\
    \ fill in\n        val extra = (1 to (n - 1) % 2).map(n => n + 1).reduce(_ * _)\n\
    \        return count * extra", "        // dp[i] is the count of numbers of digit\
    \ i.\n        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(1) = 1\n      \
    \  for (i <- 2 to n.toInt) {\n            // end with 1;\n            dp(i) +=\
    \ dp(i - 1)\n            // start with 1;\n            dp(i) += 9 * pow(10, i\
    \ - 2).toLong\n        }\n        dp(n.toInt)", "        if (n == 1) {\n     \
    \       2\n        } else {\n            (1 to n).map(i => BigInt(10).pow(i -\
    \ 1)).sum + 1\n        }", "        if (n == 1) return 10\n        var p = n -\
    \ 1\n        var a = n - 1\n        var b = 1\n        var ret = 10\n        while\
    \ (p >= 2) {\n            a *= p\n            b *= 9\n            p -= 1\n   \
    \         ret += a / b\n        }\n        return ret", "      // Count the number\
    \ of integers that start or end with 1\n      // for n - 1 digits.\n      // Start\
    \ with the end case: n = 1.\n      var cnt = n\n      // Induction step.\n   \
    \   for (i <- n - 1 to 1 by -1) {\n        cnt = cnt * (9 - i + 2)\n      }\n\
    \      return cnt", "        // return (pow(10, n).toLong - 9 * pow(9, n - 1).toLong)\n\
    \        if (n == 1) return 10\n        if (n == 2) return 100\n        var ans\
    \ = 0L\n        for (i <- 1 to 9) {\n            ans += pow(10, n - 1).toLong\
    \ - pow(9, n - 1).toLong\n        }\n        ans += pow(10, n - 1).toLong\n  \
    \      ans", "        // A rough estimate of the value of pi, calculated using\
    \ the method\n        // described in wikipedia.\n        // https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Continued_fraction_expansion\n\
    \        def pi(n : Long) : Double = {\n            var m = 0\n            var\
    \ d = 1\n            var a0 = floor(sqrt(n)).toLong\n            var a = a0\n\
    \            var res = a0\n            while (a != 2 * a0) {\n               \
    \ m = d * a - m\n                d = (n - m * m) / d\n                a = (a0\
    \ + m) / d\n                res = a\n            }\n            res\n        }\n\
    \        val cache = new HashMap[Long, Double]\n        def f(n : Long) : Double\
    \ = {\n            if (cache.contains(n)) cache(n)\n            else {\n     \
    \           val res = if (n == 1) 10.0 else 10.0 * (1.0 - 1.0 / (pi(n) + 1.0))\n\
    \                cache += (n -> res)\n                res\n            }\n   \
    \     }\n        var res = 0.0\n        for (i <- 1 to n.toInt) res += f(i)\n\
    \        res.toLong", "        // Count the number of 2-digit positive integers\
    \ that start or end with 1.\n        // 11 12 13 14 15 16 17 18 19 21 22 23 24\
    \ 25 26 27 28 29 31 ... 91\n        if (n == 2) 10\n        // Count the number\
    \ of 3-digit positive integers that start or end with 1.\n        // 111 112 113\
    \ 114 115 116 117 118 119 121 122 123 124 125 126 127 128 129 131 ... 191 911\
    \ 912 913 914 915 916 917 918 919 921 922 923 924 925 926 927 928 929 931 ...\
    \ 991\n        else if (n == 3) {\n            val N = 10\n            // Count\
    \ of 3-digit positive integers that start or end with 1 and\n            // have\
    \ no trailing zeros.\n            val count = (1 to N).map(i => pow(N - 1, i).toLong).sum\n\
    \            // There are N^2 3-digit positive integers that end with 0.\n   \
    \         count + pow(N, 2).toLong\n        }\n        // Count the number of\
    \ n-digit positive integers that start or end with 1.\n        // 11111 11112\
    \ 11113 11114 11115 11116 11117 11118 11119 11121 11122 11123 11124 11125 11126\
    \ 11127 11128 11129 11131 ... 11191 91111 91112 91113 91114 91115 91116 91117\
    \ 91118 91119 91121 91122 91123 91124 91125 91126 91127 91128 91129 91131 ...\
    \ 91191\n        else {\n            val N = 10\n            // Count of n-digit\
    \ positive integers that start or end with 1 and\n            // have no trailing\
    \ zeros.\n            val count = (1 to N).map(i => pow(N - 1, i).toLong).sum\n\
    \            // There are N^2 (n - 1)-digit positive integers that end with 0.\n\
    \            count + pow(N, 2).toLong * (pow(N, n - 2).toLong - 1)\n        }",
  "        if (n == 1) return 10\n        else if (n == 2) return 10 * 9 + 10\n  \
    \      else {\n            (1 to 9).map(x => pow(10, n - 1).toLong).reduce(_ +\
    \ _) * 9 + startsOneEnds(n - 1)\n        }", "        if (n == 1) return 2\n \
    \       if (n == 2) return 4\n        var nums = 4 : Long\n        for (i <- 3\
    \ to n.toInt) {\n            nums = nums * (9 - i + 2) + (nums * (nums - 1)) /\
    \ 2\n        }\n        nums", "        def f(n : Long) : Long = {\n         \
    \   if (n == 1) 1\n            else if (n == 2) 21\n            else {\n     \
    \           var result = 0L\n                for (i <- (1 to 9).toList) {\n  \
    \                  val sub1 = (i - 1) * pow(9, n - 2).toLong\n               \
    \     val sub2 = pow(10, n - 2).toLong\n                    result += f(n - 1)\
    \ - sub1 + sub2\n                }\n                result\n            }\n  \
    \      }\n        f(n)", "        if (n == 1) return 1\n        var total = 0\n\
    \        for (i <- 1 to (n - 1)) {\n            val ones = BigInt(10).pow(i)\n\
    \            total += ones.toLong\n        }\n        total += BigInt(10).pow(n\
    \ - 1).toLong\n        return total", "        def df(n : Long, start : Long,\
    \ end : Long) : Long = {\n            if (n == 0) return end\n            var\
    \ total = end\n            if (start != 1) total += pow(9, n - 1).toLong\n   \
    \         var i = 0\n            while (i < 10) {\n                if (i != 0)\
    \ total += df(n - 1, start, end)\n                i += 1\n            }\n    \
    \        total\n        }\n        if (n == 1) return 10\n        else return\
    \ df(n - 1, 1, 0) + df(n - 1, 0, 1)", "        val pow10 = BigInt(10).pow(n.toInt\
    \ - 1)\n        def f(m : Long) : Long = {\n            val res = if (m == 1)\
    \ 1L else 9L\n            res * pow10\n        }\n        (1L to 9L).map(f).sum",
  "        // This can be done by PIE. Let f(i) be the number of i-digit numbers\n\
    \        // that start with 1, and g(i) be the number of i-digit numbers that\n\
    \        // end with 1. Then f(i) = g(i - 1) and g(i) = 9 * f(i - 1) + g(i - 1).\n\
    \        // This can be solved by matrix exponentiation.\n        def matrixExponentiation(a\
    \ : Array[Array[Long]], b : Long) : Array[Array[Long]] = {\n            def matmul(a\
    \ : Array[Array[Long]], b : Array[Array[Long]]) : Array[Array[Long]] = {\n   \
    \             val c = Array.ofDim[Long](a.length, a.length)\n                for\
    \ (i <- 0 until a.length; j <- 0 until a.length; k <- 0 until a.length) c(i)(j)\
    \ = (c(i)(j) + a(i)(k) * b(k)(j)) % 1000000007\n                c\n          \
    \  }\n            if (b == 1) a\n            else if (b % 2 == 0) {\n        \
    \        val x = matrixExponentiation(a, b / 2)\n                matmul(x, x)\n\
    \            } else matmul(a, matrixExponentiation(a, b - 1))\n        }\n   \
    \     val a = Array(Array(0, 1), Array(9, 10))\n        val f0 = Array(Array(1,\
    \ 0))\n        val ans = matmul(f0, matrixExponentiation(a, n - 1))\n        ans(0)(0)",
  "        def f(k : Long) : Long = {\n            if (k == 0) return 0\n        \
    \    val nn = pow(10, k - 1).toLong\n            f(k - 1) + nn * 9 * k + nn *\
    \ 10\n        }\n        f(n)", "        val pow = pow(10, n - 1).toLong\n   \
    \     2 + pow + 2 * pow - 2", "        if (n == 1)\n            return 10\n  \
    \      val count = Array.fill(n.toInt)(10L)\n        count(0) = 9\n        for\
    \ (i <- 2 to n.toInt) {\n            for (j <- 0 until i - 1) {\n            \
    \    count(i - 1) += 9 * pow(10, j).toLong\n            }\n        }\n       \
    \ count(n.toInt - 1)", "        var m : Long = 0\n        if (n == 1) m = 10\n\
    \        else {\n            val count = (1 to 9).map(pow(10, _).toLong).toList.takeWhile(_\
    \ < n).sum\n            m = count * 10 + 1\n        }\n        m", "        if\
    \ (n == 1) return 3\n        // # of digits starting with 1 + # of digits ending\
    \ with 1 - # of digits starting and ending with 1\n        pow(10, n - 1).toLong\
    \ * 2 - pow(10, n - 2).toLong", "      // Take the binary number and count the\
    \ number of digits 1, mod 3.\n      def countOnes(x : Long) : Long = if (x ==\
    \ 0) 0 else if (x % 2 == 1) 1 + countOnes(x / 2) else countOnes(x / 2)\n     \
    \ val powerOfTen = pow(10, n).toLong\n      // The first digit is 1.\n      val\
    \ firstDigitOne = powerOfTen - powerOfTen / 10\n      // The last digit is 1.\n\
    \      val lastDigitOne = powerOfTen / 2\n      // The first and last digits are\
    \ 1.\n      val lastAndFirstDigitOne = countOnes(powerOfTen)\n      firstDigitOne\
    \ + lastDigitOne - lastAndFirstDigitOne", "        def pow(n : Long) : Long =\
    \ if (n == 0) 1 else 10 * pow(n - 1)\n        // Return the number of n-digit\
    \ numbers whose first digit equals `c1`,\n        // second digit equals `c2`,\
    \ ... last digit equals `cn`\n        def f(c1 : Int, c2 : Int, c3 : Int, c4 :\
    \ Int, c5 : Int, c6 : Int, c7 : Int, c8 : Int, c9 : Int, c10 : Int) : Long = {\n\
    \            val num = pow(10 - n).toInt\n            var result = 0\n       \
    \     if (c1 != 0) result += 1\n            if (c10 != 0) result += 1\n      \
    \      if (n >= 2) {\n                if (c1 != 0) result += (c1 - 1) * num\n\
    \                if (c10 != 0) result += (c10 - 1) * num\n                if (c2\
    \ != 0) result += c2 * (num / 10)\n                if (c9 != 0) result += c9 *\
    \ (num / 10)\n            }\n            if (n >= 3) {\n                if (c1\
    \ != 0) result += (c1 - 1) * num * 10 * 9 / 100\n                if (c10 != 0)\
    \ result += (c10 - 1) * num * 10 * 9 / 100\n                if (c2 != 0) result\
    \ += c2 * (num / 10) * 10 * 9 / 100\n                if (c9 != 0) result += c9\
    \ * (num / 10) * 10 * 9 / 100\n                if (c3 != 0) result += c3 * (num\
    \ / 100)\n                if (c8 != 0) result += c8 * (num / 100)\n          \
    \  }\n            if (n >= 4) {\n                if (c1 != 0) result += (c1 -\
    \ 1) * num * 10 * 9 * 10 * 9 / 10000\n                if (c10 != 0) result +=\
    \ (c10 - 1) * num * 10 * 9 * 10 * 9 / 10000\n                if (c2 != 0) result\
    \ += c2 * (num / 10) * 10 * 9 * 10 * 9 / 10000\n                if (c9 != 0) result\
    \ += c", "        // Number of n-digit positive integers that start or end with\
    \ 1.\n        // Start by computing that for n = 1, then using that to compute\n\
    \        // for n = 2, 3, ..., N.\n        val results = new Array[Long](n.toInt\
    \ + 1)\n        results(1) = 2\n        for (i <- 2 to n.toInt) {\n          \
    \  // Count the numbers of i-digit numbers starting or ending with 1\n       \
    \     // based on the numbers of (i - 1)-digit numbers starting or ending\n  \
    \          // with 1.\n            //\n            // First, the numbers of (i\
    \ - 1)-digit numbers starting or ending\n            // with 1 that have a 0 in\
    \ the middle, i.e. 10_ _ _0, 0_ _ _1.\n            // There are 10 such numbers,\
    \ since they can start with 10_ _ _,\n            // or end with 0_ _ _1.\n  \
    \          //\n            // Next, the numbers of (i - 1)-digit numbers starting\
    \ or ending\n            // with 1 that have a 1 in the middle, i.e. 10_ _ _1,\
    \ 1_ _ _1.\n            // Since these numbers must start with a 1, there are\
    \ 9 such\n            // numbers, since they can start with 10_ _ _1, 11_ _ _1,\
    \ ...,\n            // 19_ _ _1.\n            //\n            // Therefore, there\
    \ are 10 + 9 = 19 numbers of i-digit numbers\n            // starting or ending\
    \ with 1.\n            results(i) = 10 + results(i - 1)\n        }\n        results(n.toInt)",
  "        n match {\n            case 1 => 2\n            case 2 => 6\n         \
    \   case _ => 2 * (10 * pow(9, n - 2).toLong - pow(9, n - 2).toLong)\n       \
    \ }", "        var sum = 0L\n        for (i <- 1 to 9) {\n            var times\
    \ = 9\n            for (j <- 1 until n) {\n                sum += i * times\n\
    \                times *= 10\n            }\n        }\n        return sum", " \
    \       // We can use digit partitioning to solve this.\n        // A number with\
    \ k digits ending in 1 will have k-1 digits before the 1.\n        // So we can\
    \ choose from our n digits k-1 digits to put before the 1, and\n        // we\
    \ will have n-k digits left to put after the 1.\n        // For example, if n\
    \ = 6, then we can have k = 1, 2, 3, 4, 5, or 6.\n        // For k = 1, we have\
    \ 1 number\n        // For k = 2, we have 5 numbers\n        // For k = 3, we\
    \ have 20 numbers\n        // For k = 4, we have 70 numbers\n        // For k\
    \ = 5, we have 252 numbers\n        // For k = 6, we have 924 numbers\n      \
    \  // We can also use this method to count numbers ending in 0\n        // We\
    \ can also use this method to count numbers starting in 1\n        // But we cannot\
    \ use this method to count numbers starting in 0\n        // because we will have\
    \ no digits left to put after the 0.\n        // We can, however, use this method\
    \ to count numbers starting in 2\n        // up to 9.\n        // So we can use\
    \ this to count numbers with a 1 in the first digit\n        // and a 2-9 in the\
    \ last digit, and add that to the number of numbers\n        // with a 1 in the\
    \ first digit and a 0 in the last digit, and add that\n        // to the number\
    \ of numbers with a 1 in the last digit.\n        // For each of those numbers\
    \ starting in 1, there are 9 options for\n        // each digit from the first\
    \ digit to the second to last digit.\n        // After the second to last digit,\
    \ there is only one option.\n        // For each of those numbers ending in 1,\
    \ there are 9 options for\n        // each digit from the second digit to the\
    \ last digit.\n        // Before the second digit, there is only one option.\n\
    \        // So we have 10 times the sum of the binomial coefficients\n       \
    \ val count1 = (1 to (n-1).toInt).map(k => BigInt(9) * binomial(n-1, k-1)).sum\n\
    \        val count2 = 10 * binomial(n-1, n-2)\n        count1 + count2\n", " \
    \       if (n == 1) return 2\n        val dp = Array.ofDim[Long](n + 1, 10)\n\
    \        for (k <- 1 to 9) dp(1)(k) = 1\n        for (i <- 2 to n) {\n       \
    \     for (j <- 0 to 9) {\n                if (j == 0) dp(i)(j) = dp(i - 1)(1)\n\
    \                else if (j == 9) dp(i)(j) = dp(i - 1)(8)\n                else\
    \ dp(i)(j) = dp(i - 1)(j - 1) + dp(i - 1)(j + 1)\n            }\n        }\n \
    \       var res = 0L\n        for (k <- 1 to 9) res += dp(n)(k)\n        res",
  "        if (n == 1)\n            return 1\n        return pow(10, n - 1).toLong",
  "        // 1 = 1\n        // 10 - 99 = 90 = (10^1-10^0) * 9\n        // 100 - 999\
    \ = 900 = (10^2-10^1) * 9\n        // 1000 - 9999 = 9000 = (10^3-10^2) * 9\n \
    \       // 10000 - 99999 = 90000 = (10^4-10^3) * 9\n        // 100000 - 999999\
    \ = 900000 = (10^5-10^4) * 9\n        // 1000000 - 9999999 = 9000000 = (10^6-10^5)\
    \ * 9\n        // 10000000 - 99999999 = 90000000 = (10^7-10^6) * 9\n        //\
    \ 100000000 - 999999999 = 900000000 = (10^8-10^7) * 9\n        // 1000000000 -\
    \ 9999999999 = 9000000000 = (10^9-10^8) * 9\n        // 10000000000 - 99999999999\
    \ = 90000000000 = (10^10-10^9) * 9\n        // 100000000000 - 999999999999 = 900000000000\
    \ = (10^11-10^10) * 9\n        // 1000000000000 - 9999999999999 = 9000000000000\
    \ = (10^12-10^11) * 9\n        // 10000000000000 - 99999999999999 = 90000000000000\
    \ = (10^13-10^12) * 9\n        // 100000000000000 - 999999999999999 = 900000000000000\
    \ = (10^14-10^13) * 9\n        // 1000000000000000 - 9999999999999999 = 9000000000000000\
    \ = (10^15-10^14) * 9\n        // 10000000000000000 - 99999999999999999 = 90000000000000000\
    \ = (10^16-10^15) * 9\n        // 100000000000000000 - 999999999999999999 = 900000000000000000\
    \ = (10^17-10^16) * 9\n        // 1000000000000000000 - 9999999999999999999 =\
    \ 9000000000000000000 = (10^18-10^17) * 9\n        // 10000000000000000000 - 99999999999999999999\
    \ = 90000000000000000000 = (10^19-10^18) * 9\n        // 100000000000000000000\
    \ - 999999999999999999999 = 900000000000000000000 = (10^20-", "        if (n ==\
    \ 1) return 10\n        val dp = Array.ofDim[Long](n + 1, 2)\n        dp(1)(0)\
    \ = 9\n        dp(1)(1) = 1\n        for (i <- 2 to n) {\n            dp(i)(0)\
    \ = dp(i - 1)(0) * 9 + dp(i - 1)(1)\n            dp(i)(1) = dp(i - 1)(0)\n   \
    \     }\n        dp(n)(0) + dp(n)(1)", "        var c = 0\n        for (i <- 1\
    \ to 9) {\n            c += pow(10, n - 1).toLong\n        }\n        for (i <-\
    \ 1 to n - 1) {\n            c += (pow(10, i - 1).toLong) * 9 * pow(10, n - i\
    \ - 1).toLong\n        }\n        c", "        if (n == 1) return 1\n        val\
    \ power = (n - 1) * (n - 1)\n        val tens = pow(10, n - 1).toLong\n      \
    \  val numerator = (power + 1) * (power + 1)\n        val denominator = 100 *\
    \ power\n        return numerator / denominator * tens", "        var ans = pow(10,\
    \ n - 1).toLong\n        ans *= 8\n        ans", "      val cache = new Memoize[Int,\
    \ Long]\n      def f(n : Int) : Long = {\n        if (n == 1) return 2\n     \
    \   cache.getOrElseUpdate(n, f(n - 1) + pow(10, n - 1).toLong)\n      }\n    \
    \  f(n.toInt)", "        if (n == 1) return 10\n        var count = 10\n     \
    \   var d = n - 1\n        while (d > 0) {\n            if (d == 1) count += 9\
    \ else count += pow(10, d - 1).toLong * 9\n            d -= 1\n        }\n   \
    \     count", "        val startOneMap = Map(0 -> 1, 1 -> 1, 2 -> 1, 3 -> 1, 4\
    \ -> 1, 5 -> 1, 6 -> 1, 7 -> 1, 8 -> 1, 9 -> 1)\n        val startOtherMap = Map(0\
    \ -> 0, 1 -> 1, 2 -> 1, 3 -> 1, 4 -> 1, 5 -> 1, 6 -> 1, 7 -> 1, 8 -> 1, 9 -> 1)\n\
    \        def iter(currentN : Long, startOne : Map[Long, Long], startOther : Map[Long,\
    \ Long]) : Map[Long, Long] = {\n            if (currentN == n) startOne\n    \
    \        else {\n                iter(currentN + 1, \n                    ((0\
    \ to 9).map(x => startOne.getOrElse(x, 0L)) ++ (0 to 9).map(x => startOther.getOrElse(x,\
    \ 0L))).zipWithIndex.map(x => (x._2.toLong, x._1)).toMap,\n                  \
    \  ((0 to 9).map(x => if (x == 0) startOne.getOrElse(x, 0L) else startOther.getOrElse(x,\
    \ 0L)) ++ (0 to 9).map(x => startOne.getOrElse(x, 0L))).zipWithIndex.map(x =>\
    \ (x._2.toLong, x._1)).toMap)\n            }\n        }\n        iter(1, startOneMap,\
    \ startOtherMap).values.sum", "        var count = 0L\n        for (i <- 1 to\
    \ 9) {\n            count += (1L to n - 1).map(j => j).foldLeft(1L)((product,\
    \ i) => product * 9)\n        }\n        count", "        if (n == 1) return 2\n\
    \        if (n == 2) return 8\n        if (n == 3) return 24\n        if (n ==\
    \ 4) return 76\n        if (n == 5) return 236\n        if (n == 6) return 736\n\
    \        if (n == 7) return 2308\n        if (n == 8) return 7284\n        if\
    \ (n == 9) return 23060\n        var last = 23060\n        var lastlast = 7284\n\
    \        for (i <- 10 to n.toInt) {\n            val next = last * 10 + lastlast\
    \ * 9\n            lastlast = last\n            last = next\n        }\n     \
    \   last", "        val x = Array.fill(10, n + 1)(0)\n        for (i <- 1 to 9)\
    \ x(i)(1) = 1\n        for (i <- 2 to n) {\n            for (j <- 1 to 9) {\n\
    \                for (k <- 0 to 9) x(j)(i) += x(k)(i - 1)\n            }\n   \
    \     }\n        x.map(_.last).sum - x(0).last", "        val dp = Array.ofDim[Long](n.toInt\
    \ + 1, 2)\n        dp(1)(0) = 0\n        dp(1)(1) = 1\n        for (i <- 2 to\
    \ n.toInt) {\n            dp(i)(0) = dp(i - 1)(0) + dp(i - 1)(1)\n           \
    \ dp(i)(1) = dp(i - 1)(0)\n        }\n        dp(n.toInt)(0) + dp(n.toInt)(1)",
  "        if (n == 1) return 2\n        val mod : Long = pow(10, 9).toLong + 7\n\
    \        var result : Long = 0\n        val dp : Array[Array[Long]] = Array.ofDim[Long](n.toInt\
    \ + 1, 2)\n        dp(1)(0) = 1\n        dp(1)(1) = 1\n        for (i <- 2 to\
    \ n.toInt) {\n            dp(i)(0) = (dp(i - 1)(0) + dp(i - 1)(1)) % mod\n   \
    \         dp(i)(1) = dp(i - 1)(0)\n        }\n        for (i <- 0 to 1) result\
    \ = (result + dp(n.toInt)(i)) % mod\n        result", "        var ways = 0\n\
    \        for (i <- 1 to n) ways += pow(9, i).toLong - pow(8, i).toLong\n     \
    \   ways", "        if (n == 1) return 9\n        10 * (pow(10, n - 1).toLong\
    \ - 1) + (startsOneEnds(n - 1) + pow(10, n - 1).toLong)", "        val b = pow(10,\
    \ n - 1).toLong\n        val e = pow(10, n).toLong\n        val count = (b until\
    \ e).filter(x => {\n            val s = x.toString\n            (s.charAt(0) ==\
    \ '1' || s.charAt(s.length - 1) == '1')\n        }).length\n        count", " \
    \       val dp : Array[Array[Long]] = Array.ofDim[Long](n.toInt + 1, 2)\n    \
    \    dp(1)(0) = 0\n        dp(1)(1) = 1\n        for (i <- 2 to n.toInt) {\n \
    \           dp(i)(0) = dp(i - 1)(0) + dp(i - 1)(1)\n            dp(i)(1) = dp(i\
    \ - 1)(0)\n        }\n        dp(n.toInt)(0) + dp(n.toInt)(1)", "        // A\
    \ possible solution is:\n        // Consider the cases of n = 0, 1, 2, 3...\n\
    \        // 1, 10, 101, 1010, 10101, 101010, 1010101, 10101010, ...\n        //\
    \ 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, ...\n        // 1, 20, 201,\
    \ 2010, 20101, 201010, 2010101, 20101010, ...\n        // 1, 21, 211, 2111, 21111,\
    \ 21111, 211111, 2111111, ...\n        // 1, 30, 301, 3010, 30101, 301010, 3010101,\
    \ 30101010, ...\n        // 1, 31, 311, 3111, 31111, 311111, 3111111, 31111111,\
    \ ...\n        // 1, 40, 401, 4010, 40101, 401010, 4010101, 40101010, ...\n  \
    \      // 1, 41, 411, 4111, 41111, 411111, 4111111, 41111111, ...\n        //\
    \ 1, 50, 501, 5010, 50101, 501010, 5010101, 50101010, ...\n        // 1, 51, 511,\
    \ 5111, 51111, 511111, 5111111, 51111111, ...\n        // 1, 60, 601, 6010, 60101,\
    \ 601010, 6010101, 60101010, ...\n        // 1, 61, 611, 6111, 61111, 611111,\
    \ 6111111, 61111111, ...\n        // 1, 70, 701, 7010, 70101, 701010, 7010101,\
    \ 70101010, ...\n        // 1, 71, 711, 7111, 71111, 711111, 7111111, 71111111,\
    \ ...\n        // 1, 80, 801, 8010, 80101, 801010, 8010101, 80101010, ...\n  \
    \      // 1, 81, 811, 8111, 81111, 811111, 8111111, 81111111, ...\n        //\
    \ 1, 90, 901, 9010, 90101, 901010, 9010101, 90101010, ...\n        // 1, 91, 911,\
    \ 9111, 91111", "        if (n == 1) return 10\n        val dp = Array.ofDim[Long](n\
    \ + 1, 2)\n        dp(1)(0) = 9\n        dp(1)(1) = 1\n        for (i <- 2 to\
    \ n) {\n            dp(i)(0) = dp(i - 1)(0) * 9 + dp(i - 1)(1)\n            dp(i)(1)\
    \ = dp(i - 1)(0)\n        }\n        dp(n)(0) + dp(n)(1)", "        if (n == 1)\n\
    \            return 1\n        else {\n            val k = (n + 1) / 2\n     \
    \       return pow(10, k - 1).toLong\n        }", "        val dp = Array.ofDim[Long](n.toInt\
    \ + 1, 2)\n        dp(1)(0) = 0\n        dp(1)(1) = 1\n        for (i <- 2 to\
    \ n.toInt) {\n            dp(i)(0) = dp(i - 1)(0) + dp(i - 1)(1)\n           \
    \ dp(i)(1) = dp(i - 1)(0)\n        }\n        dp(n.toInt)(0) + dp(n.toInt)(1)",
  "        def f(x : Long) : Long = {\n            if (x == 0) 0\n            else\
    \ {\n                val temp = f(x - 1)\n                val pow = pow(10, x\
    \ - 1).toLong\n                (10 - x + 1) * pow + temp * (10 - x)\n        \
    \    }\n        }\n        val pow = pow(10, n - 1).toLong\n        2 * pow -\
    \ 1 + f(n)", "        val dp = Array.ofDim[Long](n.toInt + 1, 2)\n        dp(1)(0)\
    \ = 9\n        dp(1)(1) = 1\n        for (i <- 2 to n.toInt) {\n            dp(i)(0)\
    \ = 10 * dp(i - 1)(0) - dp(i - 1)(1)\n            dp(i)(1) = dp(i - 1)(0)\n  \
    \      }\n        dp(n.toInt)(0) + dp(n.toInt)(1)", "        val N = n.toInt\n\
    \        val (counts, ends) = Array.fill(2, N + 1)(0L)\n        counts(0) = 1\n\
    \        for (i <- 1 to N) {\n            for (j <- 1 to 9) {\n              \
    \  counts(1) += counts(0)\n                ends(1) += ends(0)\n            }\n\
    \            for (j <- 0 to 9) {\n                counts(0) += ends(j)\n     \
    \           ends(j) = counts(j)\n            }\n        }\n        counts(1) +\
    \ counts(0)", "        var digits = List[Int]()\n        var a = n\n        while\
    \ (a > 0) {\n            digits = (a % 10).toInt :: digits\n            a /= 10\n\
    \        }\n        if (digits.length == 1) return 1\n        var endsOne = digits.last\
    \ == 1\n        var count = 0\n        for (i <- digits.length - 2 to 0 by -1)\
    \ {\n            if (digits(i) == 1) count += pow(9, i).toLong\n            else\
    \ count += 9 * pow(9, i).toLong\n        }\n        if (endsOne) return count\
    \ + 1\n        return count", "        if (n <= 2) return 0\n        var total\
    \ = 1L\n        for (i <- 1 to n - 2) total *= 10\n        total *= 2\n      \
    \  total", "      if (n == 1) 1\n      else (1 to (n - 1).toInt).map(1 * pow(10,\
    \ _).toLong).sum + pow(10, n - 1).toLong", "        if (n == 1) return 10\n  \
    \      if (n == 2) return 55\n        // If we have n digits and start with 1,\
    \ then the rest of the n-1 digits\n        // can be chosen in 9*9^(n-2) ways,\
    \ and the first digit can be either 0 or\n        // 1, for a total of 10*9^(n-2)\
    \ ways.\n        // If we have n digits and end with 1, then the rest of the n-1\
    \ digits can\n        // be chosen in 9*9^(n-2) ways, and the last digit can be\
    \ either 0 or 1,\n        // for a total of 10*9^(n-2) ways.\n        // So we\
    \ have 20*9^(n-2) = 2*10*9^(n-2) ways.\n        2 * 10 * pow(9, n - 2).toLong",
  "        if (n <= 2)\n            return n\n        // The key observation is that\
    \ the results can be categorized into two\n        // categories:\n        //\
    \ (1) The number is composed of two parts, the first part is a number\n      \
    \  //     with one digit less than n and the second part is a digit. This\n  \
    \      //     category has a number of `pow(9, n - 1) * 9`.\n        // (2) The\
    \ number is composed of two parts, the first part is a number\n        //    \
    \ with one digit less than n and the second part is not a digit.\n        // \
    \    This category has a number of `pow(9, n - 1) * 8`.\n        // (3) The number\
    \ is composed of one part, which has a number of\n        //     `pow(9, n - 1)`.\n\
    \        pow(9, n - 1) * 9 + pow(9, n - 1) * 8 + pow(9, n - 1)", "        val\
    \ limit = (\"1\" + \"0\" * (n - 1)).toLong;\n        def count(m : Long) : Long\
    \ = {\n            if (m < 10) 1\n            else 10 * count(m / 10)\n      \
    \  }\n        val res = (1 to limit.toString.length - 1).map(x => (1 + pow(10,\
    \ x) - 1).toLong).sum + 1 + count(limit)\n        res", "        if (n == 1) return\
    \ 2\n        var ans = pow(2, n - 1).toLong\n        ans *= ans\n        ans /=\
    \ 2\n        ans *= 2\n        ans -= 1\n        ans", "        if (n == 1) return\
    \ 2\n        val ones = 2 + pow(10, n - 1).toLong\n        return ones + ones\
    \ - 1 + startsOneEnds(n - 1)", "        // A number ending in 1 must be one less\
    \ than a power of 10, so we\n        // begin there. There will be no more than\
    \ log10(n) numbers of this\n        // form.\n        var i = 0\n        var result\
    \ = 0\n        var p = 1\n        while (p <= n) {\n            p *= 10\n    \
    \        i += 1\n        }\n        result += i\n        // Next we consider numbers\
    \ of the form 1x1x1x...x1, where x is any\n        // digit.\n        result +=\
    \ (n - 1).toInt\n        // Finally, we consider numbers of the form nx, where\
    \ n and x have a\n        // common length, and n > x.\n        var nextLength\
    \ = 0\n        var currentLength = i\n        while (nextLength < currentLength)\
    \ {\n            nextLength = floor(log10(n)).toInt\n            result += min(n,\
    \ 10).toInt * (currentLength - nextLength)\n            n /= 10\n            currentLength\
    \ = nextLength\n        }\n        result", "      if (n == 1) return 2\n    \
    \  val start1 = (1 to (n - 1)).map(i => pow(10, i).toLong).sum\n      val end1\
    \ = start1\n      return start1 + end1", "        var s = 0L\n        for (i <-\
    \ 1 to n) {\n            s += pow(10, i - 1).toLong\n        }\n        s", " \
    \       if (n == 1) return 2\n        var sum = 0L\n        for (i <- 1 to 9)\
    \ {\n            val k = pow(10, n - 1).toLong\n            sum += (k - 1) * 10\
    \ + i\n        }\n        sum", "        val startOne = Array.fill(n.toInt + 1)(1L)\n\
    \        val endOne = Array.fill(n.toInt + 1)(1L)\n        for (i <- 2 to n.toInt)\
    \ {\n            startOne(i) = 10 * startOne(i - 1)\n            endOne(i) = 9\
    \ * endOne(i - 1) + startOne(i - 1)\n        }\n        startOne(n.toInt) + endOne(n.toInt)",
  "        if (n == 1) 1\n        else {\n            val first = 9 * power(10, n\
    \ - 2)\n            val second = power(10, n - 1)\n            first + second\n\
    \        }", "        if (n == 1) return 1\n        if (n % 2 == 0) {\n      \
    \      val l = n / 2\n            return 10 * (1 to l).map(i => pow(2, i - 1).toLong).reduceLeft(_\
    \ + _)\n        } else {\n            val l = n / 2\n            return 10 * 10\
    \ * (1 to l).map(i => pow(2, i - 1).toLong).reduceLeft(_ + _)\n        }", " \
    \       if (n == 1)\n            return 10\n        var count = 9\n        var\
    \ i = 0\n        while (i < n - 1) {\n            count = (count * (9 - i)) %\
    \ 1000000007\n            i += 1\n        }\n        count", "        var total\
    \ = 0L\n        var cn = n\n        while (cn > 0) {\n            val counts =\
    \ getCounts(cn)\n            if (counts.isDefined) {\n                val (startOne,\
    \ endOne) = counts.get\n                total += startOne + endOne\n         \
    \   }\n            cn -= 1\n        }\n        total", "        if (n == 1) 1\n\
    \        else {\n            val base = pow(10, n - 1).toLong\n            val\
    \ end = pow(10, n - 2).toLong\n            base - end\n        }", "        val\
    \ digitCounts = Array.fill(10)(0)\n        val queue = Array.fill(10)(new Queue[Long])\n\
    \        var result = 0L\n        var nBase10 = n\n        while (nBase10 > 0)\
    \ {\n            digitCounts(nBase10 % 10) += 1\n            nBase10 /= 10\n \
    \       }\n        // start or end with 1\n        digitCounts(1) -= 1\n     \
    \   for (i <- 0 until 10) {\n            for (j <- 0 until digitCounts(i)) {\n\
    \                queue(i).enqueue(i)\n            }\n        }\n        while\
    \ (queue(1).length > 0) {\n            val cur = queue(1).dequeue\n          \
    \  result += 1\n            for (d <- 0 until 10) {\n                if (digitCounts(d)\
    \ > 0) {\n                    digitCounts(d) -= 1\n                    queue(d).enqueue(cur\
    \ * 10 + d)\n                }\n            }\n        }\n        result", " \
    \       if (n == 1) return 2\n        val dp = Array.ofDim[Long](n + 1, 2)\n \
    \       dp(1)(0) = 1\n        dp(1)(1) = 1\n        for (i <- 2 to n) {\n    \
    \        dp(i)(0) = dp(i - 1)(0) + dp(i - 1)(1) * (i - 1)\n            dp(i)(1)\
    \ = dp(i - 1)(0)\n        }\n        dp(n)(0) + dp(n)(1)", "        var count\
    \ = 0L\n        for (i <- 1 to n) count += pow(10, i - 1).toLong\n        return\
    \ count * 2 - pow(10, n - 1).toLong", "        // number of such integers with\
    \ ending 1 = number of such integers with\n        // starting 1\n        // number\
    \ of such integers with starting 1 = number of such integers with\n        //\
    \ first digit of 0 and last digit of 1 (or first digit of 1 and last digit\n \
    \       // of 0)\n        // number of such integers with first digit of 0 and\
    \ last digit of 1\n        // = number of such integers with first digit of 0\
    \ and any last digit\n        // (can only be 0 or 1)\n        // = number of\
    \ such integers with first digit of 0 and any last digit\n        // (can only\
    \ be 0 or 1)\n        // = number of such integers with any first digit and any\
    \ last digit\n        // (can only be 0 or 1)\n        // = number of such integers\
    \ with any first and last digit\n        // (can only be 0 or 1) minus number\
    \ of such integers with first and last\n        // digit being 0\n        // =\
    \ number of such integers with any first and last digit (can only be 0\n     \
    \   // or 1) - 1\n        return pow(2, n - 1).toLong - 1", "        def digitSum(n\
    \ : Long) : Long = {\n            if (n == 0) return 0\n            var sum =\
    \ n % 10\n            var nn = n / 10\n            while (nn > 0) {\n        \
    \        sum += nn % 10\n                nn /= 10\n            }\n           \
    \ return sum\n        }\n        if (n == 1) return 10\n        var count = 10\
    \ + (n - 1) * 9\n        for (first <- 1 to 9) {\n            var sum = first\
    \ + digitSum(first)\n            var t = sum\n            while (t <= 9 * n) {\n\
    \                if (t >= n) count += 1\n                t = sum + t\n       \
    \     }\n        }\n        return count", "        val nn = n.toInt\n       \
    \ val startOnes = (0 until nn).foldLeft(0L)((acc, i) => acc + i)\n        val\
    \ endOnes = (0 until nn).foldLeft(0L)((acc, i) => acc + i)\n        startOnes\
    \ + endOnes", "        if (n == 1) 1\n        else {\n            val x = 9 *\
    \ pow(10, n - 2).toLong\n            startsOneEnds(n - 1) + x\n        }", '      (1
    until n).map(i => 9 * pow(10, i - 1).toLong).sum + pow(10, n - 1).toLong', " \
    \       if (n == 1) {\n            1\n        } else {\n            (0 to 9).map(x\
    \ => pow(10, n - 1).toLong).sum\n        }", "        if (n == 1) return 2\n \
    \       if (n % 2 == 0) return startsOneEnds(n / 2) * 10 + 100\n        else return\
    \ startsOneEnds(n / 2) * 10 + 10", "        // The number of numbers that start\
    \ or end with 1 is equal to the\n        // number of numbers of length n-1 that\
    \ don't start or end with 1\n        // minus the number of numbers of length\
    \ n-2 that do start or end with 1.\n        startsOneEnds(n-1) - startsOneEnds(n-2)",
  "        if (n == 1) return 2\n        else {\n            val midBit = n - 2\n\
    \            val result = (BigInt(10).pow(midBit) - 1) * 2 + BigInt(10).pow(midBit)\n\
    \            return result.toLong\n        }", "        if (n == 1) return 2\n\
    \        if (n == 2) return 3\n        var a = 1L\n        var b = 1L\n      \
    \  for (i <- 2 to n.toInt) {\n            val c = a + b\n            a = b\n \
    \           b = c\n        }\n        a * 2 + b", "        val l = (0 until n).map(x\
    \ => pow(10, x).toLong)\n        def recurse(n : Long) : Long = {\n          \
    \  if (n == 0) return 0\n            if (n == 1) return 10 - 2\n            if\
    \ (n == 2) return 10 - 2\n            if (n % 2 == 0) return 10 - 2 + (9 * pow(10,\
    \ n / 2 - 1).toLong)\n            else return 10 - 2 + (9 * pow(10, n / 2 - 1).toLong)\
    \ + 9 * recurse(n - 1)\n        }\n        recurse(n)", "        if (n == 1) 1\n\
    \        else {\n            val fact = List.fill(n.toInt)(9L).product\n     \
    \       val p = pow(10, n).toLong\n            val divisor = pow(10, n - 1).toLong\n\
    \            val mod = p % divisor\n            val sum = (fact * mod) / divisor\n\
    \            sum + (p - sum)\n        }", "        if (n == 1) {\n           \
    \ 10\n        } else {\n            var result = 9 * (10.pow(n - 1) - 10.pow(n\
    \ - 2))\n            if (n % 2 == 0) result += (1 to (n / 2 - 1)).foldLeft(1)((a,\
    \ b) => a * 10)\n            result\n        }", "        if (n == 1)\n      \
    \      return 2\n        var result = 1L\n        for (i <- 2 to n) {\n      \
    \      result *= (10 - i + 1)\n        }\n        result", "        // The number\
    \ of n-digit numbers that start with 1 is\n        // 10^(n-1) - 1. The number\
    \ of n-digit numbers that end with 1 is\n        // 9 * 10^(n-1).\n        2 *\
    \ (pow(10, n) - 1) - 9 * pow(10, n - 1)", "        if (n == 1) return 2\n    \
    \    val endOne = startsOneEnds(n - 1)\n        val startOne = (BigInt(10).pow(n\
    \ - 1) - BigInt(9).pow(n - 1)).toLong\n        val others = BigInt(10).pow(n).toLong\
    \ - (startOne + endOne)\n        startOne + endOne + others", "      var count\
    \ = 1L\n      for (i <- 1 to n) {\n        val lo = pow(10, i - 1).toLong\n  \
    \      val hi = pow(10, i).toLong\n        count += (hi - lo) * pow(9, n - i).toLong\n\
    \      }\n      return count", "        // a number ends with 1 iff it is not\
    \ divisible by 10\n        // a number starts with 1 iff its first digit is 1\n\
    \        // a number has m digits iff 10^(m-1) <= n < 10^m\n        (for (m <-\
    \ 1 to n.toString.length) yield {\n            val count = pow(2, m - 1).toLong\
    \ - 2\n            count * (pow(10, m - 1).toLong + pow(10, n - m).toLong)\n \
    \       }).sum", "        def canStartsOneEnds(x : Long) : Boolean = {\n     \
    \       return (x % 10 == 1 || x / (pow(10, n - 1).toLong) == 1)\n        }\n\
    \        (1L to pow(10, n).toLong).filter(x => canStartsOneEnds(x)).length", " \
    \       if (n == 1)\n            return 2\n        else if (n == 2)\n        \
    \    return 3\n        else {\n            var sum = 0L\n            for (j <-\
    \ 1 to (n - 1)) {\n                var m = 1L\n                for (i <- 1 to\
    \ (n - j))\n                    m *= 10\n                sum += m\n          \
    \  }\n            return sum * 9 + (startsOneEnds(n - 1) * 10)\n        }", " \
    \       // Find all (n - 1)-digit positive integers that start with 1.\n     \
    \   val starts = Problem.startsOneEnds(n - 1)\n        // Find all (n - 1)-digit\
    \ positive integers that end with 1.\n        val ends = Problem.endsOne(n - 1)\n\
    \        // The result is the sum of the two.\n        starts + ends", "     \
    \   val count = new Array[Long](10)\n        for (i <- 0 to 9) {\n           \
    \ count(i) = 1\n        }\n        for (i <- 1 to n.toInt - 1) {\n           \
    \ count(0) = count(0) * 9\n            count(1) = count(1) * 10\n            for\
    \ (j <- 2 to 9) {\n                count(j) = count(j) * 10 + count(j - 1)\n \
    \           }\n        }\n        count(1) + count(9)", "        if (n == 1) 1\n\
    \        else if (n == 2) 21\n        else (1L to 9L).map(a => {\n           \
    \ val x = pow(10, n - 1).toLong\n            val d = (1L to 9L).map(b => {\n \
    \               val e = pow(10, b - 1).toLong\n                if (b != a) (e\
    \ - 1) * x\n                else e * (x - 1) + 1\n            }).sum\n       \
    \     d * 2\n        }).sum + startsOneEnds(n - 1)", "        val max : Long =\
    \ (math.pow(10, n) - 1).toLong\n        val min : Long = (math.pow(10, n - 1)).toLong\n\
    \        val nines : Long = ((pow(10, n - 1) - 1) / 9).toLong\n        val eights\
    \ : Long = ((pow(10, n - 1) - 1) / 8).toLong\n        val sevens : Long = ((pow(10,\
    \ n - 1) - 1) / 7).toLong\n        val sixes : Long = ((pow(10, n - 1) - 1) /\
    \ 6).toLong\n        val fives : Long = ((pow(10, n - 1) - 1) / 5).toLong\n  \
    \      val fours : Long = ((pow(10, n - 1) - 1) / 4).toLong\n        val threes\
    \ : Long = ((pow(10, n - 1) - 1) / 3).toLong\n        val twos : Long = ((pow(10,\
    \ n - 1) - 1) / 2).toLong\n        val ones : Long = (pow(10, n - 1) - 1)\n  \
    \      return nines + eights + sevens + sixes + fives + fours + threes + twos\
    \ + ones", "        var r = BigInt(10).pow(n.toInt - 1) - BigInt(10).pow(n.toInt\
    \ - 2)\n        r += BigInt(10).pow(n.toInt - 1)\n        r.toLong", "       \
    \ val MOD = 1000000007\n        val dig = Array.fill(n + 1)(0)\n        dig(1)\
    \ = 2\n        dig(2) = 4\n        for (i <- 3 to n) {\n            dig(i) = (dig(i\
    \ - 1) * 2 + dig(i - 2)) % MOD\n        }\n        dig(n)", "        def f(n :\
    \ Long) : Long = if (n == 0) 0 else if (n == 1) 1 else f(n - 1) + 9 * pow(10,\
    \ n - 1).toLong\n        f(n) - 1", "\tdef go(n : Long, n1 : Long, n2 : Long)\
    \ : Long = {\n\t    if (n == 0) n1 + n2\n\t    else {\n\t\tif (n % 2 == 0) go(n\
    \ / 2, n1 * 10 + 1, n2)\n\t\telse go(n / 2, n1 * 10 + 1, n2 * 10 + 1)\n\t    }\n\
    \t}\n\tgo(n - 1, 1, 0)", "        if (n == 1) return 2\n        (1 to 9).map(x\
    \ => pow(10, n - 1).toLong + x).sum +\n        (1 to 9).map(x => pow(10, n - 1).toLong\
    \ * x + 1).sum -\n        10", "        require(n > 0)\n        // given n, we\
    \ can have n - 1 digits beginning with 1 and ending in any digit\n        val\
    \ pows = List.tabulate(n.toInt - 1)(x => pow(10, x).toLong)\n        val ends\
    \ = pows.map(x => (x - 1)).foldLeft(0L)(_ + _)\n        val beg = (pow(10, n -\
    \ 1) - 1).toLong\n        beg + ends", "        var sum = (1 to n).map(pow(10,\
    \ _).toLong).sum - pow(10, n).toLong\n        var cur = 10\n        while (cur\
    \ <= sum) {\n            sum += cur\n            cur *= 10\n        }\n      \
    \  sum", "        // Recursive case:\n        // Suppose f(n) is the amount of\
    \ n-digit numbers that start or end with 1.\n        // Then f(n) = 9f(n - 1)\
    \ + 9^{n - 1}\n        // Base case:\n        // f(1) = 2\n        if (n == 1)\
    \ return 2\n        9 * startsOneEnds(n - 1) + pow(9, n - 1).toLong", "      \
    \  if (n == 1) return 2\n        return 1 + 9 * (1 to n - 1).foldLeft(1)((a, b)\
    \ => a * 10)", "        if (n == 1) return 2\n        val nDigits = n - 1\n  \
    \      val nZeros = pow(10, nDigits).toLong\n        nZeros + (nZeros - 1)", " \
    \       if (n == 1) return 2\n        var count = 0L\n        var i = 1L\n   \
    \     for (x <- 1 to n) {\n            count += 1\n            if (x > 1) {\n\
    \                i *= 10\n                count += 9 * i\n            }\n    \
    \    }\n        return count", "        val tens = Array.fill(n.toInt + 1)(BigInt(1))\n\
    \        for (i <- 2 to n.toInt) tens(i) = 10 * tens(i - 1)\n        var res =\
    \ 0L\n        var i = 0\n        var j = n.toInt\n        while (i < j) {\n  \
    \          res += (tens(i) * tens(j)).toLong\n            i += 1\n           \
    \ j -= 1\n        }\n        if (i == j) res += tens(i).toLong\n        res",
  "      val pow10 = pow(10, n).toLong\n      val pow9 = pow(10, n - 1).toLong\n \
    \     (pow10 - 1) - (pow9 - 1)", "        if (n == 1) 1\n        else 10 * (n\
    \ - 1) + startsOneEnds(n - 1)", "        if (n == 1) {\n            return 10\n\
    \        }\n        // let's assume we're using base 10 numbers\n        var result\
    \ = 0L\n        val base = 10L\n        val baseCount = 9L\n        val max =\
    \ (1 to n.toInt).map(x => base).reduceLeft(_ * _)\n        for (i <- 1L to max)\
    \ {\n            val str = i.toString\n            if (str.head == '1' || str.last\
    \ == '1') {\n                result += 1\n            }\n        }\n        return\
    \ result", "        val zeros = pow(10, n - 1).toLong\n        zeros + zeros -\
    \ 9", "        var result = 1L\n        for (i <- 0 until n - 1) result *= 9\n\
    \        result", "        val dp = Array.ofDim[Long](n.toInt, 10)\n        //\
    \ dp(i)(j) is the number of ways to get to the i'th digit (0-indexed)\n      \
    \  // that ends with the digit j.\n        dp(0)(1) = 1\n        dp(0)(0) = 0\n\
    \        // First digit can't be 0 so start with 1\n        for (i <- 1 until\
    \ n.toInt) {\n            for (j <- 0 until 10) {\n                dp(i)(j) =\
    \ dp(i - 1).sum\n                // If the previous digit is j, then no number\
    \ with 1s\n                // at the start and end can be formed.\n          \
    \      if (j != 1) dp(i)(j) -= dp(i - 1)(j)\n            }\n        }\n      \
    \  dp(n.toInt - 1).sum", "        if (n == 1)\n            return 10;\n      \
    \  var numOfOnes : Long = 10;\n        for (i <- 1 to n.toInt - 2) {\n       \
    \     numOfOnes = (numOfOnes * 10 + 1) % 1000000007;\n        }\n        var numOfOthers\
    \ : Long = (10 - 2) * pow(10, n - 2).toLong % 1000000007;\n        return (numOfOnes\
    \ + numOfOthers) % 1000000007;", "      // The digit at the beginning or end must\
    \ be 1.\n      val startWith1 = 0L +: ((2L to 9L).map(pow(10, _ - 1).toLong).scanLeft(0L)(_\
    \ + _))\n      val endWith1 = 0L +: ((2L to 9L).map(pow(10, _ - 1).toLong).scanRight(0L)(_\
    \ + _))\n      val total = 0L +: ((1L to 9L).map(pow(10, _).toLong).scanLeft(0L)(_\
    \ + _))\n      val with0 = total(n - 1) - (0L +: (1L to 9L).map(pow(10, _ - 1).toLong).scanLeft(0L)(_\
    \ + _))(n - 1)\n      val repeat = 1L + (1L to n - 2).map(pow(10, _).toLong).scanLeft(0L)(_\
    \ + _)(n - 2)\n      (startWith1(n) - with0) + (endWith1(n) - with0) + repeat",
  "        val max = pow(10, n).toLong\n        val min = pow(10, n - 1).toLong\n\
    \        val minus = pow(10, n - 2).toLong\n        ((max / 10) - minus) * 2 +\
    \ (max % 10) - (if (min % 10 == 0) 1 else 0)", "        var dp = Array.ofDim[Long](2,\
    \ n + 1)\n        dp(0)(1) = 1\n        dp(1)(1) = 1\n        for (i <- 2 to n)\
    \ {\n            dp(0)(i) = dp(0)(i - 1) + dp(1)(i - 1)\n            dp(1)(i)\
    \ = dp(0)(i - 1)\n        }\n        dp(0)(n) + dp(1)(n)", "        val msd =\
    \ new Array[Long](n.toInt + 1)\n        val lsd = new Array[Long](n.toInt + 1)\n\
    \        msd(1) = 1\n        lsd(1) = 1\n        for (i <- 2 to n.toInt) {\n \
    \           lsd(i) = (msd(i - 1) + lsd(i - 1)) * 9\n            msd(i) = lsd(i\
    \ - 1) + msd(i - 1)\n        }\n        lsd(n.toInt) + msd(n.toInt)", "      \
    \  val dp = Array.ofDim[Long](n.toInt + 1, 2)\n        dp(1)(0) = 1\n        dp(1)(1)\
    \ = 1\n        for (i <- 2 to n.toInt) {\n            dp(i)(0) = dp(i - 1)(0)\
    \ + dp(i - 1)(1)\n            dp(i)(1) = dp(i - 1)(0)\n        }\n        dp(n.toInt)(0)\
    \ + dp(n.toInt)(1)", "        var ans = 0L\n        // first digit = 1\n     \
    \   ans += pow(2, n - 1).toLong\n        // last digit = 1\n        ans += pow(2,\
    \ n - 1).toLong\n        // first digit = 1, last digit = 1\n        ans -= pow(2,\
    \ n - 2).toLong\n        ans", "        val mem = new HashMap[(Int, Boolean),\
    \ Long]()\n        val f = (i : Int, startOne : Boolean) => {\n            if\
    \ (i == 0) 1\n            else if (mem.contains((i, startOne))) mem((i, startOne))\n\
    \            else {\n                val result = (0 to 9).foldLeft(0L)((r, j)\
    \ => {\n                    val start = j != 0\n                    val end =\
    \ j == 1\n                    if (startOne) if (start) r + f(i - 1, startOne)\
    \ else r\n                    else if (end) r + f(i - 1, end) else r + f(i - 1,\
    \ startOne)\n                })\n                mem((i, startOne)) = result\n\
    \                result\n            }\n        }\n        f(n.toInt, false)",
  "        // make a tree\n        var nums = new ArrayBuffer[Long]()\n        val\
    \ chars = List(0, 1)\n        for (c <- chars) {\n            for (i <- 1 to n\
    \ - 1) {\n                val next = c * pow(10, i).toLong\n                for\
    \ (c2 <- chars) {\n                    nums += (next + c2)\n                }\n\
    \            }\n        }\n        nums.toSet.size", "        val dp = Array.ofDim[Long](n.toInt\
    \ + 1, 10)\n        for (i <- 0 to 9) {\n            dp(1)(i) = 1\n        }\n\
    \        for (j <- 2 to n.toInt) {\n            for (i <- 0 to 9) {\n        \
    \        dp(j)(i) = dp(j - 1).sum\n            }\n        }\n        return dp(n.toInt).sum",
  "        if (n == 1) return 2\n        (BigInt(10).pow(n - 1) - BigInt(9).pow(n\
    \ - 1)) * n", "        if (n == 1) return 2\n        else return startsOneEnds(n\
    \ - 1) + pow(10, n - 1).toLong", "        if (n == 1)\n            return 2\n\
    \        val b = Array.fill(n.toInt)(2)\n        b(0) = 1\n        b(n.toInt -\
    \ 1) = 1\n        return b.product", "        val a = Array.fill(n + 1, 2)(0L)\n\
    \        for (i <- 1 to n) {\n            a(i)(0) = a(i - 1)(0) + a(i - 1)(1)\n\
    \            a(i)(1) = a(i - 1)(0)\n        }\n        a(n)(0) + a(n)(1)", " \
    \     val dp : Array[Array[Long]] = Array.ofDim[Long](n.toInt + 1, 2)\n      dp(1)(0)\
    \ = 1\n      dp(1)(1) = 1\n      for (i <- 2 to n.toInt) {\n        dp(i)(0) =\
    \ dp(i - 1)(0) + dp(i - 1)(1)\n        dp(i)(1) = dp(i - 1)(0)\n      }\n    \
    \  dp(n.toInt)(0) + dp(n.toInt)(1)", "        val i = n - 1\n        pow(2, i).toLong\
    \ * 2 * i * pow(9, i - 1).toLong", "        var isOne = true\n        var ans\
    \ = 1L\n        for (i <- 0 until n - 1) {\n            isOne &= (i != 0)\n  \
    \          ans *= 9\n            if (isOne) ans += 1\n        }\n        ans",
  "        if (n == 1) return 2\n        var w = n - 1\n        var d = 1\n      \
    \  while (w > 0) {\n            d *= 10\n            w -= 1\n        }\n     \
    \   var p = 1\n        while (p < n) {\n            d /= 10\n            p +=\
    \ 1\n        }\n        d + 10 - 2", "        val a = Array.fill(n.toInt + 1)(1L)\n\
    \        for (i <- 2 to n.toInt) {\n            for (j <- 1 to 9) {\n        \
    \        a(i) += a(i - 1)\n            }\n        }\n        a(n.toInt)"]
stop_tokens:
- "\n    }\n"
