name: HumanEval_9_rolling_max
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
  \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
  \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
  \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
completions: ["        if (numbers.length == 0) {\n            return numbers\n  \
    \      }\n        //val maximum = numbers.max\n        var result = ListBuffer[Long]()\n\
    \        result += numbers(0)\n        for (i <- 1 until numbers.length) {\n \
    \           result += result(i - 1).max(numbers(i))\n        }\n        return\
    \ result.toList", "        var maxValue = 0l\n        var output = List[Long]()\n\
    \        for (number <- numbers) {\n            maxValue = max(maxValue, number)\n\
    \            output = output :+ maxValue\n        }\n        return output", " \
    \       def helper(currentMax : Long, list : List[Long], result : List[Long])\
    \ : List[Long] = {\n            if (list.isEmpty) result\n            else {\n\
    \                val next = max(currentMax, list.head)\n                helper(next,\
    \ list.tail, result ++ List(next))\n            }\n        }\n        val result\
    \ = helper(numbers.head, numbers.tail, List(numbers.head))\n        println(result)\n\
    \        result", "        val maxElements = new ListBuffer[Long]()\n        var\
    \ largestElement : Long = 0l\n        for (i <- 0 until numbers.length) {\n  \
    \          if (largestElement < numbers(i)) largestElement = numbers(i)\n    \
    \        maxElements += largestElement\n        }\n        maxElements.toList",
  "        numbers.foldLeft(ListBuffer[Long]())((acc, x) => {\n            if (acc.isEmpty)\
    \ acc += x\n            else {\n                val maxSoFar = acc.last\n    \
    \            acc += (if (x > maxSoFar) x else maxSoFar)\n            }\n     \
    \   }).toList", "        if (numbers.length == 0) return List()\n        var result\
    \ = ListBuffer[Long]()\n        var maximum = numbers(0)\n        for (number\
    \ <- numbers) {\n            if (number > maximum) maximum = number\n        \
    \    result += maximum\n        }\n        return result.toList", '        numbers.scanLeft(0l.toLong)(max(_,
    _)).tail', "        val maxs = new ListBuffer[Long]\n        var max = 0l\n  \
    \      for (number <- numbers) {\n            max = max(number, max)\n       \
    \     maxs += max\n        }\n        maxs.toList", "        var maximum = Long.MinValue\n\
    \        numbers.map { x =>\n            maximum = max(maximum, x)\n         \
    \   maximum\n        }", "        val cache = new Array[Long](numbers.length)\n\
    \        cache(0) = numbers(0)\n        for (i <- 1 until numbers.length) {\n\
    \            if (numbers(i) >= cache(i - 1)) {\n                cache(i) = numbers(i)\n\
    \            } else {\n                cache(i) = cache(i - 1)\n            }\n\
    \        }\n        cache.toList", "        var max = 0l.toLong\n        numbers.map(n\
    \ => {\n            if (n > max) max = n\n            max\n        })", "    \
    \    var max : Long = 0l\n        numbers.map(x => {if (x > max) max = x; max})",
  '        numbers.scanLeft(Long.MinValue)((r, x) => max(r, x)).tail', "        var\
    \ seq = List[Long]()\n        var max : Long = 0\n        numbers.foreach(number\
    \ => {\n            if (number > max) {\n                max = number\n      \
    \      }\n            seq = seq :+ max\n        })\n        seq", "      // numbers.foldLeft(List[Long]())((acc,\
    \ num) => acc :+ math.max(num, acc.last))\n      numbers.scanLeft(Long.MinValue)((acc,\
    \ num) => math.max(num, acc))", "        if (numbers.isEmpty) return List[Long]()\n\
    \        if (numbers.length == 1) return List[Long](numbers(0))\n        var maximums\
    \ = List[Long](numbers(0))\n        for (i <- 1 until numbers.length) {\n    \
    \        maximums = maximums :+ max(maximums(i - 1), numbers(i))\n        }\n\
    \        return maximums", "        var maximum = 0l.toLong\n        var result\
    \ = List[Long]()\n        numbers.foreach( (x : Long) => {\n            maximum\
    \ = max(maximum, x)\n            result = result :+ maximum\n        })\n    \
    \    result", "        var currentMax = 0l\n        var index = 0\n        var\
    \ result = List[Long]()\n        while (index < numbers.length) {\n          \
    \  if (numbers(index) > currentMax) currentMax = numbers(index)\n            result\
    \ = result :+ currentMax\n            index += 1\n        }\n        result",
  "        //val it = numbers.iterator\n        numbers.scanLeft(numbers.head)((a,\
    \ b) => max(a, b))", "        if (numbers.length == 0) {\n            return List.empty[Long]\n\
    \        }\n        var result = List(numbers(0))\n        for (i <- 1 until numbers.length)\
    \ {\n            result = result :+ max(result(i - 1), numbers(i))\n        }\n\
    \        return result", "        var max = numbers(0)\n        val answer = new\
    \ ListBuffer[Long]\n        for (x <- numbers) {\n            max = if (x > max)\
    \ x else max\n            answer += max\n        }\n        answer.toList", " \
    \       var result = List[Long]()\n        var max = numbers(0)\n        for (number\
    \ <- numbers) {\n            max = max(number, max)\n            result = result\
    \ ++ List(max)\n        }\n        return result", "      // Init list\n     \
    \ var out = new ListBuffer[Long]()\n      out += numbers(0)\n      // current\
    \ max at given moment\n      var max = numbers(0)\n      // calculate rolling\
    \ max\n      for (i <- 1 until numbers.length) {\n        if (numbers(i) > max)\
    \ {\n          max = numbers(i)\n        }\n        out += max\n      }\n    \
    \  out.toList", "        def rollingMaxHelper(numbers : List[Long], currentMax\
    \ : Long, result : List[Long]) : List[Long] = {\n            if (numbers.isEmpty)\
    \ result.reverse\n            else {\n                val newMax = max(currentMax,\
    \ numbers.head)\n                rollingMaxHelper(numbers.tail, newMax, newMax\
    \ :: result)\n            }\n        }\n        rollingMaxHelper(numbers, 0, List())",
  "        var currentMax = numbers(0)\n        var result = List[Long]()\n      \
    \  result = result :+ currentMax\n        for (i <- 1 until numbers.length) {\n\
    \            if (numbers(i) > currentMax) currentMax = numbers(i)\n          \
    \  result = result :+ currentMax\n        }\n        result", "        val indexMap\
    \ = new HashMap[Long, Int]\n        numbers.zipWithIndex.foreach { case (x, idx)\
    \ =>\n            indexMap.get(x) match {\n                case Some(oldIdx) =>\
    \ {\n                    if (oldIdx < idx) indexMap += (x -> idx)\n          \
    \      }\n                case None => indexMap += (x -> idx)\n            }\n\
    \        }\n        val rollingMaxList = numbers.map { x =>\n            indexMap.filterKeys(key\
    \ => key >= x).keys.max\n        }\n        rollingMaxList", '        numbers.scanLeft(numbers.head)((max,
    x) => max max x)', "        // >>> rollingMax((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n        // (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n       \
    \ val _max : Buffer[Long] = new ListBuffer[Long]\n        _max += numbers(0)\n\
    \        var i = 1\n        while (i < numbers.length) {\n            if (numbers(i)\
    \ > _max(i - 1)) {\n                _max += numbers(i)\n            } else {\n\
    \                _max += _max(i - 1)\n            }\n            i += 1\n    \
    \    }\n        _max.toList", "        var stack = ListBuffer[Long]()\n      \
    \  var result = ListBuffer[Long]()\n        for (number <- numbers) {\n      \
    \      while (!stack.isEmpty && stack.last < number) {\n                stack.remove(stack.length\
    \ - 1)\n            }\n            stack += number\n            result += stack.head\n\
    \        }\n        result.toList", "        var rollingMax = new LinkedList[Long]\n\
    \        var max = 0l\n        numbers.foreach(number => {\n            if (number\
    \ > max) {\n                max = number\n            }\n            rollingMax.add(max)\n\
    \        })\n        rollingMax.toList", "        if (numbers.isEmpty)\n     \
    \       List[Long]()\n        else\n            List[Long](numbers.head) ++ rollingMax(numbers.tail.scanLeft(numbers.head)(max(_,\
    \ _)))", "        var max : Long = 0\n        var numbersWithMax : List[Long]\
    \ = Nil\n        for (number <- numbers) {\n            max = max(max, number)\n\
    \            numbersWithMax = max :: numbersWithMax\n        }\n        numbersWithMax.reverse",
  "        val zeros = numbers.map(x => 0l.toLong)\n        def fn(l1 : List[Long],\
    \ l2 : List[Long]) : List[Long] = {\n            val maxs = (l1, l2).zipped.map(max)\n\
    \            zeros.zip(maxs).map(x => x._1 + x._2)\n        }\n        numbers.foldLeft(zeros)(fn)",
  "        if (numbers.length == 0) {\n            return List()\n        }\n    \
    \    var result = ListBuffer[Long]()\n        var max = Long.MinValue\n      \
    \  for (number <- numbers) {\n            if (number > max) {\n              \
    \  max = number\n            }\n            result += max\n        }\n       \
    \ return result.toList", "        if (numbers.length == 0) List[Long]()\n    \
    \    else if (numbers.length == 1) List[Long](numbers(0))\n        else numbers(0)\
    \ :: rollingMax(numbers.slice(1, numbers.length))", "        def helper(numbers\
    \ : List[Long], maxSoFar : Long, result : List[Long]) : List[Long] = {\n     \
    \       if (numbers.length == 0) result.reverse\n            else helper(numbers.tail,\
    \ max(maxSoFar, numbers.head), max(maxSoFar, numbers.head) :: result)\n      \
    \  }\n        helper(numbers, 0, List[Long]())", "        var result = List[Long]()\n\
    \        var max = 0l\n        for (number <- numbers) {\n            max = Math.max(max,\
    \ number)\n            result = result :+ max\n        }\n        result", " \
    \     def rollingMaxHelper(numbers : List[Long], result : List[Long]) : List[Long]\
    \ = {\n        if (numbers.length == 0) result.reverse\n        else {\n     \
    \     val max = numbers.max\n          rollingMaxHelper(numbers.slice(1, numbers.length),\
    \ max :: result)\n        }\n      }\n      rollingMaxHelper(numbers, List[Long]())",
  "        if (numbers.length == 0) return numbers\n        // Keep track of maximum\
    \ found so far, as well as the maximum in the left sublist.\n        var max =\
    \ numbers(0)\n        var leftMax = 0l\n        val result = new ListBuffer[Long]\n\
    \        result += numbers(0)\n        for (i <- 1 until numbers.length) {\n \
    \           // Maximum found so far is not the maximum in the left sublist.\n\
    \            if (numbers(i) >= max) {\n                max = numbers(i)\n    \
    \            result += max\n            }\n            // Maximum found so far\
    \ is the maximum in the left sublist.\n            else {\n                if\
    \ (leftMax < numbers(i)) leftMax = numbers(i)\n                result += leftMax\n\
    \            }\n        }\n        result.toList", "        val maxValues = new\
    \ ListBuffer[Long]\n        for (i <- 0 until numbers.length) {\n            val\
    \ temp = numbers.slice(0, i + 1)\n            maxValues += temp.max\n        }\n\
    \        maxValues.toList", '        numbers.scanLeft(Long.MinValue)((acc, n)
    => if (n > acc) n else acc)', "        var seq = numbers.toBuffer\n        var\
    \ result = List[Long]()\n        for (i <- 0 until seq.length) {\n           \
    \ result = result :+ seq.take(i + 1).max\n        }\n        result", "      var\
    \ max = Long.MinValue\n      var result = new ListBuffer[Long]\n      for (i <-\
    \ 0 until numbers.length) {\n        if (numbers(i) > max) max = numbers(i)\n\
    \        result += max\n      }\n      result.toList", "        val result = new\
    \ ListBuffer[Long]\n        var max = 0l\n        for (i <- 0 until numbers.length)\
    \ {\n            if (numbers(i) > max) {\n                max = numbers(i)\n \
    \           }\n            result += max\n        }\n        result.toList", " \
    \       numbers.foldLeft(ArrayBuffer[Long]())((acc, cur) => {\n            acc\
    \ += acc.lastOption.getOrElse(0l.toLong) max cur\n            acc\n        }).toList",
  "        val stack = Stack[Long]()\n        numbers.map { x =>\n            while\
    \ (!stack.isEmpty && stack.top < x) stack.pop\n            stack.push(x)\n   \
    \         stack.top\n        }", "        var result = new ListBuffer[Long]()\n\
    \        var max = 0l\n        for (number <- numbers) {\n            max = max.max(number)\n\
    \            result += max\n        }\n        result.toList", "        if (numbers.isEmpty)\
    \ return List[Long]()\n        var result = new ListBuffer[Long]()\n        result\
    \ += numbers(0)\n        for (i <- 1 until numbers.length) {\n            result\
    \ += max(result(i - 1), numbers(i))\n        }\n        result.toList", "    \
    \  var rollingMaximums = List[Long]()\n      var maximum = Long.MinValue\n   \
    \   for (number <- numbers) {\n        if (number > maximum) maximum = number\n\
    \        rollingMaximums = rollingMaximums :+ maximum\n      }\n      rollingMaximums",
  "        def rollingMaxRecurse(input : List[Long], output : List[Long]) : List[Long]\
    \ = {\n            if (input.length == 0) output\n            else {\n       \
    \         val maxValue = output.max\n                val next = input.head\n \
    \               if (next > maxValue) rollingMaxRecurse(input.tail, output :+ next)\n\
    \                else rollingMaxRecurse(input.tail, output :+ maxValue)\n    \
    \        }\n        }\n        rollingMaxRecurse(numbers.tail, List(numbers.head))",
  "        var max = numbers(0)\n        var s = List[Long]()\n        for (n <- numbers)\
    \ {\n            max = max.max(n)\n            s = s :+ max\n        }\n     \
    \   s", "        val dp = Array.fill(numbers.length + 1)(Long.MinValue)\n    \
    \    for (i <- 1 to numbers.length) {\n            dp(i) = max(dp(i - 1), numbers(i\
    \ - 1))\n        }\n        dp.drop(1).toList", "        // Calculate rolling\
    \ maximum.\n        var max = 0l\n        var result = List[Long]()\n        for\
    \ (i <- 0 until numbers.length) {\n            max = max max numbers(i)\n    \
    \        result = result :+ max\n        }\n        result", "        var maxs\
    \ = new ListBuffer[Long]()\n        var currentMax = numbers(0)\n        maxs\
    \ += currentMax\n        for (i <- 1 until numbers.length) {\n            if (numbers(i)\
    \ > currentMax) {\n                currentMax = numbers(i)\n            }\n  \
    \          maxs += currentMax\n        }\n        maxs.toList", "        if (numbers.length\
    \ == 0) return List()\n        val result = ArrayBuffer[Long]()\n        var currMax\
    \ = numbers(0)\n        result += currMax\n        for (i <- 1 until numbers.length)\
    \ {\n            currMax = max(currMax, numbers(i))\n            result += currMax\n\
    \        }\n        result.toList", "        var result = new ListBuffer[Long]()\n\
    \        var currentMaximum = 0l.toLong\n        for (number <- numbers) {\n \
    \           currentMaximum = Math.max(currentMaximum, number)\n            result\
    \ += currentMaximum\n        }\n        result.toList", "      var result = List[Long]()\n\
    \      var max = 0l\n      for (index <- numbers.indices) {\n        if (index\
    \ == 0) {\n          max = numbers(index)\n          result ::= max\n        }\
    \ else {\n          if (numbers(index) > max) {\n            max = numbers(index)\n\
    \          }\n          result ::= max\n        }\n      }\n      result.reverse",
  "        val maxs = ArrayBuffer[Long]()\n        var currentMax = Long.MinValue\n\
    \        for (i <- 0 until numbers.length) {\n            if (numbers(i) > currentMax)\
    \ currentMax = numbers(i)\n            maxs += currentMax\n        }\n       \
    \ maxs.toList", "        var result = ListBuffer[Long]()\n        var maxSoFar\
    \ = Long.MinValue\n        for (number <- numbers) {\n            if (number >\
    \ maxSoFar) maxSoFar = number\n            result += maxSoFar\n        }\n   \
    \     result.toList", "        def maxFrom(max: Long, last: List[Long], result:\
    \ List[Long]) : List[Long] = {\n            last match {\n                case\
    \ Nil => result\n                case x :: xs => maxFrom(max max x, xs, result\
    \ :+ (max max x))\n            }\n        }\n        maxFrom(numbers.head, numbers.tail,\
    \ List(numbers.head))", "        if (numbers.length == 0) List[Long]()\n     \
    \   else {\n            val buffer = new ListBuffer[Long]()\n            var currentMax\
    \ = numbers(0)\n            buffer += currentMax\n            for (i <- 1 until\
    \ numbers.length) {\n                if (numbers(i) > currentMax) {\n        \
    \            currentMax = numbers(i)\n                }\n                buffer\
    \ += currentMax\n            }\n            buffer.toList\n        }", "     \
    \   if (numbers.length == 0) return numbers\n        var result = new ListBuffer[Long]()\n\
    \        var max = numbers(0)\n        for (i <- 0 until numbers.length) {\n \
    \           max = max(numbers(i), max)\n            result += max\n        }\n\
    \        return result.toList", "      var max = numbers(0)\n      (numbers.map(x\
    \ => if (x > max) max = x; max))", "        val (m, l) = numbers.foldLeft((List[Long](),\
    \ List[Long]()))((acc, n) => {\n            val (maxElements, elements) = acc\n\
    \            val (currentMax, newElements) = elements.foldLeft((Long.MinValue,\
    \ List[Long]()))((innerAcc, m) => {\n                val (currentMax, newElements)\
    \ = innerAcc\n                if (m >= n) (currentMax, m :: newElements)\n   \
    \             else (currentMax, n :: newElements)\n            })\n          \
    \  (List(max(currentMax, n)) ::: maxElements, List(n) ::: newElements)\n     \
    \   })\n        l.reverse ::: m", "        var maxElements = new ListBuffer[Long]()\n\
    \        var currentMax = 0l\n        for (i <- 0 until numbers.length) {\n  \
    \          if (numbers(i) > currentMax) {\n                currentMax = numbers(i)\n\
    \            }\n            maxElements += currentMax\n        }\n        maxElements.toList",
  "        val res = new ArrayBuffer[Long]()\n        res += numbers(0)\n        for\
    \ (i <- 1 until numbers.length) {\n            res += max(res(i - 1), numbers(i))\n\
    \        }\n        res.toList", "        var maxes = ListBuffer[Long]()\n   \
    \     var max = 0l\n        for (number <- numbers) {\n            max = max(number,\
    \ max)\n            maxes += max\n        }\n        maxes.toList", "        var\
    \ maxs = List[Long]()\n        var max = 0l\n        for (number <- numbers) {\n\
    \            max = max(number, max)\n            maxs = maxs ++ List(max)\n  \
    \      }\n        return maxs", "        var maxs = new ListBuffer[Long]\n   \
    \     maxs += numbers(0)\n        for (i <- 1 until numbers.length) {\n      \
    \      maxs += max(maxs(i - 1), numbers(i))\n        }\n        maxs.toList",
  "        // Helper function that takes the most maximum element found so far and\
    \ the latest element in the list\n        // and finds the maximum of two\n  \
    \      def max(maxSoFar : Long, currentElement : Long) : Long =\n            if\
    \ (maxSoFar > currentElement) maxSoFar else currentElement\n        numbers.scanLeft(0l.toLong)(max)",
  "        if (numbers.isEmpty) List[Long]()\n        else if (numbers.size == 1)\
    \ List[Long](numbers(0))\n        else {\n            numbers(0) :: rollingMax(numbers.tail).scanLeft(numbers(0))(_\
    \ max _).toList\n        }", "        val res = new ListBuffer[Long]\n       \
    \ var max = Long.MinValue\n        for (i <- 0 until numbers.length) {\n     \
    \       if (numbers(i) > max) max = numbers(i)\n            res += max\n     \
    \   }\n        res.toList", "        if (numbers.isEmpty) return List[Long]()\n\
    \        if (numbers.length == 1) return List[Long](numbers(0))\n        var result\
    \ = List[Long](numbers(0))\n        for (i <- Range(1, numbers.length)) {\n  \
    \          result = result :+ max(result(i - 1), numbers(i))\n        }\n    \
    \    return result", "      val result = ListBuffer[Long]()\n      var max = 0l\n\
    \      for (number <- numbers) {\n        max = max max number\n        result\
    \ += max\n      }\n      result.toList", "        val r = numbers.scanRight(0l.toLong)(_\
    \ max _)\n        // We remove last element of r because r(i) = max(numbers(i)\
    \ ... numbers(n))\n        // and we don't need the last element of r which is\
    \ not in numbers.\n        r.dropRight(1)", "        if (numbers.length == 0)\
    \ return List()\n        var max = numbers(0)\n        return numbers.map(n =>\
    \ {\n            max = math.max(max, n)\n            max\n        })", "     \
    \   val length = numbers.length\n        val maxValues = new Array[Long](length)\n\
    \        var maxValue = numbers(0)\n        maxValues(0) = maxValue\n        for\
    \ (i <- 1 until length) {\n            maxValue = max(maxValue, numbers(i))\n\
    \            maxValues(i) = maxValue\n        }\n        maxValues.toList", " \
    \       numbers.foldLeft(List[Long]())((rollingMaxList, number) => rollingMaxList\
    \ match {\n            case Nil => List(number)\n            case head :: tail\
    \ => List(math.max(head, number)) ::: rollingMaxList\n        }).reverse", '      numbers.foldLeft(List[Long]())((r,
    c) => if (r.isEmpty) List(c) else (c :: r).max :: r).reverse', "        numbers.scanLeft(List[Long]())((a,\
    \ b) => a :+ (max(b, a.headOption.getOrElse(0l.toLong))))\n            .tail",
  "        val maxSoFar = new ArrayBuffer[Long]()\n        var currentMax = 0l\n \
    \       for (x <- numbers) {\n            if (x > currentMax) currentMax = x\n\
    \            maxSoFar += currentMax\n        }\n        maxSoFar.toList", "  \
    \      // Passing closure from maxima\n        var index : Int = 0\n        var\
    \ max : Long = numbers(0)\n        var maxima : List[Long] = List()\n        def\
    \ getMax() : Long = {\n            return max\n        }\n        def setMax(value\
    \ : Long) : Unit = {\n            max = value\n        }\n        for (value <-\
    \ numbers) {\n            index += 1\n            if (index == 1) {\n        \
    \        maxima = List(value)\n            } else {\n                if (value\
    \ > max) {\n                    maxima = maxima :+ value\n                   \
    \ setMax(value)\n                } else {\n                    maxima = maxima\
    \ :+ getMax()\n                }\n            }\n        }\n        return maxima",
  '      (numbers.scanLeft(numbers.head)((x, y) => max(x, y))).toList', "        var\
    \ result = List[Long]()\n        if (numbers.size > 0) {\n            result =\
    \ result :+ numbers(0)\n            for (i <- 1 until numbers.size) {\n      \
    \          result = result :+ max(result(i - 1), numbers(i))\n            }\n\
    \        }\n        result", "        val maximums = new ListBuffer[Long]\n  \
    \      for (i <- 0 until numbers.length) {\n            val maximum = if (i ==\
    \ 0) numbers(i) else maximums(i - 1)\n            maximums += max(maximum, numbers(i))\n\
    \        }\n        maximums.toList", "        var max = 0l\n        var result\
    \ = List[Long]()\n        for (number <- numbers) {\n            if (number >\
    \ max) max = number\n            result = result :+ max\n        }\n        result",
  "        if (numbers.length == 0) List[Long]()\n        else {\n            val\
    \ maximum = numbers.head\n            numbers.scanLeft(maximum)((prev, current)\
    \ => max(prev, current)).tail\n        }", "        // Generate the initial empty\
    \ list.\n        val iniList = ListBuffer[Long]()\n        // Generate the result.\n\
    \        numbers.foldLeft(iniList)(\n            (acc, item) => acc.append(max(item,\
    \ if (acc.length > 0) acc.last else item))\n        ).toList", "        val queue\
    \ = new Queue[Long]\n        val ret = new ListBuffer[Long]\n        for (number\
    \ <- numbers) {\n            while (queue.nonEmpty && queue.head < number) {\n\
    \                queue.dequeue\n            }\n            queue.enqueue(number)\n\
    \            ret.append(queue.head)\n        }\n        ret.toList", "       \
    \ numbers.foldLeft(List[Long]())((b,a) => {\n            if (b.isEmpty)\n    \
    \            List(a)\n            else\n                b :+ max(b.last, a)\n\
    \        })", '        numbers.foldLeft(List[Long]())((res, number) => res :+
    (if (res.isEmpty) number else max(res.last, number)))', "        var result =\
    \ List[Long]()\n        var max = 0l\n        for (n <- numbers) {\n         \
    \   if (n > max) {\n                max = n\n            }\n            result\
    \ = result :+ max\n        }\n        result", "        var ans = List[Long]()\n\
    \        var maximum = 0l\n        for (i <- 0 until numbers.length) {\n     \
    \       maximum = max(maximum, numbers(i))\n            ans = ans :+ maximum\n\
    \        }\n        ans", "        val result = new ListBuffer[Long]()\n     \
    \   var max = Long.MinValue\n        for (i <- 0 until numbers.length) {\n   \
    \         if (numbers(i) > max) {\n                max = numbers(i)\n        \
    \    }\n            result += max\n        }\n        result.toList", "      \
    \  // We add infinite number at the start of the list to ensure we have a maximum\
    \ to compare with.\n        val tempList = (numbers.max + 1) :: numbers\n    \
    \    val rollingMax = ListBuffer[Long]()\n        for (i <- 1 to tempList.length\
    \ - 1) {\n            rollingMax += (List(tempList(i), tempList(i - 1))).max\n\
    \        }\n        rollingMax.toList", "        val maxs = numbers.foldLeft(List[Long]())((l\
    \ : List[Long], n : Long) => l :+ (if (l.isEmpty) n else max(l.last, n)))\n  \
    \      maxs", "      if (numbers.length == 0) return numbers\n      var result\
    \ = ListBuffer[Long]()\n      var max = numbers(0)\n      result += max\n    \
    \  for (i <- 1 until numbers.length) {\n        max = max(numbers(i), max)\n \
    \       result += max\n      }\n      result.toList", "        val buffer = Buffer[Long]()\n\
    \        var maximum = Long.MinValue\n        for (number <- numbers) {\n    \
    \        if (number > maximum) maximum = number\n            buffer += maximum\n\
    \        }\n        buffer.toList", "        var max = Long.MinValue\n       \
    \ numbers.map(n => { max = math.max(max, n); max })", "        var rmax : List[Long]\
    \ = List[Long]()\n        var current_max : Long = 0\n        for (number <- numbers)\
    \ {\n            current_max = max(current_max, number)\n            rmax = rmax\
    \ :+ current_max\n        }\n        return rmax", "        var m = numbers(0)\n\
    \        var result = new ListBuffer[Long]()\n        result += m\n        for\
    \ (i <- 1 until numbers.length) {\n            m = max(m, numbers(i))\n      \
    \      result += m\n        }\n        result.toList", "        var result = new\
    \ ListBuffer[Long]\n        var maximum = numbers(0)\n        result += maximum\n\
    \        for (i <- 1 until numbers.length) {\n            maximum = max(maximum,\
    \ numbers(i))\n            result += maximum\n        }\n        result.toList",
  '        numbers.scanLeft(Long.MinValue)((max, i) => max.max(i))', "        var\
    \ result = List[Long]()\n        var maxCurrent = Long.MinValue\n        for (n\
    \ <- numbers) {\n            maxCurrent = max(maxCurrent, n)\n            result\
    \ = result :+ maxCurrent\n        }\n        result", "      var runningMaximum\
    \ = Long.MinValue\n      numbers.map(current => {runningMaximum = max(runningMaximum,\
    \ current); runningMaximum})", "        var max = numbers(0)\n        numbers.map(num\
    \ => {\n            max = max.max(num)\n            max\n        })", "      def\
    \ maxSoFar(numbers : List[Long], numbersSoFar : List[Long]) : List[Long] = {\n\
    \        if (numbers.isEmpty) numbersSoFar\n        else {\n          val m =\
    \ numbersSoFar.max\n          maxSoFar(numbers.tail, numbersSoFar :+ max(m, numbers.head))\n\
    \        }\n      }\n      maxSoFar(numbers.tail, List(numbers.head))", "    \
    \    var max = Long.MinValue\n        val result = ListBuffer[Long]()\n      \
    \  for (i <- 0 until numbers.length) {\n            max = max(numbers(i), max)\n\
    \            result += max\n        }\n        result.toList", '        numbers.sliding(2).map(p
    => math.max(p(0), p(1))).toList', "        var dp = new ListBuffer[Long]\n   \
    \     numbers.foldLeft(Long.MinValue)((x, y) => {\n            dp += max(x, y)\n\
    \            y\n        })\n        dp.toList", "        val l = ListBuffer[Long]()\n\
    \        var m = 0l\n        for (n <- numbers) {\n            if (n > m) {\n\
    \                m = n\n            }\n            l += m\n        }\n       \
    \ l.toList", "        if (numbers.isEmpty) List()\n        else {\n          \
    \  var res = ListBuffer[Long]()\n            var maxVal = numbers.head\n     \
    \       res += maxVal\n            for (i <- 1 until numbers.length) {\n     \
    \           maxVal = max(maxVal, numbers(i))\n                res += maxVal\n\
    \            }\n            res.toList\n        }", '        numbers.scanRight(0l.toLong)((x,
    acc) => max(x, acc)).tail', "        val maximums = numbers.foldLeft(List[Long]())((acc,\
    \ n) => \n            if (acc.isEmpty) List(n)\n            else List(max(acc.head,\
    \ n)) ++ acc\n        )\n        maximums.reverse", "        // Recursive function\
    \ generating the list of maximum elements.\n        def rMax(numbers : List[Long],\
    \ max : Long, result : List[Long]) : List[Long] = {\n            numbers match\
    \ {\n                case Nil => result\n                case head :: tail =>\
    \ {\n                    val newMax = max max head\n                    rMax(tail,\
    \ newMax, newMax :: result)\n                }\n            }\n        }\n   \
    \     rMax(numbers, numbers.head, List[Long]()).reverse", "      var maxSoFar\
    \ = numbers(0)\n      var results = List[Long]()\n      for (number <- numbers)\
    \ {\n        maxSoFar = max(maxSoFar, number)\n        results = results :+ maxSoFar\n\
    \      }\n      results", "        if (numbers.length == 0) return numbers\n \
    \       val maximums = ListBuffer.empty[Long]\n        maximums += numbers(0)\n\
    \        for (i <- 1 until numbers.length) {\n            maximums += max(maximums(i\
    \ - 1), numbers(i))\n        }\n        maximums.toList", "      if (numbers.isEmpty)\
    \ List[Long]()\n      else if (numbers.length == 1) List[Long](numbers(0))\n \
    \     else numbers(0) :: rollingMax(numbers.tail.map(x => max(x, numbers(0))))",
  "        numbers.foldLeft(List[Long]())((acc, x) => {\n            if (acc.isEmpty)\
    \ x :: acc\n            else acc.head max x :: acc\n        }).reverse", "   \
    \     var rolling : List[Long] = List[Long]()\n        var max : Long = Long.MinValue\n\
    \        for (number <- numbers) {\n            max = max.max(number)\n      \
    \      rolling = rolling :+ max\n        }\n        return rolling", "       \
    \ if (numbers.length == 0) List()\n        else {\n            val max = numbers.max\n\
    \            if (max < numbers.head) max :: rollingMax(numbers.tail)\n       \
    \     else max :: rollingMax(numbers.tail)\n        }", "        val len = numbers.length\n\
    \        val rolled = new Array[Long](len)\n        numbers.foldLeft((Long.MinValue,\
    \ rolled))((curr, num) => {\n            val (max, rolled) = curr\n          \
    \  rolled(numbers.indexOf(num)) = max max num\n            (max max num, rolled)\n\
    \        })._2.toList", "        var maximum = numbers(0)\n        var maxima\
    \ = List[Long]()\n        for (number <- numbers) {\n            if (number >\
    \ maximum) maximum = number\n            maxima = maxima :+ maximum\n        }\n\
    \        maxima", '      numbers.scan(0l.toLong)((maximum, element) => max(maximum,
    element)).tail', "        val maxes = new ListBuffer[Long]\n        for (i <-\
    \ 0 until numbers.length) {\n            val subset = numbers.slice(0, i)\n  \
    \          val max = if (subset.isEmpty) 0 else subset.max\n            maxes\
    \ += max\n        }\n        maxes.toList", "        var result = List[Long]()\n\
    \        var max = numbers(0)\n        for (number <- numbers) {\n           \
    \ if (number > max) {\n                max = number\n            }\n         \
    \   result = result :+ max\n        }\n        result", "        def helper(numbers\
    \ : List[Long], acc : List[Long]) : List[Long] = {\n            if (numbers.length\
    \ == 0) acc\n            else helper(numbers.tail, numbers.head :: acc)\n    \
    \    }\n        helper(numbers, List[Long]()).reverse", "        var maxes = ListBuffer[Long]()\n\
    \        var max : Long = numbers(0)\n        for (i <- 0 until numbers.length)\
    \ {\n            if (numbers(i) > max) max = numbers(i)\n            maxes +=\
    \ max\n        }\n        maxes.toList", "        if (numbers.length == 0) return\
    \ numbers\n        var numbers2 = ListBuffer[Long]()\n        numbers2 += numbers(0)\n\
    \        for (i <- 1 until numbers.length) {\n            numbers2 += max(numbers2(i\
    \ - 1), numbers(i))\n        }\n        numbers2.toList", '        return numbers.scanLeft(0l.toLong)((a,
    b) => max(a, b))', "        numbers.foldLeft(List[Long]())((accum, current) =>\
    \ if (accum.length == 0) {\n            List(current)\n        } else {\n    \
    \        val max = math.max(accum.last, current)\n            accum ++ List(max)\n\
    \        })", "        var max : Long = 0l\n        for (n <- numbers) {\n   \
    \         if (n > max) max = n\n        }\n        (numbers.map((n : Long) =>\
    \ max))", "        val m = numbers.map(x => x).toArray\n        val n = numbers.size\n\
    \        for (i <- 1 until n) {\n            val last = m(i - 1)\n           \
    \ if (last > m(i)) m(i) = last\n        }\n        m.toList", "        var max\
    \ : Long = 0\n        var result : List[Long] = List()\n        for (i <- 0 until\
    \ numbers.length) {\n            if (numbers(i) > max) {\n                max\
    \ = numbers(i)\n            }\n            result = result :+ max\n        }\n\
    \        return result", "        val maxes = new ArrayBuffer[Long]()\n      \
    \  var max = 0l\n        for (number <- numbers) {\n            max = max(max,\
    \ number)\n            maxes += max\n        }\n        maxes.toList", "     \
    \   var acc = Long.MinValue\n        var maximums = List[Long]()\n        for\
    \ (number <- numbers) {\n            if (number > acc) {\n                acc\
    \ = number\n            }\n            maximums = maximums :+ acc\n        }\n\
    \        maximums", "        val result = new ListBuffer[Long]()\n        if (!numbers.isEmpty)\
    \ {\n            var max = numbers.head\n            result += max\n         \
    \   for (number <- numbers.tail) {\n                if (number > max) {\n    \
    \                max = number\n                }\n                result += max\n\
    \            }\n        }\n        result.toList", "        def loop(numbers :\
    \ List[Long], result : List[Long]) : List[Long] = {\n            if (numbers.length\
    \ == 0) result.reverse\n            else {\n                val maxSoFar = result.head\n\
    \                val max = if (numbers.head > maxSoFar) numbers.head else maxSoFar\n\
    \                loop(numbers.tail, max :: result)\n            }\n        }\n\
    \        loop(numbers, List[Long](Long.MinValue))", "        var maxNumber = Long.MinValue\n\
    \        var maxList = List[Long]()\n        numbers.foreach { n =>\n        \
    \    maxNumber = max(maxNumber, n)\n            maxList = maxList :+ maxNumber\n\
    \        }\n        maxList", "        val result = numbers.tail.foldLeft(List(numbers.head))((a,\
    \ b) => a :+ max(a.last, b))\n        result", "        if (numbers.length ==\
    \ 0) return numbers\n        // Create a list of rolling maximums.\n        def\
    \ findMaximums(numbers : List[Long], maximums : List[Long]) : List[Long] = {\n\
    \            if (numbers.length == 0) return maximums\n            val head =\
    \ numbers.head\n            val previousMaximum = maximums.head\n            val\
    \ maximum = if (head > previousMaximum) head else previousMaximum\n          \
    \  findMaximums(numbers.tail, maximum :: maximums)\n        }\n        findMaximums(numbers.tail,\
    \ List(numbers.head)).reverse", "    \tval maxSeq = new ListBuffer[Long]()\n \
    \   \tfor (i <- 0 until numbers.length) {\n    \t\tmaxSeq += numbers.slice(0,\
    \ i + 1).max\n    \t}\n    \tmaxSeq.toList", '        numbers.scanLeft(Long.MinValue)((x,
    y) => max(x, y)).tail', "        val (numbers1, numbers2) = numbers.splitAt(1)\n\
    \        val results = numbers1.toList\n        val next = numbers2.foldLeft(List[Long]())((acc,\
    \ number) => if (number > acc.head) number :: acc else acc.head :: acc).reverse\n\
    \        results ::: next", "        val maximum = new ListBuffer[Long]\n    \
    \    maximum += numbers(0)\n        for (i <- 1 until numbers.length) {\n    \
    \        maximum += max(maximum(i - 1), numbers(i))\n        }\n        maximum.toList",
  "        val size = numbers.size\n        val maxima = new Array[Long](size)\n \
    \       var max = numbers(0)\n        maxima(0) = max\n        for (i <- 1 until\
    \ size) {\n            max = max(numbers(i), max)\n            maxima(i) = max\n\
    \        }\n        return maxima.toList", "      if (numbers.isEmpty) List()\n\
    \      else {\n        numbers.head :: rollingMax(numbers.tail.zip(numbers).map(x\
    \ => max(x._1, x._2)))\n      }", '        numbers.scanLeft(0l.toLong)(max).drop(1)',
  "        var currentMax = 0L\n        var result = new ListBuffer[Long]()\n    \
    \    numbers.foreach(i => {\n            if (i > currentMax) currentMax = i\n\
    \            result += currentMax\n        })\n        result.toList", "     \
    \   var result = new ListBuffer[Long]()\n        var maxValue = 0l\n        for\
    \ (number <- numbers) {\n            maxValue = max(maxValue, number)\n      \
    \      result += maxValue\n        }\n        result.toList", "        var stack\
    \ = Stack[Long]()\n        var maxs = List[Long]()\n        for (number <- numbers)\
    \ {\n            while (stack.size > 0 && stack.top < number) stack.pop\n    \
    \        stack.push(number)\n            maxs = maxs :+ stack.top\n        }\n\
    \        return maxs", '        numbers.scanLeft(numbers.head)((a, b) => max(a,
    b)).tail', "        if (numbers.isEmpty) List()\n        else {\n            val\
    \ max = numbers.head\n            List(max) ::: rollingMax(numbers.tail.map(e\
    \ => max(e, max)))\n        }", "        var queue = mutable.Queue.empty[Long]\n\
    \        var max = numbers.head\n        numbers.foreach(x => {\n            if\
    \ (x >= max) {\n                max = x\n                queue.enqueue(max)\n\
    \            }\n            else {\n                queue.enqueue(max)\n     \
    \       }\n        })\n        queue.toList", "        var maxList = List[Long]()\n\
    \        var curMax = Long.MinValue\n        for (i <- 0 until numbers.length)\
    \ {\n            curMax = max(curMax, numbers(i))\n            maxList = maxList\
    \ :+ curMax\n        }\n        return maxList", "        var currMax = numbers(0)\n\
    \        var result = List[Long]()\n        result :+= currMax\n        for (index\
    \ <- 1 until numbers.length) {\n            currMax = max(currMax, numbers(index))\n\
    \            result :+= currMax\n        }\n        result", "        if (numbers.length\
    \ == 0) return List()\n        var maxSoFar = numbers(0)\n        var result =\
    \ List(maxSoFar)\n        for (i <- 1 until numbers.length) {\n            maxSoFar\
    \ = max(maxSoFar, numbers(i))\n            result = result :+ maxSoFar\n     \
    \   }\n        return result", "        val num = numbers.toArray\n        val\
    \ max = numbers.length\n        val result = new Array[Long](max)\n        result(0)\
    \ = num(0)\n        for (i <- 1 until max) result(i) = max(result(i - 1), num(i))\n\
    \        result.toList", '        return numbers.scanLeft(0l.toLong)((max, number)
    => Math.max(max, number))', '        numbers.scanRight(Long.MinValue)((v, acc)
    => max(v, acc)).dropRight(1)', "        numbers.tail.foldLeft(List[Long](numbers.head))\
    \ { (acc, x) =>\n            acc.head :: acc\n        }.reverse", "        if\
    \ (numbers.isEmpty) {\n            List()\n        } else {\n            numbers.zipWithIndex.map(x\
    \ => (x._1, x._2, numbers.slice(0, x._2 + 1).max)).map(x => x._3)\n        }",
  "        var maxSoFar = 0l\n        numbers.map(n => {\n            if (n > maxSoFar)\
    \ maxSoFar = n\n            maxSoFar\n        })", "      if (numbers.length ==\
    \ 0) List[Long]()\n      else if (numbers.length == 1) List[Long](numbers(0))\n\
    \      else {\n        var result = new ListBuffer[Long]()\n        var max =\
    \ Long.MinValue\n        for (n <- numbers) {\n          max = max max n\n   \
    \       result += max\n        }\n        result.toList\n      }", "        var\
    \ maxSoFar = numbers(0)\n        numbers.map(number => {\n            maxSoFar\
    \ = max(maxSoFar, number)\n            maxSoFar\n        })", "        numbers.foldLeft(List[Long]())((list,\
    \ item) =>\n            if (list.isEmpty) List(item)\n            else if (item\
    \ > list.last) list :+ item\n            else list :+ list.last\n        )", " \
    \       var result = ListBuffer[Long]()\n        var currentMax = numbers(0)\n\
    \        result += currentMax\n        for (i <- 1 until numbers.length) {\n \
    \           currentMax = max(currentMax, numbers(i))\n            result += currentMax\n\
    \        }\n        result.toList", "        def inner(numbers : List[Long], maximum\
    \ : Long, result : List[Long]) : List[Long] = {\n            if (numbers.isEmpty)\
    \ result.reverse\n            else inner(numbers.tail, max(maximum, numbers.head),\
    \ max(maximum, numbers.head) :: result)\n        }\n        inner(numbers, numbers.head,\
    \ List[Long]())", "        val accumulator = (0l.toLong, List[Long]())\n     \
    \   numbers.foldLeft(accumulator) ((accumulator, number) => {\n            val\
    \ (lastMax, maxList) = accumulator\n            (max(lastMax, number), maxList\
    \ :+ max(lastMax, number))\n        })._2", "        var result = new ListBuffer[Long]()\n\
    \        var max = 0l\n        for (i <- 0 until numbers.length) {\n         \
    \   if (numbers(i) > max) {\n                max = numbers(i)\n            }\n\
    \            result += max\n        }\n        result.toList", "        val maxes\
    \ = ListBuffer[Long]()\n        var i = 0\n        while (i < numbers.length)\
    \ {\n            maxes += numbers.slice(0, i + 1).max\n            i += 1\n  \
    \      }\n        maxes.toList", "        var rolling = ListBuffer[Long]()\n \
    \       var max = 0l\n        for (number <- numbers) {\n            if (number\
    \ > max) max = number\n            rolling += max\n        }\n        rolling.toList",
  "      def rollingMaxHelper(numbers : List[Long], maxs : List[Long]) : List[Long]\
    \ = {\n        if (numbers.isEmpty) maxs.reverse\n        else rollingMaxHelper(numbers.tail,\
    \ max(numbers.head, maxs.head) :: maxs)\n      }\n      rollingMaxHelper(numbers,\
    \ List[Long](0))", "      def loop(inputs : List[Long], outputs : List[Long])\
    \ : List[Long] = {\n        if (inputs.isEmpty) {\n          outputs\n       \
    \ } else {\n          val output = if (outputs.isEmpty) inputs.head else max(outputs.head,\
    \ inputs.head)\n          loop(inputs.tail, output :: outputs)\n        }\n  \
    \    }\n      loop(numbers, List[Long]()).reverse", "        val result = new\
    \ ListBuffer[Long]()\n        var maximum = 0l\n        numbers.foreach(value\
    \ => {\n            maximum = max(maximum, value)\n            result += maximum\n\
    \        })\n        result.toList", "      if (numbers.length == 0) return numbers\n\
    \      if (numbers.length == 1) return numbers\n      def rec(numbers : List[Long],\
    \ result : List[Long]) : List[Long] = {\n        if (numbers.length == 0) return\
    \ result\n        if (numbers.length == 1) return numbers.head :: result\n   \
    \     val subResult = numbers.head :: result\n        val max = if (subResult.head\
    \ > subResult.tail.head) subResult.head else subResult.tail.head\n        rec(numbers.tail,\
    \ max :: subResult)\n      }\n      rec(numbers, List[Long]()).reverse", "   \
    \     var max = numbers(0)\n        var ans = List[Long]()\n        ans = ans\
    \ :+ max\n        for (i <- 1 until numbers.length) {\n            max = max.max(numbers(i))\n\
    \            ans = ans :+ max\n        }\n        ans", "        var result =\
    \ new ListBuffer[Long]\n        var currentMax = numbers(0)\n        result +=\
    \ currentMax\n        for (i <- 1 until numbers.length) {\n            val element\
    \ = numbers(i)\n            currentMax = max(currentMax, element)\n          \
    \  result += currentMax\n        }\n        result.toList", "    \tif (numbers.isEmpty)\
    \ return numbers\n    \tvar result = List[Long]()\n    \tvar currentMax = numbers.head\n\
    \    \tfor (number <- numbers) {\n    \t\tcurrentMax = max(currentMax, number)\n\
    \    \t\tresult = result :+ currentMax\n    \t}\n    \tresult", "        val q\
    \ = new mutable.Queue[Long]\n        return numbers.map { i =>\n            while\
    \ (!q.isEmpty && q.last < i) q.dequeue\n            q.enqueue(i)\n           \
    \ q.head\n        }", "        var max = 0l\n        var maxes = List[Long]()\n\
    \        for (n <- numbers) {\n            max = max(n, max)\n            maxes\
    \ = maxes :+ max\n        }\n        return maxes", "        var maxes = new ListBuffer[Long]()\n\
    \        var currentMax = numbers(0)\n        maxes += currentMax\n        for\
    \ (i <- 1 until numbers.length) {\n            if (numbers(i) > currentMax) {\n\
    \                currentMax = numbers(i)\n            }\n            maxes +=\
    \ currentMax\n        }\n        maxes.toList", "      if (numbers.isEmpty)\n\
    \        Nil\n      else {\n        val maxs = new ArrayBuffer[Long]\n       \
    \ maxs += numbers.head\n        for (num <- numbers.tail) {\n          if (num\
    \ >= maxs.last)\n            maxs += num\n          else\n            maxs +=\
    \ maxs.last\n        }\n        maxs.toList\n      }", "        val dp = Array.fill(numbers.length)(0l)\n\
    \        dp(0) = numbers(0)\n        for (i <- 1 until numbers.length) {\n   \
    \         dp(i) = max(dp(i - 1), numbers(i))\n        }\n        dp.toList", " \
    \       // Return a queue containing the list of numbers.\n        // The queue\
    \ will be used to pop out maximum values.\n        def toQ(numbers : List[Long])\
    \ : Queue[Long] = {\n            var q = Queue[Long]()\n            numbers.foreach(x\
    \ => q += x)\n            q\n        }\n        // Return the maximum of x and\
    \ q.\n        def maxQ(x : Long, q : Queue[Long]) : Long = {\n            if (q.isEmpty)\
    \ x\n            else if (x >= q.front) x\n            else q.front\n        }\n\
    \        var q = toQ(numbers)\n        var currentMax = q.front\n        var result\
    \ = List[Long]()\n        while (!q.isEmpty) {\n            currentMax = maxQ(q.front,\
    \ q)\n            result = result :+ currentMax\n            q.dequeue\n     \
    \   }\n        result", '        numbers.map(x => x).scanLeft(0l.toLong)((b, a)
    => if (a > b) a else b)', "        val m = ListBuffer[Long]()\n        for (i\
    \ <- 0 until numbers.length) {\n            val s = numbers.slice(0, i + 1)\n\
    \            m += s.max\n        }\n        m.toList", "        var maxList =\
    \ List[Long]()\n        var currentMax = 0l\n        for (n <- numbers) {\n  \
    \          currentMax = max(currentMax, n)\n            maxList = maxList :+ currentMax\n\
    \        }\n        return maxList", "        val n = numbers.length\n       \
    \ var result = List[Long]()\n        var maximum : Long = 0\n        for (i <-\
    \ 0 until n) {\n            maximum = max(maximum, numbers(i))\n            result\
    \ = result :+ maximum\n        }\n        result", "        var maximum = numbers(0)\n\
    \        var maximums = List[Long]()\n        maximums = maximums :+ maximum\n\
    \        for (i <- 1 until numbers.length) {\n            if (numbers(i) > maximum)\
    \ {\n                maximum = numbers(i)\n            }\n            maximums\
    \ = maximums :+ maximum\n        }\n        maximums", "        val result = new\
    \ ListBuffer[Long]\n        val stack = new Stack[Long]\n        for (n <- numbers)\
    \ {\n            while (stack.size > 0 && stack.top < n) {\n                stack.pop\n\
    \            }\n            stack.push(n)\n            result += stack.top\n \
    \       }\n        result.toList", "        val result = Buffer[Long]()\n    \
    \    var max = Long.MinValue\n        for (number <- numbers) {\n            if\
    \ (number > max) {\n                max = number\n            }\n            result\
    \ += max\n        }\n        result.toList", "        numbers.tail.foldLeft(List[Long](numbers.head))\
    \ {\n            case (List(a), b) => List(max(a, b))\n            case (list,\
    \ num) => max(list.head, num) :: list\n        }.reverse", "        var maximum\
    \ = List[Long]()\n        var currentMax = numbers(0)\n        maximum = maximum\
    \ :+ currentMax\n        for (i <- 1 until numbers.length) {\n            currentMax\
    \ = max(currentMax, numbers(i))\n            maximum = maximum :+ currentMax\n\
    \        }\n        maximum", "        if (numbers.length == 0) return numbers\n\
    \        val results = new ListBuffer[Long]()\n        results += numbers(0)\n\
    \        for (i <- 1 until numbers.length) {\n            results += max(results(i\
    \ - 1), numbers(i))\n        }\n        results.toList", "        val initial\
    \ = numbers.head\n        val res = ListBuffer(initial)\n        for (i <- 1 until\
    \ numbers.length) {\n            val maxFrom = numbers.slice(0, i + 1).max\n \
    \           res += maxFrom\n        }\n        res.toList", "        var max =\
    \ 0l\n        return numbers.map(n => {\n            if (n > max) {\n        \
    \        max = n\n            }\n            max\n        })", "        var maxSeen\
    \ = 0l\n        var result = List[Long]()\n        for (number <- numbers) {\n\
    \            maxSeen = max(maxSeen, number)\n            result = result :+ maxSeen\n\
    \        }\n        result", "        var list = List[Long]()\n        var lmax\
    \ = numbers(0)\n        for (n <- numbers) {\n            if (n > lmax) {\n  \
    \              lmax = n\n            }\n            list = list :+ lmax\n    \
    \    }\n        list", "        val maximums = new ListBuffer[Long]\n        maximums\
    \ += numbers(0)\n        for (i <- 1 until numbers.length) {\n            maximums\
    \ += max(maximums(i - 1), numbers(i))\n        }\n        maximums.toList"]
stop_tokens:
- "\n    }\n"
