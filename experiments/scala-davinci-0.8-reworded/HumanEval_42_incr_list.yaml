name: HumanEval_42_incr_list
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n\
  \    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
  \ 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong,\
  \ 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong,\
  \ 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n\
  \    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong,\
  \ 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong,\
  \ 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong,\
  \ 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong,\
  \ 124l.toLong))));\n    }\n\n}\n"
completions: ["        if (l.length == 0) {\n            List[Long]()\n        } else\
    \ {\n            List[Long](l.head + 1) ++ incrList(l.tail)\n        }", "   \
    \     def incr(l : List[Long], acc : List[Long]) : List[Long] = {\n          \
    \  l match {\n                case List() => acc.reverse\n                case\
    \ h :: t => incr(t, (h + 1l.toLong) :: acc)\n            }\n        }\n      \
    \  incr(l, List())", "        var s : List[Long] = Nil\n        for (e <- l) {\n\
    \            s = s :+ (e + 1)\n        }\n        return s", '        l.map(e
    => e + 1)', "        // Implement this function\n        for(x <- l) yield (x+1)",
  '        l.map((x: Long) => x + 1l.toLong)', '        return l.map(n => n + 1)',
  '        return l.map((x: Long) => x + 1l.toLong)', "        if (l.size == 0) {\n\
    \            List[Long]()\n        } else {\n            (l.head + 1) :: incrList(l.tail)\n\
    \        }", '        l.map(x => x + 1)', "        var result = new ListBuffer[Long]()\n\
    \        for (element <- l) {\n            result += (element + 1)\n        }\n\
    \        return result.toList", '        l.map(x => x + 1)', "        l match\
    \ {\n            case Nil => List()\n            case head :: tail => head + 1\
    \ :: incrList(tail)\n        }", "        if (l.isEmpty)\n            l\n    \
    \    else {\n            (l.head + 1l.toLong) :: incrList(l.tail)\n        }",
  '        l.map(_ + 1)', '        l.map((item) => item + 1)', "        var result\
    \ = List[Long]()\n        for (n <- l) {\n            result = result :+ (n +\
    \ 1)\n        }\n        return result", "        var r = List[Long]()\n     \
    \   l.foreach( (c) => {\n            r = r :+ (c + 1)\n        })\n        r",
  '        l.map(_ + 1)', "        var result = List[Long]()\n        for (i <- 0\
    \ until l.length) result = result :+ (l(i) + 1)\n        return result", "   \
    \     val incrListHelper = (m : List[Long], i : Long) => m.updated(i.toInt, m(i.toInt)\
    \ + 1)\n        l.indices.foldLeft(l)(incrListHelper)", '        l.map(x => x
    + 1)', "        var r : List[Long] = Nil\n        for (e <- l) {\n           \
    \ r = r :+ (e + 1)\n        }\n        return r", '        return l.map((x: Long)
    => x + 1)', '        return l.map((x : Long) => x + 1l.toLong)', '        l.map(x
    => x + 1)', "        var ret = List[Long]()\n        l.foreach(x => ret = ret\
    \ :+ (x + 1l.toLong))\n        return ret", '        return l.map(_ + 1)', '        return
    l.map(_ + 1)', "        var newList = List[Long]()\n        for (e <- l) {\n \
    \           newList = (e + 1) :: newList\n        }\n        newList.reverse",
  "        def f(x : Long) : Long = x + 1\n        l.map(f)", "        l match {\n\
    \            case Nil => l\n            case h :: t => h + 1 :: incrList(t)\n\
    \        }", '        return l.map(x => x + 1)', '        return l.map((x : Long)
    => x + 1l)', "        var res = new ListBuffer[Long]()\n        for (item <- l)\
    \ res += (item + 1)\n        res.toList", '        l.map((x : Long) => x + 1l.toLong)',
  '        l.map(v => v + 1)', "        var new_l = List[Long]()\n        for (e <-\
    \ l) {\n            new_l = new_l ++ List[Long](e + 1l.toLong)\n        }\n  \
    \      return new_l", "        // >>> incrList((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong)))\n        // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n   \
    \     // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n        // (List[Long](6l.toLong,\
    \ 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong,\
    \ 124l.toLong))\n        l.map(e => e + 1)", '        return l.map(i => i + 1l.toLong)',
  '        return l.map((i : Long) => (i + 1l.toLong))', '        l.map(e => e + 1)',
  "        var result : List[Long] = List()\n        for (i <- l) {\n            result\
    \ = result :+ (i + 1)\n        }\n        return result", "        var output\
    \ : List[Long] = List[Long]()\n        var current : Long = 0\n        var carry\
    \ : Long = 0\n        for (i <- l.reverse) {\n            current = i + 1\n  \
    \          if (carry == 1) {\n                current += 1\n                carry\
    \ = 0\n            }\n            if (current >= 10) {\n                current\
    \ -= 10\n                carry = 1\n            }\n            output = List[Long](current)\
    \ ::: output\n        }\n        if (carry == 1) {\n            output = List[Long](1l.toLong)\
    \ ::: output\n        }\n        return output", '        l.map(n => n + 1)',
  "        var tmp = (List[Long]())\n        for (i <- 0 to l.length - 1) {\n    \
    \        tmp = tmp :+ (l(i) + 1)\n        }\n        return tmp", '        l.map(n
    => n + 1)', '        return l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', '        (l.map((i) => i + 1l))', "        var result = List[Long]()\n\
    \        for (e <- l) {\n            result = (e + 1) :: result\n        }\n \
    \       result.reverse", '        l.map((x : Long) => x + 1l.toLong)', '        l.map(x
    => x + 1)', '        return l.map((x) => (x + 1l.toLong))', "        def aux(l\
    \ : List[Long], acc : List[Long]) : List[Long] = {\n            l match {\n  \
    \              case Nil => acc\n                case x :: xs => aux(xs, acc :+\
    \ (x + 1))\n            }\n        }\n        aux(l, List[Long]())", '        l.map((x)
    => x + 1)', '        return l.map(a => a + 1l.toLong)', '        return l.map(x
    => x + 1)', '        l.map(e => e + 1)', "        val n = l.length\n        var\
    \ res = List[Long]()\n        for (i <- 0 until n) {\n            res = (l(i)\
    \ + 1l.toLong) :: res\n        }\n        res.reverse", '        l.map(x => x
    + 1)', "        if (l.isEmpty) return List()\n        return (l.head + 1l.toLong)\
    \ :: incrList(l.tail)", "        // Returns list with elements incremented by\
    \ 1.\n        def inrec(l : List[Long], result : List[Long]) : List[Long] = {\n\
    \            if (l.isEmpty) {\n                result\n            } else {\n\
    \                inrec(l.tail, result :+ (l.head + 1l.toLong))\n            }\n\
    \        }\n        inrec(l, List[Long]())", '        l.map(i => i + 1)', "  \
    \      def f(x : Long) : Long = {\n            return x + 1\n        }\n     \
    \   return l.map(f)", "        if (l.isEmpty) {\n            List[Long]()\n  \
    \      } else {\n            (l.head + 1l.toLong) :: incrList(l.tail)\n      \
    \  }", "        var r : List[Long] = List();\n        for (i <- 0 to l.length\
    \ - 1) r = r :+ (l(i) + 1);\n        return r;", "        if (l.isEmpty) {\n \
    \           return List[Long]()\n        }\n        else {\n            val x\
    \ = (l.head + 1l.toLong)\n            return x :: incrList(l.tail)\n        }",
  '        l.map(x => x + 1)', '        return l.map(_ + 1)', '        return l.map(x
    => (x + 1l.toLong))', "        l match {\n            case Nil => l\n        \
    \    case a :: b => a + 1 :: incrList(b)\n        }", '        l.map(x => x +
    1)', "        var x = List[Long]()\n        l.foreach(i => x = x.++(List[Long](i\
    \ + 1l.toLong)))\n        x", '        l.map(x => x + 1)', "        if (l.length\
    \ == 0) {\n            return l\n        }\n        return incrList(l.init) :+\
    \ (l.last + 1)", '        return l.map(x => x + 1)', '        l.map((v : Long)
    => v + 1l.toLong)', '        // YOUR CODE HERE', '        return l.map(x => x
    + 1)', '        l.map(n => n + 1)', '        l.map((elem : Long) => elem + 1l.toLong)',
  '        l.map(x => x + 1)', "        var l1 = new ListBuffer[Long]()\n        l.foreach((x)\
    \ => l1 += (x + 1l.toLong))\n        l1.toList", '        l.map(x => x + 1)',
  "        // Implicit declaration.\n        implicit def long2Long(l : Long) : Long\
    \ = {\n            l + 1\n        }\n        l", "        // >>> l\n        //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong))\n        // >>> l.map((a : Long)\
    \ => a + 1l.toLong)\n        // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n\
    \        l.map((a : Long) => a + 1l.toLong)", '        l.map((x : Long) => x +
    1l.toLong)', '        return l.map(_ + 1)', '        return l.map((x : Long) =>
    x + 1l)', "        var result : List[Long] = List[Long]()\n        var i : Long\
    \ = 0l.toLong\n        while (i < l.length) {\n            result = (l(i.toInt)\
    \ + 1l.toLong) :: result\n            i = i + 1l.toLong\n        }\n        result.reverse",
  "        def incr(l : List[Long], m : List[Long]) : List[Long] = l match {\n   \
    \         case List() => m\n            case x :: xs => incr(xs, m :+ (x + 1))\n\
    \        }\n        incr(l, List())", "        val result = new ListBuffer[Long]\n\
    \        for (item <- l) {\n            result += (item + 1)\n        }\n    \
    \    result.toList", "        var a = l\n        for (i <- 0 until a.length) {\n\
    \            a = a.updated(i, a(i) + 1)\n        }\n        return a", '        l.map(a
    => a + 1)', "        var result : List[Long] = List[Long]()\n        for (e <-\
    \ l) result = result :+ (e + 1)\n        return result", "        def incrList_Iter(l\
    \ : List[Long], s : List[Long]) : List[Long] = {\n            l match {\n    \
    \            case Nil => s\n                case x :: xs => incrList_Iter(xs,\
    \ s :+ (x + 1l.toLong))\n            }\n        }\n        incrList_Iter(l, List[Long]())",
  '        return l.map((x) => x + 1l.toLong)', '        l.map(_ + 1)', '        (List[Long]()
    /: l) ((a, b) => a :+ (b + 1l.toLong))', '        l.map((x : Long) => x + 1l.toLong)',
  '        l.map(x => x + 1)', '        return l.map(x => x + 1)', "        val nl\
    \ = l.map(x => x + 1l.toLong)\n        nl", "        if (l.length == 0) {\n  \
    \          return (List[Long]())\n        }\n        return (List[Long](l.head\
    \ + 1) ::: incrList(l.tail))", "        def incrListH(res : List[Long], l : List[Long])\
    \ : List[Long] = {\n            if (l.isEmpty) res\n            else incrListH(res\
    \ ++ List(l.head + 1), l.tail)\n        }\n        incrListH(List[Long](), l)",
  '        return l.map((_ + 1))', '        return (l.map(e => e + 1));', "      \
    \  // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n        //\
    \ (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n        // l.map(x => x + 1)\n\
    \        l.map(_ + 1)", '        l.map((i : Long) => i + 1l.toLong)', "      \
    \  if (l.isEmpty) l\n        else l.head + 1l.toLong :: incrList(l.tail)", '        return
    l.map(x => x + 1)', "        def go(l : List[Long], result : List[Long]) : List[Long]\
    \ = {\n            if (l.length == 0) result\n            else go(l.tail, result\
    \ ++ List(l.head + 1))\n        }\n        go(l, List())", "        var newList\
    \ = List[Long]()\n        for (e <- l) {\n            newList = newList :+ (e\
    \ + 1)\n        }\n        return newList", "        var out = new ListBuffer[Long]\n\
    \        for (d <- l) {\n            out += (d + 1)\n        }\n        out.toList",
  '        return l.map((x : Long) => x + 1l.toLong)', "        if (l.isEmpty)\n \
    \           l\n        else\n            l.head + 1 :: incrList(l.tail)", '        l.map(e
    => e + 1)', '        l.map(x => x + 1)', "        val result = ListBuffer[Long]()\n\
    \        for (e <- l) {\n            result += (e + 1)\n        }\n        result.toList",
  '        l.map(_ + 1)', "        var r : List[Long] = List[Long]()\n        for\
    \ (i <- 0 until l.length) r ::= l(i) + 1\n        r.reverse", '        return
    l.map(e => e + 1l.toLong)', '        return l.map((e) => e + 1l.toLong)', '        l.map(x
    => x + 1)', "        var res : List[Long] = List[Long]()\n        l.foreach(x\
    \ => res = res :+ (x + 1))\n        return res", '        return l.map(x => x
    + 1)', "        // Return tail of list.\n        // >>> tail(List(1, 2, 3))\n\
    \        // List(2, 3)\n        // >>> tail(List(5, 3, 6, 3, 3, 3, 9, 0, 124))\n\
    \        // List(3, 6, 3, 3, 3, 9, 0, 124)\n        def tail(l : List[Long]) :\
    \ List[Long] = l match {\n            case Nil => Nil\n            case h :: t\
    \ => t\n        }\n        // Return a list with its last element removed.\n \
    \       // >>> init(List(1, 2, 3))\n        // List(1, 2)\n        // >>> init(List(5,\
    \ 3, 6, 3, 3, 3, 9, 0, 124))\n        // List(5, 3, 6, 3, 3, 3, 9, 0)\n      \
    \  def init(l : List[Long]) : List[Long] = l match {\n            case Nil =>\
    \ Nil\n            case h :: Nil => Nil\n            case h :: t => h :: init(t)\n\
    \        }\n        // Return list with last element incremented by 1.\n     \
    \   // >>> addOne(List(1, 2, 3))\n        // List(1, 2, 4)\n        // >>> addOne(List(5,\
    \ 3, 6, 3, 3, 3, 9, 0, 124))\n        // List(5, 3, 6, 3, 3, 3, 9, 0, 125)\n \
    \       def addOne(l : List[Long]) : List[Long] = l match {\n            case\
    \ Nil => Nil\n            case h :: Nil => h + 1 :: Nil\n            case h ::\
    \ t => h :: addOne(t)\n        }\n        // Adds 1 to the last element in list\
    \ if it is smaller than 9,\n        // otherwise calls addOne recursively on the\
    \ tail until it\n        // reaches an element smaller than 9.\n        // >>>\
    \ incrList(List(1, 2, 3))\n        // List(1, 2, 4)\n        // >>> incrList(List(5,\
    \ 3, 6, 3, 3, 3, 9, 0, 124))\n        // List(5, 3, 6, 3, 3, 3, 9, 0, 125", '        return
    l.map(e => e + 1)', '        l.map(x => x + 1)', "        // (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong))\n        // >>> incrList((List[Long](5l.toLong, 3l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n\
    \        // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n        if (l.length <= 0)\
    \ {\n            List[Long]()\n        } else {\n            List[Long](l.head\
    \ + 1l.toLong) ++ incrList(l.tail)\n        }", "        val func : (Long) =>\
    \ Long = {x => (x + 1l.toLong)}\n        return map(l, func)", '        l.map((i)
    => i + 1l.toLong)', '        l.map(x => x + 1)', '        l.map(i => i + 1)',
  "        if (l.isEmpty) l\n        else l.head + 1l.toLong :: incrList(l.tail)",
  "        var result = List[Long]()\n        for (i <- l) {\n            result =\
    \ (i + 1l) :: result\n        }\n        result.reverse", '        return l.map(x
    => x + 1l.toLong)', '        l.map(e => e + 1)', "        l match {\n        \
    \    case Nil => Nil\n            case x :: rest => (x + 1) :: incrList(rest)\n\
    \        }", "        var acc = 0L\n        var res : List[Long] = List()\n  \
    \      for (i <- l.length - 1 to 0 by -1) {\n            var sum = l(i) + acc\
    \ + 1\n            acc = sum / 10\n            sum = sum % 10\n            res\
    \ = sum :: res\n        }\n        if (acc != 0) res = acc :: res\n        res",
  '        l.map((x : Long) => x + 1l.toLong)', "        var r : List[Long] = List[Long]()\n\
    \        var i : Long = 0l.toLong\n        while (i < l.length) {\n          \
    \  {\n                r = r.+:(l.apply(i.toInt).+(1l.toLong))\n              \
    \  i = i.+(1l.toLong)\n            }\n        }\n        return r", "        var\
    \ result = List[Long]()\n        for (i <- l) {\n            result = result :+\
    \ (i + 1)\n        }\n        return result", "        val incr : (Long) => Long\
    \ = (x : Long) => x + 1\n        return l.map(incr)", '        l.map(x => x +
    1)', "        if (l.length == 0) {\n            return List();\n        }\n  \
    \      var ret = List[Long]();\n        for (i <- 0 until l.length) {\n      \
    \      ret = ret :+ (l(i) + 1);\n        }\n        return ret;", "        var\
    \ result : List[Long] = List[Long]()\n        for (v <- l) {\n            result\
    \ = result :+ (v + 1)\n        }\n        return result", '        l.map(v =>
    v + 1)', "        val m : List[Long] = l.map((x) => x + 1)\n        return m",
  "        var l2 = new ListBuffer[Long]\n        for (i <- l) {\n            l2 +=\
    \ (i + 1)\n        }\n        return l2.toList", '        l.map((n : Long) =>
    n + 1l.toLong)', "        l match {\n            case Nil => Nil\n           \
    \ case x :: xs => (x + 1) :: incrList(xs)\n        }", '        l.map(_ + 1)',
  '        l.map((x : Long) => x + 1l.toLong)', "        if (l.length == 0) List[Long]()\n\
    \        else if (l.length == 1) List[Long]((l(0) + 1l.toLong))\n        else\
    \ List[Long]((l(0) + 1l.toLong)) ++ incrList(l.slice(1, l.length))", "       \
    \ var res = List[Long]()\n        for (i <- l) {\n            res = (i + 1) ::\
    \ res\n        }\n        res.reverse", '        l.map((e : Long) => e + 1l.toLong)',
  '        return l.map(x => x + 1)', '        return l.map((x : Long) => (x + 1))',
  "        if (l.isEmpty) List()\n        else List((l.head + 1) :: incrList(l.tail))",
  "        // Assume input is valid.\n        if (l.isEmpty) return l\n        val\
    \ r = new Array[Long](l.length)\n        r(0) = l(0) + 1\n        for (i <- 1\
    \ until l.length) {\n            r(i) = l(i) + r(i - 1)\n        }\n        return\
    \ r.toList", '        (l.toList.map((x) => (x + 1l.toLong)))', '        l.map(x
    => x + 1)', '        l.map(n => n + 1)', '        return l.map(_ + 1l.toLong)',
  '        l.map(e => e + 1)', "        // >>> list(range(1, 5))\n        // (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))\n        var result : List[Long] = l.map(_\
    \ + 1)\n        return result", '        l.map(n => n + 1)', "        if (l.isEmpty)\
    \ {\n            List[Long]()\n        } else {\n            List[Long](l.head\
    \ + 1l.toLong) ++ incrList(l.tail)\n        }", '        l.map(_ + 1)', '        return
    l.map(v => v + 1)', '        return l.map(_ + 1)', "        val l1 = l.map(x =>\
    \ x + 1)\n        return l1", '        l.map(i => i + 1)', "        var newList\
    \ = new ListBuffer[Long]()\n        for (elt <- l) {\n            newList += (elt\
    \ + 1)\n        }\n        return newList.toList", '        l.map(a => a + 1)',
  '        l.map(i => i + 1)', '        l.map((x : Long) => x + 1l.toLong)', '        l.map(x
    => x + 1)', "        var result : List[Long] = Nil\n        for (i <- 0 until\
    \ l.length) result = result :+ (l(i) + 1)\n        return result", '        return
    (List[Long]() /: l) ((a, b) => a :+ (b + 1l))', '        l.map(i => i + 1)', '        (l.map(e
    => (e + 1l.toLong)))', "        var res = new ListBuffer[Long]\n        for (element\
    \ <- l) {\n            res += (element + 1)\n        }\n        return res.toList",
  '        l.map(x => x + 1)', '        return l.map(_ + 1l.toLong)', "        var\
    \ ll = new ListBuffer[Long]\n        for (n <- l) {\n            ll += (n + 1)\n\
    \        }\n        ll.toList", "        val ret = l.map(x => x + 1)\n       \
    \ ret", "        l match {\n            case Nil => Nil\n            case x ::\
    \ xs => (x + 1l.toLong) :: incrList(xs)\n        }", "        if (l.isEmpty) {\n\
    \            return l\n        }\n        return List[Long](l.head + 1l.toLong)\
    \ ++ incrList(l.tail)", '        l.map(e => e + 1)', "        var ret: List[Long]\
    \ = List[Long]()\n        for (i <- l) ret = ret :+ (i + 1)\n        ret", " \
    \       val N = l.length\n        val ret = Array.fill(N)(0l.toLong)\n       \
    \ for (i <- 0 until N) ret(i) = l(i) + 1\n        ret.toList", "        // >>>\
    \ incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n        // (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong))\n        var ret = new ListBuffer[Long]()\n        for\
    \ (x <- l) {\n            ret += (x + 1)\n        }\n        return ret.toList",
  "        var out = l\n        for (i <- 0 until l.length) {\n            out = out.updated(i,\
    \ l(i) + 1)\n        }\n        return out", "        if (l.isEmpty) {\n     \
    \       return Nil\n        }\n        else {\n            return List(l.head\
    \ + 1) ::: incrList(l.tail)\n        }", "        var ans = List[Long]()\n   \
    \     for (i <- l) {\n            ans = ans :+ (i + 1)\n        }\n        return\
    \ ans", '        l.map(x => x + 1)']
stop_tokens:
- "\n    }\n"
