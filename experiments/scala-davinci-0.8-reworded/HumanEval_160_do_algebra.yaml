name: HumanEval_160_do_algebra
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given two lists operator, and operand. The first list has basic algebra\
  \ operations, and \n    // the second list is a list of integers. Use the two given\
  \ lists to build the algebric \n    // expression and return the evaluation of this\
  \ expression.\n    // The basic algebra operations:\n    // Addition ( + ) \n  \
  \  // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor division (\
  \ // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+', '*',\
  \ '-']\n    // list = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    // => result\
  \ = 9\n    // Note:\n    // The length of operator list is equal to the length of\
  \ operand list minus one.\n    // Operand is a list of of non-negative integers.\n\
  \    // Operator list has at least one operator, and operand list has at least two\
  \ operands.\n    def doAlgebra(op : List[String], operand : List[Long]) : Long =\
  \ {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
  **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
  \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
  //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
  \n}\n"
completions: ["        if (op.isEmpty || operand.length == 1) operand.head\n     \
    \   else {\n            var res = operand.head\n            for (i <- 1 until\
    \ operand.length) {\n                op(i - 1) match {\n                    case\
    \ \"+\" => res += operand(i)\n                    case \"-\" => res -= operand(i)\n\
    \                    case \"*\" => res *= operand(i)\n                    case\
    \ \"//\" => res /= operand(i)\n                    case \"**\" => res = pow(res,\
    \ operand(i)).toLong\n                }\n            }\n            res\n    \
    \    }", "        if (op.length < 1 || operand.length < 2) return -1\n       \
    \ var result = operand(0)\n        for (i <- 0 until op.length) {\n          \
    \  if (op(i) == \"+\") result += operand(i + 1)\n            else if (op(i) ==\
    \ \"-\") result -= operand(i + 1)\n            else if (op(i) == \"*\") result\
    \ *= operand(i + 1)\n            else if (op(i) == \"//\") result /= operand(i\
    \ + 1)\n            else if (op(i) == \"**\") result = pow(result, operand(i +\
    \ 1)).toLong\n        }\n        return result", "        // val l1 = List(\"\
    a\", \"b\", \"c\")\n        // l1.foldLeft(\"d\")((acc, x) => acc + x) => dabc\n\
    \        // l1.foldRight(\"d\")((x, acc) => acc + x) => abcd\n        // foldLeft(op).zip(operand).foldLeft(0L)((acc,\
    \ x) => acc + x._1 + x._2)\n        op.foldLeft(operand)((acc, x) => acc.sliding(2,\
    \ 1).map(l => x match {\n            case \"+\" => l(0) + l(1)\n            case\
    \ \"-\" => l(0) - l(1)\n            case \"*\" => l(0) * l(1)\n            case\
    \ \"//\" => l(0) / l(1)\n            case \"**\" => pow(l(0), l(1)).toLong\n \
    \       }).toList ::: List(acc.last)).head", "        var result = operand(0)\n\
    \        for (i <- 1 until operand.length) {\n            op(i - 1) match {\n\
    \                case \"+\" => result += operand(i)\n                case \"-\"\
    \ => result -= operand(i)\n                case \"*\" => result *= operand(i)\n\
    \                case \"//\" => result /= operand(i)\n                case \"\
    **\" => result = pow(result, operand(i)).toLong\n            }\n        }\n  \
    \      result", "        var stack = Stack[Long]()\n        for (i <- 0 until\
    \ op.length) {\n            val x = operand(i)\n            val y = operand(i\
    \ + 1)\n            op(i) match {\n                case \"+\" => stack.push(x\
    \ + y)\n                case \"-\" => stack.push(x - y)\n                case\
    \ \"*\" => stack.push(x * y)\n                case \"//\" => stack.push(x / y)\n\
    \                case \"**\" => stack.push(pow(x, y).toLong)\n            }\n\
    \        }\n        stack.pop", "        val operator = new Operator(op)\n   \
    \     val oper = operand.toList\n        val buff = new ListBuffer[Long]\n   \
    \     for (i <- 0 until op.length) {\n            val a = oper(i)\n          \
    \  val b = oper(i + 1)\n            buff += operator.calculate(a, b)\n       \
    \ }\n        return buff.sum", "        var stack = Stack[Long]()\n        for\
    \ (i <- 0 until op.length) {\n            val a = stack.pop()\n            val\
    \ b = operand(i + 1)\n            op(i) match {\n                case \"+\" =>\
    \ stack.push(a + b)\n                case \"-\" => stack.push(a - b)\n       \
    \         case \"*\" => stack.push(a * b)\n                case \"//\" => stack.push(a\
    \ / b)\n                case \"**\" => stack.push(pow(a, b).toLong)\n        \
    \    }\n        }\n        stack.pop()", "        var numStack = new Stack[Long]\n\
    \        var opStack = new Stack[String]\n        var i = 0\n        while (i\
    \ < op.length) {\n            opStack.push(op(i))\n            numStack.push(operand(i\
    \ + 1))\n            i += 1\n        }\n        numStack.push(operand(0))\n  \
    \      while (!opStack.isEmpty) {\n            val curr = opStack.pop\n      \
    \      if (curr == \"+\") {\n                val a = numStack.pop\n          \
    \      val b = numStack.pop\n                numStack.push(a + b)\n          \
    \  } else if (curr == \"-\") {\n                val a = numStack.pop\n       \
    \         val b = numStack.pop\n                numStack.push(b - a)\n       \
    \     } else if (curr == \"*\") {\n                val a = numStack.pop\n    \
    \            val b = numStack.pop\n                numStack.push(a * b)\n    \
    \        } else if (curr == \"//\") {\n                val a = numStack.pop\n\
    \                val b = numStack.pop\n                numStack.push(b / a)\n\
    \            } else if (curr == \"**\") {\n                val a = numStack.pop\n\
    \                val b = numStack.pop\n                numStack.push(pow(b, a).toLong)\n\
    \            }\n        }\n        numStack.pop", "        if (op.length != operand.length\
    \ - 1) {\n            throw new Exception\n        }\n        def operatorToFunc(op\
    \ : String) : (Long, Long) => Long = {\n            op match {\n             \
    \   case \"+\" => _ + _\n                case \"-\" => _ - _\n               \
    \ case \"*\" => _ * _\n                case \"//\" => _ / _\n                case\
    \ \"**\" => pow(_, _).toLong\n                case _ => throw new Exception\n\
    \            }\n        }\n        val func = op.map(operatorToFunc)\n       \
    \ func.zip(operand.zip(operand.tail)).foldLeft(0L)((s, e) => e._1(s, e._2._2))\
    \ + operand.head", "        if (op.length != operand.length - 1) throw new IllegalArgumentException\n\
    \        val stack = new Stack[Long]\n        stack.push(operand(0))\n       \
    \ for (i <- 0 until op.length) {\n            op(i) match {\n                case\
    \ \"+\" => {\n                    val a = stack.pop()\n                    val\
    \ b = operand(i + 1)\n                    stack.push(a + b)\n                }\n\
    \                case \"-\" => {\n                    val a = stack.pop()\n  \
    \                  val b = operand(i + 1)\n                    stack.push(a -\
    \ b)\n                }\n                case \"*\" => {\n                   \
    \ val a = stack.pop()\n                    val b = operand(i + 1)\n          \
    \          stack.push(a * b)\n                }\n                case \"//\" =>\
    \ {\n                    val a = stack.pop()\n                    val b = operand(i\
    \ + 1)\n                    stack.push(a / b)\n                }\n           \
    \     case \"**\" => {\n                    val a = stack.pop()\n            \
    \        val b = operand(i + 1)\n                    stack.push(pow(a, b).toLong)\n\
    \                }\n                case _ => throw new IllegalArgumentException\n\
    \            }\n        }\n        stack.pop()", "        var head = operand.head\n\
    \        val tail = operand.tail\n        val opIterator = op.iterator\n     \
    \   while (opIterator.hasNext) {\n            val o = opIterator.next\n      \
    \      val subHead = tail.head\n            o match {\n                case \"\
    +\" => head += subHead\n                case \"-\" => head -= subHead\n      \
    \          case \"*\" => head *= subHead\n                case \"//\" => head\
    \ = head / subHead\n                case \"**\" => head = pow(head, subHead).toLong\n\
    \            }\n            tail.remove(0)\n        }\n        head", "      \
    \  var acc = operand(0)\n        for (i <- 1 until operand.length) {\n       \
    \     op(i - 1) match {\n                case \"+\" => acc += operand(i)\n   \
    \             case \"-\" => acc -= operand(i)\n                case \"*\" => acc\
    \ *= operand(i)\n                case \"//\" => acc /= operand(i)\n          \
    \      case \"**\" => acc = pow(acc, operand(i)).toLong\n            }\n     \
    \   }\n        acc", "        var stack = Stack[Long]()\n        var ope = Stack[String]()\n\
    \        op.map(o => ope.push(o))\n        operand.map(op => stack.push(op))\n\
    \        while(!ope.isEmpty) {\n            ope.pop match {\n                case\
    \ \"+\" => {\n                    val a = stack.pop; val b = stack.pop\n     \
    \               stack.push(a + b)\n                }\n                case \"\
    -\" => {\n                    val a = stack.pop; val b = stack.pop\n         \
    \           stack.push(b - a)\n                }\n                case \"*\" =>\
    \ {\n                    val a = stack.pop; val b = stack.pop\n              \
    \      stack.push(a * b)\n                }\n                case \"//\" => {\n\
    \                    val a = stack.pop; val b = stack.pop\n                  \
    \  stack.push(b / a)\n                }\n                case \"**\" => {\n  \
    \                  val a = stack.pop; val b = stack.pop\n                    stack.push(pow(b,\
    \ a).toLong)\n                }\n            }\n        }\n        stack.pop",
  "        def loop(e : Long, ls : List[(String, Long)]) : Long = ls match {\n   \
    \         case Nil => e\n            case (r, o) :: rs => loop(r match {\n   \
    \             case \"+\" => e + o\n                case \"-\" => e - o\n     \
    \           case \"*\" => e * o\n                case \"//\" => e / o\n      \
    \          case \"**\" => e.toDouble.pow(o).toLong\n            }, rs)\n     \
    \   }\n        loop(operand.head, op.zip(operand.tail))", "        var res = operand(0)\n\
    \        for (i <- 1 until operand.length) {\n            op(i - 1) match {\n\
    \                case \"+\" => res += operand(i)\n                case \"-\" =>\
    \ res -= operand(i)\n                case \"*\" => res *= operand(i)\n       \
    \         case \"//\" => res /= operand(i)\n                case \"**\" => res\
    \ = pow(res, operand(i)).toLong\n            }\n        }\n        res", "   \
    \     val exp = new ListBuffer[String]\n        var i = 0\n        while (i <\
    \ op.length) {\n            exp += operand(i).toString\n            exp += op(i)\n\
    \            i += 1\n        }\n        exp += operand(i).toString\n        return\
    \ Expression.evalExpression(exp.toList)", "        if (op.length != operand.length\
    \ - 1) throw new IllegalArgumentException\n        val stack = new Stack[Long]\n\
    \        stack.push(operand(0))\n        op.zip(operand.tail).foreach {\n    \
    \        case (\"+\", operand) => stack.push(stack.pop + operand)\n          \
    \  case (\"-\", operand) => stack.push(stack.pop - operand)\n            case\
    \ (\"*\", operand) => stack.push(stack.pop * operand)\n            case (\"//\"\
    , operand) => stack.push(stack.pop / operand)\n            case (\"**\", operand)\
    \ => stack.push(pow(stack.pop, operand).toLong)\n        }\n        stack.pop",
  "      var stack = new Stack[Long]\n      for (i <- 0 until op.length) {\n     \
    \   val operand2 = stack.pop\n        val operand1 = stack.pop\n        val result\
    \ = if (op(i) == \"+\") operand1 + operand2\n                     else if (op(i)\
    \ == \"-\") operand1 - operand2\n                     else if (op(i) == \"*\"\
    ) operand1 * operand2\n                     else if (op(i) == \"//\") operand1\
    \ / operand2\n                     else if (op(i) == \"**\") pow(operand1, operand2).toLong\n\
    \                     else -1\n        stack.push(result)\n      }\n      stack.pop",
  "        var st = Stack[Long]()\n        var result = 0L\n        for (i <- 0 until\
    \ op.length) {\n            if (st.length >= 2) {\n                val num2 =\
    \ st.pop\n                val num1 = st.pop\n                op(i) match {\n \
    \                   case \"+\" => result = num1 + num2\n                    case\
    \ \"-\" => result = num1 - num2\n                    case \"*\" => result = num1\
    \ * num2\n                    case \"//\" => result = num1 / num2\n          \
    \          case \"**\" => result = pow(num1, num2).toLong\n                }\n\
    \                st.push(result)\n            }\n            else {\n        \
    \        st.push(operand(i))\n            }\n        }\n        st.push(operand(operand.length\
    \ - 1))\n        result = 0L\n        for (i <- 0 until st.length) {\n       \
    \     result += st(i)\n        }\n        result", "        val ans = new Stack[Long]\n\
    \        ans.push(operand(0))\n        for (i <- 1 until operand.length) {\n \
    \           op(i - 1) match {\n                case \"+\" => ans.push(ans.pop\
    \ + operand(i))\n                case \"-\" => ans.push(ans.pop - operand(i))\n\
    \                case \"*\" => ans.push(ans.pop * operand(i))\n              \
    \  case \"//\" => ans.push(ans.pop / operand(i))\n                case \"**\"\
    \ => ans.push(pow(ans.pop, operand(i)).toLong)\n            }\n        }\n   \
    \     ans.pop"]
stop_tokens:
- "\n    }\n"
