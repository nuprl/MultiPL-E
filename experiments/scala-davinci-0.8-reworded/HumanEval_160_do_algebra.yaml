name: HumanEval_160_do_algebra
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given two lists operator, and operand. The first list has basic algebra\
  \ operations, and \n    // the second list is a list of integers. Use the two given\
  \ lists to build the algebric \n    // expression and return the evaluation of this\
  \ expression.\n    // The basic algebra operations:\n    // Addition ( + ) \n  \
  \  // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor division (\
  \ // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+', '*',\
  \ '-']\n    // list = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    // => result\
  \ = 9\n    // Note:\n    // The length of operator list is equal to the length of\
  \ operand list minus one.\n    // Operand is a list of of non-negative integers.\n\
  \    // Operator list has at least one operator, and operand list has at least two\
  \ operands.\n    def doAlgebra(op : List[String], operand : List[Long]) : Long =\
  \ {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
  **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
  \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
  //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
  \n}\n"
completions: ["        if (op.isEmpty || operand.length == 1) operand.head\n     \
    \   else {\n            var res = operand.head\n            for (i <- 1 until\
    \ operand.length) {\n                op(i - 1) match {\n                    case\
    \ \"+\" => res += operand(i)\n                    case \"-\" => res -= operand(i)\n\
    \                    case \"*\" => res *= operand(i)\n                    case\
    \ \"//\" => res /= operand(i)\n                    case \"**\" => res = pow(res,\
    \ operand(i)).toLong\n                }\n            }\n            res\n    \
    \    }", "        if (op.length < 1 || operand.length < 2) return -1\n       \
    \ var result = operand(0)\n        for (i <- 0 until op.length) {\n          \
    \  if (op(i) == \"+\") result += operand(i + 1)\n            else if (op(i) ==\
    \ \"-\") result -= operand(i + 1)\n            else if (op(i) == \"*\") result\
    \ *= operand(i + 1)\n            else if (op(i) == \"//\") result /= operand(i\
    \ + 1)\n            else if (op(i) == \"**\") result = pow(result, operand(i +\
    \ 1)).toLong\n        }\n        return result", "        // val l1 = List(\"\
    a\", \"b\", \"c\")\n        // l1.foldLeft(\"d\")((acc, x) => acc + x) => dabc\n\
    \        // l1.foldRight(\"d\")((x, acc) => acc + x) => abcd\n        // foldLeft(op).zip(operand).foldLeft(0L)((acc,\
    \ x) => acc + x._1 + x._2)\n        op.foldLeft(operand)((acc, x) => acc.sliding(2,\
    \ 1).map(l => x match {\n            case \"+\" => l(0) + l(1)\n            case\
    \ \"-\" => l(0) - l(1)\n            case \"*\" => l(0) * l(1)\n            case\
    \ \"//\" => l(0) / l(1)\n            case \"**\" => pow(l(0), l(1)).toLong\n \
    \       }).toList ::: List(acc.last)).head", "        var result = operand(0)\n\
    \        for (i <- 1 until operand.length) {\n            op(i - 1) match {\n\
    \                case \"+\" => result += operand(i)\n                case \"-\"\
    \ => result -= operand(i)\n                case \"*\" => result *= operand(i)\n\
    \                case \"//\" => result /= operand(i)\n                case \"\
    **\" => result = pow(result, operand(i)).toLong\n            }\n        }\n  \
    \      result", "        var stack = Stack[Long]()\n        for (i <- 0 until\
    \ op.length) {\n            val x = operand(i)\n            val y = operand(i\
    \ + 1)\n            op(i) match {\n                case \"+\" => stack.push(x\
    \ + y)\n                case \"-\" => stack.push(x - y)\n                case\
    \ \"*\" => stack.push(x * y)\n                case \"//\" => stack.push(x / y)\n\
    \                case \"**\" => stack.push(pow(x, y).toLong)\n            }\n\
    \        }\n        stack.pop", "        val operator = new Operator(op)\n   \
    \     val oper = operand.toList\n        val buff = new ListBuffer[Long]\n   \
    \     for (i <- 0 until op.length) {\n            val a = oper(i)\n          \
    \  val b = oper(i + 1)\n            buff += operator.calculate(a, b)\n       \
    \ }\n        return buff.sum", "        var stack = Stack[Long]()\n        for\
    \ (i <- 0 until op.length) {\n            val a = stack.pop()\n            val\
    \ b = operand(i + 1)\n            op(i) match {\n                case \"+\" =>\
    \ stack.push(a + b)\n                case \"-\" => stack.push(a - b)\n       \
    \         case \"*\" => stack.push(a * b)\n                case \"//\" => stack.push(a\
    \ / b)\n                case \"**\" => stack.push(pow(a, b).toLong)\n        \
    \    }\n        }\n        stack.pop()", "        var numStack = new Stack[Long]\n\
    \        var opStack = new Stack[String]\n        var i = 0\n        while (i\
    \ < op.length) {\n            opStack.push(op(i))\n            numStack.push(operand(i\
    \ + 1))\n            i += 1\n        }\n        numStack.push(operand(0))\n  \
    \      while (!opStack.isEmpty) {\n            val curr = opStack.pop\n      \
    \      if (curr == \"+\") {\n                val a = numStack.pop\n          \
    \      val b = numStack.pop\n                numStack.push(a + b)\n          \
    \  } else if (curr == \"-\") {\n                val a = numStack.pop\n       \
    \         val b = numStack.pop\n                numStack.push(b - a)\n       \
    \     } else if (curr == \"*\") {\n                val a = numStack.pop\n    \
    \            val b = numStack.pop\n                numStack.push(a * b)\n    \
    \        } else if (curr == \"//\") {\n                val a = numStack.pop\n\
    \                val b = numStack.pop\n                numStack.push(b / a)\n\
    \            } else if (curr == \"**\") {\n                val a = numStack.pop\n\
    \                val b = numStack.pop\n                numStack.push(pow(b, a).toLong)\n\
    \            }\n        }\n        numStack.pop", "        if (op.length != operand.length\
    \ - 1) {\n            throw new Exception\n        }\n        def operatorToFunc(op\
    \ : String) : (Long, Long) => Long = {\n            op match {\n             \
    \   case \"+\" => _ + _\n                case \"-\" => _ - _\n               \
    \ case \"*\" => _ * _\n                case \"//\" => _ / _\n                case\
    \ \"**\" => pow(_, _).toLong\n                case _ => throw new Exception\n\
    \            }\n        }\n        val func = op.map(operatorToFunc)\n       \
    \ func.zip(operand.zip(operand.tail)).foldLeft(0L)((s, e) => e._1(s, e._2._2))\
    \ + operand.head", "        if (op.length != operand.length - 1) throw new IllegalArgumentException\n\
    \        val stack = new Stack[Long]\n        stack.push(operand(0))\n       \
    \ for (i <- 0 until op.length) {\n            op(i) match {\n                case\
    \ \"+\" => {\n                    val a = stack.pop()\n                    val\
    \ b = operand(i + 1)\n                    stack.push(a + b)\n                }\n\
    \                case \"-\" => {\n                    val a = stack.pop()\n  \
    \                  val b = operand(i + 1)\n                    stack.push(a -\
    \ b)\n                }\n                case \"*\" => {\n                   \
    \ val a = stack.pop()\n                    val b = operand(i + 1)\n          \
    \          stack.push(a * b)\n                }\n                case \"//\" =>\
    \ {\n                    val a = stack.pop()\n                    val b = operand(i\
    \ + 1)\n                    stack.push(a / b)\n                }\n           \
    \     case \"**\" => {\n                    val a = stack.pop()\n            \
    \        val b = operand(i + 1)\n                    stack.push(pow(a, b).toLong)\n\
    \                }\n                case _ => throw new IllegalArgumentException\n\
    \            }\n        }\n        stack.pop()", "        var head = operand.head\n\
    \        val tail = operand.tail\n        val opIterator = op.iterator\n     \
    \   while (opIterator.hasNext) {\n            val o = opIterator.next\n      \
    \      val subHead = tail.head\n            o match {\n                case \"\
    +\" => head += subHead\n                case \"-\" => head -= subHead\n      \
    \          case \"*\" => head *= subHead\n                case \"//\" => head\
    \ = head / subHead\n                case \"**\" => head = pow(head, subHead).toLong\n\
    \            }\n            tail.remove(0)\n        }\n        head", "      \
    \  var acc = operand(0)\n        for (i <- 1 until operand.length) {\n       \
    \     op(i - 1) match {\n                case \"+\" => acc += operand(i)\n   \
    \             case \"-\" => acc -= operand(i)\n                case \"*\" => acc\
    \ *= operand(i)\n                case \"//\" => acc /= operand(i)\n          \
    \      case \"**\" => acc = pow(acc, operand(i)).toLong\n            }\n     \
    \   }\n        acc", "        var stack = Stack[Long]()\n        var ope = Stack[String]()\n\
    \        op.map(o => ope.push(o))\n        operand.map(op => stack.push(op))\n\
    \        while(!ope.isEmpty) {\n            ope.pop match {\n                case\
    \ \"+\" => {\n                    val a = stack.pop; val b = stack.pop\n     \
    \               stack.push(a + b)\n                }\n                case \"\
    -\" => {\n                    val a = stack.pop; val b = stack.pop\n         \
    \           stack.push(b - a)\n                }\n                case \"*\" =>\
    \ {\n                    val a = stack.pop; val b = stack.pop\n              \
    \      stack.push(a * b)\n                }\n                case \"//\" => {\n\
    \                    val a = stack.pop; val b = stack.pop\n                  \
    \  stack.push(b / a)\n                }\n                case \"**\" => {\n  \
    \                  val a = stack.pop; val b = stack.pop\n                    stack.push(pow(b,\
    \ a).toLong)\n                }\n            }\n        }\n        stack.pop",
  "        def loop(e : Long, ls : List[(String, Long)]) : Long = ls match {\n   \
    \         case Nil => e\n            case (r, o) :: rs => loop(r match {\n   \
    \             case \"+\" => e + o\n                case \"-\" => e - o\n     \
    \           case \"*\" => e * o\n                case \"//\" => e / o\n      \
    \          case \"**\" => e.toDouble.pow(o).toLong\n            }, rs)\n     \
    \   }\n        loop(operand.head, op.zip(operand.tail))", "        var res = operand(0)\n\
    \        for (i <- 1 until operand.length) {\n            op(i - 1) match {\n\
    \                case \"+\" => res += operand(i)\n                case \"-\" =>\
    \ res -= operand(i)\n                case \"*\" => res *= operand(i)\n       \
    \         case \"//\" => res /= operand(i)\n                case \"**\" => res\
    \ = pow(res, operand(i)).toLong\n            }\n        }\n        res", "   \
    \     val exp = new ListBuffer[String]\n        var i = 0\n        while (i <\
    \ op.length) {\n            exp += operand(i).toString\n            exp += op(i)\n\
    \            i += 1\n        }\n        exp += operand(i).toString\n        return\
    \ Expression.evalExpression(exp.toList)", "        if (op.length != operand.length\
    \ - 1) throw new IllegalArgumentException\n        val stack = new Stack[Long]\n\
    \        stack.push(operand(0))\n        op.zip(operand.tail).foreach {\n    \
    \        case (\"+\", operand) => stack.push(stack.pop + operand)\n          \
    \  case (\"-\", operand) => stack.push(stack.pop - operand)\n            case\
    \ (\"*\", operand) => stack.push(stack.pop * operand)\n            case (\"//\"\
    , operand) => stack.push(stack.pop / operand)\n            case (\"**\", operand)\
    \ => stack.push(pow(stack.pop, operand).toLong)\n        }\n        stack.pop",
  "      var stack = new Stack[Long]\n      for (i <- 0 until op.length) {\n     \
    \   val operand2 = stack.pop\n        val operand1 = stack.pop\n        val result\
    \ = if (op(i) == \"+\") operand1 + operand2\n                     else if (op(i)\
    \ == \"-\") operand1 - operand2\n                     else if (op(i) == \"*\"\
    ) operand1 * operand2\n                     else if (op(i) == \"//\") operand1\
    \ / operand2\n                     else if (op(i) == \"**\") pow(operand1, operand2).toLong\n\
    \                     else -1\n        stack.push(result)\n      }\n      stack.pop",
  "        var st = Stack[Long]()\n        var result = 0L\n        for (i <- 0 until\
    \ op.length) {\n            if (st.length >= 2) {\n                val num2 =\
    \ st.pop\n                val num1 = st.pop\n                op(i) match {\n \
    \                   case \"+\" => result = num1 + num2\n                    case\
    \ \"-\" => result = num1 - num2\n                    case \"*\" => result = num1\
    \ * num2\n                    case \"//\" => result = num1 / num2\n          \
    \          case \"**\" => result = pow(num1, num2).toLong\n                }\n\
    \                st.push(result)\n            }\n            else {\n        \
    \        st.push(operand(i))\n            }\n        }\n        st.push(operand(operand.length\
    \ - 1))\n        result = 0L\n        for (i <- 0 until st.length) {\n       \
    \     result += st(i)\n        }\n        result", "        val ans = new Stack[Long]\n\
    \        ans.push(operand(0))\n        for (i <- 1 until operand.length) {\n \
    \           op(i - 1) match {\n                case \"+\" => ans.push(ans.pop\
    \ + operand(i))\n                case \"-\" => ans.push(ans.pop - operand(i))\n\
    \                case \"*\" => ans.push(ans.pop * operand(i))\n              \
    \  case \"//\" => ans.push(ans.pop / operand(i))\n                case \"**\"\
    \ => ans.push(pow(ans.pop, operand(i)).toLong)\n            }\n        }\n   \
    \     ans.pop", "        var stack = new Stack[Long]\n        stack.push(operand(0))\n\
    \        var i = 0\n        while (i < op.length) {\n            var val1 = stack.pop\n\
    \            var val2 = operand(i + 1)\n            var result = op(i) match {\n\
    \                case \"+\" => val1 + val2\n                case \"-\" => val1\
    \ - val2\n                case \"*\" => val1 * val2\n                case \"//\"\
    \ => val1 / val2\n                case \"**\" => pow(val1, val2).toLong\n    \
    \        }\n            stack.push(result)\n            i += 1\n        }\n  \
    \      stack.pop", "        val r = new scala.util.Random\n        val terms =\
    \ new ArrayBuffer[Long]\n        val es = new ArrayBuffer[String]\n        val\
    \ ans = new ArrayBuffer[String]\n        val es2 = new ArrayBuffer[String]\n \
    \       val ans2 = new ArrayBuffer[String]\n        val exprs = new ArrayBuffer[String]\n\
    \        for (i <- 0 until op.length) {\n            terms += operand(i)\n   \
    \         es += op(i)\n            exprs += (terms.map(_.toString).mkString(es.mkString)\
    \ + operand(i + 1).toString)\n        }\n        for (expr <- exprs) {\n     \
    \       val temp = expr.replaceAll(\"**\", \"\\\\^\")\n            ans += temp\n\
    \        }\n        val exp = ans.zipWithIndex.maxBy(_._1.toInt)._2\n        val\
    \ right = ans(exp).split(\"\\\\^\")\n        val tmp = if (right.length > 1) {\n\
    \            es2 += \"**\"\n            terms += right(0).toLong\n           \
    \ terms += right(1).toLong\n            ans2 += terms.map(_.toString).mkString(es2.mkString)\n\
    \            ans2.mkString.toInt\n        } else {\n            ans(exp).toInt\n\
    \        }\n        val exprs2 = new ArrayBuffer[String]\n        for (i <- 0\
    \ until op.length) {\n            terms += operand(i)\n            es += op(i)\n\
    \            exprs2 += (terms.map(_.toString).mkString(es.mkString) + operand(i\
    \ + 1).toString)\n        }\n        exprs2(exp) = tmp.toString\n        exprs2.mkString.toInt",
  "        // Remove the first one from operand list\n        val head = operand.head\n\
    \        val tail = operand.tail\n        // Use foldLeft to loop through the\
    \ list, and compute the result\n        tail.foldLeft(head)((a, b) => {\n    \
    \        op.head match {\n                case \"+\" => a + b\n              \
    \  case \"-\" => a - b\n                case \"*\" => a * b\n                case\
    \ \"//\" => a / b\n                case \"**\" => pow(a, b).toLong\n         \
    \   }\n        })", "        if (op.length == 0 || operand.length == 0) return\
    \ 0\n        val opStack = Stack[String]()\n        val operandStack = Stack[Long]()\n\
    \        opStack.push(op(0))\n        operandStack.push(operand(0))\n        for\
    \ (i <- 1 until op.length) {\n            if (op(i) == \"-\" || op(i) == \"+\"\
    ) {\n                val opTop = opStack.top\n                if (opTop == \"\
    -\" || opTop == \"+\") {\n                    val op1 = operandStack.pop\n   \
    \                 val op2 = operandStack.pop\n                    val opt = opStack.pop\n\
    \                    val exp = if (opt == \"+\") op1 + op2 else op1 - op2\n  \
    \                  operandStack.push(exp)\n                }\n               \
    \ opStack.push(op(i))\n                operandStack.push(operand(i))\n       \
    \     } else if (op(i) == \"*\" || op(i) == \"//\") {\n                val opTop\
    \ = opStack.top\n                if (opTop == \"*\" || opTop == \"//\") {\n  \
    \                  val op1 = operandStack.pop\n                    val op2 = operandStack.pop\n\
    \                    val opt = opStack.pop\n                    val exp = if (opt\
    \ == \"*\") op1 * op2 else op1 / op2\n                    operandStack.push(exp)\n\
    \                }\n                opStack.push(op(i))\n                operandStack.push(operand(i))\n\
    \            } else if (op(i) == \"**\") {\n                val opTop = opStack.top\n\
    \                if (opTop == \"**\") {\n                    val op1 = operandStack.pop\n\
    \                    val op2 = operandStack.pop\n                    val opt =\
    \ opStack.pop\n                    val exp = pow(op1, op2).toLong\n          \
    \          operandStack.push(exp)\n                }\n                opStack.push(op(i))\n\
    \                operandStack.push(operand(i))\n            }\n        }\n   \
    \     val op1 = operandStack.pop\n        val op2 = operandStack.pop\n       \
    \ val opt = opStack", "        require(op.length == operand.length - 1)\n    \
    \    var ans = operand(0)\n        for (i <- 0 until op.length) {\n          \
    \  op(i) match {\n                case \"+\" => ans += operand(i + 1)\n      \
    \          case \"-\" => ans -= operand(i + 1)\n                case \"*\" =>\
    \ ans *= operand(i + 1)\n                case \"//\" => ans = ans / operand(i\
    \ + 1)\n                case \"**\" => ans = pow(ans, operand(i + 1)).toLong\n\
    \            }\n        }\n        ans", "        if (op.length != operand.length\
    \ - 1) throw new Error(\"Invalid operator and operand list.\")\n        var operandStack\
    \ = new Stack[Long]\n        for (i <- 0 until operand.length) {\n           \
    \ operandStack.push(operand(i))\n        }\n        for (i <- 0 until op.length)\
    \ {\n            if (op(i) == \"+\") {\n                val operand1 = operandStack.pop\n\
    \                val operand2 = operandStack.pop\n                operandStack.push(operand1\
    \ + operand2)\n            } else if (op(i) == \"-\") {\n                val operand1\
    \ = operandStack.pop\n                val operand2 = operandStack.pop\n      \
    \          operandStack.push(operand1 - operand2)\n            } else if (op(i)\
    \ == \"*\") {\n                val operand1 = operandStack.pop\n             \
    \   val operand2 = operandStack.pop\n                operandStack.push(operand1\
    \ * operand2)\n            } else if (op(i) == \"//\") {\n                val\
    \ operand1 = operandStack.pop\n                val operand2 = operandStack.pop\n\
    \                operandStack.push(operand1 / operand2)\n            } else if\
    \ (op(i) == \"**\") {\n                val operand1 = operandStack.pop\n     \
    \           val operand2 = operandStack.pop\n                operandStack.push(pow(operand1,\
    \ operand2).toLong)\n            } else {\n                throw new Error(\"\
    Operator should be either '+', '-', '*', '//', or '**'.\")\n            }\n  \
    \      }\n        return operandStack.pop", "        // 1, calc by foldLeft,\n\
    \        // op.foldLeft(operand.head){(accumulator,op) =>\n        //     op match\
    \ {\n        //         case \"+\" => accumulator + operand(op.indexOf(op)+1)\n\
    \        //         case \"-\" => accumulator - operand(op.indexOf(op)+1)\n  \
    \      //         case \"*\" => accumulator * operand(op.indexOf(op)+1)\n    \
    \    //         case \"//\" => accumulator / operand(op.indexOf(op)+1)\n     \
    \   //         case \"**\" => pow(accumulator,operand(op.indexOf(op)+1)).toLong\n\
    \        //     }\n        // }\n        // 2, calc by foldRight,\n        //\
    \ op.foldRight(operand.last){(op,accumulator) =>\n        //     op match {\n\
    \        //         case \"+\" => operand(op.indexOf(op)-1) + accumulator\n  \
    \      //         case \"-\" => operand(op.indexOf(op)-1) - accumulator\n    \
    \    //         case \"*\" => operand(op.indexOf(op)-1) * accumulator\n      \
    \  //         case \"//\" => operand(op.indexOf(op)-1) / accumulator\n       \
    \ //         case \"**\" => pow(operand(op.indexOf(op)-1),accumulator).toLong\n\
    \        //     }\n        // }\n        // 3, calc by partition (more elegant\
    \ than fold, since it can use the same operator twice)\n        // operand.indices.partition(x\
    \ => x % 2 == 0).foreach(x => println(x.mkString(\" \")))\n        // operand.indices.partition(x\
    \ => x % 2 == 0).foreach(x => x.foreach(y => print(operand(y)+\" \")))\n     \
    \   // operand.indices.partition(x => x % 2 == 0).foreach(x => x.foreach(y =>\
    \ print(op(y-1)+\" \")))\n        // println\n        operand.indices.partition(x\
    \ => x % 2 == 0).foreach(x => x.", "        require(op.length == operand.length\
    \ - 1)\n        var stack = new Stack[Long]\n        for (i <- operand) {\n  \
    \          stack.push(i)\n        }\n        for (op <- op) {\n            val\
    \ v1 = stack.pop\n            val v2 = stack.pop\n            op match {\n   \
    \             case \"+\" => stack.push(v1 + v2)\n                case \"-\" =>\
    \ stack.push(v2 - v1)\n                case \"*\" => stack.push(v1 * v2)\n   \
    \             case \"//\" => stack.push(v2 / v1)\n                case \"**\"\
    \ => stack.push(pow(v2, v1).toLong)\n            }\n        }\n        return\
    \ stack.pop", "        val opMap = new HashMap[String, (Long, Long) => Long]()\n\
    \        opMap += \"+\" -> {_ + _}\n        opMap += \"-\" -> {_ - _}\n      \
    \  opMap += \"*\" -> {_ * _}\n        opMap += \"//\" -> {_ / _}\n        opMap\
    \ += \"**\" -> {(a, b) => pow(a, b).toLong}\n        var it = op.iterator\n  \
    \      var res = operand.head\n        for (operand <- operand.tail) {\n     \
    \       val f = opMap(it.next)\n            res = f(res, operand)\n        }\n\
    \        res", "        var result = operand(0)\n        for (i <- 0 until op.length)\
    \ {\n            op(i) match {\n                case \"+\" => result += operand(i\
    \ + 1)\n                case \"-\" => result -= operand(i + 1)\n             \
    \   case \"*\" => result *= operand(i + 1)\n                case \"//\" => result\
    \ /= operand(i + 1)\n                case \"**\" => result = pow(result, operand(i\
    \ + 1)).toLong\n            }\n        }\n        result", "        if (op.length\
    \ == 0 || operand.length < 2) {\n            println(\"wrong input\")\n      \
    \      return -1\n        }\n        var tmp = op.zip(operand.tail)\n        var\
    \ res = operand.head\n        for (x <- tmp) {\n            x._1 match {\n   \
    \             case \"+\" => res += x._2\n                case \"-\" => res -=\
    \ x._2\n                case \"*\" => res *= x._2\n                case \"//\"\
    \ => res /= x._2\n                case \"**\" => res = pow(res, x._2).toLong\n\
    \                case _ => println(\"wrong input\")\n            }\n        }\n\
    \        return res", "        val sb = new StringBuilder\n        (0 until op.length).foreach(i\
    \ => sb.append(operand(i)).append(op(i)))\n        sb.append(operand(op.length)).toString.toLong",
  "        var operator = new Queue[String]\n        var operand = new Queue[Long]\n\
    \        for (i <- 0 until op.length) {\n            operator += op(i)\n     \
    \   }\n        for (i <- 0 until operand.length) {\n            operand += operand(i)\n\
    \        }\n        while (operator.length > 0) {\n            val c = operator.dequeue\n\
    \            val l = operand.dequeue\n            val r = operand.dequeue\n  \
    \          c match {\n                case \"+\" => operand += l + r\n       \
    \         case \"-\" => operand += l - r\n                case \"*\" => operand\
    \ += l * r\n                case \"//\" => operand += l / r\n                case\
    \ \"**\" => operand += pow(l, r).toLong\n            }\n        }\n        operand.dequeue",
  "        var result = 0L\n        for(i <- 1 until operand.length) {\n         \
    \   op(i - 1) match {\n                case \"+\" => result = result + operand(i\
    \ - 1) + operand(i)\n                case \"-\" => result = result + operand(i\
    \ - 1) - operand(i)\n                case \"*\" => result = result + operand(i\
    \ - 1) * operand(i)\n                case \"//\" => result = result + operand(i\
    \ - 1) / operand(i)\n                case \"**\" => result = result + pow(operand(i\
    \ - 1), operand(i)).toLong\n            }\n        }\n        result", "     \
    \   var ex = operand(0)\n        for (i <- 1 until operand.length) {\n       \
    \     op(i - 1) match {\n                case \"+\" => ex += operand(i)\n    \
    \            case \"-\" => ex -= operand(i)\n                case \"*\" => ex\
    \ *= operand(i)\n                case \"//\" => ex /= operand(i)\n           \
    \     case \"**\" => ex = pow(ex, operand(i)).toLong\n            }\n        }\n\
    \        ex", "        operand.reduceLeft((a, b) => op.head match {\n        \
    \    case \"+\" => a + b\n            case \"-\" => a - b\n            case \"\
    *\" => a * b\n            case \"//\" => a / b\n            case \"**\" => pow(a,\
    \ b).toLong\n        })", "        if (op.length != operand.length - 1) throw\
    \ new IllegalArgumentException(\"Size of two lists are not the same\")\n     \
    \   var stack = new Stack[Long]\n        stack.push(operand(0))\n        for (i\
    \ <- 0 until op.length) {\n            var x = stack.pop\n            var y =\
    \ operand(i + 1)\n            op(i) match {\n                case \"+\" => stack.push(x\
    \ + y)\n                case \"-\" => stack.push(x - y)\n                case\
    \ \"*\" => stack.push(x * y)\n                case \"//\" => stack.push(x / y)\n\
    \                case \"**\" => stack.push(pow(x, y).toLong)\n               \
    \ case _ => throw new IllegalArgumentException(\"Invalid operator\")\n       \
    \     }\n        }\n        stack.pop", "        var stk = new Stack[Long]\n \
    \       var opr = new Stack[String]\n        var ret = 0L\n        var p = 0\n\
    \        while (p < op.length) {\n            while (opr.nonEmpty && (opr.top\
    \ == \"*\" || opr.top == \"/\")) {\n                opr.pop match {\n        \
    \            case \"*\" => stk.push(stk.pop * stk.pop)\n                    case\
    \ \"/\" => {\n                        val d1 = stk.pop\n                     \
    \   val d2 = stk.pop\n                        stk.push(d2 / d1)\n            \
    \        }\n                }\n            }\n            opr.push(op(p))\n  \
    \          stk.push(operand(p + 1))\n            p += 1\n        }\n        while\
    \ (opr.nonEmpty) {\n            opr.pop match {\n                case \"+\" =>\
    \ stk.push(stk.pop + stk.pop)\n                case \"-\" => {\n             \
    \       val d1 = stk.pop\n                    val d2 = stk.pop\n             \
    \       stk.push(d2 - d1)\n                }\n                case \"*\" => stk.push(stk.pop\
    \ * stk.pop)\n                case \"/\" => {\n                    val d1 = stk.pop\n\
    \                    val d2 = stk.pop\n                    stk.push(d2 / d1)\n\
    \                }\n            }\n        }\n        stk.pop", "        // A\
    \ map from operator string to binary operator function.\n        val op2Fun :\
    \ Map[String, (Long, Long) => Long] = Map(\n            \"+\" -> (_ + _),\n  \
    \          \"-\" -> (_ - _),\n            \"*\" -> (_ * _),\n            \"//\"\
    \ -> (_ / _),\n            \"**\" -> (pow(_, _).toLong)\n        )\n        //\
    \ Create a list of string of operand, and operator, and combine it together.\n\
    \        val list = (for (i <- 0 until op.length) yield operand(i).toString +\
    \ op(i)).toList ++ List(operand.last.toString)\n        // Replace all / with\
    \ //, and * with * to satisfy the syntax requirement of Scala.\n        // e.g.:\
    \ 2 / 3 / 4 => 2 // 3 // 4\n        val expression = list.mkString.replaceAll(\"\
    /\", \"//\").replaceAll(\"\\\\*\", \"*\")\n        // Evaluate the expression.\n\
    \        eval(expression).toInt", "        var result = operand(0)\n        for\
    \ (i <- 0 until op.length) {\n            op(i) match {\n                case\
    \ \"+\" => result += operand(i + 1)\n                case \"-\" => result -= operand(i\
    \ + 1)\n                case \"*\" => result *= operand(i + 1)\n             \
    \   case \"//\" => result /= operand(i + 1)\n                case \"**\" => result\
    \ = pow(result, operand(i + 1)).toLong\n            }\n        }\n        result",
  "        val expression = op.zip(operand.tail).foldLeft(operand.head)((current,\
    \ next) => {\n            val (operator, operand) = next\n            operator\
    \ match {\n                case \"+\" => current + operand\n                case\
    \ \"-\" => current - operand\n                case \"*\" => current * operand\n\
    \                case \"//\" => current / operand\n                case \"**\"\
    \ => pow(current, operand).toLong\n            }\n        })\n        expression",
  "        if (op.length == 0) operand(0)\n        else {\n            val a = operand(0)\n\
    \            val b = operand(1)\n            op(0) match {\n                case\
    \ \"+\" => doAlgebra(op.drop(1), (a + b) :: operand.drop(2))\n               \
    \ case \"-\" => doAlgebra(op.drop(1), (a - b) :: operand.drop(2))\n          \
    \      case \"*\" => doAlgebra(op.drop(1), (a * b) :: operand.drop(2))\n     \
    \           case \"//\" => doAlgebra(op.drop(1), (a / b) :: operand.drop(2))\n\
    \                case \"**\" => doAlgebra(op.drop(1), (pow(a, b).toLong) :: operand.drop(2))\n\
    \            }\n        }", "        val opStack = Stack[String]()\n        val\
    \ operandStack = Stack[Long]()\n        for (i <- 0 until op.length) {\n     \
    \       val curOp = op(i)\n            val n1 = operand(i)\n            val n2\
    \ = operand(i + 1)\n            if (curOp == \"*\" || curOp == \"/\") {\n    \
    \            if (opStack.isEmpty) {\n                    opStack.push(curOp)\n\
    \                    operandStack.push(n1)\n                } else {\n       \
    \             val prevOp = opStack.pop\n                    val prevOperand =\
    \ operandStack.pop\n                    if (prevOp == \"*\" || prevOp == \"/\"\
    ) {\n                        opStack.push(prevOp)\n                        operandStack.push(operate(prevOp,\
    \ prevOperand, n1))\n                    } else {\n                        opStack.push(prevOp)\n\
    \                        operandStack.push(prevOperand)\n                    \
    \    opStack.push(curOp)\n                        operandStack.push(n1)\n    \
    \                }\n                }\n            } else {\n                opStack.push(curOp)\n\
    \                operandStack.push(n1)\n            }\n        }\n        opStack.push(op.last)\n\
    \        operandStack.push(operand.last)\n        var result = 0L\n        while\
    \ (!opStack.isEmpty) {\n            val op = opStack.pop\n            val n1 =\
    \ operandStack.pop\n            val n2 = operandStack.pop\n            result\
    \ = operate(op, n1, n2)\n            operandStack.push(result)\n        }\n  \
    \      result", "        if (op.length == 0) return operand(0)\n        var ans\
    \ = operand(0)\n        for (i <- 1 until operand.length) {\n            op(i\
    \ - 1) match {\n                case \"+\" => ans += operand(i)\n            \
    \    case \"-\" => ans -= operand(i)\n                case \"*\" => ans *= operand(i)\n\
    \                case \"//\" => ans /= operand(i)\n                case \"**\"\
    \ => ans = pow(ans, operand(i)).toLong\n            }\n        }\n        ans",
  "        val l = operand.toArray\n        val o = op.toArray\n        var result\
    \ = l(0)\n        for (i <- 0 until o.length) {\n            o(i) match {\n  \
    \              case \"+\" => result += l(i + 1)\n                case \"-\" =>\
    \ result -= l(i + 1)\n                case \"*\" => result *= l(i + 1)\n     \
    \           case \"//\" => result /= l(i + 1)\n                case \"**\" =>\
    \ result = pow(result, l(i + 1)).toLong\n            }\n        }\n        result",
  "        val q = new Queue[Long]\n        for (v <- operand) q.enqueue(v)\n    \
    \    for (v <- op) {\n            v match {\n                case \"+\" => q.enqueue(q.dequeue\
    \ + q.dequeue)\n                case \"-\" => q.enqueue(-q.dequeue + q.dequeue)\n\
    \                case \"*\" => q.enqueue(q.dequeue * q.dequeue)\n            \
    \    case \"//\" => q.enqueue(q.dequeue / q.dequeue)\n                case \"\
    **\" => q.enqueue(pow(q.dequeue, q.dequeue).toLong)\n            }\n        }\n\
    \        q.dequeue", "        // Fill up this function body\n        // `op` is\
    \ a list of operators in string format\n        // `operand` is a list of operands\
    \ in integer format\n        var res = operand(0)\n        for (i <- 0 until op.length)\
    \ {\n            if (op(i) == \"+\") res += operand(i + 1)\n            else if\
    \ (op(i) == \"-\") res -= operand(i + 1)\n            else if (op(i) == \"*\"\
    ) res *= operand(i + 1)\n            else if (op(i) == \"//\") res /= operand(i\
    \ + 1)\n            else if (op(i) == \"**\") res = pow(res, operand(i + 1)).toLong\n\
    \        }\n        res", "        //var x = 1\n        //for (oper <- op) {\n\
    \            //if (oper == \"*\") {\n                //x *= operand\n        \
    \    //}\n        //}\n        op.zip(operand.drop(1)).foldLeft(operand.head)((n,\
    \ e) => (e._1, e._2) match {\n            case (\"+\", x) => n + x\n         \
    \   case (\"-\", x) => n - x\n            case (\"*\", x) => n * x\n         \
    \   case (\"//\", x) => n / x\n            case (\"**\", x) => pow(n, x).toLong\n\
    \        })", "        var r : Long = operand(0)\n        for (i <- 0 until op.length)\
    \ {\n            val e = operand(i + 1)\n            r = op(i) match {\n     \
    \           case \"+\" => r + e\n                case \"-\" => r - e\n       \
    \         case \"*\" => r * e\n                case \"//\" => r / e\n        \
    \        case \"**\" => pow(r, e).toLong\n            }\n        }\n        r",
  "        var stack = new Stack[Long]\n        stack.push(operand(0))\n        for\
    \ (i <- 1 until operand.length) {\n            val cur = operand(i)\n        \
    \    op(i - 1) match {\n                case \"+\" => {\n                    val\
    \ x = stack.pop()\n                    stack.push(x + cur)\n                }\n\
    \                case \"-\" => {\n                    val x = stack.pop()\n  \
    \                  stack.push(x - cur)\n                }\n                case\
    \ \"*\" => {\n                    val x = stack.pop()\n                    stack.push(x\
    \ * cur)\n                }\n                case \"//\" => {\n              \
    \      val x = stack.pop()\n                    stack.push(x / cur)\n        \
    \        }\n                case \"**\" => {\n                    val x = stack.pop()\n\
    \                    stack.push(pow(x, cur).toLong)\n                }\n     \
    \       }\n        }\n        stack.pop()", "        var result = operand(0)\n\
    \        for (i <- 1 until operand.length) {\n            if (op(i - 1) == \"\
    +\") result += operand(i)\n            else if (op(i - 1) == \"-\") result -=\
    \ operand(i)\n            else if (op(i - 1) == \"*\") result *= operand(i)\n\
    \            else if (op(i - 1) == \"//\") result /= operand(i)\n            else\
    \ if (op(i - 1) == \"**\") result = pow(result, operand(i)).toLong\n        }\n\
    \        return result", "\t\toperand.tail.foldLeft(operand.head)((a, b) => op.head\
    \ match {\n\t\t\tcase \"+\" => a + b\n\t\t\tcase \"-\" => a - b\n\t\t\tcase \"\
    *\" => a * b\n\t\t\tcase \"//\" => a / b\n\t\t\tcase \"**\" => pow(a, b).toLong\n\
    \t\t})", "        def f(op : List[String], operand : List[Long], st : Stack[Long])\
    \ : Long = {\n            if (operand.isEmpty) st.pop\n            else {\n  \
    \              st.push(operand.head)\n                val e = op.head match {\n\
    \                    case \"+\" => st.pop + st.pop\n                    case \"\
    -\" => -st.pop + st.pop\n                    case \"*\" => st.pop * st.pop\n \
    \                   case \"//\" => st.pop / st.pop\n                    case \"\
    **\" => pow(st.pop, st.pop).toLong\n                }\n                st.push(e)\n\
    \                f(op.tail, operand.tail, st)\n            }\n        }\n    \
    \    f(op, operand, new Stack[Long])", "        var result = operand(0)\n    \
    \    var i = 0\n        while (i < op.length) {\n            if (op(i) == \"+\"\
    ) result += operand(i + 1)\n            else if (op(i) == \"-\") result -= operand(i\
    \ + 1)\n            else if (op(i) == \"*\") result *= operand(i + 1)\n      \
    \      else if (op(i) == \"//\") result /= operand(i + 1)\n            else if\
    \ (op(i) == \"**\") result = pow(result, operand(i + 1)).toLong\n            i\
    \ += 1\n        }\n        result", "        // If this function is not correct,\
    \ the test cases in main function will not work.\n        var result = operand(0)\n\
    \        for (i <- 0 until op.length) {\n            op(i) match {\n         \
    \       case \"+\" => result += operand(i + 1)\n                case \"-\" =>\
    \ result -= operand(i + 1)\n                case \"*\" => result *= operand(i\
    \ + 1)\n                case \"//\" => result /= operand(i + 1)\n            \
    \    case \"**\" => result = pow(result, operand(i + 1)).toLong\n            }\n\
    \        }\n        result", "        val stack = new Stack[Long]\n        operand.foreach(i\
    \ => stack.push(i))\n        op.foreach(i => {\n            val num1 = stack.pop\n\
    \            val num2 = stack.pop\n            i match {\n                case\
    \ \"+\" => stack.push(num1 + num2)\n                case \"-\" => stack.push(num2\
    \ - num1)\n                case \"*\" => stack.push(num1 * num2)\n           \
    \     case \"//\" => stack.push(num2 / num1)\n                case \"**\" => stack.push(pow(num2,\
    \ num1).toLong)\n            }\n        })\n        stack.pop", "        val ops\
    \ = op.zip(operand.init)\n        var result = operand.last\n        for ((o,\
    \ a) <- ops.reverse) {\n            o match {\n                case \"+\" => result\
    \ = a + result\n                case \"-\" => result = a - result\n          \
    \      case \"*\" => result = a * result\n                case \"//\" => result\
    \ = a / result\n                case \"**\" => result = pow(a, result).toLong\n\
    \            }\n        }\n        result", "        var temp = operand(0)\n \
    \       for (i <- 0 until op.length) {\n            op(i) match {\n          \
    \      case \"+\" => temp += operand(i + 1)\n                case \"-\" => temp\
    \ -= operand(i + 1)\n                case \"*\" => temp *= operand(i + 1)\n  \
    \              case \"//\" => temp /= operand(i + 1)\n                case \"\
    **\" => temp = pow(temp, operand(i + 1)).toLong\n            }\n        }\n  \
    \      temp", "        val opMap = Map(\"+\" -> ((x : Long, y : Long) => x + y),\
    \ \"-\" -> ((x : Long, y : Long) => x - y), \"*\" -> ((x : Long, y : Long) =>\
    \ x * y), \"/\" -> ((x : Long, y : Long) => x / y), \"^\" -> ((x : Long, y : Long)\
    \ => pow(x, y).toLong))\n        var nums = Queue[Long]()\n        nums ++= operand\n\
    \        for (i <- op) {\n            val x = nums.dequeue\n            val y\
    \ = nums.dequeue\n            nums.enqueue(opMap(i)(x, y))\n        }\n      \
    \  nums.head", "        var result = 0.0\n        for (i <- 0 until op.length)\
    \ {\n            op(i) match {\n                case \"+\" => result = operand(i)\
    \ + operand(i + 1)\n                case \"-\" => result = operand(i) - operand(i\
    \ + 1)\n                case \"*\" => result = operand(i) * operand(i + 1)\n \
    \               case \"//\" => result = operand(i) / operand(i + 1)\n        \
    \        case \"**\" => result = pow(operand(i), operand(i + 1))\n           \
    \ }\n            operand(i + 1) = result.toLong\n        }\n        result.toLong",
  "        val result = op.indices.map(i => (op(i), operand(i), operand(i + 1))).foldLeft(0.toLong)\
    \ {\n            case (acc, (\"*\", x, y)) => acc + x * y\n            case (acc,\
    \ (\"/\", x, y)) => acc + x / y\n            case (acc, (\"+\", x, y)) => acc\
    \ + x + y\n            case (acc, (\"-\", x, y)) => acc + x - y\n            case\
    \ (acc, (\"**\", x, y)) => acc + pow(x, y).toLong\n        }\n        result",
  "        // Write your code here\n        var expr = \"\"\n        for (i <- 0 until\
    \ op.length) expr += operand(i) + op(i)\n        expr += operand(op.length)\n\
    \        expr.toDouble.floor.toLong", "        val operand1 = operand.head\n \
    \       val operand2 = operand.tail.head\n        val operator = op.head\n   \
    \     operator match {\n            case \"+\" => operand1 + operand2\n      \
    \      case \"-\" => operand1 - operand2\n            case \"*\" => operand1 *\
    \ operand2\n            case \"//\" => operand1 / operand2\n            case \"\
    **\" => pow(operand1, operand2).toLong\n        }", "\t\tvar stack = new Stack[Long]()\n\
    \t\tfor (i <- 0 until op.length) {\n\t\t\tval oprand = operand(i)\n\t\t\tval operator\
    \ = op(i)\n\t\t\tif (operator == \"+\") stack.push(stack.pop + oprand)\n\t\t\t\
    else if (operator == \"-\") stack.push(stack.pop - oprand)\n\t\t\telse if (operator\
    \ == \"*\") stack.push(stack.pop * oprand)\n\t\t\telse if (operator == \"//\"\
    ) stack.push(stack.pop / oprand)\n\t\t\telse if (operator == \"**\") stack.push(pow(stack.pop,\
    \ oprand).toLong)\n\t\t\telse stack.push(oprand)\n\t\t}\n\t\tstack.pop", "   \
    \     val operands = operand.toArray\n        op.zipWithIndex.foreach(x => x._1\
    \ match {\n            case \"+\" => operands(x._2 + 1) = operands(x._2) + operands(x._2\
    \ + 1)\n            case \"-\" => operands(x._2 + 1) = operands(x._2) - operands(x._2\
    \ + 1)\n            case \"*\" => operands(x._2 + 1) = operands(x._2) * operands(x._2\
    \ + 1)\n            case \"//\" => operands(x._2 + 1) = operands(x._2) / operands(x._2\
    \ + 1)\n            case \"**\" => operands(x._2 + 1) = pow(operands(x._2), operands(x._2\
    \ + 1)).toLong\n        })\n        operands(operands.length - 1)", "        var\
    \ i = 0\n        var result = operand(0)\n        while (i < op.length) {\n  \
    \          op(i) match {\n                case \"+\" => result += operand(i +\
    \ 1)\n                case \"-\" => result -= operand(i + 1)\n               \
    \ case \"*\" => result *= operand(i + 1)\n                case \"//\" => result\
    \ /= operand(i + 1)\n                case \"**\" => result = pow(result, operand(i\
    \ + 1)).toLong\n            }\n            i += 1\n        }\n        result",
  "        if (op.length != operand.length - 1) return Long.MinValue\n        var\
    \ stack = new Stack[String]\n        for (i <- 0 until op.length) {\n        \
    \    val v = op(i)\n            if (v == \"+\" || v == \"-\" || v == \"*\" ||\
    \ v == \"//\" || v == \"**\") {\n                stack.push(v)\n            }\
    \ else {\n                return Long.MinValue\n            }\n        }\n   \
    \     while (stack.length > 1) {\n            if (stack.contains(\"**\")) {\n\
    \                val ind = stack.indexOf(\"**\")\n                val a = operand(ind)\n\
    \                val b = operand(ind + 1)\n                operand(ind) = pow(a,\
    \ b).toLong\n                operand.remove(ind + 1)\n                stack.remove(ind)\n\
    \            } else if (stack.contains(\"//\")) {\n                val ind = stack.indexOf(\"\
    //\")\n                val a = operand(ind)\n                val b = operand(ind\
    \ + 1)\n                operand(ind) = a / b\n                operand.remove(ind\
    \ + 1)\n                stack.remove(ind)\n            } else if (stack.contains(\"\
    *\")) {\n                val ind = stack.indexOf(\"*\")\n                val a\
    \ = operand(ind)\n                val b = operand(ind + 1)\n                operand(ind)\
    \ = a * b\n                operand.remove(ind + 1)\n                stack.remove(ind)\n\
    \            } else if (stack.contains(\"-\")) {\n                val ind = stack.indexOf(\"\
    -\")\n                val a = operand(ind)\n                val b = operand(ind\
    \ + 1)\n                operand(ind) = a - b\n                operand.remove(ind\
    \ + 1)\n                stack.remove(ind)\n            } else if (stack.contains(\"\
    +\")) {\n                val ind = stack.indexOf(\"+\")\n                val a\
    \ = operand(ind)\n                val b = operand(ind + 1)\n                operand(ind)\
    \ = a + b\n                operand.remove(ind + 1)\n                stack.remove(",
  "        def perform(result : Long, op : String, operand : Long) : Long = {\n  \
    \          if (op == \"+\") result + operand\n            else if (op == \"-\"\
    ) result - operand\n            else if (op == \"*\") result * operand\n     \
    \       else if (op == \"//\") result / operand\n            else result.pow(operand.toInt)\n\
    \        }\n        var result = operand(0)\n        for (i <- 1 until operand.length)\
    \ {\n            result = perform(result, op(i - 1), operand(i))\n        }\n\
    \        result", "        var result = 0L\n        if (op.size != operand.size\
    \ - 1) return result\n        for (i <- 0 until op.size) {\n            val index\
    \ = i + 1\n            op(i) match {\n                case \"+\" => result +=\
    \ operand(index)\n                case \"-\" => result -= operand(index)\n   \
    \             case \"*\" => result *= operand(index)\n                case \"\
    //\" => result /= operand(index)\n                case \"**\" => result = pow(result,\
    \ operand(index)).toLong\n            }\n        }\n        result", "       \
    \ if (op.length != operand.length - 1) throw new IllegalArgumentException(\"operator\
    \ length should be equal to operand length minus one\")\n        if (op.length\
    \ < 1) throw new IllegalArgumentException(\"operator list should have at least\
    \ one operator\")\n        if (operand.length < 2) throw new IllegalArgumentException(\"\
    operand list should have at least two operands\")\n        //====================================================\n\
    \        var result = operand(0)\n        for (i <- 1 until operand.length) {\n\
    \            op(i - 1) match {\n                case \"+\" => result += operand(i)\n\
    \                case \"-\" => result -= operand(i)\n                case \"*\"\
    \ => result *= operand(i)\n                case \"//\" => result /= operand(i)\n\
    \                case \"**\" => result = pow(result, operand(i)).toLong\n    \
    \            case _ => throw new IllegalArgumentException(\"invalid operator\"\
    )\n            }\n        }\n        result", "        require(operand.size >=\
    \ 2 && op.size >= 1 && operand.forall(_ >= 0))\n        var operandStack = new\
    \ Stack[Long]\n        for (op <- op) {\n            var v2 = operandStack.pop\n\
    \            var v1 = operandStack.pop\n            var v = 0l\n            op\
    \ match {\n                case \"+\" => v = v1 + v2\n                case \"\
    -\" => v = v1 - v2\n                case \"*\" => v = v1 * v2\n              \
    \  case \"//\" => v = v1 / v2\n                case \"**\" => v = pow(v1, v2).toLong\n\
    \            }\n            operandStack.push(v)\n        }\n        operandStack.top",
  "        val stack = new Stack[Long]\n        for (i <- 0 until op.length) {\n \
    \           if (op(i) == \"+\") stack.push(stack.pop + operand(i + 1))\n     \
    \       else if (op(i) == \"-\") stack.push(stack.pop - operand(i + 1))\n    \
    \        else if (op(i) == \"*\") stack.push(stack.pop * operand(i + 1))\n   \
    \         else if (op(i) == \"//\") stack.push(stack.pop / operand(i + 1))\n \
    \           else if (op(i) == \"**\") stack.push(pow(stack.pop, operand(i + 1)).toLong)\n\
    \        }\n        stack.pop", "        if (op.length != operand.length - 1)\
    \ throw new Exception(\"The length of operator list is equal to the length of\
    \ operand list minus one.\")\n        var result = operand(0)\n        for (i\
    \ <- 1 until operand.length) {\n            if (op(i - 1) == \"+\") result +=\
    \ operand(i)\n            else if (op(i - 1) == \"-\") result -= operand(i)\n\
    \            else if (op(i - 1) == \"*\") result *= operand(i)\n            else\
    \ if (op(i - 1) == \"//\") result /= operand(i)\n            else if (op(i - 1)\
    \ == \"**\") result = pow(result, operand(i)).toLong\n            else throw new\
    \ Exception(\"The operator is invalid\")\n        }\n        result", "      \
    \  var result = operand(0)\n        for (i <- 0 until op.length) {\n         \
    \   op(i) match {\n                case \"+\" => result += operand(i + 1)\n  \
    \              case \"-\" => result -= operand(i + 1)\n                case \"\
    *\" => result *= operand(i + 1)\n                case \"//\" => result /= operand(i\
    \ + 1)\n                case \"**\" => result = pow(result, operand(i + 1)).toLong\n\
    \            }\n        }\n        result", "        if (op.isEmpty) return operand.head\n\
    \        return doAlgebra(op.tail, operand.tail :+ operation(op.head, operand.head,\
    \ operand.tail.head))", "        var expression = operand(0).toString\n      \
    \  for (i <- 0 until op.length) expression += \" \" + op(i) + \" \" + operand(i\
    \ + 1)\n        return eval(expression).toLong", "      val operations = Map[String,\
    \ (Long, Long) => Long](\"+\" -> ((x, y) => x + y), \"-\" -> ((x, y) => x - y),\
    \ \"*\" -> ((x, y) => x * y), \"/\" -> ((x, y) => x / y), \"**\" -> ((x, y) =>\
    \ pow(x, y).toLong))\n      def helper(op : List[String], operand : List[Long])\
    \ : Long = {\n        if (op.length == 0) operand.head\n        else {\n     \
    \     val a = operand.head\n          val b = operand.tail.head\n          val\
    \ rest = operand.tail.tail\n          val o = op.head\n          helper(op.tail,\
    \ operations(o)(a, b) :: rest)\n        }\n      }\n      helper(op, operand)",
  "        if (op.length != operand.length - 1)\n            return -1\n        var\
    \ stack = new Stack[Long]\n        stack.push(operand(0))\n        for (i <- 1\
    \ until operand.length) {\n            op(i - 1) match {\n                case\
    \ \"+\" => stack.push(stack.pop + operand(i))\n                case \"-\" => stack.push(stack.pop\
    \ - operand(i))\n                case \"*\" => stack.push(stack.pop * operand(i))\n\
    \                case \"//\" => stack.push(stack.pop / operand(i))\n         \
    \       case \"**\" => stack.push(pow(stack.pop, operand(i)).toLong)\n       \
    \     }\n        }\n        stack.pop", "        var stack = new Stack[Long]\n\
    \        for (i <- 0 until op.length) {\n            stack.push(operand(i))\n\
    \            if (op(i) == \"+\") stack.push(stack.pop + stack.pop)\n         \
    \   else if (op(i) == \"-\") {\n                val second = stack.pop\n     \
    \           val first = stack.pop\n                stack.push(first - second)\n\
    \            }\n            else if (op(i) == \"*\") stack.push(stack.pop * stack.pop)\n\
    \            else if (op(i) == \"//\") {\n                val second = stack.pop\n\
    \                val first = stack.pop\n                stack.push(first / second)\n\
    \            }\n            else if (op(i) == \"**\") {\n                val second\
    \ = stack.pop\n                val first = stack.pop\n                stack.push(pow(first,\
    \ second).toLong)\n            }\n        }\n        stack.push(operand(operand.length\
    \ - 1))\n        while (stack.length != 1) {\n            stack.push(stack.pop\
    \ + stack.pop)\n        }\n        stack.pop", "\t\t// Impossible to have less\
    \ than one operator\n\t\t// Impossible to have less than two operands\n\t\tval\
    \ operandStack = new Stack[Long]\n\t\toperandStack.push(operand(0))\n\t\tfor (index\
    \ <- 0 until op.length) {\n\t\t\tval currentOp = op(index)\n\t\t\tval currentOperand\
    \ = operand(index + 1)\n\t\t\tif (currentOp == \"+\") {\n\t\t\t\toperandStack.push(currentOperand)\n\
    \t\t\t} else if (currentOp == \"-\") {\n\t\t\t\toperandStack.push(-currentOperand)\n\
    \t\t\t} else if (currentOp == \"*\") {\n\t\t\t\toperandStack.push(operandStack.pop\
    \ * currentOperand)\n\t\t\t} else if (currentOp == \"//\") {\n\t\t\t\toperandStack.push(operandStack.pop\
    \ / currentOperand)\n\t\t\t} else if (currentOp == \"**\") {\n\t\t\t\toperandStack.push(pow(operandStack.pop,\
    \ currentOperand).toLong)\n\t\t\t}\n\t\t}\n\t\toperandStack.sum", "        if\
    \ (op.length != operand.length - 1) return 0\n        if (op.length == 0) return\
    \ 0\n        var exp = operand(0).toString\n        for (i <- 0 until op.length)\
    \ {\n            exp += op(i) + operand(i + 1).toString\n        }\n        val\
    \ p = new Eval\n        p.eval(exp)", "        val itr = operand.toIterator\n\
    \        var curr = itr.next\n        var nxt = 0\n        for (o <- op) {\n \
    \           nxt = itr.next\n            o match {\n                case \"+\"\
    \ => curr += nxt\n                case \"-\" => curr -= nxt\n                case\
    \ \"*\" => curr *= nxt\n                case \"//\" => curr /= nxt\n         \
    \       case \"**\" => curr = pow(curr, nxt).toLong\n            }\n        }\n\
    \        curr", "        val stack = Stack[Long]()\n        stack.push(operand(0))\n\
    \        for (i <- 1 until operand.length) {\n            op(i - 1) match {\n\
    \                case \"+\" => stack.push(stack.pop + operand(i))\n          \
    \      case \"-\" => stack.push(stack.pop - operand(i))\n                case\
    \ \"*\" => stack.push(stack.pop * operand(i))\n                case \"//\" =>\
    \ stack.push(stack.pop / operand(i))\n                case \"**\" => stack.push(pow(stack.pop,\
    \ operand(i)).toLong)\n            }\n        }\n        stack.pop", "       \
    \ //reversed list because this is a stack\n        var stack = new Stack[Long]()\n\
    \        for (i <- 0 until operand.length) {\n            stack.push(operand(i))\n\
    \        }\n        var result = 0.0\n        for (i <- 0 until op.length) {\n\
    \            if (op(i) == \"+\") {\n                var tmp = stack.pop\n    \
    \            result = stack.pop + tmp\n                stack.push(result.toLong)\n\
    \            } else if (op(i) == \"-\") {\n                var tmp = stack.pop\n\
    \                result = stack.pop - tmp\n                stack.push(result.toLong)\n\
    \            } else if (op(i) == \"*\") {\n                var tmp = stack.pop\n\
    \                result = stack.pop * tmp\n                stack.push(result.toLong)\n\
    \            } else if (op(i) == \"//\") {\n                var tmp = stack.pop\n\
    \                result = stack.pop / tmp\n                stack.push(result.toLong)\n\
    \            } else if (op(i) == \"**\") {\n                var tmp = stack.pop\n\
    \                result = pow(stack.pop, tmp)\n                stack.push(result.toLong)\n\
    \            }\n        }\n        return result.toLong", '        return 0',
  "        var res = operand(0)\n        for (i <- 0 until op.length) {\n        \
    \    op(i) match {\n                case \"+\" => res += operand(i + 1)\n    \
    \            case \"-\" => res -= operand(i + 1)\n                case \"*\" =>\
    \ res *= operand(i + 1)\n                case \"//\" => res /= operand(i + 1)\n\
    \                case \"**\" => res = pow(res, operand(i + 1)).toLong\n      \
    \      }\n        }\n        res", "        // If operand list only has one operand,\
    \ just return the value of this operand.\n        if (operand.length == 1) {\n\
    \            return operand(0)\n        }\n        // Otherwise, traverse the\
    \ operator list.\n        else {\n            // The result is the first operand\n\
    \            var result = operand(0)\n            // Start from the second operand,\
    \ if current operator is \"+\", then add to the result,\n            // if current\
    \ operator is \"-\", then subtract from the result, if current operator is\n \
    \           // \"*\", then multiply to the result, if current operator is \"//\"\
    , then do floor division\n            // to the result, if current operator is\
    \ \"**\", then do exponentiation to the result.\n            for (i <- 1 until\
    \ operand.length) {\n                if (op(i - 1) == \"+\") {\n             \
    \       result += operand(i)\n                }\n                else if (op(i\
    \ - 1) == \"-\") {\n                    result -= operand(i)\n               \
    \ }\n                else if (op(i - 1) == \"*\") {\n                    result\
    \ *= operand(i)\n                }\n                else if (op(i - 1) == \"//\"\
    ) {\n                    result /= operand(i)\n                }\n           \
    \     else if (op(i - 1) == \"**\") {\n                    result = pow(result,\
    \ operand(i)).toLong\n                }\n            }\n            // Return\
    \ the result.\n            return result\n        }", "        var result = operand(0)\n\
    \        var i = 0\n        for (op <- op) {\n            i += 1\n           \
    \ if (op == \"+\") result += operand(i)\n            else if (op == \"-\") result\
    \ -= operand(i)\n            else if (op == \"*\") result *= operand(i)\n    \
    \        else if (op == \"//\") result /= operand(i)\n            else if (op\
    \ == \"**\") result = pow(result, operand(i)).toLong\n        }\n        result",
  "        val opr = scala.collection.mutable.Stack[String]()\n        val result\
    \ = scala.collection.mutable.Stack[Long]()\n        for (i <- 0 until op.length)\
    \ {\n            if (op(i) == \"**\") {\n                result.push(pow(result.pop,\
    \ operand(i + 1)).toLong)\n            } else {\n                result.push(operand(i))\n\
    \                opr.push(op(i))\n            }\n        }\n        result.push(operand(operand.length\
    \ - 1))\n        while (!opr.isEmpty) {\n            val operation = opr.pop\n\
    \            val r1 = result.pop\n            val r2 = result.pop\n          \
    \  operation match {\n                case \"+\" => result.push(r1 + r2)\n   \
    \             case \"-\" => result.push(r2 - r1)\n                case \"*\" =>\
    \ result.push(r1 * r2)\n                case \"//\" => result.push(r2 / r1)\n\
    \            }\n        }\n        result.pop", "        operand.reduceLeft((x,\
    \ y) => op.head match {\n            case \"+\" => x + y\n            case \"\
    -\" => x - y\n            case \"*\" => x * y\n            case \"//\" => x /\
    \ y\n            case \"**\" => pow(x, y).toLong\n        })", "    \t//println(op)\n\
    \    \t//println(operand)\n    \t//return 0\n    \tval opMap = Map(\"+\" -> (\
    \ (x : Long, y : Long) => x + y),\n    \t\t\t\t\t \"-\" -> ( (x : Long, y : Long)\
    \ => x - y),\n    \t\t\t\t\t \"*\" -> ( (x : Long, y : Long) => x * y),\n    \t\
    \t\t\t\t \"//\" -> ( (x : Long, y : Long) => x / y),\n    \t\t\t\t\t \"**\" ->\
    \ ( (x : Long, y : Long) => pow(x, y).toLong))\n    \tvar stack = List[Long]()\n\
    \    \tvar i = 0\n    \twhile (i < op.length) {\n    \t\tstack = opMap(op(i))(stack.head,\
    \ operand(i + 1)) :: stack.tail\n    \t\ti += 1\n    \t}\n    \tstack.head", " \
    \       if (op.length == 0 || operand.length == 0) throw new IllegalArgumentException(\"\
    Either list is empty\")\n        else if (op.length != operand.length - 1) throw\
    \ new IllegalArgumentException(\"The length of operator list is not equal to the\
    \ length of operand list minus one\")\n        else {\n            val stack =\
    \ new Stack[Long]\n            val operator = Map(\"+\" -> ((x : Long, y : Long)\
    \ => x + y), \"-\" -> ((x : Long, y : Long) => x - y), \"*\" -> ((x : Long, y\
    \ : Long) => x * y), \"//\" -> ((x : Long, y : Long) => x / y), \"**\" -> ((x\
    \ : Long, y : Long) => pow(x, y).toLong))\n            for (i <- 0 until op.length)\
    \ {\n                val a = stack.pop\n                val b = stack.pop\n  \
    \              stack.push(operator(op(i))(b, a))\n            }\n            for\
    \ (i <- 1 until operand.length) {\n                stack.push(operand(i))\n  \
    \              val a = stack.pop\n                val b = stack.pop\n        \
    \        stack.push(operator(op(i - 1))(b, a))\n            }\n            stack.pop\n\
    \        }", "        var temp = operand.head\n        var i = 0\n        while\
    \ (i < op.length) {\n            op(i) match {\n                case \"+\" =>\
    \ temp += operand(i + 1)\n                case \"-\" => temp -= operand(i + 1)\n\
    \                case \"*\" => temp *= operand(i + 1)\n                case \"\
    //\" => temp /= operand(i + 1)\n                case \"**\" => temp = pow(temp,\
    \ operand(i + 1)).toLong\n            }\n            i += 1\n        }\n     \
    \   temp", "        if (op.length != operand.length - 1) return -1\n        var\
    \ res = 0.0\n        for (i <- op.indices) {\n            val num1 = operand(i)\n\
    \            val num2 = operand(i + 1)\n            val operation = op(i)\n  \
    \          if (operation == \"+\") res = num1 + num2\n            else if (operation\
    \ == \"-\") res = num1 - num2\n            else if (operation == \"*\") res =\
    \ num1 * num2\n            else if (operation == \"//\") res = num1 / num2\n \
    \           else if (operation == \"**\") res = pow(num1, num2)\n            else\
    \ return -1\n            operand(i + 1) = res.toLong\n        }\n        res.toLong",
  "        if (op.length == 1) {\n            return operand(0)\n        }\n     \
    \   var result = 0L\n        val l = op.length\n        val m = operand.length\n\
    \        val stack = new Stack[Long]\n        for (i <- 0 until l) {\n       \
    \     if (i == 0) {\n                if (op(i) == \"+\") {\n                 \
    \   result = operand(i) + operand(i + 1)\n                } else if (op(i) ==\
    \ \"-\") {\n                    result = operand(i) - operand(i + 1)\n       \
    \         } else if (op(i) == \"*\") {\n                    result = operand(i)\
    \ * operand(i + 1)\n                } else if (op(i) == \"//\") {\n          \
    \          result = operand(i) / operand(i + 1)\n                } else if (op(i)\
    \ == \"**\") {\n                    result = pow(operand(i), operand(i + 1)).toLong\n\
    \                }\n                stack.push(result)\n            } else {\n\
    \                if (op(i) == \"+\") {\n                    result = stack.pop()\
    \ + operand(i + 1)\n                } else if (op(i) == \"-\") {\n           \
    \         result = stack.pop() - operand(i + 1)\n                } else if (op(i)\
    \ == \"*\") {\n                    result = stack.pop() * operand(i + 1)\n   \
    \             } else if (op(i) == \"//\") {\n                    result = stack.pop()\
    \ / operand(i + 1)\n                } else if (op(i) == \"**\") {\n          \
    \          result = pow(stack.pop(), operand(i + 1)).toLong\n                }\n\
    \                stack.push(result)\n            }\n        }\n        return\
    \ result", "        // \n        // ref : https://www.geeksforgeeks.org/stack-set-2-infix-to-postfix/\n\
    \        // \n        def eval(op : String, a : Long, b : Long) : Long = {\n \
    \           op match {\n                case \"+\" => a + b\n                case\
    \ \"-\" => a - b\n                case \"*\" => a * b\n                case \"\
    //\" => a / b\n                case \"**\" => pow(a, b).toLong\n            }\n\
    \        }\n        def prec(op : String) : Int = {\n            op match {\n\
    \                case \"+\" => 1\n                case \"-\" => 1\n          \
    \      case \"*\" => 2\n                case \"//\" => 2\n                case\
    \ \"**\" => 3\n            }\n        }\n        def isOperator(op : String) :\
    \ Boolean = {\n            op match {\n                case \"+\" => true\n  \
    \              case \"-\" => true\n                case \"*\" => true\n      \
    \          case \"//\" => true\n                case \"**\" => true\n        \
    \        case _ => false\n            }\n        }\n        def doMath(stack :\
    \ Stack[Long], op : String) : Unit = {\n            val b = stack.pop\n      \
    \      val a = stack.pop\n            stack.push(eval(op, a, b))\n        }\n\
    \        val stack = new Stack[Long]\n        for (i <- 0 until op.length) {\n\
    \            stack.push(operand(i))\n            if (isOperator(op(i))) {\n  \
    \              doMath(stack, op(i))\n            }\n        }\n        stack.push(operand(op.length))\n\
    \        var s = new Stack[String]\n        while (!stack.isEmpty) {\n       \
    \     val o = stack.pop\n            if (isOperator(o)) {\n                val\
    \ b = s.pop\n                val a = s.pop\n                s.push(eval(o, a,\
    \ b).toString)\n            } else {\n                s.push(o.toString)\n   \
    \         }\n        }\n        s.pop.toLong", "        // Fill in the code here\n\
    \        var result = operand(0)\n        for (i <- 0 until op.length) {\n   \
    \         op(i) match {\n                case \"+\" => result += operand(i + 1)\n\
    \                case \"-\" => result -= operand(i + 1)\n                case\
    \ \"*\" => result *= operand(i + 1)\n                case \"//\" => result /=\
    \ operand(i + 1)\n                case \"**\" => result = pow(result, operand(i\
    \ + 1)).toLong\n            }\n        }\n        result", "        var res =\
    \ operand(0)\n        for (i <- 0 until op.length) {\n            op(i) match\
    \ {\n                case \"+\" => res += operand(i + 1)\n                case\
    \ \"-\" => res -= operand(i + 1)\n                case \"*\" => res *= operand(i\
    \ + 1)\n                case \"//\" => res /= operand(i + 1)\n               \
    \ case \"**\" => res = pow(res, operand(i + 1)).toLong\n            }\n      \
    \  }\n        res", "        // code here\n        if (op.length == 0) throw new\
    \ IllegalArgumentException(\"operator length must be nonzero\")\n        if (operand.length\
    \ == 0) throw new IllegalArgumentException(\"operand length must be nonzero\"\
    )\n        var stack = new Stack[Long]\n        stack.push(operand(0))\n     \
    \   for (i <- 1 until operand.length) {\n            val operator = op(i - 1)\n\
    \            val operand = operand(i)\n            operator match {\n        \
    \        case \"+\" => stack.push(stack.pop + operand)\n                case \"\
    -\" => stack.push(stack.pop - operand)\n                case \"*\" => stack.push(stack.pop\
    \ * operand)\n                case \"//\" => stack.push(stack.pop / operand)\n\
    \                case \"**\" => stack.push(pow(stack.pop, operand).toLong)\n \
    \               case _ => throw new IllegalArgumentException(\"unknown operator\
    \ \" + operator)\n            }\n        }\n        stack.pop", "        def cal(op\
    \ : String, list : List[Long]) : Long = {\n            if (op == \"+\") list.reduce(_\
    \ + _)\n            else if (op == \"-\") list.reduce(_ - _)\n            else\
    \ if (op == \"*\") list.reduce(_ * _)\n            else if (op == \"//\") list.reduce(_\
    \ / _)\n            else if (op == \"**\") list.reduce((a, b) => pow(a, b).toLong)\n\
    \            else 0\n        }\n        var i = 0\n        var list = operand\n\
    \        while (i < op.length) {\n            list = cal(op(i), List(list(0),\
    \ list(1))) :: list.drop(2)\n            i += 1\n        }\n        list(0)",
  "        if (op.isEmpty || operand.length < 2) return 0\n        var result = operand(0)\n\
    \        for (i <- 0 until op.length) {\n            op(i) match {\n         \
    \       case \"+\" => result += operand(i + 1)\n                case \"-\" =>\
    \ result -= operand(i + 1)\n                case \"*\" => result *= operand(i\
    \ + 1)\n                case \"//\" => result /= operand(i + 1)\n            \
    \    case \"**\" => result = pow(result, operand(i + 1)).toLong\n            }\n\
    \        }\n        result", "        var ans = operand(0)\n        for (i <-\
    \ 0 until op.length) {\n            if (op(i) == \"+\") ans += operand(i + 1)\n\
    \            else if (op(i) == \"-\") ans -= operand(i + 1)\n            else\
    \ if (op(i) == \"*\") ans *= operand(i + 1)\n            else if (op(i) == \"\
    //\") ans /= operand(i + 1)\n            else if (op(i) == \"**\") ans = pow(ans,\
    \ operand(i + 1)).toLong\n        }\n        ans", "        var root = new Node(operand(0))\n\
    \        var current : Node = root\n        for (i <- 1 until operand.length)\
    \ {\n            current.right = new Node(operand(i))\n            current.operator\
    \ = op(i - 1)\n            current = current.right\n        }\n        return\
    \ root.evaluate()", "        var result = operand(0)\n        for (i <- 1 until\
    \ operand.length) {\n            op(i - 1) match {\n                case \"+\"\
    \ => result += operand(i)\n                case \"-\" => result -= operand(i)\n\
    \                case \"*\" => result *= operand(i)\n                case \"//\"\
    \ => result /= operand(i)\n                case \"**\" => result = pow(result,\
    \ operand(i)).toLong\n            }\n        }\n        result", "        val\
    \ stack = new Stack[Long]\n        stack.push(operand(0))\n        for (i <- 1\
    \ until operand.length) {\n            stack.push(operand(i))\n            val\
    \ b = stack.pop\n            val a = stack.pop\n            val operation = op(i\
    \ - 1)\n            stack.push(operation match {\n                case \"+\" =>\
    \ a + b\n                case \"-\" => a - b\n                case \"*\" => a\
    \ * b\n                case \"//\" => a / b\n                case \"**\" => pow(a,\
    \ b).toLong\n            })\n        }\n        stack.pop", "        val equation\
    \ = (op zip operand).flatMap(x => List(x._2, x._1)).dropRight(1) :+ operand.last\n\
    \        (1 until op.length).foreach(i => {\n            if (equation(i) == \"\
    **\") equation(i) = \"^\"\n            else if (equation(i) == \"//\") equation(i)\
    \ = \"/\"\n        })\n        val eval = new ExprEvaluator()\n        eval.eval(equation.mkString(\"\
    \"))", "        var solution = operand(0)\n        for (i <- 0 until op.length)\
    \ {\n            op(i) match {\n                case \"+\" => solution += operand(i\
    \ + 1)\n                case \"-\" => solution -= operand(i + 1)\n           \
    \     case \"*\" => solution *= operand(i + 1)\n                case \"//\" =>\
    \ solution /= operand(i + 1)\n                case \"**\" => solution = pow(solution,\
    \ operand(i + 1)).toLong\n            }\n        }\n        return solution",
  "    \tvar result = operand(0)\n    \tfor (i <- 1 until operand.length) {\n    \t\
    \top(i - 1) match {\n    \t\t\tcase \"+\" => result += operand(i)\n    \t\t\t\
    case \"-\" => result -= operand(i)\n    \t\t\tcase \"*\" => result *= operand(i)\n\
    \    \t\t\tcase \"//\" => result /= operand(i)\n    \t\t\tcase \"**\" => result\
    \ = pow(result, operand(i)).toLong\n    \t\t}\n    \t}\n    \tresult", "     \
    \   if (op.length == 1) {\n            op(0) match {\n                case \"\
    +\" => operand(0) + operand(1)\n                case \"-\" => operand(0) - operand(1)\n\
    \                case \"*\" => operand(0) * operand(1)\n                case \"\
    //\" => operand(0) / operand(1)\n                case \"**\" => pow(operand(0),\
    \ operand(1)).toLong\n            }\n        } else {\n            var queue =\
    \ Queue[Long]()\n            queue ++= operand\n            for (i <- 0 until\
    \ op.length) {\n                op(i) match {\n                    case \"+\"\
    \ => {\n                        val right = queue.dequeue\n                  \
    \      val left = queue.dequeue\n                        queue.enqueue(left +\
    \ right)\n                    }\n                    case \"-\" => {\n       \
    \                 val right = queue.dequeue\n                        val left\
    \ = queue.dequeue\n                        queue.enqueue(left - right)\n     \
    \               }\n                    case \"*\" => {\n                     \
    \   val right = queue.dequeue\n                        val left = queue.dequeue\n\
    \                        queue.enqueue(left * right)\n                    }\n\
    \                    case \"//\" => {\n                        val right = queue.dequeue\n\
    \                        val left = queue.dequeue\n                        queue.enqueue(left\
    \ / right)\n                    }\n                    case \"**\" => {\n    \
    \                    val right = queue.dequeue\n                        val left\
    \ = queue.dequeue\n                        queue.enqueue(pow(left, right).toLong)\n\
    \                    }\n                }\n            }\n            queue.dequeue\n\
    \        }", "        if (op.length != operand.length - 1) return 0\n        var\
    \ stack = new Stack[Long]\n        for (i <- 0 until operand.length) {\n     \
    \       if (i != 0) {\n                val a = stack.pop\n                val\
    \ b = operand(i)\n                op(i - 1) match {\n                    case\
    \ \"+\" => stack.push(a + b)\n                    case \"-\" => stack.push(a -\
    \ b)\n                    case \"*\" => stack.push(a * b)\n                  \
    \  case \"//\" => if (b != 0) stack.push(a / b) else return 0\n              \
    \      case \"**\" => stack.push(pow(a, b).toLong)\n                    case _\
    \ => return 0\n                }\n            } else stack.push(operand(i))\n\
    \        }\n        stack.pop", "        val operandStack = Stack[Long]()\n  \
    \      val operatorStack = Stack[String]()\n        var i = 0\n        while (i\
    \ < op.length) {\n            operatorStack.push(op(i))\n            i += 1\n\
    \        }\n        var j = 0\n        while (j < operand.length) {\n        \
    \    operandStack.push(operand(j))\n            j += 1\n        }\n        val\
    \ firstOp = operatorStack.pop\n        val b = operandStack.pop\n        val a\
    \ = operandStack.pop\n        var result = 0L\n        firstOp match {\n     \
    \       case \"+\" => result = a + b\n            case \"-\" => result = a - b\n\
    \            case \"*\" => result = a * b\n            case \"//\" => result =\
    \ a / b\n            case \"**\" => result = pow(a, b).toLong\n        }\n   \
    \     var k = 0\n        while (k < op.length - 1) {\n            val currOp =\
    \ operatorStack.pop\n            val b = operandStack.pop\n            currOp\
    \ match {\n                case \"+\" => result += b\n                case \"\
    -\" => result -= b\n                case \"*\" => result *= b\n              \
    \  case \"//\" => result /= b\n                case \"**\" => result = pow(result,\
    \ b).toLong\n            }\n            k += 1\n        }\n        result", " \
    \       var res = new Stack[Long]()\n        for (i <- 0 until op.length) {\n\
    \            val (a, b) = (res.pop, operand(i + 1))\n            op(i) match {\n\
    \                case \"+\" => res.push(a + b)\n                case \"-\" =>\
    \ res.push(a - b)\n                case \"*\" => res.push(a * b)\n           \
    \     case \"//\" => res.push(a / b)\n                case \"**\" => res.push(pow(a,\
    \ b).toLong)\n            }\n        }\n        res.pop", "        var eval =\
    \ operand(0)\n        for (i <- 0 until op.length) {\n            if (op(i) ==\
    \ \"+\") eval += operand(i + 1)\n            else if (op(i) == \"-\") eval -=\
    \ operand(i + 1)\n            else if (op(i) == \"*\") eval *= operand(i + 1)\n\
    \            else if (op(i) == \"//\") eval /= operand(i + 1)\n            else\
    \ if (op(i) == \"**\") eval = pow(eval, operand(i + 1)).toLong\n        }\n  \
    \      eval", "        // Your code here\n        val stack = new Stack[(String,\
    \ Long)]\n        stack.push(op.head, operand.head)\n        (1 until op.length).foreach(i\
    \ => {\n            val operator = op(i)\n            val operand = operand(i)\n\
    \            operator match {\n                case \"*\" => {\n             \
    \       val (prevOperator, prevOperand) = stack.pop\n                    val result\
    \ = prevOperand * operand\n                    stack.push(prevOperator, result)\n\
    \                }\n                case \"/\" => {\n                    val (prevOperator,\
    \ prevOperand) = stack.pop\n                    val result = prevOperand / operand\n\
    \                    stack.push(prevOperator, result)\n                }\n   \
    \             case \"**\" => {\n                    val (prevOperator, prevOperand)\
    \ = stack.pop\n                    val result = pow(prevOperand, operand).toLong\n\
    \                    stack.push(prevOperator, result)\n                }\n   \
    \             case _ => stack.push(operator, operand)\n            }\n       \
    \ })\n        val operands = stack.toList.map(_._2)\n        val operators = stack.toList.map(_._1)\n\
    \        var result = operands.head\n        (1 until operators.length).foreach(i\
    \ => {\n            val operand = operands(i)\n            val operator = operators(i)\n\
    \            operator match {\n                case \"+\" => result += operand\n\
    \                case \"-\" => result -= operand\n            }\n        })\n\
    \        result", "        val buffer = new ArrayBuffer[String]\n        var result\
    \ = operand(0)\n        buffer += result.toString\n        for (i <- 1 until operand.length)\
    \ {\n            buffer += op(i - 1)\n            buffer += operand(i).toString\n\
    \            result = eval(buffer.toList)\n            buffer.clear\n        \
    \    buffer += result.toString\n        }\n        result", "        val operandStack\
    \ = new Stack[Long]\n        val operatorStack = new Stack[String]\n        operandStack.push(operand(0))\n\
    \        operandStack.push(operand(1))\n        var i = 2\n        while (i <\
    \ operand.length) {\n            val newOperand = operand(i)\n            val\
    \ newOperator = op(i - 1)\n            if (operatorStack.isEmpty) {\n        \
    \        operatorStack.push(newOperator)\n                operandStack.push(newOperand)\n\
    \            } else {\n                val oldOperator = operatorStack.top\n \
    \               if (newOperator == \"*\" || newOperator == \"//\" || newOperator\
    \ == \"**\") {\n                    if (oldOperator == \"*\" || oldOperator ==\
    \ \"//\" || oldOperator == \"**\") {\n                        val secondOperand\
    \ = operandStack.pop\n                        val firstOperand = operandStack.pop\n\
    \                        operandStack.push(calculate(firstOperand, secondOperand,\
    \ oldOperator))\n                        operatorStack.pop\n                 \
    \       operatorStack.push(newOperator)\n                        operandStack.push(newOperand)\n\
    \                    } else {\n                        operatorStack.push(newOperator)\n\
    \                        operandStack.push(newOperand)\n                    }\n\
    \                } else {\n                    while (!operatorStack.isEmpty)\
    \ {\n                        val secondOperand = operandStack.pop\n          \
    \              val firstOperand = operandStack.pop\n                        operandStack.push(calculate(firstOperand,\
    \ secondOperand, oldOperator))\n                        operatorStack.pop\n  \
    \                  }\n                    operatorStack.push(newOperator)\n  \
    \                  operandStack.push(newOperand)\n                }\n        \
    \    }\n            i += 1\n        }\n        while (!operatorStack.isEmpty)\
    \ {\n            val secondOperand = operandStack.pop\n            val firstOperand\
    \ = operandStack.pop\n            operandStack.push(calculate(firstOperand, secondOperand,\
    \ operatorStack.pop))\n        }\n        operandStack.pop", "        var stack\
    \ = new Stack[Long]\n        operand.foreach(operand => stack.push(operand))\n\
    \        op.foreach(operator => {\n            val op2 = stack.pop\n         \
    \   val op1 = stack.pop\n            operator match {\n                case \"\
    +\" => stack.push(op1 + op2)\n                case \"-\" => stack.push(op1 - op2)\n\
    \                case \"*\" => stack.push(op1 * op2)\n                case \"\
    //\" => stack.push(op1 / op2)\n                case \"**\" => stack.push(pow(op1,\
    \ op2).toLong)\n            }\n        })\n        stack.pop", "        if (op.length\
    \ != operand.length - 1) throw new Exception(\"\")\n        def calculator(a :\
    \ Long, b : Long, op : String) : Long = {\n            if (op == \"+\") a + b\n\
    \            else if (op == \"-\") a - b\n            else if (op == \"*\") a\
    \ * b\n            else if (op == \"//\") a / b\n            else if (op == \"\
    **\") pow(a, b).toLong\n            else throw new Exception(\"\")\n        }\n\
    \        var stack = Stack[Long]()\n        for (i <- 0 until op.length) {\n \
    \           val oper = operand(i)\n            if (stack.length == 0) stack.push(oper)\n\
    \            else if (op(i) == \"**\") {\n                val temp = stack.pop\n\
    \                stack.push(calculator(temp, oper, op(i)))\n            }\n  \
    \          else {\n                while (stack.length != 0 && (op(i) == \"*\"\
    \ || op(i) == \"//\")) {\n                    val temp = stack.pop\n         \
    \           stack.push(calculator(temp, oper, op(i)))\n                }\n   \
    \             stack.push(oper)\n            }\n        }\n        var result =\
    \ stack.pop\n        for (i <- op.length - 1 to 0 by -1) {\n            result\
    \ = calculator(result, operand(i + 1), op(i))\n        }\n        result", " \
    \       val stack = new Stack[Long]\n        stack.push(operand(0))\n        (1\
    \ until operand.length).foreach(i => {\n            val b = operand(i)\n     \
    \       val a = stack.pop\n            val o = op(i - 1)\n            stack.push(o\
    \ match {\n                case \"+\" => a + b\n                case \"-\" =>\
    \ a - b\n                case \"*\" => a * b\n                case \"//\" => a\
    \ / b\n                case \"**\" => pow(a, b).toLong\n            })\n     \
    \   })\n        stack.pop", "      var result = operand(0)\n      for (i <- 1\
    \ until operand.length) {\n        val curop = op(i - 1)\n        val cur = operand(i)\n\
    \        if (curop == \"+\") result += cur\n        else if (curop == \"-\") result\
    \ -= cur\n        else if (curop == \"*\") result *= cur\n        else if (curop\
    \ == \"//\") result /= cur\n        else if (curop == \"**\") result = pow(result,\
    \ cur).toLong\n      }\n      result", "        def eval(v1 : Long, v2 : Long,\
    \ op : String) : Long = op match {\n            case \"+\" => v1 + v2\n      \
    \      case \"-\" => v1 - v2\n            case \"*\" => v1 * v2\n            case\
    \ \"//\" => v1 / v2\n            case \"**\" => pow(v1, v2).toLong\n        }\n\
    \        if (op.length == 1) {\n            eval(operand(0), operand(1), op(0))\n\
    \        } else {\n            var stack = new Stack[Long]\n            var i\
    \ = 0\n            while (i < op.length) {\n                if (op(i) == \"**\"\
    ) {\n                    val v1 = stack.pop()\n                    val v2 = operand(i\
    \ + 1)\n                    stack.push(eval(v1, v2, op(i)))\n                }\
    \ else {\n                    stack.push(operand(i))\n                }\n    \
    \            i += 1\n            }\n            stack.push(operand(i))\n     \
    \       var res = stack.pop()\n            while (!stack.isEmpty) {\n        \
    \        val v2 = stack.pop()\n                val v1 = stack.pop()\n        \
    \        res = eval(v1, v2, op(op.length - 1))\n            }\n            res\n\
    \        }", "        val opMap = Map(\"+\" -> \"+\", \"-\" -> \"-\", \"*\" ->\
    \ \"*\", \"//\" -> \"//\", \"**\" -> \"**\")\n        var res = operand(0)\n \
    \       for (i <- 0 until op.length) {\n            op(i) match {\n          \
    \      case \"**\" => res = pow(res, operand(i + 1)).toLong\n                case\
    \ \"//\" => res = (res / operand(i + 1)).toLong\n                case \"*\" =>\
    \ res = res * operand(i + 1)\n                case \"-\" => res = res - operand(i\
    \ + 1)\n                case \"+\" => res = res + operand(i + 1)\n           \
    \ }\n        }\n        res", "        var ans = operand(0)\n        for (i <-\
    \ 0 until op.length) {\n            if (op(i) == \"+\") ans += operand(i + 1)\n\
    \            else if (op(i) == \"-\") ans -= operand(i + 1)\n            else\
    \ if (op(i) == \"*\") ans *= operand(i + 1)\n            else if (op(i) == \"\
    //\") ans /= operand(i + 1)\n            else if (op(i) == \"**\") ans = pow(ans,\
    \ operand(i + 1)).toLong\n        }\n        ans", "        var opStack = new\
    \ Stack[String]\n        var operandStack = new Stack[Long]\n        for(i <-\
    \ 0 until op.length) {\n            if(i == 0) {\n                opStack.push(op(i))\n\
    \                operandStack.push(operand(i))\n                operandStack.push(operand(i\
    \ + 1))\n            } else {\n                while(opStack.length > 0 && priorOp(op(i))\
    \ <= priorOp(opStack.top)) {\n                    val o2 = operandStack.pop\n\
    \                    val o1 = operandStack.pop\n                    val result\
    \ = eval(o1, o2, opStack.pop)\n                    operandStack.push(result)\n\
    \                }\n                opStack.push(op(i))\n                operandStack.push(operand(i\
    \ + 1))\n            }\n        }\n        while(opStack.length > 0) {\n     \
    \       val o2 = operandStack.pop\n            val o1 = operandStack.pop\n   \
    \         val result = eval(o1, o2, opStack.pop)\n            operandStack.push(result)\n\
    \        }\n        operandStack.pop", "        var stack = new Stack[Long]\n\
    \        stack.push(operand(0))\n        for (i <- 1 until operand.length) {\n\
    \            val o1 = stack.pop\n            val o2 = operand(i)\n           \
    \ val o = op(i - 1)\n            if (o == \"+\") stack.push(o1 + o2)\n       \
    \     else if (o == \"-\") stack.push(o1 - o2)\n            else if (o == \"*\"\
    ) stack.push(o1 * o2)\n            else if (o == \"//\") stack.push(o1 / o2)\n\
    \            else if (o == \"**\") stack.push(pow(o1, o2).toLong)\n        }\n\
    \        stack.pop", "        var l : List[Long] = operand\n        for (i <-\
    \ op.indices) {\n            l = l.slice(0, i + 1) ::: List(op(i) match {\n  \
    \              case \"+\" => l(i) + l(i + 1)\n                case \"-\" => l(i)\
    \ - l(i + 1)\n                case \"*\" => l(i) * l(i + 1)\n                case\
    \ \"//\" => l(i) / l(i + 1)\n                case \"**\" => pow(l(i), l(i + 1)).toLong\n\
    \            }) ::: l.slice(i + 2, l.length)\n        }\n        l(0)", "    \
    \    var sum = operand(0)\n        for (i <- 1 until operand.length) {\n     \
    \       if (op(i - 1) == \"+\") sum += operand(i)\n            else if (op(i -\
    \ 1) == \"-\") sum -= operand(i)\n            else if (op(i - 1) == \"*\") sum\
    \ *= operand(i)\n            else if (op(i - 1) == \"//\") sum /= operand(i)\n\
    \            else if (op(i - 1) == \"**\") sum = pow(sum, operand(i)).toLong\n\
    \        }\n        return sum", "        op.zip(operand.tail).foldLeft(operand.head)((res,\
    \ oper) => oper._1 match {\n            case \"+\" => res + oper._2\n        \
    \    case \"-\" => res - oper._2\n            case \"*\" => res * oper._2\n  \
    \          case \"//\" => res / oper._2\n            case \"**\" => pow(res, oper._2).toLong\n\
    \        })", "        def helper(op : List[String], operand : List[Long], acc\
    \ : Long) : Long = op match {\n            case \"+\" :: rest => helper(rest,\
    \ operand.tail, acc + operand.head)\n            case \"-\" :: rest => helper(rest,\
    \ operand.tail, acc - operand.head)\n            case \"*\" :: rest => helper(rest,\
    \ operand.tail, acc * operand.head)\n            case \"//\" :: rest => helper(rest,\
    \ operand.tail, acc / operand.head)\n            case \"**\" :: rest => helper(rest,\
    \ operand.tail, pow(acc, operand.head).toLong)\n            case Nil => acc\n\
    \        }\n        helper(op, operand.tail, operand.head)", "        var stack\
    \ = new Stack[Long]\n        for (i <- 0 until op.length) {\n            val r\
    \ = stack.pop\n            val l = stack.pop\n            val cur = op(i) match\
    \ {\n                case \"+\" => l + r\n                case \"-\" => l - r\n\
    \                case \"*\" => l * r\n                case \"//\" => l / r\n \
    \               case \"**\" => pow(l, r).toLong\n            }\n            stack.push(cur)\n\
    \        }\n        stack.pop", "        var stack = new Stack[Long]\n       \
    \ stack.push(operand(0))\n        for (i <- 1 until operand.length) {\n      \
    \      val cur = operand(i)\n            val prev = stack.pop\n            val\
    \ exp = op(i - 1)\n            if (exp == \"+\") stack.push(prev + cur)\n    \
    \        else if (exp == \"-\") stack.push(prev - cur)\n            else if (exp\
    \ == \"*\") stack.push(prev * cur)\n            else if (exp == \"//\") stack.push(prev\
    \ / cur)\n            else if (exp == \"**\") stack.push(prev ^ cur)\n       \
    \ }\n        stack.pop", "        // Sum of the list of numbers.\n        def\
    \ doOp(op : String, nums : List[Long]) : Long = {\n            if (op == \"+\"\
    ) nums.sum\n            else if (op == \"-\") nums.reduce(_ - _)\n           \
    \ else if (op == \"*\") nums.reduce(_ * _)\n            else if (op == \"//\"\
    ) nums.reduce(_ / _)\n            else if (op == \"**\") nums.reduce(_.toDouble.pow(_).toLong)\n\
    \            else sys.error(\"Unkonwn operator \" + op)\n        }\n        //\
    \ All operators have the same priority, so we can do the calculation\n       \
    \ // level by level.\n        val nums = new Queue[Long]\n        val ops = new\
    \ Queue[String]\n        nums ++= operand\n        ops ++= op\n        while (ops.length\
    \ > 0) {\n            nums += doOp(ops.dequeue, List(nums.dequeue, nums.dequeue))\n\
    \        }\n        nums.dequeue", "        val st = op.zip(operand).foldLeft(List[Long]())((x,\
    \ y) => y match {\n            case (e1, e2) => \n                if (e1 == \"\
    +\") x :+ e2\n                else if (e1 == \"-\") x :+ -e2\n               \
    \ else if (e1 == \"*\") x.init :+ x.last * e2\n                else if (e1 ==\
    \ \"//\") x.init :+ x.last / e2\n                else if (e1 == \"**\") x.init\
    \ :+ pow(x.last, e2).toLong\n                else x\n        })\n        st.sum",
  "        val opstack = new Stack[String]\n        val numstack = new Stack[Long]\n\
    \        for (i <- 0 until op.length) {\n            if (op(i) == \"*\" || op(i)\
    \ == \"/\") {\n                val num = if (op(i) == \"*\") operand(i) * operand(i\
    \ + 1) else operand(i) / operand(i + 1)\n                opstack.push(op(i))\n\
    \                numstack.push(num)\n            } else {\n                if\
    \ (opstack.isEmpty) {\n                    opstack.push(op(i))\n             \
    \       numstack.push(operand(i))\n                } else {\n                \
    \    while (!opstack.isEmpty && opstack.top != \"*\" && opstack.top != \"/\")\
    \ {\n                        val prevnum = numstack.pop\n                    \
    \    val prevop = opstack.pop\n                        val num = if (prevop ==\
    \ \"+\") prevnum + operand(i) else prevnum - operand(i)\n                    \
    \    opstack.push(op(i))\n                        numstack.push(num)\n       \
    \             }\n                }\n            }\n        }\n        val num\
    \ = numstack.pop\n        val prevop = opstack.pop\n        if (prevop == \"+\"\
    ) num + operand(operand.length - 1) else num - operand(operand.length - 1)", " \
    \       var stack = new ListBuffer[Long]\n        for(i <- 0 until op.length)\
    \ {\n            val b = stack.remove(stack.length - 1)\n            val a = stack.remove(stack.length\
    \ - 1)\n            stack += op(i) match {\n                case \"+\" => a +\
    \ b\n                case \"-\" => a - b\n                case \"*\" => a * b\n\
    \                case \"//\" => a / b\n                case \"**\" => pow(a, b).toLong\n\
    \            }\n        }\n        stack(0)", "        op match {\n          \
    \  case Nil => operand.last\n            case head :: tail => {\n            \
    \    head match {\n                    case \"+\" => {\n                     \
    \   val l = operand.head\n                        val r = operand.tail.head\n\
    \                        val rest = operand.tail.tail\n                      \
    \  doAlgebra(tail, l + r :: rest)\n                    }\n                   \
    \ case \"-\" => {\n                        val l = operand.head\n            \
    \            val r = operand.tail.head\n                        val rest = operand.tail.tail\n\
    \                        doAlgebra(tail, l - r :: rest)\n                    }\n\
    \                    case \"*\" => {\n                        val l = operand.head\n\
    \                        val r = operand.tail.head\n                        val\
    \ rest = operand.tail.tail\n                        doAlgebra(tail, l * r :: rest)\n\
    \                    }\n                    case \"//\" => {\n               \
    \         val l = operand.head\n                        val r = operand.tail.head\n\
    \                        val rest = operand.tail.tail\n                      \
    \  doAlgebra(tail, l / r :: rest)\n                    }\n                   \
    \ case \"**\" => {\n                        val l = operand.head\n           \
    \             val r = operand.tail.head\n                        val rest = operand.tail.tail\n\
    \                        doAlgebra(tail, pow(l, r).toLong :: rest)\n         \
    \           }\n                }\n            }\n        }", "        var stack\
    \ = Stack[Long]()\n        stack.push(operand(0))\n        for (i <- 0 until op.length)\
    \ {\n            val n = operand(i + 1)\n            op(i) match {\n         \
    \       case \"+\" => stack.push(stack.pop + n)\n                case \"-\" =>\
    \ stack.push(stack.pop - n)\n                case \"*\" => stack.push(stack.pop\
    \ * n)\n                case \"//\" => stack.push(stack.pop / n)\n           \
    \     case \"**\" => stack.push(pow(stack.pop, n).toLong)\n            }\n   \
    \     }\n        stack.pop", "        // given operator\n        // given operand\n\
    \        val expr = for {\n            i <- 0 until op.length\n        } yield\
    \ op(i) + operand(i + 1).toString\n        //val expr = op.zip(operand.tail).map(t\
    \ => t._1 + t._2.toString)\n        val exprWithParens = (operand.head :: expr).mkString(\"\
    (\", \"\", \")\")\n        val result = scala.util.Try(eval(exprWithParens)).getOrElse(0L)\n\
    \        result", "        // Fill this stub with code.\n        val operand_st\
    \ = Stack[Long]()\n        val operator_st = Stack[String]()\n        operand_st.push(operand(0))\n\
    \        operator_st.push(op(0))\n        for (i <- 1 until operand.length) {\n\
    \            operand_st.push(operand(i))\n            if (i != op.length) {\n\
    \                operator_st.push(op(i))\n            }\n        }\n        while\
    \ (operator_st.size > 0) {\n            val operand2 = operand_st.pop()\n    \
    \        val operand1 = operand_st.pop()\n            val operator = operator_st.pop()\n\
    \            operand_st.push(evaluate(operand1, operand2, operator))\n       \
    \ }\n        operand_st.pop()", "        var i = 0\n        var ans = operand(0)\n\
    \        while (i < op.length) {\n            if (op(i) == \"+\") ans += operand(i\
    \ + 1)\n            else if (op(i) == \"-\") ans -= operand(i + 1)\n         \
    \   else if (op(i) == \"*\") ans *= operand(i + 1)\n            else if (op(i)\
    \ == \"//\") ans /= operand(i + 1)\n            else if (op(i) == \"**\") ans\
    \ = pow(ans, operand(i + 1)).toLong\n            i += 1\n        }\n        ans",
  "        var stack = new Stack[Long]\n        for (i <- 0 until op.length) {\n \
    \           var o2 = stack.pop\n            var o1 = stack.pop\n            stack.push(calculate(o1,\
    \ o2, op(i)))\n        }\n        def calculate(o1 : Long, o2 : Long, op : String)\
    \ : Long = {\n            op match {\n                case \"+\" => o1 + o2\n\
    \                case \"-\" => o1 - o2\n                case \"*\" => o1 * o2\n\
    \                case \"//\" => o1 / o2\n                case \"**\" => pow(o1,\
    \ o2).toLong\n            }\n        }\n        stack.pop", "        val opStack\
    \ = Stack[String]()\n        val operandStack = Stack[Long]()\n        opStack.push(op(0))\n\
    \        operandStack.push(operand(0))\n        operandStack.push(operand(1))\n\
    \        for (i <- 2 until operand.length) {\n            if (getPriority(op(i\
    \ - 1)) >= getPriority(opStack.top)) {\n                val fst = operandStack.pop()\n\
    \                val snd = operandStack.pop()\n                val opt = opStack.pop()\n\
    \                val result = performOperation(opt, snd, fst)\n              \
    \  operandStack.push(result)\n                opStack.push(op(i - 1))\n      \
    \          operandStack.push(operand(i))\n            } else {\n             \
    \   opStack.push(op(i - 1))\n                operandStack.push(operand(i))\n \
    \           }\n        }\n        while (opStack.length > 0) {\n            val\
    \ fst = operandStack.pop()\n            val snd = operandStack.pop()\n       \
    \     val opt = opStack.pop()\n            val result = performOperation(opt,\
    \ snd, fst)\n            operandStack.push(result)\n        }\n        operandStack.pop()",
  "        if (op.length == 0) {\n            return operand(0)\n        }\n     \
    \   var result = operand(0)\n        for (i <- 0 until op.length) {\n        \
    \    op(i) match {\n                case \"+\" => result += operand(i + 1)\n \
    \               case \"-\" => result -= operand(i + 1)\n                case \"\
    *\" => result *= operand(i + 1)\n                case \"//\" => result /= operand(i\
    \ + 1)\n                case \"**\" => result = pow(result, operand(i + 1)).toLong\n\
    \            }\n        }\n        return result", "        var result = operand(0)\n\
    \        for (i <- 0 until op.length) {\n            op(i) match {\n         \
    \       case \"+\" => result += operand(i + 1)\n                case \"-\" =>\
    \ result -= operand(i + 1)\n                case \"*\" => result *= operand(i\
    \ + 1)\n                case \"//\" => result /= operand(i + 1)\n            \
    \    case \"**\" => result = pow(result, operand(i + 1)).toLong\n            }\n\
    \        }\n        result", "        var stack = new Stack[Long]\n        for\
    \ (i <- 0 until op.length) {\n            val left = stack.pop\n            val\
    \ right = operand(i + 1)\n            op(i) match {\n                case \"+\"\
    \ => stack.push(left + right)\n                case \"-\" => stack.push(left -\
    \ right)\n                case \"*\" => stack.push(left * right)\n           \
    \     case \"//\" => stack.push(left / right)\n                case \"**\" =>\
    \ stack.push(pow(left, right).toLong)\n            }\n        }\n        stack.pop",
  "        op match {\n            case Nil => operand.last\n            case hd ::\
    \ tl => operand match {\n                case Nil => 0\n                case a\
    \ :: b :: tl => \n                    hd match {\n                        case\
    \ \"+\" => operand.head + doAlgebra(tl, operand.tail)\n                      \
    \  case \"-\" => operand.head - doAlgebra(tl, operand.tail)\n                \
    \        case \"*\" => operand.head * doAlgebra(tl, operand.tail)\n          \
    \              case \"//\" => operand.head / doAlgebra(tl, operand.tail)\n   \
    \                     case \"**\" => pow(operand.head, doAlgebra(tl, operand.tail)).toLong\n\
    \                    }\n            }\n        }", "        if (op.length != operand.length\
    \ - 1) return -1\n        var opd = ListBuffer[Long]()\n        var ops = ListBuffer[String]()\n\
    \        opd ++= operand\n        ops ++= op\n        while (ops.length > 0) {\n\
    \            val i = ops.indexOf(\"**\")\n            if (i >= 0) {\n        \
    \        val result = opd(i) pow opd(i + 1)\n                opd.remove(i)\n \
    \               opd.remove(i)\n                opd.insert(i, result)\n       \
    \         ops.remove(i)\n            }\n            else {\n                val\
    \ i = ops.indexOf(\"*\")\n                if (i >= 0) {\n                    val\
    \ result = opd(i) * opd(i + 1)\n                    opd.remove(i)\n          \
    \          opd.remove(i)\n                    opd.insert(i, result)\n        \
    \            ops.remove(i)\n                }\n                else {\n      \
    \              val i = ops.indexOf(\"//\")\n                    if (i >= 0) {\n\
    \                        val result = opd(i) / opd(i + 1)\n                  \
    \      opd.remove(i)\n                        opd.remove(i)\n                \
    \        opd.insert(i, result)\n                        ops.remove(i)\n      \
    \              }\n                    else {\n                        val i =\
    \ ops.indexOf(\"+\")\n                        if (i >= 0) {\n                \
    \            val result = opd(i) + opd(i + 1)\n                            opd.remove(i)\n\
    \                            opd.remove(i)\n                            opd.insert(i,\
    \ result)\n                            ops.remove(i)\n                       \
    \ }\n                        else {\n                            val i = ops.indexOf(\"\
    -\")\n                            if (i >= 0) {\n                            \
    \    val result = opd(i) - opd(i + 1)\n                                opd.remove(i)\n\
    \                                opd.remove(i)\n                             \
    \   opd.insert(i, result)\n                                ops.remove(i)\n   \
    \                         }\n                        }\n                    }\n\
    \                }\n            }\n        }\n        opd(0)", "        var operandStack\
    \ = new Stack[Long]\n        var i = 0\n        while (i < operand.length) {\n\
    \            operandStack.push(operand(i))\n            i += 1\n        }\n  \
    \      var operatorStack = new Stack[String]\n        i = 0\n        while (i\
    \ < op.length) {\n            operatorStack.push(op(i))\n            i += 1\n\
    \        }\n        while (operatorStack.length > 0) {\n            val operator\
    \ = operatorStack.pop\n            if (operatorStack.length == 0) {\n        \
    \        val operand2 = operandStack.pop\n                val operand1 = operandStack.pop\n\
    \                operandStack.push(calculate(operator, operand1, operand2))\n\
    \            } else {\n                val operand2 = operandStack.pop\n     \
    \           val operand1 = operandStack.pop\n                val nextOperator\
    \ = operatorStack.pop\n                val nextOperationPriority = getPriority(nextOperator)\n\
    \                val currentOperationPriority = getPriority(operator)\n      \
    \          if (nextOperationPriority <= currentOperationPriority) {\n        \
    \            operandStack.push(calculate(operator, operand1, operand2))\n    \
    \                operatorStack.push(nextOperator)\n                } else {\n\
    \                    val subResult = calculate(operator, operand1, operand2)\n\
    \                    operandStack.push(subResult)\n                    operatorStack.push(nextOperator)\n\
    \                }\n            }\n        }\n        operandStack.pop", "   \
    \     if (op.length == 0 || operand.length < 2) return -1\n        var stk = new\
    \ Stack[Long]\n        for (o <- operand) stk.push(o)\n        for (p <- op) {\n\
    \            val b = stk.pop\n            val a = stk.pop\n            val res\
    \ = p match {\n                case \"+\" => a + b\n                case \"-\"\
    \ => a - b\n                case \"*\" => a * b\n                case \"//\" =>\
    \ a / b\n                case \"**\" => pow(a, b).toLong\n            }\n    \
    \        stk.push(res)\n        }\n        stk.pop", '        return -1;', " \
    \       var (opStr, operandStr) = (\"(\" + operand(0), operand(0))\n        for\
    \ (i <- 0 until op.length) {\n            opStr += \" \" + op(i) + \" \" + operand(i\
    \ + 1)\n            operandStr += \")\"\n        }\n        opStr += \")\"\n \
    \       operandStr += \")\"\n        var r = 0L\n        for (r <- op.indices)\
    \ {\n            if (op(r) == \"*\") {\n                val result = eval(opStr)\n\
    \                opStr = opStr.replace(opStr.substring(opStr.indexOf(\"*\") -\
    \ 2, opStr.indexOf(\"*\") + 3), result.toString)\n                operandStr =\
    \ operandStr.replace(operandStr.substring(operandStr.indexOf(\"*\") - 2, operandStr.indexOf(\"\
    *\") + 3), result.toString)\n            }\n        }\n        for (r <- op.indices)\
    \ {\n            if (op(r) == \"/\") {\n                val result = eval(opStr)\n\
    \                opStr = opStr.replace(opStr.substring(opStr.indexOf(\"/\") -\
    \ 2, opStr.indexOf(\"/\") + 3), result.toString)\n                operandStr =\
    \ operandStr.replace(operandStr.substring(operandStr.indexOf(\"/\") - 2, operandStr.indexOf(\"\
    /\") + 3), result.toString)\n            }\n        }\n        for (r <- op.indices)\
    \ {\n            if (op(r) == \"%\") {\n                val result = eval(opStr)\n\
    \                opStr = opStr.replace(opStr.substring(opStr.indexOf(\"%\") -\
    \ 2, opStr.indexOf(\"%\") + 3), result.toString)\n                operandStr =\
    \ operandStr.replace(operandStr.substring(operandStr.indexOf(\"%\") - 2, operandStr.indexOf(\"\
    %\") + 3), result.toString)\n            }\n        }\n        for (r <- op.indices)\
    \ {\n            if (op(r) == \"+\") {", "        var ans = operand(0)\n     \
    \   for (i <- 1 until operand.length) {\n            op(i - 1) match {\n     \
    \           case \"+\" => ans += operand(i)\n                case \"-\" => ans\
    \ -= operand(i)\n                case \"*\" => ans *= operand(i)\n           \
    \     case \"//\" => ans /= operand(i)\n                case \"**\" => ans = pow(ans,\
    \ operand(i)).toLong\n            }\n        }\n        ans", "        var result\
    \ = operand(0)\n        for (i <- 1 until operand.length) {\n            result\
    \ = op(i - 1) match {\n                case \"+\" => result + operand(i)\n   \
    \             case \"-\" => result - operand(i)\n                case \"*\" =>\
    \ result * operand(i)\n                case \"//\" => result / operand(i)\n  \
    \              case \"**\" => pow(result, operand(i)).toLong\n            }\n\
    \        }\n        result", "        var value = operand(0)\n        for (i <-\
    \ 0 until op.length) {\n            op(i) match {\n                case \"+\"\
    \ => value += operand(i + 1)\n                case \"-\" => value -= operand(i\
    \ + 1)\n                case \"*\" => value *= operand(i + 1)\n              \
    \  case \"//\" => value /= operand(i + 1)\n                case \"**\" => value\
    \ = pow(value, operand(i + 1)).toLong\n            }\n        }\n        value",
  "        var result = operand(0)\n        for (i <- 0 until op.length) {\n     \
    \       op(i) match {\n                case \"+\" => result += operand(i + 1)\n\
    \                case \"-\" => result -= operand(i + 1)\n                case\
    \ \"*\" => result *= operand(i + 1)\n                case \"//\" => result /=\
    \ operand(i + 1)\n                case \"**\" => result = pow(result, operand(i\
    \ + 1)).toLong\n            }\n        }\n        result", "        if (op.isEmpty)\
    \ {\n            operand.head\n        } else {\n            def nextOp(x : Long,\
    \ y : Long, op : String) : Long = {\n                op match {\n            \
    \        case \"+\" => x + y\n                    case \"-\" => x - y\n      \
    \              case \"*\" => x * y\n                    case \"//\" => floor(x\
    \ / y).toLong\n                    case \"**\" => pow(x, y).toLong\n         \
    \       }\n            }\n            nextOp(operand.head, doAlgebra(op.tail,\
    \ operand.tail), op.head)\n        }", "        var result = operand(0)\n    \
    \    for (i <- 1 until operand.length) {\n            if (op(i - 1) == \"+\")\
    \ result += operand(i)\n            else if (op(i - 1) == \"-\") result -= operand(i)\n\
    \            else if (op(i - 1) == \"*\") result *= operand(i)\n            else\
    \ if (op(i - 1) == \"//\") result /= operand(i)\n            else if (op(i - 1)\
    \ == \"**\") result = pow(result, operand(i)).toLong\n        }\n        return\
    \ result", "        var stack = new Stack[Long]\n        for (i <- 0 until op.length)\
    \ {\n            var first = stack.pop\n            var second = operand(i + 1)\n\
    \            var r = 0l\n            op(i) match {\n                case \"+\"\
    \ => r = first + second\n                case \"-\" => r = first - second\n  \
    \              case \"*\" => r = first * second\n                case \"//\" =>\
    \ r = first / second\n                case \"**\" => r = pow(first, second).toLong\n\
    \            }\n            stack.push(r)\n        }\n        return stack.pop",
  "        require(op.length == operand.length - 1)\n        var stack = new Stack[Long]\n\
    \        for (i <- 0 until op.length) {\n            val num1 = stack.pop\n  \
    \          val num2 = operand(i + 1)\n            stack.push(op(i) match {\n \
    \               case \"+\" => num1 + num2\n                case \"-\" => num1\
    \ - num2\n                case \"*\" => num1 * num2\n                case \"//\"\
    \ => num1 / num2\n                case \"**\" => pow(num1, num2).toLong\n    \
    \        })\n        }\n        stack.pop", "    \tvar result = operand(0)\n \
    \   \tfor (i <- 0 until op.length) {\n    \t\top(i) match {\n    \t\t\tcase \"\
    +\" => result += operand(i + 1)\n    \t\t\tcase \"-\" => result -= operand(i +\
    \ 1)\n    \t\t\tcase \"*\" => result *= operand(i + 1)\n    \t\t\tcase \"//\"\
    \ => result /= operand(i + 1)\n    \t\t\tcase \"**\" => result = pow(result, operand(i\
    \ + 1)).toLong\n    \t\t}\n    \t}\n    \tresult", "        if (op.length == 0\
    \ || operand.length == 0) {\n            throw new IllegalArgumentException(\"\
    Invalid arguments\")\n        }\n        if (op.length != operand.length - 1)\
    \ {\n            throw new IllegalArgumentException(\"Length of operator is not\
    \ right\")\n        }\n        var result = operand(0)\n        for (i <- 0 until\
    \ op.length) {\n            if (op(i) == \"+\") {\n                result += operand(i\
    \ + 1)\n            } else if (op(i) == \"-\") {\n                result -= operand(i\
    \ + 1)\n            } else if (op(i) == \"*\") {\n                result *= operand(i\
    \ + 1)\n            } else if (op(i) == \"//\") {\n                result /= operand(i\
    \ + 1)\n            } else if (op(i) == \"**\") {\n                result = pow(result,\
    \ operand(i + 1)).toLong\n            } else {\n                throw new IllegalArgumentException(\"\
    Unknown operator\")\n            }\n        }\n        result", "        var stack\
    \ = new Stack[Long]\n        for (i <- 0 until op.length) {\n            val a\
    \ = stack.pop\n            val b = operand(i + 1)\n            if (op(i) == \"\
    +\") stack.push(a + b)\n            else if (op(i) == \"-\") stack.push(a - b)\n\
    \            else if (op(i) == \"*\") stack.push(a * b)\n            else if (op(i)\
    \ == \"//\") stack.push(a / b)\n            else if (op(i) == \"**\") stack.push(pow(a,\
    \ b).toLong)\n        }\n        stack.pop", "    \t// Recursively evaluate the\
    \ value of given algebra.\n    \tdef helper(op : List[String], operand : List[Long])\
    \ : Long = op match {\n    \t\tcase x :: Nil => {\n    \t\t\tif (x == \"+\") operand.head\
    \ + operand.tail.head\n    \t\t\telse if (x == \"-\") operand.head - operand.tail.head\n\
    \    \t\t\telse if (x == \"*\") operand.head * operand.tail.head\n    \t\t\telse\
    \ if (x == \"//\") operand.head / operand.tail.head\n    \t\t\telse if (x == \"\
    **\") pow(operand.head, operand.tail.head).toLong\n    \t\t\telse throw new Exception(\"\
    Invalid operator!\")\n    \t\t}\n    \t\tcase x :: xs => {\n    \t\t\tval cur\
    \ = operand.head\n    \t\t\tval next = operand.tail.head\n    \t\t\tif (x == \"\
    +\") helper(xs, (cur + next) :: operand.tail.tail)\n    \t\t\telse if (x == \"\
    -\") helper(xs, (cur - next) :: operand.tail.tail)\n    \t\t\telse if (x == \"\
    *\") helper(xs, (cur * next) :: operand.tail.tail)\n    \t\t\telse if (x == \"\
    //\") helper(xs, (cur / next) :: operand.tail.tail)\n    \t\t\telse if (x == \"\
    **\") helper(xs, (pow(cur, next).toLong) :: operand.tail.tail)\n    \t\t\telse\
    \ throw new Exception(\"Invalid operator!\")\n    \t\t}\n    \t\tcase Nil => throw\
    \ new Exception(\"Invalid operator!\")\n    \t}\n    \t// Return the value of\
    \ given algebra.\n    \thelper(op, operand)", "        var result = operand(0)\n\
    \        var i = 0\n        while (i < op.length) {\n            if (op(i) ==\
    \ \"+\") result += operand(i + 1)\n            else if (op(i) == \"-\") result\
    \ -= operand(i + 1)\n            else if (op(i) == \"*\") result *= operand(i\
    \ + 1)\n            else if (op(i) == \"//\") result /= operand(i + 1)\n     \
    \       else if (op(i) == \"**\") result = pow(result, operand(i + 1)).toLong\n\
    \            i += 1\n        }\n        result", "        val stack = new Stack[Long]\n\
    \        for(i <- 0 until op.length) {\n            stack.push(operand(i))\n \
    \           val nextOp = op(i)\n            if(nextOp == \"+\") stack.push(stack.pop\
    \ + stack.pop)\n            else if(nextOp == \"-\") {\n                val last\
    \ = stack.pop\n                stack.push(stack.pop - last)\n            }\n \
    \           else if(nextOp == \"*\") stack.push(stack.pop * stack.pop)\n     \
    \       else if(nextOp == \"//\") {\n                val last = stack.pop\n  \
    \              stack.push(stack.pop / last)\n            }\n            else if(nextOp\
    \ == \"**\") {\n                val last = stack.pop\n                stack.push(pow(stack.pop,\
    \ last).toLong)\n            }\n        }\n        stack.pop", "    \tvar ans\
    \ = operand(0)\n    \tvar i = 0\n    \tfor (x <- op) {\n    \t\tif (x == \"+\"\
    ) ans += operand(i + 1)\n    \t\telse if (x == \"-\") ans -= operand(i + 1)\n\
    \    \t\telse if (x == \"*\") ans *= operand(i + 1)\n    \t\telse if (x == \"\
    //\") ans /= operand(i + 1)\n    \t\telse if (x == \"**\") ans = pow(ans, operand(i\
    \ + 1)).toLong\n    \t\ti += 1\n    \t}\n    \tans", "        val result = new\
    \ ListBuffer[Long]\n        result += operand(0)\n        for (i <- 1 until operand.length)\
    \ {\n            val num = operand(i)\n            val prev = result.last\n  \
    \          op(i - 1) match {\n                case \"+\" => result += (prev +\
    \ num)\n                case \"-\" => result += (prev - num)\n               \
    \ case \"*\" => result += (prev * num)\n                case \"//\" => result\
    \ += (prev / num)\n                case \"**\" => result += pow(prev, num).toLong\n\
    \            }\n        }\n        result.last", "        var res = operand(0)\n\
    \        var queue = new Queue[Long]\n        queue.enqueue(res)\n        for\
    \ (i <- 1 until operand.length) {\n            var o = op(i - 1)\n           \
    \ var t = operand(i)\n            res = o match {\n                case \"+\"\
    \ => {\n                    res += t\n                    queue.enqueue(t)\n \
    \                   res\n                }\n                case \"-\" => {\n\
    \                    res -= t\n                    queue.enqueue(-t)\n       \
    \             res\n                }\n                case \"*\" => {\n      \
    \              var t0 = queue.dequeue\n                    res = res - t0 + t0\
    \ * t\n                    queue.enqueue(t0 * t)\n                    res\n  \
    \              }\n                case \"//\" => {\n                    var t0\
    \ = queue.dequeue\n                    res = res - t0 + t0 / t\n             \
    \       queue.enqueue(t0 / t)\n                    res\n                }\n  \
    \              case \"**\" => {\n                    var t0 = queue.dequeue\n\
    \                    res = res - t0 + pow(t0, t).toLong\n                    queue.enqueue(pow(t0,\
    \ t).toLong)\n                    res\n                }\n            }\n    \
    \    }\n        res", "        if (op.length == 0) return operand(0)\n       \
    \ var result = operand(0)\n        for (i <- 1 until operand.length) {\n     \
    \       val operation = op(i - 1)\n            val right = operand(i)\n      \
    \      result = operation match {\n                case \"+\" => result + right\n\
    \                case \"-\" => result - right\n                case \"*\" => result\
    \ * right\n                case \"//\" => result / right\n                case\
    \ \"**\" => pow(result, right).toLong\n            }\n        }\n        return\
    \ result", "        var result = operand(0)\n        for (i <- 1 until operand.length)\
    \ {\n            if (op(i - 1) == \"+\") result += operand(i)\n            else\
    \ if (op(i - 1) == \"-\") result -= operand(i)\n            else if (op(i - 1)\
    \ == \"*\") result *= operand(i)\n            else if (op(i - 1) == \"//\") result\
    \ /= operand(i)\n            else if (op(i - 1) == \"**\") result = pow(result,\
    \ operand(i)).toLong\n        }\n        return result", "        var result =\
    \ operand(0)\n        for (i <- 1 until operand.length) {\n            op(i -\
    \ 1) match {\n                case \"+\" => result += operand(i)\n           \
    \     case \"-\" => result -= operand(i)\n                case \"*\" => result\
    \ *= operand(i)\n                case \"//\" => result /= operand(i)\n       \
    \         case \"**\" => result = pow(result, operand(i)).toLong\n           \
    \ }\n        }\n        result", "        var ans = operand(0)\n        for (i\
    \ <- 0 until op.length) {\n            op(i) match {\n                case \"\
    +\" => ans += operand(i + 1)\n                case \"-\" => ans -= operand(i +\
    \ 1)\n                case \"*\" => ans *= operand(i + 1)\n                case\
    \ \"//\" => ans /= operand(i + 1)\n                case \"**\" => ans = pow(ans,\
    \ operand(i + 1)).toLong\n            }\n        }\n        ans", "        //\
    \ example: op = [\"+\", \"*\", \"-\"] operand = [2, 3, 4, 5]\n        //     \
    \     res =  2 + 3 * 4 - 5\n        var res = operand(0)\n        for (i <- 1\
    \ until operand.length) {\n            op(i - 1) match {\n                case\
    \ \"+\" => res += operand(i)\n                case \"-\" => res -= operand(i)\n\
    \                case \"*\" => res *= operand(i)\n                case \"//\"\
    \ => res /= operand(i)\n                case \"**\" => res = pow(res, operand(i)).toLong\n\
    \            }\n        }\n        res", "        var res = operand(0)\n     \
    \   for (i <- 0 until op.length) {\n            op(i) match {\n              \
    \  case \"+\" => res += operand(i + 1)\n                case \"-\" => res -= operand(i\
    \ + 1)\n                case \"*\" => res *= operand(i + 1)\n                case\
    \ \"//\" => res /= operand(i + 1)\n                case \"**\" => res = pow(res,\
    \ operand(i + 1)).toLong\n            }\n        }\n        res", "        val\
    \ opMap = Map[String, (Long, Long) => Long](\"+\" -> (x => x._1 + x._2), \"-\"\
    \ -> (x => x._1 - x._2), \"*\" -> (x => x._1 * x._2), \"/\" -> (x => x._1 / x._2),\
    \ \"**\" -> (x => pow(x._1, x._2).toLong))\n        var stack = Stack[Long]()\n\
    \        for (i <- 0 until operand.length) {\n            if (i == 0) stack.push(operand(i))\n\
    \            else {\n                val n = stack.pop()\n                stack.push(opMap(op(i\
    \ - 1))((n, operand(i))))\n            }\n        }\n        stack.pop()", " \
    \       def eval(op : List[String], operand : List[Long]) : Long = op match {\n\
    \            case \"-\" :: tail => operand.head - eval(tail, operand.tail)\n \
    \           case \"*\" :: tail => operand.head * eval(tail, operand.tail)\n  \
    \          case \"/\" :: tail => operand.head / eval(tail, operand.tail)\n   \
    \         case \"+\" :: tail => operand.head + eval(tail, operand.tail)\n    \
    \        case \"^\" :: tail => pow(operand.head, eval(tail, operand.tail)).toLong\n\
    \            case Nil => operand.head\n        }\n        eval(op, operand)",
  "        // Algorithm:\n        // We need to execute the multiplication and division\
    \ first, and then execute the addition and subtraction\n        // 1. Build the\
    \ expression tree using multiplication and division.\n        // 2. Visit the\
    \ expression tree and calculate the result.\n        case class Node(data : String,\
    \ left : Node, right : Node)\n        // Return the root node of the tree\n  \
    \      def buildTree(op : List[String], operand : List[Long]) : Node = {\n   \
    \         // Algorithm:\n            // 1. Find the first occurrence of * or /\n\
    \            // 2. Divide the list in two parts:\n            //    a. The part\
    \ left to this operator\n            //    b. The part right to this operator\n\
    \            // 3. Combine the two parts, add the operator, and return the new\
    \ list\n            // 4. Call this method recursively on the new list until there\
    \ is no more * or /\n            if (op.isEmpty) {\n                val r = operand.head\n\
    \                return Node(r.toString, null, null)\n            }\n        \
    \    var index = 0\n            while (index < op.length) {\n                if\
    \ (op(index) == \"*\" || op(index) == \"/\") {\n                    val leftOp\
    \ = op.slice(0, index)\n                    val leftOperand = operand.slice(0,\
    \ index + 1)\n                    val rightOp = op.slice(index + 1, op.length)\n\
    \                    val rightOperand = operand.slice(index + 1, operand.length)\n\
    \                    val newOp = leftOp ++ List(op(index)) ++ rightOp\n      \
    \              val newOperand = leftOperand ++ rightOperand\n                \
    \    val newNode = Node(op(index), buildTree(leftOp, leftOperand), buildTree(rightOp,\
    \ rightOperand))\n                    return newNode\n                }\n    \
    \            index += 1\n            }\n            // There is no more * or /\n\
    \            // Find the first occurrence of + or -\n            index = 0\n \
    \           while (index < op.length) {\n                if (op(index) == \"+\"\
    \ || op(index) == \"-\") {\n                    val leftOp = op.slice(0, index)\n\
    \                    val leftOperand = operand.slice(0", "        var result =\
    \ operand(0)\n        for (i <- 0 until op.length) {\n            op(i) match\
    \ {\n                case \"+\" => result += operand(i + 1)\n                case\
    \ \"-\" => result -= operand(i + 1)\n                case \"*\" => result *= operand(i\
    \ + 1)\n                case \"//\" => result /= operand(i + 1)\n            \
    \    case \"**\" => result = pow(result, operand(i + 1)).toLong\n            }\n\
    \        }\n        result", "        val s = Stack[Long]()\n        var res =\
    \ 0.toLong\n        for(i <- 0 until op.length) {\n            val o1 = s.pop\n\
    \            val o2 = operand(i + 1)\n            op(i) match {\n            \
    \    case \"+\" => s.push(o1 + o2)\n                case \"-\" => s.push(o1 -\
    \ o2)\n                case \"*\" => s.push(o1 * o2)\n                case \"\
    //\" => s.push(o1 / o2)\n                case \"**\" => s.push(pow(o1, o2).toLong)\n\
    \            }\n        }\n        res = s.pop\n        return res", "       \
    \ var result = operand(0)\n        for (i <- 1 until operand.length) {\n     \
    \       op(i - 1) match {\n                case \"+\" => result += operand(i)\n\
    \                case \"-\" => result -= operand(i)\n                case \"*\"\
    \ => result *= operand(i)\n                case \"//\" => result /= operand(i)\n\
    \                case \"**\" => result = pow(result, operand(i)).toLong\n    \
    \        }\n        }\n        result", "        var (i, j) = (0, 0)\n       \
    \ var q = new ArrayBuffer[Long]()\n        while (i < op.length) {\n         \
    \   if (op(i) == \"*\" || op(i) == \"/\") {\n                if (op(i) == \"*\"\
    ) q += q.remove(j) * q.remove(j)\n                else q += q.remove(j) / q.remove(j)\n\
    \            } else {\n                q += operand(j)\n                j += 1\n\
    \            }\n            i += 1\n        }\n        q += operand(j)\n     \
    \   q.reduce(_ + _)", "        var ret = operand(0)\n        for (i <- 0 until\
    \ op.length) {\n            op(i) match {\n                case \"+\" => ret +=\
    \ operand(i + 1)\n                case \"-\" => ret -= operand(i + 1)\n      \
    \          case \"*\" => ret *= operand(i + 1)\n                case \"//\" =>\
    \ ret /= operand(i + 1)\n                case \"**\" => ret = pow(ret, operand(i\
    \ + 1)).toLong\n            }\n        }\n        ret", "        var intp = new\
    \ Interpreter\n        op.zip(operand.tail).foreach(x => intp.process(x._1, x._2))\n\
    \        intp.process(\"=\", operand.head)", "        var stack = new Stack[Long]\n\
    \        val commandMap = new HashMap[String, (Long, Long) => Long]\n        commandMap\
    \ += (\"+\" -> {_ + _})\n        commandMap += (\"-\" -> {_ - _})\n        commandMap\
    \ += (\"*\" -> {_ * _})\n        commandMap += (\"/\" -> {_ / _})\n        commandMap\
    \ += (\"^\" -> {pow(_, _).toLong})\n        for (i <- 0 until op.length) {\n \
    \           val arg1 = stack.pop\n            val arg2 = operand(i + 1)\n    \
    \        val operator = op(i)\n            val res = commandMap(operator)(arg1,\
    \ arg2)\n            stack.push(res)\n        }\n        stack.pop", "       \
    \ def doOperation(operators : List[String], operands : List[Long]) : Long = {\n\
    \            if (operators.isEmpty) {\n                operands.head\n       \
    \     } else {\n                operators.head match {\n                    case\
    \ \"+\" => operands.head + doOperation(operators.tail, operands.tail)\n      \
    \              case \"-\" => operands.head - doOperation(operators.tail, operands.tail)\n\
    \                    case \"*\" => operands.head * doOperation(operators.tail,\
    \ operands.tail)\n                    case \"//\" => operands.head / doOperation(operators.tail,\
    \ operands.tail)\n                    case \"**\" => pow(operands.head, doOperation(operators.tail,\
    \ operands.tail)).toLong\n                }\n            }\n        }\n      \
    \  doOperation(op, operand)", "        def helper(op : List[String], operand :\
    \ List[Long], result : Long) : Long = {\n            op match {\n            \
    \    case x :: Nil => {\n                    x match {\n                     \
    \   case \"+\" => result + operand.head\n                        case \"-\" =>\
    \ result - operand.head\n                        case \"*\" => result * operand.head\n\
    \                        case \"//\" => result / operand.head\n              \
    \          case \"**\" => pow(result, operand.head).toLong\n                 \
    \   }\n                }\n                case x :: xs => {\n                \
    \    x match {\n                        case \"+\" => helper(xs, operand.tail,\
    \ result + operand.head)\n                        case \"-\" => helper(xs, operand.tail,\
    \ result - operand.head)\n                        case \"*\" => helper(xs, operand.tail,\
    \ result * operand.head)\n                        case \"//\" => helper(xs, operand.tail,\
    \ result / operand.head)\n                        case \"**\" => helper(xs, operand.tail,\
    \ pow(result, operand.head).toLong)\n                    }\n                }\n\
    \            }\n        }\n        helper(op, operand.tail, operand.head)", " \
    \       if (op.isEmpty) throw new IllegalArgumentException\n        if (operand.isEmpty)\
    \ throw new IllegalArgumentException\n        val stack = new Stack[String]\n\
    \        var number = operand.head\n        operand.tail.foreach(x => {\n    \
    \        val tmp = op.head\n            op.remove(0)\n            stack.push(x.toString)\n\
    \            stack.push(tmp)\n        })\n        while (!stack.isEmpty) {\n \
    \           val oper = stack.pop\n            val operand = stack.pop\n      \
    \      if (oper == \"+\") number += operand.toLong\n            else if (oper\
    \ == \"-\") number -= operand.toLong\n            else if (oper == \"*\") number\
    \ *= operand.toLong\n            else if (oper == \"//\") number /= operand.toLong\n\
    \            else if (oper == \"**\") number = pow(number, operand.toDouble).toLong\n\
    \            else throw new IllegalArgumentException\n        }\n        number",
  "        var ans = operand(0)\n        for (i <- 0 until op.length) {\n        \
    \    val o = op(i)\n            val x = operand(i + 1)\n            o match {\n\
    \                case \"+\" => ans += x\n                case \"-\" => ans -=\
    \ x\n                case \"*\" => ans *= x\n                case \"//\" => ans\
    \ = ans / x\n                case \"**\" => ans = pow(ans, x).toLong\n       \
    \     }\n        }\n        ans", "        val stack = Stack[Long]()\n       \
    \ for (i <- 0 until op.length) {\n            val x = operand(i)\n           \
    \ val y = operand(i + 1)\n            val expression = op(i) match {\n       \
    \         case \"+\" => x + y\n                case \"-\" => x - y\n         \
    \       case \"*\" => x * y\n                case \"//\" => x / y\n          \
    \      case \"**\" => pow(x, y).toLong\n            }\n            stack.push(expression)\n\
    \        }\n        return stack.pop()", "        var index = 0\n        var result\
    \ = operand(0)\n        for (i <- 0 until op.length) {\n            val next =\
    \ operand(i + 1)\n            op(i) match {\n                case \"+\" => result\
    \ += next\n                case \"-\" => result -= next\n                case\
    \ \"*\" => result *= next\n                case \"//\" => result /= next\n   \
    \             case \"**\" => result = pow(result, next).toLong\n            }\n\
    \        }\n        result", "        val stack = new Stack[Long]\n        stack.push(operand(0))\n\
    \        for (i <- 0 until op.length) {\n            op(i) match {\n         \
    \       case \"+\" => stack.push(stack.pop + operand(i + 1))\n               \
    \ case \"-\" => stack.push(stack.pop - operand(i + 1))\n                case \"\
    *\" => stack.push(stack.pop * operand(i + 1))\n                case \"//\" =>\
    \ stack.push(stack.pop / operand(i + 1))\n                case \"**\" => stack.push(pow(stack.pop,\
    \ operand(i + 1)).toLong)\n            }\n        }\n        stack.pop", "   \
    \     def iter(op : List[String], operand : List[Long], i : Int) : Long = {\n\
    \            if (i == 0) operand(0) else {\n                val s = operand(i)\n\
    \                val ex = iter(op, operand, i - 1)\n                if (op(i -\
    \ 1) == \"+\") ex + s else if (op(i - 1) == \"-\") ex - s else if (op(i - 1) ==\
    \ \"*\") ex * s else if (op(i - 1) == \"//\") ex / s else pow(ex, s).toLong\n\
    \            }\n        }\n        iter(op, operand, op.length)", "        val\
    \ res = new Stack[Long]\n        var i = 0\n        while (i < op.length) {\n\
    \            val opr = op(i)\n            val op1 = operand(i)\n            val\
    \ op2 = operand(i + 1)\n            opr match {\n                case \"+\" =>\
    \ res.push(op1 + op2)\n                case \"-\" => res.push(op1 - op2)\n   \
    \             case \"*\" => res.push(op1 * op2)\n                case \"//\" =>\
    \ res.push(op1 / op2)\n                case \"**\" => res.push(pow(op1, op2).toLong)\n\
    \            }\n            i += 1\n        }\n        res.pop", "        val\
    \ stack = new Stack[Long]\n        for (i <- 0 until op.length) {\n          \
    \  val v1 = stack.pop\n            val v2 = operand(i + 1)\n            val v\
    \ = op(i) match {\n                case \"+\" => v1 + v2\n                case\
    \ \"-\" => v1 - v2\n                case \"*\" => v1 * v2\n                case\
    \ \"//\" => v1 / v2\n                case \"**\" => pow(v1, v2).toLong\n     \
    \       }\n            stack.push(v)\n        }\n        stack.pop", "       \
    \ op.head match {\n            case \"+\" => operand.head + doAlgebra(op.tail,\
    \ operand.tail)\n            case \"-\" => operand.head - doAlgebra(op.tail, operand.tail)\n\
    \            case \"*\" => operand.head * doAlgebra(op.tail, operand.tail)\n \
    \           case \"//\" => operand.head / doAlgebra(op.tail, operand.tail)\n \
    \           case \"**\" => pow(operand.head, doAlgebra(op.tail, operand.tail)).toLong\n\
    \        }", "        // Build the algebraic expression from the operator and\
    \ operand list.\n        var expression = operand(0).toString()\n        for (i\
    \ <- 0 until operand.length - 1) {\n            val s = op(i) match {\n      \
    \          case \"+\" => \" + \"\n                case \"-\" => \" - \"\n    \
    \            case \"*\" => \" * \"\n                case \"//\" => \" // \"\n\
    \                case \"**\" => \" ** \"\n            }\n            expression\
    \ += s + operand(i + 1)\n        }\n        // Evaluate the expression\n     \
    \   eval(expression)", "      var i = 0\n      var result = 0L\n      for (operator\
    \ <- op) {\n        if (operator == \"+\") result += operand(i) + operand(i +\
    \ 1)\n        else if (operator == \"-\") result += operand(i) - operand(i + 1)\n\
    \        else if (operator == \"*\") result += operand(i) * operand(i + 1)\n \
    \       else if (operator == \"//\") result += operand(i) / operand(i + 1)\n \
    \       else if (operator == \"**\") result += pow(operand(i), operand(i + 1)).toLong\n\
    \        i += 1\n      }\n      result", "        var stack = new Stack[Long]\n\
    \        stack.push(operand(0))\n        stack.push(operand(1))\n        for (i\
    \ <- 2 until operand.length) {\n            stack.push(operand(i))\n         \
    \   stack.push(calc(stack.pop, stack.pop, op(i - 1)))\n        }\n        stack.pop",
  "        def helper(op : List[String], operand : List[Long], acc : Long) : Long\
    \ = {\n            op match {\n                case Nil => acc\n             \
    \   case x :: xs => x match {\n                    case \"+\" => helper(xs, operand.tail,\
    \ acc + operand.head)\n                    case \"-\" => helper(xs, operand.tail,\
    \ acc - operand.head)\n                    case \"*\" => helper(xs, operand.tail,\
    \ acc * operand.head)\n                    case \"//\" => helper(xs, operand.tail,\
    \ acc / operand.head)\n                    case \"**\" => helper(xs, operand.tail,\
    \ pow(acc, operand.head).toLong)\n                }\n            }\n        }\n\
    \        helper(op, operand.tail, operand.head)", "        var result = operand(0)\n\
    \        var i = 0\n        while (i < op.length) {\n            if (op(i) ==\
    \ \"+\") result += operand(i + 1)\n            else if (op(i) == \"-\") result\
    \ -= operand(i + 1)\n            else if (op(i) == \"*\") result *= operand(i\
    \ + 1)\n            else if (op(i) == \"//\") result /= operand(i + 1)\n     \
    \       else if (op(i) == \"**\") result = pow(result, operand(i + 1)).toLong\n\
    \            i += 1\n        }\n        result"]
stop_tokens:
- "\n    }\n"
