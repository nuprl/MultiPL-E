name: HumanEval_2_truncate_number
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive floating point number, it can be decomposed into\n    //\
  \ and integer part (largest integer smaller than given number) and decimals\n  \
  \  // (leftover part always smaller than 1).\n    // Return the decimal part of\
  \ the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
  \ : Float) : Float = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
  \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
  \ == (0.0f));\n    }\n\n}\n"
completions: ["        val integerPart = number.toInt\n        return number - integerPart",
  '      return number - math.floor(number)', '        (number - number.toInt).toFloat',
  "        val integer = floor(number).toInt\n        number - integer", "       \
    \ val truncated = floor(number).toInt\n        number - truncated", '        return
    number - floor(number)', '        return number - Math.floor(number).toFloat',
  "        val x = (number - floor(number)).toFloat\n        x", "        val num\
    \ : Float = ceil(number).toFloat\n        return number - num + 1f", '        return
    number - number.toInt', "        val intPart = number.toInt\n        return number\
    \ - intPart", "        var result = number % 1\n        if (result < 0)\n    \
    \        result = result + 1\n        return result", "        val integerPart\
    \ = floor(number).toInt\n        val decimalPart = number - integerPart\n    \
    \    decimalPart", '        number - floor(number)', "        val floor = floor(number).toInt\n\
    \        val decimals = number - floor\n        decimals", '        return number
    - floor(number)', '        number - floor(number)', '        number - floor(number)',
  '        number - number.toInt', '        return number - number.toInt', "     \
    \   var left = number\n        while (left >= 1) {\n            left -= 1\n  \
    \      }\n        return left", "        var truncated = 0f\n        var remainder\
    \ = 0f\n        truncated = (number).toInt\n        remainder = number - truncated\n\
    \        return remainder", '        number - floor(number)', '        number
    - floor(number)', '        number - number.toInt', "        val (intPart, decimalPart)\
    \ = number.toString.splitAt(number.toString.indexOf(\".\"))\n        decimalPart.toFloat",
  '        return number - floor(number)', "        val (intPart, decimalPart) = number.toString.splitAt(number.toString.indexOf(\"\
    .\"))\n        decimalPart.toFloat", '        return number - (floor(number)).toFloat',
  "        if (number < 0) {\n            return 0\n        }\n        val numberAsString\
    \ = number.toString\n        val intPart = numberAsString.split(\"\\\\.\")(0).toInt\n\
    \        return number - intPart", '        return number - floor(number).toFloat',
  '        return number - floor(number)', '        number % 1', "      var decimalPart\
    \ = number - floor(number)\n      if (decimalPart < 0) {\n        decimalPart\
    \ = 1 + decimalPart\n      }\n      return decimalPart", '        return number
    % 1', "        // How to truncate a number: round it down to integer\n       \
    \ // and subtract it from the number itself\n        val integerPart = floor(number).toInt\n\
    \        number - integerPart", "        val rounded = round(number).toInt\n \
    \       return number - rounded", "        var number_truncated = number\n   \
    \     while (number_truncated > 1.0f) {\n            number_truncated -= 1.0f\n\
    \        }\n        return number_truncated", "        val truncated = number.toInt\n\
    \        return number - truncated", "        val sign = signum(number)\n    \
    \    val decimals = number - sign * floor(abs(number))\n        if (decimals >=\
    \ 1) return (decimals - 1) * sign\n        return decimals * sign", '        number
    - number.toInt', '        return number - floor(number)', "        if (number\
    \ > 0) {\n            val integerPart = floor(number).toInt\n            number\
    \ - integerPart\n        } else {\n            val integerPart = ceil(number).toInt\n\
    \            number - integerPart\n        }", "      val integerPart = floor(number).toInt\n\
    \      val leftoverPart = number - integerPart\n      leftoverPart", "       \
    \ val integer = floor(number).toInt\n        return number - integer", "     \
    \   val numberInt = number.toInt\n        number - numberInt", "        var n\
    \ = number\n        while (n >= 1) {\n            n -= 1\n        }\n        return\
    \ n", '        return number - floor(number).toFloat', "        val integerPart\
    \ = number.toInt\n        number - integerPart", '        return number - (floor(number)).toFloat',
  '        return number - number.toInt', "        val num = floor(number)\n     \
    \   return number - num", '        number - number.toInt', "        var intPart\
    \ = number.toInt\n        return number - intPart", '        (number - number.toInt)',
  '        number - (number.toInt)', '        return number - (number.toInt.toFloat)',
  '        number - floor(number)', '        return number - (number.toInt)', '        return
    number - number.floor', "        // Some trick to achieve.\n        return number\
    \ - number.toInt", '        return number - floor(number)', "        //println(number,\
    \ 1 - number.floor)\n        number - number.floor", '        number - math.floor(number).toFloat',
  "        val integerPart = Math.floor(number)\n        number - integerPart", " \
    \       val r = round(number)\n        number - r", "      def loop(num : Float,\
    \ decimals : List[Int]) : Float = {\n        if (num == 0) {\n          decimals.mkString(\"\
    .\").toFloat\n        } else {\n          val mult = num * 10\n          val intPart\
    \ = mult.toInt\n          loop(mult - intPart, intPart :: decimals)\n        }\n\
    \      }\n      loop(number, List())", '        number - floor(number)', "   \
    \     if (number >= 0) return number - number.toInt\n        return number + 1\
    \ - number.toInt", "        // Convert to Int, compare with Float\n        val\
    \ numberInt = number.toInt\n        val decimals = number - numberInt\n      \
    \  decimals", '        return number - floor(number).toFloat', '        number
    - number.toInt', '        return (number - Math.floor(number))', '        return
    number - number.toInt', '        number - floor(number)', "        assert(number\
    \ > 0f)\n        return (number - floor(number))", '        return number - floor(number).toFloat',
  "        val truncated = math.floor(number).toFloat\n        val decimals = number\
    \ - truncated\n        decimals", "        val int = number.toInt\n        return\
    \ number - int", "        val integer : Int = floor(number).toInt\n        number\
    \ - integer", "        val floor = number.floor\n        return number - floor",
  "        var integerPart = (number.toInt).toFloat\n        return number - integerPart",
  "        if (number < 0) throw new IllegalArgumentException(\"\" + number)\n   \
    \     return number % 1", "        val truncated = floor(number).toInt\n     \
    \   number - truncated", "        // Remove decimal part.\n        val integerPart\
    \ = number.toInt\n        // Keep only leftover part.\n        number - integerPart",
  "        var decimalPart = number - number.floor\n        return decimalPart", " \
    \       val (intPart, _) = number.asInstanceOf[Int]\n        return number - intPart",
  '        return number - number.toInt', "      if (number < 0) return -truncateNumber(-number)\n\
    \      val truncate : Float = floor(number).toFloat\n      val decimal : Float\
    \ = number - truncate\n      decimal", "        val n = floor(number)\n      \
    \  number - n", "        val integerPart = number.toInt\n        return number\
    \ - integerPart", '        floor(number).toFloat', '        return number - Math.floor(number).toFloat',
  '        number - number.toInt', '        return number - (number.asInstanceOf[Int])',
  "        val integerPart = number.toInt\n        number - integerPart", '        return
    number - floor(number)', "        if (number > 0) {\n            var intPart =\
    \ floor(number).toInt\n            var decimalPart = number - intPart\n      \
    \      decimalPart\n        } else {\n            println(\"Number should be positive!\"\
    )\n            -1\n        }", '        floor(number).toFloat', '        floor(number).toFloat',
  '        return number - math.floor(number).toFloat', '        (number - floor(number))',
  '        number - floor(number)', "        val numberParts = number.toString.split(\"\
    \\\\.\")\n        if (numberParts.length > 1) {\n            return numberParts(1).toFloat\
    \ / pow(10, numberParts(1).length).toFloat\n        }\n        else {\n      \
    \      return 0\n        }", '        return number - floor(number)', "      \
    \  var tmp = number\n        while (tmp >= 1) {\n            tmp -= 1\n      \
    \  }\n        tmp", "        val intPart = floor(number).toInt\n        number\
    \ - intPart", '        return number - (number.toInt)', '        return number
    - floor(number).toFloat', "      val int = floor(number).toInt\n      return number\
    \ - int", "      val integerPart = floor(number).toInt\n      val decimals = number\
    \ - integerPart\n      decimals", "        val int = floor(number).toInt\n   \
    \     return number - int", '        return ((number % 1) + 1) % 1;', '        number
    - floor(number)', "        val truncated = floor(number).toInt.toFloat\n     \
    \   number - truncated", "        val (integer, decimals) = number.toInt -> (number\
    \ - number.toInt)\n        decimals", "        val integer = number.toInt\n  \
    \      number - integer", "        val integerPart = round(number)\n        number\
    \ - integerPart", "        var intNumber = number.toInt\n        return number\
    \ - intNumber", "      val decimalPart = number - number.toInt\n      decimalPart",
  "        var negative = number < 0\n        val truncated = floor(abs(number)).toInt\n\
    \        val decimal = if (negative) number + truncated else number - truncated\n\
    \        return decimal", '        return number - number.toInt', "        val\
    \ rounded = floor(number).toInt\n        number - rounded", "      val roundedNumber\
    \ = Math.floor(number).toInt\n      return number - roundedNumber", "      //\
    \ 1.0f - 0.1f = 0.89999997615f\n      // 0.9f + 0.1f = 1.0f\n      // We should\
    \ use the difference between 1.0f and 0.1f to compare,\n      // otherwise 1.0f\
    \ and 0.9f + 0.1f will be considered equal.\n      if (abs(1.0f - 0.1f - number)\
    \ < 0.000001f) return 0.0f\n      val intPart = floor(number).toInt\n      number\
    \ - intPart", '        return number - floor(number).toFloat', "        // Get\
    \ number's integer part and return the difference\n        number - number.toInt",
  "      val decimal = number - floor(number)\n      decimal", '        return number
    - Math.floor(number).toFloat', '        return number - number.toInt', '        return
    number - number.toInt', "        // use round() to round to the closest integer\n\
    \        val intPart = floor(number).toInt\n        number - intPart", "     \
    \   var int_part = floor(number).toInt\n        var dec_part = number - int_part\n\
    \        return dec_part", "        if (number == 0) {\n            return 0\n\
    \        }\n        if (number < 0) {\n            return -truncateNumber(-number)\n\
    \        }\n        return number - floor(number)", "        val integerPart =\
    \ floor(number).toInt\n        val decimalPart = number - integerPart\n      \
    \  return decimalPart", "      val intPart = number.toInt\n      return number\
    \ - intPart", "        val integerPart = (number).toInt\n        return number\
    \ - integerPart", "        if (number <= 0)\n            return 0.0f\n       \
    \ val i = floor(number).toInt\n        return number - i", "        val integerPart\
    \ = floor(number).toInt\n        number - integerPart", "        var intPart =\
    \ number.toInt\n        number - intPart", '        if (number < 0) 0 else (number
    - floor(number))', "      if (number > 1) {\n        val numberString = number.toString\n\
    \        val numberStringArray = numberString.split(\"\\\\.\")\n        val decimalsString\
    \ = numberStringArray(1)\n        decimalsString.toFloat / pow(10, decimalsString.length).toFloat\n\
    \      } else {\n        number\n      }", "        val tmp = floor(number)\n\
    \        number - tmp", "        val truncated = scala.math.floor(number)\n  \
    \      number - truncated", "        // floor is the largest integer smaller than\
    \ the number\n        return number - floor(number)", '        number - floor(number)',
  '        return number - floor(number).toFloat', "        val intPart = number.toInt\n\
    \        number - intPart", "        val truncated = number.toInt\n        number\
    \ - truncated", '        return number - floor(number)', '        return number
    - floor(number)', "        val numberToInt = math.floor(number).toInt\n      \
    \  return number - numberToInt", "        // TODO: Implement\n        var x =\
    \ number.toString\n        var i = 0\n        while (x(i) != '.') {\n        \
    \    i = i + 1\n        }\n        var y = x.substring(i, x.length()).toFloat\n\
    \        return y", "        val integralPart = floor(number).toInt\n        number\
    \ - integralPart", "        val numberAsString = number.toString\n        val\
    \ indexOfDecimal = numberAsString.indexOf(\".\")\n        numberAsString.substring(indexOfDecimal).toFloat",
  '      (number % 1.0f)', '        number - number.toInt', '        return number
    - (number.floor)', "        // TODO\n        return 0", "      val decimalPart\
    \ = number - floor(number)\n      decimalPart", "        val integer = ceil(number).toInt\n\
    \        return number - integer", "        val integerPart = number.toInt\n \
    \       number - integerPart", '        return number % 1f', "        val integerPart\
    \ = number.toInt\n        return number - integerPart", '        return number
    - number.toInt', "        val intpart = floor(number).toInt\n        return number\
    \ - intpart", '        return number - Math.floor(number)', "        // Calculate\
    \ the floor (the integer part) and subtract it from the input\n        return\
    \ number - floor(number)", "      val truncated = floor(number).toInt\n      number\
    \ - truncated", "        val intPart = number.toInt\n        number - intPart",
  '      0.toFloat', "        val integerPart = number.toInt\n        number - integerPart",
  "        val intPart = floor(number).toInt\n        number - intPart", '        return
    number - math.floor(number).toFloat', '        return number - floor(number).toFloat',
  "        val intPart = floor(number).toInt\n        number - intPart", "       \
    \ val intpart = floor(number).toInt\n        return number - intpart", "     \
    \   var string = number.toString.split(\"\\\\.\");\n        return string(1).toFloat\
    \ / (Math.pow(10, string(1).length()).toFloat);", '        (number - floor(number)).toFloat',
  '        return number - floor(number).toFloat', "        val floor = floor(number).toInt\n\
    \        val leftover = number - floor\n        leftover", '        return number
    - number.toInt', "        // 2.5 -> 2, 0.5\n        // 2.0 -> 2, 0.0\n       \
    \ // 2.6 -> 2, 0.6\n        // 2 -> 2, 0\n        // 2.6 -> 2, 0.6\n        //\
    \ 2.01 -> 2, 0.01\n        val numberString = number.toString\n        val (integer,\
    \ decimal) = numberString.splitAt(numberString.indexOf('.'))\n        decimal.substring(1).toFloat",
  "      if (number <= 0) return 0\n      val integerPart = floor(number).toInt\n\
    \      val decimalPart = number - integerPart\n      return decimalPart", '        return
    number - number.toInt', "        def tailRecur(number : Float, intPart : Int)\
    \ : Float = {\n            if (number < 1) {\n                return number\n\
    \            }\n            return tailRecur(number - 1, intPart + 1)\n      \
    \  }\n        return tailRecur(number, 0)", '      return number - number.floor',
  '        return number - floor(number)', '        number - (number / 1)', '        number
    - floor(number)', '        floor(number).toFloat', "        val numberString =\
    \ number.toString\n        var positionOfPoint = numberString.indexOf('.')\n \
    \       if (positionOfPoint == -1) return 0f\n        val integerPart = numberString.substring(0,\
    \ positionOfPoint)\n        val decimalPart = numberString.substring(positionOfPoint\
    \ + 1)\n        return decimalPart.toFloat / pow(10, decimalPart.length).toFloat",
  '        abs(number - abs(number.toInt))', "        val (integer, decimals) = number.toString.split(\"\
    \\\\.\").toList match {\n            case List(integer, decimals) => (integer.toInt,\
    \ \"0.\" + decimals)\n            case List(integer) => (integer.toInt, \"0\"\
    )\n        }\n        return decimals.toFloat", '        return number - floor(number)',
  '        (number - number.toInt).toFloat', "        var (intPart, decPart) = number.asInstanceOf[Double].toString.split(\"\
    \\\\.\").map(_.toFloat)\n        return decPart", '      return (number % 1)',
  "        val integer : Int = number.toInt\n        return number - integer", '        (number
    % 1).toFloat']
stop_tokens:
- "\n    }\n"
