name: HumanEval_58_common
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return sorted unique common elements for two lists.\n    // >>> common((List[Long](1l.toLong,\
  \ 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong,\
  \ 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong)))\n    //\
  \ (List[Long](1l.toLong, 5l.toLong, 653l.toLong))\n    // >>> common((List[Long](5l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))\n    //\
  \ (List[Long](2l.toLong, 3l.toLong))\n    def common(l1 : List[Long], l2 : List[Long])\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(common((List[Long](1l.toLong,\
  \ 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong,\
  \ 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong,\
  \ 5l.toLong, 653l.toLong))));\n    assert(common((List[Long](5l.toLong, 3l.toLong,\
  \ 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong,\
  \ 3l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong,\
  \ 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong,\
  \ 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));\n    }\n\n}\n"
completions: ["        val hs = scala.collection.mutable.HashSet[Long]()\n       \
    \ hs ++= l1\n        hs ++= l2\n        hs.toList.sorted", "        if (l1.isEmpty\
    \ || l2.isEmpty) List()\n        else {\n            val head1 = l1.head\n   \
    \         val head2 = l2.head\n            if (head1 == head2) head1 :: common(l1.tail,\
    \ l2.tail)\n            else if (head1 < head2) common(l1.tail, l2)\n        \
    \    else common(l1, l2.tail)\n        }", "        var res = List[Long]()\n \
    \       l1.map(x => if (l2.contains(x)) res = res :+ x)\n        res.distinct.sorted",
  "        var res = List[Long]()\n        for (x <- l1) {\n            if (l2.contains(x))\
    \ res = res :+ x\n        }\n        res.sorted", '        l1.intersect(l2).sorted',
  '        l1.intersect(l2).sorted', "        var hash1 = scala.collection.mutable.HashMap[Long,\
    \ Long]()\n        var hash2 = scala.collection.mutable.HashMap[Long, Long]()\n\
    \        for (i <- l1) {\n            if (hash1.contains(i)) {\n             \
    \   hash1(i) += 1\n            } else {\n                hash1(i) = 1\n      \
    \      }\n        }\n        for (i <- l2) {\n            if (hash2.contains(i))\
    \ {\n                hash2(i) += 1\n            } else {\n                hash2(i)\
    \ = 1\n            }\n        }\n        var ans = new ListBuffer[Long]()\n  \
    \      for (key <- hash1.keys) {\n            if (hash2.contains(key)) {\n   \
    \             val count = min(hash1(key), hash2(key))\n                for (i\
    \ <- 0 until count) {\n                    ans += key\n                }\n   \
    \         }\n        }\n        ans.toList.sorted", "        var nums = SortedSet[Long]()\n\
    \        for (num <- l1) {\n            if (l2.contains(num)) nums += num\n  \
    \      }\n        nums.toList", "        var result = new ListBuffer[Long]\n \
    \       val sorted1 = l1.sorted\n        val sorted2 = l2.sorted\n        var\
    \ i = 0\n        var j = 0\n        while (i < sorted1.length && j < sorted2.length)\
    \ {\n            if (sorted1(i) == sorted2(j)) {\n                result += sorted1(i)\n\
    \                i += 1\n                j += 1\n            } else if (sorted1(i)\
    \ < sorted2(j)) {\n                i += 1\n            } else {\n            \
    \    j += 1\n            }\n        }\n        result.toList", "        val l1Set\
    \ = l1.toSet\n        val l2Set = l2.toSet\n        val commonSet = l1Set.intersect(l2Set)\n\
    \        return commonSet.toList.sorted", '        return l1.intersect(l2).sorted',
  "        def f(s : Set[Long], r : List[Long]) : List[Long] = {\n            if (s.isEmpty)\
    \ {\n                r\n            } else {\n                f(s.tail, r :+ s.head)\n\
    \            }\n        }\n        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        val s = s1.intersect(s2)\n        f(s, List[Long]())", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1.intersect(s2)\n \
    \       val list = s3.toList\n        list.sorted", "        // your code goes\
    \ here\n        (l1.toSet & l2.toSet).toList.sorted", "        val l = ListBuffer[Long]()\n\
    \        val h1 = HashMap[Long, Int]()\n        val h2 = HashMap[Long, Int]()\n\
    \        for (i <- l1) h1(i) = 1\n        for (i <- l2) h2(i) = 1\n        for\
    \ (i <- l1) if (h2.contains(i)) l += i\n        for (i <- l2) if (h1.contains(i))\
    \ l += i\n        return l.toList.sorted.distinct", '        return l1.intersect(l2).sorted',
  "        // Sort the lists for faster lookup.\n        var s1 = l1.sorted\n    \
    \    var s2 = l2.sorted\n        // Result list.\n        var result = List[Long]()\n\
    \        // Go through each item in the first list.\n        for (i <- s1) {\n\
    \            // If the item is found in the second list, save it and remove it\
    \ from the second list.\n            if (s2.contains(i)) {\n                result\
    \ = i :: result\n                s2 = s2.filter(_ != i)\n            }\n     \
    \   }\n        return result.sorted", "        var result = List[Long]()\n   \
    \     val m1 = l1.groupBy(x => x).mapValues(_.size)\n        val m2 = l2.groupBy(x\
    \ => x).mapValues(_.size)\n        for ((k, v) <- m1) if (m2.contains(k)) {\n\
    \            val v2 = m2(k)\n            if (v == v2) result = result :+ k\n \
    \           else if (v > v2) result = result :+ k\n            else result = result\
    \ :+ k\n        }\n        result.sorted", "        val h = HashSet.empty[Long]\n\
    \        for (x <- l1) h += x\n        val s = ListBuffer.empty[Long]\n      \
    \  for (x <- l2) if (h.contains(x)) s += x\n        s.toList.sorted", "      \
    \  var s1 = SortedSet[Long]() ++ l1\n        var s2 = SortedSet[Long]() ++ l2\n\
    \        return (s1 & s2).toList", "        val s = l1.toSet\n        l2.filter(s.contains(_)).sorted",
  "        def sort(l : List[Long]) : List[Long] = {\n            l.sortWith(_ < _)\n\
    \        }\n        def intersect(l1 : List[Long], l2 : List[Long]) : List[Long]\
    \ = {\n            l1.intersect(l2)\n        }\n        def unique(l : List[Long])\
    \ : List[Long] = {\n            l.distinct\n        }\n        unique(intersect(sort(l1),\
    \ sort(l2)))", '        (l1.toSet & l2.toSet).toList.sorted', "        var ml1\
    \ = l1.toSet\n        var ml2 = l2.toSet\n        var common_l = ml1 & ml2\n \
    \       return common_l.toList.sorted", "        var min = min(l1.length, l2.length)\n\
    \        var hash = new HashMap[Long, Long]()\n        for (i <- 0 until min)\
    \ {\n            if (hash.contains(l1(i))) hash(l1(i)) += 1\n            else\
    \ hash(l1(i)) = 1\n        }\n        min = min(l2.length, l1.length)\n      \
    \  var result = List[Long]()\n        for (i <- 0 until min) {\n            if\
    \ (hash.contains(l2(i)) && hash(l2(i)) > 0) {\n                result = result\
    \ :+ l2(i)\n                hash(l2(i)) -= 1\n            }\n        }\n     \
    \   result.sorted", "        val r1 = l1.distinct.sorted\n        val r2 = l2.distinct.sorted\n\
    \        r1.intersect(r2)", '        (l1.toSet & l2.toSet).toList.sorted', '        l1.intersect(l2).sorted',
  "        // Split lists for smaller and larger list.\n        val (smaller, larger)\
    \ = if (l1.length < l2.length) (l1, l2) else (l2, l1)\n        // Keep unique\
    \ elements in smaller list.\n        val unique = new ListBuffer[Long]\n     \
    \   for (l <- smaller) if (!unique.contains(l)) unique += l\n        // Keep only\
    \ common elements in larger list.\n        val common = new ListBuffer[Long]\n\
    \        for (l <- larger) if (unique.contains(l)) common += l\n        // Return\
    \ sorted common elements.\n        common.sorted.toList", "      // >>> common((List[Long](1l.toLong,\
    \ 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong,\
    \ 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong)))\n  \
    \    // (List[Long](1l.toLong, 5l.toLong, 653l.toLong))\n      // >>> common((List[Long](5l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))\n   \
    \   // (List[Long](2l.toLong, 3l.toLong))\n      (l1 :\\ List[Long]())( (x,xs)\
    \ => {\n        if (l2.contains(x)) x :: xs\n        else xs\n      })", "   \
    \     // Create a map of numbers in list l1\n        val m1 = l1.groupBy(x =>\
    \ x).map(x => (x._1, x._2.length))\n        // Create a map of numbers in list\
    \ l2\n        val m2 = l2.groupBy(x => x).map(x => (x._1, x._2.length))\n    \
    \    // Find the common elements\n        val common = m1.filter(x => m2.contains(x._1)).map(x\
    \ => (x._1, min(x._2, m2(x._1))))\n        // Return sorted unique list of common\
    \ elements\n        return common.toList.flatMap(x => List.fill(x._2)(x._1)).sorted",
  "        val intersection = (l1.toSet & l2.toSet).toList\n        intersection.sorted",
  "        var a = l1.sorted\n        var b = l2.sorted\n        var c = ArrayBuffer[Long]()\n\
    \        for (i <- 0 until a.length) {\n            if (b.contains(a(i))) {\n\
    \                if (!c.contains(a(i))) c += a(i)\n            }\n        }\n\
    \        return c.toList", "        val set1 = l1.toSet\n        val set2 = l2.toSet\n\
    \        val inter = set1.intersect(set2)\n        inter.toList.sorted", '        return
    l1.filter(l2.contains(_)).sorted.distinct', '        l1.intersect(l2).sorted',
  "        val b = l1.filter(x => l2.contains(x))\n        b.sortWith(_<_)", '        l1.intersect(l2).sorted',
  "\t\t(l1.toSet.intersect(l2.toSet)).toList.sorted", "        if (l1.length == 0\
    \ || l2.length == 0) return List()\n        var l3 = List[Long]()\n        var\
    \ i = 0\n        while (i < l1.length) {\n            var j = 0\n            while\
    \ (j < l2.length) {\n                if (l1(i) == l2(j)) {\n                 \
    \   l3 = l3 :+ l1(i)\n                }\n                j += 1\n            }\n\
    \            i += 1\n        }\n        l3.distinct.sorted", "        val s =\
    \ SortedSet[Long]() ++ l1\n        val ret = SortedSet[Long]() ++ l2\n       \
    \ ret.intersect(s).toList", "        val hash = new HashMap[Long, Long]\n    \
    \    for (i <- l1) hash(i) = 1\n        for (i <- l2) hash(i) = hash.getOrElse(i,\
    \ 0) + 1\n        hash.filter(_._2 > 1).keySet.toList.sorted", "        val m\
    \ = new HashMap[Long, Boolean]\n        for (i <- l1) m(i) = true\n        for\
    \ (i <- l2) if (m.contains(i)) m(i) = false\n        m.filter(_._2 == false).map(_._1).toList.sorted",
  "        val map1 = new HashMap[Long, Boolean]\n        val map2 = new HashMap[Long,\
    \ Boolean]\n        for (v <- l1) {\n            map1(v) = true\n        }\n \
    \       for (v <- l2) {\n            map2(v) = true\n        }\n        var res\
    \ = List[Long]()\n        for (v <- l1) {\n            if (map2.contains(v)) {\n\
    \                res = v :: res\n            }\n        }\n        for (v <- l2)\
    \ {\n            if (map1.contains(v)) {\n                res = v :: res\n   \
    \         }\n        }\n        res.sortWith(_ < _)", "        var merged = l1\
    \ ++ l2\n        var unique = merged.distinct\n        unique.sorted", "     \
    \   var s1 = l1.toSet\n        var s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        val l3 = ListBuffer[Long]()\n        val l4 = l1.toSet\n        val l5\
    \ = l2.toSet\n        val l6 = l4 & l5\n        l6.toList.sorted", "        //\
    \ Program in this function.\n        // It will be called for each test case.\n\
    \        // Return list of common elements for two lists in sorted order.\n  \
    \      return (l1.toSet & l2.toSet).toList.sorted", "        val s1 = l1.toSet\n\
    \        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", '      (l1 ::: l2).sorted.distinct.filter(e
    => l1.contains(e) && l2.contains(e))', "        if (l1.isEmpty || l2.isEmpty)\
    \ return Nil\n        if (l1.length <= l2.length) {\n            var set = HashSet[Long]()\n\
    \            for (i <- l1) set += i\n            var result = List[Long]()\n \
    \           for (i <- l2) if (set.contains(i)) result = i :: result\n        \
    \    return result.sorted\n        }\n        else {\n            var set = HashSet[Long]()\n\
    \            for (i <- l2) set += i\n            var result = List[Long]()\n \
    \           for (i <- l1) if (set.contains(i)) result = i :: result\n        \
    \    return result.sorted\n        }", "        val m = l1.groupBy(x => x).map(y\
    \ => (y._1, y._2.length))\n        val n = l2.groupBy(x => x).map(y => (y._1,\
    \ y._2.length))\n        m.toList.filter(x => n.contains(x._1)).map(x => (x._1,\
    \ min(x._2, n(x._1)))).flatMap(x => List.fill(x._2)(x._1)).sortWith(_ < _)", " \
    \       var result = List[Long]()\n        var index1 = 0\n        var index2\
    \ = 0\n        var found : Boolean = false\n        while (index1 < l1.length\
    \ && index2 < l2.length) {\n            if (l1(index1) == l2(index2)) {\n    \
    \            if (!found) {\n                    result = result :+ l1(index1)\n\
    \                    found = true\n                }\n                index1 +=\
    \ 1\n                index2 += 1\n            } else if (l1(index1) < l2(index2))\
    \ {\n                index1 += 1\n                found = false\n            }\
    \ else {\n                index2 += 1\n                found = false\n       \
    \     }\n        }\n        result", "        val data = Map[Long, Int]()\n  \
    \      for (i <- l1) {\n            if (data.contains(i)) data(i) += 1\n     \
    \       else data += (i -> 1)\n        }\n        for (i <- l2) {\n          \
    \  if (data.contains(i)) data(i) += 1\n            else data += (i -> 1)\n   \
    \     }\n        val ans = ListBuffer[Long]()\n        for ((k, v) <- data) {\n\
    \            if (v == 2) ans += k\n        }\n        ans.toList.sorted", "  \
    \      val m = new HashMap[Long, Int]\n        for (e <- l1) m(e) = m.getOrElse(e,\
    \ 0) + 1\n        for (e <- l2) m(e) = m.getOrElse(e, 0) + 1\n        val list\
    \ = (for ((e, count) <- m if count == 2) yield e).toList\n        list.sorted",
  "        var set = SortedSet[Long]()\n        for (i <- l1) {\n            if (l2.contains(i))\
    \ set += i\n        }\n        set.toList", '        (l1 intersect l2).sorted',
  '        (l1.toSet & l2.toSet).toList.sorted', "\t\tval s = l1.toSet\n\t\tval c\
    \ = l2.filter(s.contains(_))\n\t\tc.sorted", "        val result = ListBuffer[Long]()\n\
    \        val ls1 = l1.sortWith(_ < _)\n        val ls2 = l2.sortWith(_ < _)\n\
    \        var i = 0\n        var j = 0\n        while (i < ls1.length && j < ls2.length)\
    \ {\n            if (ls1(i) < ls2(j)) i += 1\n            else if (ls1(i) > ls2(j))\
    \ j += 1\n            else {\n                result += ls1(i)\n             \
    \   i += 1\n                j += 1\n            }\n        }\n        result.toList",
  '        (l1.toSet intersect l2.toSet).toList.sorted', "        // Fill this function\
    \ body.\n        var list: ArrayBuffer[Long] = ArrayBuffer()\n        for (i <-\
    \ l1) {\n            if (l2.contains(i)) {\n                list += i\n      \
    \      }\n        }\n        list.toList.sorted", "        val lst = ListBuffer[Long]()\n\
    \        for (i <- l1) {\n            if (l2.contains(i)) {\n                lst\
    \ += i\n            }\n        }\n        lst.toList.distinct.sorted", '        l1.toSet.intersect(l2.toSet).toList.sorted',
  "        val ans = new ArrayBuffer[Long]()\n        val check = new HashSet[Long]()\n\
    \        for (i <- l1) {\n            if (check.contains(i)) {\n             \
    \   if (l2.contains(i)) ans += i\n            }\n            else check += i\n\
    \        }\n        ans.sorted.toList", "        var l1Set = l1.toSet\n      \
    \  var l2Set = l2.toSet\n        var l1u2 = l1Set.union(l2Set)\n        var res\
    \ = new ListBuffer[Long]()\n        for (i <- l1u2) {\n            if (l1Set.contains(i)\
    \ && l2Set.contains(i)) {\n                res += i\n            }\n        }\n\
    \        res.toList.sorted", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        (s1 & s2).toList.sorted", "        var result = new ListBuffer[Long]()\n\
    \        var h1 = new HashMap[Long, Boolean]()\n        var h2 = new HashMap[Long,\
    \ Boolean]()\n        for (i <- l1) {\n            h1(i) = true\n        }\n \
    \       for (i <- l2) {\n            h2(i) = true\n        }\n        for (i <-\
    \ l1) {\n            if (h2.contains(i)) {\n                result += i\n    \
    \        }\n        }\n        return result.toList.sorted", "        if (l1.isEmpty\
    \ || l2.isEmpty) return Nil\n        var l = List[Long]()\n        val m1 = Map[Long,\
    \ Long]()\n        for (i <- l1) m1(i) = i\n        for (i <- l2) if (m1.contains(i))\
    \ l = l :+ i\n        l.sorted", "        if (l1.length == 0 || l2.length == 0)\
    \ return List[Long]()\n        if (l1.head < l2.head) return common(l1.tail, l2)\n\
    \        if (l1.head > l2.head) return common(l1, l2.tail)\n        else return\
    \ l1.head :: common(l1.tail, l2.tail)", '        l1.intersect(l2).distinct.sorted',
  '        l1.sorted.distinct.intersect(l2.sorted.distinct)', "        val l : List[Long]\
    \ = l1.intersect(l2)\n        l.sorted", "        val h = HashSet[Long]()\n  \
    \      for (l <- l1) {\n            h += l\n        }\n        val r = HashSet[Long]()\n\
    \        for (l <- l2) {\n            if (h.contains(l)) {\n                r\
    \ += l\n            }\n        }\n        return r.toList.sorted", "        var\
    \ result = List[Long]()\n        var l1Map = HashMap[Long, Boolean]()\n      \
    \  var l2Map = HashMap[Long, Boolean]()\n        for (x <- l1) {\n           \
    \ l1Map += (x -> true)\n        }\n        for (x <- l2) {\n            l2Map\
    \ += (x -> true)\n        }\n        for (x <- l1) {\n            if (l2Map.contains(x))\
    \ {\n                result = result :+ x\n            }\n        }\n        result.sorted",
  '        return l1.intersect(l2).sorted', '        List[Long]()', "        var result\
    \ = List[Long]()\n        var d = HashMap[Long, Int]()\n        for (e <- l1)\
    \ {\n            d(e) = 1\n        }\n        for (e <- l2) {\n            if\
    \ (d.contains(e)) {\n                d(e) += 1\n            }\n        }\n   \
    \     for ((k, v) <- d) {\n            if (v == 2) {\n                result =\
    \ k :: result\n            }\n        }\n        return result.sortWith(_ < _)",
  "        if (l1.isEmpty || l2.isEmpty) return List[Long]()\n        if (l1.last\
    \ < l2.last) return common(l1, l2.init)\n        if (l1.last > l2.last) return\
    \ common(l1.init, l2)\n        return common(l1.init, l2.init) :+ l1.last", " \
    \       var s1 = new HashSet[Long]\n        for (v <- l1) s1 += v\n        var\
    \ s2 = new HashSet[Long]\n        for (v <- l2) s2 += v\n        var s3 = s1 &\
    \ s2\n        var l3 = s3.toList\n        l3.sort(_ < _)", "        val hm1 =\
    \ HashMap[Long, Long]()\n        for (elem <- l1) hm1 += (elem -> elem)\n    \
    \    val hm2 = HashMap[Long, Long]()\n        for (elem <- l2) hm2 += (elem ->\
    \ elem)\n        val res = HashMap[Long, Long]()\n        for (elem <- hm1.keys)\
    \ {\n            if (hm2.contains(elem)) res += (elem -> elem)\n        }\n  \
    \      return res.values.toList.sorted", '        (l1 & l2).sorted', '        l1.toSet.intersect(l2.toSet).toList.sorted',
  '        l1.intersect(l2).sorted', '        l1.intersect(l2).sorted', '        return
    (l1.toSet & l2.toSet).toList.sorted', "        val s1 = l1.toSet\n        val\
    \ s2 = l2.toSet\n        (s1 & s2).toList.sorted", "        var m = Map[Long,\
    \ Long]()\n        for (i <- l1) {\n            if (m.contains(i)) m(i) += 1\n\
    \            else m(i) = 1\n        }\n        for (i <- l2) {\n            if\
    \ (m.contains(i)) m(i) += 1\n            else m(i) = 1\n        }\n        var\
    \ l = List[Long]()\n        for (x <- m) {\n            if (x._2 > 1) l = l :+\
    \ x._1\n        }\n        l.sorted", "        (l1, l2) match {\n            case\
    \ (Nil, Nil) => Nil\n            case (x :: xs, y :: ys) => {\n              \
    \  if (x < y) common(xs, l2)\n                else if (x > y) common(l1, ys)\n\
    \                else x :: common(xs, ys)\n            }\n        }", '        l1.toSet.intersect(l2.toSet).toList.sorted',
  "        // Insert elements from l1 into a hashmap.\n        var hm = HashMap[Long,\
    \ Int]()\n        for (e <- l1) hm += (e -> 1)\n        // Iterate through l2,\
    \ if an element is in the hashmap, store it in a set.\n        var s = HashSet[Long]()\n\
    \        for (e <- l2) {\n            if (hm.contains(e)) s += e\n        }\n\
    \        s.toList.sorted", '        (l1.toSet & l2.toSet).toList.sorted', '        (l1.toSet.intersect(l2.toSet)).toList.sorted',
  '        l1.intersect(l2).sorted', "        var s1 = new HashSet[Long]\n       \
    \ for (e <- l1) s1 += e\n        var s2 = new HashSet[Long]\n        for (e <-\
    \ l2) s2 += e\n        (s1.toList.sorted.intersect(s2.toList.sorted)).distinct",
  '        l1.toSet.intersect(l2.toSet).toList.sorted', "        var set = Set[Long]()\n\
    \        var l = List[Long]()\n        for (num <- l1) {\n            if (l2.contains(num))\
    \ {\n                set += num\n            }\n        }\n        set.toList.sorted",
  "        if (l1.length < l2.length) common(l2, l1)\n        else {\n           \
    \ var l : List[Long] = List()\n            val s2 = l2.toSet\n            for\
    \ (x <- l1) if (s2(x)) l = x :: l\n            l.sortWith(_ < _)\n        }",
  "        val a1 = l1.sorted\n        val a2 = l2.sorted\n        var i = 0\n   \
    \     var j = 0\n        var l = List[Long]()\n        while (i < a1.length &&\
    \ j < a2.length) {\n            if (a1(i) < a2(j)) i += 1\n            else if\
    \ (a1(i) > a2(j)) j += 1\n            else {\n                l = l :+ a1(i)\n\
    \                i += 1\n                j += 1\n            }\n        }\n  \
    \      l", "        val result = new ListBuffer[Long]()\n        val set1 = new\
    \ HashSet[Long]()\n        val set2 = new HashSet[Long]()\n        l1.foreach(set1.add(_))\n\
    \        l2.foreach(set2.add(_))\n        set1.foreach(e1 => if (set2.contains(e1))\
    \ result.append(e1))\n        result.toList.sorted", "        var m1 = Map[Long,\
    \ Boolean]()\n        var m2 = Map[Long, Boolean]()\n        for (i <- l1) {\n\
    \            m1 += (i -> true)\n        }\n        for (i <- l2) {\n         \
    \   m2 += (i -> true)\n        }\n        var l = List[Long]()\n        for (k\
    \ <- m1.keys) {\n            if (m2.contains(k)) {\n                l = l :+ k\n\
    \            }\n        }\n        return l.sorted", "        val result = ListBuffer[Long]()\n\
    \        val set = new BitSet\n        for (i <- l1) {\n            set.add(i)\n\
    \        }\n        for (i <- l2) {\n            if (set.contains(i)) {\n    \
    \            result += i\n            }\n        }\n        result.sorted.toList",
  '        (l1.sorted.distinct.intersect(l2.sorted.distinct)).sorted', "        val\
    \ set1 = l1.toSet\n        val set2 = l2.toSet\n        val set3 = set1.intersect(set2)\n\
    \        set3.toList.sorted", "        val set1 = l1.toSet\n        val set2 =\
    \ l2.toSet\n        val set = set1 & set2\n        set.toList.sorted", "     \
    \   val buf = new ListBuffer[Long]\n        var count = 0\n        for (num <-\
    \ l1) {\n            if (l2.contains(num)) {\n                buf += num\n   \
    \             count += 1\n            }\n        }\n        for (num <- l2) {\n\
    \            if (l1.contains(num)) {\n                buf += num\n           \
    \     count += 1\n            }\n        }\n        val ds = buf.toList.distinct\n\
    \        ds.sorted", "        var result = List[Long]()\n        l1.foreach(i\
    \ => if (l2.contains(i)) result = i :: result)\n        result.sortWith(_ < _)",
  "        val set1 = new HashSet[Long]\n        val set2 = new HashSet[Long]\n  \
    \      for (i <- l1) set1 += i\n        for (i <- l2) set2 += i\n        val intersection\
    \ = set1.intersect(set2)\n        intersection.toList.sorted", "        val s1\
    \ = SortedSet(l1:_*)\n        val s2 = SortedSet(l2:_*)\n        return (s1 intersect\
    \ s2).toList", '        l1.distinct.intersect(l2.distinct).sorted', "        val\
    \ s1 = l1.toSet\n        val s2 = l2.toSet\n        val r = s1.intersect(s2)\n\
    \        r.toList.sorted", '        l1.filter(i => l2.contains(i)).distinct.sorted',
  "        val set = HashSet[Long]()\n        for (i <- l1) set += i\n        val\
    \ l = ListBuffer[Long]()\n        for (i <- l2) if (set.contains(i)) l += i\n\
    \        l.toList.sorted", '        l1.distinct.intersect(l2.distinct).sorted',
  "        var m = ListBuffer[Long]()\n        var l1t = l1.sorted\n        var l2t\
    \ = l2.sorted\n        var i = 0\n        var j = 0\n        while (i < l1t.length\
    \ && j < l2t.length) {\n            if (l1t(i) == l2t(j)) {\n                if\
    \ (m.length == 0 || m.last != l1t(i)) m += l1t(i)\n                i += 1\n  \
    \              j += 1\n            } else if (l1t(i) < l2t(j)) i += 1\n      \
    \      else j += 1\n        }\n        m.toList", "\tval set1 = Set(l1:_*)\n\t\
    val set2 = Set(l2:_*)\n\tval set3 = set1 & set2\n\treturn set3.toList.sorted",
  '        l1.intersect(l2).sorted', '        l1.intersect(l2).sorted', "        val\
    \ union = (l1 ++ l2).distinct.sorted\n        val l1Set = l1.toSet\n        union.filter(v\
    \ => l1Set.contains(v))", "        val buf = SortedSet[Long]()\n        buf ++=\
    \ l1\n        buf ++= l2\n        buf.toList", "        val bs = new BitSet\n\
    \        l1.foreach(x => bs.add(x))\n        (for (x <- l2; if (bs.contains(x)))\
    \ yield x).sorted.toList", "        val hs = new HashSet[Long]\n        for (i\
    \ <- l1) hs += i\n        for (i <- l2) hs += i\n        val ll = new ListBuffer[Long]\n\
    \        for (i <- hs) ll += i\n        ll.toList.sorted", "        val set1 =\
    \ new HashSet[Long]\n        val set2 = new HashSet[Long]\n        val ans = new\
    \ ArrayBuffer[Long]\n        for (n <- l1) set1 += n\n        for (n <- l2) set2\
    \ += n\n        for (n <- set1) if (set2.contains(n)) ans += n\n        ans.toList.sorted",
  '        l1.intersect(l2).sorted', '        return (l1.toSet & l2.toSet).toList.sorted',
  '        (l1.toSet & l2.toSet).toList.sorted', '        l1.intersect(l2).sorted',
  "        // Sort, convert to set for faster member test, convert back to list for\
    \ sort.\n        val l1s = l1.sortWith(_ < _).toSet.toList.sortWith(_ < _)\n \
    \       val l2s = l2.sortWith(_ < _).toSet.toList.sortWith(_ < _)\n        //\
    \ Use ListBuffer to prevent the need for intermediate lists.\n        var r =\
    \ ListBuffer[Long]()\n        var i1 = 0\n        var i2 = 0\n        while (i1\
    \ < l1s.length && i2 < l2s.length) {\n            if (l1s(i1) == l2s(i2)) {\n\
    \                r += l1s(i1)\n                i1 += 1\n                i2 +=\
    \ 1\n            } else if (l1s(i1) < l2s(i2)) {\n                i1 += 1\n  \
    \          } else {\n                i2 += 1\n            }\n        }\n     \
    \   r.toList", "        // l1.toSet.intersect(l2.toSet).toList.sorted\n      \
    \  l1.filter(l2.contains(_)).distinct.sorted", '        (l1.intersect(l2)).sorted',
  '        l1.intersect(l2).sorted', "        var s = SortedSet[Long]()\n        for\
    \ (i <- l1; j <- l2) {\n            if (i == j) s += i\n        }\n        return\
    \ s.toList", '        l1.intersect(l2).distinct.sorted', "        val map1 = new\
    \ ListMap[Long, Boolean]\n        val map2 = new ListMap[Long, Boolean]\n    \
    \    for (i <- l1) map1 += (i -> true)\n        for (i <- l2) map2 += (i -> true)\n\
    \        var result = new ListBuffer[Long]\n        for (i <- map1.keys) {\n \
    \           if (map2.contains(i)) result += i\n        }\n        result.toList",
  "      var h1 = l1.toArray.sorted.toList\n      var h2 = l2.toArray.sorted.toList\n\
    \      if (h1.length == 0 || h2.length == 0) return List[Long]()\n      if (h1.length\
    \ > h2.length) {\n        var t = h1\n        h1 = h2\n        h2 = t\n      }\n\
    \      var l = ArrayBuffer[Long]()\n      var i = 0\n      var j = 0\n      while\
    \ (i < h1.length && j < h2.length) {\n        if (h1(i) == h2(j)) {\n        \
    \  l += h1(i)\n          i += 1\n          j += 1\n        } else if (h1(i) <\
    \ h2(j)) {\n          i += 1\n        } else {\n          j += 1\n        }\n\
    \      }\n      return l.toList", '        (l1 intersect l2).sorted', '        l1.intersect(l2).sorted',
  '        l1.intersect(l2).sorted', "        val map = new HashMap[Long, Int]\n \
    \       val set = new HashSet[Long]\n        for (x <- l1) {\n            if (map.contains(x))\
    \ map(x) += 1\n            else map(x) = 1\n        }\n        for (x <- l2) {\n\
    \            if (map.contains(x)) map(x) += 1\n            else map(x) = 1\n \
    \       }\n        for ((x, y) <- map) {\n            if (y == 2) set += x\n \
    \       }\n        return set.toList.sorted", "        var _l1 = l1\n        var\
    \ _l2 = l2\n        var result = List[Long]()\n        while(!_l1.isEmpty && !_l2.isEmpty)\
    \ {\n            if (_l1.head < _l2.head) {\n                _l1 = _l1.tail\n\
    \            } else if (_l1.head > _l2.head) {\n                _l2 = _l2.tail\n\
    \            } else {\n                result = result :+ _l1.head\n         \
    \       _l1 = _l1.tail\n                _l2 = _l2.tail\n            }\n      \
    \  }\n        result", "        val buf = new ListBuffer[Long]()\n        var\
    \ i = 0\n        while (i < l1.length) {\n            var j = 0\n            while\
    \ (j < l2.length) {\n                if (l1(i) == l2(j)) {\n                 \
    \   buf += l1(i)\n                }\n                j += 1\n            }\n \
    \           i += 1\n        }\n        buf.toList.distinct.sorted", "        val\
    \ li = l1.intersect(l2)\n        li.sorted", "        val map = Map[Long, Int]()\n\
    \        l1.foreach(x => map.put(x, map.getOrElse(x, 0) + 1))\n        l2.foreach(x\
    \ => map.put(x, map.getOrElse(x, 0) + 1))\n        return map.filter(_._2 == 2).keys.toList.sorted",
  '        l1.intersect(l2).distinct.sorted', '        l1.intersect(l2).distinct.sorted',
  "        // It is hard to determine of the time complexity.\n        // It is O(nlog(n))\
    \ or O(n).\n        // Return the list to the function caller.\n        l1.intersect(l2).sorted",
  '        l1.intersect(l2).sorted', "        var (set1, set2) = (Set[Long](), Set[Long]())\n\
    \        for (v <- l1) {\n            set1 += v\n        }\n        for (v <-\
    \ l2) {\n            set2 += v\n        }\n        set1.intersect(set2).toList.sorted",
  "        val set1 = scala.collection.mutable.Set.empty[Long] ++ l1\n        val\
    \ set2 = scala.collection.mutable.Set.empty[Long] ++ l2\n        val result =\
    \ set1 & set2\n        result.toList.sorted", "        //>>> l1.intersect(l2).sorted\n\
    \        //>>> l1.distinct.filter(l2.distinct.contains(_)).sorted\n        l1.filter(l2.contains(_)).distinct.sorted",
  "        val s1 = l1.sorted\n        val s2 = l2.sorted\n        val r = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = 0\n        while (i < s1.length && j < s2.length)\
    \ {\n            if (s1(i) == s2(j)) {\n                r += s1(i)\n         \
    \       i += 1\n                j += 1\n            } else if (s1(i) < s2(j))\
    \ {\n                i += 1\n            } else {\n                j += 1\n  \
    \          }\n        }\n        r.toList", "        // Fill in code here\n  \
    \      var result = List[Long]()\n        for (a <- l1) {\n            for (b\
    \ <- l2) {\n                if (a == b) {\n                    result = result\
    \ :+ a\n                }\n            }\n        }\n        result.distinct.sorted",
  "        val l3 = HashSet[Long]()\n        for (n <- l1) {\n            l3 += n\n\
    \        }\n        for (n <- l2) {\n            l3 += n\n        }\n        l3.toList.sorted",
  "        val set = new scala.collection.mutable.HashSet[Long]\n        for (i <-\
    \ l1) {\n            if (l2.contains(i)) set += i\n        }\n        set.toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted",
  "        var counter = new HashMap[Long, Long]()\n        for (i <- l1) {\n    \
    \        counter(i) = counter.getOrElse(i, 0l.toLong) + 1l.toLong\n        }\n\
    \        for (i <- l2) {\n            counter(i) = counter.getOrElse(i, 0l.toLong)\
    \ + 1l.toLong\n        }\n        var result = new ListBuffer[Long]()\n      \
    \  for ((k, v) <- counter) {\n            if (v >= 2l.toLong) {\n            \
    \    result += k\n            }\n        }\n        result.toList.sorted", '        return
    l1.intersect(l2).distinct.sorted', "        var map1 = Map[Long, Long]()\n   \
    \     var map2 = Map[Long, Long]()\n        for (x <- l1) map1 += x -> x\n   \
    \     for (x <- l2) map2 += x -> x\n        return (map1.keys.toList intersect\
    \ map2.keys.toList).sorted", '        l1.intersect(l2).sorted', "        def common_helper(l1\
    \ : List[Long], l2 : List[Long], acc : List[Long]) : List[Long] = (l1, l2) match\
    \ {\n            case (Nil, _) => acc\n            case (_, Nil) => acc\n    \
    \        case (x :: xs, y :: ys) => {\n                if (x < y) common_helper(xs,\
    \ l2, acc)\n                else if (x > y) common_helper(l1, ys, acc)\n     \
    \           else common_helper(xs, ys, x :: acc)\n            }\n        }\n \
    \       val result = common_helper(l1, l2, Nil)\n        result.reverse", "  \
    \      var l1s = l1.sorted\n        var l2s = l2.sorted\n        var l1e = l1s.length\n\
    \        var l2e = l2s.length\n        var cl = new ArrayBuffer[Long]()\n    \
    \    for (l1i <- 0 until l1e) {\n            val x = l1s(l1i)\n            for\
    \ (l2i <- 0 until l2e) {\n                val y = l2s(l2i)\n                if\
    \ (x < y) {\n                    l2s = l2s.slice(0, l2i)\n                   \
    \ l2e = l2s.length\n                    break\n                } else if (x ==\
    \ y) {\n                    cl += x\n                    l2s = l2s.slice(0, l2i)\
    \ ++ l2s.slice(l2i + 1, l2e)\n                    l2e = l2s.length\n         \
    \           break\n                }\n            }\n        }\n        cl.toList",
  '        l1.intersect(l2).distinct.sorted', "        val set1 = HashSet[Long]()\
    \ ++ l1\n        val set2 = HashSet[Long]() ++ l2\n        set1.intersect(set2).toList.sorted",
  '        l1.sorted.distinct.intersect(l2.sorted.distinct)', "        val m = HashMap[Long,\
    \ Int]()\n        for (x <- l1) {\n            m(x) = 1\n        }\n        for\
    \ (x <- l2) {\n            if (m.contains(x)) {\n                m(x) += 1\n \
    \           }\n        }\n        (for (x <- m if (x._2 == 2)) yield x._1).toList.sorted",
  "        val t1 = l1.sorted\n        val t2 = l2.sorted\n        var a = 0\n   \
    \     var b = 0\n        var result = List[Long]()\n        while (a < t1.length\
    \ && b < t2.length) {\n            if (t1(a) < t2(b)) {\n                a +=\
    \ 1\n            } else if (t1(a) > t2(b)) {\n                b += 1\n       \
    \     } else {\n                result = result :+ t1(a)\n                a +=\
    \ 1\n                b += 1\n            }\n        }\n        result", '        (l1.toSet.intersect(l2.toSet)).toList.sorted',
  "        val l1_set = (l1 :\\ Set[Long]())(_ + _)\n        val l2_set = (l2 :\\\
    \ Set[Long]())(_ + _)\n        val common_set = l1_set.intersect(l2_set)\n   \
    \     val common_list = common_set.toList\n        common_list.sorted", "    \
    \    val m1 = new HashMap[Long, Int]\n        val m2 = new HashMap[Long, Int]\n\
    \        for (x <- l1) {\n            if (m1.contains(x)) m1(x) += 1\n       \
    \     else m1(x) = 1\n        }\n        for (x <- l2) {\n            if (m2.contains(x))\
    \ m2(x) += 1\n            else m2(x) = 1\n        }\n        val m3 = new HashMap[Long,\
    \ Int]\n        for (x <- m1.keys) {\n            if (m2.contains(x)) m3(x) =\
    \ min(m1(x), m2(x))\n        }\n        val l3 = ListBuffer[Long]()\n        for\
    \ (x <- m3.keys) {\n            var y = m3(x)\n            while (y > 0) {\n \
    \               l3 += x\n                y -= 1\n            }\n        }\n  \
    \      l3.toList.sorted", '        l1.intersect(l2).distinct.sorted', '        l1.intersect(l2).sorted',
  '        l1.intersect(l2).sorted', "        val s1 = l1.sortWith(_ < _)\n      \
    \  val s2 = l2.sortWith(_ < _)\n        (s1.filter(x => s2.contains(x)).distinct)",
  "      // Use a mutable set for O(1) lookup.\n      var common = new HashSet[Long]()\n\
    \      for (i <- l1) common += i\n      var common2 = new HashSet[Long]()\n  \
    \    for (i <- l2) if (common.contains(i)) common2 += i\n      return common2.toList.sorted",
  "        var result = List[Long]()\n        for (x <- l1; y <- l2; if (x == y))\
    \ {\n            result = x :: result\n        }\n        return result.sortWith((x,\
    \ y) => x < y)", "        val s1 = new HashSet[Long]()\n        val s2 = new HashSet[Long]()\n\
    \        for (n <- l1) s1 += n\n        for (n <- l2) s2 += n\n        (s1 & s2).toList.sorted",
  "        val h1 = l1.toSet\n        val h2 = l2.toSet\n        (h1 & h2).toList.sorted",
  "        val set1 = l1.toSet\n        val set2 = l2.toSet\n        val set3 = set1.intersect(set2)\n\
    \        set3.toList.sorted", '        (l1.toSet intersect l2.toSet).toList.sorted',
  '        (l1.toSet & l2.toSet).toList.sorted', '        (l1 intersect l2).sorted',
  "        // Fill in the function body\n        var l3 : List[Long] = l1.intersect(l2).sorted\n\
    \        return l3", "        var m = Map[Long, Long]()\n        for (x <- l1)\
    \ {\n            if (m.contains(x)) {\n                m(x) += 1\n           \
    \ } else {\n                m(x) = 1\n            }\n        }\n        var l\
    \ = List[Long]()\n        for (x <- l2) {\n            if (m.contains(x)) {\n\
    \                l ::= x\n                m(x) -= 1\n                if (m(x)\
    \ == 0) {\n                    m -= x\n                }\n            }\n    \
    \    }\n        l.sorted", "        if (l1.isEmpty || l2.isEmpty)\n          \
    \  return List()\n        val l1set = l1.toSet\n        val l2set = l2.toSet\n\
    \        val lcommon = l1set.intersect(l2set)\n        lcommon.toList.sorted",
  "        // Assume that the list is sorted.\n        var result = List[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (i < l1.length && j < l2.length)\
    \ {\n            if (l1(i) == l2(j)) {\n                result = l1(i) :: result\n\
    \                i += 1\n                j += 1\n            } else if (l1(i)\
    \ < l2(j)) {\n                i += 1\n            } else {\n                j\
    \ += 1\n            }\n        }\n        result.reverse", '        return l1.filter(l2.contains(_)).distinct.sorted',
  "        var set = new HashSet[Long]\n        for (i <- l1) {\n            set +=\
    \ i\n        }\n        var result = new ListBuffer[Long]\n        for (i <- l2)\
    \ {\n            if (set.contains(i)) {\n                result += i\n       \
    \     }\n        }\n        result.toList.sorted", "        val m1 = Map[Long,\
    \ Long]()\n        for (i <- l1) {\n            m1(i) = 1\n        }\n       \
    \ val m2 = Map[Long, Long]()\n        for (i <- l2) {\n            m2(i) = 1\n\
    \        }\n        val m = Map[Long, Long]()\n        for (i <- m1.keys) {\n\
    \            if (m2.contains(i)) {\n                m(i) = 1\n            }\n\
    \        }\n        return m.keys.toList.sorted", "        if (l1.length == 0\
    \ || l2.length == 0) return List()\n        var i = 0\n        var j = 0\n   \
    \     var l = List[Long]()\n        while (i < l1.length && j < l2.length) {\n\
    \            if (l1(i) == l2(j)) {\n                l = l :+ l1(i)\n         \
    \       i += 1\n                j += 1\n            } else if (l1(i) < l2(j))\
    \ {\n                i += 1\n            } else {\n                j += 1\n  \
    \          }\n        }\n        return l", "        val set1 = HashSet[Long]()\
    \ ++ l1\n        val set2 = HashSet[Long]() ++ l2\n        (set1 & set2).toList.sorted",
  '        l1.toSet.intersect(l2.toSet).toList.sorted', '        return l1.intersect(l2).sorted',
  '        return (l1 ::: l2).distinct.sorted.reverse', "        // Your answer here.\n\
    \        // return 0l.toLong\n        l1.intersect(l2).sorted", '        l1.filter(x
    => l2.contains(x)).distinct.sorted', '        l1.intersect(l2).sorted', '        l1.intersect(l2).distinct.sorted',
  '        (l1 & l2).toList.sorted', "        // >>> common((List[Long](1l.toLong,\
    \ 2l.toLong, 5l.toLong)), (List[Long](2l.toLong, 5l.toLong, 3l.toLong)))\n   \
    \     // (List[Long](2l.toLong, 5l.toLong))\n        // >>> common((List[Long](1l.toLong,\
    \ 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong,\
    \ 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong)))\n  \
    \      // (List[Long](1l.toLong, 5l.toLong, 653l.toLong))\n        // >>> common((List[Long](5l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))\n   \
    \     // (List[Long](2l.toLong, 3l.toLong))\n        def func(l1 : List[Long],\
    \ l2 : List[Long], acc : List[Long]) : List[Long] = {\n            if (l1.isEmpty\
    \ || l2.isEmpty) acc\n            else {\n                val (common, newAcc)\
    \ = (\n                    if (l1.head == l2.head) (l1.head, acc :+ l1.head)\n\
    \                    else (0l, acc)\n                )\n                if (common\
    \ == 0l) {\n                    if (l1.head < l2.head) func(l1.tail, l2, newAcc)\n\
    \                    else func(l1, l2.tail, newAcc)\n                }\n     \
    \           else {\n                    func(l1.tail, l2.tail, newAcc)\n     \
    \           }\n            }\n        }\n        func(l1.sorted, l2.sorted, List())",
  "        val hs = HashSet.empty[Long]\n        val hs2 = HashSet.empty[Long]\n \
    \       l1.foreach(i => hs.add(i))\n        l2.foreach(i => if (hs.contains(i))\
    \ hs2.add(i))\n        hs2.toList.sorted"]
stop_tokens:
- "\n    }\n"
