name: HumanEval_61_correct_bracketing
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // brackets is a string of \"(\" and \")\".\n    // return true if every opening\
  \ bracket has a corresponding closing bracket.\n    // >>> correctBracketing((\"\
  (\"))\n    // (false)\n    // >>> correctBracketing((\"()\"))\n    // (true)\n \
  \   // >>> correctBracketing((\"(()())\"))\n    // (true)\n    // >>> correctBracketing((\"\
  )(()\"))\n    // (false)\n    def correctBracketing(brackets : String) : Boolean\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(correctBracketing((\"\
  ()\")) == (true));\n    assert(correctBracketing((\"(()())\")) == (true));\n   \
  \ assert(correctBracketing((\"()()(()())()\")) == (true));\n    assert(correctBracketing((\"\
  ()()((()()())())(()()(()))\")) == (true));\n    assert(correctBracketing((\"((()())))\"\
  )) == (false));\n    assert(correctBracketing((\")(()\")) == (false));\n    assert(correctBracketing((\"\
  (\")) == (false));\n    assert(correctBracketing((\"((((\")) == (false));\n    assert(correctBracketing((\"\
  )\")) == (false));\n    assert(correctBracketing((\"(()\")) == (false));\n    assert(correctBracketing((\"\
  ()()(()())())(()\")) == (false));\n    assert(correctBracketing((\"()()(()())()))()\"\
  )) == (false));\n    }\n\n}\n"
completions: ["        var count = 0\n        for (c <- brackets) {\n            if\
    \ (c == '(') {\n                count += 1\n            } else if (c == ')') {\n\
    \                count -= 1\n            }\n            if (count < 0) return\
    \ false\n        }\n        return count == 0", "        var curr = 0\n      \
    \  for (c <- brackets) {\n            if (c == '(') curr += 1\n            else\
    \ curr -= 1\n            if (curr < 0) return false\n        }\n        return\
    \ curr == 0", "        var stack = 0\n        brackets.foreach(c => {\n      \
    \      if (c == '(') stack += 1\n            else if (c == ')') stack -= 1\n \
    \           if (stack < 0) return false\n        })\n        stack == 0", "  \
    \      if (brackets.length == 0) return true\n        if (brackets.length == 1)\
    \ return false\n        var stack = new Stack[Char]\n        for (c <- brackets)\
    \ {\n            if (c == '(') stack.push(c)\n            else if (c == ')') {\n\
    \                if (stack.length == 0) return false\n                stack.pop\n\
    \            }\n        }\n        return stack.length == 0", "        if (brackets.length\
    \ % 2 == 1) return false\n        var stack = new Stack[Char]\n        for (c\
    \ <- brackets) c match {\n            case '(' => stack.push(c)\n            case\
    \ ')' => if (stack.isEmpty || stack.pop != '(') return false\n        }\n    \
    \    stack.isEmpty", "        brackets.foldLeft((0, true))((t, e) => {\n     \
    \       val (p, r) = t\n            if (e == '(')\n                (p + 1, r)\n\
    \            else if (e == ')') {\n                if (p == 0)\n             \
    \       (p, false)\n                else\n                    (p - 1, r)\n   \
    \         }\n            else\n                (p, r)\n        })._2", "     \
    \   val openBrackets = ListBuffer.empty[Int]\n        for (i <- 0 until brackets.length)\
    \ {\n            brackets(i) match {\n                case '(' => openBrackets\
    \ += i\n                case ')' => if (openBrackets.isEmpty) return false else\
    \ openBrackets.remove(openBrackets.length - 1)\n            }\n        }\n   \
    \     return openBrackets.isEmpty", "        var stack = Stack[Char]()\n     \
    \   for (c <- brackets) {\n            if (c == '(') {\n                stack.push(c)\n\
    \            } else if (c == ')') {\n                if (stack.size == 0) {\n\
    \                    return false\n                } else {\n                \
    \    stack.pop\n                }\n            }\n        }\n        return stack.size\
    \ == 0", "        var stack = new Stack[Char]\n        for (bracket <- brackets)\
    \ {\n            if (bracket == '(') stack.push(bracket)\n            else if\
    \ (bracket == ')') {\n                if (stack.isEmpty) return false\n      \
    \          stack.pop\n            }\n        }\n        stack.isEmpty", "    \
    \    var count = 0\n        for (c <- brackets) {\n            if (c == '(') count\
    \ += 1\n            else if (c == ')') count -= 1\n            if (count < 0)\
    \ return false\n        }\n        return count == 0", "        val stack = Stack[Char]()\n\
    \        for (c <- brackets) {\n            if (c == '(') stack.push(c)\n    \
    \        else if (c == ')') {\n                if (stack.isEmpty) return false\n\
    \                else stack.pop\n            }\n        }\n        stack.isEmpty",
  "        // if we have an opening bracket, search for a closing bracket.\n     \
    \   // if we don't find one, return false.\n        var count = 0\n        for\
    \ (bracket <- brackets) {\n            if (bracket == '(') {\n               \
    \ count += 1\n            } else if (bracket == ')') {\n                count\
    \ -= 1\n            }\n            if (count < 0) {\n                return false\n\
    \            }\n        }\n        // check that we have no remaining opening\
    \ brackets.\n        if (count == 0) {\n            return true\n        } else\
    \ {\n            return false\n        }", "        var stack = new Stack[Char]()\n\
    \        for (bracket <- brackets) {\n            if (bracket == '(') {\n    \
    \            stack.push(bracket)\n            } else if (bracket == ')') {\n \
    \               if (stack.isEmpty) return false\n                stack.pop\n \
    \           }\n        }\n        stack.isEmpty", "        var level = 0\n   \
    \     brackets.foreach(c => {\n            if (c == '(') level += 1\n        \
    \    else level -= 1\n            if (level < 0) return false\n        })\n  \
    \      return level == 0", "        var count = 0\n        for (i <- 0 until brackets.length)\
    \ {\n            val c = brackets(i)\n            if (c == '(') count += 1\n \
    \           else if (c == ')') count -= 1\n            if (count < 0) return false\n\
    \        }\n        count == 0", "      var numOpen : Int = 0\n      for (c <-\
    \ brackets) {\n        c match {\n          case '(' => numOpen += 1\n       \
    \   case ')' => numOpen -= 1\n        }\n        if (numOpen < 0) return false\n\
    \      }\n      return numOpen == 0", "        if (brackets.length == 0) return\
    \ true\n        if (brackets.length == 1) return false\n        var stack = Stack[Char]()\n\
    \        for (c <- brackets) {\n            if (c == '(') stack.push(c)\n    \
    \        else if (c == ')') {\n                if (stack.isEmpty) return false\n\
    \                else stack.pop\n            }\n        }\n        if (stack.isEmpty)\
    \ true else false", "        var open : Int = 0\n        for (i <- 0 until brackets.length)\
    \ {\n            brackets(i) match {\n                case '(' => open += 1\n\
    \                case ')' => open -= 1\n            }\n            if (open <\
    \ 0) return false\n        }\n        return open == 0", "        val stack =\
    \ new Stack[Char]\n        for (c <- brackets) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return false\n\
    \                stack.pop\n            }\n        }\n        return stack.isEmpty",
  "        var opener = 0\n        for (c <- brackets) {\n            if (c == '(')\
    \ opener += 1\n            else opener -= 1\n            if (opener < 0) return\
    \ false\n        }\n        return opener == 0", "        var count = 0\n    \
    \    for (ch <- brackets) {\n            if (ch == '(') count += 1\n         \
    \   else if (ch == ')') count -= 1\n            if (count < 0) return false\n\
    \        }\n        count == 0", "        var stack = new Stack[Char]\n      \
    \  for (i <- 0 until brackets.length) {\n            val c = brackets(i)\n   \
    \         if (c == '(') {\n                stack.push(c)\n            } else if\
    \ (c == ')') {\n                if (stack.isEmpty) {\n                    return\
    \ false\n                } else {\n                    stack.pop\n           \
    \     }\n            }\n        }\n        return stack.isEmpty", "        var\
    \ stack = new Stack[Char]\n        brackets.foreach(c => if (c == '(') stack.push(c)\
    \ else if (stack.isEmpty || stack.pop != '(') return false)\n        stack.isEmpty",
  "        val stack = new Stack[Char]\n        for (c <- brackets) {\n          \
    \  if (c == '(') stack.push(c)\n            else if (c == ')') {\n           \
    \     if (stack.isEmpty) return false\n                stack.pop\n           \
    \ }\n        }\n        return stack.isEmpty", "        val stack = new Stack[Char]\n\
    \        for (bracket <- brackets) {\n            if (bracket == '(') stack.push(bracket)\n\
    \            else if (bracket == ')') {\n                if (stack.isEmpty) return\
    \ false\n                stack.pop\n            }\n        }\n        stack.isEmpty",
  "        var stack = 0\n        for (char <- brackets) {\n            if (char ==\
    \ '(') stack += 1\n            else if (char == ')') stack -= 1\n            if\
    \ (stack < 0) return false\n        }\n        return stack == 0", "        def\
    \ correctBracketing(stack : List[Char], remaining : List[Char]) : Boolean = {\n\
    \            if (remaining.isEmpty) stack.isEmpty\n            else if (remaining.head\
    \ == '(') correctBracketing(remaining.head :: stack, remaining.tail)\n       \
    \     else if (stack.isEmpty) false\n            else correctBracketing(stack.tail,\
    \ remaining.tail)\n        }\n        correctBracketing(List(), brackets.toList)",
  "        var open : Int = 0\n        for (i <- 0 until brackets.length) {\n    \
    \        if (brackets(i) == '(') open += 1\n            else open -= 1\n     \
    \       if (open < 0) return false\n        }\n        open == 0", "        var\
    \ stack = Stack[Char]()\n        for (ch <- brackets) {\n            if (ch ==\
    \ '(') stack.push(ch)\n            else if (ch == ')') {\n                if (stack.isEmpty)\
    \ return false\n                stack.pop\n            }\n        }\n        return\
    \ stack.isEmpty", "      var count : Int = 0\n      for (b <- brackets) {\n  \
    \      if (b == '(') count += 1\n        else if (b == ')') count -= 1\n     \
    \   if (count < 0) return false\n      }\n      return count == 0", "        var\
    \ count = 0\n        for (c <- brackets) {\n            if (c == '(') count +=\
    \ 1\n            else if (c == ')') count -= 1\n            if (count < 0) return\
    \ false\n        }\n        count == 0", "      // We will use a stack of bools.\n\
    \      // False is a left bracket.\n      // True is a right bracket.\n      val\
    \ stack = new scala.collection.mutable.Stack[Boolean]()\n      for (i <- 0 until\
    \ brackets.length) {\n        brackets(i) match {\n          case '(' => stack.push(false)\n\
    \          case ')' => stack.push(true)\n        }\n      }\n      while (!stack.isEmpty)\
    \ {\n        val bracket1 = stack.pop()\n        if (stack.isEmpty) return false\n\
    \        val bracket2 = stack.pop()\n        if (bracket1 == bracket2) return\
    \ false\n      }\n      return true", "        var count = 0\n        for (c <-\
    \ brackets) {\n            if (c == '(') {\n                count += 1\n     \
    \       } else if (c == ')') {\n                count -= 1\n            }\n  \
    \          if (count < 0) return false\n        }\n        count == 0", "    \
    \    var stack = new Stack[Char]()\n        for (c <- brackets) {\n          \
    \  if (c == '(') stack.push(c)\n            else if (c == ')') {\n           \
    \     if (stack.isEmpty) return false\n                else stack.pop\n      \
    \      }\n        }\n        stack.isEmpty", "        var open = 0\n        for\
    \ (i <- 0 until brackets.length) {\n            if (brackets(i) == '(') {\n  \
    \              open += 1\n            } else {\n                open -= 1\n  \
    \              if (open < 0) {\n                    return false\n           \
    \     }\n            }\n        }\n        return open == 0", "        brackets.foldLeft(0)\
    \ {\n            case (open, '(') => open + 1\n            case (open, ')') =>\
    \ if (open > 0) open - 1 else open\n            case (open, _) => open\n     \
    \   } == 0", "        if (brackets.length % 2 == 1) return false\n        if (brackets.head\
    \ == ')') return false\n        if (brackets.last == '(') return false\n     \
    \   var (unmatched, i) = (0, 0)\n        for (c <- brackets) {\n            if\
    \ (c == '(') unmatched += 1\n            else unmatched -= 1\n            if (unmatched\
    \ < 0) return false\n        }\n        if (unmatched == 0) return true\n    \
    \    else return false", "        var stack = Stack[Char]()\n        brackets.foreach(c\
    \ => {\n        \tif (c == '(') stack.push(c)\n        \telse if (c == ')') {\n\
    \        \t    if (stack.size == 0) return false\n        \t    else stack.pop\n\
    \        \t}\n        })\n        stack.size == 0", "        var l = List[Char]()\n\
    \        for (c <- brackets) {\n            if (c == '(') {\n                l\
    \ = c :: l\n            } else if (c == ')') {\n                if (l.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        l = l.tail\n                }\n            }\n        }\n        l.isEmpty",
  "        var stack = new Stack[Char]\n        for (ch <- brackets) {\n         \
    \   if (ch == '(') {\n                stack.push(ch)\n            } else if (ch\
    \ == ')') {\n                if (stack.isEmpty) return false\n               \
    \ stack.pop\n            }\n        }\n        stack.isEmpty", "        var stack\
    \ = new Stack[String]()\n        for (bracket <- brackets) {\n            if (bracket\
    \ == '(') stack.push(\"(\")\n            else if (bracket == ')') {\n        \
    \        if (stack.isEmpty) return false\n                else stack.pop()\n \
    \           }\n        }\n        stack.isEmpty", "        val stack = new Stack[Char]\n\
    \        for (c <- brackets) {\n            if (c == '(') stack.push(c)\n    \
    \        else if (c == ')') {\n                if (stack.isEmpty) return false\n\
    \                else stack.pop\n            }\n        }\n        return stack.isEmpty",
  "        var stack = List[Char]()\n        brackets.foreach { c =>\n           \
    \ if (c == '(') {\n                stack = c :: stack\n            } else if (c\
    \ == ')') {\n                if (stack.isEmpty) return false\n               \
    \ stack = stack.tail\n            }\n        }\n        return stack.isEmpty",
  "        val opening = Stack[Char]()\n        for (c <- brackets) {\n          \
    \  if (c == '(') opening.push(c)\n            else if (opening.isEmpty) return\
    \ false\n            else opening.pop\n        }\n        return opening.isEmpty",
  "        var stack = new Stack[Int]()\n        for (i <- 0 until brackets.length)\
    \ {\n            if (brackets(i) == '(') stack.push(i)\n            else if (brackets(i)\
    \ == ')') {\n                if (stack.length == 0) return false\n           \
    \     else stack.pop()\n            }\n        }\n        return stack.length\
    \ == 0", "        brackets.toList.foldLeft(0)((balance, bracket) => if (bracket\
    \ == '(') balance + 1 else if (bracket == ')') balance - 1 else balance) == 0",
  "        var openCount = 0\n        for (bracket <- brackets) {\n            if\
    \ (bracket == '(') openCount += 1\n            else if (bracket == ')') openCount\
    \ -= 1\n            if (openCount < 0) return false\n        }\n        return\
    \ openCount == 0", "      var opened = 0\n      brackets.foreach(c => if (c ==\
    \ '(') opened += 1 else opened -= 1)\n      opened == 0", "        var stack =\
    \ new Stack[Char]\n        for (bracket <- brackets) {\n            if (bracket\
    \ == '(') {\n                stack.push(bracket)\n            } else if (bracket\
    \ == ')') {\n                if (stack.isEmpty) return false\n               \
    \ stack.pop\n            }\n        }\n        stack.isEmpty", "        val s\
    \ = new Stack[Char]\n        for (c <- brackets) {\n            if (c == '(')\
    \ s.push(c)\n            else if (c == ')') {\n                if (s.isEmpty)\
    \ return false\n                if (s.pop != '(') return false\n            }\n\
    \        }\n        s.isEmpty", "        var stack = new Stack[Char]\n       \
    \ for (c <- brackets) {\n            if (c == '(') stack.push(c)\n           \
    \ else if (c == ')') {\n                if (stack.isEmpty) return false\n    \
    \            else stack.pop\n            }\n        }\n        return stack.isEmpty",
  "        var count = 0\n        for (c <- brackets) {\n            if (c == '(')\
    \ count += 1\n            else if (c == ')') count -= 1\n            if (count\
    \ < 0) return false\n        }\n        count == 0", "        val balance = brackets.foldLeft(0)((acc,\
    \ c) => {\n            if (c == '(') acc + 1\n            else if (c == ')') acc\
    \ - 1\n            else acc\n        })\n        if (balance != 0) false\n   \
    \     else {\n            val invalid = brackets.take(brackets.length - 1).foldLeft(false)((acc,\
    \ c) => {\n                if (c == '(' && brackets(brackets.indexOf(c) + 1) ==\
    \ ')') acc || true\n                else acc || false\n            })\n      \
    \      !invalid\n        }", "      var l = 0\n      var r = 0\n      for (ch\
    \ <- brackets) {\n        if (ch == '(') l += 1\n        else r += 1\n       \
    \ if (r > l) return false\n      }\n      return l == r", "        var closeCount\
    \ = 0\n        for (open <- brackets) {\n            if (open == '(') closeCount\
    \ += 1\n            else if (open == ')') closeCount -= 1\n            if (closeCount\
    \ < 0) return false\n        }\n        return closeCount == 0", "        brackets.count(_\
    \ == '(') == brackets.count(_ == ')')", "        def isOK(brackets : String, count\
    \ : Int) : Boolean = {\n            if (count < 0)\n                false\n  \
    \          else if (brackets.isEmpty)\n                count == 0\n          \
    \  else if (brackets.head == '(')\n                isOK(brackets.tail, count +\
    \ 1)\n            else if (brackets.head == ')')\n                isOK(brackets.tail,\
    \ count - 1)\n            else\n                false\n        }\n        isOK(brackets,\
    \ 0)", "        def countBrackets(brackets : String) : Int = {\n            if\
    \ (brackets.length == 0) 0\n            else if (brackets.charAt(0) == '(') 1\
    \ + countBrackets(brackets.substring(1))\n            else if (brackets.charAt(0)\
    \ == ')') -1 + countBrackets(brackets.substring(1))\n            else countBrackets(brackets.substring(1))\n\
    \        }\n        countBrackets(brackets) == 0", "        var stack = List[Char]()\n\
    \        for (c <- brackets) {\n            if (c == '(') {\n                stack\
    \ = c :: stack\n            } else if (c == ')') {\n                if (stack.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        stack = stack.tail\n                }\n            }\n        }\n   \
    \     stack.isEmpty", "        var count = 0\n        for (c <- brackets) {\n\
    \            if (c == '(') count += 1\n            else if (c == ')') count -=\
    \ 1\n            if (count < 0) return false\n        }\n        return count\
    \ == 0", "      val n = brackets.length\n      var opening = 0\n      for (i <-\
    \ 0 until n) {\n        brackets(i) match {\n          case '(' => opening +=\
    \ 1\n          case ')' => opening -= 1\n          case _ =>\n        }\n    \
    \    if (opening < 0) return false\n      }\n      opening == 0", "        var\
    \ stack = new Stack[Char]()\n        for (ch <- brackets) {\n            if (ch\
    \ == '(') stack.push(ch)\n            else if (ch == ')') {\n                if\
    \ (stack.isEmpty) return false\n                else stack.pop\n            }\n\
    \        }\n        return stack.isEmpty", "        if (brackets.length == 0)\
    \ true\n        else if (brackets.charAt(0) == ')') false\n        else {\n  \
    \          var b : Array[Char] = brackets.toCharArray\n            var count :\
    \ Int = 0\n            for (i <- 0 until b.length) {\n                if (b(i)\
    \ == '(') count += 1\n                else if (b(i) == ')') count -= 1\n     \
    \           if (count < 0) return false\n            }\n            count == 0\n\
    \        }", "        var prev = ' '\n        var bracketStack = Stack[Char]()\n\
    \        for (c <- brackets) {\n            if (c == '(') {\n                bracketStack.push(c)\n\
    \            } else if (c == ')') {\n                if (bracketStack.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        bracketStack.pop\n                }\n            }\n        }\n     \
    \   return bracketStack.isEmpty", "        val stack = Stack[Char]()\n       \
    \ brackets.foreach(c => {\n            if (c == '(') stack.push(c)\n         \
    \   else if (c == ')') {\n                if (stack.isEmpty) return false\n  \
    \              stack.pop\n            }\n        })\n        return stack.isEmpty",
  "        var bb = brackets\n        //print(brackets)\n        var count = 0\n \
    \       for (i <- 0 until brackets.length()) {\n            if (brackets(i) ==\
    \ '(') count += 1\n            else if (brackets(i) == ')') count -= 1\n     \
    \       if (count < 0) return false\n        }\n        count == 0", "       \
    \ val stack = new scala.collection.mutable.Stack[Char]()\n        for (c <- brackets)\
    \ {\n            if (c == '(') stack.push(c)\n            else if (c == ')') if\
    \ (stack.isEmpty) return false else stack.pop\n        }\n        return stack.isEmpty",
  "        var count = 0\n        for (bracket <- brackets) {\n            if (bracket\
    \ == '(') count += 1\n            else if (bracket == ')') count -= 1\n      \
    \      if (count < 0) return false\n        }\n        return count == 0", " \
    \       var count = 0\n        for (bracket <- brackets) {\n            if (bracket\
    \ == '(') {\n                count += 1\n            } else if (bracket == ')')\
    \ {\n                count -= 1\n            }\n            if (count < 0) {\n\
    \                return false\n            }\n        }\n        return count\
    \ == 0", "        var opened = 0\n        for (c <- brackets) {\n            if\
    \ (c == '(') opened += 1\n            else if (c == ')') opened -= 1\n       \
    \     if (opened < 0) return false\n        }\n        opened == 0", "       \
    \ var count = 0\n        for (bracket <- brackets) {\n            if (bracket\
    \ == '(') count += 1\n            else if (bracket == ')') count -= 1\n      \
    \      if (count < 0) return false\n        }\n        return count == 0", " \
    \     var stack = new Stack[Char]\n      for (b <- brackets) {\n        if (b\
    \ == '(') {\n          stack.push(b)\n        } else if (b == ')') {\n       \
    \   if (stack.size == 0) return false\n          stack.pop\n        }\n      }\n\
    \      return stack.size == 0", "        var counter = 0\n        for (i <- 0\
    \ until brackets.length) {\n            if (brackets(i) == '(') counter += 1\n\
    \            else counter -= 1\n            if (counter < 0) return false\n  \
    \      }\n        return counter == 0", "        var count = 0\n        for (x\
    \ <- brackets) {\n            if (x == '(') {\n                count += 1\n  \
    \          } else if (x == ')') {\n                count -= 1\n            }\n\
    \            if (count < 0) {\n                return false\n            }\n \
    \       }\n        if (count == 0) true else false", "        var stack = new\
    \ Stack[Char]\n        for (bracket <- brackets) {\n            if (bracket ==\
    \ '(') {\n                stack.push(bracket)\n            } else if (bracket\
    \ == ')') {\n                if (stack.isEmpty) {\n                    return\
    \ false\n                } else {\n                    stack.pop\n           \
    \     }\n            }\n        }\n        stack.isEmpty", "        var numOpenBrackets\
    \ = 0\n        for (c <- brackets) {\n            if (c == '(') numOpenBrackets\
    \ += 1\n            else if (c == ')') numOpenBrackets -= 1\n            if (numOpenBrackets\
    \ < 0) return false\n        }\n        return numOpenBrackets == 0", "      \
    \  var stack = new Stack[Char]\n        for (c <- brackets) {\n            if\
    \ (c == '(') stack.push(c)\n            else if (c == ')') {\n               \
    \ if (stack.isEmpty) return false\n                stack.pop\n            }\n\
    \        }\n        stack.isEmpty", "        //>>> correctBracketing((\")(()\"\
    ))\n        //false\n        //>>> correctBracketing((\"(()())\"))\n        //true\n\
    \        var numBrackets = 0\n        for (bracket <- brackets) {\n          \
    \  bracket match {\n                case '(' => numBrackets += 1\n           \
    \     case ')' => numBrackets -= 1\n            }\n            if (numBrackets\
    \ < 0) return false\n        }\n        return numBrackets == 0", "        var\
    \ opened = 0\n        for (bracket <- brackets) {\n            bracket match {\n\
    \                case '(' => opened += 1\n                case ')' => opened -=\
    \ 1\n            }\n            if (opened < 0) return false\n        }\n    \
    \    return opened == 0", "\tvar stack = new Stack[Char]\n\tfor (c <- brackets)\
    \ {\n\t    if (c == '(') {\n\t\tstack.push(c)\n\t    } else if (c == ')') {\n\t\
    \tif (stack.isEmpty) return false\n\t\tstack.pop\n\t    }\n\t}\n\treturn stack.isEmpty",
  "        val stack = new Stack[Char]\n        var remainingBrackets = brackets\n\
    \        while (!remainingBrackets.isEmpty) {\n            val head = remainingBrackets.head\n\
    \            remainingBrackets = remainingBrackets.tail\n            if (head\
    \ == '(') stack.push(head)\n            else if (head == ')') {\n            \
    \    if (stack.isEmpty) return false\n                else stack.pop\n       \
    \     }\n        }\n        stack.isEmpty", "        var open = 0\n        for\
    \ (i <- 0 until brackets.length) {\n            brackets(i) match {\n        \
    \        case '(' => open += 1\n                case ')' => open -= 1\n      \
    \      }\n            if (open < 0) return false\n        }\n        open == 0",
  "        var cnt = 0\n        for (ch <- brackets) {\n            if (ch == '(')\
    \ cnt += 1\n            else if (ch == ')') cnt -= 1\n            if (cnt < 0)\
    \ return false\n        }\n        cnt == 0", "        // 1. incorrect if no closing\
    \ bracket for an opening bracket\n        // 2. incorrect if closing bracket before\
    \ an opening bracket\n        val check = (pairs : Array[(Char, Int)]) => {\n\
    \            val arr = Array.fill(pairs.length)(0)\n            for (i <- 0 until\
    \ pairs.length) {\n                if (pairs(i)._1 == '(') arr(i) = 1\n      \
    \          else arr(i) = -1\n            }\n            for (i <- 1 until pairs.length)\
    \ arr(i) += arr(i - 1)\n            arr.forall(_ >= 0)\n        }\n        val\
    \ openingBrackets = brackets.zipWithIndex.filter(_._1 == '(')\n        val closingBrackets\
    \ = brackets.zipWithIndex.filter(_._1 == ')')\n        if (openingBrackets.length\
    \ != closingBrackets.length) return false\n        val pairs = (openingBrackets\
    \ ++ closingBrackets).sortBy(_._2)\n        check(pairs)", "        var stack\
    \ = new Stack[Char]()\n        for (c <- brackets) {\n            if (c == '(')\
    \ stack.push(c)\n            else if (c == ')') {\n                if (stack.size\
    \ == 0) return false\n                stack.pop\n            }\n        }\n  \
    \      stack.size == 0", "        val stack = ListBuffer[Char]()\n        for\
    \ (i <- 0 until brackets.length) {\n            if (brackets(i) == '(') stack\
    \ += '('\n            else if (stack.isEmpty) return false\n            else stack.remove(stack.length\
    \ - 1)\n        }\n        stack.isEmpty", "        val stack = new Stack[Char]\n\
    \        brackets.foreach(c => if (c == '(') stack.push(c) else if (stack.isEmpty\
    \ || stack.pop != '(') return false)\n        stack.isEmpty", "        var cnt\
    \ = 0\n        for (c <- brackets) {\n            if (c == '(') cnt += 1\n   \
    \         else if (c == ')') cnt -= 1\n            if (cnt < 0) return false\n\
    \        }\n        cnt == 0", "        var open = 0\n        for (b <- brackets)\
    \ {\n            if (b == '(') {\n                open += 1\n            } else\
    \ if (b == ')') {\n                open -= 1\n            }\n            if (open\
    \ < 0) return false\n        }\n        return open == 0", "        var stack\
    \ = new Stack[Char]()\n        for (c <- brackets) {\n            if (c == '(')\
    \ stack.push(c)\n            else if (c == ')') if (stack.size == 0) return false\
    \ else stack.pop()\n        }\n        return stack.size == 0", "        val stack\
    \ = Stack[Char]()\n        for (ch <- brackets) {\n            if (ch == '(')\
    \ {\n                stack.push(ch)\n            } else if (ch == ')') {\n   \
    \             if (stack.isEmpty) {\n                    return false\n       \
    \         } else {\n                    stack.pop\n                }\n       \
    \     }\n        }\n        stack.isEmpty", "        val bracketStack = Stack[Char]()\n\
    \        for (bracket <- brackets) {\n            if (bracket == '(') bracketStack.push(bracket)\n\
    \            else if (bracket == ')') {\n                if (bracketStack.isEmpty)\
    \ return false\n                else bracketStack.pop\n            }\n       \
    \ }\n        return bracketStack.isEmpty", "        var stack = new Stack[Char]\n\
    \        for (c <- brackets) c match {\n            case '(' => stack.push(c)\n\
    \            case ')' => {\n                if (stack.isEmpty) return false\n\
    \                stack.pop\n            }\n        }\n        stack.isEmpty",
  "        var sum = 0\n        for (ch <- brackets) {\n            if (ch == '(')\
    \ sum += 1\n            else if (ch == ')') sum -= 1\n            if (sum < 0)\
    \ return false\n        }\n        return sum == 0", "      var count = 0\n  \
    \    for (i <- 0 until brackets.length) {\n        brackets(i) match {\n     \
    \     case '(' => count += 1\n          case ')' => count -= 1\n        }\n  \
    \      if (count < 0) return false\n      }\n      count == 0", "      var result\
    \ = true\n      var openCount = 0\n      for (c <- brackets) {\n        if (c\
    \ == '(') openCount += 1\n        else if (c == ')') openCount -= 1\n        if\
    \ (openCount < 0) {\n          result = false\n          return result\n     \
    \   }\n      }\n      if (openCount > 0) result = false\n      result", "    \
    \    // FIXME\n        true", "        var stack = Stack[Char]()\n        for\
    \ (i <- 0 until brackets.length) {\n            val ch = brackets(i)\n       \
    \     if (ch == '(') stack.push(ch)\n            else if (ch == ')') {\n     \
    \           if (stack.isEmpty) return false\n                else stack.pop\n\
    \            }\n        }\n        stack.isEmpty", "        val stack = new Stack[Char]\n\
    \        var matched = true\n        var index = 0\n        while (index < brackets.length\
    \ && matched) {\n            val symbol = brackets(index)\n            if (symbol\
    \ == '(') stack.push(symbol)\n            else {\n                if (stack.isEmpty)\
    \ matched = false\n                else stack.pop\n            }\n           \
    \ index += 1\n        }\n        matched && stack.isEmpty", "        if (brackets.isEmpty)\
    \ true\n        else {\n            val c = brackets.head\n            if (c ==\
    \ '(') {\n                val index = brackets.indexOf(')')\n                if\
    \ (index != -1) correctBracketing(brackets.substring(index + 1))\n           \
    \     else false\n            }\n            else false\n        }", "       \
    \ val stack = new Stack[Char]\n        for (char <- brackets) {\n            if\
    \ (char == '(') {\n                stack.push(char)\n            } else if (char\
    \ == ')') {\n                if (stack.size == 0) return false\n             \
    \   stack.pop\n            }\n        }\n        stack.size == 0", "        var\
    \ c = 0\n        for (x <- brackets) {\n            if (x == '(') c += 1\n   \
    \         else if (x == ')') c -= 1\n            if (c < 0) return false\n   \
    \     }\n        c == 0", "        if (brackets.length == 0)\n            return\
    \ true\n        var open : Int = 0\n        for (c <- brackets) {\n          \
    \  if (c == '(')\n                open += 1\n            else if (c == ')')\n\
    \                open -= 1\n            if (open < 0)\n                return\
    \ false\n        }\n        return open == 0", "        def check(s : String,\
    \ i : Int) : Boolean = {\n            if (i >= s.length) true\n            else\
    \ {\n                if (s(i) == '(') check(s, i + 1)\n                else if\
    \ (s(i) == ')') {\n                    if (i == 0) false\n                   \
    \ else if (s(i - 1) == '(') check(s.substring(0, i - 1) + s.substring(i + 1),\
    \ i - 1)\n                    else false\n                }\n                else\
    \ check(s, i + 1)\n            }\n        }\n        check(brackets, 0)", "  \
    \      val stack = Stack[Char]()\n        for (c <- brackets) {\n            if\
    \ (c == '(') {\n                stack.push(c)\n            } else if (c == ')')\
    \ {\n                if (stack.isEmpty) {\n                    return false\n\
    \                } else {\n                    stack.pop\n                }\n\
    \            }\n        }\n        return stack.isEmpty", "        val numOpenBrackets\
    \ = brackets.filter(c => c == '(').length\n        val numCloseBrackets = brackets.filter(c\
    \ => c == ')').length\n        val numExtraBrackets = numOpenBrackets - numCloseBrackets\n\
    \        val numBracketsToRemove = max(0, -1 * numExtraBrackets)\n        val\
    \ bracketsToUse = brackets.substring(numBracketsToRemove, brackets.length - numBracketsToRemove)\n\
    \        val stack = new Stack[Char]\n        for (c <- bracketsToUse) {\n   \
    \         if (c == '(') {\n                stack.push(c)\n            } else {\n\
    \                if (stack.isEmpty) {\n                    return false\n    \
    \            } else {\n                    stack.pop\n                }\n    \
    \        }\n        }\n        return stack.isEmpty", "        var count = 0\n\
    \        for (ch <- brackets) {\n            if (ch == '(') count += 1\n     \
    \       else if (ch == ')') count -= 1\n            if (count < 0) return false\n\
    \        }\n        return count == 0", "\tvar stack = new Stack[Char]\n\tfor\
    \ (c <- brackets) {\n\t    if (c == '(') stack.push(c)\n\t    else if (c == ')')\
    \ {\n\t\tif (stack.isEmpty) return false\n\t\tstack.pop\n\t    }\n\t}\n\tstack.isEmpty",
  "        var toVisit = new Stack[Char]()\n        brackets.foreach(c => {\n    \
    \        if (c == '(') {\n                toVisit.push(c)\n            } else\
    \ if (c == ')') {\n                if (toVisit.isEmpty) return false\n       \
    \         else toVisit.pop()\n            }\n        })\n        toVisit.isEmpty",
  "        val stack = new Stack[Char]\n        for (c <- brackets) {\n          \
    \  if (c == '(') {\n                stack.push(c)\n            } else if (c ==\
    \ ')') {\n                if (stack.isEmpty) {\n                    return false\n\
    \                } else {\n                    stack.pop\n                }\n\
    \            }\n        }\n        return stack.isEmpty", "\t\tval stack = new\
    \ Stack[Char]\n\t\tfor (i <- 0 until brackets.length) {\n\t\t\tval c = brackets(i)\n\
    \t\t\tif (c == '(') stack.push(c)\n\t\t\telse if (c == ')') {\n\t\t\t\tif (stack.isEmpty)\
    \ return false\n\t\t\t\tstack.pop\n\t\t\t}\n\t\t}\n\t\tstack.isEmpty", "     \
    \   var stack = new Stack[Char]\n        for (c <- brackets) {\n            if\
    \ (c == '(') stack.push(c)\n            else if (c == ')') if (stack.isEmpty)\
    \ return false else stack.pop\n        }\n        return stack.isEmpty", "   \
    \     def correctBracketing(brackets : String, depth : Int) : Boolean = {\n  \
    \          if (depth < 0) return false\n            if (brackets.length == 0)\
    \ return depth == 0\n            if (brackets.head == '(') return correctBracketing(brackets.tail,\
    \ depth + 1)\n            else return correctBracketing(brackets.tail, depth -\
    \ 1)\n        }\n        correctBracketing(brackets, 0)", "\tvar opening = 0\n\
    \tfor (i <- 0 until brackets.length) {\n\t    val c = brackets(i)\n\t    if (c\
    \ == '(') opening += 1\n\t    else if (c == ')') opening -= 1\n\t    if (opening\
    \ < 0) return false\n\t}\n\topening == 0", "        var index = 0\n        for\
    \ (bracket <- brackets) {\n            if (bracket == '(') {\n               \
    \ index += 1\n            } else if (bracket == ')') {\n                index\
    \ -= 1\n            }\n            if (index < 0) {\n                return false\n\
    \            }\n        }\n        return index == 0", "        var left = 0\n\
    \        var right = 0\n        for (char <- brackets) {\n            if (char\
    \ == '(') left += 1\n            else if (char == ')') right += 1\n          \
    \  if (right > left) return false\n        }\n        return left == right", " \
    \       var count = 0\n        for (char <- brackets) {\n            if (char\
    \ == '(') {\n                count += 1\n            } else if (char == ')') {\n\
    \                count -= 1\n            }\n            if (count < 0) {\n   \
    \             return false\n            }\n        }\n        return count ==\
    \ 0", "      val stack = Stack[Char]()\n      brackets.foreach(b => {\n      \
    \  if (b == '(') {\n          stack.push(b)\n        } else {\n          if (stack.isEmpty)\
    \ return false\n          stack.pop\n        }\n      })\n      return stack.isEmpty",
  "        var stack = new ArrayBuffer[Char]()\n        for (c <- brackets) {\n  \
    \          if (c == '(') {\n                stack += c\n            } else if\
    \ (c == ')') {\n                if (stack.length == 0) {\n                   \
    \ return false\n                } else {\n                    stack.remove(stack.length\
    \ - 1)\n                }\n            }\n        }\n        return stack.length\
    \ == 0", "        val stack = ListBuffer[Char]()\n        for (c <- brackets)\
    \ {\n            if (c == '(') {\n                stack += c\n            } else\
    \ if (c == ')') {\n                if (stack.size == 0) return false\n       \
    \         stack.remove(stack.size - 1)\n            }\n        }\n        stack.size\
    \ == 0", '        // TODO: Write this function', "        var count = 0\n    \
    \    for (i <- 0 until brackets.length) {\n            if (brackets(i) == '(')\
    \ {\n                count += 1\n            } else {\n                count -=\
    \ 1\n            }\n            if (count < 0) {\n                return false\n\
    \            }\n        }\n        return count == 0", "        var stack = new\
    \ Stack[Char]\n        brackets.foreach(c => if (c == '(') stack.push(c) else\
    \ if (stack.isEmpty || stack.pop != '(') return false)\n        stack.isEmpty",
  "        var stack = new Stack[Char]()\n        for (bracket <- brackets) {\n  \
    \          if (bracket == '(') stack.push(bracket)\n            else if (bracket\
    \ == ')') {\n                if (stack.isEmpty) return false\n               \
    \ stack.pop\n            }\n        }\n        return stack.isEmpty", "      \
    \  val stack = new Stack[Char]\n        for (i <- 0 until brackets.length) {\n\
    \            val ch = brackets(i)\n            if (ch == '(') {\n            \
    \    stack.push(ch)\n            } else if (ch == ')') {\n                if (stack.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        stack.pop\n                }\n            }\n        }\n        return\
    \ stack.isEmpty", "        var stack = new Stack[Char]()\n        for (i <- 0\
    \ until brackets.length) {\n            if (brackets(i) == '(') {\n          \
    \      stack.push('(')\n            } else {\n                if (stack.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        stack.pop()\n                }\n            }\n        }\n        return\
    \ stack.isEmpty", "        val stack = new Stack[Char]\n        brackets.foreach(c\
    \ => {\n            if (c == '(') stack.push(c)\n            else if (c == ')')\
    \ {\n                if (stack.isEmpty) return false\n                stack.pop\n\
    \            }\n        })\n        stack.isEmpty", "        var sum = 0\n   \
    \     for (b <- brackets) b match {\n            case '(' => sum += 1\n      \
    \      case ')' => sum -= 1\n            case _ =>\n        }\n        sum ==\
    \ 0", "      var bracketCount = 0\n      for (bracket <- brackets) bracket match\
    \ {\n        case '(' => bracketCount += 1\n        case ')' => bracketCount -=\
    \ 1\n        case _ => ()\n      }\n      bracketCount == 0", "        brackets.count(_\
    \ == '(') == brackets.count(_ == ')')", "        var count = 0\n        for (char\
    \ <- brackets) if (char == '(') count += 1 else if (char == ')') count -= 1\n\
    \        return count == 0", "        val openings = 0\n        val closings =\
    \ 0\n        for (bracket <- brackets) {\n            if (bracket == '(') openings\
    \ += 1\n            else if (bracket == ')') closings += 1\n            if (closings\
    \ > openings) return false\n        }\n        openings == closings", "      \
    \  var depth = 0\n        for (bracket <- brackets) {\n            bracket match\
    \ {\n                case '(' => depth += 1\n                case ')' => depth\
    \ -= 1\n            }\n            if (depth < 0) {\n                return false\n\
    \            }\n        }\n        depth == 0", "        if (brackets.isEmpty)\
    \ return true\n        val b = new Stack[Char]\n        for (i <- 0 until brackets.length)\
    \ {\n            if (brackets(i) == '(') b.push('(')\n            else if (b.isEmpty)\
    \ return false\n            else b.pop\n        }\n        return b.isEmpty",
  "        var openBrackets = new ListBuffer[Char]()\n        for (c <- brackets)\
    \ {\n            if (c == '(') {\n                openBrackets += c\n        \
    \    } else if (c == ')') {\n                if (openBrackets.length == 0) {\n\
    \                    return false\n                } else {\n                \
    \    openBrackets.remove(openBrackets.length - 1)\n                }\n       \
    \     }\n        }\n        openBrackets.length == 0", "        val stack = new\
    \ Stack[Char]\n        for (c <- brackets) {\n            if (c == '(') stack.push(c)\n\
    \            else if (c == ')') {\n                if (stack.isEmpty) return false\n\
    \                else stack.pop\n            }\n        }\n        return stack.isEmpty",
  "        def go(depth : Int, brackets : List[Char]) : Boolean = brackets match {\n\
    \            case Nil => depth == 0\n            case h :: t => if (h == '(')\
    \ go(depth + 1, t) else if (depth > 0) go(depth - 1, t) else false\n        }\n\
    \        go(0, brackets.toList)", "        if (brackets.length % 2 == 1) {\n \
    \           return false\n        }\n        var stack = new Stack[Char]\n   \
    \     for (c <- brackets) {\n            if (c == '(') {\n                stack.push(c)\n\
    \            } else {\n                if (stack.isEmpty) {\n                \
    \    return false\n                }\n                if (stack.pop != '(') {\n\
    \                    return false\n                }\n            }\n        }\n\
    \        return stack.isEmpty", "        val stack = new Stack[Char]\n       \
    \ brackets.foreach(c => {\n            if (c == '(') stack.push(c)\n         \
    \   else if (c == ')') {\n                if (stack.isEmpty) return false\n  \
    \              stack.pop\n            }\n        })\n        stack.isEmpty", " \
    \       var stack = 0\n        for (c <- brackets) {\n            if (c == '(')\
    \ stack += 1\n            else if (c == ')') stack -= 1\n            if (stack\
    \ < 0) return false\n        }\n        return stack == 0", "        var leftBrackets\
    \ : Int = 0\n        for (bracket <- brackets) {\n            if (bracket == '(')\
    \ {\n                leftBrackets += 1\n            } else if (bracket == ')')\
    \ {\n                leftBrackets -= 1\n            }\n            if (leftBrackets\
    \ < 0) return false\n        }\n        return leftBrackets == 0", "        val\
    \ openBrackets = Stack[Char]()\n        var i = 0\n        while (i < brackets.length)\
    \ {\n            val bracket = brackets(i)\n            if (bracket == '(') {\n\
    \                openBrackets.push(bracket)\n            } else if (bracket ==\
    \ ')') {\n                if (openBrackets.isEmpty) return false\n           \
    \     openBrackets.pop\n            }\n            i += 1\n        }\n       \
    \ return openBrackets.isEmpty", "        var stack = new Stack[Char]\n       \
    \ for (c <- brackets) {\n            if (c == '(') stack.push(c)\n           \
    \ else if (c == ')') {\n                if (stack.isEmpty) return false\n    \
    \            else stack.pop\n            }\n        }\n        stack.isEmpty",
  "        var count = 0\n        for (bracket <- brackets) {\n            if (bracket\
    \ == '(') count += 1\n            else if (bracket == ')') count -= 1\n      \
    \      if (count < 0) return false\n        }\n        return count == 0", " \
    \       brackets.foldLeft((0, true))((a, b) => if (b == '(') (a._1 + 1, a._2)\
    \ else if (b == ')') (a._1 - 1, a._2 && a._1 > 0))._2", "        var leftBrackets\
    \ = 0\n        var rightBrackets = 0\n        for (c <- brackets) {\n        \
    \    if (c == '(') leftBrackets += 1\n            else rightBrackets += 1\n  \
    \          if (rightBrackets > leftBrackets) return false\n        }\n       \
    \ return rightBrackets == leftBrackets", "        var c = 0\n        for (b <-\
    \ brackets) {\n            b match {\n                case '(' => c += 1\n   \
    \             case ')' => c -= 1\n            }\n            if (c < 0) return\
    \ false\n        }\n        c == 0", "        var stack = new Stack[Char]\n  \
    \      for (c <- brackets) {\n            if (c == '(') stack.push(c)\n      \
    \      else if (c == ')') {\n                if (stack.isEmpty) return false\n\
    \                else stack.pop\n            }\n        }\n        stack.isEmpty",
  "        var closingBracketsToOpen : Int = 0\n        for (i <- 0 until brackets.length)\
    \ {\n            if (brackets(i) == '(') closingBracketsToOpen += 1\n        \
    \    else closingBracketsToOpen -= 1\n            if (closingBracketsToOpen <\
    \ 0) return false\n        }\n        return closingBracketsToOpen == 0", "  \
    \      // track whether you have seen a closing bracket before an opening bracket.\n\
    \        var seen_closing = false\n        // stack of opening brackets.\n   \
    \     var stack = new Stack[String]\n        // loop through all brackets.\n \
    \       brackets.foreach((c : Char) => {\n            // if its an opening bracket,\
    \ push it onto the stack.\n            if (c == '(') {\n                stack.push(\"\
    (\")\n            }\n            // if its a closing bracket, pop an opening bracket\
    \ off of the stack.\n            else if (c == ')') {\n                // if the\
    \ stack was empty, then you saw a closing bracket before an opening bracket.\n\
    \                if (stack.isEmpty) {\n                    seen_closing = true\n\
    \                }\n                // otherwise pop an opening bracket off of\
    \ the stack.\n                else {\n                    stack.pop\n        \
    \        }\n            }\n        })\n        // if you saw a closing bracket\
    \ before an opening bracket, return false.\n        if (seen_closing) {\n    \
    \        return false\n        }\n        // if the stack is empty, you have a\
    \ correct bracketing.\n        return stack.isEmpty", "        var prev = brackets(0)\n\
    \        var result = false\n        if (brackets.length % 2 == 0) {\n       \
    \     result = brackets.forall(x => x == '(' || x == ')')\n            if (result)\
    \ {\n                var cnt = 0\n                brackets.foreach(x => if (x\
    \ == '(') cnt += 1 else cnt -= 1)\n                result = cnt == 0\n       \
    \     }\n        }\n        result", "        var counter = 0\n        for (x\
    \ <- brackets) {\n            if (x == '(') {\n                counter += 1\n\
    \            } else if (x == ')') {\n                counter -= 1\n          \
    \  }\n            if (counter < 0) {\n                return false\n         \
    \   }\n        }\n        return counter == 0", "        var stack = new Stack[Char]\n\
    \        for (c <- brackets) {\n            if (c == '(') stack.push(c)\n    \
    \        else if (c == ')') if (stack.isEmpty) return false else stack.pop\n \
    \       }\n        return stack.isEmpty", "        val opening = Set('(', '[',\
    \ '{')\n        val closing = Set(')', ']', '}')\n        val pairs = Map('('\
    \ -> ')', '[' -> ']', '{' -> '}')\n        val stack = Stack[Char]()\n       \
    \ for (c <- brackets) {\n            if (opening.contains(c)) stack.push(c)\n\
    \            else if (closing.contains(c)) {\n                if (stack.isEmpty)\
    \ return false\n                val last = stack.pop\n                if (pairs(last)\
    \ != c) return false\n            }\n        }\n        stack.isEmpty", "    \
    \    var count = 0\n        for (bracket <- brackets) {\n            if (bracket\
    \ == '(') count += 1\n            else if (bracket == ')') count -= 1\n      \
    \      if (count < 0) return false\n        }\n        return count == 0", " \
    \       val st = new Stack[Char]\n        brackets.foreach(ch => {\n         \
    \   if (ch == '(') st.push(ch)\n            else if (ch == ')') {\n          \
    \      if (st.size == 0) return false\n                else st.pop\n         \
    \   }\n        })\n        st.size == 0", "        def isCorrect(brackets : List[Char],\
    \ count : Int) : Boolean = {\n            if (count < 0) false\n            else\
    \ if (brackets.isEmpty) count == 0\n            else if (brackets.head == '(')\
    \ isCorrect(brackets.tail, count + 1)\n            else isCorrect(brackets.tail,\
    \ count - 1)\n        }\n        isCorrect(brackets.toList, 0)", "        val\
    \ arr = brackets.toCharArray\n        var count = 0\n        for (c <- arr) {\n\
    \            if (c == '(') {\n                count += 1\n            } else if\
    \ (c == ')') {\n                count -= 1\n            }\n            if (count\
    \ < 0) return false\n        }\n        count == 0", "        var bracketStack\
    \ = new Stack[Char]()\n        for (c <- brackets) {\n            if (c == '(')\
    \ bracketStack.push(c)\n            else if (c == ')') {\n                if (bracketStack.isEmpty)\
    \ return false\n                else bracketStack.pop\n            }\n       \
    \ }\n        bracketStack.isEmpty", "        val stack = new Stack[Char]\n   \
    \     var success = true\n        var i = 0\n        while (i < brackets.length\
    \ && success) {\n            if (brackets(i) == '(') stack.push('(')\n       \
    \     else if (stack.size == 0) success = false\n            else stack.pop\n\
    \            i += 1\n        }\n        success && stack.size == 0", "       \
    \ val stack = Stack[Char]()\n        var pos = 0\n        while (pos < brackets.length)\
    \ {\n            val ch = brackets(pos)\n            if (ch == '(') stack.push(ch)\n\
    \            else if (ch == ')') {\n                if (stack.isEmpty) return\
    \ false\n                else stack.pop\n            }\n            pos += 1\n\
    \        }\n        stack.isEmpty", "        // http://stackoverflow.com/questions/3542163/is-there-a-stack-data-structure-in-scala\n\
    \        val stack = new scala.collection.mutable.Stack[Char]()\n        brackets.foreach(bracket\
    \ => {\n            if (bracket == '(') {\n                stack.push(bracket)\n\
    \            } else if (bracket == ')') {\n                if (stack.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        stack.pop()\n                }\n            } else {\n              \
    \  throw new Exception(\"wrong input: \" + bracket)\n            }\n        })\n\
    \        if (stack.isEmpty) {\n            return true\n        } else {\n   \
    \         return false\n        }", "        var p = 0\n        for (b <- brackets)\
    \ {\n            if (b == '(') p += 1\n            else if (b == ')') p -= 1\n\
    \            if (p < 0) return false\n        }\n        p == 0", "        var\
    \ stack = new Stack[Char]\n        for (i <- 0 until brackets.length) {\n    \
    \        if (brackets(i) == '(') {\n                stack.push('(')\n        \
    \    } else {\n                if (stack.isEmpty) return false\n             \
    \   stack.pop\n            }\n        }\n        return stack.isEmpty", "    \
    \    var left = 0\n        var right = 0\n        for (ch <- brackets) {\n   \
    \         if (ch == '(') left += 1\n            else if (ch == ')') right += 1\n\
    \            if (right > left) return false\n        }\n        left == right",
  "        if (brackets.length % 2 == 1) return false\n        var stack = new Stack[Char]\n\
    \        for (c <- brackets) c match {\n            case '(' => stack.push(c)\n\
    \            case ')' => {\n                if (stack.isEmpty) return false\n\
    \                if (stack.pop != '(') return false\n            }\n        }\n\
    \        return stack.isEmpty", "        val stack = Stack[Char]()\n        for\
    \ (bracket <- brackets) {\n            if (bracket == '(') {\n               \
    \ stack.push(bracket)\n            } else if (bracket == ')') {\n            \
    \    if (stack.size > 0) {\n                    if (stack.top == '(') {\n    \
    \                    stack.pop\n                    } else {\n               \
    \         return false\n                    }\n                } else {\n    \
    \                return false\n                }\n            } else {\n     \
    \           throw new IllegalArgumentException(\"brackets must only contain '('\
    \ and ')'.\")\n            }\n        }\n        stack.size == 0", "        var\
    \ bracketCount = 0\n        for (b <- brackets) {\n            if (b == '(') bracketCount\
    \ += 1\n            else bracketCount -= 1\n            if (bracketCount < 0)\
    \ return false\n        }\n        return bracketCount == 0", "        var count\
    \ = 0\n        for (bracket <- brackets) {\n            if (bracket == '(') {\n\
    \                count += 1\n            } else if (bracket == ')') {\n      \
    \          count -= 1\n            }\n            if (count < 0) {\n         \
    \       return false\n            }\n        }\n        count == 0", "       \
    \ var stack = new Stack[Char]\n        for (char <- brackets) {\n            if\
    \ (char == '(') {\n                stack.push(char)\n            } else if (char\
    \ == ')') {\n                if (stack.isEmpty) return false\n               \
    \ stack.pop\n            }\n        }\n        stack.isEmpty", "        var stack\
    \ = Stack[Char]()\n        for (bracket <- brackets) {\n            if (bracket\
    \ == '(') stack.push(bracket)\n            else if (bracket == ')') if (stack.isEmpty)\
    \ return false else stack.pop\n        }\n        stack.isEmpty", "        if\
    \ (brackets.length == 0) true\n        else if (brackets.head == ')') false\n\
    \        else {\n            var numOpeningBrackets = 0\n            var numClosingBrackets\
    \ = 0\n            for (c <- brackets) {\n                if (c == '(') numOpeningBrackets\
    \ += 1\n                else if (c == ')') numClosingBrackets += 1\n         \
    \   }\n            return numOpeningBrackets == numClosingBrackets\n        }",
  "        val stack = ListBuffer[Char]()\n        for (c <- brackets) {\n       \
    \     if (c == '(') stack += c\n            else if (c == ')') if (stack.length\
    \ == 0 || stack.last != '(') return false else stack.trimEnd(1)\n        }\n \
    \       return stack.length == 0", "        var stack = new Stack[Char]()\n  \
    \      for (i <- 0 until brackets.length) {\n            brackets(i) match {\n\
    \                case '(' => stack.push('(')\n                case ')' => if (stack.isEmpty\
    \ || stack.pop() != '(') return false\n            }\n        }\n        return\
    \ stack.isEmpty", "        brackets.foldLeft(List[Char]())((list, c) => if (c\
    \ == '(') c :: list else if (list.isEmpty) return false else list.tail) == Nil",
  "        brackets.zipWithIndex.map(x => if (x._1 == '(') -1 else 1).scanLeft(0)(_\
    \ + _).filter(_ < 0).isEmpty", "        var stack = new Stack[String]\n      \
    \  brackets.foreach(ch => {\n            if (ch == '(') stack.push(\"(\")\n  \
    \          else {\n                if (stack.isEmpty) return false\n         \
    \       stack.pop\n            }\n        })\n        stack.isEmpty", "      \
    \  var count = 0\n        for (i <- 0 until brackets.length) {\n            brackets(i)\
    \ match {\n                case '(' => count += 1\n                case ')' =>\
    \ count -= 1\n            }\n            if (count < 0) return false\n       \
    \ }\n        count == 0", "        var count = 0\n        for (i <- 0 until brackets.length)\
    \ {\n            val c = brackets(i)\n            if (c == '(') count += 1\n \
    \           else if (c == ')') count -= 1\n            if (count < 0) return false\n\
    \        }\n        count == 0", "        var stack = new Stack[Char]\n      \
    \  for (i <- 0 until brackets.length) {\n            if (brackets(i) == '(') {\n\
    \                stack.push('(')\n            } else {\n                if (stack.isEmpty)\
    \ return false\n                stack.pop\n            }\n        }\n        return\
    \ stack.isEmpty", "        var opened = 0\n        for (i <- 0 until brackets.length)\
    \ {\n            if (brackets(i) == '(') {\n                opened += 1\n    \
    \        } else {\n                opened -= 1\n                if (opened < 0)\
    \ {\n                    return false\n                }\n            }\n    \
    \    }\n        opened == 0", "        var open = List[Char]()\n        for (ch\
    \ <- brackets) {\n            if (ch == '(') open = ch :: open\n            else\
    \ if (ch == ')') if (open.isEmpty) return false else open = open.tail\n      \
    \  }\n        open.isEmpty", "        var ans = true\n        var i = 0\n    \
    \    var count = 0\n        while (i < brackets.length) {\n            if (brackets(i)\
    \ == '(') count += 1\n            else count -= 1\n            if (count < 0)\
    \ ans = false\n            i += 1\n        }\n        ans && count == 0", "  \
    \      var openCount = 0\n        for (c <- brackets) {\n            c match {\n\
    \                case '(' => openCount += 1\n                case ')' => openCount\
    \ -= 1\n                case _ => throw new RuntimeException\n            }\n\
    \            if (openCount < 0) return false\n        }\n        openCount ==\
    \ 0", "        val stack = new Stack[Char]\n        brackets.foreach(c => if (c\
    \ == '(') stack.push(c) else if (stack.isEmpty || stack.pop != '(') return false)\n\
    \        return stack.isEmpty", "        def f(r : String, s : Int) : Boolean\
    \ = r match {\n            case \"\" => s == 0\n            case \"(\" + rest\
    \ => f(rest, s + 1)\n            case \")\" + rest => s > 0 && f(rest, s - 1)\n\
    \        }\n        f(brackets, 0)", "        var bracketsLeft = 0\n        for\
    \ (c <- brackets) {\n            c match {\n                case '(' => bracketsLeft\
    \ += 1\n                case ')' => bracketsLeft -= 1\n                case _\
    \ => ()\n            }\n            if (bracketsLeft < 0) return false\n     \
    \   }\n        bracketsLeft == 0", "        val stack = new Stack[Char]\n    \
    \    brackets.foreach(c => {\n            if (c == '(') stack.push(c)\n      \
    \      else if (c == ')') {\n                if (stack.isEmpty) return false\n\
    \                stack.pop\n            }\n        })\n        stack.isEmpty",
  "        var stack = new Stack[Char]()\n        for (char <- brackets) {\n     \
    \       if (char == '(') stack.push(char)\n            else if (char == ')') {\n\
    \                if (stack.size == 0) return false\n                stack.pop()\n\
    \            }\n        }\n        return stack.size == 0", "        var count\
    \ = 0\n        for (c <- brackets) {\n            if (c == '(') count += 1\n \
    \           else if (c == ')') count -= 1\n            if (count < 0) return false\n\
    \        }\n        return count == 0", "        def rec(brackets : String, level\
    \ : Int) : Boolean = {\n            if (level < 0) return false\n            if\
    \ (brackets.isEmpty) return level == 0\n            val char = brackets.head\n\
    \            if (char == '(') return rec(brackets.tail, level + 1)\n         \
    \   if (char == ')') return rec(brackets.tail, level - 1)\n            return\
    \ rec(brackets.tail, level)\n        }\n        return rec(brackets, 0)", "  \
    \      var counter = 0\n        for (char <- brackets) {\n            if (char\
    \ == '(') {\n                counter += 1\n            } else if (char == ')')\
    \ {\n                counter -= 1\n            }\n            if (counter < 0)\
    \ {\n                return false\n            }\n        }\n        return counter\
    \ == 0", "        var stack = new Stack[Char]()\n        for (bracket <- brackets)\
    \ {\n            if (bracket == '(') {\n                stack.push(bracket)\n\
    \            } else if (bracket == ')') {\n                if (stack.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        stack.pop()\n                }\n            }\n        }\n        stack.isEmpty",
  "        var stack = Stack[Char]()\n        for (c <- brackets) {\n            if\
    \ (c == '(') stack.push(c)\n            else if (c == ')') {\n               \
    \ if (stack.isEmpty) return false\n                if (stack.pop != '(') return\
    \ false\n            }\n        }\n        return stack.isEmpty", "        val\
    \ openBrackets = Queue[Char]()\n        var closedBrackets = 0\n        for (bracket\
    \ <- brackets) {\n            if (bracket == '(') {\n                openBrackets\
    \ += bracket\n            } else {\n                if (openBrackets.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        openBrackets.dequeue\n                }\n            }\n        }\n \
    \       openBrackets.isEmpty", "        var stack = new Stack[Char]\n        for\
    \ (c <- brackets) {\n            if (c == '(') {\n                stack.push(c)\n\
    \            } else if (c == ')') {\n                if (stack.isEmpty) {\n  \
    \                  return false\n                } else {\n                  \
    \  stack.pop\n                }\n            }\n        }\n        stack.isEmpty",
  "        var stack = ArrayBuffer[Char]()\n        for (c <- brackets) {\n      \
    \      if (c == '(') stack += c\n            else if (c == ')') {\n          \
    \      if (stack.length == 0) return false\n                stack = stack.dropRight(1)\n\
    \            }\n        }\n        return stack.length == 0", "\tvar bracketCount\
    \ = 0\n\tfor (c <- brackets) {\n\t    if (c == '(') {\n\t\tbracketCount += 1\n\
    \t    } else if (c == ')') {\n\t\tbracketCount -= 1\n\t    }\n\t    if (bracketCount\
    \ < 0) {\n\t\treturn false\n\t    }\n\t}\n\tif (bracketCount == 0) {\n\t    return\
    \ true\n\t} else {\n\t    return false\n\t}", "        var balance = 0\n     \
    \   for (b <- brackets) {\n            b match {\n                case '(' =>\
    \ balance += 1\n                case ')' => balance -= 1\n                case\
    \ _ => ;\n            }\n            if (balance < 0) return false\n        }\n\
    \        return balance == 0", "        var cnt = 0\n        for (i <- 0 until\
    \ brackets.length) {\n            brackets(i) match {\n                case '('\
    \ => cnt += 1\n                case ')' => cnt -= 1\n            }\n         \
    \   if (cnt < 0) return false\n        }\n        return cnt == 0"]
stop_tokens:
- "\n    }\n"
