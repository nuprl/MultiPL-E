name: HumanEval_129_minPath
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a grid with N rows and N columns (N >= 2) and a positive integer k,\
  \ \n    // each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n    // inclusive appears exactly once on the cells of the grid.\n    //\
  \ You have to find the minimum path of length k in the grid. You can start\n   \
  \ // from any cell, and in each step you can move to any of the neighbor cells,\n\
  \    // in other words, you can go to cells which share an edge with you current\n\
  \    // cell.\n    // Please note that a path of length k means visiting exactly\
  \ k cells (not\n    // necessarily distinct).\n    // You CANNOT go off the grid.\n\
  \    // A path A (of length k) is considered less than a path B (of length k) if\n\
  \    // after making the ordered lists of the values on the cells that A and B go\n\
  \    // through (let's call them lst_A and lst_B), lst_A is lexicographically less\n\
  \    // than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n\
  \    // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    //\
  \ lst_A[j] = lst_B[j].\n    // It is guaranteed that the answer is unique.\n   \
  \ // Return an ordered list of the values on the cells that the minimum path go\
  \ through.\n    // Examples:    \n    // >>> minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l))\n    // (List[Long](1l.toLong, 2l.toLong, 1l.toLong))\n\
  \    // >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l))\n    // (List[Long](1l.toLong))\n    def minPath(grid : List[List[Long]],\
  \ k : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong,\
  \ 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong,\
  \ 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong,\
  \ 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong,\
  \ 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong,\
  \ 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](11l.toLong,\
  \ 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong,\
  \ 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong,\
  \ 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong,\
  \ 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong,\
  \ 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong,\
  \ 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong),\
  \ List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong,\
  \ 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong,\
  \ 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong,\
  \ 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong),\
  \ List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        val n = grid.length\n        val m = grid(0).length\n     \
    \   val g = grid.map(_.toArray).toArray\n        val (si, sj) = (for (i <- (0\
    \ until n); j <- (0 until m)) yield (i, j)).minBy(x => (g(x._1)(x._2), x._1, x._2))\n\
    \        val moves = Array(Array(-1, 0), Array(1, 0), Array(0, -1), Array(0, 1))\n\
    \        val queue = new scala.collection.mutable.PriorityQueue[(Int, Int, List[Long])]()(Ordering.by(_._3))\n\
    \        queue.enqueue((si, sj, List(g(si)(sj))))\n        val visited = Array.fill(n,\
    \ m)(false)\n        visited(si)(sj) = true\n        while (!queue.isEmpty) {\n\
    \            val (i, j, path) = queue.dequeue\n            if (path.length ==\
    \ k) return path\n            for (m <- moves) {\n                val (ni, nj)\
    \ = (i + m(0), j + m(1))\n                if (ni >= 0 && ni < n && nj >= 0 &&\
    \ nj < m && !visited(ni)(nj)) {\n                    visited(ni)(nj) = true\n\
    \                    queue.enqueue((ni, nj, path :+ g(ni)(nj)))\n            \
    \    }\n            }\n        }\n        return List()", "        val n = grid.length\n\
    \        val m = grid(0).length\n        var p = List[Long]()\n        var d =\
    \ List[List[Long]]()\n        for (i <- 0 until n) {\n            d = d :+ List[Long]()\n\
    \            for (j <- 0 until m) {\n                d(i) = d(i) :+ 0l\n     \
    \       }\n        }\n        d(0)(0) = 1l\n        var ok = false\n        while\
    \ (!ok) {\n            ok = true\n            for (i <- 0 until n) {\n       \
    \         for (j <- 0 until m) {\n                    if (d(i)(j) == k) ok = false\n\
    \                    if (d(i)(j) > 0) {\n                        if (i > 0 &&\
    \ d(i - 1)(j) == 0) {\n                            d(i - 1)(j) = d(i)(j) + 1\n\
    \                            ok = false\n                        }\n         \
    \               if (i < n - 1 && d(i + 1)(j) == 0) {\n                       \
    \     d(i + 1)(j) = d(i)(j) + 1\n                            ok = false\n    \
    \                    }\n                        if (j > 0 && d(i)(j - 1) == 0)\
    \ {\n                            d(i)(j - 1) = d(i)(j) + 1\n                 \
    \           ok = false\n                        }\n                        if\
    \ (j < m - 1 && d(i)(j + 1) == 0) {\n                            d(i)(j + 1) =\
    \ d(i)(j) + 1\n                            ok = false\n                      \
    \  }\n                    }\n                }\n            }\n        }\n   \
    \     var a = 1l\n        var b = 1l\n        var c = 1l\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                if (d(i)(j)\
    \ == k) {\n                    c = grid(i)(j)\n                    a = i\n   \
    \                 b = j\n                }\n            }\n        }\n       \
    \ p = p :+ c\n        for (i <- k - 1 to 1 by -1) {\n            if (a > 0 &&\
    \ d(a - 1)(", "\t\t// Fill up this function body\n        if (k == 1) {\n    \
    \        var ans = List[Long]()\n            for (i <- 0 until grid.length) for\
    \ (j <- 0 until grid(i).length) if (grid(i)(j) == 1) ans = List(1)\n         \
    \   return ans\n        }\n        var empty = new Array[Array[Int]](grid.length)\n\
    \        for (i <- 0 until grid.length) empty(i) = new Array[Int](grid(i).length)\n\
    \        for (i <- 0 until grid.length) for (j <- 0 until grid(i).length) empty(i)(j)\
    \ = grid(i)(j).toInt\n        var ans = List[Long]()\n        for (i <- 0 until\
    \ grid.length) for (j <- 0 until grid(i).length) {\n            val res = dfs(i,\
    \ j, k, empty)\n            if (ans.length == 0 || res < ans) ans = res\n    \
    \    }\n        ans", "        val n = grid.length\n        val edges = new Array[Array[(Long,\
    \ Long)]](n * n)\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ n) {\n                val id = i * n + j\n                if (i == 0) {\n  \
    \                  if (j == 0) {\n                        edges(id) = Array((id\
    \ + 1, grid(0)(1)), (id + n, grid(1)(0)))\n                    } else if (j ==\
    \ n - 1) {\n                        edges(id) = Array((id - 1, grid(0)(n - 2)),\
    \ (id + n, grid(1)(n - 1)))\n                    } else {\n                  \
    \      edges(id) = Array((id - 1, grid(0)(j - 1)), (id + 1, grid(0)(j + 1)), (id\
    \ + n, grid(1)(j)))\n                    }\n                } else if (i == n\
    \ - 1) {\n                    if (j == 0) {\n                        edges(id)\
    \ = Array((id + 1, grid(n - 1)(1)), (id - n, grid(n - 2)(0)))\n              \
    \      } else if (j == n - 1) {\n                        edges(id) = Array((id\
    \ - 1, grid(n - 1)(n - 2)), (id - n, grid(n - 2)(n - 1)))\n                  \
    \  } else {\n                        edges(id) = Array((id - 1, grid(n - 1)(j\
    \ - 1)), (id + 1, grid(n - 1)(j + 1)), (id - n, grid(n - 2)(j)))\n           \
    \         }\n                } else {\n                    if (j == 0) {\n   \
    \                     edges(id) = Array((id + 1, grid(i)(1)), (id - n, grid(i\
    \ - 1)(0)), (id + n, grid(i + 1)(0)))\n                    } else if (j == n -\
    \ 1) {\n                        edges(id) = Array((id - 1, grid(i)(n - 2)), (id\
    \ - n, grid(i - 1)(n - 1)), (id + n, grid(i + 1)(n - 1)))\n                  \
    \  } else {\n                        edges(id) = Array((", "        // Use a 2D\
    \ array to store minimum paths of all lengths.\n        val dp = Array.ofDim[Int](grid.length,\
    \ grid.length)\n        dp(0)(0) = 1\n        def recur(row : Int, col : Int,\
    \ path : List[Long]) : List[Long] = {\n            if (row == grid.length - 1\
    \ && col == grid.length - 1) {\n                if (path.length == k.toInt) path\n\
    \                else if (path.length > k.toInt) Nil\n                else {\n\
    \                    val path1 = recur(row, col - 1, path ++ List(grid(row)(col\
    \ - 1)))\n                    val path2 = recur(row - 1, col, path ++ List(grid(row\
    \ - 1)(col)))\n                    if (path1.length == k.toInt && path2.length\
    \ == k.toInt) {\n                        if (path1 < path2) path1\n          \
    \              else path2\n                    }\n                    else if\
    \ (path1.length == k.toInt) path1\n                    else if (path2.length ==\
    \ k.toInt) path2\n                    else Nil\n                }\n          \
    \  }\n            else if (row == grid.length - 1) {\n                if (path.length\
    \ == k.toInt) path\n                else if (path.length > k.toInt) Nil\n    \
    \            else {\n                    val path1 = recur(row, col - 1, path\
    \ ++ List(grid(row)(col - 1)))\n                    if (path1.length == k.toInt)\
    \ path1\n                    else Nil\n                }\n            }\n    \
    \        else if (col == grid.length - 1) {\n                if (path.length ==\
    \ k.toInt) path\n                else if (path.length > k.toInt) Nil\n       \
    \         else {\n                    val path2 = recur(row - 1, col, path ++\
    \ List(grid(row - 1)(col)))\n                    if (path2.length == k.toInt)\
    \ path2\n                    else Nil\n                }\n            }\n    \
    \        else {\n                if (path.length == k.toInt) path\n          \
    \      else if (path.length > k.toInt) Nil\n                else {\n         \
    \           val", "      // Type your answer here\n      val N = grid.length\n\
    \      val r = new Array[Array[Array[Long]]](N)\n      for (i <- 0 until N) {\n\
    \        r(i) = new Array[Array[Long]](N)\n        for (j <- 0 until N) {\n  \
    \        r(i)(j) = new Array[Long](N * N + 1)\n          for (l <- 0 until N *\
    \ N + 1) {\n            r(i)(j)(l) = 0\n          }\n        }\n      }\n    \
    \  var remain = k\n      for (i <- 0 until N) {\n        for (j <- 0 until N)\
    \ {\n          r(i)(j)(grid(i)(j).toInt) = 1\n        }\n      }\n      for (i\
    \ <- 0 until N) {\n        for (j <- 0 until N) {\n          for (l <- 1 until\
    \ N * N + 1) {\n            r(i)(j)(l) = r(i)(j)(l - 1)\n            if (i > 0)\
    \ {\n              r(i)(j)(l) = min(r(i)(j)(l), r(i - 1)(j)(l - 1))\n        \
    \    }\n            if (j > 0) {\n              r(i)(j)(l) = min(r(i)(j)(l), r(i)(j\
    \ - 1)(l - 1))\n            }\n            if (i < N - 1) {\n              r(i)(j)(l)\
    \ = min(r(i)(j)(l), r(i + 1)(j)(l - 1))\n            }\n            if (j < N\
    \ - 1) {\n              r(i)(j)(l) = min(r(i)(j)(l), r(i)(j + 1)(l - 1))\n   \
    \         }\n          }\n        }\n      }\n      val ans = new Array[Long](k.toInt)\n\
    \      var x = 0\n      var y = 0\n      for (i <- 0 until k.toInt) {\n      \
    \  ans(i) = grid(x)(y)\n        if (x > 0 && r(x - 1)(y)(remain) < r(x)(y)(rem",
  "        val N = grid.length\n        val M = grid(0).length\n        val shortestPath\
    \ = new ShortestPath(N * M, false)\n        for (i <- 0 until N) {\n         \
    \   for (j <- 0 until M) {\n                val u = M * i + j\n              \
    \  if (i > 0) {\n                    val v = M * (i - 1) + j\n               \
    \     val w = grid(i - 1)(j)\n                    shortestPath.addEdge(u, v, w)\n\
    \                }\n                if (i < N - 1) {\n                    val\
    \ v = M * (i + 1) + j\n                    val w = grid(i + 1)(j)\n          \
    \          shortestPath.addEdge(u, v, w)\n                }\n                if\
    \ (j > 0) {\n                    val v = M * i + j - 1\n                    val\
    \ w = grid(i)(j - 1)\n                    shortestPath.addEdge(u, v, w)\n    \
    \            }\n                if (j < M - 1) {\n                    val v =\
    \ M * i + j + 1\n                    val w = grid(i)(j + 1)\n                \
    \    shortestPath.addEdge(u, v, w)\n                }\n            }\n       \
    \ }\n        val V = N * M\n        val result = new ListBuffer[Long]\n      \
    \  for (i <- 0 until V) result += grid(i / M)(i % M)\n        for (i <- 0 until\
    \ V) {\n            shortestPath.solve(i)\n            for (j <- 0 until V) {\n\
    \                if (shortestPath.pred(j) != -1) {\n                    val newPath\
    \ = new ListBuffer[Long]\n                    var current = j\n              \
    \      while (current != i) {\n                        newPath += grid(current\
    \ / M)(current % M)\n                        current = shortestPath.pred(current)\n\
    \                    }\n                    newPath += grid(current / M)(current\
    \ % M)\n                    if (newPath.length <= k && newPath < result) result\
    \ = newPath\n                }\n            }\n        }\n        result.toList",
  "        def f(g : List[List[Long]], k : Long, q : Queue[(Long, Long, Long, List[Long])])\
    \ : List[Long] = {\n            if (k == 0) {\n                return List[Long]()\n\
    \            }\n            var minPath : List[Long] = null\n            for (path\
    \ <- q) {\n                val x = path._1\n                val y = path._2\n\
    \                val len = path._3\n                val pathVal = path._4\n  \
    \              if (len == k) {\n                    if (minPath == null) {\n \
    \                       minPath = pathVal\n                    } else {\n    \
    \                    if (lexicographicLess(pathVal, minPath)) {\n            \
    \                minPath = pathVal\n                        }\n              \
    \      }\n                } else {\n                    val r = 1l\n         \
    \           if (x - r >= 0) {\n                        q.enqueue((x - r, y, len\
    \ + 1, pathVal :+ g(x.toInt - 1)(y.toInt)))\n                    }\n         \
    \           if (x + r < g.length) {\n                        q.enqueue((x + r,\
    \ y, len + 1, pathVal :+ g(x.toInt + 1)(y.toInt)))\n                    }\n  \
    \                  if (y - r >= 0) {\n                        q.enqueue((x, y\
    \ - r, len + 1, pathVal :+ g(x.toInt)(y.toInt - 1)))\n                    }\n\
    \                    if (y + r < g.length) {\n                        q.enqueue((x,\
    \ y + r, len + 1, pathVal :+ g(x.toInt)(y.toInt + 1)))\n                    }\n\
    \                }\n            }\n            return minPath\n        }\n   \
    \     val q = Queue[(Long, Long, Long, List[Long])]()\n        for (i <- 0 until\
    \ grid.length) {\n            for (j <- 0 until grid.length) {\n             \
    \   q.enqueue((i.toLong, j.toLong, 1l, List[Long](grid(i)(j))))\n            }\n\
    \        }\n        return f(grid, k, q)", "        val N = grid.length\n    \
    \    val M = grid(0).length\n        val NN = N * M\n        // (i, j) is the\
    \ coordinates of the cell that we are processing\n        val dp = Array.fill(N,\
    \ M)((0l, Map[Long, Long]()))\n        for (i <- 0 until N; j <- 0 until M) {\n\
    \            // For each cell in the grid:\n            // dp(i)(j)._1 = min(dp(x)(y)._1)\
    \ + 1, (x, y) neighbors of (i, j)\n            // dp(i)(j)._2 = the sequence we\
    \ get by taking the sequence in dp(x)(y)._2 and adding the value at (i, j) to\
    \ the end of it, (x, y) neighbors of (i, j)\n            // The two equations\
    \ can be combined by noticing that there is only one \"best\" sequence that we\
    \ must add the value at (i, j) to the end of it\n            // Therefore, the\
    \ smallest value of dp(x)(y)._1 that we get after doing that is the best value\
    \ for dp(i)(j)._1\n            // Now, the next part is why this algorithm will\
    \ give us the correct answer, which is to prove that for all (i, j) we have the\
    \ following:\n            // For any neighbor (x, y) of (i, j) we have dp(x)(y)._1\
    \ > dp(i)(j)._1 OR (dp(x)(y)._1 = dp(i)(j)._1 AND dp(x)(y)._2 > dp(i)(j)._2)\n\
    \            // This is true for base case, for every cell in the grid, (x, y)\
    \ is a neighbor of itself and the two sequences are just the value at (x, y)\n\
    \            // Assume this holds for some (i, j) in the grid, and let's prove\
    \ it holds for all neighbors of (i, j)\n            // For any neighbor (x, y)\
    \ of (i, j)\n            // We have dp(x)(y)._1 = min(dp(z)(w)._1) + 1, (z, w)\
    \ neighbors", "        // Your code here\n        null", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val map = HashMap[Long, (Int, Int)]()\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        map(grid(i)(j)) = (i, j)\n            }\n        }\n        var count\
    \ = new Array[Array[Array[Int]]](n)\n        for (i <- 0 until n) {\n        \
    \    count(i) = new Array[Array[Int]](m)\n            for (j <- 0 until m) {\n\
    \                count(i)(j) = new Array[Int](n * m + 1)\n            }\n    \
    \    }\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               if (i == 0 && j == 0) {\n                    count(i)(j)(1) =\
    \ 0\n                } else {\n                    var u = -1\n              \
    \      var v = -1\n                    if (i > 0) {\n                        u\
    \ = i - 1\n                        v = j\n                    }\n            \
    \        if (j > 0) {\n                        if (u == -1 || count(u)(v)(1) >\
    \ count(i - 1)(j)(1)) {\n                            u = i\n                 \
    \           v = j - 1\n                        }\n                    }\n    \
    \                for (l <- 1 to n * m) {\n                        count(i)(j)(l)\
    \ = count(u)(v)(l)\n                    }\n                    val tmp = map(grid(i)(j))\n\
    \                    for (l <- 1 to n * m) {\n                        if (tmp._1\
    \ == u && tmp._2 == v) {\n                            count(i)(j)(l) = count(i)(j)(l\
    \ - 1)\n                        } else {\n                            count(i)(j)(l)\
    \ = min(count(i)(j)(l), count(i)(j)(l - 1) + 1)\n                        }\n \
    \                   }\n                }\n            }\n        }\n        var\
    \ result = new Array[Long](k.toInt)\n        var i = n - 1\n        var j = m\
    \ - 1\n        for (l <- k.toInt to 1 by -1) {\n", "        // find the starting\
    \ point of the minimum path\n        val point = {\n            var min_value\
    \ = grid(0)(0)\n            var min_point = (0, 0)\n            for (i <- 0 until\
    \ grid.length) {\n                for (j <- 0 until grid(i).length) {\n      \
    \              if (grid(i)(j) < min_value) {\n                        min_value\
    \ = grid(i)(j)\n                        min_point = (i, j)\n                 \
    \   }\n                }\n            }\n            min_point\n        }\n  \
    \      // record the distance from starting point\n        val dist = Array.fill(grid.length,\
    \ grid(0).length)(Long.MaxValue)\n        dist(point._1)(point._2) = 0\n     \
    \   val queue = Queue[(Int, Int)]()\n        queue.enqueue(point)\n        while\
    \ (!queue.isEmpty) {\n            val cur = queue.dequeue\n            for (i\
    \ <- -1 to 1) {\n                for (j <- -1 to 1) {\n                    if\
    \ (i == 0 && j == 0) {\n                        // do nothing\n              \
    \      } else if (cur._1 + i >= 0 && cur._1 + i < grid.length && cur._2 + j >=\
    \ 0 && cur._2 + j < grid(0).length) {\n                        if (dist(cur._1\
    \ + i)(cur._2 + j) > dist(cur._1)(cur._2) + 1) {\n                           \
    \ dist(cur._1 + i)(cur._2 + j) = dist(cur._1)(cur._2) + 1\n                  \
    \          queue.enqueue((cur._1 + i, cur._2 + j))\n                        }\n\
    \                    }\n                }\n            }\n        }\n        //\
    \ find all points with distance k\n        val points = ArrayBuffer[(Int, Int)]()\n\
    \        for (i <- 0 until grid.length) {\n            for (j <- 0 until grid(i).length)\
    \ {\n                if (dist(i)(j) == k) {\n                    points += ((i,\
    \ j))\n                }\n            }\n        }\n        // find the one with\
    \ minimum value\n        val result = {\n            var min_value = Long.MaxValue\n\
    \            var", "        var n = grid.length\n        var dist = Array.ofDim[Long](n,\
    \ n)\n        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n   \
    \             dist(i)(j) = Long.MaxValue\n            }\n        }\n        dist(0)(0)\
    \ = 0\n        var pq = PriorityQueue(0l.toLong, (0, 0, 0l))(Ordering.by(x =>\
    \ x._2._3))\n        while (!pq.isEmpty) {\n            var (value, (i, j, d))\
    \ = pq.dequeue\n            if (d > dist(i)(j)) continue\n            for (k <-\
    \ 0 until n) {\n                for (l <- 0 until n) {\n                    var\
    \ dd = d + abs(i - k) + abs(j - l)\n                    if (dd <= k && dd < dist(k)(l))\
    \ {\n                        dist(k)(l) = dd\n                        pq.enqueue(grid(k)(l),\
    \ (k, l, dd))\n                    }\n                }\n            }\n     \
    \   }\n        var path = (List[Long]() /: dist(n - 1)(n - 1).toInt)((path, x)\
    \ => path :+ grid(x / n)(x % n))\n        return path", "        // dp[i][j][p]\
    \ = minimum path starting from (i, j) of length p\n        val dp = Array.ofDim[Long](grid.length,\
    \ grid.length, k.toInt + 1)\n        for (i <- 0 until grid.length; j <- 0 until\
    \ grid.length; p <- 0 to k.toInt) {\n            dp(i)(j)(p) = Long.MaxValue\n\
    \        }\n        // Find minimum path starting from each cell of length 1\n\
    \        for (i <- 0 until grid.length; j <- 0 until grid.length) {\n        \
    \    dp(i)(j)(1) = grid(i)(j)\n        }\n        // Find minimum path starting\
    \ from each cell of length p\n        for (p <- 2 to k.toInt) {\n            for\
    \ (i <- 0 until grid.length; j <- 0 until grid.length) {\n                // Try\
    \ all neighbors\n                val neighbors = List((i - 1, j), (i + 1, j),\
    \ (i, j - 1), (i, j + 1))\n                for (neighbor <- neighbors) {\n   \
    \                 if (neighbor._1 >= 0 && neighbor._1 < grid.length && neighbor._2\
    \ >= 0 && neighbor._2 < grid.length) {\n                        // Check if a\
    \ path starting from neighbor with length p - 1 can reach (i, j)\n           \
    \             val temp = grid(i)(j) :: dp(neighbor._1)(neighbor._2)(p - 1) ::\
    \ Nil\n                        if (temp.length == p && temp.sorted < dp(i)(j)(p))\
    \ {\n                            dp(i)(j)(p) = temp.sorted\n                 \
    \       }\n                    }\n                }\n            }\n        }\n\
    \        // Return minimum path starting from any cell of length k\n        var\
    \ answer = dp(0)(0)(k.toInt)\n        for (i <- 0 until grid.length; j <- 0 until\
    \ grid.length) {\n            if (dp(i)(j)(k.toInt) < answer) {\n            \
    \    answer = dp(i)(j)(k.toInt)\n            }\n        }\n        answer.toList",
  "        var L = Long.MaxValue\n        var R = Long.MinValue\n        var U = Long.MaxValue\n\
    \        var D = Long.MinValue\n        for (i <- 0 until grid.length) {\n   \
    \         for (j <- 0 until grid(i).length) {\n                if (grid(i)(j)\
    \ > R) R = grid(i)(j)\n                if (grid(i)(j) < L) L = grid(i)(j)\n  \
    \              if (grid(i)(j) > D) D = grid(i)(j)\n                if (grid(i)(j)\
    \ < U) U = grid(i)(j)\n            }\n        }\n        if (k == 1) return List(min(L,\
    \ min(U, min(R, D))))\n        def dfs(x : Int, y : Int, k : Long, path : List[Long])\
    \ : List[Long] = {\n            if (k == 0) return path\n            var min =\
    \ Long.MaxValue\n            var minPath = List[Long]()\n            if (x + 1\
    \ < grid.length && grid(x + 1)(y) < min) {\n                min = grid(x + 1)(y)\n\
    \                minPath = dfs(x + 1, y, k - 1, path :+ min)\n            }\n\
    \            if (x - 1 >= 0 && grid(x - 1)(y) < min) {\n                min =\
    \ grid(x - 1)(y)\n                minPath = dfs(x - 1, y, k - 1, path :+ min)\n\
    \            }\n            if (y + 1 < grid(x).length && grid(x)(y + 1) < min)\
    \ {\n                min = grid(x)(y + 1)\n                minPath = dfs(x, y\
    \ + 1, k - 1, path :+ min)\n            }\n            if (y - 1 >= 0 && grid(x)(y\
    \ - 1) < min) {\n                min = grid(x)(y - 1)\n                minPath\
    \ = dfs(x, y - 1, k - 1, path :+ min)\n            }\n            return minPath\n\
    \        }\n        for (i <- 0 until grid.length) {\n            for (j", " \
    \     val size = grid.size\n      val dp = new Array[Array[Pair[Long, List[Long]]]](size)\n\
    \      for (i <- 0 until size) {\n        dp(i) = new Array[Pair[Long, List[Long]]](size)\n\
    \        for (j <- 0 until size) {\n          dp(i)(j) = null\n        }\n   \
    \   }\n      val seen = new Array[Array[Boolean]](size)\n      for (i <- 0 until\
    \ size) {\n        seen(i) = new Array[Boolean](size)\n        for (j <- 0 until\
    \ size) {\n          seen(i)(j) = false\n        }\n      }\n      val dfs = new\
    \ mutable.Stack[Pair[Int, Int]]\n      val ans = new mutable.Stack[Long]\n   \
    \   dfs.push(new Pair(0, 0))\n      while (!dfs.isEmpty) {\n        val p = dfs.pop\n\
    \        if (p.first < 0 || p.first >= size || p.second < 0 || p.second >= size)\
    \ continue\n        if (seen(p.first)(p.second)) continue\n        seen(p.first)(p.second)\
    \ = true\n        val cur = new Pair(dp(p.first)(p.second) match {\n         \
    \ case null => 0l\n          case pair => pair.first\n        }, List(grid(p.first)(p.second)))\n\
    \        for (i <- -1 to 1) {\n          for (j <- -1 to 1) {\n            if\
    \ (i == 0 && j == 0) continue\n            if (p.first + i < 0 || p.first + i\
    \ >= size || p.second + j < 0 || p.second + j >= size) continue\n            if\
    \ (dp(p.first + i)(p.second + j) == null) {\n              dp(p.first + i)(p.second\
    \ + j) = new Pair(cur.first + 1, List(grid(p.first + i)(p.second + j)))\n    \
    \          dfs.push(new Pair(p.first + i, p.second + j))\n            } else {\n\
    \              val v = dp(p", "        if (k == 1) {\n            var answer =\
    \ List[Long]()\n            var max = grid(0)(0)\n            var x = 0\n    \
    \        var y = 0\n            for (i <- 0 until grid.length) {\n           \
    \     for (j <- 0 until grid(i).length) {\n                    if (grid(i)(j)\
    \ > max) {\n                        max = grid(i)(j)\n                       \
    \ x = i\n                        y = j\n                    }\n              \
    \  }\n            }\n            answer = answer :+ max\n            return answer\n\
    \        }\n        var grid1 = Array.ofDim[(Long, Long)](grid.length, grid(0).length)\n\
    \        for (i <- 0 until grid.length) {\n            for (j <- 0 until grid(i).length)\
    \ {\n                grid1(i)(j) = (grid(i)(j), 0)\n            }\n        }\n\
    \        var queue = Queue[(Int, Int)]()\n        var answer = ArrayBuffer[Long]()\n\
    \        var x = 0\n        var y = 0\n        var min = grid(0)(0)\n        for\
    \ (i <- 0 until grid.length) {\n            for (j <- 0 until grid(i).length)\
    \ {\n                if (grid(i)(j) < min) {\n                    min = grid(i)(j)\n\
    \                    x = i\n                    y = j\n                }\n   \
    \         }\n        }\n        grid1(x)(y) = (grid(x)(y), 1)\n        queue.enqueue((x,\
    \ y))\n        while (!queue.isEmpty) {\n            var cur = queue.dequeue\n\
    \            if (grid1(cur._1)(cur._2)._2 == k) {\n                answer += grid1(cur._1)(cur._2)._1\n\
    \                break\n            }\n            if (cur._1 != 0) {\n      \
    \          if (grid1(cur._1 - 1)(cur._2)._2 == 0) {\n                    grid1(cur._1\
    \ - 1)(cur._2) = (grid(cur._1 - 1)(cur._2), grid1(cur._1)(cur._2)._2 + 1)\n  \
    \                  queue.enqueue((cur._1 - 1,", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(0l)\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until n) {\n                dp(i)(j) = grid(i)(j)\n      \
    \      }\n        }\n        for (i <- 1 until n) {\n            dp(0)(i) += dp(0)(i\
    \ - 1)\n            dp(i)(0) += dp(i - 1)(0)\n        }\n        for (i <- 1 until\
    \ n) {\n            for (j <- 1 until n) {\n                dp(i)(j) += min(dp(i\
    \ - 1)(j), dp(i)(j - 1))\n            }\n        }\n        var curr = (0, 0)\n\
    \        var result = new ArrayBuffer[Long]\n        while (k > 0) {\n       \
    \     k -= 1\n            result += grid(curr._1)(curr._2)\n            if (curr._1\
    \ == n - 1) {\n                curr = (curr._1, curr._2 + 1)\n            }\n\
    \            else if (curr._2 == n - 1) {\n                curr = (curr._1 + 1,\
    \ curr._2)\n            }\n            else if (dp(curr._1 + 1)(curr._2) < dp(curr._1)(curr._2\
    \ + 1)) {\n                curr = (curr._1 + 1, curr._2)\n            }\n    \
    \        else {\n                curr = (curr._1, curr._2 + 1)\n            }\n\
    \        }\n        result.toList", "        var g : Array[Array[(Long, Long)]]\
    \ = Array.ofDim[(Long, Long)](grid.length, grid.length)\n        for (i <- 0 until\
    \ grid.length) {\n            for (j <- 0 until grid.length) {\n             \
    \   g(i)(j) = (grid(i)(j), grid(i)(j))\n            }\n        }\n        for\
    \ (i <- 1 until grid.length) {\n            g(i)(0) = (g(i - 1)(0)._1 + g(i)(0)._2,\
    \ g(i)(0)._2)\n        }\n        for (j <- 1 until grid.length) {\n         \
    \   g(0)(j) = (g(0)(j - 1)._1 + g(0)(j)._2, g(0)(j)._2)\n        }\n        for\
    \ (i <- 1 until grid.length) {\n            for (j <- 1 until grid.length) {\n\
    \                g(i)(j) = (min(g(i - 1)(j)._1, g(i)(j - 1)._1) + g(i)(j)._2,\
    \ g(i)(j)._2)\n            }\n        }\n        var min : Long = g(grid.length\
    \ - 1)(grid.length - 1)._1\n        var list : List[Long] = List(g(grid.length\
    \ - 1)(grid.length - 1)._2)\n        var i : Int = grid.length - 1\n        var\
    \ j : Int = grid.length - 1\n        while (list.length < k) {\n            if\
    \ (i > 0 && g(i - 1)(j)._1 + g(i)(j)._2 == min) {\n                min -= g(i)(j)._2\n\
    \                list = g(i)(j)._2 :: list\n                i -= 1\n         \
    \   } else {\n                min -= g(i)(j)._2\n                list = g(i)(j)._2\
    \ :: list\n                j -= 1\n            }\n        }\n        return list",
  "        var gridList = List[(Int, Int, Long)]()\n        var visitList = new HashMap[(Int,\
    \ Int), Long]()\n        var minList = List[Long]()\n        var min = Long.MaxValue\n\
    \        for (r <- 0 until grid.length) {\n            for (c <- 0 until grid(r).length)\
    \ {\n                gridList = (r, c, grid(r)(c)) :: gridList\n            }\n\
    \        }\n        for (x <- gridList) {\n            visitList.clear\n     \
    \       var list = List[Long]()\n            var cost = findPath(x._1, x._2, k,\
    \ 0l, visitList, grid, list)\n            if (cost < min) {\n                min\
    \ = cost\n                minList = list\n            }\n        }\n        return\
    \ minList", "        // map from value to (x, y)\n        val valueMap = Map[Long,\
    \ (Int, Int)]()\n        for (x <- 0 until grid.length) for (y <- 0 until grid(x).length)\
    \ {\n            valueMap += (grid(x)(y) -> (x, y))\n        }\n        // map\
    \ from (x, y) to value\n        val revValueMap = Map[(Int, Int), Long]()\n  \
    \      for (x <- 0 until grid.length) for (y <- 0 until grid(x).length) {\n  \
    \          revValueMap += ((x, y) -> grid(x)(y))\n        }\n        // solve\
    \ the problem with (0, 0) as starting point\n        // solve(0, 0, k, Set[(Int,\
    \ Int)](), List[Long]())\n        // solve(x, y, length, visited, currentPath)\n\
    \        def solve(x : Int, y : Int, length : Long, visited : Set[(Int, Int)],\
    \ currentPath : List[Long]) : List[Long] = {\n            if (length == 0) {\n\
    \                return currentPath\n            }\n            var minPath =\
    \ List[Long]()\n            for (i <- 1 to 4) {\n                val newX = x\
    \ + (i match {\n                    case 1 => -1\n                    case 2 =>\
    \ 0\n                    case 3 => 1\n                    case 4 => 0\n      \
    \          })\n                val newY = y + (i match {\n                   \
    \ case 1 => 0\n                    case 2 => -1\n                    case 3 =>\
    \ 0\n                    case 4 => 1\n                })\n                if (newX\
    \ >= 0 && newX < grid.length && newY >= 0 && newY < grid(0).length && !visited.contains((newX,\
    \ newY))) {\n                    val newVisited = visited + ((newX, newY))\n \
    \                   val newPath = solve(newX, newY, length - 1, newVisited, revValueMap((newX,\
    \ newY)) :: currentPath)\n                    if (minPath.isEmpty || less(newPath,\
    \ minPath)) {\n                        minPath = newPath\n                   \
    \ }\n                }\n            }\n            return minPath\n        }\n\
    \        return solve(0, 0,", "        val cells = Array.ofDim[Long](grid.length,\
    \ grid.length)\n        for (i <- 0 until grid.length) for (j <- 0 until grid.length)\
    \ cells(i)(j) = grid(i)(j)\n        val paths = Array.ofDim[List[Long]](grid.length,\
    \ grid.length)\n        for (i <- 0 until grid.length) for (j <- 0 until grid.length)\
    \ paths(i)(j) = List(cells(i)(j))\n        for (i <- 0 until grid.length) for\
    \ (j <- 0 until grid.length) {\n            if (i - 1 >= 0) if (cells(i - 1)(j)\
    \ < cells(i)(j)) {\n                cells(i)(j) = cells(i - 1)(j)\n          \
    \      paths(i)(j) = paths(i - 1)(j) :+ cells(i)(j)\n            }\n         \
    \   if (i + 1 < grid.length) if (cells(i + 1)(j) < cells(i)(j)) {\n          \
    \      cells(i)(j) = cells(i + 1)(j)\n                paths(i)(j) = paths(i +\
    \ 1)(j) :+ cells(i)(j)\n            }\n            if (j - 1 >= 0) if (cells(i)(j\
    \ - 1) < cells(i)(j)) {\n                cells(i)(j) = cells(i)(j - 1)\n     \
    \           paths(i)(j) = paths(i)(j - 1) :+ cells(i)(j)\n            }\n    \
    \        if (j + 1 < grid.length) if (cells(i)(j + 1) < cells(i)(j)) {\n     \
    \           cells(i)(j) = cells(i)(j + 1)\n                paths(i)(j) = paths(i)(j\
    \ + 1) :+ cells(i)(j)\n            }\n        }\n        var minPaths = paths.map(x\
    \ => x.map(y => y)).toList\n        for (i <- 0 until grid.length) for (j <- 0\
    \ until grid.length) {\n            if (i - 1 >= 0) if (comparePaths(paths(i -\
    \ 1)(j) :+ cells", "        // We maintain a queue of paths. The paths are sorted\
    \ based on their values (lexicographical order).\n        // We start by enqueuing\
    \ the shortest path possible (empty path).\n        // Each iteration, we dequeue\
    \ one path, take one step and enqueue the new resulting paths.\n        // We\
    \ stop when we find a path of length k (it must be the minimum path of length\
    \ k).\n        // IMPORTANT: We can enqueue at most 4 new paths from one path\
    \ (the path can be taken from top, bottom, left or right).\n        val queue\
    \ = new PriorityQueue[List[Long]]()(Ordering.by(x => x))\n        queue.enqueue(List[Long]())\n\
    \        while (queue.nonEmpty) {\n            val path = queue.dequeue\n    \
    \        if (path.length == k) return path\n            // Take one step\n   \
    \         val (i, j) = (path.last.toInt / grid.length, path.last.toInt % grid.length)\n\
    \            // Get the neighbors\n            val neighbors = List((i + 1, j),\
    \ (i - 1, j), (i, j + 1), (i, j - 1)).filter(p => p._1 >= 0 && p._1 < grid.length\
    \ && p._2 >= 0 && p._2 < grid.length)\n            for (p <- neighbors) {\n  \
    \              val newPath = (path :+ grid(p._1)(p._2)).sorted\n             \
    \   if (!queue.exists(x => x == newPath)) queue.enqueue(newPath)\n           \
    \ }\n        }\n        throw new Exception", "      def find(grid : List[List[Long]],\
    \ k : Long, r : Int, c : Int, result : List[Long]) : List[Long] = {\n        if\
    \ (k == 0) result\n        else {\n          val rn = r match {\n            case\
    \ 0 => 0\n            case 1 => 0\n            case 2 => 1\n            case _\
    \ => 0\n          }\n          val rx = r match {\n            case 0 => 2\n \
    \           case 1 => 2\n            case 2 => 1\n            case _ => 0\n  \
    \        }\n          val cn = c match {\n            case 0 => 0\n          \
    \  case 1 => 0\n            case 2 => 1\n            case _ => 0\n          }\n\
    \          val cx = c match {\n            case 0 => 2\n            case 1 =>\
    \ 2\n            case 2 => 1\n            case _ => 0\n          }\n         \
    \ val adj = List(List(rn, cn), List(rn, cx), List(rx, cn), List(rx, cx))\n   \
    \       val candidates = adj.map(x => find(grid, k - 1, x(0), x(1), result :+\
    \ grid(x(0))(x(1))))\n          val min = candidates.foldLeft(List[Long]())((x,\
    \ y) => if (x.length == 0 || (x.length != 0 && x.lexicographicCompare(y) < 0))\
    \ x else y)\n          min\n        }\n      }\n      val r = grid.length\n  \
    \    val c = grid(0).length\n      find(grid, k, 0, 0, List[Long]())", "     \
    \   val N = grid.length\n        var x = 0\n        var y = 0\n        var prev\
    \ = Array.ofDim[Long](N, N)\n        for (i <- 0 until N) for (j <- 0 until N)\
    \ prev(i)(j) = -1\n        for (i <- 0 until N) for (j <- 0 until N) if (grid(i)(j)\
    \ == 1) {x = i; y = j}\n        var dp = Array.ofDim[Long](N, N)\n        for\
    \ (i <- 0 until N) for (j <- 0 until N) dp(i)(j) = grid(i)(j)\n        for (i\
    \ <- 1 until N) for (j <- 1 until N) {\n            if (i == 1 && j == 1) {\n\
    \                if (dp(i)(j) < dp(i - 1)(j)) {dp(i)(j) = dp(i - 1)(j); prev(i)(j)\
    \ = dp(i - 1)(j)}\n                if (dp(i)(j) < dp(i)(j - 1)) {dp(i)(j) = dp(i)(j\
    \ - 1); prev(i)(j) = dp(i)(j - 1)}\n            } else {\n                if (dp(i)(j)\
    \ < dp(i - 1)(j)) {dp(i)(j) = dp(i - 1)(j); prev(i)(j) = dp(i - 1)(j)}\n     \
    \           if (dp(i)(j) < dp(i)(j - 1)) {dp(i)(j) = dp(i)(j - 1); prev(i)(j)\
    \ = dp(i)(j - 1)}\n                if (dp(i)(j) < dp(i - 1)(j - 1)) {dp(i)(j)\
    \ = dp(i - 1)(j - 1); prev(i)(j) = dp(i - 1)(j - 1)}\n            }\n        }\n\
    \        var ans = ListBuffer[Long]()\n        var res = 0L\n        for (i <-\
    \ N - 1 to 0 by -1) for (j <- N - 1 to 0 by -1) if (", "        // Return a tuple\
    \ (path, list of values) such that path is a list of cell\n        // coordinates,\
    \ and list of values is the ordered list of the values on\n        // the cells\
    \ that path go through.\n        def minPathHelper(grid : List[List[Long]], k\
    \ : Long, init : Tuple2[List[Long], List[Long]]) : Tuple2[List[Long], List[Long]]\
    \ = {\n            // Find the minimum value on the cells around the given cell.\n\
    \            def minValAround(grid : List[List[Long]], x : Long, y : Long) : Long\
    \ = {\n                // Return the minimum value on the cells around the given\
    \ cell.\n                // Boundary check is implemented by the caller.\n   \
    \             def minValAroundInner(grid : List[List[Long]], x : Long, y : Long)\
    \ : Long = {\n                    List(grid(x.toInt - 1)(y.toInt), grid(x.toInt\
    \ + 1)(y.toInt), grid(x.toInt)(y.toInt - 1), grid(x.toInt)(y.toInt + 1)).min\n\
    \                }\n                if (x == 0) minValAroundInner(grid, x, y)\n\
    \                else if (x == grid.length - 1) minValAroundInner(grid, x, y)\n\
    \                else if (y == 0) minValAroundInner(grid, x, y)\n            \
    \    else if (y == grid(0).length - 1) minValAroundInner(grid, x, y)\n       \
    \         else minValAroundInner(grid, x, y)\n            }\n            // Return\
    \ the minimum value on the cells around the given cell, plus\n            // a\
    \ list of its coordinates.\n            def minValAroundLst(grid : List[List[Long]],\
    \ x : Long, y : Long) : Tuple2[Long, List[Tuple2[Long, Long]]] = {\n         \
    \       // Return the minimum value on the cells around the given cell, plus\n\
    \                // a list of its coordinates.\n                // Boundary check\
    \ is implemented by the caller.\n                def minValAroundLstInner(grid\
    \ : List[List[Long]], x : Long, y : Long) : Tuple", "        // Given a grid g\
    \ and a path (i1, j1) -> (i2, j2) -> ... -> (ik, jk),\n        // check if this\
    \ path is a possible path with length k in the grid.\n        def isPossible(g\
    \ : List[List[Long]], path : List[(Int, Int)]) : Boolean = {\n            val\
    \ pathSet = Set[(Int, Int)]() ++ path\n            path.length == k.toInt && path.forall(p\
    \ => 0 <= p._1 && p._1 < g.length && 0 <= p._2 && p._2 < g.length) && \n     \
    \       path.zipWithIndex.forall(p => {\n                val prev = path(max(0,\
    \ p._2 - 1))\n                Set[(Int, Int)]((prev._1 - 1, prev._2), (prev._1\
    \ + 1, prev._2), (prev._1, prev._2 - 1), (prev._1, prev._2 + 1)).contains(p._1)\n\
    \            })\n        }\n        // We use BFS to find the shortest path from\
    \ any cell to other cells.\n        // The distance is measured using the number\
    \ of cells in the path.\n        // For each cell, the parent is the next cell\
    \ in the path.\n        def bfs(grid : List[List[Long]]) : List[List[(Int, Int)]]\
    \ = {\n            // A queue to store the cells that we need to visit.\n    \
    \        val queue = Queue[(Int, Int)]()\n            // An array to store the\
    \ distance of each cell from the source.\n            val dist = Array.fill(grid.length,\
    \ grid.length)(-1)\n            // An array to store the parent of each cell.\n\
    \            val parent = Array.fill(grid.length, grid.length)((0, 0))\n     \
    \       for (i <- 0 until grid.length; j <- 0 until grid.length) {\n         \
    \       // Initialization.\n                dist(i)(j) = 0\n                queue.enqueue((i,\
    \ j))\n            }\n            while (!queue.isEmpty) {\n                val\
    \ cur = queue.dequeue\n                // Check the possible four directions.\n\
    \                List((cur._1 - 1,", "        // Implement this function yourself\n\
    \        List[Long]()", "        // Build a map from (cell_value, cell_position)\
    \ to the minimum path leading to the cell.\n        // The cell_position is a\
    \ tuple (row, column).\n        val minPaths = new HashMap[(Long, (Int, Int)),\
    \ List[Long]]\n        for (row <- 0 until grid.length; column <- 0 until grid(row).length)\
    \ {\n            minPaths((grid(row)(column), (row, column))) = List(grid(row)(column))\n\
    \        }\n        var found = false\n        var currentPathLength = 1\n   \
    \     while (!found) {\n            // At the beginning of each iteration, all\
    \ values in the map are paths of\n            // length currentPathLength.\n \
    \           // Update the map by taking all pairs of (cell_value, cell_position)\
    \ in the\n            // map and generating new pairs by going to one of the neighbors\
    \ of the\n            // cell and extending the path by 1.\n            val updatedMinPaths\
    \ = new HashMap[(Long, (Int, Int)), List[Long]]\n            for ((cell_value,\
    \ cell_position) <- minPaths.keys) {\n                val path = minPaths(cell_value,\
    \ cell_position)\n                val row = cell_position._1\n               \
    \ val column = cell_position._2\n                val neighborPathLength = currentPathLength\
    \ + 1\n                val neighborPaths = List[List[Long]](\n               \
    \     if (row > 0) List(grid(row - 1)(column)) ++ path else path,\n          \
    \          if (row < grid.length - 1) List(grid(row + 1)(column)) ++ path else\
    \ path,\n                    if (column > 0) List(grid(row)(column - 1)) ++ path\
    \ else path,\n                    if (column < grid(row).length - 1) List(grid(row)(column\
    \ + 1)) ++ path else path\n                )\n                for (neighborPath\
    \ <- neighborPaths) {\n                    val (neighborCellValue, neighborCellPosition)\
    \ = (neighborPath.head, (row, column))\n                    // If the length of\
    \ the path is less than k, add the path to the map.\n                    if (neighborPathLength\
    \ < k) {\n                        if (!updatedMinPaths.contains(ne", "       \
    \ val n = grid.length\n        // Recursively go through the grid by looking for\
    \ all posible paths\n        // and backtrack when the path length is greater\
    \ than k.\n        def go(i : Int, j : Int, path : List[Long], visited : Set[(Int,\
    \ Int)]) : List[Long] = {\n            val cell = grid(i)(j)\n            // Add\
    \ the current cell to the path\n            val newPath = cell :: path\n     \
    \       // If the path has length k, then return the path\n            if (newPath.length\
    \ == k) return newPath\n            // Otherwise, go to the neighbors\n      \
    \      var minPath : List[Long] = null\n            for (d <- 0 until 4) {\n \
    \               val (di, dj) = if (d == 0) (1, 0) else if (d == 1) (-1, 0) else\
    \ if (d == 2) (0, 1) else (0, -1)\n                val (ni, nj) = (i + di, j +\
    \ dj)\n                if (ni >= 0 && ni < n && nj >= 0 && nj < n && !visited.contains((ni,\
    \ nj))) {\n                    val newVisited = visited + ((ni, nj))\n       \
    \             val newMinPath = go(ni, nj, newPath, newVisited)\n             \
    \       if (minPath == null || newMinPath.compare(minPath) < 0) minPath = newMinPath\n\
    \                }\n            }\n            if (minPath == null) newPath else\
    \ minPath\n        }\n        // Go to each cell and see if the path is the minimum\
    \ path\n        var ans : List[Long] = null\n        for (i <- 0 until n; j <-\
    \ 0 until n) {\n            val newPath = go(i, j, Nil, Set())\n            if\
    \ (ans == null || newPath.compare(ans) < 0) ans = newPath\n        }\n       \
    \ ans", "        val n = grid.length\n        // grid.map(x => x.toSet).foldLeft(Set[Long]())((x,\
    \ y) => x ++ y) == (1 to n * n).toSet\n        val graph = new GridGraph(grid)\n\
    \        val start = new IntPair(0, 0)\n        val end = new IntPair(n - 1, n\
    \ - 1)\n        val result = new ListBuffer[IntPair]\n        def dfs(pos : IntPair,\
    \ visited : List[IntPair], length : Long) : List[IntPair] = {\n            if\
    \ (length == k) {\n                if (result.length == 0 || compare(result.toList,\
    \ visited) < 0) {\n                    result.clear\n                    result\
    \ ++= visited\n                }\n                return visited\n           \
    \ }\n            for (neighbor <- graph.neighbors(pos)) {\n                if\
    \ (!visited.contains(neighbor)) {\n                    dfs(neighbor, neighbor\
    \ :: visited, length + 1)\n                }\n            }\n            visited\n\
    \        }\n        dfs(start, List(start), 1)\n        result.toList.map(x =>\
    \ grid(x.x)(x.y)).reverse", "        case class Coord(x : Int, y : Int)\n    \
    \    case class State(coord : Coord, valList : List[Long])\n        def getNeighbors(curState\
    \ : State) : List[State] = {\n            val curX = curState.coord.x\n      \
    \      val curY = curState.coord.y\n            val curVal = grid(curX)(curY)\n\
    \            var result = List[State]()\n            if (curX > 0) {\n       \
    \         val neighborVal = grid(curX - 1)(curY)\n                if (neighborVal\
    \ < curVal) result = State(Coord(curX - 1, curY), neighborVal :: curState.valList)\
    \ :: result\n            }\n            if (curX < grid.length - 1) {\n      \
    \          val neighborVal = grid(curX + 1)(curY)\n                if (neighborVal\
    \ < curVal) result = State(Coord(curX + 1, curY), neighborVal :: curState.valList)\
    \ :: result\n            }\n            if (curY > 0) {\n                val neighborVal\
    \ = grid(curX)(curY - 1)\n                if (neighborVal < curVal) result = State(Coord(curX,\
    \ curY - 1), neighborVal :: curState.valList) :: result\n            }\n     \
    \       if (curY < grid(0).length - 1) {\n                val neighborVal = grid(curX)(curY\
    \ + 1)\n                if (neighborVal < curVal) result = State(Coord(curX, curY\
    \ + 1), neighborVal :: curState.valList) :: result\n            }\n          \
    \  result\n        }\n        var bestState = State(Coord(0, 0), List[Long](grid(0)(0)))\n\
    \        val visited = HashSet[Coord]()\n        val neighbors = Queue[State]()\n\
    \        visited += bestState.coord\n        neighbors.enqueue(bestState)\n  \
    \      for (i <- 0 until k.toInt - 1) {\n            var foundBest = false\n \
    \           while (!neighbors.isEmpty && !foundBest) {\n                val curState\
    \ = neighbors.dequeue\n                for (neighbor <- getNeighbors(curState))",
  "        // Fill in this function.\n        val n = grid.length\n        val dp\
    \ = Array.fill(n, n)(Long.MaxValue)\n        for (i <- 0 until n) dp(i)(i) = 0\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i > 0) dp(i)(j) = min(dp(i)(j), dp(i - 1)(j) + grid(i)(j))\n    \
    \            if (j > 0) dp(i)(j) = min(dp(i)(j), dp(i)(j - 1) + grid(i)(j))\n\
    \                if (i < n - 1) dp(i)(j) = min(dp(i)(j), dp(i + 1)(j) + grid(i)(j))\n\
    \                if (j < n - 1) dp(i)(j) = min(dp(i)(j), dp(i)(j + 1) + grid(i)(j))\n\
    \            }\n        }\n        val di = Array((-1, 0), (0, -1), (1, 0), (0,\
    \ 1))\n        val r = new ArrayBuffer[Long]\n        var (x, y) = (0, 0)\n  \
    \      var counter = 0\n        while (counter < k) {\n            var (nx, ny)\
    \ = (x, y)\n            var (minv, mini) = (Long.MaxValue, -1)\n            for\
    \ (i <- 0 until 4) {\n                val (tx, ty) = (x + di(i)._1, y + di(i)._2)\n\
    \                if (tx >= 0 && tx < n && ty >= 0 && ty < n && dp(tx)(ty) + grid(tx)(ty)\
    \ < minv) {\n                    (nx, ny) = (tx, ty)\n                    (minv,\
    \ mini) = (dp(tx)(ty) + grid(tx)(ty), i)\n                }\n            }\n \
    \           r += grid(nx)(ny)\n            (x, y) = (nx, ny)\n            counter\
    \ += 1\n        }\n        r.to", "        // Implement this function.\n     \
    \   val m = grid.length\n        val n = grid(0).length\n        val offset =\
    \ 0\n        val start_point = (0, 0)\n        val vertex_num = m * n\n      \
    \  val graph = new Graph(vertex_num, start_point, offset)\n        for (i <- 0\
    \ until m) {\n            for (j <- 0 until n) {\n                if (i - 1 >=\
    \ 0) {\n                    graph.addEdge(i * n + j, (i - 1) * n + j, grid(i -\
    \ 1)(j))\n                }\n                if (i + 1 < m) {\n              \
    \      graph.addEdge(i * n + j, (i + 1) * n + j, grid(i + 1)(j))\n           \
    \     }\n                if (j - 1 >= 0) {\n                    graph.addEdge(i\
    \ * n + j, i * n + j - 1, grid(i)(j - 1))\n                }\n               \
    \ if (j + 1 < n) {\n                    graph.addEdge(i * n + j, i * n + j + 1,\
    \ grid(i)(j + 1))\n                }\n            }\n        }\n        graph.dijkstra(start_point)\n\
    \        // dp on path length\n        val dp = Array.ofDim[Int](vertex_num, k.toInt\
    \ + 1)\n        for (i <- 0 until vertex_num) {\n            dp(i)(0) = i\n  \
    \      }\n        for (i <- 1 to k.toInt) {\n            for (j <- 0 until vertex_num)\
    \ {\n                dp(j)(i) = -1\n                for (e <- graph.graph(j))\
    \ {\n                    if (graph.dist(e.to) + graph.weight(e) < graph.dist(j))\
    \ {\n                        if (dp(e.to)(i - 1) != -1) {\n                  \
    \          dp(j)(i) = e.to\n                        }\n                    }\n\
    \                }\n            }\n        }\n        val path = Array.ofDim[Int](k.toInt)\n\
    \        var cur = graph.start_point\n        for (i <- k.toInt", "        //\
    \ edge cases\n        if (k < 1) return List[Long]()\n        if (k == 1) {\n\
    \            val min = grid.flatten.min\n            val result = ListBuffer[Long]()\n\
    \            for (i <- 0 until grid.length) {\n                for (j <- 0 until\
    \ grid(i).length) {\n                    if (grid(i)(j) == min) {\n          \
    \              result += (i + 1).toLong\n                        result += (j\
    \ + 1).toLong\n                        return result.toList\n                \
    \    }\n                }\n            }\n        }\n        // general case\n\
    \        val size = grid.length\n        val graph = Array.ofDim[(Long, Long)](size,\
    \ size)\n        for (i <- 0 until size) {\n            for (j <- 0 until size)\
    \ {\n                graph(i)(j) = (grid(i)(j), 0l)\n            }\n        }\n\
    \        val visited = Array.ofDim[Boolean](size, size)\n        var min_cost\
    \ = Long.MaxValue\n        var min_path = List[Long]()\n        for (i <- 0 until\
    \ size) {\n            for (j <- 0 until size) {\n                val (curr_cost,\
    \ curr_path) = dfs(i, j, k, graph, visited)\n                if (curr_cost < min_cost)\
    \ {\n                    min_cost = curr_cost\n                    min_path =\
    \ curr_path\n                }\n            }\n        }\n        min_path", " \
    \       // grid[r][c] : r-th row, c-th column\n        // r, c : 0-indexed\n \
    \       // n : the number of rows and columns of the grid\n        val n = grid.length\n\
    \        // dp[r][c][i] : minimum path starts from grid[r][c] with length i\n\
    \        val dp = Array.ofDim[List[Long]](n, n, k.toInt + 1)\n        for (r <-\
    \ 0 until n; c <- 0 until n) {\n            if (grid(r)(c) == -1) dp(r)(c)(0)\
    \ = List[Long]()\n            else dp(r)(c)(0) = List[Long](grid(r)(c))\n    \
    \    }\n        for (i <- 1 to k.toInt) {\n            for (r <- 0 until n; c\
    \ <- 0 until n) {\n                if (grid(r)(c) == -1) dp(r)(c)(i) = List[Long]()\n\
    \                else {\n                    val l = new ListBuffer[Long]\n  \
    \                  val paths = new ListBuffer[List[Long]]\n                  \
    \  if (r - 1 >= 0 && grid(r - 1)(c) != -1) {\n                        paths +=\
    \ dp(r - 1)(c)(i - 1)\n                    }\n                    if (r + 1 <\
    \ n && grid(r + 1)(c) != -1) {\n                        paths += dp(r + 1)(c)(i\
    \ - 1)\n                    }\n                    if (c - 1 >= 0 && grid(r)(c\
    \ - 1) != -1) {\n                        paths += dp(r)(c - 1)(i - 1)\n      \
    \              }\n                    if (c + 1 < n && grid(r)(c + 1) != -1) {\n\
    \                        paths += dp(r)(c + 1)(i - 1)\n                    }\n\
    \                    for (path <- paths) {\n                        val path2\
    \ = path.map(x => x)\n                        path2 += grid(r)(c)\n          \
    \              l += path2\n                    }\n                    dp(r)(c)(i)\
    \ = l.toList.sortWith((a, b) => {\n                        for (i <-", '        null',
  "        // long answer(vector<vector<long long>> grid, long long k) {\n       \
    \ //     int n = grid.size();\n        //     vector<vector<pair<long long, int>>>\
    \ dp(n, vector<pair<long long, int>>(n, make_pair(0, 0)));\n        //     for\
    \ (int i = 0; i < n; i++) {\n        //         for (int j = 0; j < n; j++) {\n\
    \        //             dp[i][j] = make_pair(grid[i][j], (1l << (i * n + j)));\n\
    \        //         }\n        //     }\n        //     for (int steps = 1; steps\
    \ < k; steps++) {\n        //         vector<vector<pair<long long, int>>> temp(n,\
    \ vector<pair<long long, int>>(n, make_pair(0, 0)));\n        //         for (int\
    \ i = 0; i < n; i++) {\n        //             for (int j = 0; j < n; j++) {\n\
    \        //                 if (i > 0) {\n        //                     temp[i][j]\
    \ = min(temp[i][j], make_pair(dp[i][j].first + dp[i - 1][j].first, dp[i][j].second\
    \ | dp[i - 1][j].second));\n        //                 }\n        //         \
    \        if (i < n - 1) {\n        //                     temp[i][j] = min(temp[i][j],\
    \ make_pair(dp[i][j].first + dp[i + 1][j].first, dp[i][j].second | dp[i + 1][j].second));\n\
    \        //                 }\n        //                 if (j > 0) {\n     \
    \   //                     temp[i][j] = min(temp[i][j], make_pair(dp[i][j].first\
    \ + dp[i][j - 1].first, dp[i][j].second | dp[i][j - 1].second));\n        // \
    \                }\n        //                 if (j < n - 1) {\n        //  \
    \                   temp[i][j] = min(temp[i][", "        val n = grid.length\n\
    \        val node = ListBuffer[Long]()\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until n) {\n                node += grid(i)(j)\n         \
    \   }\n        }\n        node.sortWith(_ < _)\n        def find(n : Long) : Long\
    \ = {\n            var count = 0\n            for (i <- 0 until n) {\n       \
    \         count += i + 1\n            }\n            var p = n - 1\n         \
    \   while (count < n * n - k) {\n                count += p\n                p\
    \ -= 1\n            }\n            return p\n        }\n        var x = find(n)\n\
    \        var y = n - 1\n        var result = ListBuffer[Long]()\n        var count\
    \ = 0\n        while (count < k) {\n            count += 1\n            result\
    \ += grid(x)(y)\n            x += 1\n            y -= 1\n        }\n        return\
    \ result.toList", "      val N = grid.length\n      val M = grid(0).length\n \
    \     var memo = new Array[Array[Array[Long]]](N)\n      for (i <- 0 until N)\
    \ {\n        memo(i) = new Array[Array[Long]](M)\n        for (j <- 0 until M)\
    \ {\n          memo(i)(j) = new Array[Long](k.toInt + 1)\n          for (l <-\
    \ 0 to k.toInt) memo(i)(j)(l) = -1\n        }\n      }\n      def minPath(i :\
    \ Int, j : Int, n : Int) : Long = {\n        if (memo(i)(j)(n) != -1) return memo(i)(j)(n)\n\
    \        if (n == 0) return 0\n        var result = Long.MaxValue\n        if\
    \ (i > 0) result = min(result, abs(grid(i)(j) - grid(i - 1)(j)) + minPath(i -\
    \ 1, j, n - 1))\n        if (i < N - 1) result = min(result, abs(grid(i)(j) -\
    \ grid(i + 1)(j)) + minPath(i + 1, j, n - 1))\n        if (j > 0) result = min(result,\
    \ abs(grid(i)(j) - grid(i)(j - 1)) + minPath(i, j - 1, n - 1))\n        if (j\
    \ < M - 1) result = min(result, abs(grid(i)(j) - grid(i)(j + 1)) + minPath(i,\
    \ j + 1, n - 1))\n        memo(i)(j)(n) = result\n        return result\n    \
    \  }\n      var minValue = Long.MaxValue\n      var bestI = -1\n      var bestJ\
    \ = -1\n      for (i <- 0 until N) {\n        for (j <- 0 until M) {\n       \
    \   val value = minPath(i, j, k.toInt)\n          if (value < minValue) {\n  \
    \          minValue = value\n            bestI = i\n            bestJ = j\n  \
    \        }\n        }\n      }\n      var n = k.toInt\n      var i = best", " \
    \       // Create the adjacency list\n        val adj : Array[ListBuffer[Int]]\
    \ = Array.fill(grid.size * grid.size)(ListBuffer[Int]())\n        for (i <- 0\
    \ until grid.size) {\n            for (j <- 0 until grid.size) {\n           \
    \     if (i > 0) adj(i * grid.size + j) += (i - 1) * grid.size + j\n         \
    \       if (i < grid.size - 1) adj(i * grid.size + j) += (i + 1) * grid.size +\
    \ j\n                if (j > 0) adj(i * grid.size + j) += i * grid.size + j -\
    \ 1\n                if (j < grid.size - 1) adj(i * grid.size + j) += i * grid.size\
    \ + j + 1\n            }\n        }\n        // Create the neighbor list\n   \
    \     val nb : Array[ListBuffer[Int]] = Array.fill(grid.size * grid.size)(ListBuffer[Int]())\n\
    \        for (i <- 0 until grid.size) {\n            for (j <- 0 until grid.size)\
    \ {\n                for (n <- adj(i * grid.size + j)) {\n                   \
    \ for (m <- adj(n)) {\n                        if (m != i * grid.size + j) nb(i\
    \ * grid.size + j) += m\n                    }\n                }\n          \
    \  }\n        }\n        // DFS\n        var result : List[Long] = List[Long]()\n\
    \        def dfs(path : List[Long], cur : Int) {\n            if (path.size ==\
    \ k) {\n                if (result.size == 0 || path < result) result = path\n\
    \            } else {\n                for (n <- adj(cur)) {\n               \
    \     if (path.contains(grid(n / grid.size)(n % grid.size))) dfs(path, n)\n  \
    \                  else {\n                        dfs(path :+ grid(n / grid.size)(n\
    \ % grid.size), n)\n                        for (m <- nb(n)) {\n             \
    \               if (path.contains(grid(m / grid.size)(m % grid.size))) dfs(path,\
    \ m)\n                ", "        // Simply check all paths.\n        val n =\
    \ grid.length\n        def nthRow(i : Int) = grid(i).toList\n        def nthColumn(i\
    \ : Int) = grid.map(_(i)).toList\n        val paths = List.range(0, n).flatMap(i\
    \ => List.range(0, n).map(j => (i, j))).flatMap(cell => {\n            val candidates\
    \ = List(nthRow(cell._1), nthColumn(cell._2)).zipWithIndex.map(_.swap)\n     \
    \       def buildPath(candidate : (Int, List[Long]), index : Int) : List[Long]\
    \ = {\n                if (index == 0) candidate._2\n                else candidate._2\
    \ ::: buildPath(candidates(index - 1), index - 1)\n            }\n           \
    \ List.range(0, candidates.length).map(i => buildPath(candidates(i), i))\n   \
    \     })\n        def lexLess(path1 : List[Long], path2 : List[Long]) : Boolean\
    \ = {\n            if (path1.length == path2.length) {\n                if (path1.isEmpty)\
    \ false\n                else if (path1.head < path2.head) true\n            \
    \    else if (path1.head > path2.head) false\n                else lexLess(path1.tail,\
    \ path2.tail)\n            } else if (path1.length < path2.length) true\n    \
    \        else false\n        }\n        def min(path1 : List[Long], path2 : List[Long])\
    \ : List[Long] = {\n            if (lexLess(path1, path2)) path1\n           \
    \ else path2\n        }\n        val answer = paths.filter(_.length == k).foldLeft(List[Long]())(min)\n\
    \        answer", "        // Good luck!\n        var arr = Array.ofDim[Long](grid.length,\
    \ grid.length)\n        for (i <- 0 until grid.length) {\n            for (j <-\
    \ 0 until grid.length) {\n                arr(i)(j) = grid(i)(j)\n           \
    \ }\n        }\n        val visited = Array.ofDim[Boolean](grid.length, grid.length)\n\
    \        def genIndex(i : Int, j : Int) : Long = {\n            (i * grid.length\
    \ + j + 1l)\n        }\n        def getMinIndex(i : Int, j : Int) : (Int, Int)\
    \ = {\n            var min = arr(i)(j)\n            var index = (i, j)\n     \
    \       if (i > 0 && min > arr(i - 1)(j)) {\n                min = arr(i - 1)(j)\n\
    \                index = (i - 1, j)\n            }\n            if (i < grid.length\
    \ - 1 && min > arr(i + 1)(j)) {\n                min = arr(i + 1)(j)\n       \
    \         index = (i + 1, j)\n            }\n            if (j > 0 && min > arr(i)(j\
    \ - 1)) {\n                min = arr(i)(j - 1)\n                index = (i, j\
    \ - 1)\n            }\n            if (j < grid.length - 1 && min > arr(i)(j +\
    \ 1)) {\n                min = arr(i)(j + 1)\n                index = (i, j +\
    \ 1)\n            }\n            index\n        }\n        var i = 0\n       \
    \ var j = 0\n        var min = arr(i)(j)\n        var index = (i, j)\n       \
    \ while (k > 0) {\n            visited(i)(j) = true\n            index = getMinIndex(i,\
    \ j)\n            i = index._1\n            j = index._2\n            k -= 1\n\
    \        }\n        List[Long](genIndex(i, j))", "        // Your code here\n\
    \        def get(x : Int, y : Int) : Long = {\n        \tgrid(x)(y)\n        }\n\
    \        def up(x : Int, y : Int) : Boolean = {\n        \tx > 0\n        }\n\
    \        def down(x : Int, y : Int) : Boolean = {\n        \tx < grid.length -\
    \ 1\n        }\n        def left(x : Int, y : Int) : Boolean = {\n        \ty\
    \ > 0\n        }\n        def right(x : Int, y : Int) : Boolean = {\n        \t\
    y < grid(0).length - 1\n        }\n        val n = grid.length\n        val kk\
    \ = k.toInt\n        var dp = Array.ofDim[Array[List[Long]]](kk + 1, n, n)\n \
    \       for (i <- 0 until n) {\n        \tfor (j <- 0 until n) {\n        \t\t\
    dp(0)(i)(j) = List[Long]()\n        \t}\n        }\n        for (times <- 1 to\
    \ kk) {\n        \tfor (i <- 0 until n) {\n        \t\tfor (j <- 0 until n) {\n\
    \        \t\t\tdp(times)(i)(j) = List.fill(kk + 1)(-1l)\n        \t\t\tvar paths\
    \ = new ArrayBuffer[List[Long]]\n        \t\t\tif (up(i, j)) {\n        \t\t\t\
    \tpaths += get(i, j) :: dp(times - 1)(i - 1)(j)\n        \t\t\t}\n        \t\t\
    \tif (down(i, j)) {\n        \t\t\t\tpaths += get(i, j) :: dp(times - 1)(i + 1)(j)\n\
    \        \t\t\t}\n        \t\t\tif (left(i, j)) {\n        \t\t\t\tpaths += get(i,\
    \ j) :: dp(times - 1)(i)(j - 1)\n        \t\t\t}\n        \t\t\tif (right(i, j))\
    \ {\n        \t\t\t\tpaths += get(i, j) :: dp(times - 1)(i)(j + 1)\n        ",
  "        if (k == 1) {\n            var minValue = Long.MaxValue\n            var\
    \ minValueIndex = Tuple2[Int, Int](0, 0)\n            for (i <- 0 until grid.length)\
    \ {\n                for (j <- 0 until grid(i).length) {\n                   \
    \ if (grid(i)(j) < minValue) {\n                        minValue = grid(i)(j)\n\
    \                        minValueIndex = Tuple2[Int, Int](i, j)\n            \
    \        }\n                }\n            }\n            return List[Long](minValue)\n\
    \        }\n        val path = Array.ofDim[List[Long]](grid.length, grid(0).length)\n\
    \        var minLength = Long.MaxValue\n        var minLengthIndex = Tuple2[Int,\
    \ Int](0, 0)\n        val cnt = Array.ofDim[Long](k.toInt)\n        for (i <-\
    \ 0 until grid.length) {\n            for (j <- 0 until grid(i).length) {\n  \
    \              if (i == 0 && j == 0) path(i)(j) = List[Long](grid(i)(j))\n   \
    \             else {\n                    var minList = List[Long]()\n       \
    \             var minLength = Long.MaxValue\n                    if (i > 0) {\n\
    \                        var list = path(i - 1)(j)\n                        list\
    \ = list.filterNot(_ == grid(i)(j))\n                        list = list :+ grid(i)(j)\n\
    \                        if (list.length < minLength) {\n                    \
    \        minLength = list.length\n                            minList = list\n\
    \                        }\n                    }\n                    if (j >\
    \ 0) {\n                        var list = path(i)(j - 1)\n                  \
    \      list = list.filterNot(_ == grid(i)(j))\n                        list =\
    \ list :+ grid(i)(j)\n                        if (list.length < minLength) {\n\
    \                            minLength = list.length\n                       \
    \     minList = list\n                        }\n                    }\n     \
    \               path(i)(j) = minList\n                }\n                if (path(i)(j).length\
    \ == k) {\n                    var maxValue = Long.MinValue\n                \
    \    for (idx <- 0 until k.toInt) {\n                       ", "        // Fill\
    \ in the code here\n        List[Long]()", "        if (k == 1) {\n          \
    \  return List(grid.minBy(_.min).min)\n        }\n        def next(grid : List[List[Long]],\
    \ current : List[Long], row : Int, col : Int, k : Long) : List[Long] = {\n   \
    \         if (k == 0) {\n                return current\n            }\n     \
    \       if (row > 0 && grid(row - 1)(col) < grid(row)(col)) {\n              \
    \  if (current.length == 0 || grid(row - 1)(col) < current.last) {\n         \
    \           val c2 = current ++ List(grid(row - 1)(col))\n                   \
    \ return next(grid, c2, row - 1, col, k - 1)\n                }\n            }\n\
    \            if (row < grid.length - 1 && grid(row + 1)(col) < grid(row)(col))\
    \ {\n                if (current.length == 0 || grid(row + 1)(col) < current.last)\
    \ {\n                    val c2 = current ++ List(grid(row + 1)(col))\n      \
    \              return next(grid, c2, row + 1, col, k - 1)\n                }\n\
    \            }\n            if (col > 0 && grid(row)(col - 1) < grid(row)(col))\
    \ {\n                if (current.length == 0 || grid(row)(col - 1) < current.last)\
    \ {\n                    val c2 = current ++ List(grid(row)(col - 1))\n      \
    \              return next(grid, c2, row, col - 1, k - 1)\n                }\n\
    \            }\n            if (col < grid(0).length - 1 && grid(row)(col + 1)\
    \ < grid(row)(col)) {\n                if (current.length == 0 || grid(row)(col\
    \ + 1) < current.last) {\n                    val c2 = current ++ List(grid(row)(col\
    \ + 1))\n                    return next(grid, c2, row, col + 1, k - 1)\n    \
    \            }\n            }\n            return List(grid.minBy(_.min).min)\n\
    \        }\n        def cal(grid : List[List[Long]], row : Int, col : Int, k :\
    \ Long) : List[Long] = {\n", '        null', "        // val distances = Array.ofDim[Long](grid.length,\
    \ grid.length)\n        // val pq = PriorityQueue[Tuple2[Long, Tuple2[Int, Int]]]()(Ordering.by(t\
    \ => t._1))\n        // pq.enqueue((0l, (0, 0)))\n        // while (pq.nonEmpty)\
    \ {\n        //     val cur = pq.dequeue\n        //     val x = cur._2._1\n \
    \       //     val y = cur._2._2\n        //     val d = cur._1\n        //  \
    \   if (distances(x)(y) > d) {\n        //         distances(x)(y) = d\n     \
    \   //         for (newx <- max(0, x - 1) to min(grid.length - 1, x + 1); newy\
    \ <- max(0, y - 1) to min(grid.length - 1, y + 1)) {\n        //             pq.enqueue((d\
    \ + grid(newx)(newy), (newx, newy)))\n        //         }\n        //     }\n\
    \        // }\n        val bests = Array.ofDim[Tuple2[Long, List[Long]]](grid.length,\
    \ grid.length)\n        val todolists = Array.ofDim[PriorityQueue[Tuple2[Long,\
    \ List[Long]]]](grid.length, grid.length)\n        for (i <- 0 until grid.length;\
    \ j <- 0 until grid.length) {\n            todolists(i)(j) = PriorityQueue[Tuple2[Long,\
    \ List[Long]]]()(Ordering.by(t => t._1))\n            todolists(i)(j).enqueue((grid(i)(j),\
    \ List(grid(i)(j))))\n        }\n        for (l <- 1l to k) {\n            for\
    \ (i <- 0 until grid.length; j <- 0 until grid.length) {\n                val\
    \ cur = todolists(i)(j).dequeue\n                val d = cur._1\n            \
    \    val lst = cur._2\n                if (bests(i)(j) == null || bests(i)(j)._1\
    \ > d) {\n                   ", "        // Your code goes here\n        Nil",
  "        /**\n         * grid[i][j]\n         * (i, j) -> List[Long]\n         */\n\
    \        var cache = Map[(Int, Int), List[Long]]()\n        def search(i : Int,\
    \ j : Int, k : Long) : List[Long] = {\n            if (k == 0) return List[Long]()\n\
    \            if (cache.contains((i, j))) return cache((i, j))\n            var\
    \ result = List[Long]()\n            if (i + 1 < grid.length) {\n            \
    \    var r = search(i + 1, j, k - 1)\n                if (r.length == k - 1) {\n\
    \                    r = grid(i)(j) :: r\n                    if (result.length\
    \ == 0 || result > r) result = r\n                }\n            }\n         \
    \   if (i - 1 >= 0) {\n                var r = search(i - 1, j, k - 1)\n     \
    \           if (r.length == k - 1) {\n                    r = grid(i)(j) :: r\n\
    \                    if (result.length == 0 || result > r) result = r\n      \
    \          }\n            }\n            if (j + 1 < grid(i).length) {\n     \
    \           var r = search(i, j + 1, k - 1)\n                if (r.length == k\
    \ - 1) {\n                    r = grid(i)(j) :: r\n                    if (result.length\
    \ == 0 || result > r) result = r\n                }\n            }\n         \
    \   if (j - 1 >= 0) {\n                var r = search(i, j - 1, k - 1)\n     \
    \           if (r.length == k - 1) {\n                    r = grid(i)(j) :: r\n\
    \                    if (result.length == 0 || result > r) result = r\n      \
    \          }\n            }\n            cache((i, j)) = result\n            return\
    \ result\n        }\n        search(0, 0, k)", "        // BEGIN\n        List(1l)\n\
    \        // END", "        case class Point(x : Int, y : Int)\n        val gridMap\
    \ = Map[Point, Long]()\n        for (x <- 0 until grid.length) for (y <- 0 until\
    \ grid(x).length) gridMap += Point(x, y) -> grid(x)(y)\n        case class Cell(point\
    \ : Point, cost : Long) extends Ordered[Cell] {\n            def compare(that\
    \ : Cell) = this.cost.compare(that.cost)\n        }\n        case class State(cell\
    \ : Cell, restPath : List[Cell])\n        val pointSet = gridMap.keySet\n    \
    \    val neighbors = Array[Array[Cell]](Array(Cell(Point(-1, 0), 1), Cell(Point(1,\
    \ 0), 1), Cell(Point(0, -1), 1), Cell(Point(0, 1), 1)),\n            Array(Cell(Point(-1,\
    \ -1), 2), Cell(Point(-1, 1), 2), Cell(Point(1, -1), 2), Cell(Point(1, 1), 2)))\n\
    \        def isValidPoint(point : Point) = pointSet.contains(point)\n        def\
    \ getNextState(state : State) = {\n            val State(cell, restPath) = state\n\
    \            val Point(x, y) = cell.point\n            neighbors(restPath.length\
    \ % 2).map(Cell(Point(x + _.point.x, y + _.point.y), cell.cost + _.cost)).filter(p\
    \ => isValidPoint(p.point)).map(State(_, restPath))\n        }\n        def minCost(point\
    \ : Point, pathLength : Int) = {\n            if (pathLength == 1) return gridMap(point)\n\
    \            var pq = PriorityQueue[State]()(Ordering.by((state : State) => state.cell))\n\
    \            pq += State(Cell(point, 0), List(Cell(Point(0, 0), 0)))\n       \
    \     while (!pq.isEmpty) {\n                val state = pq.dequeue\n        \
    \        val State(cell, restPath) = state\n                if (restPath.length\
    \ == pathLength - 1) return cell.cost\n                getNextState(state).foreach(pq\
    \ +=", "        val n = grid.length\n        val arr = Array.ofDim[Long](n, n)\n\
    \        for (i <- 0 until n) arr(i) = grid(i).toArray\n        val used = Array.ofDim[Boolean](n,\
    \ n)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(e =>\
    \ e._1))\n        for (i <- 0 until n) for (j <- 0 until n) if (i + j == 0) pq.enqueue((arr(i)(j),\
    \ i, j))\n        var res = ArrayBuffer[Long]()\n        var (min, x, y) = (0l,\
    \ 0, 0)\n        for (i <- 0 until k.toInt) {\n            var found = false\n\
    \            while (!found) {\n                val (min, x, y) = pq.dequeue\n\
    \                if (!used(x)(y)) {\n                    found = true\n      \
    \              used(x)(y) = true\n                    res += min\n           \
    \     }\n            }\n            if (x + 1 < n && !used(x + 1)(y)) pq.enqueue((arr(x\
    \ + 1)(y), x + 1, y))\n            if (y + 1 < n && !used(x)(y + 1)) pq.enqueue((arr(x)(y\
    \ + 1), x, y + 1))\n        }\n        res.toList", '        null', "        var\
    \ p = List[(Long, Long)]()\n        for (i <- 0 until grid.length) {\n       \
    \     for (j <- 0 until grid(i).length) {\n                if (grid(i)(j) == 1)\
    \ {\n                    p = (i.toLong, j.toLong) :: p\n                }\n  \
    \          }\n        }\n        var q = PriorityQueue[(List[Long], List[(Long,\
    \ Long)])]()(Ordering.by((arg : (List[Long], List[(Long, Long)])) => arg._1))\n\
    \        q += ((List[Long](), p))\n        var h = new HashMap[(List[Long], List[(Long,\
    \ Long)]), Boolean]()\n        while (!q.isEmpty) {\n            val t = q.dequeue\n\
    \            val l = t._1\n            val ll = t._2\n            if (h.contains(t))\
    \ {\n                continue\n            }\n            h(t) = true\n      \
    \      if (l.length == k) {\n                return l\n            }\n       \
    \     val nl = ListBuffer[Long]()\n            val nll = ListBuffer[(Long, Long)]()\n\
    \            for (e <- ll) {\n                val r = e._1\n                val\
    \ c = e._2\n                val dr = List(-1l, 0l, 1l)\n                val dc\
    \ = List(-1l, 0l, 1l)\n                for (i <- 0 until dr.length) {\n      \
    \              for (j <- 0 until dc.length) {\n                        if (dr(i)\
    \ == 0 && dc(j) == 0) {\n                            continue\n              \
    \          }\n                        val nr = r + dr(i)\n                   \
    \     val nc = c + dc(j)\n                        if (nr >= 0 && nr < grid.length\
    \ && nc >= 0 && nc < grid(nr.toInt).length) {\n                            nl\
    \ += grid(nr.toInt)(nc.toInt)\n                            nll += ((nr, nc))\n\
    \                        }\n                    }\n                }\n       \
    \     }\n            for (i <- 0 until nl.length) {\n                val nnl =\
    \ nl(i) :: l\n                val n", "        // Your code goes here.\n     \
    \   var result : List[Long] = List[Long]()\n        var visited = new Array[Array[Boolean]](grid.length)\n\
    \        for (i <- 0 until grid.length) {\n            visited(i) = new Array[Boolean](grid(i).length)\n\
    \            for (j <- 0 until grid(i).length) visited(i)(j) = false\n       \
    \ }\n        def go(i : Int, j : Int, k : Long, path : List[Long]) : List[Long]\
    \ = {\n            if (k == 0) path\n            else {\n                var min\
    \ = List[Long]()\n                visited(i)(j) = true\n                for (di\
    \ <- -1 to 1) for (dj <- -1 to 1) {\n                    if ((di == 0 && dj ==\
    \ 0) || i + di < 0 || i + di >= grid.length || j + dj < 0 || j + dj >= grid(i).length\
    \ || visited(i + di)(j + dj)) {}\n                    else {\n               \
    \         val path1 = go(i + di, j + dj, k - 1, path :+ grid(i + di)(j + dj))\n\
    \                        if (min.isEmpty || path1 < min) min = path1\n       \
    \             }\n                }\n                visited(i)(j) = false\n  \
    \              min\n            }\n        }\n        for (i <- 0 until grid.length)\
    \ for (j <- 0 until grid(i).length) {\n            val path = go(i, j, k, List[Long](grid(i)(j)))\n\
    \            if (result.isEmpty || path < result) result = path\n        }\n \
    \       result", "        // Your code here\n        return List[Long]()", " \
    \       // k: the length of the path\n        // grid: contains N rows and N columns\
    \ (N >= 2) and a positive integer k\n        // each cell of the grid contains\
    \ a value. Every integer in the range [1, N * N]\n        // inclusive appears\
    \ exactly once on the cells of the grid.\n        val N = grid.length\n      \
    \  // state x, y, k\n        var dp = Array.ofDim[Long](N, N, k.toInt + 1)\n \
    \       // initialize dp\n        for (i <- 0 until N) {\n            for (j <-\
    \ 0 until N) {\n                dp(i)(j)(1) = grid(i)(j)\n            }\n    \
    \    }\n        // dp\n        for (k_ <- 2 to k.toInt) {\n            for (i\
    \ <- 0 until N) {\n                for (j <- 0 until N) {\n                  \
    \  dp(i)(j)(k_) = Long.MaxValue\n                    if (i - 1 >= 0) dp(i)(j)(k_)\
    \ = min(dp(i)(j)(k_), dp(i - 1)(j)(k_ - 1))\n                    if (i + 1 < N)\
    \ dp(i)(j)(k_) = min(dp(i)(j)(k_), dp(i + 1)(j)(k_ - 1))\n                   \
    \ if (j - 1 >= 0) dp(i)(j)(k_) = min(dp(i)(j)(k_), dp(i)(j - 1)(k_ - 1))\n   \
    \                 if (j + 1 < N) dp(i)(j)(k_) = min(dp(i)(j)(k_), dp(i)(j + 1)(k_\
    \ - 1))\n                    dp(i)(j)(k_) += grid(i)(j)\n                }\n \
    \           }\n        }\n        // find path\n        var x = 0\n        var\
    \ y = 0\n        var currentK = k.toInt\n        var result = List[Long]()\n \
    \       while (currentK >= 1) {\n            result = grid(x)(y) :: result\n \
    \           if (x - 1 >= 0 && dp(x - 1)(y)(current", "        var result = new\
    \ Array[Array[List[Long]]](grid.length)\n        for (i <- 0 until grid.length)\
    \ {\n            result(i) = new Array[List[Long]](grid(i).length)\n         \
    \   for (j <- 0 until grid(i).length) result(i)(j) = null\n        }\n       \
    \ def getNeighbors(r : Int, c : Int) : List[(Int, Int)] = {\n            var result\
    \ = List[(Int, Int)]()\n            if (r > 0) result = (r - 1, c) :: result\n\
    \            if (r < grid.length - 1) result = (r + 1, c) :: result\n        \
    \    if (c > 0) result = (r, c - 1) :: result\n            if (c < grid(r).length\
    \ - 1) result = (r, c + 1) :: result\n            result\n        }\n        def\
    \ dfs(r : Int, c : Int, k : Long) : List[Long] = {\n            if (k == 0) return\
    \ List(grid(r)(c))\n            if (result(r)(c) != null) return result(r)(c)\n\
    \            var min = List[Long]()\n            for ((nr, nc) <- getNeighbors(r,\
    \ c)) {\n                val temp = dfs(nr, nc, k - 1)\n                if (min.length\
    \ == 0 || compare(temp, min) < 0) min = temp\n            }\n            result(r)(c)\
    \ = grid(r)(c) :: min\n            result(r)(c)\n        }\n        def compare(l1\
    \ : List[Long], l2 : List[Long]) : Int = {\n            if (l1.length != l2.length)\
    \ return l1.length - l2.length\n            for (i <- 0 until l1.length) {\n \
    \               if (l1(i) < l2(i)) return -1\n                if (l1(i) > l2(i))\
    \ return 1\n            }\n            return 0\n        }\n        for (i <-\
    \ 0 until grid.length; j <- 0 until grid(i).length) dfs(i, j, k)\n        var\
    \ min = List", "        var minPath = List[Long]()\n        val matrix = new Array[Array[Long]](grid.length)\n\
    \        var i = 0\n        while (i < grid.length) {\n            matrix(i) =\
    \ grid(i).toArray\n            i += 1\n        }\n        var r = 0\n        while\
    \ (r < matrix.length) {\n            var c = 0\n            while (c < matrix(r).length)\
    \ {\n                findMinPath((r, c), k)\n                c += 1\n        \
    \    }\n            r += 1\n        }\n        return minPath\n        def findMinPath(pos\
    \ : (Int, Int), k : Long) {\n            if (k == 0) {\n                if (minPath.length\
    \ == 0) minPath = List(matrix(pos._1)(pos._2))\n                else {\n     \
    \               if (minPath(0) > matrix(pos._1)(pos._2)) minPath = List(matrix(pos._1)(pos._2))\n\
    \                }\n            }\n            else {\n                val r =\
    \ pos._1\n                val c = pos._2\n                val cands = if (r >\
    \ 0) List((r - 1, c)) else List() ++ \n                                if (r <\
    \ matrix.length - 1) List((r + 1, c)) else List() ++ \n                      \
    \          if (c > 0) List((r, c - 1)) else List() ++ \n                     \
    \           if (c < matrix(r).length - 1) List((r, c + 1)) else List()\n     \
    \           var minCand = List[Long]()\n                var i = 0\n          \
    \      while (i < cands.length) {\n                    findMinPath(cands(i), k\
    \ - 1)\n                    if (minCand.length == 0) minCand = minPath\n     \
    \               else {\n                        if (minCand(0) > minPath(0)) minCand\
    \ = minPath\n                    }\n                    i += 1\n             \
    \   }\n                minPath = List(matrix(pos._1)(pos._2)) ++ minCand\n   \
    \         }\n        }", "        val inf = 1000000000l\n        val n = grid.length\n\
    \        var f = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until n) {\n                f(i)(j) = List[Long](grid(i)(j))\n\
    \            }\n        }\n        for (x <- 1 until k.toInt) {\n            var\
    \ g = Array.fill(n, n)(List[Long]())\n            for (i <- 0 until n) {\n   \
    \             for (j <- 0 until n) {\n                    var lst = List[Long]()\n\
    \                    if (i > 0) lst = min(lst, f(i - 1)(j) :+ grid(i)(j))\n  \
    \                  if (i < n - 1) lst = min(lst, f(i + 1)(j) :+ grid(i)(j))\n\
    \                    if (j > 0) lst = min(lst, f(i)(j - 1) :+ grid(i)(j))\n  \
    \                  if (j < n - 1) lst = min(lst, f(i)(j + 1) :+ grid(i)(j))\n\
    \                    g(i)(j) = lst\n                }\n            }\n       \
    \     f = g\n        }\n        var result = List[Long]()\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until n) {\n                result = min(result,\
    \ f(i)(j))\n            }\n        }\n        result", "        // Build up the\
    \ graph\n        val n = grid.length\n        val hm = HashMap[Long, HashSet[Long]]()\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        hm += (grid(i)(j) -> HashSet[Long]())\n            }\n        }\n   \
    \     for (i <- 0 until n) {\n            for (j <- 0 until n) {\n           \
    \     for (di <- -1 to 1) {\n                    for (dj <- -1 to 1) {\n     \
    \                   if (abs(di) + abs(dj) != 1) {\n                          \
    \  continue\n                        }\n                        val pi = i + di\n\
    \                        val pj = j + dj\n                        if (pi < 0 ||\
    \ pi >= n || pj < 0 || pj >= n) {\n                            continue\n    \
    \                    }\n                        val v = grid(i)(j)\n         \
    \               val pv = grid(pi)(pj)\n                        hm(v) += pv\n \
    \                   }\n                }\n            }\n        }\n        //\
    \ Find the minimum path using Dijkstra's algorithm\n        val queue = PriorityQueue[State]()\n\
    \        queue += State(1, List[Long](grid(0)(0)))\n        while (!queue.isEmpty)\
    \ {\n            val state = queue.dequeue\n            if (state.k == k) {\n\
    \                return state.list\n            }\n            for (v <- hm(state.current))\
    \ {\n                queue += State(state.k + 1, state.list :+ v)\n          \
    \  }\n        }\n        throw new NoSuchElementException", "        // Implement\
    \ this function\n        List()", "        val N = grid.length\n        var dp\
    \ = Array.ofDim[String](N, N, k.toInt + 1)\n        def solve(x : Int, y : Int,\
    \ z : Int) : String = {\n            if (z < 0) return null\n            if (dp(x)(y)(z)\
    \ != null) return dp(x)(y)(z)\n            if (z == 0) return grid(x)(y).toString\n\
    \            var l = \"\"\n            var r = \"\"\n            var u = \"\"\n\
    \            var d = \"\"\n            if (x > 0) l = solve(x - 1, y, z - 1)\n\
    \            if (x < N - 1) r = solve(x + 1, y, z - 1)\n            if (y > 0)\
    \ u = solve(x, y - 1, z - 1)\n            if (y < N - 1) d = solve(x, y + 1, z\
    \ - 1)\n            var arr = List[String](l, r, u, d)\n            arr = arr.filter(_\
    \ != null)\n            if (arr.isEmpty) return null\n            var min = arr.reduce((a,\
    \ b) => if (a < b) a else b)\n            dp(x)(y)(z) = grid(x)(y).toString +\
    \ min\n            return dp(x)(y)(z)\n        }\n        var result = \"\"\n\
    \        for (i <- 0 until N) for (j <- 0 until N) {\n            var tmp = solve(i,\
    \ j, k.toInt)\n            if (tmp != null && (result == \"\" || tmp < result))\
    \ result = tmp\n        }\n        return result.map(_.toLong - '0').toList",
  "        var rowNum = grid.length\n        var colNum = grid(0).length\n       \
    \ var dp = Array.ofDim[Long](rowNum, colNum, k.toInt + 1)\n        for (i <- 0\
    \ until rowNum) for (j <- 0 until colNum) for (l <- 0 to k.toInt) dp(i)(j)(l)\
    \ = Long.MaxValue\n        for (i <- 0 until rowNum) for (j <- 0 until colNum)\
    \ dp(i)(j)(1) = grid(i)(j)\n        for (l <- 2 to k.toInt) {\n            for\
    \ (i <- 0 until rowNum) {\n                for (j <- 0 until colNum) {\n     \
    \               var minval = Long.MaxValue\n                    if (i - 1 >= 0)\
    \ minval = min(minval, dp(i - 1)(j)(l - 1))\n                    if (i + 1 < rowNum)\
    \ minval = min(minval, dp(i + 1)(j)(l - 1))\n                    if (j - 1 >=\
    \ 0) minval = min(minval, dp(i)(j - 1)(l - 1))\n                    if (j + 1\
    \ < colNum) minval = min(minval, dp(i)(j + 1)(l - 1))\n                    dp(i)(j)(l)\
    \ = minval + grid(i)(j)\n                }\n            }\n        }\n       \
    \ var i = 0\n        var j = 0\n        var result = new ListBuffer[Long]\n  \
    \      for (l <- 1 to k.toInt) {\n            result += grid(i)(j)\n         \
    \   var minval = Long.MaxValue\n            var ni = i\n            var nj = j\n\
    \            if (i - 1 >= 0) if (dp(i - 1)(j)(l) < minval) {minval = dp(i - 1)(j)(l);\
    \ ni = i - 1; nj = j}\n            if (i + 1 < rowNum) if (dp(i + 1)(j)(l) < minval)\
    \ {minval = dp(i + 1)(j)(l); ni = i + 1; nj = j}\n            if (j -", "    \
    \    // Your code here\n        grid", "        val n = grid.length\n        val\
    \ init = ListBuffer[Long]()\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until n) {\n                if (grid(i)(j) == 1) init += grid(i)(j)\n \
    \           }\n        }\n        var state = Set[(ListBuffer[Long], Int, Int)]()\n\
    \        state += Tuple3(init, 0, 0)\n        while (true) {\n            val\
    \ next = Set[(ListBuffer[Long], Int, Int)]()\n            for (s <- state) {\n\
    \                val (path, x, y) = s\n                if (path.length == k) return\
    \ path.toList\n                if (x > 0) next += Tuple3(path += grid(x - 1)(y),\
    \ x - 1, y)\n                if (x < n - 1) next += Tuple3(path += grid(x + 1)(y),\
    \ x + 1, y)\n                if (y > 0) next += Tuple3(path += grid(x)(y - 1),\
    \ x, y - 1)\n                if (y < n - 1) next += Tuple3(path += grid(x)(y +\
    \ 1), x, y + 1)\n            }\n            val sp = next.toList.sortWith(cmp)\n\
    \            state = Set[(ListBuffer[Long], Int, Int)]()\n            state +=\
    \ sp(0)\n        }\n        return List[Long]()", "        // Write your code\
    \ here\n        var list = new Array[(Long, (Int, Int))]((grid.length * grid.length).toInt)\n\
    \        var index = 0\n        for (i <- 0 until grid.length) {\n           \
    \ for (j <- 0 until grid.length) {\n                list(index) = (grid(i)(j),\
    \ (i, j))\n                index += 1\n            }\n        }\n        list\
    \ = list.sortWith(_._1 < _._1)\n        var ans = Long.MaxValue\n        var result\
    \ = List[Long]()\n        for (i <- 0 until list.length) {\n            var t\
    \ = dfs(grid, list(i)._2._1, list(i)._2._2, k, list(i)._1)\n            if (t._1\
    \ != -1 && t._1 < ans) {\n                ans = t._1\n                result =\
    \ t._2\n            }\n        }\n        result", "        val N = grid.length\n\
    \        val M = grid(0).length\n        var minimumPath = List[Long]()\n    \
    \    for (i <- 1 to N) {\n            for (j <- 1 to M) {\n                minimumPath\
    \ :+= grid(i - 1)(j - 1)\n            }\n        }\n        for (i <- 1 to N *\
    \ M) {\n            for (j <- 1 to N * M) {\n                if (i != j) {\n \
    \                   var flag = true\n                    for (l <- 1 to k) {\n\
    \                        if (flag) {\n                            if (minimumPath(l\
    \ - 1) != minimumPath(l - 1)) flag = false\n                        }\n      \
    \              }\n                    if (flag) {\n                        if\
    \ (minimumPath(i - 1) < minimumPath(j - 1)) {\n                            val\
    \ temp = minimumPath(i - 1)\n                            minimumPath(i - 1) =\
    \ minimumPath(j - 1)\n                            minimumPath(j - 1) = temp\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        minimumPath.take(k.toInt)", '        ???', "     \
    \   if (k == 1) return (1l :: Nil)\n        val n = grid.length\n        val m\
    \ = new Array[Array[Tuple2[Long, List[Long]]]](n)\n        for (i <- 0 until n)\
    \ m(i) = new Array[Tuple2[Long, List[Long]]](n)\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until n) {\n                val x = grid(i)(j)\n\
    \                if (x == 1) m(i)(j) = (0l, 1l :: Nil)\n                else {\n\
    \                    var (c, l) = (Long.MaxValue, Nil : List[Long])\n        \
    \            if (i - 1 >= 0) {\n                        val v = m(i - 1)(j)\n\
    \                        if (v._1 < c) {\n                            c = v._1\n\
    \                            l = v._2\n                        }\n           \
    \         }\n                    if (j - 1 >= 0) {\n                        val\
    \ v = m(i)(j - 1)\n                        if (v._1 < c) {\n                 \
    \           c = v._1\n                            l = v._2\n                 \
    \       }\n                    }\n                    m(i)(j) = (c + 1, l :::\
    \ (x :: Nil))\n                }\n            }\n        }\n        val ans =\
    \ m(n - 1)(n - 1)\n        if (ans._1 > k) return List[Long]()\n        return\
    \ ans._2", "        // Use Dijkstra algorithm to find the path with shortest sum\n\
    \        val allNodes = grid.flatten.sorted\n        val numRow = grid.length\n\
    \        val numCol = grid(0).length\n        val minGraph = new Graph(allNodes.length,\
    \ numRow * numCol * numRow * numCol)\n        for (i <- 0 until numRow; j <- 0\
    \ until numCol) {\n            val node = grid(i)(j)\n            if (i > 0) {\n\
    \                val neighbor = grid(i - 1)(j)\n                minGraph.addEdge(allNodes.indexOf(node),\
    \ allNodes.indexOf(neighbor), abs(node - neighbor))\n            }\n         \
    \   if (i < numRow - 1) {\n                val neighbor = grid(i + 1)(j)\n   \
    \             minGraph.addEdge(allNodes.indexOf(node), allNodes.indexOf(neighbor),\
    \ abs(node - neighbor))\n            }\n            if (j > 0) {\n           \
    \     val neighbor = grid(i)(j - 1)\n                minGraph.addEdge(allNodes.indexOf(node),\
    \ allNodes.indexOf(neighbor), abs(node - neighbor))\n            }\n         \
    \   if (j < numCol - 1) {\n                val neighbor = grid(i)(j + 1)\n   \
    \             minGraph.addEdge(allNodes.indexOf(node), allNodes.indexOf(neighbor),\
    \ abs(node - neighbor))\n            }\n        }\n        val path = minGraph.dijkstra(allNodes.indexOf(grid(0)(0)),\
    \ (k - 1).toInt)\n        return path.map(allNodes(_))", "        // Write your\
    \ code here\n        List()", "        val n = grid.length\n        // paths :\
    \ (x, y, depth, path)\n        var paths = PriorityQueue[(Int, Int, Int, List[Long])]()((a,\
    \ b) => {\n            if (a._3 != b._3) {\n                a._3 < b._3\n    \
    \        } else {\n                a._4 < b._4\n            }\n        })\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until n) {\n          \
    \      paths += ((i, j, 1, List(grid(i)(j))))\n            }\n        }\n    \
    \    while (paths.nonEmpty) {\n            val best = paths.dequeue\n        \
    \    if (best._3 < k) {\n                for (i <- 0 until 4) {\n            \
    \        val x = best._1 + Array(-1, 0, 1, 0)(i)\n                    val y =\
    \ best._2 + Array(0, 1, 0, -1)(i)\n                    if (x >= 0 && x < n &&\
    \ y >= 0 && y < n) {\n                        paths += ((x, y, best._3 + 1, best._4\
    \ :+ grid(x)(y)))\n                    }\n                }\n            } else\
    \ {\n                return best._4\n            }\n        }\n        List()",
  "        val n = grid.length\n        val m = grid(0).length\n        var dp = Array.ofDim[Long](n,\
    \ m, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt)\
    \ {\n            dp(i)(j)(l) = -1\n        }\n        val dirs = List((0, 1),\
    \ (0, -1), (1, 0), (-1, 0))\n        def recur(i : Int, j : Int, l : Int) : Long\
    \ = {\n            if (l == 0) return 0\n            if (dp(i)(j)(l) != -1) return\
    \ dp(i)(j)(l)\n            var ans = Long.MaxValue\n            for (dir <- dirs)\
    \ {\n                val u = i + dir._1\n                val v = j + dir._2\n\
    \                if (u >= 0 && u < n && v >= 0 && v < m) {\n                 \
    \   ans = min(ans, recur(u, v, l - 1) + grid(u)(v))\n                }\n     \
    \       }\n            dp(i)(j)(l) = ans\n            return ans\n        }\n\
    \        def find(i : Int, j : Int, l : Int) : List[Long] = {\n            if\
    \ (l == 0) return List(grid(i)(j))\n            var minv = Long.MaxValue\n   \
    \         var minlst = List[Long]()\n            for (dir <- dirs) {\n       \
    \         val u = i + dir._1\n                val v = j + dir._2\n           \
    \     if (u >= 0 && u < n && v >= 0 && v < m) {\n                    val vv =\
    \ recur(u, v, l - 1) + grid(u)(v)\n                    if (vv < minv) {\n    \
    \                    minv = vv\n                        minlst = find(u, v, l\
    \ - 1) :+ grid(u)(v)\n                    }\n                }\n            }\n\
    \            return minlst\n        }\n        for (i <- 0 until n; j <- 0 until\
    \ m) {\n            recur(i, j, k.toInt)\n", "        /**\n         * Returns\
    \ the coordinates of a cell in a row-major form.\n         */\n        def coord(r\
    \ : Int, c : Int) : Int = {\n            return r * grid.size + c\n        }\n\
    \        /**\n         * Returns a list of neighbors of a cell.\n         */\n\
    \        def neighbors(r : Int, c : Int) : List[Int] = {\n            return List((r\
    \ - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)).filter(p => p._1 >= 0 && p._1 <\
    \ grid.size && p._2 >= 0 && p._2 < grid.size).map(p => coord(p._1, p._2))\n  \
    \      }\n        /**\n         * Computes the shortest paths to all cells.\n\
    \         */\n        def dijkstra(s : Int) : Array[Array[Int]] = {\n        \
    \    val d = Array.fill(grid.size, grid.size)(Int.MaxValue)\n            val pq\
    \ = new scala.collection.mutable.PriorityQueue[(Int, Int)]()(Ordering.by[(Int,\
    \ Int), Int](x => -x._2))\n            pq.enqueue((s, 0))\n            while (!pq.isEmpty)\
    \ {\n                val (v, dis) = pq.dequeue\n                val r = v / grid.size\n\
    \                val c = v % grid.size\n                if (dis < d(r)(c)) {\n\
    \                    d(r)(c) = dis\n                    for (u <- neighbors(r,\
    \ c)) {\n                        pq.enqueue((u, dis + 1))\n                  \
    \  }\n                }\n            }\n            return d\n        }\n    \
    \    /**\n         * Computes the lexicographically minimum path of length k,\
    \ starts from the cell with minimum value.\n         */\n        def compute(s\
    \ : Int, k : Long) : List[Long] = {\n            val d = dijkstra(s)\n       \
    \     val pq = new scala.collection.mutable.PriorityQueue[(List[Long], Int)]()(Ordering.by[(List[Long],\
    \ Int), List[Long]](x => x._1))", "        val n = grid.length\n        var ans\
    \ = Array.fill(k.toInt)(0l)\n        var min_val = 0l\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until n) {\n                if (grid(i)(j) < min_val)\
    \ {\n                    ans(0) = grid(i)(j)\n                    min_val = grid(i)(j)\n\
    \                }\n            }\n        }\n        for (i <- 1 until k.toInt)\
    \ {\n            min_val = 0l\n            for (x <- 0 until n) {\n          \
    \      for (y <- 0 until n) {\n                    if (grid(x)(y) > ans(i - 1)\
    \ && grid(x)(y) < min_val) {\n                        ans(i) = grid(x)(y)\n  \
    \                      min_val = grid(x)(y)\n                    }\n         \
    \       }\n            }\n        }\n        ans.toList", "        val n = grid.length\n\
    \        var minPath = new Queue[Long]\n        var minValue = 0l\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                val\
    \ curValue = grid(i)(j)\n                if (curValue < minValue) {\n        \
    \            minPath.clear\n                    minPath += curValue\n        \
    \            minValue = curValue\n                } else if (curValue == minValue)\
    \ {\n                    minPath += curValue\n                }\n            }\n\
    \        }\n        minPath.toList", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val hash = Array.fill(n, m)((0, 0))\n        var\
    \ min = Long.MaxValue\n        var minPath = List.empty[Long]\n        def dfs(i\
    \ : Int, j : Int, curr : Long, count : Int, path : List[Long]) {\n           \
    \ if (i < 0 || i >= n || j < 0 || j >= m) return\n            if (hash(i)(j)._1\
    \ == count) {\n                if (hash(i)(j)._2 < curr) return\n            \
    \    else hash(i)(j) = (count, curr)\n            }\n            else hash(i)(j)\
    \ = (count, curr)\n            if (count == k) {\n                if (curr < min)\
    \ {\n                    min = curr\n                    minPath = path\n    \
    \            }\n                return\n            }\n            dfs(i - 1,\
    \ j, curr * 10 + grid(i)(j), count + 1, path :+ grid(i)(j))\n            dfs(i\
    \ + 1, j, curr * 10 + grid(i)(j), count + 1, path :+ grid(i)(j))\n           \
    \ dfs(i, j - 1, curr * 10 + grid(i)(j), count + 1, path :+ grid(i)(j))\n     \
    \       dfs(i, j + 1, curr * 10 + grid(i)(j), count + 1, path :+ grid(i)(j))\n\
    \        }\n        for (i <- 0 until n; j <- 0 until m) {\n            dfs(i,\
    \ j, grid(i)(j), 1, List(grid(i)(j)))\n        }\n        minPath", "        val\
    \ n = grid.length\n        // Node Information\n        // (node value, row, column)\n\
    \        val nodeList = ArrayBuffer.fill(n * n)((0l, 0, 0))\n        // Store\
    \ the neighbors of each node\n        val neighbors = ArrayBuffer.fill(n * n)(ArrayBuffer[(Long,\
    \ Int, Int)]())\n        // Nodes that are visited so far\n        val visited\
    \ = ArrayBuffer[(Long, Int, Int)]()\n        // To store the paths\n        val\
    \ paths = ArrayBuffer[List[Long]]()\n        // To maintain the result\n     \
    \   var result = List[Long]()\n        // To store the minimum path\n        var\
    \ minPath = List[Long]()\n        // The number of edges in the graph is 2 * n\
    \ * n - n - n\n        // So the time complexity is O(|E|) = O(2 * n * n - n -\
    \ n) = O(n^2)\n        // Considering we are using a priority queue\n        //\
    \ So the time complexity is O(|E| * log(|E|)) = O(n^2 * log(n^2))\n        //\
    \ = O(n^2 * 2 * log(n)) = O(n^2 * log(n))\n        // Also the space complexity\
    \ is O(n^2)\n        for (i <- 0 until n) {\n            for (j <- 0 until n)\
    \ {\n                val value = grid(i)(j)\n                val index = i * n\
    \ + j\n                nodeList(index) = (value, i, j)\n                // Find\
    \ the neighbor nodes\n                // Left neighbor\n                if (j\
    \ - 1 >= 0) {\n                    neighbors(index) += nodeList(index - 1)\n \
    \               }\n                // Right neighbor\n                if (j +\
    \ 1 < n) {\n                    neighbors(index) += nodeList(index + 1)\n    \
    \            }\n                // Upper neighbor\n                if (i - 1 >=\
    \ 0) {\n                    neighbors(index) += nodeList(index - n)\n        \
    \        }\n                // Lower neighbor\n                if (i + 1 < n)\
    \ {\n                    neighbors(index) += nodeList(index + n)\n           \
    \     }\n            }\n        }\n        // Dijkstra's algorithm", '        ???',
  "        val m = grid.length\n        val n = grid(0).length\n        var dp = ListBuffer[ListBuffer[Long]]()\n\
    \        for (i <- 0 until m) {\n            dp += ListBuffer[Long]()\n      \
    \      for (j <- 0 until n) {\n                dp(i) += (1l << 60)\n         \
    \   }\n        }\n        val q = Queue[(Int, Int, Long)]()\n        for (i <-\
    \ 0 until m) {\n            for (j <- 0 until n) {\n                dp(i)(j) =\
    \ grid(i)(j)\n                q.enqueue((i, j, 0))\n            }\n        }\n\
    \        while (!q.isEmpty) {\n            val (i, j, c) = q.dequeue\n       \
    \     if (c < k) {\n                if (i > 0 && dp(i - 1)(j) > dp(i)(j)) {\n\
    \                    dp(i - 1)(j) = dp(i)(j)\n                    q.enqueue((i\
    \ - 1, j, c + 1))\n                }\n                if (i < m - 1 && dp(i +\
    \ 1)(j) > dp(i)(j)) {\n                    dp(i + 1)(j) = dp(i)(j)\n         \
    \           q.enqueue((i + 1, j, c + 1))\n                }\n                if\
    \ (j > 0 && dp(i)(j - 1) > dp(i)(j)) {\n                    dp(i)(j - 1) = dp(i)(j)\n\
    \                    q.enqueue((i, j - 1, c + 1))\n                }\n       \
    \         if (j < n - 1 && dp(i)(j + 1) > dp(i)(j)) {\n                    dp(i)(j\
    \ + 1) = dp(i)(j)\n                    q.enqueue((i, j + 1, c + 1))\n        \
    \        }\n            }\n        }\n        val mn = (1l << 60)\n        var\
    \ ret = ListBuffer[Long]()\n        for (i <- 0 until m) {\n            for (j\
    \ <- 0 until n) {\n                if (", "        val N = grid.length\n     \
    \   if (N == 1) return List(grid(0)(0))\n        val map = scala.collection.mutable.HashMap[Long,\
    \ Int]()\n        var counter = 0\n        for (x <- 0 until N) {\n          \
    \  for (y <- 0 until N) {\n                map += (grid(x)(y) -> counter)\n  \
    \              counter += 1\n            }\n        }\n        val dist = Array.ofDim[Int](N\
    \ * N, N * N)\n        for (x <- 0 until N) {\n            for (y <- 0 until N)\
    \ {\n                for (x1 <- 0 until N) {\n                    for (y1 <- 0\
    \ until N) {\n                        dist(map(grid(x)(y)))(map(grid(x1)(y1)))\
    \ = (x - x1).abs + (y - y1).abs\n                    }\n                }\n  \
    \          }\n        }\n        val graph = new Graph(N * N)\n        for (x\
    \ <- 0 until N) {\n            for (y <- 0 until N) {\n                for (x1\
    \ <- 0 until N) {\n                    for (y1 <- 0 until N) {\n             \
    \           if (dist(map(grid(x)(y)))(map(grid(x1)(y1))) == 1) graph.addEdge(map(grid(x)(y)),\
    \ map(grid(x1)(y1)))\n                    }\n                }\n            }\n\
    \        }\n        var result = List[Long]()\n        val all = graph.shortestPath(0,\
    \ N * N - 1, k)\n        for (x <- all) result = grid(x / N)(x % N) :: result\n\
    \        result", "        val n = grid.length\n        if (n == 0) return List()\n\
    \        // (1) Build the adjacent table:\n        val adjacent = Array.ofDim[List[Int]](n\
    \ * n)\n        for (i <- 0 until n) for (j <- 0 until n) {\n            val cur\
    \ = i * n + j\n            adjacent(cur) = List[Int]()\n            if (i > 0)\
    \ adjacent(cur) = (cur - n) :: adjacent(cur)\n            if (i < n - 1) adjacent(cur)\
    \ = (cur + n) :: adjacent(cur)\n            if (j > 0) adjacent(cur) = (cur -\
    \ 1) :: adjacent(cur)\n            if (j < n - 1) adjacent(cur) = (cur + 1) ::\
    \ adjacent(cur)\n        }\n        // (2) Use Dynamic Programming:\n        val\
    \ dp = Array.ofDim[List[Long]](n * n)\n        for (i <- 0 until n * n) dp(i)\
    \ = List(grid(i / n)(i % n))\n        for (i <- 1 until k.toInt) for (j <- 0 until\
    \ n * n) for (x <- adjacent(j)) {\n            val l = grid(j / n)(j % n) :: dp(x)\n\
    \            if (dp(j) == null || isLessThan(l, dp(j))) dp(j) = l\n        }\n\
    \        return dp(0)", "      val g = grid.transpose\n      def h(grid : List[List[Long]],\
    \ k : Long) : List[Long] = {\n        if (k == 1) {\n          val a = grid.map(_.min).toList\n\
    \          a.zipWithIndex.minBy(_._1)._2 :: a.min :: Nil\n        } else {\n \
    \         val a = grid.map(_.min).toList\n          val b = grid.map(_.min).toList\n\
    \          val m = a.min\n          val l = b.zipWithIndex.filter(_._1 == m).map(_._2).toList\n\
    \          if (k == l.size) l\n          else {\n            var d = new HashMap[Int,\
    \ List[Long]]\n            for (i <- l) {\n              val t = (i :: h(grid.map(_.filter(_\
    \ != m)).filter(_.size > 0), k - 1)).reverse\n              if (!d.contains(t.hashCode))\
    \ d += (t.hashCode -> t)\n            }\n            d.values.toList.minBy(_.toString)\n\
    \          }\n        }\n      }\n      h(g, k).map(g(0)(_)).reverse", "     \
    \   if (k <= 0) List[Long]()\n        else {\n            val n = grid.length\n\
    \            val total = n * n\n            if (k > total) List[Long]()\n    \
    \        else {\n                var gridx = Array.ofDim[Long](n, n)\n       \
    \         for (i <- 0 until n) gridx(i) = grid(i).toArray\n                var\
    \ min = n * n\n                var minlist = List[Long]()\n                for\
    \ (i <- 0 until n) {\n                    for (j <- 0 until n) {\n           \
    \             val tmp = Array.ofDim[Long](n, n)\n                        for (i\
    \ <- 0 until n) tmp(i) = gridx(i).clone\n                        var list = List[Long]()\n\
    \                        var cnt = 0\n                        var x = i\n    \
    \                    var y = j\n                        while (cnt < k) {\n  \
    \                          list = list :+ tmp(x)(y)\n                        \
    \    tmp(x)(y) = 0\n                            val can = check(x, y, n, tmp)\n\
    \                            if (can._1 == -1) break\n                       \
    \     else {\n                                x = can._1\n                   \
    \             y = can._2\n                            }\n                    \
    \        cnt += 1\n                        }\n                        if (cnt\
    \ == k) {\n                            if (list.toSet.size < min) {\n        \
    \                        min = list.toSet.size\n                             \
    \   minlist = list\n                            }\n                          \
    \  else if (list.toSet.size == min) {\n                                if (list\
    \ < minlist) minlist = list\n                            }\n                 \
    \       }\n                    }\n                }\n                minlist\n\
    \            }\n        }", "        val n = grid.length\n        val dp = Array.fill(n)(Array.fill(n)(LONG_MAX))\n\
    \        for (i <- 0 until n) dp(i)(i) = 0\n        for (l <- 1 until n) {\n \
    \           for (i <- 0 until n) {\n                val j = (i + l) % n\n    \
    \            for (k <- i until j) {\n                    val m = (k + 1) % n\n\
    \                    dp(i)(j) = min(dp(i)(j), dp(i)(k) + dp(m)(j) + grid(i)(k)\
    \ + grid(m)(j))\n                }\n            }\n        }\n        val min_index\
    \ = dp.map(_.min).zipWithIndex.min._2\n        var res = new ListBuffer[Long]\n\
    \        var i = min_index\n        var j = min_index\n        for (k <- 0 until\
    \ k.toInt) {\n            res += grid(i)(j)\n            j = (j + 1) % n\n   \
    \         if (j == i) {\n                j = (j + 1) % n\n            }\n    \
    \        i = (i + 1) % n\n        }\n        res.toList", '        return (List[Long]())',
  "        var n = grid.length\n        var dp = Array.ofDim[Long](n, n, n * n)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        for (l <- 0 until n * n) {\n                    dp(i)(j)(l) = Long.MaxValue\n\
    \                }\n            }\n        }\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until n) {\n                dp(i)(j)(0) = grid(i)(j)\n\
    \            }\n        }\n        var min = Long.MaxValue\n        var min_path\
    \ = List[Long]()\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ n) {\n                if (i > 0) {\n                    for (l <- 0 until n\
    \ * n) {\n                        if (l == n * n - 1) {\n                    \
    \        dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l))\n                   \
    \     } else {\n                            dp(i)(j)(l + 1) = min(dp(i)(j)(l +\
    \ 1), dp(i - 1)(j)(l))\n                        }\n                    }\n   \
    \             }\n                if (j > 0) {\n                    for (l <- 0\
    \ until n * n) {\n                        if (l == n * n - 1) {\n            \
    \                dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l))\n           \
    \             } else {\n                            dp(i)(j)(l + 1) = min(dp(i)(j)(l\
    \ + 1), dp(i)(j - 1)(l))\n                        }\n                    }\n \
    \               }\n                if (i < n - 1) {\n                    for (l\
    \ <- 0 until n * n) {\n                        if (l == n * n - 1) {\n       \
    \                     dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l))\n      \
    \                  } else {\n                            dp(i)(j)(l + 1) = min",
  '        null', "        val n = grid.length\n        val cellValues = new Array[Long](n\
    \ * n)\n        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n \
    \               cellValues(n * i + j) = grid(i)(j)\n            }\n        }\n\
    \        cellValues.sortWith(_ < _)\n        val minPaths = new Array[Array[Int]](n\
    \ * n)\n        for (i <- 0 until n * n) {\n            minPaths(i) = new Array[Int](n\
    \ * n)\n            for (j <- 0 until n * n) {\n                minPaths(i)(j)\
    \ = Int.MaxValue\n            }\n        }\n        val visited = new Array[Array[Boolean]](n)\n\
    \        for (i <- 0 until n) {\n            visited(i) = new Array[Boolean](n)\n\
    \            for (j <- 0 until n) {\n                visited(i)(j) = false\n \
    \           }\n        }\n        def dfs(i : Int, j : Int, steps : Int) {\n \
    \           if (steps < minPaths(i)(j)) {\n                minPaths(i)(j) = steps\n\
    \                for (newI <- max(0, i - 1) to min(n - 1, i + 1)) {\n        \
    \            for (newJ <- max(0, j - 1) to min(n - 1, j + 1)) {\n            \
    \            if (!visited(newI)(newJ)) {\n                            visited(newI)(newJ)\
    \ = true\n                            dfs(newI, newJ, steps + 1)\n           \
    \                 visited(newI)(newJ) = false\n                        }\n   \
    \                 }\n                }\n            }\n        }\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                visited(i)(j)\
    \ = true\n                dfs(i, j, 0)\n                visited(i)(j) = false\n\
    \            }\n        }\n        def getMinPath(idx : Int, steps : Int) : List[Long]\
    \ = {\n            if (steps >= k) List[Long]()\n            else {\n        \
    \        var minJ = -1\n", "        val n = grid.length\n        val dp = Array.fill(n)(Array.fill(n)(List[Long]()))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        val x = grid(i)(j)\n                var min = Long.MaxValue\n       \
    \         if (i > 0) {\n                    val y = grid(i - 1)(j)\n         \
    \           if (x <= y) {\n                        if (x < y) {\n            \
    \                min = x\n                        } else {\n                 \
    \           min = x min y\n                        }\n                    }\n\
    \                }\n                if (j > 0) {\n                    val y =\
    \ grid(i)(j - 1)\n                    if (x <= y) {\n                        if\
    \ (x < y) {\n                            min = x\n                        } else\
    \ {\n                            min = x min y\n                        }\n  \
    \                  }\n                }\n                if (i < n - 1) {\n  \
    \                  val y = grid(i + 1)(j)\n                    if (x <= y) {\n\
    \                        if (x < y) {\n                            min = x\n \
    \                       } else {\n                            min = x min y\n\
    \                        }\n                    }\n                }\n       \
    \         if (j < n - 1) {\n                    val y = grid(i)(j + 1)\n     \
    \               if (x <= y) {\n                        if (x < y) {\n        \
    \                    min = x\n                        } else {\n             \
    \               min = x min y\n                        }\n                   \
    \ }\n                }\n                if (min == Long.MaxValue) {\n        \
    \            dp(i)(j) = List(x)\n                } else {\n                  \
    \  dp(i)(j) = min :: x :: Nil\n                }\n            }\n        }\n \
    \       var ret = List[Long]()\n        var x = (0, 0)\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until n) {\n                if (dp(i)(j).length\
    \ > ret.length) {\n                    ret = dp(i)(j)\n                    x =\
    \ (i, j)\n                }\n            }\n        }\n        for (i <- 1 to\
    \ k.toInt - 1) {\n            val", "        def getNeighbors(row : Int, col :\
    \ Int) : List[(Int, Int)] = {\n            val n = grid.length\n            var\
    \ res = List[(Int, Int)]()\n            if (row - 1 >= 0) res ::= (row - 1, col)\n\
    \            if (row + 1 < n) res ::= (row + 1, col)\n            if (col - 1\
    \ >= 0) res ::= (row, col - 1)\n            if (col + 1 < n) res ::= (row, col\
    \ + 1)\n            res\n        }\n        def dfs(row : Int, col : Int, left\
    \ : Long, current : List[Long]) : List[Long] = {\n            if (left == 0) current\n\
    \            else {\n                val neighbors = getNeighbors(row, col)\n\
    \                val res = neighbors.map(t => dfs(t._1, t._2, left - 1, grid(t._1)(t._2)\
    \ :: current)).sortWith((lst1, lst2) => lst1.mkString < lst2.mkString)\n     \
    \           res.head\n            }\n        }\n        val l = grid.length\n\
    \        dfs(0, 0, k, List[Long](grid(0)(0)))", "        var move = Array.ofDim[List[Long]](grid.length,\
    \ grid.length)\n        for (i <- 0 until grid.length) {\n            for (j <-\
    \ 0 until grid.length) {\n                move(i)(j) = List(grid(i)(j))\n    \
    \        }\n        }\n        for (l <- 1 until k.toInt) {\n            for (i\
    \ <- 0 until grid.length) {\n                for (j <- 0 until grid.length) {\n\
    \                    val n1 = if (i > 0) move(i - 1)(j) else Nil\n           \
    \         val n2 = if (i < grid.length - 1) move(i + 1)(j) else Nil\n        \
    \            val n3 = if (j > 0) move(i)(j - 1) else Nil\n                   \
    \ val n4 = if (j < grid.length - 1) move(i)(j + 1) else Nil\n                \
    \    val possible = List(n1, n2, n3, n4).filter(x => x != Nil).map(x => grid(i)(j)\
    \ :: x).sortBy(x => x.reverse)\n                    move(i)(j) = possible(0)\n\
    \                }\n            }\n        }\n        var result = List[Long]()\n\
    \        for (i <- 0 until grid.length) {\n            for (j <- 0 until grid.length)\
    \ {\n                if (result == Nil || move(i)(j).reverse < result.reverse)\
    \ result = move(i)(j)\n            }\n        }\n        result", "        var\
    \ row = grid.length\n        var col = grid(0).length\n        var i = 0\n   \
    \     var j = 0\n        var current = grid(0)(0)\n        var last = grid(0)(0)\n\
    \        var table = Array.ofDim[List[Long]](row, col)\n        while (i < row)\
    \ {\n            j = 0\n            while (j < col) {\n                table(i)(j)\
    \ = List[Long]()\n                j += 1\n            }\n            i += 1\n\
    \        }\n        i = 0\n        j = 0\n        table(0)(0) = List[Long](current)\n\
    \        var k1 = k - 1\n        while (k1 > 0) {\n            if (i == 0) {\n\
    \                if (j == 0) {\n                    if (grid(i)(j + 1) < grid(i\
    \ + 1)(j)) {\n                        current = grid(i)(j + 1)\n             \
    \           j += 1\n                    } else {\n                        current\
    \ = grid(i + 1)(j)\n                        i += 1\n                    }\n  \
    \              } else if (j == col - 1) {\n                    if (grid(i)(j -\
    \ 1) < grid(i + 1)(j)) {\n                        current = grid(i)(j - 1)\n \
    \                       j -= 1\n                    } else {\n               \
    \         current = grid(i + 1)(j)\n                        i += 1\n         \
    \           }\n                } else {\n                    if (grid(i)(j - 1)\
    \ < grid(i)(j + 1)) {\n                        if (grid(i)(j - 1) < grid(i + 1)(j))\
    \ {\n                            current = grid(i)(j - 1)\n                  \
    \          j -= 1\n                        } else {\n                        \
    \    current = grid(i + 1)(j)\n                            i += 1\n          \
    \              }\n                    } else {\n                        if (grid(i)(j\
    \ + 1) < grid(i + 1)(j)) {\n                            current = grid(i)(j +\
    \ 1)\n                            j += 1\n                        } else {\n \
    \                           current = grid(i + 1)(j)\n                       \
    \     i += 1\n                        }\n                    }\n             \
    \   }\n            } else if (i == row - 1", "        // Time: O(n^2)\n      \
    \  // Space: O(n^2)\n        val n = grid.length\n        val dist = Array.ofDim[Long](n,\
    \ n)\n        val sx = Array.ofDim[Long](n, n)\n        val sy = Array.ofDim[Long](n,\
    \ n)\n        var minDist = Long.MaxValue\n        var minX = 0\n        var minY\
    \ = 0\n        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n  \
    \              val d = if (i == 0 && j == 0) 0 else {\n                    val\
    \ up = if (i > 0) dist(i - 1)(j) else Long.MaxValue\n                    val left\
    \ = if (j > 0) dist(i)(j - 1) else Long.MaxValue\n                    val min\
    \ = min(up, left)\n                    if (min == Long.MaxValue) min else min\
    \ + 1\n                }\n                dist(i)(j) = d\n                if (d\
    \ < minDist) {\n                    minDist = d\n                    minX = i\n\
    \                    minY = j\n                }\n                sx(i)(j) = -1\n\
    \                sy(i)(j) = -1\n                if (d == up) {\n             \
    \       sx(i)(j) = i - 1\n                    sy(i)(j) = j\n                }\n\
    \                if (d == left) {\n                    sx(i)(j) = i\n        \
    \            sy(i)(j) = j - 1\n                }\n            }\n        }\n \
    \       val result = ListBuffer[Long]()\n        var x = minX\n        var y =\
    \ minY\n        for (i <- 0 until k.toInt) {\n            result += grid(x)(y)\n\
    \            val x1 = sx(x)(y)\n            val y1 = sy(x)(y)\n            x =\
    \ x1\n            y = y1\n        }\n        result.toList", "        if (k ==\
    \ 1) {\n            var minValue = Long.MaxValue\n            var minRow = 0\n\
    \            var minCol = 0\n            for (row <- 0 until grid.length) {\n\
    \                for (col <- 0 until grid(row).length) {\n                   \
    \ if (grid(row)(col) < minValue) {\n                        minValue = grid(row)(col)\n\
    \                        minRow = row\n                        minCol = col\n\
    \                    }\n                }\n            }\n            List(grid(minRow)(minCol))\n\
    \        } else {\n            val graph = Array.ofDim[(List[Long], List[Long])](grid.length,\
    \ grid(0).length)\n            for (row <- 0 until grid.length) {\n          \
    \      for (col <- 0 until grid(row).length) {\n                    var minPaths\
    \ = List[List[Long]]()\n                    if (row > 0) {\n                 \
    \       val candidate = (minPath(List(grid(row - 1)(col)) :: graph(row - 1)(col)._1,\
    \ k - 1), (row - 1, col))\n                        if (minPaths.isEmpty || candidate._1\
    \ < minPaths.head) {\n                            minPaths = List(candidate._1)\n\
    \                        } else if (candidate._1 == minPaths.head) {\n       \
    \                     minPaths ::= candidate._1\n                        }\n \
    \                   }\n                    if (row < grid.length - 1) {\n    \
    \                    val candidate = (minPath(List(grid(row + 1)(col)) :: graph(row\
    \ + 1)(col)._1, k - 1), (row + 1, col))\n                        if (minPaths.isEmpty\
    \ || candidate._1 < minPaths.head) {\n                            minPaths = List(candidate._1)\n\
    \                        } else if (candidate._1 == minPaths.head) {\n       \
    \                     minPaths ::= candidate._1\n                        }\n \
    \                   }\n                    if (col > 0) {\n                  \
    \      val candidate = (minPath(List(grid(row)(col - 1)) :: graph(row)(col - 1)._1,\
    \ k - 1), (row, col - 1))\n                        if (minPaths.isEmpty || candidate._1\
    \ < min", "        def connect(x : Long, y : Long) : Map[Long, List[Long]] = {\n\
    \            val x_ = x % n\n            val y_ = y % n\n            if (x_ <\
    \ 0 || y_ < 0 || x_ >= n || y_ >= n) return Map[Long, List[Long]]()\n        \
    \    val v = grid(x_)(y_)\n            if (v < 1 || v > m) return Map[Long, List[Long]]()\n\
    \            if (Map(x * n + y -> List(v)).contains(v)) Map(x * n + y -> List(v))\n\
    \            else Map(x * n + y -> List(v)) ++ connect(x + 1, y) ++ connect(x\
    \ - 1, y) ++ connect(x, y + 1) ++ connect(x, y - 1)\n        }\n        val n\
    \ = grid.length\n        val m = n * n\n        var g = Map[Long, List[Long]]()\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        g ++= connect(i, j)\n            }\n        }\n        var (x, y) = (-1l,\
    \ -1l)\n        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n \
    \               if (g(i * n + j).length == m) {\n                    x = i\n \
    \                   y = j\n                }\n            }\n        }\n     \
    \   val dx = List(-1, 0, 1, 0)\n        val dy = List(0, 1, 0, -1)\n        val\
    \ visit = Array.fill(n, n)(false)\n        val q = Queue[(Long, Long, Long, List[Long])]()\n\
    \        q.enqueue((x, y, 0, List[Long]()))\n        visit(x.toInt)(y.toInt) =\
    \ true\n        while (!q.isEmpty) {\n            val (x, y, c, l) = q.dequeue\n\
    \            if (c == k) return l\n            for (i <- 0 until 4) {\n      \
    \          val x_ = x + dx(i)\n                val y_ = y +", "        // Finding\
    \ all valid min paths of lengths k, 1 <= k <= grid.size * grid.size.\n       \
    \ // DP.\n        val minPaths = new Array[List[List[Long]]](((grid.size * grid.size)\
    \ + 1).toInt)\n        // Define a comparator.\n        def compare(path1 : List[Long],\
    \ path2 : List[Long]) : Boolean = {\n            for (i <- 0 until path1.size)\
    \ {\n                if (path1(i) != path2(i)) return path1(i) < path2(i)\n  \
    \          }\n            false\n        }\n        // Define an equality comparator.\n\
    \        def compareTo(path1 : List[Long], path2 : List[Long]) : Boolean = {\n\
    \            for (i <- 0 until path1.size) {\n                if (path1(i) !=\
    \ path2(i)) return false\n            }\n            true\n        }\n       \
    \ // Finding all paths of length 1.\n        for (i <- 0 until grid.size) {\n\
    \            for (j <- 0 until grid.size) {\n                minPaths(1) = minPaths(1)\
    \ :+ List[Long](grid(i)(j))\n            }\n        }\n        // Finding all\
    \ paths of length > 1.\n        for (length <- 2 to grid.size * grid.size) {\n\
    \            // Preparing the temporary storage.\n            val minPathsLength\
    \ = new ArrayBuffer[List[Long]]\n            // For each path of length length\
    \ - 1.\n            for (lastPath <- minPaths(length - 1)) {\n               \
    \ val row = lastPath.last.toInt / grid.size\n                val col = lastPath.last.toInt\
    \ % grid.size\n                if (row - 1 >= 0) {\n                    val path\
    \ = lastPath :+ (grid(row - 1)(col))\n                    // If the path is not\
    \ already in the temporary storage.\n                    if (!minPathsLength.contains(path))\
    \ {\n                        // Insert the path into the temporary storage.\n\
    \                        minPathsLength += path\n                    }\n     \
    \           }\n                if (row + 1 < grid.size) {\n                  \
    \  val path = lastPath :+ (grid(row + 1)(col", "        val n = grid.length\n\
    \        val visited = Array.fill(n, n)(false)\n        val values = Array.fill(n,\
    \ n)(Long.MaxValue)\n        val pq = PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        pq.enqueue((grid(i)(j), i, j))\n                values(i)(j) = grid(i)(j)\n\
    \            }\n        }\n        var count = 0\n        var result = List[Long]()\n\
    \        while (count < k) {\n            val item = pq.dequeue\n            val\
    \ value = item._1\n            val i = item._2\n            val j = item._3\n\
    \            val xs = List((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1))\n \
    \           if (!visited(i)(j)) {\n                visited(i)(j) = true\n    \
    \            count += 1\n                result = result :+ value\n          \
    \      for (x <- xs) {\n                    val xi = x._1\n                  \
    \  val xj = x._2\n                    if (xi >= 0 && xi < n && xj >= 0 && xj <\
    \ n && !visited(xi)(xj)) {\n                        if (values(xi)(xj) > value)\
    \ {\n                            pq.enqueue((value, xi, xj))\n               \
    \             values(xi)(xj) = value\n                        }\n            \
    \        }\n                }\n            }\n        }\n        result", "  \
    \      // Your code here\n        var grid_ = new Array[Array[Long]](grid.length)\n\
    \        for (i <- 0 until grid.length) {\n            grid_(i) = new Array[Long](grid(i).length)\n\
    \            for (j <- 0 until grid(i).length) {\n                grid_(i)(j)\
    \ = grid(i)(j)\n            }\n        }\n        var heap = new Array[(Int, Int,\
    \ Long)](grid.length * grid(0).length + 1)\n        var count = 0\n        def\
    \ lessThan(a : (Int, Int, Long), b : (Int, Int, Long)) : Boolean = {\n       \
    \     if (a._3 != b._3) a._3 < b._3\n            else if (a._1 != b._1) a._1 <\
    \ b._1\n            else a._2 < b._2\n        }\n        def swap(a : Int, b :\
    \ Int) {\n            var tmp = heap(a)\n            heap(a) = heap(b)\n     \
    \       heap(b) = tmp\n        }\n        def push(index : Int) {\n          \
    \  if (index == 0) return\n            if (lessThan(heap(index), heap(index /\
    \ 2))) {\n                swap(index, index / 2)\n                push(index /\
    \ 2)\n            }\n        }\n        def pop() {\n            var i = 1\n \
    \           while (i * 2 <= count) {\n                var left = i * 2\n     \
    \           var right = i * 2 + 1\n                if (left <= count && right\
    \ <= count) {\n                    if (lessThan(heap(left), heap(right))) {\n\
    \                        if (lessThan(heap(left), heap(i))) {\n              \
    \              swap(left, i)\n                            i = left\n         \
    \               } else return\n                    } else {\n                \
    \        if (lessThan(heap(right), heap(i))) {\n                            swap(right,\
    \ i)\n                            i = right\n                        } else return\n\
    \                    }\n                } else if (left <= count) {\n        \
    \            if (lessThan(heap(left), heap(i))) {\n                        swap(left,\
    \ i)\n                        i = left", "        if (k == 1) {\n            var\
    \ g = grid\n            var min = 1000000000000000l\n            var minrow =\
    \ 0\n            var mincol = 0\n            for (row <- 0 until g.length) {\n\
    \                for (col <- 0 until g(row).length) {\n                    if\
    \ (g(row)(col) < min) {\n                        min = g(row)(col)\n         \
    \               minrow = row\n                        mincol = col\n         \
    \           }\n                }\n            }\n            return List(g(minrow)(mincol))\n\
    \        }\n        var grid2 : Array[Array[Int]] = Array.ofDim[Int](grid.length,\
    \ grid(0).length)\n        for (row <- 0 until grid.length) {\n            for\
    \ (col <- 0 until grid(row).length) {\n                grid2(row)(col) = grid(row)(col).toInt\n\
    \            }\n        }\n        var grid3 : Array[Array[Int]] = Array.ofDim[Int](grid.length,\
    \ grid(0).length)\n        for (row <- 0 until grid.length) {\n            for\
    \ (col <- 0 until grid(row).length) {\n                grid3(row)(col) = 100000000\n\
    \            }\n        }\n        for (row <- 0 until grid.length) {\n      \
    \      for (col <- 0 until grid(row).length) {\n                var grid4 : Array[Array[Int]]\
    \ = Array.ofDim[Int](grid.length, grid(0).length)\n                for (row2 <-\
    \ 0 until grid.length) {\n                    for (col2 <- 0 until grid(row2).length)\
    \ {\n                        grid4(row2)(col2) = 100000000\n                 \
    \   }\n                }\n                grid4(row)(col) = grid2(row)(col)\n\
    \                var queue : List[(Int, Int)] = List()\n                queue\
    \ ::= (row, col)\n                while (queue.length > 0) {\n               \
    \     var cur = queue.head\n                    queue = queue.tail\n         \
    \           if (cur._1 > 0) {\n                        if (grid4(cur._1 - 1)(cur._2)\
    \ > grid4(cur._1)(cur._2) + grid2(cur._1 - 1)(", "        val row = grid.length\n\
    \        val col = grid(0).length\n        val max = row * col\n        val s\
    \ = grid.flatten.sorted\n        def dfs(k : Long, r : Int, c : Int, lst : List[Long])\
    \ : List[Long] = {\n            if (k == 0) return lst\n            else {\n \
    \               val l = ListBuffer[Long]()\n                if (r - 1 >= 0 &&\
    \ grid(r - 1)(c) > lst.last) l += grid(r - 1)(c)\n                if (r + 1 <\
    \ row && grid(r + 1)(c) > lst.last) l += grid(r + 1)(c)\n                if (c\
    \ - 1 >= 0 && grid(r)(c - 1) > lst.last) l += grid(r)(c - 1)\n               \
    \ if (c + 1 < col && grid(r)(c + 1) > lst.last) l += grid(r)(c + 1)\n        \
    \        if (l.isEmpty) return Nil\n                var min = l(0)\n         \
    \       var ans = Nil\n                for (x <- l) {\n                    val\
    \ tmp = dfs(k - 1, s.indexOf(x) / col, s.indexOf(x) % col, x :: lst)\n       \
    \             if (tmp != Nil && (min > x || (min == x && tmp.last < ans.last)))\
    \ {\n                        min = x\n                        ans = tmp\n    \
    \                }\n                }\n                return ans\n          \
    \  }\n        }\n        return dfs(k, s.indexOf(1) / col, s.indexOf(1) % col,\
    \ List(1l))", '        return null;', "        val n = grid.length\n        val\
    \ m = grid(0).length\n        var adj = Array.ofDim[List[(Int, Int)]](n, m)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        adj(i)(j) = List[(Int, Int)]()\n                if (i - 1 >= 0) adj(i)(j)\
    \ = (i - 1, j) :: adj(i)(j)\n                if (i + 1 < n) adj(i)(j) = (i + 1,\
    \ j) :: adj(i)(j)\n                if (j - 1 >= 0) adj(i)(j) = (i, j - 1) :: adj(i)(j)\n\
    \                if (j + 1 < m) adj(i)(j) = (i, j + 1) :: adj(i)(j)\n        \
    \    }\n        }\n        var dist = Array.ofDim[Long](n, m)\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                dist(i)(j)\
    \ = Long.MaxValue\n            }\n        }\n        dist(0)(0) = 0\n        var\
    \ q = Queue[(Int, Int)]()\n        q.enqueue((0, 0))\n        while (!q.isEmpty)\
    \ {\n            val (i, j) = q.dequeue\n            for ((pi, pj) <- adj(i)(j))\
    \ {\n                if (dist(pi)(pj) > dist(i)(j) + 1) {\n                  \
    \  dist(pi)(pj) = dist(i)(j) + 1\n                    q.enqueue((pi, pj))\n  \
    \              }\n            }\n        }\n        def find(i : Int, j : Int,\
    \ k : Long) : List[Long] = {\n            if (k == 0) List(grid(i)(j))\n     \
    \       else {\n                val next = adj(i)(j).filter(pair => dist(pair._1)(pair._2)\
    \ == dist(i)(j) - 1).map(pair => (pair._1, pair._2, find(pair._1, pair._2, k -\
    \ 1)))\n                next", '        null', "        // A path is represented\
    \ by a tuple (coords, valList).\n        // coords is a list of coordinates of\
    \ the cells that the path go through.\n        // valList is the ordered list\
    \ of the values on the cells that the path go through.\n        // Each path is\
    \ extended (by one step) to its four neighbors.\n        // The extended paths\
    \ are added to the priority queue.\n        // The process is repeated until we\
    \ have k paths (in the priority queue).\n        // If we have more than k paths\
    \ at some point of the execution, we remove the worst path.\n        // If a path\
    \ is extended to a cell that it has already been through, it is removed.\n   \
    \     // The first path (added to the priority queue) starts from the cell in\
    \ the first row\n        // and first column.\n        // In each step we remove\
    \ the best path from the priority queue.\n        // If we have k paths and the\
    \ current path is worse than all the paths we have,\n        // we do not extend\
    \ it.\n        val N = grid.length\n        val M = grid(0).length\n        val\
    \ pq = new PriorityQueue[(List[(Int, Int)], List[Long])]()(Ordering.by[(List[(Int,\
    \ Int)], List[Long]), (List[Long], Boolean)](path => (path._2, path._1.length\
    \ < k)))\n        pq += ((List((0, 0)), List(grid(0)(0))))\n        while (pq.length\
    \ < k) {\n            val (coords, valList) = pq.dequeue\n            val (r,\
    \ c) = coords.last\n            if (r + 1 < N) {\n                val newPath\
    \ = (coords :+ (r + 1, c), valList :+ grid(r + 1)(c))\n                if (!coords.contains((r\
    \ + 1, c))) {\n                    pq += newPath\n                }\n        \
    \    }\n            if (c + 1 < M) {\n                val newPath = (coords :+\
    \ (r, c + 1), valList :+ grid(r)(c + 1))\n                if (!coords.contains((r,\
    \ c + 1))) {\n                    pq += newPath\n                }\n         \
    \   }", "        val n = grid.length\n        var result = List[(List[Long], Long)]()\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        val visited = HashSet[(Int, Int)]()\n                val queue = Queue[(List[Long],\
    \ Long, (Int, Int))]()\n                queue.enqueue((List[Long](grid(i)(j)),\
    \ 1l, (i, j)))\n                while (!queue.isEmpty) {\n                   \
    \ val path = queue.dequeue\n                    val cur_grid = path._3\n     \
    \               val p = path._1\n                    val cur_len = path._2\n \
    \                   if (cur_len == k) {\n                        result = (p,\
    \ 0l) :: result\n                    } else {\n                        val x =\
    \ cur_grid._1\n                        val y = cur_grid._2\n                 \
    \       if (x - 1 >= 0 && !visited.contains((x - 1, y))) {\n                 \
    \           visited.add((x - 1, y))\n                            queue.enqueue((p\
    \ :+ grid(x - 1)(y), cur_len + 1, (x - 1, y)))\n                        }\n  \
    \                      if (x + 1 < n && !visited.contains((x + 1, y))) {\n   \
    \                         visited.add((x + 1, y))\n                          \
    \  queue.enqueue((p :+ grid(x + 1)(y), cur_len + 1, (x + 1, y)))\n           \
    \             }\n                        if (y - 1 >= 0 && !visited.contains((x,\
    \ y - 1))) {\n                            visited.add((x, y - 1))\n          \
    \                  queue.enqueue((p :+ grid(x)(y - 1), cur_len + 1, (x, y - 1)))\n\
    \                        }\n                        if (y + 1 < n && !visited.contains((x,\
    \ y + 1))) {\n                            visited.add((x, y + 1))\n          \
    \                  queue.enqueue((p :+ grid(x)(y + 1), cur_len + 1, (x, y + 1)))\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        result = result.sortWith((a,", "        // Your code\
    \ here\n        return null", "        var memo = new HashMap[Tuple2[Tuple2[Int,\
    \ Int], Long], Tuple2[Long, List[Long]]]()\n        def minPath(i : Int, j : Int,\
    \ k : Long) : Tuple2[Long, List[Long]] = {\n            if (memo.contains(Tuple2(Tuple2(i,\
    \ j), k))) {\n                memo(Tuple2(Tuple2(i, j), k))\n            } else\
    \ {\n                var res = Tuple2(Long.MaxValue, List[Long]())\n         \
    \       if (k == 0) {\n                    res = Tuple2(0, List[Long]())\n   \
    \             } else {\n                    if (i > 0) {\n                   \
    \     val subres = minPath(i - 1, j, k - 1)\n                        if (subres._1\
    \ < res._1 || (subres._1 == res._1 && (grid(i - 1)(j) :: subres._2) < res._2))\
    \ {\n                            res = Tuple2(subres._1, grid(i - 1)(j) :: subres._2)\n\
    \                        }\n                    }\n                    if (i <\
    \ grid.length - 1) {\n                        val subres = minPath(i + 1, j, k\
    \ - 1)\n                        if (subres._1 < res._1 || (subres._1 == res._1\
    \ && (grid(i + 1)(j) :: subres._2) < res._2)) {\n                            res\
    \ = Tuple2(subres._1, grid(i + 1)(j) :: subres._2)\n                        }\n\
    \                    }\n                    if (j > 0) {\n                   \
    \     val subres = minPath(i, j - 1, k - 1)\n                        if (subres._1\
    \ < res._1 || (subres._1 == res._1 && (grid(i)(j - 1) :: subres._2) < res._2))\
    \ {\n                            res = Tuple2(subres._1, grid(i)(j - 1) :: subres._2)\n\
    \                        }\n                    }\n                    if (j <\
    \ grid(0).length - 1) {\n                        val subres = minPath(i, j +",
  "        val R = grid.length\n        val C = grid(0).length\n        val ans :\
    \ ListBuffer[Long] = new ListBuffer\n        // dp(i)(j)(l) represents the minimum\
    \ path of length l starting from grid(i)(j).\n        // It is equal to null if\
    \ such a path doesn't exist.\n        val dp : Array[Array[Array[List[Long]]]]\
    \ = Array.ofDim[List[Long]](R, C, k.toInt + 1)\n        val r = minPathHelper(grid,\
    \ dp, k.toInt, 0, 0)\n        if (r == null) null else r.reverse", "        //\
    \ The idea is to use a priority queue to store the paths that are\n        //\
    \ currently being explored (this is very much like Dijkstra's algorithm\n    \
    \    // for shortest path problem). We keep exploring the path with the smallest\n\
    \        // smallest head value until we find the solution, or we have no solution.\n\
    \        var cellValues = List[Long]()\n        var gridSize = grid.length\n \
    \       for (i <- 0 until gridSize) {\n            for (j <- 0 until gridSize)\
    \ {\n                cellValues = cellValues :+ grid(i)(j)\n            }\n  \
    \      }\n        cellValues = cellValues.sorted\n        var pq = PriorityQueue[Path]()(PathOrdering)\n\
    \        var path = new Path(List[Long](), new GridPoint(0, 0), grid, k)\n   \
    \     path.explore()\n        pq.enqueue(path)\n        while (!pq.isEmpty) {\n\
    \            var p = pq.dequeue()\n            if (p.isSolution()) {\n       \
    \         return p.path\n            }\n            else {\n                p.explore()\n\
    \                pq.enqueue(p)\n            }\n        }\n        return List[Long]()",
  "        val N = grid.length\n        // Answer\n        val ans = ListBuffer[Long]()\n\
    \        // row, col, min_path, remaining\n        val queue = Queue[(Int, Int,\
    \ List[Long], Long)]()\n        // Iterate through all cells of the grid\n   \
    \     for (row <- 0 until N; col <- 0 until N) {\n            queue.enqueue((row,\
    \ col, List(grid(row)(col)), k - 1))\n        }\n        while (!queue.isEmpty)\
    \ {\n            val (row, col, path, remain) = queue.dequeue\n            if\
    \ (remain == 0) {\n                if (ans.isEmpty || ans > path) ans.clear; ans\
    \ ++= path\n            } else {\n                // Try going down\n        \
    \        if (row < N - 1) {\n                    queue.enqueue((row + 1, col,\
    \ path :+ grid(row + 1)(col), remain - 1))\n                }\n              \
    \  // Try going right\n                if (col < N - 1) {\n                  \
    \  queue.enqueue((row, col + 1, path :+ grid(row)(col + 1), remain - 1))\n   \
    \             }\n                // Try going up\n                if (row > 0)\
    \ {\n                    queue.enqueue((row - 1, col, path :+ grid(row - 1)(col),\
    \ remain - 1))\n                }\n                // Try going left\n       \
    \         if (col > 0) {\n                    queue.enqueue((row, col - 1, path\
    \ :+ grid(row)(col - 1), remain - 1))\n                }\n            }\n    \
    \    }\n        ans.toList", "        // Your code here...\n        Nil", "  \
    \      var n = grid.length\n        var a = Array.fill(n, n)(0)\n        for (i\
    \ <- 0 until n) for (j <- 0 until n) a(i)(j) = grid(i)(j).toInt\n        val dp\
    \ = Array.fill(n, n, n * n + 1)(Int.MaxValue)\n        dp(0)(0)(1) = a(0)(0)\n\
    \        val q = Queue((0, 0, 1))\n        while (!q.isEmpty) {\n            val\
    \ i = q.head._1\n            val j = q.head._2\n            val step = q.head._3\n\
    \            q.dequeue\n            if (i > 0) {\n                if (step + 1\
    \ <= n * n && dp(i - 1)(j)(step + 1) > dp(i)(j)(step) + a(i - 1)(j)) {\n     \
    \               dp(i - 1)(j)(step + 1) = dp(i)(j)(step) + a(i - 1)(j)\n      \
    \              q.enqueue((i - 1, j, step + 1))\n                }\n          \
    \  }\n            if (i < n - 1) {\n                if (step + 1 <= n * n && dp(i\
    \ + 1)(j)(step + 1) > dp(i)(j)(step) + a(i + 1)(j)) {\n                    dp(i\
    \ + 1)(j)(step + 1) = dp(i)(j)(step) + a(i + 1)(j)\n                    q.enqueue((i\
    \ + 1, j, step + 1))\n                }\n            }\n            if (j > 0)\
    \ {\n                if (step + 1 <= n * n && dp(i)(j - 1)(step + 1) > dp(i)(j)(step)\
    \ + a(i)(j - 1)) {\n                    dp(i)(j - 1)(step + 1) = dp(i)(j)(step)\
    \ + a(i)(j - 1)\n                    q.enqueue((i, j - 1, step + 1))\n       \
    \         }\n            }\n            if (j < n - 1) {\n                if (step\
    \ + 1", "        val f = Array.ofDim[Long](grid.length, grid.length)\n       \
    \ val s = Array.ofDim[Long](grid.length, grid.length)\n        for (i <- 0 until\
    \ grid.length) for (j <- 0 until grid.length) {\n            if (i == 0 && j ==\
    \ 0) {\n                f(i)(j) = grid(i)(j)\n                s(i)(j) = grid(i)(j)\n\
    \            } else if (i == 0) {\n                f(i)(j) = f(i)(j - 1) + grid(i)(j)\n\
    \                s(i)(j) = s(i)(j - 1) + grid(i)(j)\n            } else if (j\
    \ == 0) {\n                f(i)(j) = f(i - 1)(j) + grid(i)(j)\n              \
    \  s(i)(j) = s(i - 1)(j) + grid(i)(j)\n            } else {\n                f(i)(j)\
    \ = min(f(i - 1)(j), f(i)(j - 1)) + grid(i)(j)\n                s(i)(j) = max(s(i\
    \ - 1)(j), s(i)(j - 1)) + grid(i)(j)\n            }\n        }\n        val ans\
    \ = new ListBuffer[Long]\n        var i = grid.length - 1\n        var j = grid.length\
    \ - 1\n        while (k > 0) {\n            if (i == 0 && j == 0) {\n        \
    \        ans += grid(i)(j)\n                k -= 1\n            } else if (i ==\
    \ 0) {\n                ans += grid(i)(j)\n                j -= 1\n          \
    \      k -= 1\n            } else if (j == 0) {\n                ans += grid(i)(j)\n\
    \                i -= 1\n                k -= 1\n            } else {\n      \
    \          if (f(i - 1)(j) <= f(i)(j - 1)) {\n                    ans += grid(i)(j)\n\
    \                    i -= 1\n                    k -= 1\n                } else\
    \ {\n                    ans += grid(i)(j)\n                    j -= 1\n     \
    \               k -= 1\n                }\n            }\n", "        val gridx\
    \ = grid.map(_.toArray).toArray\n        // returns the cell that has the least\
    \ value among all of the cells (x, y)\n        // such that 1 <= x <= N and 1\
    \ <= y <= N.\n        def leastValueCell() : (Int, Int) = {\n            var x\
    \ = 0\n            var y = 0\n            var value = Long.MaxValue\n        \
    \    for (i <- 0 until gridx.length) {\n                for (j <- 0 until gridx(i).length)\
    \ {\n                    if (gridx(i)(j) < value) {\n                        x\
    \ = i\n                        y = j\n                        value = gridx(i)(j)\n\
    \                    }\n                }\n            }\n            (x, y)\n\
    \        }\n        // returns a pair of a cell and a list of its neighbors\n\
    \        def neighbors(t : (Int, Int)) : (Int, Int, List[(Int, Int)]) = {\n  \
    \          val (x, y) = t\n            val neighbors = ListBuffer[(Int, Int)]()\n\
    \            if (x - 1 >= 0) neighbors += ((x - 1, y))\n            if (x + 1\
    \ < gridx.length) neighbors += ((x + 1, y))\n            if (y - 1 >= 0) neighbors\
    \ += ((x, y - 1))\n            if (y + 1 < gridx(x).length) neighbors += ((x,\
    \ y + 1))\n            (x, y, neighbors.toList)\n        }\n        // returns\
    \ the cell that has the least value among all of the cells (x, y)\n        //\
    \ such that 1 <= x <= N and 1 <= y <= N and that cell is not in the forbiddenList.\n\
    \        def leastValueCell(forbiddenList : List[(Int, Int)]) : (Int, Int) = {\n\
    \            var x = 0\n            var y = 0\n            var value = Long.MaxValue\n\
    \            for (i <- 0 until gridx.length) {\n                for (j <- 0 until\
    \ gridx(i).length) {\n                    if (gridx(i)(j) < value && !forbiddenList.contains((i,\
    \ j))) {\n                        x = i\n                        y = j\n     \
    \                   value = gridx(i)(", "        // We just go to all possible\
    \ paths, and then find the minimum path.\n        // This is naive.\n        val\
    \ n = grid.length\n        def aux(path : List[Long], r : Int, c : Int, steps\
    \ : Long) : List[Long] = {\n            if (steps == k) path\n            else\
    \ {\n                var ans = path\n                if (r > 0) ans = ans :::\
    \ aux(path :+ grid(r - 1)(c), r - 1, c, steps + 1)\n                if (r < n\
    \ - 1) ans = ans ::: aux(path :+ grid(r + 1)(c), r + 1, c, steps + 1)\n      \
    \          if (c > 0) ans = ans ::: aux(path :+ grid(r)(c - 1), r, c - 1, steps\
    \ + 1)\n                if (c < n - 1) ans = ans ::: aux(path :+ grid(r)(c + 1),\
    \ r, c + 1, steps + 1)\n                ans\n            }\n        }\n      \
    \  aux(List[Long](), 0, 0, 0).sortWith((a, b) => a < b).min", "\t\tvar pos = List[Int]()\n\
    \t\tvar min = List[Long]()\n\t\tvar minpos = List[Int]()\n\t\tfor (i <- 0 until\
    \ grid.length) {\n\t\t\tfor (j <- 0 until grid(i).length) {\n\t\t\t\tpos = List(i,\
    \ j)\n\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\tmin = List(grid(i)(j))\n\t\t\t\
    \t\tminpos = pos\n\t\t\t\t} else {\n\t\t\t\t\tvar prev = List[Long]()\n\t\t\t\t\
    \tif (i > 0) prev = List(grid(i - 1)(j))\n\t\t\t\t\tif (j > 0) prev = prev :::\
    \ List(grid(i)(j - 1))\n\t\t\t\t\tif (prev.length == 2) {\n\t\t\t\t\t\tif (prev(0)\
    \ < prev(1)) {\n\t\t\t\t\t\t\tif (grid(i)(j) < prev(0)) {\n\t\t\t\t\t\t\t\tmin\
    \ = List(grid(i)(j))\n\t\t\t\t\t\t\t\tminpos = pos\n\t\t\t\t\t\t\t} else {\n\t\
    \t\t\t\t\t\t\tmin = List(prev(0))\n\t\t\t\t\t\t\t\tminpos = List(i - 1, j)\n\t\
    \t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (grid(i)(j) < prev(1)) {\n\
    \t\t\t\t\t\t\t\tmin = List(grid(i)(j))\n\t\t\t\t\t\t\t\tminpos = pos\n\t\t\t\t\
    \t\t\t} else {\n\t\t\t\t\t\t\t\tmin = List(prev(1))\n\t\t\t\t\t\t\t\tminpos =\
    \ List(i, j - 1)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\
    \t\tif (grid(i)(j) < prev(0)) {\n\t\t\t\t\t\t\tmin = List(grid(i", "        val\
    \ n = grid.length\n        var mask = new Array[Array[Boolean]](n, n)\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until n) {\n              \
    \  mask(i)(j) = false\n            }\n        }\n        var min = (List[Long](),\
    \ Long.MaxValue)\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ n) {\n                min = minPath1(grid, i, j, k, mask, (List[Long](), Long.MaxValue))\n\
    \            }\n        }\n        return min._1", "        // The states will\
    \ be (i, j, k). Here i, j are the coordinates of the\n        // cell, and k is\
    \ the remaining length of the path.\n        // Each transition is denoted by\
    \ (p, q) -> (i, j), where (p, q) is the\n        // current state, and (i, j)\
    \ is the state we want to transition to.\n        // First we will find the states\
    \ that are reachable in the final step\n        // (the k-th step) of our path.\n\
    \        val n = grid.length\n        // The transition graph.\n        val transition\
    \ = new HashMap[(Int, Int, Long), List[(Int, Int)]]\n        for (p <- 0 until\
    \ n; q <- 0 until n; curk <- 0l until k + 1) {\n            transition((p, q,\
    \ curk)) = ListBuffer[(Int, Int)]()\n            for (i <- 0 until n; j <- 0 until\
    \ n) {\n                // We can go to (i, j) only if the value in grid[i][j]\
    \ is less\n                // than grid[p][q] because we want to move in the lexicographically\n\
    \                // minimum order (to minimize our path).\n                if\
    \ (curk + 1 <= k && grid(i)(j) < grid(p)(q)) transition((p, q, curk)) += ((i,\
    \ j))\n            }\n        }\n        // Find the minimum path by running BFS.\n\
    \        // For each cell (p, q), we will keep the minimum path that ends at this\n\
    \        // cell (we will get the same cell again, but at the k-th step)\n   \
    \     val minPath = new HashMap[(Int, Int), List[Long]]\n        for (p <- 0 until\
    \ n; q <- 0 until n) minPath((p, q)) = List[Long]()\n        // BFS frontier.\n\
    \        val bfs = new Queue[(Int, Int, Long)]\n        for (p <- 0 until n; q\
    \ <- 0 until n) {\n            if (transition((p, q, k - 1l)).isEmpty) minPath((p,\
    \ q)) = List(grid(p)(q))\n            else bfs += ((p, q,", "        // In C++,\
    \ std::vector<std::vector<int>>\n        // In Scala, List[List[Long]]\n     \
    \   // In C++, std::vector<int>\n        // In Scala, List[Long]\n        // In\
    \ C++, int\n        // In Scala, Long\n        // Your code here\n        val\
    \ dp = Array.ofDim[(List[Long], Long)](grid.length, grid.length)\n        for\
    \ (i <- 0 until grid.length) {\n            for (j <- 0 until grid.length) {\n\
    \                dp(i)(j) = (List[Long](), Long.MaxValue)\n            }\n   \
    \     }\n        val q = Queue[(Int, Int)]()\n        q.enqueue((0, 0))\n    \
    \    dp(0)(0) = (List[Long](grid(0)(0)), grid(0)(0))\n        while (!q.isEmpty)\
    \ {\n            val (x, y) = q.dequeue\n            if (x < grid.length - 1)\
    \ {\n                val d = dp(x)(y)._2 + grid(x + 1)(y)\n                if\
    \ (d < dp(x + 1)(y)._2) {\n                    dp(x + 1)(y) = (dp(x)(y)._1 :+\
    \ grid(x + 1)(y), d)\n                    q.enqueue((x + 1, y))\n            \
    \    }\n            }\n            if (y < grid.length - 1) {\n              \
    \  val d = dp(x)(y)._2 + grid(x)(y + 1)\n                if (d < dp(x)(y + 1)._2)\
    \ {\n                    dp(x)(y + 1) = (dp(x)(y)._1 :+ grid(x)(y + 1), d)\n \
    \                   q.enqueue((x, y + 1))\n                }\n            }\n\
    \        }\n        dp(grid.length - 1)(grid.length - 1)._1", "        val f :\
    \ Array[Array[Long]] = Array.ofDim[Long](grid.length, grid.length)\n        val\
    \ g : Array[Array[Long]] = Array.ofDim[Long](grid.length, grid.length)\n     \
    \   val d : Array[Array[Int]] = Array.ofDim[Int](grid.length, grid.length)\n \
    \       var min = Long.MaxValue\n        for (i <- 0 until grid.length) {\n  \
    \          for (j <- 0 until grid.length) {\n                f(i)(j) = Long.MaxValue\n\
    \                g(i)(j) = Long.MaxValue\n                d(i)(j) = 0\n      \
    \      }\n        }\n        for (i <- 0 until grid.length) {\n            for\
    \ (j <- 0 until grid.length) {\n                if (i > 0) {\n               \
    \     if (grid(i)(j) < grid(i - 1)(j)) {\n                        f(i)(j) = min(f(i)(j),\
    \ g(i - 1)(j))\n                        g(i)(j) = min(g(i)(j), f(i - 1)(j) + grid(i)(j)\
    \ - grid(i - 1)(j))\n                        d(i)(j) |= 1\n                  \
    \  } else if (grid(i)(j) > grid(i - 1)(j)) {\n                        f(i)(j)\
    \ = min(f(i)(j), f(i - 1)(j) + grid(i - 1)(j) - grid(i)(j))\n                \
    \        g(i)(j) = min(g(i)(j), g(i - 1)(j))\n                        d(i)(j)\
    \ |= 1\n                    } else {\n                        f(i)(j) = min(f(i)(j),\
    \ f(i - 1)(j))\n                        g(i)(j) = min(g(i)(j), g(i - 1)(j))\n\
    \                        d(i)(j) |= 1\n                    }\n               \
    \ }\n                if (j > 0) {\n                    if (grid(i)(j) < grid(i)(j\
    \ - 1)) {\n                        f(i)(j) = min(f(i)(j), g(i)(j", "        //\
    \ your code here\n        return List[Long]()", "        // first, let's find\
    \ the starting point\n        var lowest = Long.MaxValue\n        var lowestRow\
    \ = -1\n        var lowestCol = -1\n        for (i <- 0 until grid.length) {\n\
    \            for (j <- 0 until grid(i).length) {\n                if (grid(i)(j)\
    \ < lowest) {\n                    lowest = grid(i)(j)\n                    lowestRow\
    \ = i\n                    lowestCol = j\n                }\n            }\n \
    \       }\n        // initialize the queue\n        var queue = new ArrayBuffer[(Int,\
    \ Int, Int, Long, ArrayBuffer[Long])]\n        var start = (lowestRow, lowestCol,\
    \ 0, lowest, new ArrayBuffer[Long])\n        start._5 += start._4\n        queue\
    \ += start\n        // main loop\n        while (queue.length > 0) {\n       \
    \     var newQueue = new ArrayBuffer[(Int, Int, Int, Long, ArrayBuffer[Long])]\n\
    \            for (elem <- queue) {\n                var visited = new ArrayBuffer[(Int,\
    \ Int)]\n                visited += ((elem._1, elem._2))\n                var\
    \ newPath = elem._5\n                var newStep = elem._3 + 1\n             \
    \   var newSum = elem._4\n                var newRow = elem._1\n             \
    \   var newCol = elem._2\n                if (newStep == k) {\n              \
    \      // the queue will be empty at the next iteration and the loop will terminate\n\
    \                    return newPath.toList\n                }\n              \
    \  if (newRow > 0 && !visited.contains((newRow - 1, newCol))) {\n            \
    \        var newNode = (newRow - 1, newCol, newStep, newSum + grid(newRow - 1)(newCol),\
    \ newPath)\n                    newNode._5 += newNode._4\n                   \
    \ newQueue += newNode\n                }\n                if (newRow < grid.length\
    \ - 1 && !visited.contains((newRow + 1, newCol))) {\n                    var newNode\
    \ = (newRow + 1, newCol, newStep, newSum + grid(newRow + 1)(newCol), newPath)\n\
    \                    newNode._5 += newNode._4\n                    newQueue +=\
    \ newNode\n                }\n               ", "        // Your code here\n \
    \       null", "        var n = grid.length\n        // check\n        if (n ==\
    \ 0) return List()\n        if (grid(0).length != n) return List()\n        if\
    \ (k < 1) return List()\n        val range = (1 to n * n).toList\n        val\
    \ exist = new HashSet[Long]\n        val grid_copy = grid.map(_.map(v => {\n \
    \           if (exist.contains(v)) return -1\n            exist += v\n       \
    \     return v\n        }))\n        // find the starting point\n        val find_start\
    \ = grid_copy.foldLeft(range)((lst, l) => {\n            lst.filter(grid_copy.map(_.contains(_)).reduce(_\
    \ & _)(_))\n        })\n        if (find_start.length == 0) return List()\n  \
    \      val start = find_start(0)\n        // recursive function\n        def helper(current\
    \ : Long, k : Long, path : List[Long]) : List[Long] = {\n            if (k ==\
    \ 0) return path\n            var result = List[Long]()\n            // left\n\
    \            if (current % n != 1) {\n                var r = grid_copy(current\
    \ / n - 1)(current % n - 2)\n                if (r != -1) {\n                \
    \    r = helper(current - 1, k - 1, path :+ r)\n                    if (result.length\
    \ == 0 || result(0) > r(0)) result = r\n                }\n            }\n   \
    \         // right\n            if (current % n != 0) {\n                var r\
    \ = grid_copy(current / n - 1)(current % n)\n                if (r != -1) {\n\
    \                    r = helper(current + 1, k - 1, path :+ r)\n             \
    \       if (result.length == 0 || result(0) > r(0)) result = r\n             \
    \   }\n            }\n            // up\n            if (current / n != 1) {\n\
    \                var r = grid_copy(current / n - 2)(current % n - 1)\n       \
    \         if (r != -1) {\n                    r = helper(current - n, k - 1, path\
    \ :+ r)\n                    if (result.length ==", "        // Build matrix\n\
    \        val m = grid.length\n        val n = grid(0).length\n        // Define\
    \ some functions\n        def coord(l : Long) : (Int, Int) = {\n            (l.toInt\
    \ / n, l.toInt % n)\n        }\n        def value(coord : (Int, Int)) : Long =\
    \ {\n            grid(coord._1)(coord._2)\n        }\n        def neighbor(l :\
    \ Long) : List[Long] = {\n            val c = coord(l)\n            List((c._1\
    \ - 1, c._2), (c._1 + 1, c._2), (c._1, c._2 - 1), (c._1, c._2 + 1)).filter((t\
    \ : (Int, Int)) => (t._1 >= 0 && t._1 < m && t._2 >= 0 && t._2 < n)).map((t :\
    \ (Int, Int)) => (t._1 * n + t._2).toLong)\n        }\n        def is_terminal(l\
    \ : Long) : Boolean = {\n            neighbor(l).length == 0\n        }\n    \
    \    def comp(x : (Long, List[Long]), y : (Long, List[Long])) : Boolean = {\n\
    \            (x._2 zip y._2).forall((t : (Long, Long)) => (t._1 == t._2)) && (x._2.length\
    \ < y._2.length || (x._2.length == y._2.length && x._2.last < y._2.last))\n  \
    \      }\n        // Run BFS to find all paths of length k\n        val queue\
    \ = Queue[(Long, List[Long])]()\n        val visited = ListBuffer[(Long, List[Long])]()\n\
    \        val terminals = Queue[(Long, List[Long])]()\n        var min : (Long,\
    \ List[Long]) = null\n        // Initialize queue\n        queue.enqueue((0l,\
    \ List[Long](value(coord(0l)))))\n        while (!queue.isEmpty) {\n         \
    \   val (l, lst) = queue.dequeue\n            if (is_terminal(l)) {\n        \
    \        terminals.enqueue((l,", "        // Write your code here\n        if\
    \ (k <= 0) return List[Long]()\n        if (k == 1) {\n            val l = grid.reduce((x,\
    \ y) => x ++ y)\n            return List[Long](l.min)\n        }\n        val\
    \ maxx = grid.length\n        val maxy = grid(0).length\n        val arr = Array.ofDim[Long](maxx,\
    \ maxy)\n        for (i <- 0 until maxx) {\n            for (j <- 0 until maxy)\
    \ {\n                arr(i)(j) = grid(i)(j)\n            }\n        }\n      \
    \  val dp = Array.ofDim[Long](maxx, maxy, k.toInt + 1)\n        for (i <- 0 until\
    \ maxx) {\n            for (j <- 0 until maxy) {\n                dp(i)(j)(1)\
    \ = arr(i)(j)\n            }\n        }\n        for (i <- 0 until maxx) {\n \
    \           for (j <- 0 until maxy) {\n                if (i > 0) {\n        \
    \            dp(i)(j)(2) = min(dp(i)(j)(2), dp(i - 1)(j)(1) + arr(i)(j))\n   \
    \             }\n                if (i < maxx - 1) {\n                    dp(i)(j)(2)\
    \ = min(dp(i)(j)(2), dp(i + 1)(j)(1) + arr(i)(j))\n                }\n       \
    \         if (j > 0) {\n                    dp(i)(j)(2) = min(dp(i)(j)(2), dp(i)(j\
    \ - 1)(1) + arr(i)(j))\n                }\n                if (j < maxy - 1) {\n\
    \                    dp(i)(j)(2) = min(dp(i)(j)(2), dp(i)(j + 1)(1) + arr(i)(j))\n\
    \                }\n            }\n        }\n        for (l <- 3 to k.toInt)\
    \ {\n            for (i <- 0 until maxx) {\n                for (j <- 0 until\
    \ maxy) {\n                    if (i > 0) {\n", "        case class Path(grid\
    \ : List[List[Long]], k : Long, path : List[Long]) {\n            def next = {\n\
    \                val min = minPath(grid, path.last)\n                val paths\
    \ = path match {\n                    case List() => min.map(i => (i, i))\n  \
    \                  case _ => min.map(i => (i, min(path.last - 1)))\n         \
    \       }\n                val nxt = for (p <- paths) yield {\n              \
    \      val nxtPath = Path(grid, k - 1, p._1 :: path)\n                    (nxtPath,\
    \ p._2)\n                }\n                nxt.filter(p => p._1.path.length ==\
    \ k && p._1.path.distinct.length == k).sortBy(p => p._2).head\n            }\n\
    \        }\n        def minPath(grid : List[List[Long]], last : Long) : List[Long]\
    \ = {\n            def minPathRec(grid : List[List[Long]], last : Long, i : Int,\
    \ j : Int, res : List[Long]) : List[Long] = {\n                if (i < 0 || j\
    \ < 0 || i >= grid.length || j >= grid.length) res\n                else if (grid(i)(j)\
    \ == last) res\n                else {\n                    val lst = List(grid(i)(j)\
    \ + 1) :: List(grid(i)(j) - 1) :: List(grid(i)(j)) :: Nil\n                  \
    \  val lst1 = lst.map(x => minPathRec(grid, x, i - 1, j, List(x)))\n         \
    \           val lst2 = lst.map(x => minPathRec(grid, x, i + 1, j, List(x)))\n\
    \                    val lst3 = lst.map(x => minPathRec(grid, x, i, j - 1, List(x)))\n\
    \                    val lst4 = lst.map(x => minPathRec(grid, x, i, j + 1, List(x)))\n\
    \                    res ++ (lst1 ++ lst2 ++ lst3 ++ lst4).filter(l => l.nonEmpty).sortBy(l\
    \ => l.last)\n", "        // First, find the min and max values of the grid\n\
    \        val minValue = grid.map(l => l.min).min\n        val maxValue = grid.map(l\
    \ => l.max).max\n        // Go over all the values from minValue to maxValue.\n\
    \        // For each value, perform BFS to find all the paths that end with\n\
    \        // that value. The paths that start with smaller value will be added\n\
    \        // to the queue before the paths that start with a larger value, so\n\
    \        // if there are two paths in the queue with the same length and\n   \
    \     // the same values in the middle, the one that starts with a smaller\n \
    \       // value will be popped before the other.\n        val queue = Queue[(List[Long],\
    \ (Int, Int))]()\n        val reached = HashSet[(Int, Int)]()\n        var minPath\
    \ = List[Long]()\n        for (i <- 0 until grid.length) for (j <- 0 until grid(i).length)\
    \ {\n            if (grid(i)(j) == minValue) {\n                reached += ((i,\
    \ j))\n                queue += ((List[Long](minValue), (i, j)))\n           \
    \ }\n        }\n        var found = false\n        while (!queue.isEmpty && !found)\
    \ {\n            val (path, (i, j)) = queue.dequeue\n            val (up, down,\
    \ left, right) = ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1))\n          \
    \  List((up, 0), (down, 1), (left, 2), (right, 3)).filter(pair => {\n        \
    \        val (x, y) = pair._1\n                x >= 0 && x < grid.length && y\
    \ >= 0 && y < grid(x).length && !reached.contains(pair._1)\n            }).foreach(pair\
    \ => {\n                val (x, y) = pair._1\n                if (grid(x)(y) ==\
    \ maxValue) {\n                    minPath = path :+ maxValue\n              \
    \      found = true\n                } else {\n                    reached +=\
    \ ((x, y))\n                    queue += ((path :+ grid(x)(y), (x, y)))\n", " \
    \       val n = grid.length\n        val adj = Array.fill(n, n)((List[(Int, Int)](),\
    \ List[(Int, Int)]()))\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until n) {\n                if (i > 0) adj(i)(j)._1 = (i - 1, j) :: adj(i)(j)._1\n\
    \                if (i < n - 1) adj(i)(j)._1 = (i + 1, j) :: adj(i)(j)._1\n  \
    \              if (j > 0) adj(i)(j)._2 = (i, j - 1) :: adj(i)(j)._2\n        \
    \        if (j < n - 1) adj(i)(j)._2 = (i, j + 1) :: adj(i)(j)._2\n          \
    \  }\n        }\n        val adj2 = adj.map(_.map(_._1))\n        val adj3 = adj.map(_.map(_._2))\n\
    \        val map = grid.flatMap(_.zipWithIndex).map(x => (x._1, x._2)).toMap\n\
    \        val queue = Queue[List[(Int, Int)]]()\n        val visited = Array.fill(n,\
    \ n)(false)\n        for (i <- 0 until n) {\n            for (j <- 0 until n)\
    \ {\n                visited(i)(j) = true\n                queue.enqueue(List((i,\
    \ j)))\n                visited(i)(j) = false\n            }\n        }\n    \
    \    val ans = Array.fill(n * n + 1)(List[Long]())\n        while (!queue.isEmpty)\
    \ {\n            val path = queue.dequeue\n            if (path.length == k) {\n\
    \                val cur = path.map(x => grid(x._1)(x._2)).sorted\n          \
    \      if (ans(cur.length) == Nil || ans(cur.length).zip(cur).exists(x => x._1\
    \ > x._2)) {\n                    ans(cur.length) = cur\n                }\n \
    \           } else {\n                val cur = path.last\n                val\
    \ ns = adj2(cur._1)(cur._2) :::", "        val n = grid.length\n        var grid2\
    \ = grid.map(_.toArray)\n        for (i <- 0 until n) grid2(i)(i) = 0\n      \
    \  for (i <- 0 until n; j <- 0 until n; if (i != j)) grid2(i)(j) = min(grid2(i)(j),\
    \ grid2(i)(i) + grid2(i)(j))\n        var dp = new Array[Long](n)\n        for\
    \ (i <- 0 until n) dp(i) = grid2(0)(i)\n        for (k <- 2 to k.toInt) {\n  \
    \          var newdp = new Array[Long](n)\n            for (i <- 0 until n) {\n\
    \                newdp(i) = Long.MaxValue\n                for (j <- 0 until n)\
    \ {\n                    newdp(i) = min(newdp(i), dp(j) + grid2(j)(i))\n     \
    \           }\n            }\n            dp = newdp\n        }\n        dp.toList",
  "        def getSize(grid : List[List[Long]]) : Int = {\n            val n = grid.length\n\
    \            return n\n        }\n        def getCell(grid : List[List[Long]],\
    \ row : Int, col : Int) : Long = {\n            return grid(row)(col)\n      \
    \  }\n        def getMinPath(grid : List[List[Long]], k : Long) : List[Long] =\
    \ {\n            val n = getSize(grid)\n            val cache = Array.ofDim[List[Long]](n,\
    \ n)\n            for (i <- 0 until n) {\n                for (j <- 0 until n)\
    \ {\n                    cache(i)(j) = List[Long]()\n                }\n     \
    \       }\n            for (i <- 0 until n) {\n                for (j <- 0 until\
    \ n) {\n                    val value = getCell(grid, i, j)\n                \
    \    //println(i + \" \" + j + \" \" + value)\n                    if (k == 1)\
    \ {\n                        cache(i)(j) = List[Long](value)\n               \
    \     } else {\n                        var minPath = List[Long]()\n         \
    \               if (i - 1 >= 0) {\n                            val up = cache(i\
    \ - 1)(j)\n                            if (minPath.isEmpty || lexicographicallyLess(up,\
    \ minPath)) {\n                                minPath = up\n                \
    \            }\n                        }\n                        if (i + 1 <\
    \ n) {\n                            val down = cache(i + 1)(j)\n             \
    \               if (minPath.isEmpty || lexicographicallyLess(down, minPath)) {\n\
    \                                minPath = down\n                            }\n\
    \                        }\n                        if (j - 1 >= 0) {\n      \
    \                      val left = cache(i)(j - 1)\n                          \
    \  if (minPath.isEmpty || lexicographicallyLess(left, minPath)) {\n          \
    \                      minPath = left\n                            }\n       \
    \                 }\n                        if (j + 1 < n) {\n              \
    \              val right = cache(i)(j + 1)\n                            if (minPath.isEmpty\
    \ || lexicographicallyLess(right, minPath)) {\n                              \
    \  minPath = right\n                            }\n                        }\n\
    \                        cache(", "        val size = grid.size\n        def solve(i\
    \ : Int, j : Int, k : Long) : List[Long] = {\n            if (k == 0) List[Long]()\n\
    \            else {\n                val ni = List(i - 1, i, i + 1)\n        \
    \        val nj = List(j - 1, j, j + 1)\n                val neighbor = (for (x\
    \ <- ni; y <- nj if x >= 0 && x < size && y >= 0 && y < size && (x != i || y !=\
    \ j)) yield (x, y)).map(x => (x, grid(x._1)(x._2))).sortBy(_._2)\n           \
    \     val candidates = ListBuffer[(List[Long], Int)]()\n                for (z\
    \ <- neighbor) {\n                    val next = solve(z._1._1, z._1._2, k - 1)\n\
    \                    candidates += ((z._2 :: next, next.size))\n             \
    \   }\n                candidates.sortBy(x => (x._1, x._2)).head._1\n        \
    \    }\n        }\n        for (i <- 0 until size; j <- 0 until size) {\n    \
    \        val res = solve(i, j, k)\n            if (res.size == k.toInt) return\
    \ res\n        }\n        return List[Long]()", "        var listList = new ListBuffer[List[Long]]()\n\
    \        listList += List[Long]()\n        val n = grid.length\n        var st\
    \ = new Stack[(Int, Int)]()\n        st.push((0, 0))\n        var dp = Array.ofDim[Boolean](n,\
    \ n)\n        for (i <- 0 until n) for (j <- 0 until n) dp(i)(j) = false\n   \
    \     dp(0)(0) = true\n        var list = new ListBuffer[Long]()\n        var\
    \ minList = new ListBuffer[Long]()\n        var min = Long.MaxValue\n        def\
    \ recur(k : Long) {\n            if (k == 0) {\n                if (listList.last.length\
    \ < min) {\n                    min = listList.last.length\n                 \
    \   minList = listList.last\n                }\n                return\n     \
    \       }\n            val curr = st.top\n            if (curr._1 - 1 >= 0 &&\
    \ dp(curr._1 - 1)(curr._2) == false) {\n                st.push((curr._1 - 1,\
    \ curr._2))\n                dp(curr._1 - 1)(curr._2) = true\n               \
    \ listList += listList.last :+ grid(curr._1 - 1)(curr._2)\n                recur(k\
    \ - 1)\n                listList.remove(listList.length - 1)\n               \
    \ dp(curr._1 - 1)(curr._2) = false\n                st.pop\n            }\n  \
    \          if (curr._1 + 1 < n && dp(curr._1 + 1)(curr._2) == false) {\n     \
    \           st.push((curr._1 + 1, curr._2))\n                dp(curr._1 + 1)(curr._2)\
    \ = true\n                listList += listList.last :+ grid(curr._1 + 1)(curr._2)\n\
    \                recur(k - 1)\n                listList.remove(listList.length\
    \ - 1)\n                dp(curr._1 + 1)(curr._2) = false\n                st.pop\n\
    \            }\n            if (curr", "      var ans = List[Long]()\n      for\
    \ (row <- grid) ans = ans ::: row\n      ans = ans.sorted\n      val grid1 = new\
    \ Array[Array[Long]](grid.length)\n      var count = 0\n      for (row <- grid)\
    \ {\n        val row1 = new Array[Long](row.length)\n        for (col <- row)\
    \ {\n          row1(count) = col\n          count += 1\n        }\n        count\
    \ = 0\n        grid1(grid.indexOf(row)) = row1\n      }\n      var min = k\n \
    \     val dir = Array(Array(0, 1), Array(0, -1), Array(1, 0), Array(-1, 0))\n\
    \      var maxi = -1\n      var maxj = -1\n      for (i <- 0 until grid.length)\
    \ {\n        for (j <- 0 until grid.length) {\n          val queue = Queue[(Int,\
    \ Int, Int)]()\n          val visit = new Array[Array[Boolean]](grid.length)\n\
    \          for (i <- 0 until grid.length) {\n            val row = new Array[Boolean](grid.length)\n\
    \            for (j <- 0 until grid.length) row(j) = false\n            visit(i)\
    \ = row\n          }\n          queue.enqueue((i, j, 0))\n          while (!queue.isEmpty)\
    \ {\n            val node = queue.dequeue\n            if (node._3 > min) {\n\
    \              if (ans(min - 1) < grid1(node._1)(node._2)) {\n               \
    \ min = node._3\n                maxi = node._1\n                maxj = node._2\n\
    \              }\n            }\n            visit(node._1)(node._2) = true\n\
    \            for (d <- dir) {\n              val x = node._1 + d(0)\n        \
    \      val y = node._2 + d(1)\n              if (x >= 0 && x < grid.length &&\
    \ y >= 0 && y < grid.length && !visit(x)(y)) {\n                if (ans(node._3)\
    \ == grid1(x)(y)) queue.enqueue((x, y, node._3 + 1))\n             ", "      \
    \  if (k < 1) return Nil\n        // map from a cell (row, col) to a priority\
    \ queue of paths\n        val paths = new HashMap[(Int, Int), ListBuffer[(List[Long],\
    \ Long)]]\n        for (row <- 0 until grid.length; col <- 0 until grid(0).length)\
    \ {\n            paths((row, col)) = new ListBuffer[(List[Long], Long)]\n    \
    \        paths((row, col)) += ((List(grid(row)(col)), grid(row)(col)))\n     \
    \   }\n        for (i <- 1 until k.toInt) {\n            val newPaths = new HashMap[(Int,\
    \ Int), ListBuffer[(List[Long], Long)]]\n            for (row <- 0 until grid.length;\
    \ col <- 0 until grid(0).length) {\n                newPaths((row, col)) = new\
    \ ListBuffer[(List[Long], Long)]\n                if (row > 0) {\n           \
    \         val buf = paths((row - 1, col))\n                    if (buf.size >\
    \ 0) {\n                        val path = buf(0)\n                        newPaths((row,\
    \ col)) += ((path._1 :+ grid(row)(col), path._2 + grid(row)(col)))\n         \
    \           }\n                }\n                if (row < grid.length - 1) {\n\
    \                    val buf = paths((row + 1, col))\n                    if (buf.size\
    \ > 0) {\n                        val path = buf(0)\n                        newPaths((row,\
    \ col)) += ((path._1 :+ grid(row)(col), path._2 + grid(row)(col)))\n         \
    \           }\n                }\n                if (col > 0) {\n           \
    \         val buf = paths((row, col - 1))\n                    if (buf.size >\
    \ 0) {\n                        val path = buf(0)\n                        newPaths((row,\
    \ col)) += ((path._1 :+ grid(row)(col), path._2 + grid(row)(col)))\n         \
    \           }\n                }\n                if (col < grid(0).length - 1)\
    \ {\n                    val buf = paths((row, col + 1))\n                   \
    \ if (buf.size > 0) {\n                        val path = buf(0)\n           \
    \             newPaths((row,", "        var dict = Map[Int, Long]()\n        for\
    \ (r <- 0 until grid.length; c <- 0 until grid(r).length) dict(r * grid.length\
    \ + c) = grid(r)(c)\n        def helper(dict : Map[Int, Long], from : Int, to\
    \ : Int, visited : List[Int], curValue : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (visited.length == k) return if (dict(from) < curValue)\
    \ acc else acc :+ dict(from)\n            var minPath = List[Long]()\n       \
    \     for (i <- -1 to 1; j <- -1 to 1 if i != 0 || j != 0) {\n               \
    \ val next = (from / grid.length + i) * grid.length + from % grid.length + j\n\
    \                if (next >= 0 && next < grid.length * grid.length && !visited.contains(next))\
    \ {\n                    val lst = helper(dict, next, to, visited :+ next, curValue,\
    \ acc :+ dict(from))\n                    if (minPath.isEmpty || lst.mkString\
    \ < minPath.mkString) minPath = lst\n                }\n            }\n      \
    \      return minPath\n        }\n        var minPath = List[Long]()\n       \
    \ for (r <- 0 until grid.length; c <- 0 until grid(r).length) {\n            val\
    \ lst = helper(dict, r * grid.length + c, r * grid.length + c, List[Int](r * grid.length\
    \ + c), dict(r * grid.length + c), List[Long]())\n            if (minPath.isEmpty\
    \ || lst.mkString < minPath.mkString) minPath = lst\n        }\n        return\
    \ minPath", "        if (k == 1) {\n            val ordered = grid.flatten.sorted\n\
    \            List(ordered(0))\n        } else {\n            val left = \n   \
    \         if (k >= 2) {\n                val gridLeft = grid.map(x => x.tail)\n\
    \                val ordered = minPath(gridLeft, k - 1)\n                if (grid(0)(0)\
    \ < ordered(0)) grid(0)(0) :: ordered else ordered\n            } else {\n   \
    \             Nil\n            }\n            val up = \n            if (k >=\
    \ 2) {\n                val gridUp = grid.tail\n                val ordered =\
    \ minPath(gridUp, k - 1)\n                if (grid(0)(0) < ordered(0)) grid(0)(0)\
    \ :: ordered else ordered\n            } else {\n                Nil\n       \
    \     }\n            if (left == Nil && up == Nil) List(grid(0)(0))\n        \
    \    else if (left == Nil) up\n            else if (up == Nil) left\n        \
    \    else if (left.head < up.head) left\n            else up\n        }", "  \
    \      val bfs = new BFS(grid, k)\n        bfs.getMinimumPath", "        // Build\
    \ adjacency matrix\n        val adj : Array[Array[List[Long]]] = Array.ofDim[List[Long]](grid.length,\
    \ grid.length)\n        for (i <- 0 until grid.length) {\n            for (j <-\
    \ 0 until grid.length) {\n                adj(i)(j) = List[Long]()\n         \
    \       if (i > 0) adj(i)(j) = adj(i)(j) :+ grid(i - 1)(j)\n                if\
    \ (i < grid.length - 1) adj(i)(j) = adj(i)(j) :+ grid(i + 1)(j)\n            \
    \    if (j > 0) adj(i)(j) = adj(i)(j) :+ grid(i)(j - 1)\n                if (j\
    \ < grid.length - 1) adj(i)(j) = adj(i)(j) :+ grid(i)(j + 1)\n            }\n\
    \        }\n        // State: (current_cell, remaining_length)\n        // Initial\
    \ states: State(grid(0)(0), k - 1), ..., State(grid(grid.length - 1)(grid.length\
    \ - 1), k - 1)\n        val states = for (i <- 0 until grid.length; j <- 0 until\
    \ grid.length) yield new State(grid(i)(j), k - 1)\n        // Define an ordering\
    \ on states\n        implicit val stateOrdering = new Ordering[State] {\n    \
    \        def compare(x : State, y : State) = {\n                if (x.length <\
    \ y.length) -1\n                else if (x.length > y.length) 1\n            \
    \    else {\n                    for (i <- 0 until x.length) {\n             \
    \           if (x.values(i) < y.values(i)) return -1\n                       \
    \ else if (x.values(i) > y.values(i)) return 1\n                    }\n      \
    \              0\n                }\n            }\n        }\n        // Priority\
    \ queue for all states\n        val pq = new PriorityQueue[State]()(stateOrdering)\n\
    \        pq ++= states\n        // Explore the states\n        while (!pq.isEmpty)\
    \ {\n            val cur = pq.dequeue\n            if", "        val n = grid.length\n\
    \        // BFS\n        // path -> (last, total)\n        val paths = Queue[((Int,\
    \ Int), Long)]()\n        // cell -> smallest length\n        val m = Map[(Int,\
    \ Int), Long]()\n        for (i <- 0 until n) for (j <- 0 until n) m += ((i, j)\
    \ -> (k + 1))\n        var minPath : List[Long] = null\n        paths += (((0,\
    \ 0), 0))\n        while (!paths.isEmpty) {\n            val ((i, j), last) =\
    \ paths.dequeue\n            val total = last + 1\n            if (total <= k)\
    \ {\n                val path = List[Long](grid(i)(j))\n                if (total\
    \ == k) {\n                    if (minPath == null || minPath > path) minPath\
    \ = path\n                } else {\n                    for (d <- 0 until 4) {\n\
    \                        val (x, y) = (i + (d match {case 0 => 1 case 1 => -1\
    \ case 2 => 0 case 3 => 0}), j + (d match {case 0 => 0 case 1 => 0 case 2 => 1\
    \ case 3 => -1}))\n                        if (x >= 0 && x < n && y >= 0 && y\
    \ < n) {\n                            if (m((x, y)) > total) {\n             \
    \                   m((x, y)) = total\n                                paths +=\
    \ (((x, y), total))\n                            }\n                        }\n\
    \                    }\n                }\n            }\n        }\n        minPath",
  "        case class Node(cell : (Int, Int), path : List[Long]) extends Ordered[Node]\
    \ {\n            def compare(that : Node) = {\n                var i = 0\n   \
    \             while (i < k && i < path.length && i < that.path.length && path(i)\
    \ == that.path(i)) i += 1\n                if (i == k || i == path.length || i\
    \ == that.path.length) {\n                    if (i == k || i == path.length)\
    \ -1\n                    else 1\n                }\n                else path(i).compare(that.path(i))\n\
    \            }\n        }\n        val n = grid.length\n        val m = grid(0).length\n\
    \        val heap = new BinaryHeap[Node]()\n        val result = new Array[Long](k.toInt)\n\
    \        for (i <- 0 until n; j <- 0 until m) heap.add(Node((i, j), List(grid(i)(j))))\n\
    \        var current = heap.extractMin()\n        for (i <- 0 until k.toInt) {\n\
    \            result(i) = current.path(0)\n            val ns = List((current.cell._1\
    \ - 1, current.cell._2), (current.cell._1 + 1, current.cell._2), (current.cell._1,\
    \ current.cell._2 - 1), (current.cell._1, current.cell._2 + 1))\n            for\
    \ (n <- ns if n._1 >= 0 && n._1 < n && n._2 >= 0 && n._2 < m) heap.add(Node(n,\
    \ grid(n._1)(n._2) :: current.path))\n            current = heap.extractMin()\n\
    \        }\n        result.toList", "        val m = grid.length\n        val\
    \ n = grid(0).length\n        var dp = Array.ofDim[Long](m, n, m * n)\n      \
    \  for (i <- 0 until m; j <- 0 until n) {\n            dp(i)(j)(0) = grid(i)(j)\n\
    \        }\n        var current = 1\n        while (current < k) {\n         \
    \   for (i <- 0 until m; j <- 0 until n) {\n                dp(i)(j)(current)\
    \ = min(\n                    get(dp, i - 1, j, current - 1),\n              \
    \      get(dp, i + 1, j, current - 1),\n                    get(dp, i, j - 1,\
    \ current - 1),\n                    get(dp, i, j + 1, current - 1))\n       \
    \     }\n            current += 1\n        }\n        var min = dp(0)(0)(k.toInt\
    \ - 1)\n        var minPos = (0, 0)\n        for (i <- 0 until m; j <- 0 until\
    \ n) {\n            if (dp(i)(j)(k.toInt - 1) < min) {\n                min =\
    \ dp(i)(j)(k.toInt - 1)\n                minPos = (i, j)\n            }\n    \
    \    }\n        var result = ListBuffer[Long]()\n        var pos = minPos\n  \
    \      var remaining = k\n        while (remaining > 0) {\n            result\
    \ += grid(pos._1)(pos._2)\n            var min = dp(pos._1)(pos._2)(remaining.toInt\
    \ - 1)\n            var minPos = (0, 0)\n            var candidates = List((pos._1\
    \ - 1, pos._2), (pos._1 + 1, pos._2), (pos._1, pos._2 - 1), (pos._1, pos._2 +\
    \ 1))\n            for (candidate <- candidates) {\n                if (candidate._1\
    \ >= 0 && candidate._1 < m && candidate._2 >= 0 && candidate._2 < n) {\n     \
    \               if (dp(candidate._1)(candidate._2)(remaining.toInt - 1) < min)\
    \ {\n                        min = dp(candidate._1", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(List[Long]())\n        val dp2 = Array.fill(n,\
    \ n)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ n) {\n                dp(i)(j) = List(grid(i)(j))\n                for (di <-\
    \ -1 to 1; dj <- -1 to 1; if (i + di >= 0 && i + di < n && j + dj >= 0 && j +\
    \ dj < n && (di != 0 || dj != 0))) {\n                    dp2(i)(j) = dp2(i)(j)\
    \ ::: dp(i + di)(j + dj)\n                }\n                dp2(i)(j) = dp2(i)(j).distinct.sorted\n\
    \                dp(i)(j) = (for (i <- dp2(i)(j) if !dp(i)(j).contains(i)) yield\
    \ i).toList\n            }\n        }\n        var ans = List[Long]()\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until n) {\n              \
    \  ans = (if (ans.isEmpty || ans > dp(i)(j)) dp(i)(j) else ans)\n            }\n\
    \        }\n        ans", "        var n = grid.length\n        var m = new Array[Array[Array[List[Long]]]](n)\n\
    \        for (i <- 0 until n) {\n            m(i) = new Array[Array[List[Long]]](n)\n\
    \            for (j <- 0 until n) {\n                m(i)(j) = new Array[List[Long]](k.toInt\
    \ + 1)\n                for (l <- 0 to k.toInt) m(i)(j)(l) = List()\n        \
    \    }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ n) {\n                for (l <- 1 to k.toInt) {\n                    var paths\
    \ = new ListBuffer[List[Long]]()\n                    if (i > 0) paths += (grid(i)(j)\
    \ :: m(i - 1)(j)(l - 1))\n                    if (i < n - 1) paths += (grid(i)(j)\
    \ :: m(i + 1)(j)(l - 1))\n                    if (j > 0) paths += (grid(i)(j)\
    \ :: m(i)(j - 1)(l - 1))\n                    if (j < n - 1) paths += (grid(i)(j)\
    \ :: m(i)(j + 1)(l - 1))\n                    m(i)(j)(l) = paths.minBy(x => x)\n\
    \                }\n            }\n        }\n        var paths = new ListBuffer[List[Long]]()\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        paths += m(i)(j)(k.toInt)\n            }\n        }\n        paths.minBy(x\
    \ => x)", "        val n = grid.length\n        val arr = grid.flatten.toArray\n\
    \        val cost = Array.ofDim[Int](n, n)\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until n) {\n                cost(i)(j) = arr.indexOf(grid(i)(j))\n\
    \            }\n        }\n        val result = Array.ofDim[Int](n, n, k.toInt\
    \ + 1)\n        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n \
    \               result(i)(j)(0) = 0\n            }\n        }\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until n) {\n                for (l\
    \ <- 1 to k.toInt) {\n                    result(i)(j)(l) = Int.MaxValue\n   \
    \                 if (i > 0) result(i)(j)(l) = min(result(i)(j)(l), result(i -\
    \ 1)(j)(l - 1) + cost(i)(j))\n                    if (j > 0) result(i)(j)(l) =\
    \ min(result(i)(j)(l), result(i)(j - 1)(l - 1) + cost(i)(j))\n               \
    \     if (i < n - 1) result(i)(j)(l) = min(result(i)(j)(l), result(i + 1)(j)(l\
    \ - 1) + cost(i)(j))\n                    if (j < n - 1) result(i)(j)(l) = min(result(i)(j)(l),\
    \ result(i)(j + 1)(l - 1) + cost(i)(j))\n                }\n            }\n  \
    \      }\n        var index = 0\n        var value = Int.MaxValue\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                if (result(i)(j)(k.toInt)\
    \ < value) {\n                    index = grid(i)(j).toInt\n                 \
    \   value = result(i)(j)(k.toInt)\n                }\n            }\n        }\n\
    \        def solve(x : Int, y : Int, l : Int) : List[Long] = {\n", "        //\
    \ grid: List[List[Long]]\n        // k: Long\n        // returnType: List[Long]\n\
    \        ???", "        val dp = Array.fill[Long](grid.size, grid.size)(Int.MaxValue)\n\
    \        val back = Array.fill[(Int, Int)](grid.size, grid.size)((-1, -1))\n \
    \       def valid((i : Int, j : Int)) : Boolean = {\n            i >= 0 && i <\
    \ grid.size && j >= 0 && j < grid.size\n        }\n        val kk = k.toInt\n\
    \        for (i <- 0 until grid.size; j <- 0 until grid.size) {\n            for\
    \ (delta <- (-1 to 1).toList; if delta != 0) {\n                if (valid((i +\
    \ delta, j))) {\n                    if (dp(i)(j) > dp(i + delta)(j) + 1) {\n\
    \                        dp(i)(j) = dp(i + delta)(j) + 1\n                   \
    \     back(i)(j) = (i + delta, j)\n                    }\n                }\n\
    \                if (valid((i, j + delta))) {\n                    if (dp(i)(j)\
    \ > dp(i)(j + delta) + 1) {\n                        dp(i)(j) = dp(i)(j + delta)\
    \ + 1\n                        back(i)(j) = (i, j + delta)\n                 \
    \   }\n                }\n            }\n        }\n        val min_index = (0\
    \ until grid.size).map(i => (dp(i)(grid.size - 1), i)).minBy(_._1)._2\n      \
    \  def rec((i : Int, j : Int) : List[Long]) : List[Long] = {\n            if (i\
    \ == -1) Nil\n            else {\n                val (x, y) = back(i)(j)\n  \
    \              grid(i)(j) :: rec((x, y))\n            }\n        }\n        rec((min_index,\
    \ grid.size - 1)).take(kk)", "        // Write your code here\n        Nil", " \
    \       val N = grid.length\n        var m = grid\n        def get(r : Int, c\
    \ : Int) : Long = {\n            var mr = r\n            if (mr < 0) mr = 0\n\
    \            if (mr >= N) mr = N - 1\n            var mc = c\n            if (mc\
    \ < 0) mc = 0\n            if (mc >= N) mc = N - 1\n            m(mr)(mc)\n  \
    \      }\n        val dr = List(-1, 0, 1, 0)\n        val dc = List(0, 1, 0, -1)\n\
    \        val rq = new PriorityQueue[Long]()(Ordering.by(t => -t))\n        for\
    \ (r <- 0 until N; c <- 0 until N) {\n            var cnt = 0\n            for\
    \ (i <- 0 until 4) {\n                val nr = r + dr(i)\n                val\
    \ nc = c + dc(i)\n                if (get(nr, nc) < get(r, c)) cnt += 1\n    \
    \        }\n            rq.enqueue(get(r, c) * N * N + cnt * N + r)\n        }\n\
    \        var src = ListBuffer[Int]()\n        while (rq.size > 0) {\n        \
    \    val t = rq.dequeue()\n            val v = t / (N * N)\n            val cnt\
    \ = (t / N) % N\n            val r = t % N\n            if (cnt == 0) src += r\n\
    \        }\n        val dst = Array.fill(N)(ListBuffer[Int]())\n        for (r\
    \ <- 0 until N; c <- 0 until N) {\n            var min = Long.MaxValue\n     \
    \       var mini = -1\n            for (i <- 0 until 4) {\n                val\
    \ nr = r + dr(i)\n                val nc = c + dc(i)\n                if (get(nr,\
    \ nc) < min) {\n                    min = get(nr, nc)\n                    mini\
    \ = i\n                }\n            }\n            if (mini != -1) {\n     \
    \           val nr = r + dr(mini)\n                val nc = c + dc(mini)\n", " \
    \       val n = grid.length\n        // val maxLength = min(n * n, k)\n      \
    \  val maxLength = k\n        val nodes = for (x <- 0 until n; y <- 0 until n)\
    \ yield {\n            val id = x * n + y\n            val next = for (x1 <- -1\
    \ to 1; y1 <- -1 to 1 if (abs(x1) + abs(y1) <= 1 && 0 <= x + x1 && x + x1 < n\
    \ && 0 <= y + y1 && y + y1 < n)) yield {\n                (x + x1) * n + (y +\
    \ y1)\n            }\n            val nextIds = next.toSet\n            val nextIds2\
    \ = (for (id1 <- nextIds; id2 <- nextIds) yield {\n                if (id1 < id2)\
    \ (id1, id2) else (id2, id1)\n            }).toSet\n            (id, (grid(x)(y),\
    \ nextIds, nextIds2))\n        }\n        // println(nodes.toMap)\n        val\
    \ nodeMap = nodes.toMap\n        val path = new Path(maxLength, nodeMap)\n   \
    \     val start = for (i <- 0 until n) yield nodeMap(i)._1\n        val queue\
    \ = new PriorityQueue[Path]()(Ordering.by[Path, Long](_.value))\n        for (s\
    \ <- start) {\n            val p = path.add(s, s)\n            queue.enqueue(p)\n\
    \        }\n        while (!queue.isEmpty) {\n            val p = queue.dequeue\n\
    \            if (p.value != -1) {\n                if (p.length == maxLength)\
    \ {\n                    println(p.value)\n                    return p.lst\n\
    \                }\n                else {\n                    val edges = nodeMap(p.lst.last)._3\n\
    \                    for (edge <- edges) {\n                        val x = nodeMap(edge._1)._1\n\
    \                        val y = nodeMap(edge._2)._1\n                       \
    \ val newNode = if (x < y) edge._1 else edge._2\n                        val p2\
    \ = p.add(newNode, newNode)\n", "        val h = grid.length\n        val w =\
    \ grid(0).length\n        // precompute distance table\n        val distTable\
    \ = Array.ofDim[Int](h, w, h, w)\n        for (i <- 0 until h; j <- 0 until w)\
    \ {\n            for (x <- 0 until h; y <- 0 until w) {\n                distTable(i)(j)(x)(y)\
    \ = abs(i - x) + abs(j - y)\n            }\n        }\n        // compute costs\
    \ of each path\n        val pathCost = Array.ofDim[(Int, Long)](h, w, k.toInt\
    \ + 1)\n        for (i <- 0 until h; j <- 0 until w) {\n            for (l <-\
    \ 0 to k.toInt) {\n                if (l == 0) {\n                    pathCost(i)(j)(l)\
    \ = (0, grid(i)(j))\n                } else {\n                    pathCost(i)(j)(l)\
    \ = (Int.MaxValue, 0)\n                    for (x <- 0 until h; y <- 0 until w)\
    \ {\n                        if (distTable(i)(j)(x)(y) == 1) {\n             \
    \               val cost = pathCost(x)(y)(l - 1)\n                           \
    \ if (cost._1 < pathCost(i)(j)(l)._1) {\n                                pathCost(i)(j)(l)\
    \ = (cost._1, cost._2 * 10 + grid(i)(j))\n                            } else if\
    \ (cost._1 == pathCost(i)(j)(l)._1) {\n                                pathCost(i)(j)(l)\
    \ = (cost._1, min(cost._2 * 10 + grid(i)(j), pathCost(i)(j)(l)._2))\n        \
    \                    }\n                        }\n                    }\n   \
    \             }\n            }\n        }\n        // find the minimum path\n\
    \        var res = (Int.MaxValue, 0l)\n        for (i <- 0 until h; j <- 0 until\
    \ w) {\n            if (pathCost(i)(j)(k.toInt)._1 < res._1) {\n             \
    \   res = pathCost(i)(j)(k.toInt)\n            } else if (", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val inf = Long.MaxValue\n\
    \        val dp = Array.fill(n, m)(inf)\n        for (i <- 0 until n) {\n    \
    \        for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = grid(i)(j)\n                else {\n                    if (i > 0) dp(i)(j)\
    \ = min(dp(i)(j), dp(i - 1)(j) + grid(i)(j))\n                    if (j > 0) dp(i)(j)\
    \ = min(dp(i)(j), dp(i)(j - 1) + grid(i)(j))\n                }\n            }\n\
    \        }\n        val newGrid = Array.fill(n, m)((inf, 0, 0))\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i ==\
    \ 0 && j == 0) newGrid(i)(j) = (grid(i)(j), i, j)\n                else {\n  \
    \                  if (i > 0) newGrid(i)(j) = min(newGrid(i)(j), (newGrid(i -\
    \ 1)(j)._1 + grid(i)(j), i - 1, j))\n                    if (j > 0) newGrid(i)(j)\
    \ = min(newGrid(i)(j), (newGrid(i)(j - 1)._1 + grid(i)(j), i, j - 1))\n      \
    \          }\n            }\n        }\n        val cell = newGrid(n - 1)(m -\
    \ 1)\n        var x = cell._2\n        var y = cell._3\n        val res = new\
    \ ListBuffer[Long]\n        for (i <- 0 until k.toInt) {\n            res += grid(x)(y)\n\
    \            if (x == 0) y -= 1\n            else if (y == 0) x -= 1\n       \
    \     else {\n                if (newGrid(x - 1)(y)._1 < newGrid(x)(y - 1)._1)\
    \ x -= 1\n                else y -= 1\n            }\n        }\n        res.",
  '        ???', "        val N = grid.length\n        val cells = grid.flatten\n\
    \        // Pre-calculate the possible paths between cells\n        val paths\
    \ = Array.fill(N, N)(List[List[Long]]())\n        for (cell <- cells) {\n    \
    \        val (row, col) = getCell(N, cell)\n            val possiblePaths = ListBuffer[List[Long]]()\n\
    \            // Move left\n            if (col - 1 >= 0) possiblePaths += List(cell,\
    \ cell - 1)\n            // Move right\n            if (col + 1 < N) possiblePaths\
    \ += List(cell, cell + 1)\n            // Move up\n            if (row - 1 >=\
    \ 0) possiblePaths += List(cell, cell - N)\n            // Move down\n       \
    \     if (row + 1 < N) possiblePaths += List(cell, cell + N)\n            paths(row)(col)\
    \ = possiblePaths.toList\n        }\n        // Now calculate the paths of each\
    \ cell\n        val pathEnd = Array.fill(N, N)(List[List[Long]]())\n        val\
    \ pathLength = Array.fill(N, N)(-1)\n        val queue = Queue[Long]()\n     \
    \   for (cell <- cells) {\n            val (row, col) = getCell(N, cell)\n   \
    \         pathEnd(row)(col) = List(List(cell))\n            pathLength(row)(col)\
    \ = 0\n            queue += cell\n        }\n        while (!queue.isEmpty) {\n\
    \            val cell = queue.dequeue\n            val (row, col) = getCell(N,\
    \ cell)\n            for (possiblePath <- paths(row)(col)) {\n               \
    \ if (possiblePath.last == cell) {\n                    val dest = possiblePath.head\n\
    \                    val (destRow, destCol) = getCell(N, dest)\n             \
    \       if (pathLength(destRow)(destCol) == -1 || pathLength(destRow)(destCol)\
    \ == pathLength(row)(col) + 1) {\n                        pathLength(destRow)(destCol)\
    \ = pathLength(row)(col) + 1\n                        val temp = pathEnd(row)(col).map(p\
    \ => p :+ dest)\n                        pathEnd(destRow", "        val n = grid.length\n\
    \        var dist = ListBuffer[ListBuffer[Long]]()\n        for (i <- 0 until\
    \ n) {\n            dist += ListBuffer[Long]()\n            for (j <- 0 until\
    \ n) dist(i) += Long.MaxValue\n        }\n        dist(0)(0) = grid(0)(0)\n  \
    \      var pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by((_ : (Long,\
    \ Int, Int))._1))\n        pq += ((dist(0)(0), 0, 0))\n        while (!pq.isEmpty)\
    \ {\n            val (d, x, y) = pq.dequeue\n            if (d > dist(x)(y)) continue\n\
    \            List((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)).foreach(t =>\
    \ {\n                val (u, v) = t\n                if (u >= 0 && u < n && v\
    \ >= 0 && v < n) {\n                    val d2 = d + grid(u)(v)\n            \
    \        if (d2 < dist(u)(v)) {\n                        dist(u)(v) = d2\n   \
    \                     pq += ((d2, u, v))\n                    }\n            \
    \    }\n            })\n        }\n        val r = ListBuffer[Long]()\n      \
    \  var i = 0\n        var j = 0\n        for (t <- 0 until k.toInt) {\n      \
    \      r += grid(i)(j)\n            val a = if (i > 0) dist(i - 1)(j) else Long.MaxValue\n\
    \            val b = if (i < n - 1) dist(i + 1)(j) else Long.MaxValue\n      \
    \      val c = if (j > 0) dist(i)(j - 1) else Long.MaxValue\n            val d\
    \ = if (j < n - 1) dist(i)(j + 1) else Long.MaxValue\n            if (a < b &&\
    \ a < c && a < d) i -= 1\n            else if (b < a && b < c && b < d) i += 1\n\
    \            else if (c < a && c < b && c < d) j -= 1\n           ", "       \
    \ def count(p : (Int, Int), k : Long) : Long = {\n            if (k == 0) 1\n\
    \            else {\n                val (x, y) = p\n                val n = grid.length\n\
    \                var count = 0l\n                if (x - 1 >= 0) count += count((x\
    \ - 1, y), k - 1)\n                if (x + 1 < n) count += count((x + 1, y), k\
    \ - 1)\n                if (y - 1 >= 0) count += count((x, y - 1), k - 1)\n  \
    \              if (y + 1 < n) count += count((x, y + 1), k - 1)\n            \
    \    count\n            }\n        }\n        def minPathList(p : (Int, Int),\
    \ k : Long) : List[(Int, Int)] = {\n            if (k == 0) List(p)\n        \
    \    else {\n                val (x, y) = p\n                val n = grid.length\n\
    \                val neighbors = {\n                    val neighbors = ListBuffer[(Int,\
    \ Int)]()\n                    if (x - 1 >= 0) neighbors += ((x - 1, y))\n   \
    \                 if (x + 1 < n) neighbors += ((x + 1, y))\n                 \
    \   if (y - 1 >= 0) neighbors += ((x, y - 1))\n                    if (y + 1 <\
    \ n) neighbors += ((x, y + 1))\n                    neighbors.toList\n       \
    \         }\n                val max = neighbors.map(p => count(p, k - 1)).max\n\
    \                val paths = neighbors.filter(p => count(p, k - 1) == max)\n \
    \               val bestPath = paths.sortWith((a, b) => {\n                  \
    \  if (grid(a._1)(a._2) < grid(b._1)(b._2)) true\n                    else if\
    \ (grid(a._1)(a._2) > grid(b._1)(b._2)) false\n                    else a < b\n\
    \                }).head\n                bestPath :: minPathList(bestPath, k\
    \ - 1)\n            }\n        }\n        val n = grid.length\n        val path\
    \ = minPathList((0, 0), k)\n        val lst = path.map(p => grid(", "        //\
    \ dp(i)(j)(d) = minimum path going through (i, j) with length d\n        val dp\
    \ = Array.fill(grid.length, grid.length, k.toInt + 1)(Long.MaxValue)\n       \
    \ for (i <- 0 until grid.length; j <- 0 until grid.length) {\n            if (i\
    \ == 0 && j == 0) dp(i)(j)(1) = grid(i)(j)\n            else {\n             \
    \   if (i > 0) dp(i)(j)(1) = min(dp(i)(j)(1), grid(i)(j))\n                if\
    \ (j > 0) dp(i)(j)(1) = min(dp(i)(j)(1), grid(i)(j))\n            }\n        }\n\
    \        for (i <- 0 until grid.length; j <- 0 until grid.length; d <- 2 to k.toInt)\
    \ {\n            if (i > 0) dp(i)(j)(d) = min(dp(i)(j)(d), dp(i - 1)(j)(d - 1)\
    \ + grid(i)(j))\n            if (j > 0) dp(i)(j)(d) = min(dp(i)(j)(d), dp(i)(j\
    \ - 1)(d - 1) + grid(i)(j))\n            if (i < grid.length - 1) dp(i)(j)(d)\
    \ = min(dp(i)(j)(d), dp(i + 1)(j)(d - 1) + grid(i)(j))\n            if (j < grid.length\
    \ - 1) dp(i)(j)(d) = min(dp(i)(j)(d), dp(i)(j + 1)(d - 1) + grid(i)(j))\n    \
    \    }\n        def rec(i : Int, j : Int, d : Int) : List[Long] = {\n        \
    \    if (d == 1) List(grid(i)(j))\n            else {\n                if (i >\
    \ 0 && dp(i)(j)(d) == dp(i - 1)(j)(d - 1) + grid(i)(j)) rec(i - 1, j, d - 1) :+\
    \ grid", "        // Your Code Here\n        var n = grid.length\n        var\
    \ m = grid(0).length\n        var table = Array.ofDim[Long](n, m, k.toInt)\n \
    \       for (i <- 0 until n) {\n            for (j <- 0 until m) {\n         \
    \       for (p <- 0 until k.toInt) {\n                    table(i)(j)(p) = Int.MaxValue\n\
    \                }\n            }\n        }\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                table(i)(j)(0) = grid(i)(j)\n\
    \            }\n        }\n        var dx = Array(1, -1, 0, 0)\n        var dy\
    \ = Array(0, 0, 1, -1)\n        for (p <- 1 until k.toInt) {\n            for\
    \ (i <- 0 until n) {\n                for (j <- 0 until m) {\n               \
    \     for (q <- 0 until 4) {\n                        var x = i + dx(q)\n    \
    \                    var y = j + dy(q)\n                        if (x >= 0 &&\
    \ x < n && y >= 0 && y < m) {\n                            table(i)(j)(p) = min(table(i)(j)(p),\
    \ table(x)(y)(p - 1))\n                        }\n                    }\n    \
    \            }\n            }\n        }\n        var ret = Long.MaxValue\n  \
    \      var ind = -1\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (table(i)(j)(k.toInt - 1) < ret) {\n              \
    \      ret = table(i)(j)(k.toInt - 1)\n                    ind = i * m + j\n \
    \               }\n            }\n        }\n        var xx = Array(ind / m, ind\
    \ % m)\n        var retlst = List[Long]()\n        retlst = retlst :+ ret\n  \
    \      for (p <- k.toInt - 2 to 0 by -1) {\n            var retval = Long.MaxValue\n\
    \            var indx = -1\n            var indy = -1\n            for (q <- 0\
    \ until 4) {\n                var x", "\t    // let grid[r][c] = v means the cell\
    \ at the r-th row and the c-th column\n\t    // contains the value v.\n\t    //\
    \ let pos = (r, c) means the cell at the r-th row and the c-th column.\n\t   \
    \ // let path = (a, b, c, ..., d) means visiting the cells pos_a, pos_b, pos_c,\
    \ ..., pos_d in order.\n\t    // let val_path = (v_a, v_b, v_c, ..., v_d) means\
    \ the list of the values on the cells pos_a, pos_b, pos_c, ..., pos_d in order.\n\
    \t    // let row = r means the cell is in the r-th row.\n\t    // let col = c\
    \ means the cell is in the c-th column.\n\t    // let val = v means the cell contains\
    \ the value v.\n\t    // note that we can represent the grid as:\n\t    // grid\
    \ = { pos_1, pos_2, ..., pos_n }\n\t    // for any element pos_i in grid, pos_i\
    \ = (row_i, col_i, val_i).\n\t    // Observation:\n\t    // The minimum path has\
    \ to start from the smallest cell and end at the largest cell.\n\t    // To find\
    \ the minimum path, we should find the path that goes through the cells in increasing\
    \ order.\n\t    // then, we get the minimum path.\n\t    // =>\n\t    // Find\
    \ a path that goes through the cells in increasing order (we call it a \"good\
    \ path\").\n\t    // Note that a good path has to start from the smallest cell\
    \ and end at the largest cell.\n\t    // Now we have to find the shortest good\
    \ path.\n\t    // Let's call the shortest good path the minimum path.\n\t    //\
    \ Now we have to find the shortest good path.\n\t    // Let's call the shortest\
    \ good path the minimum path.\n\t    // =>\n\t    // Find the minimum path in\
    \ the graph G = (grid, edges).\n\t    // for any pos_i in grid, let pos_i = (row_i,\
    \ col_i, val_i).\n\t   ", "        // (value, (x, y))\n        val map = Map[Long,\
    \ (Int, Int)]()\n        for (i <- 0 until grid.length) {\n            for (j\
    \ <- 0 until grid(i).length) {\n                map(grid(i)(j)) = (i, j)\n   \
    \         }\n        }\n        val result = ListBuffer[Long]()\n        val visited\
    \ = Array.fill(grid.length, grid.length)(false)\n        val dx = Array(1, 0,\
    \ -1, 0)\n        val dy = Array(0, 1, 0, -1)\n        def bfs(start : (Int, Int),\
    \ k : Long) : List[Long] = {\n            val queue = Queue[(Int, Int)]()\n  \
    \          queue.enqueue(start)\n            visited(start._1)(start._2) = true\n\
    \            val path = ListBuffer[Long]()\n            path += grid(start._1)(start._2)\n\
    \            while (!queue.isEmpty) {\n                val (x, y) = queue.dequeue\n\
    \                for (i <- 0 until 4) {\n                    val (nextX, nextY)\
    \ = (x + dx(i), y + dy(i))\n                    if (nextX >= 0 && nextX < grid.length\
    \ && nextY >= 0 && nextY < grid.length && !visited(nextX)(nextY)) {\n        \
    \                visited(nextX)(nextY) = true\n                        queue.enqueue((nextX,\
    \ nextY))\n                        path += grid(nextX)(nextY)\n              \
    \      }\n                }\n            }\n            path.toList\n        }\n\
    \        var tempResult = List[Long]()\n        val n = grid.length\n        for\
    \ (i <- 1 until n * n + 1) {\n            val (x, y) = map(i)\n            for\
    \ (j <- 0 until grid.length) {\n                for (k <- 0 until grid(j).length)\
    \ {\n                    visited(j)(k) = false\n                }\n          \
    \  }\n            visited(x)(y) = true\n            tempResult = bfs((x, y), k)\n\
    \            if (tempResult.length >= k.toInt) {\n                result ++= temp",
  "        val n = grid.length\n        val h = Array.fill(n, n)(-1)\n        val\
    \ d = Array.fill(n, n)(-1)\n        val q = Queue[(Int, Int)]()\n        val m\
    \ = new HashMap[(Int, Int), List[(Int, Int)]]()\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until n) {\n                val e = (i, j)\n    \
    \            if (i - 1 >= 0) m.update(e, m.getOrElse(e, List()) :+ (i - 1, j))\n\
    \                if (i + 1 < n) m.update(e, m.getOrElse(e, List()) :+ (i + 1,\
    \ j))\n                if (j - 1 >= 0) m.update(e, m.getOrElse(e, List()) :+ (i,\
    \ j - 1))\n                if (j + 1 < n) m.update(e, m.getOrElse(e, List()) :+\
    \ (i, j + 1))\n            }\n        }\n        val s = new HashSet[(Int, Int)]()\n\
    \        q.enqueue((0, 0))\n        d(0)(0) = 0\n        while (!q.isEmpty) {\n\
    \            val c = q.dequeue\n            val x = c._1\n            val y =\
    \ c._2\n            if (x == n - 1 && y == n - 1) {\n                s.add(c)\n\
    \                d(x)(y) = 0\n            }\n            else {\n            \
    \    for (neighbor <- m.getOrElse(c, List())) {\n                    val nx =\
    \ neighbor._1\n                    val ny = neighbor._2\n                    if\
    \ (d(nx)(ny) == -1 || d(nx)(ny) > d(x)(y) + 1) {\n                        if (d(nx)(ny)\
    \ == -1) {\n                            h(nx)(ny) = h(x)(y) + 1\n            \
    \                q.enqueue(neighbor)\n                        }\n            \
    \            d(nx)(ny) = d(x)(y) + 1\n                    }\n               ",
  "        // You don't need to check input validity.\n        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(Int.MaxValue)\n        dp(0)(0) = 0\n     \
    \   val prev = Array.fill(n, n)(List[Int]())\n        for (length <- 1 to k.toInt)\
    \ {\n            for (r <- 0 until n) {\n                for (c <- 0 until n)\
    \ {\n                    if (r > 0 && dp(r - 1)(c) + 1 < dp(r)(c)) {\n       \
    \                 dp(r)(c) = dp(r - 1)(c) + 1\n                        prev(r)(c)\
    \ = (r - 1) :: prev(r - 1)(c)\n                    }\n                    if (c\
    \ > 0 && dp(r)(c - 1) + 1 < dp(r)(c)) {\n                        dp(r)(c) = dp(r)(c\
    \ - 1) + 1\n                        prev(r)(c) = (c - 1) :: prev(r)(c - 1)\n \
    \                   }\n                    if (r < n - 1 && dp(r + 1)(c) + 1 <\
    \ dp(r)(c)) {\n                        dp(r)(c) = dp(r + 1)(c) + 1\n         \
    \               prev(r)(c) = (r + 1) :: prev(r + 1)(c)\n                    }\n\
    \                    if (c < n - 1 && dp(r)(c + 1) + 1 < dp(r)(c)) {\n       \
    \                 dp(r)(c) = dp(r)(c + 1) + 1\n                        prev(r)(c)\
    \ = (c + 1) :: prev(r)(c + 1)\n                    }\n                }\n    \
    \        }\n        }\n        def getMinPath(r : Int, c : Int) : List[Long] =\
    \ {\n            if (prev(r)(c).isEmpty) List(grid(r)(c))\n            else grid(r)(c)\
    \ :: getMinPath(prev(r)(c).head, prev(r)(c).tail.head)\n        }\n        getMinPath(n\
    \ - 1, n - 1)\n    }", "        // Given a state (i, j, k, path), return the next\
    \ k states that are connected to this state\n        // by a path of length 1\n\
    \        def neighbors(i : Int, j : Int, k : Long, path : List[Long]) : List[(Int,\
    \ Int, Long, List[Long])] = {\n            if (i > 0) {\n                (i -\
    \ 1, j, k - 1, grid(i - 1)(j) :: path) :: (if (j > 0) {\n                    (i,\
    \ j - 1, k - 1, grid(i)(j - 1) :: path) :: (if (j < grid(0).length - 1) {\n  \
    \                      (i, j + 1, k - 1, grid(i)(j + 1) :: path) :: (if (i < grid.length\
    \ - 1) {\n                            (i + 1, j, k - 1, grid(i + 1)(j) :: path)\
    \ :: Nil\n                        } else {\n                            Nil\n\
    \                        })\n                    } else {\n                  \
    \      Nil\n                    })\n                } else {\n               \
    \     Nil\n                })\n            } else {\n                (if (j >\
    \ 0) {\n                    (i, j - 1, k - 1, grid(i)(j - 1) :: path) :: (if (j\
    \ < grid(0).length - 1) {\n                        (i, j + 1, k - 1, grid(i)(j\
    \ + 1) :: path) :: (if (i < grid.length - 1) {\n                            (i\
    \ + 1, j, k - 1, grid(i + 1)(j) :: path) :: Nil\n                        } else\
    \ {\n                            Nil\n                        })\n           \
    \         } else {\n                        Nil\n                    })\n    \
    \            } else {\n                    (if (j < grid(0).length - 1) {\n  \
    \                      (i, j + 1, k - 1, grid(i)(j + 1) :: path) :: (if (i < grid.length\
    \ - 1) {\n                            (i + 1, j, k - 1, grid(i + 1)(j) :: path)\
    \ :: Nil\n                        } else {\n                            Nil\n\
    \                        })\n                    } else {\n                  \
    \      (if (i < grid.length - 1) {\n", "        if (k == 1) {\n            val\
    \ flatten = grid.flatten\n            return List(flatten.min)\n        }\n  \
    \      case class Cell(i : Int, j : Int, value : Long)\n        case class Path(cells\
    \ : List[Cell], min_value : Long) extends Ordered[Path] {\n            override\
    \ def compare(that : Path) : Int = {\n                if (cells.size != that.cells.size)\
    \ throw new Exception(\"Cannot compare paths with different lengths\")\n     \
    \           for (i <- 0 until cells.size) {\n                    if (cells(i).value\
    \ != that.cells(i).value) return (cells(i).value - that.cells(i).value).toInt\n\
    \                }\n                return 0\n            }\n        }\n     \
    \   val rows = grid.size\n        val cols = grid(0).size\n        val d = Array.ofDim[Cell](rows,\
    \ cols)\n        for (i <- 0 until rows; j <- 0 until cols) d(i)(j) = Cell(i,\
    \ j, grid(i)(j))\n        val pq = new PriorityQueue[Path]()(Ordering.by((_ :\
    \ Path).cells.head.value).reverse)\n        for (i <- 0 until rows; j <- 0 until\
    \ cols) {\n            if (i > 0) pq += Path(List(d(i)(j), d(i - 1)(j)), (d(i)(j).value\
    \ + d(i - 1)(j).value))\n            if (i < rows - 1) pq += Path(List(d(i)(j),\
    \ d(i + 1)(j)), (d(i)(j).value + d(i + 1)(j).value))\n            if (j > 0) pq\
    \ += Path(List(d(i)(j), d(i)(j - 1)), (d(i)(j).value + d(i)(j - 1).value))\n \
    \           if (j < cols - 1) pq += Path(List(d(i)(j), d(i)(j + 1)), (d(i)(j).value\
    \ + d(i)(j + 1).value))\n        }\n        while (pq.size > 0) {\n           ",
  "        var ans : List[Long] = List[Long]()\n        return ans", "        // The\
    \ distance of paths with i steps is denoted as dist[i], and the minimum path with\
    \ i steps is minPath[i].\n        // We use a map to store the grid because we\
    \ need quick access to grid cells.\n        val gridMap = Map.empty[(Int, Int),\
    \ Long]\n        for (i <- 0 until grid.length) {\n            for (j <- 0 until\
    \ grid(i).length) {\n                gridMap((i, j)) = grid(i)(j)\n          \
    \  }\n        }\n        // We use an array of lists to store the paths because\
    \ we need to reverse the lists.\n        // If we use ListBuffer, it will take\
    \ O(n) time to reverse a list.\n        val dist = new Array[List[Long]](k.toInt\
    \ + 1)\n        for (i <- 0 until dist.length) {\n            dist(i) = List.empty[Long]\n\
    \        }\n        // Recursively assign the minimum paths using dynamic programming.\n\
    \        // dist(i) = min(dist(i - 1), dist(i - 2), ..., dist(i - min(i, k - i))\
    \ + grid(i))\n        def dp(i : Int, j : Int) : Unit = {\n            if (i >=\
    \ 0 && i < dist.length && j >= 0 && j < dist.length) {\n                // For\
    \ every i, dist(i) is assigned only once, that is, we need to do an \"or\".\n\
    \                // If dist(i) is empty, it is assigned; otherwise, it is left\
    \ as is.\n                val cands = ListBuffer.empty[List[Long]]\n         \
    \       for (d <- 0 until min(i, k.toInt - i)) {\n                    if (i -\
    \ d - 1 >= 0) {\n                        val path = dist(i - d - 1)\n        \
    \                // If the last step to get to path(i - d - 1) is not the current\
    \ cell, \n                        // we can use path(i - d - 1) to get to path(i\
    \ - d).\n                        if (path.length > 0 && path.last != gridMap((i\
    \ - d, j))) {\n                            cands += (path :+ gridMap((i - d, j)))\n\
    \                       ", "        // Write your code here\n        return List[Long]()",
  "        val m = grid.length\n        val n = grid(0).length\n        // val numbers\
    \ = Array.ofDim[Long](m, n)\n        val numbers = Array.fill[Long](m, n)(Long.MaxValue)\n\
    \        val visited = Array.fill[Boolean](m, n)(false)\n        var i = 0\n \
    \       while (i < m) {\n            var j = 0\n            while (j < n) {\n\
    \                numbers(i)(j) = grid(i)(j)\n                j += 1\n        \
    \    }\n            i += 1\n        }\n        def bfs() : Boolean = {\n     \
    \       val pq = Array.fill[(Long, Int, Int)](m * n)((Long.MaxValue, 0, 0))\n\
    \            var first = 0\n            var last = 0\n            last += 1\n\
    \            pq(last) = (numbers(0)(0), 0, 0)\n            while (first < last)\
    \ {\n                val cur = pq(first)\n                val curNum = cur._1\n\
    \                val curX = cur._2\n                val curY = cur._3\n      \
    \          first += 1\n                if (curNum < numbers(curX)(curY)) {\n \
    \                   numbers(curX)(curY) = curNum\n                    val dirs\
    \ = List((0, 1), (0, -1), (1, 0), (-1, 0))\n                    dirs.foreach(x\
    \ => {\n                        val nextX = curX + x._1\n                    \
    \    val nextY = curY + x._2\n                        if (nextX >= 0 && nextX\
    \ < m && nextY >= 0 && nextY < n) {\n                            val nextNum =\
    \ curNum + grid(nextX)(nextY)\n                            if (nextNum < numbers(nextX)(nextY))\
    \ {\n                                last += 1\n                             \
    \   pq(last) = (nextNum, nextX, nextY)\n                            }\n      \
    \                  }\n                    })\n                }\n            }\n\
    \            return numbers(m - 1)(n - 1) <= k\n        }\n        def dfs(x :\
    \ Int, y : Int, curSum : Long, curK : Long, curRes : List[Long]) : List[Long]\
    \ =", "        // minPath(grid, i, j, k) = minimum path from grid[i][j] to grid[i][j]\
    \ of length k\n        // minPath(grid, i, j, k) = if k == 0, grid[i][j]\n   \
    \     //                         = if k < 0, None\n        //                \
    \         = if i, j < 0 || i, j >= len(grid), None\n        //               \
    \          = if grid[i][j] == None, None\n        //                         =\
    \ min(minPath(grid, i, j, k - 1) + grid[i][j], minPath(grid, i + 1, j, k - 1)\
    \ + grid[i][j], minPath(grid, i - 1, j, k - 1) + grid[i][j], minPath(grid, i,\
    \ j + 1, k - 1) + grid[i][j], minPath(grid, i, j - 1, k - 1) + grid[i][j])\n \
    \       val len = grid.length\n        val ans = new Array[(List[Long], List[Long])](len)\n\
    \        for (i <- 0 until len) ans(i) = new Array[(List[Long], List[Long])](len)\n\
    \        for (i <- 0 until len) for (j <- 0 until len) ans(i)(j) = (Nil, Nil)\n\
    \        for (k <- 1 to k.toInt) {\n            for (i <- 0 until len) for (j\
    \ <- 0 until len) {\n                if (grid(i)(j) != None) {\n             \
    \       if (k == 1) ans(i)(j) = (List(grid(i)(j)), List(grid(i)(j)))\n       \
    \             else {\n                        var minimum = ans(i)(j)\n      \
    \                  if (i > 0) {\n                            val result = (ans(i\
    \ - 1)(j)._1, ans(i - 1)(j)._2 :+ grid(i)(j))\n                            if\
    \ (result._1 != Nil && (minimum._1 == Nil || result._1 < minimum._1)) minimum\
    \ = result\n                        }\n                        if (i < len - 1)\
    \ {\n                            val result = (ans(i + 1)(j)._1,", "        var\
    \ result = List[Long]()\n        val n = grid.length\n        val pos = new Array[(Int,\
    \ Int)](n * n)\n        for (x <- 0 until n; y <- 0 until n) {\n            pos(grid(x)(y).toInt\
    \ - 1) = (x, y)\n        }\n        var min = Long.MaxValue\n        for (i <-\
    \ 0 until n * n) {\n            val (sx, sy) = pos(i)\n            var cost =\
    \ new Array[Long](n * n)\n            for (j <- 0 until n * n) {\n           \
    \     val (tx, ty) = pos(j)\n                cost(j) = abs(sx - tx) + abs(sy -\
    \ ty)\n            }\n            for (j <- 0 until n * n) {\n               \
    \ for (l <- j + 1 until n * n) {\n                    if (cost(j) > cost(l)) {\n\
    \                        val tmp = cost(j)\n                        cost(j) =\
    \ cost(l)\n                        cost(l) = tmp\n                        val\
    \ tmpp = pos(j)\n                        pos(j) = pos(l)\n                   \
    \     pos(l) = tmpp\n                    }\n                }\n            }\n\
    \            var total = cost.sum\n            if (total < min) {\n          \
    \      min = total\n                result = pos.take(k.toInt).map(x => (x._1\
    \ + 1).toLong).toList\n            }\n        }\n        result", "        var\
    \ last = List[Long]()\n        var current = List[Long]()\n        for (i <- 0\
    \ until grid.length) {\n            for (j <- 0 until grid(i).length) {\n    \
    \            val x = grid(i)(j)\n                current ::= x\n             \
    \   if (i + j < 2) last = current\n                else {\n                  \
    \  var min = last\n                    var minj = 0\n                    for (j\
    \ <- 0 until 3) {\n                        if (j != i && j != i + 1) {\n     \
    \                       if (j == 0) {\n                                if (last(0)\
    \ > last(1)) {\n                                    min = last.tail\n        \
    \                            minj = j\n                                }\n   \
    \                         } else if (j == 2) {\n                             \
    \   if (last(1) > last(2)) {\n                                    min = last.take(2)\n\
    \                                    minj = j\n                              \
    \  }\n                            }\n                        }\n             \
    \       }\n                    current = min :+ x\n                    last =\
    \ current\n                }\n            }\n        }\n        last", "     \
    \   val max = grid.length\n        var min = 0l\n        val grid2 = Array.ofDim[Long](max,\
    \ max)\n        for (i <- 0 until max) {\n            for (j <- 0 until max) {\n\
    \                grid2(i)(j) = grid(i)(j)\n            }\n        }\n        for\
    \ (i <- 0 until max) {\n            for (j <- 0 until max) {\n               \
    \ if (grid2(i)(j) > 0) {\n                    min = grid2(i)(j)\n            \
    \        break\n                }\n            }\n        }\n        var cand\
    \ = scala.collection.mutable.ListBuffer[Long]()\n        def solve(x : Int, y\
    \ : Int, path : List[Long], visited : Set[(Int, Int)]) : Unit = {\n          \
    \  if (path.length == k) {\n                cand += toLong(path)\n           \
    \     return\n            }\n            if (x - 1 >= 0 && !visited.contains((x\
    \ - 1, y))) {\n                solve(x - 1, y, grid2(x - 1)(y) :: path, visited\
    \ + ((x - 1, y)))\n            }\n            if (x + 1 < max && !visited.contains((x\
    \ + 1, y))) {\n                solve(x + 1, y, grid2(x + 1)(y) :: path, visited\
    \ + ((x + 1, y)))\n            }\n            if (y - 1 >= 0 && !visited.contains((x,\
    \ y - 1))) {\n                solve(x, y - 1, grid2(x)(y - 1) :: path, visited\
    \ + ((x, y - 1)))\n            }\n            if (y + 1 < max && !visited.contains((x,\
    \ y + 1))) {\n                solve(x, y + 1, grid2(x)(y + 1) :: path, visited\
    \ + ((x, y + 1)))\n            }\n        }\n        for (i <- 0 until max) {\n\
    \            for (j <- 0 until max) {\n                if (grid2(i)(j) > 0) {\n\
    \                    solve(i, j, List(grid2(i)(j)), Set())\n                }\n\
    \            }\n", "        // Your code here\n        return List[Long]()", " \
    \       val n = grid.length\n        val m = grid(0).length\n        var values\
    \ = collection.mutable.MutableList[Long]()\n        val map = collection.mutable.Map[(Int,\
    \ Int), (Int, Int)]()\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                values += grid(i)(j)\n                map((i, j))\
    \ = (i, j)\n            }\n        }\n        values = values.sorted\n       \
    \ val indexes = collection.mutable.Map[Long, (Int, Int)]()\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                indexes(grid(i)(j))\
    \ = (i, j)\n            }\n        }\n        val adj = Array.ofDim[List[(Int,\
    \ Int)]](n, m)\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                val x = collection.mutable.MutableList[(Int, Int)]()\n\
    \                if (i > 0) x += ((i - 1, j))\n                if (i < n - 1)\
    \ x += ((i + 1, j))\n                if (j > 0) x += ((i, j - 1))\n          \
    \      if (j < m - 1) x += ((i, j + 1))\n                adj(i)(j) = x.toList\n\
    \            }\n        }\n        def check(path : List[(Int, Int)]) : Boolean\
    \ = {\n            if (path.length == k.toInt) return true\n            val v\
    \ = path.last\n            for (i <- 0 until n) {\n                for (j <- 0\
    \ until m) {\n                    map((i, j)) = (i, j)\n                }\n  \
    \          }\n            for (x <- path) {\n                val (i, j) = x\n\
    \                val next = adj(i)(j)\n                for (y <- next) {\n   \
    \                 val (i1, j1) = y\n                    map((i1, j1)) = (i, j)\n\
    \                }\n            }\n            val ns = adj(v._1)(v._2)\n    \
    \       ", "        // Write your solution here\n        var startRow = -1\n \
    \       var startCol = -1\n        var minList = ArrayBuffer[Long]()\n       \
    \ for (i <- 0 until grid.length) {\n            var list = grid(i)\n         \
    \   for (j <- 0 until list.length) {\n                if (list(j) == 1) {\n  \
    \                  startRow = i\n                    startCol = j\n          \
    \      }\n            }\n        }\n        var map = new HashMap[Tuple2[Int,\
    \ Int], ArrayBuffer[Long]]()\n        var set = new HashSet[Tuple2[Int, Int]]()\n\
    \        set.add((startRow, startCol))\n        if (grid(startRow)(startCol) ==\
    \ 1) {\n            map((startRow, startCol)) = ArrayBuffer[Long](1)\n       \
    \ }\n        var count = 0\n        while (count < k) {\n            var newSet\
    \ = new HashSet[Tuple2[Int, Int]]()\n            for (i <- set) {\n          \
    \      var list = map(i)\n                var n = grid.length\n              \
    \  var m = grid(0).length\n                if (i._1 > 0 && !set.contains((i._1\
    \ - 1, i._2))) {\n                    var newList = ArrayBuffer[Long]()\n    \
    \                for (j <- list) {\n                        newList.append(j)\n\
    \                    }\n                    newList.append(grid(i._1 - 1)(i._2))\n\
    \                    map((i._1 - 1, i._2)) = newList\n                    newSet.add((i._1\
    \ - 1, i._2))\n                }\n                if (i._1 < n - 1 && !set.contains((i._1\
    \ + 1, i._2))) {\n                    var newList = ArrayBuffer[Long]()\n    \
    \                for (j <- list) {\n                        newList.append(j)\n\
    \                    }\n                    newList.append(grid(i._1 + 1)(i._2))\n\
    \                    map((i._1 + 1, i._2)) = newList\n                    newSet.add((i._1\
    \ + 1, i._2))\n                }\n                if (i._2 > 0 && !set.contains",
  "        // your code here\n        val n = grid.length\n        val G = Array.fill(n,\
    \ n)(List[List[Long]]())\n        for (i <- 0 until n) for (j <- 0 until n) {\n\
    \            val x = grid(i)(j)\n            if (i > 0) {\n                val\
    \ y = grid(i - 1)(j)\n                if (x < y) G(i)(j) = G(i)(j) :+ List[Long](x,\
    \ y)\n                else G(i)(j) = G(i)(j) :+ List[Long](y, x)\n           \
    \ }\n            if (i < n - 1) {\n                val y = grid(i + 1)(j)\n  \
    \              if (x < y) G(i)(j) = G(i)(j) :+ List[Long](x, y)\n            \
    \    else G(i)(j) = G(i)(j) :+ List[Long](y, x)\n            }\n            if\
    \ (j > 0) {\n                val y = grid(i)(j - 1)\n                if (x < y)\
    \ G(i)(j) = G(i)(j) :+ List[Long](x, y)\n                else G(i)(j) = G(i)(j)\
    \ :+ List[Long](y, x)\n            }\n            if (j < n - 1) {\n         \
    \       val y = grid(i)(j + 1)\n                if (x < y) G(i)(j) = G(i)(j) :+\
    \ List[Long](x, y)\n                else G(i)(j) = G(i)(j) :+ List[Long](y, x)\n\
    \            }\n        }\n        val A = Array.fill(n * n)(List[List[Long]]())\n\
    \        for (i <- 0 until n) for (j <- 0 until n) A(grid(i)(j).toInt - 1) = G(i)(j)\n\
    \        val pq = new BinaryHeap[List[Long]]((lst1, lst2) => lst1(0) < lst2(0))\n\
    \        val inq = Array.fill(n * n)(false)\n", "        def getMinPath(grid :\
    \ List[List[Long]], k : Long, currentCell : (Int, Int), visited : HashSet[(Int,\
    \ Int)]) : List[Long] = {\n            val rowCount = grid.length\n          \
    \  val columnCount = grid(0).length\n            val thisCell = grid(currentCell._1)(currentCell._2)\n\
    \            if (k == 1) {\n                return List(thisCell)\n          \
    \  }\n            else {\n                val adjacentCells = List((currentCell._1\
    \ - 1, currentCell._2), (currentCell._1 + 1, currentCell._2), (currentCell._1,\
    \ currentCell._2 - 1), (currentCell._1, currentCell._2 + 1))\n               \
    \ val adjacentCellsToVisit = adjacentCells.filter(cell => cell._1 >= 0 && cell._1\
    \ < rowCount && cell._2 >= 0 && cell._2 < columnCount && visited.contains(cell)\
    \ == false)\n                if (adjacentCellsToVisit.length == 0) {\n       \
    \             return List(thisCell)\n                }\n                else {\n\
    \                    val minimumPaths = adjacentCellsToVisit.map(cell => (cell,\
    \ grid(cell._1)(cell._2))).sortBy(cell => cell._2).map(cell => {\n           \
    \             val newVisited = visited.clone\n                        newVisited.add(cell._1)\n\
    \                        val subPath = getMinPath(grid, k - 1, cell._1, newVisited)\n\
    \                        List(thisCell) ++ subPath\n                    })\n \
    \                   return minimumPaths.minBy(path => path)\n                }\n\
    \            }\n        }\n        val rowCount = grid.length\n        val columnCount\
    \ = grid(0).length\n        var minimumPath = List[Long]()\n        for (i <-\
    \ 0 until rowCount) {\n            for (j <- 0 until columnCount) {\n        \
    \        val newVisited = HashSet[(Int, Int)]()\n                newVisited.add((i,\
    \ j))\n                val subPath = getMinPath(grid, k, (i, j), newVisited)\n\
    \                if (minimumPath.length == 0 || subPath.length > 0 && subPath.zip(minimumPath).take",
  "        // \n        // We create a priority queue to store all paths of length\
    \ k.\n        // In each step, we extract the minimum path from the queue\n  \
    \      // and add all new paths of length k + 1 to the queue.\n        // We iterate\
    \ over all new paths, if the new path is smaller than\n        // the current\
    \ minimum path, we update the minimum path.\n        // \n        // We use a\
    \ class Node to represent the nodes in the path.\n        class Node(val value\
    \ : Long, val row : Int, val col : Int) extends Ordered[Node] {\n            def\
    \ compare(that : Node) = {\n                if (this.value < that.value) -1\n\
    \                else if (this.value > that.value) 1\n                else 0\n\
    \            }\n        }\n        // \n        // Return the number of rows and\
    \ columns of a grid.\n        // \n        def getSize(grid : List[List[Long]])\
    \ : (Int, Int) = {\n            (grid.length, grid(0).length)\n        }\n   \
    \     // \n        // Return whether a node is in a path.\n        // \n     \
    \   def inPath(node : Node, path : List[Node]) : Boolean = {\n            path.exists(p\
    \ => p.row == node.row && p.col == node.col)\n        }\n        // \n       \
    \ // Return all neighbors of a node in a grid.\n        // \n        def getNeighbors(node\
    \ : Node, grid : List[List[Long]]) : List[Node] = {\n            val (n, m) =\
    \ getSize(grid)\n            List(\n                if (node.row > 0) Some(new\
    \ Node(grid(node.row - 1)(node.col), node.row - 1, node.col)) else None,\n   \
    \             if (node.row < n - 1) Some(new Node(grid(node.row + 1)(node.col),\
    \ node.row + 1, node.col)) else None,\n                if (node.col > 0) Some(new\
    \ Node(grid(node.row)(node.col - 1), node.row, node.col - 1)) else None,\n   \
    \             if (node.col < m - 1) Some(new", "        var n = grid.length\n\
    \        var m = grid(0).length\n        var target = grid.flatten.sorted\n  \
    \      // generate all paths\n        var paths = new ListBuffer[List[(Int, Int)]]\n\
    \        for (i <- 0 until n; j <- 0 until m) {\n            var q = new Queue[(Int,\
    \ Int)]\n            q.enqueue((i, j))\n            var visited = new HashSet[(Int,\
    \ Int)]\n            visited.add((i, j))\n            while (!q.isEmpty) {\n \
    \               var l = q.dequeue\n                if (l._1 > 0 && !visited.contains((l._1\
    \ - 1, l._2))) {\n                    var x = (l._1 - 1, l._2)\n             \
    \       visited.add(x)\n                    q.enqueue(x)\n                }\n\
    \                if (l._1 < n - 1 && !visited.contains((l._1 + 1, l._2))) {\n\
    \                    var x = (l._1 + 1, l._2)\n                    visited.add(x)\n\
    \                    q.enqueue(x)\n                }\n                if (l._2\
    \ > 0 && !visited.contains((l._1, l._2 - 1))) {\n                    var x = (l._1,\
    \ l._2 - 1)\n                    visited.add(x)\n                    q.enqueue(x)\n\
    \                }\n                if (l._2 < m - 1 && !visited.contains((l._1,\
    \ l._2 + 1))) {\n                    var x = (l._1, l._2 + 1)\n              \
    \      visited.add(x)\n                    q.enqueue(x)\n                }\n \
    \           }\n            if (visited.size == k) paths.append(visited.toList)\n\
    \        }\n        // generate all values\n        var values = new ListBuffer[List[Long]]\n\
    \        for (p <- paths) {\n            var v = new ListBuffer[Long]\n      \
    \      for (point <- p) v.append(grid(point._1)(point._2))\n            values.append(v.toList)\n\
    \        }\n        var min = values(0)\n        for", "        var m = List[List[Long]]()\n\
    \        for (i <- 0 until grid.length) {\n            var tmp = List[Long]()\n\
    \            for (j <- 0 until grid(i).length) {\n                tmp = tmp :+\
    \ grid(i)(j)\n            }\n            m = m :+ tmp\n        }\n        var\
    \ t = m\n        for (l <- 0 until k.toInt - 1) {\n            t = helper(t)\n\
    \        }\n        var min = List[Long]()\n        for (i <- 0 until t.length)\
    \ {\n            for (j <- 0 until t(i).length) {\n                min = min :+\
    \ t(i)(j)\n            }\n        }\n        return min", '        ???', "   \
    \     type Point = (Int, Int)\n        var minPath = List[Point]()\n        var\
    \ minVal = grid.map(x => x.map(y => (y, y))).toArray\n        var g = grid.map(x\
    \ => x.map(y => (y, 1L))).toArray\n        for (cur <- 1 to k.toInt) {\n     \
    \       for (i <- 0 until g.length) {\n                for (j <- 0 until g(i).length)\
    \ {\n                    if (i > 0 && (g(i - 1)(j)._1 + g(i)(j)._1 < g(i - 1)(j)._2\
    \ + g(i)(j)._2 || (g(i - 1)(j)._1 + g(i)(j)._1 == g(i - 1)(j)._2 + g(i)(j)._2\
    \ && g(i - 1)(j)._1 < g(i)(j)._1))) {\n                        g(i - 1)(j) = (g(i\
    \ - 1)(j)._1 + g(i)(j)._1, g(i - 1)(j)._2 + g(i)(j)._2)\n                    \
    \    minVal(i - 1)(j) = (g(i - 1)(j)._1, minVal(i - 1)(j)._2 min g(i)(j)._2)\n\
    \                    }\n                    if (j > 0 && (g(i)(j - 1)._1 + g(i)(j)._1\
    \ < g(i)(j - 1)._2 + g(i)(j)._2 || (g(i)(j - 1)._1 + g(i)(j)._1 == g(i)(j - 1)._2\
    \ + g(i)(j)._2 && g(i)(j - 1)._1 < g(i)(j)._1))) {\n                        g(i)(j\
    \ - 1) = (g(i)(j - 1)._1 + g(i)(j)._1, g(i)(j - 1)._2 + g(i)(j)._2)\n        \
    \                minVal(i)(j - 1) = (g(i)(j - 1)._1", "        // Write your code\
    \ here\n        val sortedGrid = grid.map(_.sorted).sorted\n        var minPath\
    \ = List[Long]()\n        if (k == 1) {\n            minPath = List(sortedGrid(0)(0))\n\
    \        } else {\n            for (i <- 0 until sortedGrid.length) {\n      \
    \          for (j <- 0 until sortedGrid(i).length) {\n                    if (sortedGrid(i)(j)\
    \ == sortedGrid(0)(0)) {\n                        val path = findMinPath(sortedGrid,\
    \ i, j, k)\n                        if (minPath.isEmpty || path < minPath) minPath\
    \ = path\n                    }\n                }\n            }\n        }\n\
    \        minPath", "        // O(n^2 * k) is too slow\n        // val n = grid.length\n\
    \        // val gridMap = new HashMap[Long, Long]\n        // grid.flatten.foreach(value\
    \ => gridMap += value -> value)\n        // def dfs(position : Long, gridMap :\
    \ HashMap[Long, Long], result : List[Long], length : Long) : List[Long] = {\n\
    \        //     if (length == k) return result\n        //     val row = position\
    \ / n\n        //     val col = position % n\n        //     if (row + 1 < n &&\
    \ gridMap.contains(grid(row + 1)(col)))\n        //         dfs((row + 1) * n\
    \ + col, gridMap -= grid(row + 1)(col), result :+ grid(row + 1)(col), length +\
    \ 1)\n        //     else if (row - 1 >= 0 && gridMap.contains(grid(row - 1)(col)))\n\
    \        //         dfs((row - 1) * n + col, gridMap -= grid(row - 1)(col), result\
    \ :+ grid(row - 1)(col), length + 1)\n        //     else if (col + 1 < n && gridMap.contains(grid(row)(col\
    \ + 1)))\n        //         dfs(row * n + col + 1, gridMap -= grid(row)(col +\
    \ 1), result :+ grid(row)(col + 1), length + 1)\n        //     else if (col -\
    \ 1 >= 0 && gridMap.contains(grid(row)(col - 1)))\n        //         dfs(row\
    \ * n + col - 1, gridMap -= grid(row)(col - 1), result :+ grid(row)(col - 1),\
    \ length + 1)\n        //     else return result\n        // }\n        // grid.flatten.map(value\
    \ => dfs(grid.flatten.indexOf(value), gridMap -= value, List(value), 1)).filter(x\
    \ => x.length == k).minBy(x => x)\n        // O(n^2 * sqrt(n))\n        // val\
    \ n = grid.length\n        // def dfs(position : (Int, Int), gridMap : List[(Long,\
    \ Long)", "        var bfs = new Queue[(Long, Long, List[Long])]\n        var\
    \ visited = new HashSet[(Long, Long)]\n        val n = grid.length\n        val\
    \ dirs = List((-1, 0), (1, 0), (0, -1), (0, 1))\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until n) {\n                bfs += ((i, j, List(grid(i)(j))))\n\
    \                visited += ((i, j))\n            }\n        }\n        var ans\
    \ = List[Long]()\n        while (!bfs.isEmpty) {\n            val cur = bfs.dequeue\n\
    \            if (cur._3.length == k) {\n                if (ans.isEmpty || ans\
    \ > cur._3) ans = cur._3\n            } else {\n                for (dir <- dirs)\
    \ {\n                    val r = cur._1 + dir._1\n                    val c =\
    \ cur._2 + dir._2\n                    if (r >= 0 && r < n && c >= 0 && c < n\
    \ && !visited.contains((r, c))) {\n                        bfs += ((r, c, cur._3\
    \ :+ grid(r)(c)))\n                        visited += ((r, c))\n             \
    \       }\n                }\n            }\n        }\n        ans", "      \
    \  val n = grid.length\n        var res = new ListBuffer[Long]\n        var min\
    \ = new ListBuffer[Long]\n        min += 1000000000000l\n        var path = new\
    \ ListBuffer[Long]\n        def recurse(i : Int, j : Int, path : ListBuffer[Long])\
    \ {\n            if (i < 0 || i >= n || j < 0 || j >= n) return\n            if\
    \ (path.length == k) {\n                if (path.toList < min.toList) {\n    \
    \                min = path\n                    res = path\n                }\n\
    \                return\n            }\n            path += grid(i)(j)\n     \
    \       recurse(i - 1, j, path)\n            recurse(i + 1, j, path)\n       \
    \     recurse(i, j - 1, path)\n            recurse(i, j + 1, path)\n         \
    \   path.remove(path.length - 1)\n        }\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until n) {\n                recurse(i, j, path)\n   \
    \         }\n        }\n        return res.toList", "        // f[i][j][step]\
    \ = (result, index)\n        // result = min(result, f[i][j][step - 1].result\
    \ ++ List(grid[i][j]))\n        // index = if (f[i][j][step - 1].result ++ List(grid[i][j])\
    \ is lexicographically less than f[i][j][step - 1].result)\n        //       \
    \  then f[i][j][step - 1].index else i * grid.length + j\n        val f = Array.ofDim[(List[Long],\
    \ Int)](grid.length, grid.length, k.toInt + 1)\n        val size = grid.length\n\
    \        for (i <- 0 until size; j <- 0 until size) f(i)(j)(0) = (List(), -1)\n\
    \        for (step <- 1 to k.toInt) {\n            for (i <- 0 until size; j <-\
    \ 0 until size) {\n                val neis = ((i + 1, j), (i - 1, j), (i, j +\
    \ 1), (i, j - 1)).filter(x => x._1 >= 0 && x._1 < size && x._2 >= 0 && x._2 <\
    \ size)\n                f(i)(j)(step) = (List(), i * size + j)\n            \
    \    for ((x, y) <- neis) {\n                    val xy = (f(x)(y)(step - 1)._1\
    \ ++ List(grid(i)(j)), i * size + j)\n                    if (xy._1 < f(i)(j)(step)._1)\
    \ f(i)(j)(step) = xy\n                }\n            }\n        }\n        var\
    \ index = 0\n        for (i <- 0 until size; j <- 0 until size) {\n          \
    \  if (f(i)(j)(k.toInt)._2 > index) index = f(i)(j)(k.toInt)._2\n        }\n \
    \       f(index / size)(index % size)(k.toInt)._1", "        // Your code here\n\
    \        return null", '        null', "        // grid[i][j] is the value of\
    \ cell (i, j)\n        // the numbers in the grid is from 1 to N * N\n       \
    \ val n = grid.length\n        // for each cell (i, j), its neighbors are (i -\
    \ 1, j), (i + 1, j), (i, j - 1), (i, j + 1)\n        // we use bitmask to do DFS.\n\
    \        // each bitmask has n * n bits, and the ith bit is 1 if we have visited\
    \ the ith cell.\n        // the ith cell is (i / n, i % n)\n        // if we've\
    \ visited the cell (i, j), then the (i * n + j)th bit is 1.\n        // we use\
    \ a pair of ((start position bitmask, stop position bitmask), List[Long]) to represent\
    \ a path.\n        // this way, we don't need to care about the start position\
    \ and the stop position during the search.\n        // the first bitmask says\
    \ the start position, and the second bitmask says the stop position.\n       \
    \ val start = grid.flatten.zipWithIndex.map(x => (1l << x._2, x._1)).toList\n\
    \        // for each cell (i, j), the cell number is i * n + j.\n        val length\
    \ = k\n        // our answer will contain exactly length cells.\n        val ans\
    \ = new ListBuffer[Long]\n        // the path from start to end.\n        // we\
    \ will find the answer in ans\n        val init = (0l, 0l)\n        // this is\
    \ the initial state for DFS.\n        def dfs(cur : ((Long, Long), List[Long]))\
    \ : Unit = {\n            // if we've visited exactly length cells, then we're\
    \ done.\n            if (cur._2.length == length) {\n                ans ++= cur._2\n\
    \                return\n            }\n            val startMask = cur._1._1\n\
    \            val stopMask = cur._1._2\n            val path = cur._2\n       \
    \     // for each cell (i, j), the cell number is i * n + j.\n            val\
    \ index = n * n - 1 - path.length\n            // the next cell should be (i,\
    \ j), where", "        // K is number of steps to consider, so N-K+1 is number\
    \ of element in solution\n        val n = grid.length\n        // It is guaranteed\
    \ that answer is unique so we can just take the first solution\n        val dp\
    \ = Array.fill(n)(Array.fill(n)(Long.MaxValue))\n        for (i <- 0 until n)\
    \ for (j <- 0 until n) {\n            if (i > 0) {\n                if (grid(i)(j)\
    \ < grid(i - 1)(j)) dp(i)(j) = dp(i - 1)(j)\n                else dp(i)(j) = grid(i\
    \ - 1)(j)\n            }\n            if (j > 0) {\n                if (grid(i)(j)\
    \ < grid(i)(j - 1)) dp(i)(j) = dp(i)(j - 1)\n                else dp(i)(j) = grid(i)(j\
    \ - 1)\n            }\n        }\n        def update(x : Long, y : Long, v : Long)\
    \ : Unit = {\n            dp(x.toInt)(y.toInt) = v\n            for (dx <- -1\
    \ to 1) for (dy <- -1 to 1) {\n                if (dx == 0 && dy == 0) ()\n  \
    \              else {\n                    val newx = x + dx\n               \
    \     val newy = y + dy\n                    if (newx >= 0 && newx < n && newy\
    \ >= 0 && newy < n) {\n                        if (grid(newx.toInt)(newy.toInt)\
    \ < dp(x.toInt)(y.toInt)) dp(x.toInt)(y.toInt) = grid(newx.toInt)(newy.toInt)\n\
    \                    }\n                }\n            }\n        }\n        var\
    \ position = (0l, 0l)\n        var p = 0l\n        var res = List[Long]()\n  \
    \      while (p < k) {\n            res = res :+ grid(position._1.toInt)(position._2.toInt)\n\
    \            val gridValue = grid(position._1.toInt)(position._2.toInt)\n    \
    \        // Try going down\n            if (", "\t// the height and width of the\
    \ grid\n\tval h = grid.length\n\tval w = grid(0).length\n\t// the set of all possible\
    \ path, stored in a trie\n\tval pathSet = new Trie()\n\t// find the values of\
    \ all cells and store them in a list\n\tval cellList = new Array[Long](h * w)\n\
    \tvar ci = 0\n\tfor (i <- 0 until h) {\n\t    for (j <- 0 until w) {\n\t\tcellList(ci)\
    \ = grid(i)(j)\n\t\tci += 1\n\t    }\n\t}\n\t// sort the list, and save the index\
    \ of the cells\n\tval sortedCellList = cellList.toArray.sorted\n\tval cellIndex\
    \ = new Array[Int](h * w)\n\tfor (i <- 0 until h * w) {\n\t    val ind = cellList.indexOf(sortedCellList(i))\n\
    \t    cellIndex(ind) = i\n\t}\n\t// find the first cell and add it to the path\
    \ set\n\tvar firstCell = new Array[Int](2)\n\tfor (i <- 0 until h) {\n\t    for\
    \ (j <- 0 until w) {\n\t\tif (cellIndex(i * w + j) == 0) {\n\t\t    firstCell(0)\
    \ = i\n\t\t    firstCell(1) = j\n\t\t}\n\t    }\n\t}\n\tpathSet.add(List(sortedCellList(0)))\n\
    \t// find all possible paths and add them to the path set\n\tfor (i <- 1 until\
    \ k) {\n\t    val newPathSet = new Trie()\n\t    for (path <- pathSet.paths) {\n\
    \t\tval paths = expandPath(path, grid, cellIndex, h, w)\n\t\tfor (path <- paths)\
    \ {\n\t\t    newPathSet.add(path)\n\t\t}\n\t    }\n\t    pathSet.paths = newPathSet.paths\n\
    \t}\n\t// return the smallest path\n\tpathSet.paths.minBy(_.reverse.head)", '        null',
  "        var paths = ListBuffer[List[Long]]()\n        var queue = Queue[(Int, Int,\
    \ Int, Long)]()\n        val n = grid.length\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until n) {\n                queue.enqueue((i, j, 0, grid(i)(j)))\n\
    \            }\n        }\n        while (!queue.isEmpty) {\n            val v\
    \ = queue.dequeue\n            if (v._3 == k) {\n                paths += List(v._4)\n\
    \            } else {\n                if (v._1 != 0) queue.enqueue((v._1 - 1,\
    \ v._2, v._3 + 1, grid(v._1 - 1)(v._2)))\n                if (v._1 != n - 1) queue.enqueue((v._1\
    \ + 1, v._2, v._3 + 1, grid(v._1 + 1)(v._2)))\n                if (v._2 != 0)\
    \ queue.enqueue((v._1, v._2 - 1, v._3 + 1, grid(v._1)(v._2 - 1)))\n          \
    \      if (v._2 != n - 1) queue.enqueue((v._1, v._2 + 1, v._3 + 1, grid(v._1)(v._2\
    \ + 1)))\n            }\n        }\n        paths.sortWith(_.lexicographicallyLessThan(_)).head",
  "        var result = List[Long]()\n        // BEGIN_SOLUTION\n        val n = grid.length\n\
    \        val cur = (for (i <- 0 until n) yield for (j <- 0 until n) yield false).toArray\n\
    \        val min = (for (i <- 0 until n) yield for (j <- 0 until n) yield Long.MaxValue).toArray\n\
    \        def next(i : Int, j : Int) : List[(Int, Int)] = {\n            def withinBounds(i\
    \ : Int, j : Int) : Boolean = {\n                i >= 0 && i < n && j >= 0 &&\
    \ j < n\n            }\n            List((i - 1, j), (i + 1, j), (i, j - 1), (i,\
    \ j + 1)).filter(x => withinBounds(x._1, x._2))\n        }\n        def inBounds(pos\
    \ : (Int, Int)) : Boolean = {\n            val (i, j) = pos\n            i >=\
    \ 0 && i < n && j >= 0 && j < n\n        }\n        def compare(pos1 : (Int, Int),\
    \ pos2 : (Int, Int)) : Boolean = {\n            val (i1, j1) = pos1\n        \
    \    val (i2, j2) = pos2\n            grid(i1)(j1) < grid(i2)(j2)\n        }\n\
    \        def go(pos : (Int, Int), path : List[Long]) : Unit = {\n            if\
    \ (path.length == k) {\n                val (i, j) = pos\n                min(i)(j)\
    \ = min(i)(j) min path.reverse.tail.reverse.map(x => (grid(i)(j) - x) abs).sum\n\
    \            } else {\n                next(pos._1, pos._2).filter(inBounds).foreach(x\
    \ => go(x, grid(x._1)(x._2) :: path))\n            }\n        }\n        for (i\
    \ <- 0 until n; j <- 0 until n) {\n            go((i, j), List[Long]())\n    \
    \    }\n        var min0 = Long.MaxValue\n        var minPos = (0, 0)\n      \
    \  for (", "        val dp = Array.fill[Long](grid.size, grid.size)(0)\n     \
    \   val w = grid.size\n        for {\n            i <- 0 until w\n           \
    \ j <- 0 until w\n        } dp(i)(j) = grid(i)(j)\n        for {\n           \
    \ i <- 1 until w\n            j <- 1 until w\n        } dp(i)(j) = min(dp(i -\
    \ 1)(j), dp(i)(j - 1))\n        var i = 0\n        var j = 0\n        var res\
    \ = ListBuffer[Long]()\n        while (i < w && j < w && k > 0) {\n          \
    \  if (i == 0 && j == 0) {\n                res += dp(i)(j)\n                k\
    \ -= 1\n                i += 1\n            } else if (i == 0) {\n           \
    \     res += dp(i)(j)\n                j += 1\n                k -= 1\n      \
    \      } else if (j == 0) {\n                res += dp(i)(j)\n               \
    \ i += 1\n                k -= 1\n            } else {\n                if (dp(i\
    \ - 1)(j) <= dp(i)(j - 1)) {\n                    res += dp(i)(j)\n          \
    \          i += 1\n                    k -= 1\n                } else {\n    \
    \                res += dp(i)(j)\n                    j += 1\n               \
    \     k -= 1\n                }\n            }\n        }\n        if (k > 0)\
    \ {\n            if (i == w) {\n                for (j <- j until j + k.toInt)\
    \ res += dp(i - 1)(j)\n            } else {\n                for (i <- i until\
    \ i + k.toInt) res += dp(i)(j - 1)\n            }\n        }\n        res.toList"]
stop_tokens:
- "\n    }\n"
