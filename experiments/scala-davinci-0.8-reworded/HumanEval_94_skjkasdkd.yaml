name: HumanEval_94_skjkasdkd
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of integers.\n    // You need to find the largest prime\
  \ value and return the sum of its digits.\n    // Examples:\n    // >>> skjkasdkd((List[Long](0l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong,\
  \ 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong,\
  \ 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong)))\n    //\
  \ (10l)\n    // >>> skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong,\
  \ 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong,\
  \ 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)))\n\
  \    // (25l)\n    // >>> skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong,\
  \ 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong,\
  \ 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong)))\n\
  \    // (13l)\n    // >>> skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong,\
  \ 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong,\
  \ 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))\n    // (11l)\n    // >>> skjkasdkd((List[Long](0l.toLong,\
  \ 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong)))\n    // (3l)\n   \
  \ // >>> skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
  \ 7l.toLong)))\n    // (7l)\n    def skjkasdkd(lst : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(skjkasdkd((List[Long](0l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong,\
  \ 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong,\
  \ 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong))) == (10l));\n\
  \    assert(skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong,\
  \ 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong))) == (25l));\n\
  \    assert(skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong,\
  \ 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong,\
  \ 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong))) == (13l));\n    assert(skjkasdkd((List[Long](0l.toLong,\
  \ 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong,\
  \ 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong))) == (11l));\n\
  \    assert(skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong,\
  \ 1l.toLong, 21l.toLong))) == (3l));\n    assert(skjkasdkd((List[Long](0l.toLong,\
  \ 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong))) == (7l));\n    assert(skjkasdkd((List[Long](8191l.toLong)))\
  \ == (19l));\n    assert(skjkasdkd((List[Long](8191l.toLong, 123456l.toLong, 127l.toLong,\
  \ 7l.toLong))) == (19l));\n    assert(skjkasdkd((List[Long](127l.toLong, 97l.toLong,\
  \ 8192l.toLong))) == (10l));\n    }\n\n}\n"
completions: ["        var lst2 = lst.toSet\n        var lst3 = lst2.toList\n    \
    \    lst3 = lst3.filter(x => x > 1)\n        var lst4 = lst3.map(x => if (isPrime(x))\
    \ x else 1)\n        lst4 = lst4.filter(x => x > 1)\n        var lst5 = lst4.map(x\
    \ => x.toString.toList)\n        var lst6 = lst5.map(x => x.map(y => y.toString.toInt))\n\
    \        var lst7 = lst6.map(x => x.sum)\n        var max = lst7.max\n       \
    \ max", "        // Your code here\n        val p = new Primes(lst.max)\n    \
    \    val primes = p.getPrimes()\n        val subset = lst.filter(x => primes.contains(x))\n\
    \        if (subset.isEmpty) 0\n        else {\n            val max = subset.max\n\
    \            var sum = 0l\n            var num = max\n            while (num >\
    \ 0) {\n                sum += num % 10\n                num /= 10\n         \
    \   }\n            sum\n        }", "        var s : Long = 0l.toLong\n      \
    \  for (i <- lst) {\n            s += i\n        }\n        return s", "     \
    \   var lstt = lst\n        // <<< Don't change the function signature for this\
    \ example!!\n        // Your solution to Problem 1 within this function body.\n\
    \        // You can add functions, but don't change function names\n        //\
    \ or delete the given example.\n        var y = 1l\n        var s = 0l\n     \
    \   var p = 0l\n        var k = 0l\n        var h = 0l\n        var g = 0l\n \
    \       var q = 0l\n        while (y > 0l) {\n            p = lstt.indexOf(y)\n\
    \            if (p != -1l) {\n                k = lstt(p)\n                h =\
    \ k\n                while (k > 0l) {\n                    g = k % 10l\n     \
    \               q = q + g\n                    k = k / 10l\n                }\n\
    \                if (h > s) {\n                    s = h\n                }\n\
    \            }\n            y = y + 1l\n        }\n        return q", "      \
    \  def loop(lst : List[Long], primes : List[Long]) : Long = {\n            if\
    \ (lst.isEmpty) {\n                if (primes.isEmpty) 0l\n                else\
    \ primes.max\n            } else {\n                if (lst.head.isPrime) loop(lst.tail,\
    \ lst.head :: primes)\n                else loop(lst.tail, primes)\n         \
    \   }\n        }\n        var l = loop(lst, List[Long]())\n        if (l == 0l)\
    \ 0l\n        else l.toString.map(_.asDigit).sum", "        var maxPrime = lst.max\n\
    \        var sum = 0\n        while (maxPrime != 0) {\n            sum += maxPrime\
    \ % 10\n            maxPrime /= 10\n        }\n        return sum", "        def\
    \ helper(lst : List[Long], acc : Long) : Long = {\n            val primes = Array(2l,\
    \ 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l,\
    \ 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l,\
    \ 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l, 193l,\
    \ 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l, 269l,\
    \ 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l, 349l,\
    \ 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l, 431l,\
    \ 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l, 503l,\
    \ 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 593l, 599l,\
    \ 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l, 673l,\
    \ 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l, 761l,\
    \ 769l, 773l, 787l, 797l, 809l, 811l, 821l, 823l,", "        if (lst.isEmpty)\
    \ 0l\n        else {\n            var m = Long.MinValue\n            for (i <-\
    \ lst) if (BigInt(i).isProbablePrime(10000)) m = max(m, i)\n            if (m\
    \ == Long.MinValue) 0l\n            else {\n                var s = 0l\n     \
    \           var n = m\n                while (n > 0) {\n                    s\
    \ += n % 10\n                    n /= 10\n                }\n                s\n\
    \            }\n        }", '        lst.filter(x => isPrime(x)).max.toString.map(x
    => x.asDigit).sum', '        lst.map(i => i.toString.map(c => c.asDigit).sum).max',
  "        var prime = 0l\n        var sum = 0l\n        for (n <- lst) {\n      \
    \      val isPrime = (2 to sqrt(n).toInt).forall(x => n % x != 0)\n          \
    \  if (isPrime && n > prime) {\n                prime = n\n            }\n   \
    \     }\n        var a = prime\n        while (a > 0) {\n            sum += a\
    \ % 10\n            a /= 10\n        }\n        return sum", "        println(lst.max)\n\
    \        lst.max.toString.toList.map(_.asDigit).sum", "        val n = lst.reduce(max(_,\
    \ _))\n        def isPrime(x : Long) : Boolean = (2l to floor(sqrt(x)).toLong).forall(x\
    \ % _ != 0)\n        val primes = lst.filter(isPrime(_))\n        val sorted =\
    \ primes.sorted\n        if (sorted.isEmpty) 0 else sorted.last", "        val\
    \ arr = lst.toArray\n        var primes = List[Long]()\n        for (j <- arr)\
    \ {\n            if (isPrime(j)) primes :+= j\n        }\n        var max = primes.max\n\
    \        var digits = max.toString.toCharArray.map(x => x.toString.toLong)\n \
    \       digits.sum", '        lst.filter(i => isPrime(i)).reduceLeft(max).toString.map(i
    => i.asDigit).reduceLeft(_ + _)', "        var mutableList = lst.toBuffer\n  \
    \      mutableList.remove(0)\n        val primes = mutableList.filter(x => isPrime(x)).sorted\n\
    \        val prime = primes.last\n        var sum = 0l\n        while (prime >\
    \ 0) {\n            sum += prime % 10\n            prime /= 10\n        }\n  \
    \      sum", "        val num = lst.filter(primes.contains(_)).sorted.last\n \
    \       sumDigits(num)", "        lst.map(x => x.toString).filter(x => x.forall(y\
    \ => !(y == '0'))).map(x => x.toLong).filter(x => (1 to x).toList.filter(y =>\
    \ x % y == 0).size == 2).max.toString.toList.map(x => x.toString.toLong).sum",
  "        val primes = lst.filter(x => x.isPrime)\n        val primesSorted = primes.sortWith(_\
    \ > _)\n        val largestPrime = primesSorted.head\n        return largestPrime.digits.sum",
  "        def nextprime(num : Long) : Long = {\n            var isprime = false\n\
    \            var curr = num + 1\n            while (!isprime) {\n            \
    \    isprime = true\n                for (j <- 2l.toLong to sqrt(curr).toLong)\
    \ {\n                    if (curr % j == 0) {\n                        isprime\
    \ = false\n                        curr += 1\n                    }\n        \
    \        }\n            }\n            curr\n        }\n        def sumdigits(num\
    \ : Long) : Long = {\n            var sum = 0l.toLong\n            var curr =\
    \ num\n            while (curr > 0) {\n                sum += curr % 10\n    \
    \            curr /= 10\n            }\n            sum\n        }\n        def\
    \ sumlargest(lst : List[Long], p : Long) : Long = {\n            var lgprime =\
    \ p\n            for (i <- lst) {\n                if (i > lgprime) {\n      \
    \              lgprime = nextprime(i)\n                }\n            }\n    \
    \        sumdigits(lgprime)\n        }\n        sumlargest(lst, 0l.toLong)", " \
    \       if (lst.length == 0) 0l.toLong\n        else {\n            val ll = lst.toArray.sortWith(_\
    \ > _)\n            var c = 0\n            for (i <- lst) {\n                if\
    \ (isPrime(i)) {\n                    c = i\n                    break\n     \
    \           }\n            }\n            if (c == 0) 0l.toLong\n            else\
    \ {\n                var s = 0\n                var i = c\n                while\
    \ (i > 0) {\n                    s += i % 10\n                    i /= 10\n  \
    \              }\n                s\n            }\n        }", "        lst.foldLeft(0l.toLong)((x,\
    \ y) => if (isPrime(y)) {\n            val factor = factors(y)\n            val\
    \ prime = factor.foldLeft(0l.toLong)((a, b) => if (b > x && isPrime(b)) b else\
    \ a)\n            if (prime > x) prime else x\n        } else {\n            x\n\
    \        })", "        lst.filter((i) => {\n            !lst.filter((j) => {\n\
    \                i != j && i % j == 0l\n            }).isEmpty\n        }).max",
  "        if (lst.length <= 0) 0\n        else {\n            val primes = sieve(lst.max.toInt)\n\
    \            primes.max.toString.toList.map(_.asDigit).sum\n        }", "    \
    \    // \u0412\u0441\u0435 \u043F\u0440\u043E\u0441\u0442\u044B\u0435 \u0447\u0438\
    \u0441\u043B\u0430 \u0438\u0437 \u043D\u0430\u0448\u0435\u0433\u043E \u0441\u043F\
    \u0438\u0441\u043A\u0430\n        val primes = lst.filter(x => Prime.isPrime(x))\n\
    \        // \u0421\u0430\u043C\u043E\u0435 \u0431\u043E\u043B\u044C\u0448\u043E\
    \u0435 \u043F\u0440\u043E\u0441\u0442\u043E\u0435 \u0447\u0438\u0441\u043B\u043E\
    \n        val largest = primes.max\n        // \u0421\u0443\u043C\u043C\u0430\
    \ \u0446\u0438\u0444\u0440 \u0441\u0430\u043C\u043E\u0433\u043E \u0431\u043E\u043B\
    \u044C\u0448\u043E\u0433\u043E \u043F\u0440\u043E\u0441\u0442\u043E\u0433\u043E\
    \ \u0447\u0438\u0441\u043B\u0430\n        val sum = largest.toString.map(_.asDigit).sum\n\
    \        sum", "        // You need to find the largest prime value and return\
    \ the sum of its digits.\n        def sieveOfEratosthenes(n : Int) : List[Int]\
    \ = {\n            val primes = new ArrayBuffer[Int]();\n            val A = new\
    \ Array[Boolean](n);\n            for (i <- 2 until n) {\n                A(i)\
    \ = true;\n            }\n            for (i <- 2 until sqrt(n).toInt) {\n   \
    \             if (A(i)) {\n                    var j = i * i;\n              \
    \      while (j < n) {\n                        A(j) = false;\n              \
    \          j += i;\n                    }\n                }\n            }\n\
    \            for (i <- 2 until n) {\n                if (A(i)) {\n           \
    \         primes += i;\n                }\n            }\n            primes.toList;\n\
    \        }\n        def isPrime(n : Int) : Boolean = {\n            if (n < 2)\
    \ {\n                return false;\n            }\n            if (n == 2) {\n\
    \                return true;\n            }\n            if (n % 2 == 0) {\n\
    \                return false;\n            }\n            for (i <- 3 to sqrt(n).toInt\
    \ by 2) {\n                if (n % i == 0) {\n                    return false;\n\
    \                }\n            }\n            return true;\n        }\n     \
    \   def isPrimeLong(n : Long) : Boolean = {\n            if (n < 2) {\n      \
    \          return false;\n            }\n            if (n == 2) {\n         \
    \       return true;\n            }\n            if (n % 2 == 0) {\n         \
    \       return false;\n            }\n            for (i <- 3l to sqrt(n).toLong\
    \ by 2) {\n                if (n % i == 0) {\n                    return false;\n\
    \                }\n            }\n            return true;\n        }\n     \
    \   def getDigits(n : Long) : List[Long] = {\n            var digits = List[Long]();\n\
    \            while (n > 0) {\n                digits = (n % 10) :: digits;\n \
    \               n /= 10;\n            }\n            digits;\n        }\n    \
    \    var primes = sieveOf", "        val primes = lst.filter(i => (i > 1) && !(List.range(2,\
    \ (i - 1)) exists (i % _ == 0)))\n        val largest = primes.max\n        return\
    \ largest.toString.toCharArray.map(_.asDigit).sum", "        def isPrime(number\
    \ : Long) : Boolean = {\n            if (number < 2) return false\n          \
    \  for (i <- 2l to (floor(sqrt(number))).toLong) {\n                if (number\
    \ % i == 0) return false\n            }\n            return true\n        }\n\
    \        var max = 0l\n        for (i <- lst) {\n            if (isPrime(i) &&\
    \ i > max) max = i\n        }\n        var sum = 0l\n        while (max > 0) {\n\
    \            sum += max % 10\n            max /= 10\n        }\n        return\
    \ sum", "        def isPrime(n : Long) : Boolean = {\n            if (n < 2) return\
    \ false\n            for (i <- 2 to sqrt(n).toInt) if (n % i == 0) return false\n\
    \            return true\n        }\n        var max = 0L\n        for (i <- lst\
    \ if (isPrime(i))) if (i > max) max = i\n        return (if (max != 0) max.toString.toList.map(x\
    \ => x.toString.toLong).sum else 0)", "        // Write your code here\n     \
    \   val primes = lst.filter(isPrime(_))\n        val d = primes.map(_.toString.map(_.asDigit).sum).max\n\
    \        d", "        var a = lst.sortWith((a, b) => a > b).filter((x) => this.ehprimo(x));\n\
    \        var s = a(0).toString();\n        var b = s.split(\"\").map((x) => x.toLong);\n\
    \        return b.reduce((x, y) => x + y);", "      val sieve = Array.fill(lst.max.toInt)(true)\n\
    \      sieve(0) = false\n      sieve(1) = false\n      for (i <- 2 to sqrt(lst.max).toInt)\
    \ {\n        if (sieve(i)) {\n          var j = i * i\n          while (j < lst.max)\
    \ {\n            sieve(j) = false\n            j += i\n          }\n        }\n\
    \      }\n      val primes = new ArrayBuffer[Int]\n      for (i <- 0 to lst.max.toInt)\
    \ {\n        if (sieve(i)) primes += i\n      }\n      val lsp = primes.max\n\
    \      var sum = 0\n      for (i <- 0 to lsp.toString.length - 1) {\n        sum\
    \ += lsp.toString.charAt(i).asDigit\n      }\n      sum", "        def s(lst :\
    \ List[Long]) : Long = {\n            lst match {\n                case Nil =>\
    \ 0l\n                case x :: Nil => x\n                case x :: xs => x +\
    \ s(xs)\n            }\n        }\n        def g(lst : List[Long]) : Long = {\n\
    \            lst match {\n                case Nil => 1l\n                case\
    \ x :: Nil => x\n                case x :: xs => x * g(xs)\n            }\n  \
    \      }\n        def p(n : Long) : Boolean = {\n            val m = sqrt(n.toDouble).toLong\n\
    \            var f = 2l\n            while (f <= m) {\n                if (n %\
    \ f == 0) return false\n                f += 1\n            }\n            true\n\
    \        }\n        def d(n : Long) : List[Long] = {\n            var l = List[Long]()\n\
    \            var m = n\n            while (m > 0) {\n                l = (m %\
    \ 10) :: l\n                m /= 10\n            }\n            l\n        }\n\
    \        val primes = lst.filter(p(_))\n        val biggestPrime = primes.reduceLeft((a,\
    \ b) => max(a, b))\n        val digits = d(biggestPrime)\n        s(digits)",
  "        def powMod(a : Long, b : Long, mod : Long) : Long = {\n            var\
    \ sum = 1l.toLong\n            var currPow = a\n            var currB = b\n  \
    \          while (currB > 0) {\n                if (currB % 2 == 1) {\n      \
    \              sum = (sum * currPow) % mod\n                    currB -= 1\n \
    \               }\n                currPow = (currPow * currPow) % mod\n     \
    \           currB /= 2\n            }\n            sum\n        }\n        def\
    \ isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n    \
    \        var p = powMod(2, n - 1, n)\n            return p == 1\n        }\n \
    \       def largestPrime(n : Long) : Long = {\n            if (n <= 1) return\
    \ -1\n            var currPrime = n\n            while (!isPrime(currPrime)) currPrime\
    \ -= 1\n            currPrime\n        }\n        def sumDigits(n : Long) : Long\
    \ = {\n            var sum = 0l.toLong\n            var currN = n\n          \
    \  while (currN > 0) {\n                sum += currN % 10\n                currN\
    \ /= 10\n            }\n            sum\n        }\n        var largestPrime =\
    \ 0l.toLong\n        for (i <- lst) {\n            var currPrime = largestPrime(i)\n\
    \            if (currPrime > largestPrime) largestPrime = currPrime\n        }\n\
    \        sumDigits(largestPrime)", "        def skjkasdkd(lst : List[Long], res\
    \ : Long) : Long = {\n            if (lst.length == 0) return res\n          \
    \  var sres = res\n            if (lst.last > sres) {\n                var value\
    \ = lst.last\n                var prime = true\n                for (i <- 2l to\
    \ sqrt(value.toDouble).toLong) {\n                    if (value % i == 0) {\n\
    \                        prime = false\n                        break\n      \
    \              }\n                }\n                if (prime) {\n          \
    \          var sum = 0l\n                    while (value > 0) {\n           \
    \             sum += value % 10\n                        value /= 10\n       \
    \             }\n                    if (sum > sres) sres = sum\n            \
    \    }\n            }\n            skjkasdkd(lst.dropRight(1), sres)\n       \
    \ }\n        return skjkasdkd(lst, 0)", "        var mx = 0L\n        for (x <-\
    \ lst) {\n            val prime = isPrime(x)\n            if (prime) {\n     \
    \           mx = max(mx, x)\n            }\n        }\n        var sum = 0L\n\
    \        var temp = mx\n        while (temp > 0) {\n            sum += temp %\
    \ 10\n            temp /= 10\n        }\n        return sum", "        val mp\
    \ = Map[Long, Long]()\n        var mx = 0\n        for (value <- lst) {\n    \
    \        var valu = value\n            while (valu % 2 == 0) {\n             \
    \   valu /= 2\n            }\n            var flag = true\n            while (valu\
    \ > 1 && flag) {\n                flag = false\n                for (i <- 3 to\
    \ sqrt(valu).toInt by 2) {\n                    if (valu % i == 0) {\n       \
    \                 flag = true\n                        valu /= i\n           \
    \         }\n                }\n            }\n            if (valu != 1) {\n\
    \                if (mp.contains(valu)) {\n                    mp(valu) += 1\n\
    \                } else {\n                    mp(valu) = 1\n                }\n\
    \                mx = max(mx, mp(valu).toInt).toInt\n            }\n        }\n\
    \        var res = 0\n        for ((value, times) <- mp) {\n            if (times\
    \ == mx) {\n                var valu = value\n                while (valu > 0)\
    \ {\n                    res += valu % 10\n                    valu /= 10\n  \
    \              }\n            }\n        }\n        res", "        val sieve =\
    \ Array.fill(10000000)(true)\n        for (i <- 2 to sieve.length - 1) {\n   \
    \         if (sieve(i)) {\n                for (j <- i + i to sieve.length - 1\
    \ by i) {\n                    sieve(j) = false\n                }\n         \
    \   }\n        }\n        val lst2 = lst.filter(sieve(_))\n        var num = 0l\n\
    \        var x = 0l\n        for (i <- lst2) {\n            if (i > num) {\n \
    \               num = i\n                x = i\n            }\n        }\n   \
    \     var sum = 0l\n        while (x > 0) {\n            sum += x % 10\n     \
    \       x /= 10\n        }\n        sum", "        // lst.map(n => if (n % 2 ==\
    \ 0) n / 2 else n).filter(n => n > 1).last\n        lst.filter(n => n > 1).map(n\
    \ => if (n % 2 == 0) n / 2 else n).last", '        lst.max', "        // val lst\
    \ = List(0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong,\
    \ 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong,\
    \ 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong,\
    \ 3l.toLong)\n        // val lst = List(1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong,\
    \ 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)\n\
    \        // val lst = List(1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong,\
    \ 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong,\
    \ 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong)\n        // val lst\
    \ = List(0l.toLong, 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong,\
    \ 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong,\
    \ 6l.toLong)\n        // val lst = List(0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong,\
    \ 1l.toLong, 21l.toLong)\n        // val lst", "        if (lst.length == 0) return\
    \ 0l\n        val primes = lst.filter(x => isPrime(x));\n        val largestPrime\
    \ = primes.max\n        val sum = largestPrime.toString.map(_.asDigit).sum\n \
    \       return sum", "        // get primes\n        val primes = ListBuffer[Long]()\n\
    \        var isPrime = true\n        for (n <- lst) {\n            for (d <- 2\
    \ to sqrt(n).toInt) {\n                if (n % d == 0) {\n                   \
    \ isPrime = false\n                    break\n                }\n            }\n\
    \            if (isPrime) primes += n\n            isPrime = true\n        }\n\
    \        // get max prime\n        val maxPrime = primes.max\n        // sum digits\n\
    \        var sum = 0l\n        var n = maxPrime\n        while (n > 0) {\n   \
    \         sum += n % 10\n            n /= 10\n        }\n        sum", "     \
    \   // >>> skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong, 5l.toLong, 2l.toLong,\
    \ 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong, 2l.toLong, 32l.toLong,\
    \ 324l.toLong, 4l.toLong, 3l.toLong)))\n        // 10\n        // >>> skjkasdkd((List[Long](1l.toLong,\
    \ 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong,\
    \ 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong,\
    \ 2l.toLong, 5l.toLong, 1l.toLong)))\n        // 25\n        // >>> skjkasdkd((List[Long](1l.toLong,\
    \ 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong,\
    \ 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong,\
    \ 3l.toLong)))\n        // 13\n        // >>> skjkasdkd((List[Long](0l.toLong,\
    \ 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong,\
    \ 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))\n    \
    \    // 11\n        // >>> skjkasdkd((List[Long](0", "        def isPrime(n :\
    \ Long) : Boolean = {\n            if (n < 2) return false\n            if (n\
    \ == 2 || n == 3) return true\n            if (n % 2 == 0 || n % 3 == 0) return\
    \ false\n            var i = 5l\n            var w = 2l\n            while (i\
    \ * i <= n) {\n                if (n % i == 0) return false\n                i\
    \ += w\n                w = 6 - w\n            }\n            return true\n  \
    \      }\n        def sumOfDigits(n : Long) : Long = {\n            if (n == 0)\
    \ return 0\n            return n % 10 + sumOfDigits(n / 10)\n        }\n     \
    \   var currentMax = 0l\n        for (i <- lst) {\n            if (isPrime(i)\
    \ && i > currentMax) currentMax = i\n        }\n        return sumOfDigits(currentMax)",
  "        var max = 0l\n        for (a <- lst) {\n            if (isPrime(a)) {\n\
    \                if (a > max) max = a\n            }\n        }\n        var ret\
    \ = 0l\n        var temp = max\n        while (temp > 0) {\n            ret +=\
    \ temp % 10\n            temp /= 10\n        }\n        return ret", "       \
    \ var b:Long = 0l\n        var a:Long = 0l\n        var z:Long = 0l\n        for\
    \ (i <- lst) {\n            if (isPrime(i)) {\n                b = i\n       \
    \         if (b > a) {\n                    a = b\n                }\n       \
    \     }\n        }\n        a.toString.map(_.asDigit).sum", "        var max:Long\
    \ = 0l\n        for (i <- lst) {\n            if (isPrime(i)) max = max.max(i)\n\
    \        }\n        var sum:Long = 0l\n        for (i <- max.toString.toList)\
    \ {\n            sum += (i - '0').toLong\n        }\n        return sum", "  \
    \      def isPrime(n : Long) : Boolean = if (n < 2) false else if (n == 2) true\
    \ else !(2l.to(sqrt(n).toLong).exists(n % _ == 0))\n        def digitSum(n : Long)\
    \ : Long = if (n < 10) n else (n % 10) + digitSum(n / 10)\n        lst.filter(isPrime(_)).max.toLong",
  "        def isPrime(n : Long) : Boolean = {\n            if (n < 2) false\n   \
    \         else if (n == 2) true\n            else !(2 to sqrt(n).toInt).exists(x\
    \ => n % x == 0)\n        }\n        def isSumOfDigitsPrime(n : Long) : Boolean\
    \ = {\n            val primes = (2 to 9).toList.filter(x => isPrime(x))\n    \
    \        val sumOfDigits = n.toString.map(x => x.asDigit).sum\n            primes.contains(sumOfDigits)\n\
    \        }\n        val largestPrime = lst.filter(x => isPrime(x)).max\n     \
    \   val sumOfDigitsOfLargestPrime = largestPrime.toString.map(x => x.asDigit).sum\n\
    \        sumOfDigitsOfLargestPrime", "        val sieve = new Sieve(lst.max.toInt)\n\
    \        val primes = (1 to lst.max.toInt).map(sieve.isPrime(_)).zipWithIndex.filter(_._1).map(_._2).toList\n\
    \        lst.map(primes.count(_ > _)).max", "\t\tdef helper(lst : List[Long],\
    \ current : Long, greatest : Long) : Long = {\n\t\t\tval sorted = lst.sortWith(_\
    \ > _)\n\t\t\tval taken = sorted.takeWhile(_ <= current)\n\t\t\tif (taken.isEmpty)\
    \ greatest\n\t\t\telse {\n\t\t\t\tif (isPrime(taken.head)) {\n\t\t\t\t\tval newGreatest\
    \ = taken.head\n\t\t\t\t\thelper(sorted.dropWhile(_ <= current), current, newGreatest)\n\
    \t\t\t\t}\n\t\t\t\telse helper(sorted.dropWhile(_ <= current), current, greatest)\n\
    \t\t\t}\n\t\t}\n\t\tval s = helper(lst, (lst.max + 1), 0)\n\t\tdef sum(n : Long)\
    \ : Long = {\n\t\t\tif (n == 0) 0\n\t\t\telse (n % 10l) + sum(n / 10l)\n\t\t}\n\
    \t\tsum(s)", "        def skjkasdkd0(primes : Long) : Long = {\n            if\
    \ (lst.contains(primes)) primes\n            else skjkasdkd0(primes + 1)\n   \
    \     }\n        val max = lst.max\n        val primes = skjkasdkd0(1)\n     \
    \   primes.toString.map(x => x.asDigit).sum", "        lst.map(p => {\n      \
    \      var prev = p\n            var next = 0l\n            while (prev > 0) {\n\
    \                next += prev % 10\n                prev /= 10\n            }\n\
    \            next\n        }).max", "        val maxPrime : Long = lst.map(BigInt(_)).filter(BigInt(_).isProbablePrime(1000)).max.toLong\n\
    \        maxPrime.toString.toList.map(_.asDigit).sum", '        (0l)', "     \
    \   var sum = 0l\n        for (n <- lst) {\n            if (n > 0 && isPrime(n))\
    \ {\n                sum += n.toString.map(x => x.asDigit).sum\n            }\n\
    \        }\n        return sum", "        // \u663E\u7136, \u6240\u6709\u6570\u5728\
    [0,65536]\u8303\u56F4\u5185.\n        val m = lst.foldLeft(0l)((x, y) => x + y)\n\
    \        var t = 0l\n        var p = 0l\n        while (m > 0) {\n           \
    \ t = m % 10\n            m /= 10\n            if (t > p) p = t\n        }\n \
    \       p", "        // For example, 2 and 3 are both prime numbers.\n       \
    \ def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n\
    \            if (n <= 3) return true\n            if (n % 2 == 0 || n % 3 == 0)\
    \ return false\n            var i = 5\n            while (i * i <= n) {\n    \
    \            if (n % i == 0 || n % (i + 2) == 0) return false\n              \
    \  i += 6\n            }\n            return true\n        }\n        def digits(n\
    \ : Long) : List[Long] = {\n            var result = List[Long]()\n          \
    \  var k = n\n            while (k > 0) {\n                result = (k % 10) ::\
    \ result\n                k /= 10\n            }\n            return result\n\
    \        }\n        var largestPrime = -1l\n        for (i <- lst) {\n       \
    \     if (isPrime(i)) {\n                if (i > largestPrime) largestPrime =\
    \ i\n            }\n        }\n        var sum = 0l\n        digits(largestPrime).foreach(sum\
    \ += _)\n        return sum", "        var max : Long = 0\n        for (e <- lst)\
    \ {\n            if (e > max && e.isPrime) max = e\n        }\n        if (max\
    \ == 0) return max\n        val digits = max.toString.map(_.asDigit).sum\n   \
    \     digits", "        // Your code goes here\n        var klsdjasd = Long.MinValue\n\
    \        for (i <- lst) {\n            if (i > klsdjasd && i.isProbablePrime(100))\
    \ klsdjasd = i\n        }\n        var alkdjakldjlkadjlasdjk = 0l\n        for\
    \ (i <- klsdjasd.toString) {\n            alkdjakldjlkadjlasdjk += i.asDigit\n\
    \        }\n        return alkdjakldjlkadjlasdjk", "        def checkPrime(x :\
    \ Long) : Boolean = {\n            def loop(i : Long) : Boolean = {\n        \
    \        if (i > sqrt(x)) true\n                else if (x % i == 0) false\n \
    \               else loop(i + 1)\n            }\n            if (x == 0 || x ==\
    \ 1) false\n            else loop(2)\n        }\n        def getSumOfDigits(x\
    \ : Long) : Long = {\n            def loop(x : Long, acc : Long) : Long = {\n\
    \                if (x == 0) acc\n                else loop(x / 10, acc + x %\
    \ 10)\n            }\n            loop(x, 0)\n        }\n        def loop(lst\
    \ : List[Long], largestPrime : Long) : Long = {\n            if (lst.isEmpty)\
    \ getSumOfDigits(largestPrime)\n            else {\n                val prime\
    \ = lst.head\n                if (checkPrime(prime) && prime > largestPrime) loop(lst.tail,\
    \ prime)\n                else loop(lst.tail, largestPrime)\n            }\n \
    \       }\n        loop(lst, 0)", "        var ms : Map[Long, Long] = Map.empty\n\
    \        var m : Long = 1\n        for (i <- lst) {\n            var t = i\n \
    \           var p : Long = 0\n            while (t > 1) {\n                p =\
    \ 0\n                for (j <- (1l to i)) {\n                    if (t % j ==\
    \ 0) {\n                        p = j\n                        t /= j\n      \
    \                  ms(p) = 1\n                        break\n                \
    \    }\n                }\n            }\n        }\n        ms.keySet.toList.filter(_\
    \ > 1).sortWith(_ > _).headOption match {\n            case Some(j) => for (i\
    \ <- j.toString) yield (i.asDigit.toLong) sum\n            case None => 0\n  \
    \      }", "        // edge cases\n        if (lst.length == 0) return 0l\n  \
    \      if (lst.length == 1) return lst(0)\n        // get all primes under the\
    \ ceiling\n        val ceil = lst.max\n        var allPrimes = new ListBuffer[Long]()\n\
    \        allPrimes += 2l\n        allPrimes += 3l\n        var cur = 5l\n    \
    \    while (cur <= ceil) {\n            var isPrime = true\n            for (i\
    \ <- 0 until allPrimes.length) {\n                if (cur % allPrimes(i) == 0)\
    \ {\n                    isPrime = false\n                    break\n        \
    \        }\n            }\n            if (isPrime) allPrimes += cur\n       \
    \     cur += 2\n        }\n        // get all prime numbers from lst\n       \
    \ var primeNumbers = new ListBuffer[Long]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until allPrimes.length) {\n                if (lst(i)\
    \ == allPrimes(j)) {\n                    primeNumbers += lst(i)\n           \
    \         break\n                }\n            }\n        }\n        if (primeNumbers.length\
    \ == 0) return 0l\n        // find the max prime number\n        var max = primeNumbers(0)\n\
    \        for (i <- 1 until primeNumbers.length) {\n            if (primeNumbers(i)\
    \ > max) max = primeNumbers(i)\n        }\n        // get the sum of the digits\
    \ of max\n        var sum = 0l\n        while (max > 0) {\n            sum +=\
    \ max % 10\n            max /= 10\n        }\n        sum", '        val pmap
    = List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l,
    53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l,
    127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l,
    193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l,
    269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l,
    349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l,
    431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l,
    503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 593l,
    599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l,
    673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l,
    761l, 769l, 773l, 787l, 797l, 809l, 811l, 821l, 823l, 827l, 829l, 839l, 853l,
    857l,', "        def skjkasdkd0(lst : List[Long], sum : Long) : Long = {\n   \
    \         lst match {\n                case Nil => sum\n                case _\
    \ => {\n                    val (a, b) = lst.span(x => x != 2l && x != 3l && x\
    \ != 5l && x != 7l)\n                    val (a1, b1) = a.span(x => x < 2l)\n\
    \                    if (b.isEmpty)\n                        sum\n           \
    \         else {\n                        val nlst = b.map(x => {\n          \
    \                  if (x % 2l == 0l)\n                                x / 2l\n\
    \                            else if (x % 3l == 0l)\n                        \
    \        x / 3l\n                            else if (x % 5l == 0l)\n        \
    \                        x / 5l\n                            else if (x % 7l ==\
    \ 0l)\n                                x / 7l\n                            else\n\
    \                                x\n                        })\n             \
    \           val (nlst1, nlst2) = nlst.partition(x => x >= 2l)\n              \
    \          skjkasdkd0(nlst1 ::: b1, sum + nlst2.map(x => x.toString.map(y => y.asDigit).sum).max)\n\
    \                    }\n                }\n            }\n        }\n        skjkasdkd0(lst,\
    \ 0l)", "        // >>> skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong,\
    \ 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong)))\n        // (10l)\n\
    \        // >>> skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong,\
    \ 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)))\n\
    \        // (25l)\n        // >>> skjkasdkd((List[Long](1l.toLong, 3l.toLong,\
    \ 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong,\
    \ 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong,\
    \ 3l.toLong)))\n        // (13l)\n        // >>> skjkasdkd((List[Long](0l.toLong,\
    \ 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong,\
    \ 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))\n    \
    \    // (11l)\n        //", '        lst.map(x => if (x.isPrime) x else 0).filter(x
    => x != 0).max.toString.map(x => x.asDigit).sum', '        lst.filter(x => isPrime(x)).max.toString.toCharArray.map(x
    => x.toString.toLong).sum', "        var s = HashSet[Long]()\n        var m =\
    \ lst.sorted.distinct.filter(v => !s.contains(v)).reverse.map(v => if(v == 0)\
    \ v else if(v == 1) v else if(v == 2) v else if(v == 3) v else if(v == 5) v else\
    \ if(v == 7) v else if(v % 2 == 0) s.add(2); v / 2 else if(v % 3 == 0) s.add(3);\
    \ v / 3 else if(v % 5 == 0) s.add(5); v / 5 else if(v % 7 == 0) s.add(7); v /\
    \ 7 else {\n            var n = ceil(sqrt(v)).toLong\n            while(n > 2)\
    \ {\n                if(v % n == 0) {\n                    s.add(n)\n        \
    \            v /= n\n                }\n                n -= 1\n            }\n\
    \            v\n        }).filter(v => v > 1)\n        var max = m.max\n     \
    \   var sum = 0l\n        while(max > 0) {\n            sum += max % 10\n    \
    \        max /= 10\n        }\n        sum", "        var primes = ArrayBuffer[Long]()\n\
    \        var maxPrime = 0l\n        for (number <- lst) {\n            if (number\
    \ > 1) {\n                val isPrime = (2 to number.toInt).forall(number % _\
    \ != 0)\n                if (isPrime) {\n                    primes += number\n\
    \                    if (number > maxPrime) maxPrime = number\n              \
    \  }\n            }\n        }\n        // println(primes.toList)\n        //\
    \ println(maxPrime)\n        var sum = 0l\n        while (maxPrime > 0) {\n  \
    \          sum += maxPrime % 10\n            maxPrime /= 10\n        }\n     \
    \   return sum", '        // val primes = List(2l, 3l, 5l, 7l, 11l, 13l, 17l,
    19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l,
    89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l,
    163l, 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l,
    233l, 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l,
    311l, 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l,
    389l, 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l,
    463l, 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l,
    563l, 569l, 571l, 577l, 587l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l,
    641l, 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l,
    727l, 733l, 739l, 743l, 751l, 757l, 761l, 769l, 773l, 787l, 797l, 809l, 811l,
    821l, 823l, 827l, 829l, 839l, 853l, 857l', "        var myhash = new HashMap[Long,\
    \ Boolean]\n        var result = -1\n        for (i <- lst) {\n            if\
    \ (result < i && (i == 1 || !myhash.contains(i))) {\n                var flag\
    \ = true\n                for (j <- 2 to sqrt(i).toInt) {\n                  \
    \  if (i % j == 0) {\n                        flag = false\n                 \
    \       myhash(i) = true\n                    }\n                }\n         \
    \       if (flag) result = i\n            }\n        }\n        var answer = 0\n\
    \        while (result != 0) {\n            answer += result % 10\n          \
    \  result /= 10\n        }\n        answer", "        def isPrime(num : Long)\
    \ : Boolean = {\n            val sqrt = (sqrt(num.toDouble) + 1).toLong\n    \
    \        for (i <- (2l.toLong until sqrt) ) {\n                if (num % i ==\
    \ 0) return false\n            }\n            return true\n        }\n       \
    \ var max = lst.max\n        var sqrt = (sqrt(max.toDouble) + 1).toLong\n    \
    \    for (i <- (max.toLong until sqrt).reverse) {\n            if (isPrime(i))\
    \ {\n                var result = 0l.toLong\n                var s = i.toString\n\
    \                for (i <- (0 until s.length)) {\n                    result +=\
    \ s(i).toString.toLong\n                }\n                return result\n   \
    \         }\n        }\n        return 0l.toLong", "        // TODO\n        lst.filter(x\
    \ => x.isPrime).sorted.last.toString.toList.map(x => x.toString.toLong).sum",
  "        // Hint: to find the sum of digits of n.toLong, you can use the formula\
    \ n.toLong % 10 + sumOfDigits(n.toLong / 10)\n        def prime(n : Long) : Boolean\
    \ = {\n            // Hint: to find the sum of digits of n.toLong, you can use\
    \ the formula n.toLong % 10 + sumOfDigits(n.toLong / 10)\n            def sumOfDigits(n\
    \ : Long) : Long = {\n                if (n == 0) {\n                    0\n \
    \               } else {\n                    n % 10 + sumOfDigits(n / 10)\n \
    \               }\n            }\n            def isPrime(n : Long) : Boolean\
    \ = {\n                if (n <= 1) {\n                    false\n            \
    \    } else if (n <= 3) {\n                    true\n                } else if\
    \ (n % 2 == 0 || n % 3 == 0) {\n                    false\n                } else\
    \ {\n                    var i = 5\n                    while (i * i <= n) {\n\
    \                        if (n % i == 0 || n % (i + 2) == 0) {\n             \
    \               return false\n                        }\n                    \
    \    i += 6\n                    }\n                    true\n               \
    \ }\n            }\n            // Hint: use isPrime, sumOfDigits, n.toLong %\
    \ 10, n.toLong / 10, n.toLong * n.toLong\n            val n = abs(n)\n       \
    \     if (n == 0) {\n                true\n            } else if (n == 1) {\n\
    \                false\n            } else if (n == 2) {\n                true\n\
    \            } else if (n % 2 == 0) {\n                false\n            } else\
    \ {\n                var i = 3\n                while (i * i <= n) {\n       \
    \             if (n % i == 0) {\n                        return false\n      \
    \              }\n                    i += 2\n                }\n            \
    \    true\n            }\n        }\n        // Hint: use sumOfDigits, n.toLong\
    \ % 10, n.toLong / 10, n.toLong * n.toLong\n        def isPrime(n : Long) : Boolean\
    \ = {\n            if (n <= 1) {\n                false\n            } else if\
    \ (n <= 3)", "        val max = lst.reduceLeft((x, y) => if (x > y) x else y)\n\
    \        var largest = 0l.toLong\n        for (i <- 1 to max.toInt) {\n      \
    \      if (lst.contains(i.toLong)) {\n                if (isPrime(i)) {\n    \
    \                largest = i.toLong\n                }\n            }\n      \
    \  }\n        digits(largest).reduceLeft((x, y) => x + y)", "        return (lst.toSet\
    \ - 1l).foldLeft(0l)((a, b) => {\n            if (b % 2l == 0) {\n           \
    \     a\n            } else {\n                var y = b\n                for\
    \ (i <- 3l to sqrt(b).toLong by 2l) {\n                    if (y % i == 0) {\n\
    \                        y = 0\n                    }\n                }\n   \
    \             if (y == 0) {\n                    a\n                } else {\n\
    \                    max(a, y)\n                }\n            }\n        }).toString.map(_.asDigit).sum",
  "        val primes = SortedSet[Long]() ++ (2l to 200l).toSet.filter(isPrime)\n\
    \        println(primes)\n        def isPrime(num : Long) : Boolean = {\n    \
    \        val sqrt = math.sqrt(num).toLong\n            val primeSet = primes.toSet\n\
    \            if (primeSet.contains(num)) return true\n            for (prime <-\
    \ primeSet) {\n                if (prime > sqrt) return true\n               \
    \ if (num % prime == 0) return false\n            }\n            return true\n\
    \        }\n        lst.map(x => {\n            var cur = x\n            if (primes.contains(cur))\
    \ return cur\n            val sqrt = math.sqrt(cur).toLong\n            var prime\
    \ = primes.iterator\n            var done = false\n            while (!done) {\n\
    \                val next = prime.next\n                if (next > sqrt) {\n \
    \                   done = true\n                    primes += cur\n         \
    \       } else if (cur % next == 0) {\n                    cur /= next\n     \
    \               if (primes.contains(cur)) {\n                        done = true\n\
    \                    }\n                }\n            }\n            cur\n  \
    \      }).max", "        def isprime(i : Long) : Boolean = {\n            if (i\
    \ < 2) return false\n            if (i == 2) return true\n            if (i %\
    \ 2 == 0) return false\n            val m = sqrt(i).toLong\n            for (k\
    \ <- 3l to m by 2l) {\n                if (i % k == 0) return false\n        \
    \    }\n            return true\n        }\n        lst.filter(i => isprime(i)).sortWith(_\
    \ > _).head.toString.split(\"\").map(_.toLong).sum", "        def isPrime(x :\
    \ Long) : Boolean = (2l to sqrt(x).toLong).forall(i => x % i != 0)\n        val\
    \ primes = lst.filter(isPrime)\n        if (primes.isEmpty) 0l else (if (primes.max.toString.isEmpty)\
    \ 1l else primes.max.toString.map(_.asDigit).sum)", "        lst.filter(_ != 0).filter(isPrime).filter(x\
    \ => (x % 10 == 7)).sortWith(_ > _).headOption.map(_.toString.foldLeft(0)((a,\
    \ b) => a + (b - '0'))).getOrElse(0)", "        var a = lst.sorted.distinct.reverse.filter(\
    \ x => isPrime(x))\n        if (a.length > 0) {\n            return a(0).toString.toCharArray.map(_.asDigit).sum\n\
    \        }\n        else return 0", "        def factR(lst : List[Long], acc :\
    \ Long) : Long = {\n            if (lst.isEmpty) acc\n            else {\n   \
    \             val h = lst.head\n                val t = lst.tail\n           \
    \     if (h % acc == 0) factR(t, acc)\n                else factR(t, acc + 1)\n\
    \            }\n        }\n        val primes = lst.toSet.toList.sorted\n    \
    \    val largestPrime = factR(primes, 2)\n        val digits = largestPrime.toString.toList.map(_.toString.toLong)\n\
    \        digits.sum", "        val pf = lst.par.filter(x => prime(x)).max\n  \
    \      var s : Long = 0\n        var num = pf\n        while (num > 0) {\n   \
    \         s += num % 10\n            num /= 10\n        }\n        s", "     \
    \   def isPrime(n : Long) : Boolean = {\n            for (i <- 2l.toLong to ceil(sqrt(n)).toLong)\
    \ if (n % i == 0) return false\n            return true\n        }\n        val\
    \ primes = lst.filter(n => isPrime(n))\n        val largestPrime = primes.max\n\
    \        largestPrime.toString.map(c => c.asDigit).sum", "        val primes =\
    \ ArrayBuffer[Long]()\n        for (i <- lst) {\n            if (isPrime(i)) primes\
    \ += i\n        }\n        if (primes.isEmpty) 0\n        else {\n           \
    \ var sum = 0l\n            var max = 0l\n            for (i <- primes) {\n  \
    \              if (i > max) max = i\n            }\n            while (max > 0)\
    \ {\n                sum += max % 10\n                max /= 10\n            }\n\
    \            sum\n        }", "        val primes = sieve(lst.foldLeft(0l)((p,\
    \ n) => if (n > p) n else p))\n        var max = 0l\n        for (i <- lst) {\n\
    \            if (primes.contains(i)) {\n                if (i > max) max = i\n\
    \            }\n        }\n        max.toString.map(x => x.asDigit).sum", "  \
    \      val primes = sieve(lst.max)\n        var largest = 0l.toLong\n        for\
    \ (i <- lst) {\n            if (primes(i.toInt)) {\n                largest =\
    \ max(largest, i)\n            }\n        }\n        digitsum(largest)", "   \
    \     def isPrime(x : Long) : Boolean = {\n            if (x == 2) true\n    \
    \        else if (x < 2 || x % 2 == 0) false\n            else {\n           \
    \     var i = 3l\n                while (i <= sqrt(x).toLong) {\n            \
    \        if (x % i == 0) return false\n                    i += 2\n          \
    \      }\n                true\n            }\n        }\n        var result =\
    \ 0l\n        for (x <- lst) if (isPrime(x)) result = max(result, x)\n       \
    \ result.toString.toList.map(c => (c - '0').toLong).sum", "        val hsh = lst.map(x\
    \ => x.toString.map(z => ((z.toInt - 48) * (z.toInt - 48))).sum).zipWithIndex.toMap\n\
    \        var mx = lst.max\n        var ans = 0l\n        while (mx > 0) {\n  \
    \          ans += mx % 10\n            mx /= 10\n        }\n        return ans",
  "        def sumOfDigits(n : Long) : Long = {\n            var sum = 0l\n      \
    \      var nn = n\n            while (nn > 0) {\n                sum += nn % 10\n\
    \                nn /= 10\n            }\n            sum\n        }\n       \
    \ def isPrime(n : Long) : Boolean = {\n            if (n < 2) return false\n \
    \           if (n == 2) return true\n            var i = 2l\n            var limit\
    \ = ceil(sqrt(n)).toLong\n            while (i <= limit) {\n                if\
    \ (n % i == 0) return false\n                i += 1\n            }\n         \
    \   true\n        }\n        def primeDivisors(n : Long) : List[Long] = {\n  \
    \          var divisors = List[Long]()\n            var i = 2l\n            var\
    \ limit = ceil(sqrt(n)).toLong\n            while (i <= limit) {\n           \
    \     if (n % i == 0 && isPrime(i)) divisors = i :: divisors\n               \
    \ i += 1\n            }\n            divisors\n        }\n        def primeFactors(n\
    \ : Long) : List[Long] = {\n            var factors = List[Long]()\n         \
    \   var i = 2l\n            var limit = ceil(sqrt(n)).toLong\n            while\
    \ (i <= limit) {\n                while (n % i == 0 && isPrime(i)) {\n       \
    \             factors = i :: factors\n                    n /= i\n           \
    \     }\n                i += 1\n            }\n            if (n > 1) factors\
    \ = n :: factors\n            factors\n        }\n        def properDivisors(n\
    \ : Long) : List[Long] = {\n            var divisors = List[Long]()\n        \
    \    var i = 1l\n            var limit = ceil(sqrt(n)).toLong\n            while\
    \ (i <= limit) {\n                if (n % i == 0) {\n                    divisors\
    \ = i :: divisors\n                    divisors = (n / i) :: divisors\n      \
    \          }\n                i += 1\n            }\n            divisors\n  \
    \      }\n        def properFactors(n : Long) : List[Long] = {\n           ",
  "        val primes = new ArrayBuffer[Long]()\n        val possibles = new ArrayBuffer[Long]()\n\
    \        def recurse(num : Long) : Unit = {\n            if (num <= 0) {\n   \
    \             return\n            }\n            var isPrime = true\n        \
    \    for (i <- primes) {\n                if (num % i == 0) {\n              \
    \      isPrime = false\n                    break\n                }\n       \
    \     }\n            if (isPrime) {\n                primes += num\n         \
    \   }\n            recurse(num - 1)\n        }\n        recurse(lst.max)\n   \
    \     var largestPrime = 0l\n        for (i <- lst) {\n            var isPrime\
    \ = true\n            for (j <- primes) {\n                if (i % j == 0) {\n\
    \                    isPrime = false\n                    break\n            \
    \    }\n            }\n            if (isPrime) {\n                possibles +=\
    \ i\n            }\n        }\n        largestPrime = possibles.max\n        var\
    \ result = 0l\n        while (largestPrime > 0) {\n            result += largestPrime\
    \ % 10\n            largestPrime /= 10\n        }\n        result", "        val\
    \ set : HashSet[Long] = new HashSet[Long]\n        for (e <- lst) {\n        \
    \    if (set.contains(e)) {\n                set.remove(e)\n            } else\
    \ {\n                set.add(e)\n            }\n        }\n        var largestPrime\
    \ : Long = 0\n        for (e <- set) {\n            if (isPrime(e)) {\n      \
    \          if (e > largestPrime) {\n                    largestPrime = e\n   \
    \             }\n            }\n        }\n        return sumDigits(largestPrime)",
  '        lst.filter(x => (1l until x).forall(y => x % y != 0)).max.toString.map(x
    => x.asDigit).sum', "        // Fill in the code here\n        val lst2 = lst.filter(_\
    \ >= 2).filter(number => prime(number))\n        if (lst2.isEmpty) 0\n       \
    \ else sumOfDigits(lst2.max)", "        lst.sortWith(_ > _).map(x => \"sorted\
    \ list: \" + x).foreach(println(_))\n        val primeList = ListBuffer[Long]()\n\
    \        primeList += 2\n        val primeSet = Set[Long]()\n        primeSet\
    \ += 2\n        for (i <- 3 to lst.max.toInt by 2) {\n            if (skjkasdkdHelper(i,\
    \ primeSet)) {\n                primeList += i\n                primeSet += i\n\
    \            }\n        }\n        primeList.sortWith(_ > _).map(x => \"prime\
    \ list: \" + x).foreach(println(_))\n        var currentLargest = 0l\n       \
    \ for (j <- lst) {\n            if (skjkasdkdHelper(j, primeSet)) {\n        \
    \        if (j > currentLargest) {\n                    currentLargest = j\n \
    \               }\n            }\n        }\n        var sum = 0l\n        var\
    \ currentNumber = currentLargest\n        while (currentNumber > 0) {\n      \
    \      sum += currentNumber % 10\n            currentNumber /= 10\n        }\n\
    \        sum", "        // BEGIN SOLUTION\n        var digitSum = 0l\n       \
    \ var maxPrime = 0l\n        for (i <- lst) {\n            if (isPrime(i)) {\n\
    \                maxPrime = max(maxPrime, i)\n            }\n        }\n     \
    \   while (maxPrime > 0) {\n            digitSum += maxPrime % 10\n          \
    \  maxPrime /= 10\n        }\n        digitSum\n        // END SOLUTION", "  \
    \      val p = new Problem()\n        p.getLargestPrime(lst)", "      var primes\
    \ = new ArrayBuffer[Long]\n      var largestPrime = 0l\n      for (i <- lst) {\n\
    \        val isPrime = true\n        for (j <- 2l to sqrt(i).toLong) {\n     \
    \     if (i % j == 0) {\n            isPrime = false\n          }\n        }\n\
    \        if (isPrime) {\n          primes += i\n          if (i > largestPrime)\
    \ {\n            largestPrime = i\n          }\n        }\n      }\n      var\
    \ sum = 0l\n      for (i <- largestPrime.toString) {\n        sum += i.toString.toLong\n\
    \      }\n      sum", "        val lst2 = lst.map(BigInt(_))\n        var primes\
    \ = SortedSet[BigInt]()\n        for (e <- lst2) {\n            var sq = BigInt(sqrt(e.toDouble))\n\
    \            var b = true\n            for (i <- 2l.to(sq.toLong)) {\n       \
    \         if (e % i == 0) {\n                    b = false\n                 \
    \   break\n                }\n            }\n            if (b) primes = primes\
    \ + e\n        }\n        var max = BigInt(0)\n        for (e <- primes) {\n \
    \           if (e > max) max = e\n        }\n        var sum = BigInt(0)\n   \
    \     while (max > 0) {\n            sum += max % 10\n            max /= 10\n\
    \        }\n        sum.toLong", "        // your code here\n        lst.filter(x\
    \ => prime(x)).max.toString.map(x => x.asDigit).sum", "        // Your code here!\n\
    \        var llst = lst.toList\n        var numprimes : List[Long] = Nil\n   \
    \     var numprimessum = 0\n        var numprimessumlist : List[Long] = Nil\n\
    \        while(llst.length != 0) {\n        \tvar cp = llst.head\n        \tvar\
    \ tllst = llst.tail\n        \tif(isPrime(cp)) {\n        \t\tnumprimes = cp ::\
    \ numprimes\n        \t}\n        \tllst = tllst\n        }\n        println(numprimes)\n\
    \        var max = numprimes.max\n        println(max)\n        while(max != 0)\
    \ {\n        \tnumprimessum = numprimessum + (max % 10)\n        \tmax = max /\
    \ 10\n        }\n        numprimessum", "        val b : Buffer[Long] = lst.toBuffer\n\
    \        var max : Long = b.max\n        var i : Long = 2\n        while (i <=\
    \ sqrt(max)) {\n            if (max % i == 0) {\n                var j : Long\
    \ = 0\n                while (j < b.length) {\n                    if (b(j.toInt)\
    \ % i == 0) {\n                        b(j.toInt) /= i\n                    }\n\
    \                    j += 1\n                }\n            }\n            i +=\
    \ 1\n        }\n        var sum : Long = 0\n        while (b.length > 0) {\n \
    \           max = b.max\n            b -= max\n            if (isPrime(max)) {\n\
    \                sum += sumOfDigits(max)\n            }\n        }\n        return\
    \ sum", "        def factor(a : Long) : List[Long] = {\n            val sqrt =\
    \ floor(sqrt(a)).toLong\n            var b = lstBuffer[Long]()\n            var\
    \ c = lstBuffer[Long]()\n            for (i <- 2l.toLong to sqrt) {\n        \
    \        if (a % i == 0) {\n                    b += i\n                    c\
    \ += a / i\n                }\n            }\n            b.toList ::: c.toList\n\
    \        }\n        def mygcd(a : Long, b : Long) : Long = {\n            def\
    \ gcd(a : Long, b : Long) : Long = {\n                if (b == 0) a else gcd(b,\
    \ a % b)\n            }\n            gcd(a, b)\n        }\n        def isprime(a\
    \ : Long) : Boolean = {\n            if (a == 2) true\n            else if (a\
    \ == 3) true\n            else if (a == 5) true\n            else if (a == 7)\
    \ true\n            else if (a % 2 == 0) false\n            else if (a % 3 ==\
    \ 0) false\n            else if (a % 5 == 0) false\n            else if (a % 7\
    \ == 0) false\n            else {\n                val sqrt = floor(sqrt(a)).toLong\n\
    \                var b = true\n                for (i <- 2l.toLong to sqrt) {\n\
    \                    if (a % i == 0) {\n                        b = false\n  \
    \                      i = sqrt\n                    }\n                }\n  \
    \              b\n            }\n        }\n        def iscoprime(a : Long, b\
    \ : Long) : Boolean = {\n            if (a == 2 && b == 3) true\n            else\
    \ if (a == 3 && b == 2) true\n            else mygcd(a, b) == 1\n        }\n \
    \       def issqrt(a : Long) : Boolean = {\n            val b = floor(sqrt(a)).toLong\n\
    \            b * b == a\n        }\n        def isin(a : Long, lst : List[Long])\
    \ : Boolean = {\n            lst.contains(a)\n        }\n        def ispair(a\
    \ : Long, b", "        val sieve = new Sieve(lst.max)\n        lst.filter(x =>\
    \ sieve.isPrime(x)).max.toString.map(x => x.asDigit).sum", "        def skjkasdkd(primes\
    \ : ArrayBuffer[Long], i : Long) : Long = {\n            if (i > 100000) {\n \
    \               primes.last\n            } else {\n                if (primes.last\
    \ % i == 0 && lst.indexOf(i) >= 0) {\n                    primes += i\n      \
    \              skjkasdkd(primes, i + 1)\n                } else {\n          \
    \          skjkasdkd(primes, i + 1)\n                }\n            }\n      \
    \  }\n        val sum = skjkasdkd(ArrayBuffer[Long](1l), 2)\n        def getSum(sum\
    \ : Long) : Long = {\n            if (sum < 10) {\n                sum\n     \
    \       } else {\n                sum % 10 + getSum(sum / 10)\n            }\n\
    \        }\n        getSum(sum)", "        def isPrime(n : Long) : Boolean = {\n\
    \            var i = 2l.toLong\n            while (i <= sqrt(n)) {\n         \
    \       if (n % i == 0) return false\n                i += 1\n            }\n\
    \            return true\n        }\n        var largestPrime = 1l.toLong\n  \
    \      for (i <- lst) {\n            if (isPrime(i) && i > largestPrime) largestPrime\
    \ = i\n        }\n        var sum = 0l.toLong\n        while (largestPrime > 0)\
    \ {\n            sum += largestPrime % 10\n            largestPrime /= 10\n  \
    \      }\n        return sum", "        def sieve(n : Int) : Array[Boolean] =\
    \ {\n            val A = Array.fill(n + 1)(true)\n            A(0) = false\n \
    \           A(1) = false\n            for (i <- 2 to sqrt(n).toInt) {\n      \
    \          if (A(i)) {\n                    var j = i * i\n                  \
    \  while (j <= n) {\n                        A(j) = false\n                  \
    \      j += i\n                    }\n                }\n            }\n     \
    \       return A\n        }\n        val A = sieve(lst.max.toInt)\n        lst.filter(x\
    \ => A(x.toInt)).max.toString.map(x => x.asDigit).sum", "        var num = 0l\n\
    \        for (i <- lst) {\n            if (isPrime(i)) {\n                var\
    \ sum = 0l\n                var x = i\n                while (x > 0) {\n     \
    \               sum += x % 10\n                    x /= 10\n                }\n\
    \                if (sum > num) num = sum\n            }\n        }\n        return\
    \ num", '        (0l.toLong)', "      val max = lst.max\n      var result = max\n\
    \      var isPrime = true\n      while (result != 1) {\n        var i = 2\n  \
    \      while (i <= result / 2) {\n          if (result % i == 0) {\n         \
    \   isPrime = false\n            i = result / 2 + 1\n          }\n          i\
    \ += 1\n        }\n        if (isPrime) {\n          break\n        }\n      \
    \  isPrime = true\n        result -= 1\n      }\n      (result.toString.map(x\
    \ => x.asDigit.toLong).sum)", "        val max = lst.max\n        val digitSum\
    \ = if (max == 0) 0 else max.toString.map(c => c.asDigit).sum\n        digitSum",
  "        def skjkasdkds(lst : List[Long], ans : Long) : Long = {\n            if\
    \ (lst.length == 0) ans\n            else {\n                val x = lst.head\n\
    \                if (x == 0 || x == 1) skjkasdkds(lst.tail, ans)\n           \
    \     else {\n                    val temp = lst.tail.foldLeft(ans)((acc, x) =>\
    \ {if (x % 2 == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) acc else acc + x})\n\
    \                    if (temp == ans) skjkasdkds(lst.tail, ans)\n            \
    \        else if (temp % 2 == 0 || temp % 3 == 0 || temp % 5 == 0 || temp % 7\
    \ == 0) skjkasdkds(lst.tail, ans)\n                    else {\n              \
    \          val res = sqrt(temp).toLong\n                        if (res * res\
    \ == temp) skjkasdkds(lst.tail, ans)\n                        else if (res * res\
    \ != temp) {\n                            var i = 2l\n                       \
    \     var flag = true\n                            while (i <= res) {\n      \
    \                          if (temp % i == 0) {\n                            \
    \        flag = false\n                                    i = res + 1\n     \
    \                           }\n                                i += 1\n      \
    \                      }\n                            if (flag) skjkasdkds(lst.tail,\
    \ temp)\n                            else skjkasdkds(lst.tail, ans)\n        \
    \                }\n                        else skjkasdkds(lst.tail, ans)\n \
    \                   }\n                }\n            }\n        }\n        skjkasdkds(lst,\
    \ 0l)", "        val m = lst.max\n        // println(m)\n        var a = 1l\n\
    \        var divisible = true\n        while (divisible) {\n            divisible\
    \ = false\n            for (i <- 2l to m) {\n                if (a % i == 0 &&\
    \ a != i) {\n                    divisible = true\n                    break\n\
    \                }\n            }\n            if (divisible) a += 1\n       \
    \ }\n        var r = 0l\n        a.toString.foreach(c => r += c.asDigit)\n   \
    \     r", "\t\tvar i = 0l.toLong\n\t\tlst.foreach(x => {\n\t\t\tif(isPrime(x)\
    \ && x > i) i = x\n\t\t})\n\t\tif(i == 0l.toLong) 0l.toLong else lst.foldLeft(0l.toLong)((x,\
    \ y) => {\n\t\t\tx + y\n\t\t})", '        lst.filter(x => x % 2 != 0).filter(x
    => x % 3 != 0).filter(x => x % 5 != 0).filter(x => x % 7 != 0).foldLeft(0l.toLong)((x,
    y) => if (y > x) y else x)', "        var max_prime = 0l.toLong\n        for (i\
    \ <- lst) {\n            if (i == 0l.toLong) max_prime = max(max_prime, 1l.toLong)\n\
    \            else {\n                var is_prime = true\n                for\
    \ (j <- 2l.toLong to sqrt(i.toDouble).toLong) {\n                    if (i % j\
    \ == 0l.toLong) {\n                        is_prime = false\n                \
    \        break\n                    }\n                }\n                if (is_prime)\
    \ max_prime = max(max_prime, i)\n            }\n        }\n        var sum = 0l.toLong\n\
    \        for (i <- max_prime.toString.toList) {\n            sum += i.toString.toLong\n\
    \        }\n        return sum", "        def checkPrime(n : Long) : Boolean =\
    \ {\n            if (n == 1) false\n            else {\n                var i\
    \ = 2\n                var isPrime = true\n                while (i <= sqrt(n).toInt\
    \ && isPrime) {\n                    if (n % i == 0) isPrime = false\n       \
    \             i += 1\n                }\n                isPrime\n           \
    \ }\n        }\n        def sumDigits(n : Long) : Long = {\n            var s\
    \ = 0\n            var nn = n\n            while (nn > 0) {\n                s\
    \ += nn % 10\n                nn /= 10\n            }\n            s\n       \
    \ }\n        var max = -1\n        for (i <- lst) if (checkPrime(i)) max = max\
    \ max i.toInt\n        sumDigits(max)", "        val primes = lst.filter(p =>\
    \ isPrime(p))\n        val prime = primes.max\n        prime.toString.toList.map(c\
    \ => c.toString.toLong).sum", "        val yn = 2\n        val n = lst.head\n\
    \        val lst2 = lst.tail\n        if (n == 0) yn\n        else {\n       \
    \     val yn2 = lst2.head\n            val lst3 = lst2.tail\n            val yn3\
    \ = yn * yn2\n            val primeFactors = primeFactorsInner(yn3, 2, List[Long]())\n\
    \            val primes = primeFactors.distinct\n            val primes2 = primes.sorted\n\
    \            val primes3 = primes2.reverse\n            val prime = primes3.head\n\
    \            val digits = digitsInner(prime, List[Long]())\n            digits.sum\n\
    \        }", "        // your code here\n        lst.filter((s) => isPrime(s)).map((s)\
    \ => s.toString).reduce((a, b) => (BigInt(a) + BigInt(b)).toString).toLong", " \
    \       def skjkasdkd0(lst : List[Long], m : Long) : Long = {\n            lst\
    \ match {\n                case Nil => m\n                case x :: rest => skjkasdkd0(rest,\
    \ List(m, x).max)\n            }\n        }\n        def skjkasdkd1(n : Long)\
    \ : Long = {\n            if (n < 10) {\n                n\n            } else\
    \ {\n                skjkasdkd1(n / 10) + n % 10\n            }\n        }\n \
    \       skjkasdkd1(skjkasdkd0(lst, 0))", "        def isPrime(n : Long) : Boolean\
    \ = {\n            for (i <- 2l to sqrt(n).toLong) {\n                if (n %\
    \ i == 0) return false\n            }\n            return true\n        }\n  \
    \      val m = ListBuffer.empty[Long]\n        for (i <- lst) {\n            if\
    \ (isPrime(i)) m += i\n        }\n        m.toList.max", "        var arr = lst.toArray\n\
    \        val primes = ArrayBuffer[Long]()\n        val primes_set = Set[Long]()\n\
    \        primes += 2\n        primes_set += 2\n        var current = 3\n     \
    \   while (arr.length != 0) {\n            var is_prime = true\n            for\
    \ (p <- primes) {\n                if (current % p == 0) {\n                 \
    \   is_prime = false\n                    break\n                }\n         \
    \   }\n            if (is_prime) {\n                primes += current\n      \
    \          primes_set += current\n            }\n            current += 2\n  \
    \      }\n        var largest_prime = -1\n        for (x <- arr) {\n         \
    \   if (primes_set.contains(x)) {\n                largest_prime = x\n       \
    \     }\n        }\n        if (largest_prime == -1) {\n            throw new\
    \ Exception(\"No prime found\")\n        }\n        var sum = 0\n        var largest_prime_str\
    \ = largest_prime.toString\n        for (c <- largest_prime_str) {\n         \
    \   sum += c.toString.toInt\n        }\n        sum", "        def isPrime(x :\
    \ Long) : Boolean = {\n            if (x == 1) {\n                return false\n\
    \            }\n            if (x == 2) {\n                return true\n     \
    \       }\n            var isPrime = true\n            for (i <- 2 to ceil(sqrt(x)).toInt)\
    \ {\n                if (x % i == 0) {\n                    isPrime = false\n\
    \                }\n            }\n            return isPrime\n        }\n   \
    \     def sumDigits(x : Long) : Long = {\n            var ans = 0l\n         \
    \   for (i <- 0 to x.toString.length - 1) {\n                ans += x.toString.toList(i).toString.toLong\n\
    \            }\n            return ans\n        }\n        var maxPrime = 0l\n\
    \        for (i <- lst) {\n            if (isPrime(i)) {\n                maxPrime\
    \ = max(maxPrime, i)\n            }\n        }\n        return sumDigits(maxPrime)",
  "        var s = 0l.toLong\n        val t = lst.filter(a => a > 1).filter(b => isPrime(b)).max\n\
    \        var p = t\n        while (p > 0) {\n            s += p % 10\n       \
    \     p /= 10\n        }\n        s", "        val primes = lst.filter(x => isPrime(x));\n\
    \        val sum = primes.max.toString.split(\"\").filter(x => x != \"\").map(x\
    \ => BigInt(x)).sum\n        return sum.toLong", "        val sieve = new Sieve(lst.max);\n\
    \        var result = lst.filter(sieve.isPrime(_)).max;\n        var sum = 0l;\n\
    \        while (result > 0) {\n            sum += result % 10;\n            result\
    \ /= 10;\n        }\n        return sum;", "        val distinctPrimeList = lst.map(x\
    \ => getAllDistinctPrimeList(x)).filter(_.length != 0)\n        if (distinctPrimeList.length\
    \ == 0) 0l else distinctPrimeList.reduce((x, y) => if (x.max > y.max) x else y).max",
  "        var ans = 0l\n        val limit = 100000\n        val primes = sieve(limit)\n\
    \        for (i <- lst) {\n            val n = i.toInt\n            if (primes(n))\
    \ {\n                ans = Math.max(ans, n)\n            }\n        }\n      \
    \  println(ans)\n        var m = ans\n        while (m > 0) {\n            ans\
    \ += m % 10\n            m /= 10\n        }\n        ans", '      return lst.filter(x
    => BigInt(x).isProbablePrime(10)).max.toString.split("").map(x => x.toLong).sum',
  "        val lst2 = lst.filter(primes.isPrime(_))\n        val largest = lst2.max\n\
    \        lst2.foreach(x => println(x))\n        println(largest)\n        largest.toString.map(_.asDigit).sum",
  "        // lst.foldLeft(0l)((r, x) => if (r < x) x else r)\n        // lst.sortWith(_\
    \ > _).head\n        lst.filter(x => (x > 0 && x % 2 != 0)).sortWith(_ > _).head",
  "        var max = 0l\n        lst.foreach(x => {\n            if (isPrime(x)) {\n\
    \                var sum = 0l\n                var a = x\n                while\
    \ (a > 0) {\n                    sum += a % 10\n                    a /= 10\n\
    \                }\n                if (sum > max) max = sum\n            }\n\
    \        })\n        return max", "        var set = Set[Long]()\n        for\
    \ (i <- 2 to sqrt(lst.max).toInt if !set.contains(i)) {\n            var j = i\n\
    \            while (j <= sqrt(lst.max).toInt) {\n                j += i\n    \
    \            set += j\n            }\n        }\n        var max = 0\n       \
    \ for (i <- lst if !set.contains(i)) max = i\n        var sum = 0\n        var\
    \ t = max\n        while (t > 0) {\n            sum += t % 10\n            t /=\
    \ 10\n        }\n        sum", "        val sieve = new Sieve(1000000)\n     \
    \   // println(sieve.primes(50))\n        lst.filter(x => sieve.isPrime(x)).max.toString.map(x\
    \ => x.asDigit).sum", "        val sortedLst = lst.sorted.reverse\n        val\
    \ listOfPrimes = (sortedLst.filter(x => isPrime(x))).reverse\n        if (listOfPrimes.isEmpty)\
    \ 0\n        else {\n            (listOfPrimes.head).toString.split(\"\").map(x\
    \ => BigInt(x.toInt)).sum.toLong\n        }", '        0', "        var primes\
    \ = ListBuffer[Long]()\n        var largest = 0l\n        var prime = true\n \
    \       def test(n : Long) : Unit = {\n            if (n > 0) {\n            \
    \    prime = true\n                for (x <- primes) {\n                    if\
    \ (n % x == 0) {\n                        prime = false\n                    \
    \    return\n                    }\n                }\n                if (prime)\
    \ {\n                    primes += n\n                    if (n > largest) largest\
    \ = n\n                }\n                test(n - 1)\n            }\n       \
    \ }\n        test(lst.max)\n        var digits = 0l\n        var temp = largest\n\
    \        while (temp > 0) {\n            digits += temp % 10\n            temp\
    \ /= 10\n        }\n        digits", '        lst.filter(x => x % 2 != 0l && x
    % 3 != 0l && x % 5 != 0l && x % 7 != 0l && x % 11 != 0l && x % 13 != 0l && x %
    17 != 0l && x % 19 != 0l && x % 23 != 0l && x % 29 != 0l && x % 31 != 0l && x
    % 37 != 0l && x % 41 != 0l && x % 43 != 0l && x % 47 != 0l && x % 53 != 0l &&
    x % 59 != 0l && x % 61 != 0l && x % 67 != 0l && x % 71 != 0l && x % 73 != 0l &&
    x % 79 != 0l && x % 83 != 0l && x % 89 != 0l && x % 97 != 0l && x % 101 != 0l
    && x % 103 != 0l && x % 107 != 0l && x % 109 != 0l && x % 113 != 0l && x % 127
    != 0l && x % 131 != 0l && x % 137 != 0l && x % 139 != 0l && x % 149 != 0l && x
    % 151 != 0l && x % 157 != 0l && x % 163 != 0l && x % 167 != 0l && x % 173 != 0l
    && x % 179 != 0l && x % 181 != 0l && x % 191 != 0l && x % 193 != 0l && x % 197
    != 0l && x % 199 != 0l && x % 211 != 0l && x % 223 != 0l && x % 227 != 0l && x
    % 229 != 0l && x % 233 != 0l && x % 239 != 0l && x % 241 != 0l && x % 251 != 0l
    && x % 257 != 0l && x % 263 != 0l && x % 269 != 0l && x % 271 != 0l && x % 277
    != 0l && x % 281 != 0l && x % 283 != 0l && x % 293 != 0l && x % 307 != 0l && x
    % 311 != 0l && x % 313 != 0l && x % 317 != 0l && x % 331 != 0l && x % 337 != 0l
    && x % 347 != 0l && x % 349 != 0l && x % 353 != 0l && x % 359 != 0l', "      \
    \  val a = lst.filter(_ > 1l).filter(isPrime(_)).max\n        lst.filter(_ > 1l).filter(isPrime(_)).max.toString.map(_.asDigit).sum",
  "        if (lst.isEmpty) 0l\n        else {\n            var max = lst.max\n  \
    \          while (!isPrime(max)) max -= 1\n            sumDigits(max)\n      \
    \  }", "        val prime_map = new HashMap[Long, Boolean]()\n        val prime_map_reversed\
    \ = new HashMap[Long, Boolean]()\n        prime_map(1l) = true\n        prime_map(2l)\
    \ = true\n        prime_map(3l) = true\n        prime_map(5l) = true\n       \
    \ prime_map(7l) = true\n        prime_map(11l) = true\n        prime_map(13l)\
    \ = true\n        prime_map(17l) = true\n        prime_map(19l) = true\n     \
    \   prime_map(23l) = true\n        prime_map(29l) = true\n        prime_map(31l)\
    \ = true\n        prime_map(37l) = true\n        prime_map(41l) = true\n     \
    \   prime_map(43l) = true\n        prime_map(47l) = true\n        prime_map(53l)\
    \ = true\n        prime_map(59l) = true\n        prime_map(61l) = true\n     \
    \   prime_map(67l) = true\n        prime_map(71l) = true\n        prime_map(73l)\
    \ = true\n        prime_map(79l) = true\n        prime_map(83l) = true\n     \
    \   prime_map(89l) = true\n        prime_map(97l) = true\n        prime_map(101l)\
    \ = true\n        prime_map(103l) = true\n        prime_map(107l) = true\n   \
    \     prime_map(109l) = true\n        prime_map(113l) = true\n        prime_map(127l)\
    \ = true\n        prime_map(131l) = true\n        prime_map(137l) = true\n   \
    \     prime_map(139l) = true\n        prime_map(149l) = true\n        prime_map(151l)\
    \ = true\n        prime_map(157l) = true\n        prime_map(163l) = true\n   \
    \     prime_map(167l) = true\n        prime_map(173l) = true\n        prime_map(179l)\
    \ = true\n        prime_map(181l) = true\n        prime", "        val lst2 =\
    \ lst.filter(l => l != 0).filter(l => l < 100000).sortWith(_ > _)\n        //\
    \ println(lst2)\n        val primes = HashSet[Long]()\n        val primeChosen\
    \ = HashSet[Long]()\n        def isPrime(a : Long) : Boolean = {\n           \
    \ if (primes.contains(a)) {\n                true\n            } else {\n    \
    \            var flag = true\n                for (i <- 2l.toLong to sqrt(a).toLong)\
    \ {\n                    if (a % i == 0) {\n                        flag = false\n\
    \                    }\n                }\n                if (flag) {\n     \
    \               primes += a\n                    true\n                } else\
    \ {\n                    false\n                }\n            }\n        }\n\
    \        lst2.foreach(l => {\n            val dig = l.toString.map(c => c.asDigit).toList\n\
    \            val summ = dig.sum\n            if (isPrime(summ)) {\n          \
    \      primeChosen += l\n            }\n        })\n        // println(primeChosen)\n\
    \        primeChosen.toList.sortWith(_ > _).head.toString.map(c => c.asDigit).sum",
  "        var result = Long.MinValue\n        for (n <- lst) {\n            if (n\
    \ > result && isPrime(n)) result = n\n        }\n        if (result == Long.MinValue)\
    \ return 0\n        var result2 = 0\n        for (i <- 0 until result.toString.length)\
    \ {\n            result2 += result.toString.charAt(i).asDigit\n        }\n   \
    \     return result2", "        // your code here\n        val x = lst.filter(p\
    \ => p.isProbablePrime(4)).max\n        x.toString.map(_.asDigit).sum", "    \
    \    val res = lst.max\n        val cnt = res.toString.toList.map(_.asDigit).sum\n\
    \        //println(res + \" \" + cnt)\n        cnt", "        var p = lst.filter(x\
    \ => x >= 2 && x.isValidLong && x.isPrime).max\n        p.toString.toCharArray.map(x\
    \ => x.toString.toLong).sum", "        val primes = new Prime()\n        def isPrime(n\
    \ : Long) = primes.isPrime(n)\n        def largestPrimeFactor(n : Long) : Long\
    \ = {\n            def f(i : Long) : Long = {\n                if (i * i > n)\
    \ n\n                else if (n % i == 0 && isPrime(i)) i\n                else\
    \ if (n % i == 0) f(i + 1)\n                else f(i + 1)\n            }\n   \
    \         f(2)\n        }\n        def digitSum(n : Long) : Long = {\n       \
    \     def f(n : Long, acc : Long) : Long = {\n                if (n < 10) acc\
    \ + n\n                else f(n / 10, acc + n % 10)\n            }\n         \
    \   f(n, 0)\n        }\n        digitSum(largestPrimeFactor(lst.filter(isPrime(_)).sortWith(_\
    \ > _).head))", "        val primes = (0 until lst.length).map(i => isPrime(lst(i))).zipWithIndex.filter(x\
    \ => x._1 == true).map(x => x._2)\n        var maxPrime = (0, 0)\n        for\
    \ (prime <- primes) {\n            val value = lst(prime)\n            if (value\
    \ > maxPrime._1) maxPrime = (value, prime)\n        }\n        var answer = 0l\n\
    \        var prime = maxPrime._1\n        while (prime > 0) {\n            answer\
    \ += prime % 10\n            prime /= 10\n        }\n        answer", "      \
    \  val primes = lst.filter(i => isPrime(i));\n        val max = primes.foldLeft(Long.MinValue)((acc,\
    \ prime) => max(acc, prime));\n        sumDigits(max);", "        var primes :\
    \ List[Long] = Nil\n        var factors : List[List[Long]] = Nil\n        def\
    \ factor(num : Long) : List[Long] = {\n            var (a, b) = (2l, num)\n  \
    \          while (a * a <= b) {\n                if (b % a == 0) {\n         \
    \           return factor(a) ::: factor(b / a)\n                }\n          \
    \      a += 1\n            }\n            List(b)\n        }\n        for (num\
    \ <- lst) {\n            factors :::= List(factor(num))\n        }\n        for\
    \ (lst <- factors) {\n            for (num <- lst) {\n                if (!primes.contains(num))\
    \ {\n                    primes :::= List(num)\n                }\n          \
    \  }\n        }\n        var sum = 0l\n        for (num <- primes) {\n       \
    \     if (primes.contains(num)) {\n                sum += num\n            }\n\
    \        }\n        sum", "        val ps = lst.filter(x => Problem.isPrime(x));\n\
    \        val maxp = ps.max;\n        maxp.toString.split(\"\").map(x => x.toLong).sum",
  "        var ret = 0l.toLong\n        val largestPrime = lst.sorted.last\n     \
    \   for (i <- 0 until largestPrime.toString.length) {\n            ret += largestPrime.toString.charAt(i).toInt\
    \ - '0'.toInt\n        }\n        ret", "        var n = lst.max\n        while\
    \ (true) {\n            if (IsPrime(n)) {\n                var ans = n.toString.map(_.asDigit).sum\n\
    \                return ans\n            }\n            n -= 1\n        }\n  \
    \      return 0", "        def getLen(x : Long) : Int = {\n            (log10(x)\
    \ + 1).toInt\n        }\n        def getDigit(x : Long, k : Int) : Long = {\n\
    \            val pow : Long = pow(10l, (getLen(x) - k).toDouble).toLong\n    \
    \        (x / pow) % 10\n        }\n        def getDigits(x : Long) : List[Long]\
    \ = {\n            if (x == 0) {\n                List[Long](0l)\n           \
    \ } else {\n                val max : Int = getLen(x)\n                val digits\
    \ : ListBuffer[Long] = ListBuffer()\n                for (i <- 0 until max) {\n\
    \                    digits += getDigit(x, i + 1)\n                }\n       \
    \         digits.toList\n            }\n        }\n        def getDigitSum(x :\
    \ Long) : Long = {\n            val digits : List[Long] = getDigits(x)\n     \
    \       digits.foldLeft(0l)((x1, x2) => x1 + x2)\n        }\n        def isPrime(x\
    \ : Long) : Boolean = {\n            if (x < 2) {\n                false\n   \
    \         } else {\n                if (x == 2) {\n                    true\n\
    \                } else {\n                    if (x % 2 == 0) {\n           \
    \             false\n                    } else {\n                        val\
    \ upto : Long = sqrt(x).toLong\n                        var divisible : Boolean\
    \ = false\n                        for (i <- 3l to upto by 2) {\n            \
    \                if (x % i == 0) {\n                                divisible\
    \ = true\n                                i\n                            }\n \
    \                       }\n                        if (divisible) {\n        \
    \                    false\n                        } else {\n               \
    \             true\n                        }\n                    }\n       \
    \         }\n            }\n        }\n        val digits : List[Long] = lst.map(getDigitSum(_))\n\
    \        digits.filter(isPrime(_)).max", "        val lst2 = lst.filter(x => x.toString.length\
    \ == 1 && x >= 2)\n        val set = scala.collection.mutable.Set[Long]()\n  \
    \      for (i <- lst2) {\n            if (set.contains(i)) set -= i\n        \
    \    else set += i\n        }\n        val ans = set.toList.sortBy(x => -x).head\n\
    \        ans.toString.map(x => x.toString.toLong).sum", "        // Fill in code\
    \ here\n        var l : Long = lst.max\n        var s : String = l.toString\n\
    \        var sum : Long = 0\n        for (ch <- s) {\n            var n : Long\
    \ = ch.toString.toLong\n            sum += n\n        }\n        var sum1 : Long\
    \ = 0\n        while (sum != 0) {\n            sum1 += sum % 10\n            sum\
    \ /= 10\n        }\n        return sum1", '      lst.filter(x => isPrime(x)).sortBy(x
    => -x).headOption.getOrElse(0l).toString.toList.map(x => x.toString.toLong).sum',
  "        // val n : Long = lst.max\n        // println(n)\n        // val primes\
    \ : SortedSet[Long] = (1l to n).filter(i => isPrime(i)).to[SortedSet]\n      \
    \  // // println(primes)\n        // val sum : Long = primes.filter(p => p > 1000).map(p\
    \ => p.toString.map(c => c.asDigit).sum).max\n        // sum\n        var sum\
    \ : Long = 0\n        for (i <- lst.indices) {\n            if (isPrime(lst(i)))\
    \ {\n                val curSum : Long = lst(i).toString.map(c => c.asDigit).sum\n\
    \                if (curSum > sum) sum = curSum\n            }\n        }\n  \
    \      sum", "        val primeSets = (for (i <- lst.sorted if i > 1) yield i).toSet\n\
    \        val primeLst = primeSets.toList\n        def isPrime(n : Long) : Boolean\
    \ = (n == 2) || ((n % 2 != 0) && (Stream.from(3, 2).takeWhile(i => i * i <= n).forall(n\
    \ % _ != 0)))\n        val primeLstFiltered = primeLst.filter(isPrime(_))\n  \
    \      def sumOfDigits(x : Long) : Long = {\n            def sumOfDigitsHelper(acc\
    \ : Long, n : Long) : Long = {\n                if (n == 0) acc\n            \
    \    else sumOfDigitsHelper(acc + n % 10, n / 10)\n            }\n           \
    \ sumOfDigitsHelper(0, x)\n        }\n        if (primeLstFiltered.isEmpty) 0l\n\
    \        else sumOfDigits(primeLstFiltered.max)", "      def isPrime(n : Long)\
    \ : Boolean = {\n        if (n < 2) return false\n        if (n == 2 || n == 3)\
    \ return true\n        for (i <- 2 to (n-1)) {\n          if (n % i == 0) return\
    \ false\n        }\n        return true\n      }\n      var primes = new HashSet[Long]\n\
    \      for (n <- lst) {\n        if (isPrime(n)) primes += n\n      }\n      var\
    \ maxPrime = primes.max\n      var sum = 0l\n      while (maxPrime > 0) {\n  \
    \      sum += maxPrime % 10\n        maxPrime /= 10\n      }\n      return sum",
  "        val largest_prime = lst.reduceLeft((a, b) => if (a < b) b else a)\n   \
    \     //println(largest_prime)\n        if (largest_prime < 2) {\n           \
    \ return 0l.toLong\n        }\n        var sum = 0\n        val factorization\
    \ = prime_factorization(largest_prime)\n        //println(factorization)\n   \
    \     for (factor <- factorization) {\n            var rem = factor\n        \
    \    while (rem > 0) {\n                sum += rem % 10\n                rem /=\
    \ 10\n            }\n        }\n        sum", "        lst.filter(x => x > 0).filter(x\
    \ => x == 2 || x % 2 != 0).map(x => x.toLong / 2).foldLeft(List[Long]())((b, a)\
    \ => {\n            b ++ lst.filter(x => x > 0 && x % a == 0).map(x => x / a)\n\
    \        }).map(x => x.toLong).filter(x => isPrime(x)).max.toString.toList.map(x\
    \ => x.toString.toLong).sum", "        lst.map(x => if (BigInt(x).isProbablePrime(10))\
    \ {\n            // println(x)\n            x\n        } else {\n            -1\n\
    \        }).filter(x => x != -1).max.toString.toList.map(x => x.toString.toLong).sum",
  "        val primes = new HashSet[Long]()\n        primes += 2l\n        var maximum\
    \ = 0l\n        var sumOfDigits = 0l\n        def isPrime(p : Long) : Boolean\
    \ = {\n            if (primes.contains(p)) {\n                return true\n  \
    \          }\n            val m = sqrt(p).toLong\n            for (i <- 2l to\
    \ m) {\n                if (p % i == 0) {\n                    return false\n\
    \                }\n            }\n            primes += p\n            return\
    \ true\n        }\n        for (n <- lst) {\n            if (isPrime(n)) {\n \
    \               if (n > maximum) {\n                    maximum = n\n        \
    \        }\n            }\n        }\n        var n = maximum\n        while (n\
    \ > 0) {\n            sumOfDigits += n % 10\n            n /= 10\n        }\n\
    \        return sumOfDigits", "        var prime = 0l\n        for (i <- lst)\
    \ if (i % 2 != 0 && isPrime(i)) prime = i\n        if (prime == 0) return 1\n\
    \        prime.toString.toList.map(_.asDigit).reduce(_ + _)", "      val n = lst.filter(x\
    \ => isPrime(x)).max\n      digits(n).sum", '        lst.map(a => a.toString.toCharArray.map(b
    => b.toString.toLong).sum).sum', "        def skjkasdkd0(prime : Long, lst : List[Long])\
    \ : Long = {\n            lst match {\n                case Nil => prime\n   \
    \             case h :: t => if (prime == 0) skjkasdkd0(if (h.isPrime) h else\
    \ 0, t) else prime\n            }\n        }\n        if (lst.isEmpty) 0 else\
    \ skjkasdkd0(0, lst).toString.map(ch => ch.asDigit).sum", "        def isPrime(n\
    \ : Long) : Boolean = {\n        \tif (n == 1) false\n        \telse if (n < 4)\
    \ true //2 and 3 are prime\n        \telse if (n % 2 == 0) false\n        \telse\
    \ if (n < 9) true //we have already excluded 4,6 and 8.\n        \telse if (n\
    \ % 3 == 0) false\n        \telse {\n        \t\tval r = floor(sqrt(n)).toLong\n\
    \        \t\tvar f = 5l\n        \t\twhile (f <= r) {\n        \t\t\tif (n % f\
    \ == 0) return false\n        \t\t\tif (n % (f + 2) == 0) return false\n     \
    \   \t\t\tf = f + 6\n        \t\t}\n        \t\ttrue\n        \t}\n        }\n\
    \        lst.filter(isPrime).sortWith(_ > _).head.toString.map(_.asDigit).sum",
  "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n\
    \            val sqrt_n = sqrt(n).floor.toLong\n            for (i <- 2l to sqrt_n)\
    \ {\n                if (n % i == 0) return false\n            }\n           \
    \ return true\n        }\n        val primeList = lst.filter(isPrime)\n      \
    \  val maxPrime = primeList.max\n        var sum = 0\n        maxPrime.toString.foreach(c\
    \ => sum += c.toString.toInt)\n        return sum.toLong", "        val m = lst.max\n\
    \        var max = Long.MinValue\n        if (m < 2) return 0\n        var i =\
    \ 2\n        while (i <= m) {\n            if (lst.contains(i)) {\n          \
    \      var j = 2\n                var isPrime = true\n                while (j\
    \ < i) {\n                    if (i % j == 0) {\n                        isPrime\
    \ = false\n                        j = i\n                    }\n            \
    \        j += 1\n                }\n                if (isPrime) {\n         \
    \           val s = i.toString\n                    var sum = 0\n            \
    \        for (d <- s) sum += d.asDigit\n                    if (sum > max) max\
    \ = sum\n                }\n            }\n            i += 1\n        }\n   \
    \     max", "\tval l = lst.filter(x => x % 2 != 0).toArray.sorted.reverse\n\t\
    val sqrt = sqrt(l(0)).toInt\n\tvar prime = List[Long]()\n\tfor (i <- 3 to sqrt\
    \ by 2) {\n\t    if (l(0) % i == 0) prime = i :: prime\n\t}\n\tprime.reverse.map(x\
    \ => getSum(x)).max", "        var max : Long = 0l\n        for (i <- lst) {\n\
    \            if (isPrime(i)) {\n                if (i > max) {\n             \
    \       max = i\n                }\n            }\n        }\n        var sum\
    \ : Long = 0l\n        val digits = max.toString.map(_.asDigit)\n        for (j\
    \ <- digits) {\n            sum += j\n        }\n        return sum", "      \
    \  def f(lst : List[Long], largest : Long) : Long = {\n            lst match {\n\
    \                case h :: t => if (h > largest && isPrime(h)) f(t, h) else f(t,\
    \ largest)\n                case Nil => largest\n            }\n        }\n  \
    \      def g(x : Long) : Long = {\n            def f(x : Long, sum : Long) : Long\
    \ = {\n                if (x > 0) f(x / 10, sum + x % 10) else sum\n         \
    \   }\n            f(x, 0)\n        }\n        g(f(lst, 0))", "        val x =\
    \ lst.filter(isPrime).max\n        x.toString.map(_.asDigit).sum", "        var\
    \ l = 0l\n        for (i <- lst) {\n            if (Problem.isPrime(i)) {\n  \
    \              l = i\n            }\n        }\n        val s = l.toString\n \
    \       var result = 0l\n        for (j <- s) {\n            result += j.toString.toLong\n\
    \        }\n        return result", '        lst.filter(isPrime(_)).map(x => sumDigits(x)).max',
  "        val primeSums = SortedSet[Long]()\n        for (i <- lst) {\n         \
    \   if (isPrime(i)) {\n                primeSums += digitSum(i)\n            }\n\
    \        }\n        primeSums.last", "        var answer = 0l\n        var primes\
    \ = 0l\n        val xs = lst.map(x => {\n            var a = x.toString\n    \
    \        var c = 0\n            while (a.length > 0) {\n                c += a.last.toString.toInt\n\
    \                a = a.substring(0, a.length - 1)\n            }\n           \
    \ c\n        })\n        for (x <- xs) {\n            var flag = true\n      \
    \      for (i <- 2 to sqrt(x).toInt) {\n                if (x % i == 0) {\n  \
    \                  flag = false\n                    break\n                }\n\
    \            }\n            if (flag && x > primes) {\n                primes\
    \ = x\n            }\n        }\n        answer = primes\n        answer", " \
    \       var primes = ListBuffer[Long]()\n        for (i <- 0 to 1000) {\n    \
    \        primes += i\n        }\n        for (i <- 0 to 1000) {\n            for\
    \ (j <- 2 to 1000) {\n                if (i * j <= 1000) {\n                 \
    \   primes -= i * j\n                }\n            }\n        }\n        var\
    \ result = lst.max\n        while (!primes.contains(result)) {\n            result\
    \ -= 1\n        }\n        var sum = 0\n        while (result > 0) {\n       \
    \     sum += result % 10\n            result /= 10\n        }\n        return\
    \ sum", "        var lst1 = lst\n        val k : Long = 1l\n        var p = lst1.filter((x)\
    \ => x != k)\n        var l : Long = 100l\n        while (p.filter((x) => x >\
    \ 0).size > 0) {\n            val x = p.filter((x) => x > 0).min\n           \
    \ val y = p.filter((x) => x > 0).filter((y) => y % x == 0).max\n            if\
    \ (y <= l) {\n                l = y\n            }\n            p = p.filter((x)\
    \ => x != y)\n        }\n        if (l < 100) {\n            var z = l\n     \
    \       var sum : Long = 0l\n            while (z > 0) {\n                sum\
    \ += z % 10\n                z /= 10\n            }\n            return sum\n\
    \        }\n        return lst1.sum", "        val primes = ArrayBuffer[Long]()\n\
    \        val primesDict = HashMap[Long, Int]()\n        def checkPrime(num : Long)\
    \ : Boolean = {\n            if (num < 2) return false\n            if (num ==\
    \ 2) return true\n            var i = 2l\n            while (i <= sqrt(num)) {\n\
    \                if (num % i == 0) return false\n                i += 1\n    \
    \        }\n            return true\n        }\n        var maxPrime = -1l\n \
    \       def recurse(lst : List[Long]) : Long = {\n            if (lst.isEmpty)\
    \ return 0\n            if (lst.head == 0) return recurse(lst.tail)\n        \
    \    var num = lst.head\n            var digits = 0\n            while (num >\
    \ 0) {\n                digits += 1\n                num /= 10\n            }\n\
    \            for (size <- digits to 1 by -1) {\n                num = lst.head\n\
    \                for (offset <- 0 to digits - size) {\n                    val\
    \ prime = num % scala.math.pow(10, size).toLong\n                    if (checkPrime(prime))\
    \ {\n                        if (prime > maxPrime) maxPrime = prime\n        \
    \                if (primesDict.contains(prime)) primesDict(prime) += 1\n    \
    \                    else primesDict(prime) = 1\n                    }\n     \
    \               num /= 10\n                }\n            }\n            return\
    \ recurse(lst.tail)\n        }\n        recurse(lst)\n        var sum = 0l\n \
    \       for (x <- primesDict.keys) if (primesDict(x) >= lst.length / 2) sum +=\
    \ x\n        return sum", "        val s : Set[Long] = new HashSet[Long]\n   \
    \     val m : Map[Long, Long] = new HashMap[Long, Long]\n        val pr : HashSet[Long]\
    \ = new HashSet[Long]\n        def isPrime(n : Long) : Boolean = {\n         \
    \   var flag : Boolean = true\n            for (i <- 2l.toLong to sqrt(n).toLong)\
    \ {\n                if (n % i == 0) {\n                    flag = false\n   \
    \                 break\n                }\n            }\n            flag\n\
    \        }\n        for (i <- lst) {\n            if (s.contains(i)) {\n     \
    \           m(i) = m(i) + 1\n            } else {\n                s.add(i)\n\
    \                m(i) = 1\n            }\n        }\n        m.foreach(e => {\n\
    \            if (isPrime(e._1)) {\n                pr.add(e._1)\n            }\n\
    \        })\n        var max : Long = 0\n        pr.foreach(e => {\n         \
    \   if (e > max) {\n                max = e\n            }\n        })\n     \
    \   var result : Long = 0\n        while (max > 0) {\n            result = result\
    \ + max % 10\n            max = max / 10\n        }\n        result", "      \
    \  def isPrime(n : Long) : Boolean = {\n            var i = 2l.toLong\n      \
    \      if (n == 2l.toLong) return true\n            if (n == 1l.toLong) return\
    \ false\n            while (i <= sqrt(n)) {\n                if (n % i == 0l.toLong)\
    \ return false\n                i += 1l.toLong\n            }\n            return\
    \ true\n        }\n        var primeSum = 0l.toLong\n        var largestPrime\
    \ = 0l.toLong\n        for (i <- lst) {\n            if (isPrime(i)) {\n     \
    \           if (i > largestPrime) largestPrime = i\n            }\n        }\n\
    \        while (largestPrime > 0l.toLong) {\n            primeSum += largestPrime\
    \ % 10l.toLong\n            largestPrime /= 10l.toLong\n        }\n        return\
    \ primeSum", "        // >>> skjkasdkd((List[Long](0l.toLong, 3l.toLong, 2l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong, 3l.toLong,\
    \ 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong)))\n        // (10l)\n\
    \        // >>> skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong,\
    \ 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)))\n\
    \        // (25l)\n        // >>> skjkasdkd((List[Long](1l.toLong, 3l.toLong,\
    \ 1l.toLong, 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong,\
    \ 163l.toLong, 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong,\
    \ 3l.toLong)))\n        // (13l)\n        // >>> skjkasdkd((List[Long](0l.toLong,\
    \ 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong,\
    \ 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))\n    \
    \    // (11l)\n        //", "        var primes : List[Long] = List[Long]()\n\
    \        // Fill in primes\n        for (i <- 2l to (sqrt(lst.max).toLong + 1l))\
    \ {\n            if (primes.filter((p) => i % p == 0).size == 0) {\n         \
    \       primes = primes :+ i\n            }\n        }\n        //println(primes)\n\
    \        //println(lst)\n        //println(lst.max)\n        //println(primes.filter((p)\
    \ => (lst.max % p == 0)))\n        primes.filter((p) => (lst.max % p == 0)).last.toString.toList.map((c)\
    \ => c.toString.toLong).sum", "        // find largest prime in the list and return\
    \ the sum of its digits\n        var max = 0l.toLong\n        for (n <- lst) {\n\
    \            if (isPrime(n) && n > max) {\n                max = n\n         \
    \   }\n        }\n        if (max == 0l.toLong) return 0l.toLong\n        return\
    \ max.toString.split(\"\").foldLeft(0l.toLong)((acc, x) => acc + x.toLong)", " \
    \       def gcd(a : Long, b : Long) : Long = if (b == 0) a else gcd(b, a % b)\n\
    \        def isPrime(n : Long) : Boolean = if (n < 2) false else if (n == 2) true\
    \ else if (n % 2 == 0) false else (3 to floor(sqrt(n)).toInt by 2).forall(x =>\
    \ n % x != 0)\n        def product(lst : List[Long]) : Long = lst.reduceLeft(_\
    \ * _)\n        var primes = List[Long]()\n        var current = product(lst)\n\
    \        var i = 2\n        while (i <= current) {\n            if (current %\
    \ i == 0 && isPrime(i)) {\n                primes = i :: primes\n            \
    \    current /= i\n            }\n            else i += 1\n        }\n       \
    \ var largestPrime = primes.reduceLeft((a, b) => if (a > b) a else b)\n      \
    \  return largestPrime.toString.toList.map(_.asDigit).reduceLeft(_ + _)", "  \
    \      var primes = scala.collection.mutable.MutableList[Long]()\n        for\
    \ (a <- lst) {\n            if (a != 0) {\n                if (a.isValidInt) {\n\
    \                    primes += a\n                }\n            }\n        }\n\
    \        var maxNum = 0l\n        for (p <- primes) {\n            if (isPrime(p))\
    \ {\n                if (p > maxNum) {\n                    maxNum = p\n     \
    \           }\n            }\n        }\n        var sum = 0l\n        for (d\
    \ <- maxNum.toString.toList) {\n            sum += d.toString.toInt\n        }\n\
    \        return sum", "        val p = new Prime(lst.max)\n        var max = 0l\n\
    \        for (i <- lst) {\n            if (p.isPrime(i)) {\n                max\
    \ = i\n            }\n        }\n        return max.toString.split(\"\").map(_.toLong).sum",
  '        lst.foldLeft(0l)((a, b) => max(a, Problem.getLargestPrimeFactor(b)))',
  "        val s = lst.filter((x) => x != 0)\n        val p = (for (e <- s if s.filter((x)\
    \ => e % x == 0).size == 1) yield e).max\n        //val p = s.filter((x) => s.filter((y)\
    \ => x % y == 0).size == 1).max\n        def getSum(n : Long) : Long = {\n   \
    \         var m = n\n            var sum = 0\n            while (m > 0) {\n  \
    \              sum += m % 10\n                m /= 10\n            }\n       \
    \     sum\n        }\n        getSum(p)", "        def jshkfjhkjfs(lst : List[Long])\
    \ : Long = {\n            def fdsfkjsdjh(x : Long) : Long = {\n              \
    \  if (x < 2) return 0\n                val s = scala.collection.mutable.Set[Long]()\n\
    \                for (i <- 2 to sqrt(x).toInt) {\n                    if (x %\
    \ i == 0) {\n                        s += i.toLong\n                        s\
    \ += (x / i).toLong\n                    }\n                }\n              \
    \  if (s.isEmpty) return x\n                return 0\n            }\n        \
    \    lst.foldLeft(0l)((a, i) => max(a, fdsfkjsdjh(i)))\n        }\n        val\
    \ m = jshkfjhkjfs(lst)\n        if (m == 0) return 0\n        def jskdfjskjd(x\
    \ : Long) : Long = {\n            if (x < 10) return x\n            return (x\
    \ % 10) + jskdfjskjd(x / 10)\n        }\n        return jskdfjskjd(m)", "    \
    \    var z = 0l\n        var mx = 0l\n        for (i <- lst) {\n            if\
    \ (i.isProbablePrime(1000)) {\n                if (i > mx) {\n               \
    \     mx = i\n                }\n            }\n        }\n        while (mx >\
    \ 0) {\n            z += mx % 10\n            mx /= 10\n        }\n        return\
    \ z", "        def isPrime(x : Long) : Boolean = {\n            def isPrimeHelper(x\
    \ : Long, i : Long) : Boolean = {\n                if (i > sqrt(x)) true\n   \
    \             else if (x % i == 0) false\n                else isPrimeHelper(x,\
    \ i + 1)\n            }\n            isPrimeHelper(x, 2)\n        }\n        def\
    \ primeDigitSum(x : Long) : Long = {\n            if (x == 0) 0\n            else\
    \ primeDigitSum(x / 10) + x % 10\n        }\n        def pds(x : Long) : Long\
    \ = primeDigitSum(x)\n        var currentLargestPrime = 0l\n        for (x <-\
    \ lst) {\n            if (isPrime(x) && x > currentLargestPrime) currentLargestPrime\
    \ = x\n        }\n        pds(currentLargestPrime)", "        var prime = lst.map(p\
    \ => primesieve(p)).max\n        prime", "        val  k = lst.filter(x => isPrime(x)\
    \ && x != 1l).max\n        k.toString.map(x => x.asDigit).sum"]
stop_tokens:
- "\n    }\n"
