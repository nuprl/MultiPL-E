name: HumanEval_111_histogram
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a string representing a space separated lowercase letters, return\
  \ a map\n    // of the letter with the most repetition and containing the corresponding\
  \ count.\n    // If several letters have the same occurrence, return all of them.\n\
  \    // Example:\n    // >>> histogram((\"a b c\"))\n    // (Map[String,Long](\"\
  a\" -> 1l, \"b\" -> 1l, \"c\" -> 1l))\n    // >>> histogram((\"a b b a\"))\n   \
  \ // (Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))\n    // >>> histogram((\"a b c\
  \ a b\"))\n    // (Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))\n    // >>> histogram((\"\
  b b b b a\"))\n    // (Map[String,Long](\"b\" -> 4l))\n    // >>> histogram((\"\"\
  ))\n    // (Map[String,Long]())\n    def histogram(test : String) : Map[String,Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(histogram((\"a b\
  \ b a\")).equals((Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))));\n    assert(histogram((\"\
  a b c a b\")).equals((Map[String,Long](\"a\" -> 2l, \"b\" -> 2l))));\n    assert(histogram((\"\
  a b c d g\")).equals((Map[String,Long](\"a\" -> 1l, \"b\" -> 1l, \"c\" -> 1l, \"\
  d\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"r t g\")).equals((Map[String,Long](\"\
  r\" -> 1l, \"t\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"b b b b a\")).equals((Map[String,Long](\"\
  b\" -> 4l))));\n    assert(histogram((\"r t g\")).equals((Map[String,Long](\"r\"\
  \ -> 1l, \"t\" -> 1l, \"g\" -> 1l))));\n    assert(histogram((\"\")).equals((Map[String,Long]())));\n\
  \    assert(histogram((\"a\")).equals((Map[String,Long](\"a\" -> 1l))));\n    }\n\
  \n}\n"
completions: ["        val list = test.split(\" \").toList\n        var map = new\
    \ HashMap[String,Long]\n        val occurences = collection.mutable.Map[String,Long]()\n\
    \        for (c <- list) {\n            val num = occurences.getOrElse(c, 0l)\n\
    \            occurences.put(c, num + 1)\n        }\n        for ((k,v) <- occurences)\
    \ {\n            if (map.contains(k)) {\n                map.put(k,max(map(k),v))\n\
    \            } else {\n                map.put(k,v)\n            }\n        }\n\
    \        map", "        // your code here\n        Map[String,Long]()", "    \
    \    // Fill in the blank\n        null", "        // *** your code here ***\n\
    \        if (test == \"\") {\n            var re: Map[String, Long] = Map()\n\
    \            return re\n        }\n        var list: List[String] = test.split(\"\
    \ \").toList\n        var dict: Map[String, Long] = Map()\n        for (i <- list)\
    \ {\n            if (dict.contains(i))\n                dict = dict.updated(i,\
    \ dict(i) + 1)\n            else\n                dict = dict + (i -> 1)\n   \
    \     }\n        var max: Long = dict.values.max\n        var re: Map[String,\
    \ Long] = Map()\n        for (i <- dict) {\n            if (i._2 == max)\n   \
    \             re = re + (i._1 -> i._2)\n        }\n        return re", "     \
    \   val list = test.split(\" \").toList\n        val map = Map.empty[String, Long]\n\
    \        var newmap = Map.empty[String, Long]\n        if(list.size == 0)\n  \
    \          return map\n        for(i <- 0 until list.size){\n            newmap\
    \ += list(i) -> (map.getOrElse(list(i), 0l) + 1l)\n        }\n        newmap.filter(p\
    \ => p._2 == newmap.values.max)", "    \tval s = test.split(\" \")\n    \tvar\
    \ m = new HashMap[String,Long]\n    \tif (s.length != 0) {\n    \t\tvar count\
    \ = 1\n    \t\tvar highest = 1\n    \t\tvar prev = s(0)\n    \t\tm += (prev ->\
    \ count)\n    \t\tfor (i <- 1 until s.length) {\n    \t\t\tif (s(i) == prev) {\n\
    \    \t\t\t\tcount += 1\n    \t\t\t\tm(prev) = count\n    \t\t\t\tif (count >\
    \ highest) highest = count\n    \t\t\t} else {\n    \t\t\t\tm += (s(i) -> 1)\n\
    \    \t\t\t\tcount = 1\n    \t\t\t}\n    \t\t\tprev = s(i)\n    \t\t}\n    \t\t\
    m = m.filter(_._2 == highest)\n    \t}\n    \tm", "        val letters = test.split(\"\
    \ \")\n        var histo = Map[String,Long]()\n        for (letter <- letters)\
    \ {\n            if (histo.contains(letter)) {\n                histo(letter)\
    \ += 1\n            } else {\n                histo(letter) = 1\n            }\n\
    \        }\n        return histo", "    \tval char = test.split(\" \").toList\n\
    \    \tval map = scala.collection.mutable.Map[String,Long]()\n    \tfor (i <-\
    \ char) {\n    \t\tif (map.contains(i)) {\n    \t\t\tmap(i) += 1\n    \t\t} else\
    \ {\n    \t\t\tmap += (i -> 1)\n    \t\t}\n    \t}\n    \tval most = map.values.max\n\
    \    \tval result = scala.collection.mutable.Map[String,Long]()\n    \tfor (k\
    \ <- map.keys) {\n    \t\tif (map(k) == most) {\n    \t\t\tresult += (k -> most)\n\
    \    \t\t}\n    \t}\n    \tresult.toMap", "        var ret = Map[String,Long]()\n\
    \        val ia = test.split(\" \")\n        for (i <- ia) {\n            val\
    \ w = ret.getOrElse(i, 0l)\n            ret += (i -> (w + 1l))\n        }\n  \
    \      ret.filter { case (k,v) => v == ret.values.max }", "        var map = Map[String,Long]()\n\
    \        for (x <- test.split(\" \")) {\n            if (map.contains(x)) map(x)\
    \ += 1l\n            else map += (x -> 1l)\n        }\n        var max = map.values.max\n\
    \        map.filter(_._2 == max)", "        val tokens = test.split(\" \")\n \
    \       val m = new scala.collection.mutable.HashMap[String,Long]\n        for\
    \ (t <- tokens) {\n            val c = m.getOrElse(t, 0l)\n            m.put(t,\
    \ c + 1)\n        }\n        m.toMap", '        return test.split(" ").groupBy(n
    => n).mapValues(v => v.length.toLong)', "        // Fill in the implementation\
    \ here\n        return Map()", '        ???', "        // TODO: Insert code here\n\
    \        Map[String,Long]()", "        val l = test.split(\" \").toList\n    \
    \    l.groupBy(identity).mapValues(_.size)", "        var result : Map[String,Long]\
    \ = Map()\n        var letters : Map[String,Long] = Map()\n        for (ch <-\
    \ test) letters = letters.updated(ch.toString, letters.getOrElse(ch.toString,\
    \ 0) + 1)\n        if (letters.size > 0) {\n            val max = letters.values.max\n\
    \            for ((key, value) <- letters) if (value == max) result = result.updated(key,\
    \ value)\n        }\n        result", "        var m = Map[String,Long]()\n  \
    \      test.split(\" \").foreach(i => {\n            if (m.contains(i)) m(i) +=\
    \ 1\n            else m += (i -> 1)\n        })\n        val best = m.values.max\n\
    \        return m.filter(_._2 == best)", "        val dict = new HashMap[String,\
    \ Long]()\n        for (c <- test.split(\" \"))\n            dict.put(c, dict.getOrElse(c,\
    \ 0) + 1)\n        dict.foldLeft(new HashMap[String, Long]()) {\n            case\
    \ (result, (key, count)) => {\n                if (result.getOrElse(count, 0)\
    \ == 0)\n                    result.put(count, 0)\n                result.put(key,\
    \ count)\n                result\n            }\n        }.filter(_._2 == dict.values.max).mapValues(_\
    \ => dict.values.max)", "        var max = 0\n        var map = new HashMap[String,\
    \ Long]\n        for (c <- test.split(\" \")) {\n            if (map.contains(c))\
    \ {\n                var count = map(c)\n                count += 1\n        \
    \        map(c) = count\n                if (count > max) max = count\n      \
    \      } else {\n                map(c) = 1\n                if (max == 0) max\
    \ = 1\n            }\n        }\n        val m = Map[String,Long]()\n        for\
    \ ((k,v) <- map) if (v == max) m(k) = v\n        m", "        // Your code goes\
    \ here.\n        var hist = Map[String,Long]()\n        var lis = test.split(\"\
    \ \")\n        var lis2 = lis.toList\n        for(i <- 0 until lis.length){\n\
    \            var n = lis2.count(x => x == lis(i))\n            hist += (lis(i)\
    \ -> n)\n        }\n        return hist.filter(x => x._2 == hist.values.max)",
  "        var counts = new scala.collection.mutable.HashMap[String,Long]()\n    \
    \    val words = test.split(\" \")\n        for (i <- 0 until words.length) {\n\
    \            if (counts.contains(words(i))) counts(words(i)) += 1\n          \
    \  else counts(words(i)) = 1\n        }\n        var maxCount = counts.values.max\n\
    \        var bestCounts = new scala.collection.mutable.HashMap[String,Long]()\n\
    \        for ((k,v) <- counts) if (v == maxCount) bestCounts(k) = v\n        return\
    \ bestCounts.toMap", "        var map = Map[String,Long]()\n        for (s <-\
    \ test.split(\" \")) {\n            if (map.contains(s)) {\n                map\
    \ += (s -> (map(s) + 1))\n            } else {\n                map += (s -> 1)\n\
    \            }\n        }\n        var max = 0\n        for (c <- map.keys) {\n\
    \            if (map(c) > max) {\n                max = map(c).toInt\n       \
    \     }\n        }\n        val buf = new mutable.HashMap[String,Long]()\n   \
    \     for (c <- map.keys) {\n            if (map(c) == max) {\n              \
    \  buf += (c -> map(c))\n            }\n        }\n        buf.toMap", "     \
    \   if (test.isEmpty) Map()\n        else {\n            val letters = test.split(\"\
    \ \")\n            val map = new HashMap[String,Long]()\n            var max =\
    \ 0l\n            letters.foreach(x => {\n                if (map.contains(x))\
    \ {\n                    map(x) += 1\n                    if (map(x) > max) max\
    \ = map(x)\n                }\n                else {\n                    map\
    \ += (x -> 1l)\n                    if (1l > max) max = 1l\n                }\n\
    \            })\n            map.toMap.filter(_._2 == max)\n        }", "    \
    \    val letters = test.split(\" \")\n        var result = Map[String,Long]()\n\
    \        var max = 0\n        for (letter <- letters) {\n            if (result.contains(letter))\
    \ {\n                result += (letter -> (result(letter) + 1))\n            }\
    \ else {\n                result += (letter -> 1)\n            }\n           \
    \ if (result(letter) > max) {\n                max = result(letter).toInt\n  \
    \          }\n        }\n        for (letter <- result.keys) {\n            if\
    \ (result(letter) < max) {\n                result -= letter\n            }\n\
    \        }\n        return result", '        test.split(" ").groupBy(identity).mapValues(_.length)',
  "        val res : Map[String,Long] = HashMap[String,Long]()\n        val l = test.split(\"\
    \ \")\n        val max = l.map(x => l.count(_ == x)).max\n        for (i <- l)\
    \ {\n            if (l.count(_ == i) == max) res += i -> max\n        }\n    \
    \    res", "        var occurences : Map[String,Long] = Map()\n        var temp\
    \ : Map[String,Long] = Map()\n        var max = 0l\n        for (l <- test.split(\"\
    \ \")) {\n            if (occurences.contains(l)) {\n                occurences(l)\
    \ += 1\n            } else {\n                occurences += (l -> 1)\n       \
    \     }\n            if (occurences(l) > max) {\n                max = occurences(l)\n\
    \            }\n        }\n        occurences.foreach { case (a,b) =>\n      \
    \      if (b == max) {\n                temp += (a -> b)\n            }\n    \
    \    }\n        temp", "        var s : Map[String,Long] = Map[String,Long]()\n\
    \        for (l <- test) {\n            if (s.contains(l.toString)) {\n      \
    \          s(l.toString) += 1\n            } else {\n                s(l.toString)\
    \ = 1\n            }\n        }\n        s", "        if (test.isEmpty) {\n  \
    \          return Map[String,Long]()\n        }\n        var result = test.split(\"\
    \ \").groupBy(x => x).map(x => (x._1, x._2.length))\n        var max = result.maxBy(x\
    \ => x._2)\n        var same = result.filter(x => x._2 == max._2)\n        return\
    \ same", "        val ret = new HashMap[String,Long]\n        for (i <- test.split(\"\
    \ \")) {\n            val n = ret.getOrElse(i, 0l)\n            ret.put(i, n +\
    \ 1)\n        }\n        var max = 0l\n        for (i <- ret.values) {\n     \
    \       if (i > max) max = i\n        }\n        ret.filter(p => p._2 == max)",
  "        if (test.length == 0) Map[String,Long]()\n        else {\n            val\
    \ words = test.split(\" \")\n            val groups = words.groupBy(x => x)\n\
    \            val histo = groups.map(x => (x._1, x._2.length.toLong))\n       \
    \     val maxCount = histo.foldLeft(0l)((a,b) => max(a,b._2))\n            histo.filter(x\
    \ => x._2 == maxCount)\n        }", "        var result = Map[String,Long]()\n\
    \        test.split(\" \").foreach {\n            c =>\n                val t\
    \ = result.getOrElse(c, 0l)\n                result += (c -> (t + 1))\n      \
    \  }\n        val max = result.values.max\n        result.filter(e => e._2 ==\
    \ max)", '        ???', "        def helper(letters : Array[String], count : Map[String,Long])\
    \ : Map[String,Long] = {\n            if (letters.isEmpty) return count\n    \
    \        else {\n                val letter = letters.head\n                if\
    \ (count.contains(letter)) {\n                    val newCount = count(letter)\
    \ + 1\n                    return helper(letters.tail, count + (letter -> newCount))\n\
    \                }\n                else return helper(letters.tail, count + (letter\
    \ -> 1l))\n            }\n        }\n        val count = Map[String,Long]()\n\
    \        if (test.isEmpty) return count\n        else return helper(test.split(\"\
    \ \"), count)", "        var map = Map[String,Long]()\n        var list = test.split(\"\
    \ \")\n        var max = 0\n        for (i <- 0 until list.length) {\n       \
    \     if (map.contains(list(i))) map(list(i)) += 1\n            else map += (list(i)\
    \ -> 1)\n            if (map(list(i)) > max) max = map(list(i)).toInt\n      \
    \  }\n        return map.filter(e => e._2 == max)", '        null', "        var\
    \ histogram = Map[String,Long]()\n        for (letter <- test.split(\" \")) {\n\
    \            if (histogram.contains(letter)) {\n                histogram += (letter\
    \ -> (histogram(letter) + 1))\n            } else {\n                histogram\
    \ += (letter -> 1)\n            }\n        }\n        val maximum = histogram.values.max\n\
    \        var result = Map[String,Long]()\n        for ((letter, count) <- histogram)\
    \ {\n            if (count == maximum) {\n                result += (letter ->\
    \ count)\n            }\n        }\n        return result", "        val letters\
    \ = test.split(\" \")\n        val map = Map[String,Long]()\n        var count\
    \ = 0l\n        letters.foreach(letter => {\n            count = map.getOrElse(letter,\
    \ 0l)\n            map.put(letter, count + 1l)\n        })\n        val max =\
    \ map.maxBy(_._2)._2\n        val letter = map.filter(x => x._2 == max)\n    \
    \    letter", "        val arr = test.split(\" \")\n        var map = Map[String,Long]()\n\
    \        var max = 0l\n        for (i <- 0 until arr.length) {\n            if\
    \ (map.contains(arr(i))) {\n                map += arr(i) -> (map(arr(i)) + 1)\n\
    \            } else {\n                map += arr(i) -> 1\n            }\n   \
    \         if (map(arr(i)) > max) {\n                max = map(arr(i))\n      \
    \      }\n        }\n        val result = Map[String,Long]()\n        for ((key,value)\
    \ <- map) {\n            if (value == max) {\n                result += key ->\
    \ value\n            }\n        }\n        result", "        if (test.length ==\
    \ 0) return Map()\n        val map = Map[String,Long]()\n        test.split(\"\
    \ \").foreach(x => {\n            if (map.contains(x)) {\n                map(x)\
    \ += 1\n            } else {\n                map += (x -> 1)\n            }\n\
    \        })\n        val max = map.maxBy(_._2)._2\n        map.filter(_._2 ==\
    \ max)", "        var histogram = Map[String,Long]()\n        test.split(\" \"\
    ).map(x => {\n            if (histogram.contains(x)) histogram(x) += 1l\n    \
    \        else histogram(x) = 1l\n        })\n        histogram", "        var\
    \ occurences = HashMap[String,Long]()\n        val words = test.split(\" \")\n\
    \        for (word <- words) {\n            if (occurences.contains(word)) {\n\
    \                occurences(word) += 1\n            } else {\n               \
    \ occurences(word) = 1\n            }\n        }\n        var histogram = HashMap[String,Long]()\n\
    \        var max = 0l\n        for ((word, count) <- occurences) {\n         \
    \   if (count > max) {\n                max = count\n                histogram\
    \ = HashMap(word -> count)\n            } else if (count == max) {\n         \
    \       histogram(word) = count\n            }\n        }\n        histogram",
  "        // Convert the string to a sequence of elements.\n        val elements\
    \ = test.split(\" \")\n        // Convert the sequence to a map of (word, count).\n\
    \        val histogram = new mutable.HashMap[String,Long]()\n        for (e <-\
    \ elements) histogram.put(e, histogram.getOrElse(e, 0l) + 1l)\n        // Find\
    \ the maximum count.\n        val max = histogram.values.max\n        // Return\
    \ the keys corresponding to the maximum count.\n        val matchingValues = histogram.filter(_._2\
    \ == max)\n        Map() ++ matchingValues", "        var result = Map[String,Long]()\n\
    \        if (test.isEmpty)\n            return result\n        val counts = test.split(\"\
    \ \").groupBy(identity).mapValues(_.size)\n        val max = counts.values.max\n\
    \        val maxElements = counts.filter(_._2 == max)\n        maxElements.keys.foreach(result\
    \ += _ -> max)\n        return result", "        var hist = scala.collection.mutable.Map[String,\
    \ Long]()\n        var li = test.split(\" \")\n        for (i <- li) {\n     \
    \       if (hist.contains(i)) {\n                hist(i) += 1\n            } else\
    \ {\n                hist(i) = 1\n            }\n        }\n        hist", " \
    \       // YOUR CODE HERE\n        Map()", '        test.split(" ").groupBy(x
    => x).mapValues(x => x.length)', "        val stringArray = test.split(\" \")\n\
    \        val mapString = Map[String,Long]()\n        for (i <- 0 until stringArray.length)\
    \ {\n            if (!mapString.contains(stringArray(i))) {\n                mapString\
    \ += (stringArray(i) -> 1l)\n            } else {\n                mapString +=\
    \ (stringArray(i) -> (mapString(stringArray(i)) + 1l))\n            }\n      \
    \  }\n        return mapString", "        // fill in your code here\n        val\
    \ histogram = new HashMap[String,Long]()\n        test.split(\" \").foreach(c\
    \ => {\n            val count = histogram.getOrElse(c, 0l)\n            histogram.put(c,\
    \ count + 1)\n        })\n        val max = histogram.values.max\n        histogram.filter(m\
    \ => m._2 == max)", "        val hist = new HashMap[String, Long]\n        for\
    \ (s <- test.split(\" \")) {\n            val newCount = hist.getOrElse(s, 0l)\
    \ + 1l\n            hist.put(s, newCount)\n        }\n        hist.filter(kv =>\
    \ kv._2 == hist.values.max)", "        val terms = test.split(\" \")\n       \
    \ var hist = new HashMap[String,Long]\n        for (term <- terms) {\n       \
    \     hist(term) = hist.getOrElse(term, 0l) + 1l\n        }\n        hist.filter(x\
    \ => x._2 == hist.values.max)", '        test.split(" ").foldLeft(Map[String,Long]())((accum,item)
    => accum.updated(item,accum.getOrElse(item,0l) + 1l))', '        test.split("
    ").groupBy(identity).mapValues(_.length)', "      var maxCount = 0l\n      var\
    \ result : Set[String] = Set[String]()\n      val h = new HashMap[String, Long]\n\
    \      test.split(\" \").foreach(x => h(x) = h.getOrElse(x, 0l) + 1l)\n      for\
    \ ((k, v) <- h) {\n        if (v > maxCount) {\n          maxCount = v\n     \
    \     result = Set(k)\n        } else if (v == maxCount) {\n          result +=\
    \ k\n        }\n      }\n      result.map(x => (x, maxCount)).toMap", '        return
    test.split(" ").groupBy(p => p).map(p => (p._1, p._2.length.toLong))', "     \
    \   val map = new HashMap[String,Long]\n        for (c <- test.split(\" \")) {\n\
    \            if (map.contains(c)) {\n                map(c) += 1\n           \
    \ } else {\n                map += (c -> 1)\n            }\n        }\n      \
    \  map", "        var max_count = 0l\n        var letters = new HashMap[String,Long]()\n\
    \        for (word <- test.split(\" \")) {\n            if (letters.contains(word))\
    \ {\n                var count = letters(word) + 1\n                letters +=\
    \ (word -> count)\n                if (count > max_count) {\n                \
    \    max_count = count\n                }\n            } else {\n            \
    \    letters += (word -> 1l)\n            }\n        }\n        var res = new\
    \ HashMap[String,Long]()\n        for ((k,v) <- letters) {\n            if (v\
    \ == max_count) {\n                res += (k -> v)\n            }\n        }\n\
    \        return res", "        if (test.isEmpty) {\n            return Map[String,Long]()\n\
    \        }\n        var result = Map[String,Long]()\n        var test = test.trim.split(\"\
    \ \")\n        for (i <- 0 until test.length) {\n            var current = test(i)\n\
    \            if (result.contains(current)) {\n                result(current)\
    \ += 1\n            } else {\n                result += current -> 1\n       \
    \     }\n        }\n        val max = result.values.max\n        result = result.filter(_._2\
    \ == max)\n        return result", '        test.split(" ").groupBy((word : String)
    => word).map((kv : (String, Array[String])) => (kv._1, kv._2.length.toLong))',
  "        //if(test.contains(\"\"))\n        return Map[String,Long]()", "      //\
    \ Fill in the code here\n      val counter = Map[String,Long]()\n      test.split(\"\
    \ \").foreach(s => {\n        if (counter.contains(s)) counter(s) += 1\n     \
    \   else counter(s) = 1\n      })\n      val maxValue = counter.maxBy(_._2)._2\n\
    \      val maxValue2 = counter.maxBy(_._2)._2\n      val maxKey = counter.maxBy(_._2)._1\n\
    \      val maxKey2 = counter.maxBy(_._2)._1\n      val maxKeyList = ListBuffer[String]()\n\
    \      counter.foreach(e => if (e._2 == maxValue) maxKeyList += e._1)\n      counter.filter(e\
    \ => e._2 == maxValue)", "        // Your code here\n        return Map[String,Long]()",
  '        return Map()', "    \tval tokens = test.split(\" \")\n    \tval counter\
    \ = HashMap[String,Long]()\n    \tfor (t <- tokens) {\n    \t\tif (counter.contains(t))\
    \ counter(t) += 1\n    \t\telse counter(t) = 1\n    \t}\n    \tval max = counter.values.max\n\
    \    \tval keys = for (k <- counter.keys if counter(k) == max) yield k\n    \t\
    return (keys.toList.zip(List.fill(keys.length)(max)).toMap)", '        test.split("
    ").foldLeft(Map[String,Long]())((map, c) => map + (c -> (map.getOrElse(c, 0L)
    + 1)))', "        val letters = test.split(\" \")\n        val map = new HashMap[String,Long]\n\
    \        for (letter <- letters) {\n            map(letter) = map.getOrElse(letter,\
    \ 0l) + 1l\n        }\n        val max = map.values.max\n        map.filter(_._2\
    \ == max)", "        // Fill in the implementation to match the above examples\n\
    \        var map : Map[String,Long] = Map()\n        test.split(\" \").foreach(\
    \ x => {\n          if (map.contains(x)) {\n            map += (x -> (map(x) +\
    \ 1))\n          } else {\n            map += (x -> 1)\n          }\n        })\n\
    \        var max = 1l\n        var maxMap = map.filter(x => x._2 == max)\n   \
    \     map.foreach( x => {\n          if (x._2 > max) {\n            max = x._2\n\
    \            maxMap = Map(x)\n          } else if (x._2 == max) {\n          \
    \  maxMap += x\n          }\n        })\n        maxMap", "        val numbers\
    \ : List[String] = test.split(\" \").toList\n        numbers.groupBy(identity).map(t\
    \ => (t._1, t._2.length.toLong))", '        return ???', "        var m = Map[String,Long]()\n\
    \        if (test.size == 0) return m\n        var t = test.split(\" \")\n   \
    \     for (t1 <- t) {\n            if (m.contains(t1)) m(t1) += 1\n          \
    \  else m += (t1 -> 1)\n        }\n        m", '        test.split(" ").groupBy(w
    => w).map(e => (e._1, e._2.length.toLong))', "        val map = scala.collection.mutable.Map[String,Long]()\n\
    \        for (c <- test.split(\" \")) {\n            if (map.contains(c)) {\n\
    \                map(c) += 1\n            } else {\n                map += c ->\
    \ 1\n            }\n        }\n        val result = map.groupBy(_._2).maxBy(_._1)._2\n\
    \        result.map{case (k,v) => (k,v.toLong)}.toMap", "        var hist : Map[String,Long]\
    \ = Map()\n        for (c <- test.split(\" \")) {\n            if (hist.contains(c))\
    \ {\n                hist += (c -> (hist(c) + 1))\n            } else {\n    \
    \            hist += (c -> 1)\n            }\n        }\n        var max : Long\
    \ = 0\n        var result : Map[String,Long] = Map()\n        for ((k,v) <- hist)\
    \ {\n            if (v > max) {\n                max = v\n                result\
    \ = Map(k -> v)\n            } else if (v == max) {\n                result +=\
    \ (k -> v)\n            }\n        }\n        return result", "        //println(test)\n\
    \        val xs = test.split(\" \")\n        var map = new HashMap[String,Long]()\n\
    \        for (i <- 0 until xs.length) {\n            var y = xs(i)\n         \
    \   if (map.contains(y)) {\n                map(y) += 1\n            } else {\n\
    \                map(y) = 1\n            }\n        }\n        // get the maximum\
    \ value\n        val max = map.values.max\n        val newMap = new HashMap[String,Long]()\n\
    \        for ((k,v) <- map) {\n            if (v == max) newMap(k) = v\n     \
    \   }\n        newMap", "        // Fill in\n        null", '        ???', '        test.split("
    ").groupBy(s => s).map(s => (s._1, s._2.length.toLong))', "        if (test.length()\
    \ == 0) return Map[String,Long]()\n        val list = test.split(\" \").map(l\
    \ => (l, 1l)).groupBy(_._1).map(e => (e._1, e._2.map(_._2).sum))\n        val\
    \ max = list.maxBy(_._2)._2\n        val maxs = list.filter(_._2 == max)\n   \
    \     return maxs", "        val items = test.split(\" \")\n        val hist =\
    \ scala.collection.mutable.Map[String,Long]()\n        for (item <- items) {\n\
    \            if (hist.contains(item)) hist(item) += 1l\n            else hist(item)\
    \ = 1l\n        }\n        val max = (hist.values.toList).sortWith((x,y) => x\
    \ > y)(0)\n        var maxKeys = scala.collection.mutable.Map[String,Long]()\n\
    \        for ((key,value) <- hist) {\n            if (value == max) maxKeys(key)\
    \ = value\n        }\n        maxKeys.toMap", '        // your code here', " \
    \       var histogram = HashMap[String,Long]()\n        for (letter <- test.split(\"\
    \ \")) {\n            if (histogram.contains(letter)) histogram(letter) += 1l\n\
    \            else histogram(letter) = 1l\n        }\n        var result = Map[String,Long]()\n\
    \        for ((letter,count) <- histogram) {\n            if (result.isEmpty)\
    \ result += (letter -> count)\n            else if (result.values.head < count)\
    \ result = Map(letter -> count)\n            else if (result.values.head == count)\
    \ result += (letter -> count)\n        }\n        return result", '        ???',
  "        val hist = HashMap[String, Long]()\n        for (x <- test.split(\" \"\
    )) hist(x) = hist.getOrElse(x, 0l) + 1l\n        var histmax = 0l\n        hist.map(x\
    \ => if (x._2 > histmax) histmax = x._2)\n        hist.filter(x => x._2 == histmax)",
  "        var map : Map[String,Long] = Map()\n        for (c <- test.split(\" \"\
    )) {\n            if (map.contains(c)) {\n                map(c) += 1\n      \
    \      } else {\n                map += (c -> 1)\n            }\n        }\n \
    \       var max = 0\n        for (count <- map.values) {\n            if (count\
    \ > max) max = count\n        }\n        var result : Map[String,Long] = Map()\n\
    \        for ((k,v) <- map) {\n            if (v == max) result += (k -> v)\n\
    \        }\n        return result", "        var m = Map[String,Long]()\n    \
    \    test.split(\" \").foreach(s => {\n            if (!m.contains(s)) m += (s\
    \ -> 1l)\n            else m(s) += 1l\n        })\n        return m", "      \
    \  // solve problem here\n        test.split(\" \").groupBy(x => x).map(x => (x._1,\
    \ x._2.length.toLong))", "        // Split string into array of strings\n    \
    \    val arr = test.split(\" \")\n        // Create an array of hashes where the\
    \ key is a lowercase letter and the value is 0\n        val letterFreq = new Array[HashMap[String,Long]](26)\n\
    \        for (i <- 0 until 26) {\n            letterFreq(i) = new HashMap[String,Long]()\n\
    \            letterFreq(i) += (\"\" + ('a' + i) -> 0l)\n        }\n        //\
    \ Convert each element in array of strings to a lowercase character, then increase\
    \ the corresponding value by 1.\n        for (i <- 0 until arr.length) {\n   \
    \         val letter = arr(i).toLowerCase()\n            val index = letter.charAt(0)\
    \ - 'a'\n            letterFreq(index)(letter) += 1\n        }\n        // Find\
    \ the maximum value, then find all the elements with that maximum value.\n   \
    \     val maxFreq = letterFreq.foldLeft(0l)((a,b) => max(a,b.foldLeft(0l)((c,d)\
    \ => max(c,d._2))))\n        val maxLetters = letterFreq.filter(x => x.foldLeft(0l)((a,b)\
    \ => max(a,b._2)) == maxFreq)\n        maxLetters.foldLeft(new HashMap[String,Long]())((a,b)\
    \ => a ++ b.filter(x => x._2 == maxFreq))", "        val count = Map[String,Long]()\n\
    \        val max = 1l\n        val words = test.split(\" \")\n        for (word\
    \ <- words) {\n            if (count.contains(word)) count(word) += 1l\n     \
    \       else count(word) = 1l\n        }\n        for (word <- count.keys) {\n\
    \            if (count(word) == max) count(word) = 1l\n            else count(word)\
    \ = max\n        }\n        return count", "        var result : Map[String,Long]\
    \ = new HashMap()\n        if (test == \"\") return result\n        var dict :\
    \ Map[String,Long] = new HashMap()\n        var list : List[String] = test.split(\"\
    \ \").toList\n        for (c <- list) {\n            var v : Long = dict.getOrElse(c,\
    \ 0l)\n            dict.put(c, v + 1)\n        }\n        var max : Long = dict.values.toList.max\n\
    \        for ((k,v) <- dict) {\n            if (v == max) {\n                result.put(k,v)\n\
    \            }\n        }\n        return result", '        null', '        test.split("
    ").groupBy(identity).mapValues(_.length)', "        val keymap = Map[String,Int]()\n\
    \        for (i <- test.split(\" \")) {\n            val v = keymap.getOrElse(i,\
    \ 0)\n            keymap += (i -> (v + 1))\n        }\n        val max = keymap.map(_._2).max\n\
    \        keymap.filter(p => p._2 == max).map(p => (p._1, p._2.toLong))", "   \
    \     var m : Map[String,Long] = new HashMap[String,Long]()\n        for (i <-\
    \ test.split(\" \")) {\n            if (m.contains(i)) {\n                m(i)\
    \ = m(i) + 1\n            } else {\n                m(i) = 1\n            }\n\
    \        }\n        m", "        val h: Map[String,Long] = Map()\n        test.split(\"\
    \ \").foreach(e => h(e) = h.getOrElse(e, 0l) + 1l)\n        val max = h.values.max\n\
    \        h.filter(pair => pair._2 == max)", '        test.toLowerCase.split("
    ").groupBy(identity).mapValues(_.length).filter(x => x._2 == test.toLowerCase.split("
    ").groupBy(identity).mapValues(_.length).values.max)', "        var m = Map[String,Long]()\n\
    \        var l = test.split(\" \")\n        if(l.size == 0) return m\n       \
    \ for(i <- 0 until l.size) {\n            if(m.contains(l(i))) m(l(i)) += 1\n\
    \            else m += (l(i) -> 1)\n        }\n        return m", '        test.split("
    ").groupBy(identity).mapValues(_.length.toLong)', '        test.split(" ").toList.groupBy(x
    => x).mapValues(l => l.length.toLong)', "        // Fill in the body of this function\
    \ and remove the exception\n        throw new NotImplementedError", '        return
    test.split(" ").groupBy((e : String) => e).mapValues((e : Array[String]) => e.length.toLong)',
  "        val map = new HashMap[String,Long]()\n        val words = test.split(\"\
    \ \")\n        words.foreach(w => {\n            if(map.contains(w)) {\n     \
    \           map(w) += 1\n            } else {\n                map(w) = 1\n  \
    \          }\n        })\n        val max = map.values.max\n        map.filter(m\
    \ => m._2 == max)", "        // replace the line below with your code\n      \
    \  return Map()", "        var map = Map[String,Long]()\n        test.split(\"\
    \ \").foreach(x => map.put(x, map.getOrElse(x, 0l) + 1l))\n        var max = map.values.max\n\
    \        map.retain((k,v) => v == max)\n        return map", "        val histogram\
    \ : Map[String,Long] = Map()\n        test.split(\" \").foreach(word => {\n  \
    \          histogram.get(word) match {\n                case Some(value) => histogram(word)\
    \ = value + 1\n                case None => histogram(word) = 1\n            }\n\
    \        })\n        histogram", "        var myMap = Map[String,Long]()\n   \
    \     for (s <- test.split(\" \")) {\n            if (myMap.contains(s)) myMap(s)\
    \ += 1l\n            else myMap(s) = 1l\n        }\n        var max_val = -1\n\
    \        for (v <- myMap.values) if (v > max_val) max_val = v.toInt\n        var\
    \ output = Map[String,Long]()\n        for ((k,v) <- myMap) if (v == max_val)\
    \ output(k) = v\n        return output", "      // Fill in the code below\n  \
    \    var result : Map[String,Long] = Map()\n      if (test.length() == 0) {\n\
    \        return result\n      }\n      var words : Array[String] = test.split(\"\
    \ \")\n      var max : Long = 1\n      for (i <- 0 to words.length - 1) {\n  \
    \      if (result.contains(words(i))) {\n          result(words(i)) += 1\n   \
    \       if (result(words(i)) > max) {\n            max = result(words(i))\n  \
    \        }\n        } else {\n          result += (words(i) -> 1)\n        }\n\
    \      }\n      var result2 : Map[String,Long] = Map()\n      for (key <- result.keys)\
    \ {\n        if (result(key) == max) {\n          result2 += (key -> max)\n  \
    \      }\n      }\n      return result2", "        val count = new HashMap[String,Long]()\n\
    \        if (test.isEmpty) return count\n        test.split(\" \").foreach(x =>\
    \ {\n            if (count.contains(x)) count(x) += 1\n            else count(x)\
    \ = 1\n        })\n        var max = Long.MinValue\n        count.foreach(x =>\
    \ max = max.max(x._2))\n        count.filter(x => x._2 == max)", "        if (test.length\
    \ == 0) return Map[String,Long]()\n        val ls = test.split(\" \")\n      \
    \  val s = new HashMap[String,Long]()\n        ls.foreach(a => {\n           \
    \ val count = if (s.contains(a)) s(a) else 0\n            s(a) = count + 1\n \
    \       })\n        val ms = s.toSeq.sortBy(_._2).reverse\n        val h = ms.head._2\n\
    \        val ans = ms.filter(_._2 == h).map(a => (a._1, a._2)).toMap\n       \
    \ ans", "      var map = Map[String,Long]()\n      test.split(\" \").foreach(e\
    \ => {\n        var i = 0\n        if (map.contains(e)) {\n          i = map(e).toInt\n\
    \        }\n        map += (e -> (i + 1))\n      })\n      map", "        val\
    \ splitted = test.split(\" \")\n        splitted.toList.groupBy(identity).mapValues(_.size).filter(x\
    \ => x._2 == splitted.length)", "        var counts = Map[String,Long]()\n   \
    \     for (c <- test.split(\" \"))\n            counts(c) = counts.getOrElse(c,\
    \ 0l) + 1l\n        counts.filter({case (k,v) => v == counts.values.max})", " \
    \       val splitted = test.split(\" \")\n        if (splitted.length > 0) {\n\
    \            val histo = splitted.groupBy(x => x).mapValues(x => x.length)\n \
    \           val maxValue = histo.map(x => x._2).max\n            return histo.filter(_._2\
    \ == maxValue)\n        }\n        return Map[String,Long]()", "        // your\
    \ solution here\n        if (test.length()==0) {\n            return Map[String,Long]()\n\
    \        }\n        var dict = Map[String,Long]()\n        val split = test.split(\"\
    \ \")\n        for (s <- split) {\n            if (dict.contains(s)) {\n     \
    \           dict(s)+=1\n            } else {\n                dict += (s -> 1)\n\
    \            }\n        }\n        dict", "        val words = test.split(\" \"\
    )\n        var counted = Map[String, Long]()\n        words.foreach(w => counted(w)\
    \ = counted.getOrElse(w, 0l) + 1l)\n        return counted", "        val chars\
    \ = test.split(\" \")\n        var sorted = chars.toList.sortBy(x => x)\n    \
    \    var hist = scala.collection.mutable.Map[String, Long]()\n        var curr\
    \ = sorted.head\n        var currCount = 0\n        var max = 0\n        var maxChars\
    \ = scala.collection.mutable.Set[String]()\n        while (sorted.length > 0)\
    \ {\n            val c = sorted.head\n            if (c == curr) {\n         \
    \       currCount += 1\n            } else {\n                hist(curr) = currCount\n\
    \                if (currCount > max) {\n                    max = currCount\n\
    \                    maxChars.clear\n                    maxChars += curr\n  \
    \              } else if (currCount == max) {\n                    maxChars +=\
    \ curr\n                }\n                curr = c\n                currCount\
    \ = 1\n            }\n            sorted = sorted.tail\n        }\n        if\
    \ (currCount > 0) {\n            hist(curr) = currCount\n            if (currCount\
    \ > max) {\n                max = currCount\n                maxChars.clear\n\
    \                maxChars += curr\n            } else if (currCount == max) {\n\
    \                maxChars += curr\n            }\n        }\n        val result\
    \ = maxChars.map(x => (x, max)).toMap\n        result", '        return test.trim.split("
    ").toList.groupBy(x => x).mapValues(x => x.length.toLong)', '        test.toLowerCase.split("
    ").groupBy(identity).mapValues(_.length)', "        var m = Map[String,Long]()\n\
    \        for (char <- test.split(\" \")) {\n            if (m.contains(char))\
    \ m(char) += 1\n            else m += (char -> 1)\n        }\n        var n =\
    \ Map[String,Long]()\n        var max = 0l\n        for ((k,v) <- m) if (v > max)\
    \ max = v\n        for ((k,v) <- m) if (v == max) n += (k -> v)\n        return\
    \ n", "        // Fill in the function body here.\n        return null", "   \
    \     if (test.length == 0) return Map[String,Long]()\n        else {\n      \
    \      val count = test.split(\" \").groupBy(x => x).map(x => (x._1, x._2.length.toLong))\n\
    \            val max = count.values.max\n            count.filter(x => x._2 ==\
    \ max)\n        }", "        var letters = test.split(\" \")\n        var m =\
    \ Map[String, Long]()\n        for (i <- 0 until letters.length) {\n         \
    \   if (m.contains(letters(i))) {\n                m += (letters(i) -> (m(letters(i))\
    \ + 1))\n            } else {\n                m += (letters(i) -> 1)\n      \
    \      }\n        }\n        var max = 0\n        for (i <- m.keys) {\n      \
    \      if (m(i) > max) {\n                max = m(i).toInt\n            }\n  \
    \      }\n        var l = List[String]()\n        for (i <- m.keys) {\n      \
    \      if (m(i) == max) {\n                l = i :: l\n            }\n       \
    \ }\n        var m1 = Map[String, Long]()\n        for (i <- l) {\n          \
    \  m1 += (i -> max)\n        }\n        return m1", "        var ret : Map[String,Long]\
    \ = new HashMap[String,Long]()\n        var c = 0\n        for (c <- test.split(\"\
    \ \")) {\n            if (ret.contains(c)) {\n                ret(c) += 1\n  \
    \          } else {\n                ret(c) = 1\n            }\n        }\n  \
    \      ret", "        // Your code here.\n        return Map[String,Long]()",
  "        var h = HashMap[String, Long]()\n        test.split(\" \").foreach(l =>\
    \ {\n            val c = if (h.contains(l)) h(l) + 1 else 1\n            h +=\
    \ (l -> c)\n        })\n        val max = h.values.toList.sort((a, b) => a > b).head\n\
    \        h.filter(p => p._2 == max)", "        val groups = test.split(\" \").groupBy(n\
    \ => n)\n        val maxFreq = groups.map(n => n._2.length).max\n        val most\
    \ = groups.filter(n => n._2.length == maxFreq)\n        most.map(n => (n._1,n._2.length.toLong))",
  "        val t = test.split(\" \")\n        val l = t.toList\n        val lm = l.groupBy(a\
    \ => a).map(a => (a._1, a._2.length))\n        val ma = lm.toArray\n        val\
    \ maxCount = ma.maxBy(a => a._2)._2\n        val max = ma.filter(a => a._2 ==\
    \ maxCount)\n        val maxM = max.toMap\n        return maxM", "        var\
    \ result : Map[String,Long] = new HashMap[String,Long]()\n        var hist : Map[String,Long]\
    \ = new HashMap[String,Long]()\n        for (k <- test.split(\" \")) {\n     \
    \       if (hist.contains(k)) {\n                hist(k) += 1\n            } else\
    \ {\n                hist(k) = 1\n            }\n        }\n        val max =\
    \ hist.values.max\n        for ((k,v) <- hist) {\n            if (v == max) {\n\
    \                result(k) = v\n            }\n        }\n        return result",
  '        test.split(" ").groupBy(x => x).mapValues(x => x.length.toLong)', '        //
    your code here', '        test.split(" ").map(x => (x, 1)).groupBy(_._1).map(x
    => (x._1, x._2.map(_._2).sum)).filter(_._2 == test.split(" ").groupBy(identity).map(x
    => (x._1, x._2.length)).toList.sortBy(_._2).reverse.head._2)', "        var keyVal\
    \ = new HashMap[String,Long]()\n        test.split(\" \").foreach(key => {\n \
    \           var newVal = keyVal.getOrElse(key, 0l) + 1\n            keyVal(key)\
    \ = newVal\n        })\n        var maxKey = keyVal.maxBy(a => a._2)\n       \
    \ var maxVal = maxKey._2\n        keyVal.filter(a => a._2 == maxVal)", "     \
    \   // Fill in the code for the method here\n        null", "        var m = new\
    \ HashMap[String,Long]\n        test.split(\" \").foreach { l =>\n           \
    \ m.get(l) match {\n                case Some(v) => m.put(l, v + 1)\n        \
    \        case None => m.put(l, 1)\n            }\n        }\n        var result\
    \ = new HashMap[String,Long]\n        var maxOcc = 0\n        m.foreach { case\
    \ (k,v) =>\n            if (v > maxOcc) {\n                maxOcc = v\n      \
    \          result.clear\n                result.put(k,v)\n            } else if\
    \ (v == maxOcc) {\n                result.put(k,v)\n            }\n        }\n\
    \        result", '        test.split(" ").groupBy(x => x).mapValues(x => x.length.toLong)',
  "        val m = test.split(\" \").foldLeft(Map[String,Long]())((m, c) => {\n  \
    \          if (!m.contains(c)) m + (c -> 1l)\n            else m + (c -> (m(c)\
    \ + 1l))\n        })\n        return m.filter(e => e._2 == m.values.max)", '        return
    test.split(" ").groupBy(x => x).mapValues(x => x.length.toLong)', "        val\
    \ empty = Map[String,Long]()\n        val counts = (for (c <- test.split(\" \"\
    )) yield (c,1l)).groupBy(_._1).map(t => (t._1, t._2.map(_._2).sum))\n        val\
    \ maxCount = counts.foldLeft(0l)((acc, t) => max(acc, t._2))\n        counts.filter(t\
    \ => t._2 == maxCount)", "        // Enter code here\n        if (test.length()\
    \ == 0) return Map[String,Long]()\n        val tokens = test.split(\" \")\n  \
    \      val tokenCount = tokens.map(x => (x, 1)).groupBy(_._1).map(x => (x._1,\
    \ x._2.map(_._2).reduce(_ + _)))\n        tokenCount.filter(_._2 == tokenCount.map(_._2).max)",
  '        ???', "        var data = ArrayBuffer[(String, Long)]()\n        for (i\
    \ <- test.split(\" \")) {\n            var found = false\n            for (j <-\
    \ data) {\n                if (j._1 == i) {\n                    data -= j\n \
    \                   data += ((i, j._2 + 1))\n                    found = true\n\
    \                }\n            }\n            if (!found) {\n               \
    \ data += ((i, 1))\n            }\n        }\n        var max = 0\n        for\
    \ (i <- data) {\n            if (i._2 > max) {\n                max = i._2\n \
    \           }\n        }\n        var result = HashMap[String, Long]()\n     \
    \   for (i <- data) {\n            if (i._2 == max) {\n                result\
    \ += i\n            }\n        }\n        return result", "        val l = test.split(\"\
    \ \").toList\n        val dict = new HashMap[String,Long]()\n        var maxC\
    \ = 0\n        l.foreach { s =>\n            val c = dict.getOrElse(s, 0l)\n \
    \           dict.put(s, c + 1)\n            maxC = max(maxC, c.toInt + 1)\n  \
    \      }\n        val result = new HashMap[String,Long]()\n        l.foreach {\
    \ s =>\n            val c = dict.getOrElse(s, 0l)\n            if (c == maxC)\
    \ {\n                result.put(s, c)\n            }\n        }\n        result",
  "        // TODO: implement method\n        return Map()", "        // Write your\
    \ code here\n        ???", "        var res = new HashMap[String,Long]()\n   \
    \     for (c <- test.split(\" \")) {\n            if (res.contains(c)) res(c)\
    \ += 1\n            else res += (c -> 1)\n        }\n        res.filter(x => x._2\
    \ == res.values.max)", "        val words = test.split(\" \").toList\n       \
    \ val wordsCount = for (w <- words) yield words.count(x => x == w)\n        val\
    \ max = wordsCount.max\n        val maxWords = for ((w,c) <- words.zip(wordsCount)\
    \ if c == max) yield w\n        return maxWords.toSet.map(x => (x,max)).toMap",
  '        ???', "        val testA = test.split(\" \")\n        val freq = new HashMap[String,Long]\n\
    \        for (i <- 0 until testA.length) {\n            freq(testA(i)) = freq.getOrElse(testA(i),\
    \ 0) + 1\n        }\n        val maxFreq = freq.values.max\n        freq.filter(x\
    \ => x._2 == maxFreq)", "      // var test = \"a b c\"\n      val pre = test.split(\"\
    \ \")\n      // val pre = \"a b c\".split(\" \")\n      val result = Map[String,Long]()\n\
    \      // var result = Map[String,Long]()\n      var maximum = 1\n      for (i\
    \ <- 0 until pre.length) {\n        if (result.isDefinedAt(pre(i))) {\n      \
    \    result(pre(i)) += 1\n          if (result(pre(i)) > maximum) maximum = result(pre(i)).toInt\n\
    \        }\n        else {\n          result(pre(i)) = 1\n        }\n      }\n\
    \      result.filter(_._2 == maximum)", '        return Map[String,Long]()', " \
    \       if (test.length == 0) Map.empty[String,Long]\n        else test.split(\"\
    \ \").groupBy(e => e).mapValues(e => e.length.toLong)", "        var map = new\
    \ HashMap[String,Long]\n        for (ch <- test) {\n            if (map.contains(ch.toString))\
    \ map(ch.toString) += 1\n            else map += (ch.toString -> 1)\n        }\n\
    \        val max = map.foldLeft(0l)((b,a) => max(b,a._2))\n        map.retain((k,v)\
    \ => v == max)\n        map", '        // Your code here', "        var counts\
    \ = scala.collection.mutable.Map[String,Long]()\n        for (word <- test.split(\"\
    \ \")) {\n            if (counts.contains(word)) {\n                counts(word)\
    \ += 1\n            } else {\n                counts(word) = 1\n            }\n\
    \        }\n        val max = counts.values.max\n        val keys = counts.filter(_._2\
    \ == max).keySet\n        counts.filter(x => keys.contains(x._1)).toMap", "  \
    \      val values = test.split(\" \")\n        val groups = values.groupBy(identity).mapValues(_.size)\n\
    \        val maxVal = values.map(_.toInt).max\n        val maxValKeys = groups.filter(_._2\
    \ == maxVal).keySet\n        groups.filter(x => maxValKeys.contains(x._1))", " \
    \       // Fill in the code here\n        val letter = test.split(\" \")\n   \
    \     val letterMap = Map[String, Long]()\n        for (i <- 0 until letter.length)\
    \ {\n            if (letterMap.contains(letter(i))) {\n                val count\
    \ = letterMap(letter(i))\n                letterMap += (letter(i) -> (count +\
    \ 1))\n            } else {\n                letterMap += (letter(i) -> 1)\n \
    \           }\n        }\n        letterMap", "        // Fill up this function\
    \ body\n        // using pattern matching\n        // using recursion\n      \
    \  return null", "        val histo = new HashMap[String,Long]()\n        for\
    \ (e <- test.split(\" \")) {\n            if (histo.contains(e)) {\n         \
    \       histo(e) += 1\n            } else {\n                histo += e -> 1\n\
    \            }\n        }\n        histo.filter { case (k,v) => v == histo.values.max\
    \ }", "        val words = test.split(\" \")\n        var counts = Map[String,Long]()\n\
    \        for (word <- words) {\n            if (counts.contains(word)) {\n   \
    \             counts(word) += 1\n            } else {\n                counts\
    \ += (word -> 1)\n            }\n        }\n        val maxCount = counts.values.max\n\
    \        var maxCountItems = Map[String,Long]()\n        for ((key, value) <-\
    \ counts) {\n            if (value == maxCount) {\n                maxCountItems\
    \ += (key -> value)\n            }\n        }\n        return maxCountItems",
  '        test.split(" ").groupBy(char => char).mapValues(value => value.length.toLong)',
  "        // your code here\n        Map[String,Long]()", "        // Write your\
    \ code here\n        if (test.isEmpty) return Map[String,Long]()\n        else\
    \ {\n            val words = test.split(\" \")\n            val wordMap = new\
    \ HashMap[String, Long]\n            words.foreach(x => wordMap.put(x, 1 + wordMap.getOrElse(x,\
    \ 0)))\n            val values = wordMap.values.toList\n            val maxValue\
    \ = values.max\n            val result = new HashMap[String, Long]\n         \
    \   for ((key, value) <- wordMap) {\n                if (value == maxValue) result.put(key,\
    \ value)\n            }\n            return result\n        }", "        val splitted\
    \ = test.split(\" \")\n        var m = Map[String,Long]()\n        for (letter\
    \ <- splitted) {\n            if (m.contains(letter)) m(letter) += 1\n       \
    \     else m += (letter -> 1)\n        }\n        return m", '        return test.split("
    ").groupBy(identity).mapValues(_.length).filter(x => x._2 == test.split(" ").groupBy(identity).mapValues(_.length).values.max)',
  "        if (test.isEmpty) return Map[String,Long]()\n        var map = Map[String,Long]()\n\
    \        for (c <- test.split(\" \")) {\n            if (map.contains(c)) map(c)\
    \ += 1\n            else map += c -> 1\n        }\n        var max = 0\n     \
    \   for (c <- map.values) if (c > max) max = c\n        var result = Map[String,Long]()\n\
    \        for ((c,n) <- map) if (n == max) result += c -> n\n        return result",
  '        return Map[String,Long]()', "    \tval l = test.split(\" \").filter(_ !=\
    \ \"\").toList\n    \tl.groupBy(identity).mapValues(_.size)", '        return
    Map[String,Long]()', "        def histogram0(word : String, index : Int, hist\
    \ : Map[String,Long]) : Map[String,Long] = {\n            if (index == word.length)\
    \ {\n                hist\n            } else {\n                histogram0(word,\
    \ index + 1, hist.updated(word(index).toString, hist.getOrElse(word(index).toString,\
    \ 0l) + 1l))\n            }\n        }\n        histogram0(test, 0, Map[String,Long]())",
  "        var letters = new HashMap[String,Long]()\n        for (letter <- test.split(\"\
    \ \")) {\n            var count = letters.getOrElse(letter, 0)\n            letters\
    \ += (letter -> (count + 1))\n        }\n        var maxOccurrence = letters.values.max\n\
    \        return letters.filter(key => key._2 == maxOccurrence)", "        // Determines\
    \ if a string is a valid letter\n        def isLetter(ch : String) : Boolean =\
    \ {\n            return (ch >= \"a\" && ch <= \"z\")\n        }\n        // Splits\
    \ the string into an array of letters\n        def getLetters(str : String) :\
    \ Array[String] = {\n            return str.split(\" \").filter(isLetter(_))\n\
    \        }\n        // Returns a map of counts for each letter\n        def getCounts(letters\
    \ : Array[String]) : Map[String,Long] = {\n            var counts = HashMap[String,Long]()\n\
    \            for (ch <- letters) counts(ch) = 1 + counts.getOrElse(ch, 0)\n  \
    \          return counts\n        }\n        // Returns the count of the most\
    \ frequent letter\n        def getMaxCount(counts : Map[String,Long]) : Long =\
    \ {\n            return counts.foldLeft(0l)(max(_,_._2))\n        }\n        //\
    \ Filters counts to only include letters of the most frequent count\n        def\
    \ getHistogram(counts : Map[String,Long], maxCount : Long) : Map[String,Long]\
    \ = {\n            var filtered = counts.filter(_._2 == maxCount)\n          \
    \  return filtered\n        }\n        // Parses the string into an array of letters\
    \ and a map of counts\n        val letters = getLetters(test)\n        val counts\
    \ = getCounts(letters)\n        // Gets the count of the most frequent letter\
    \ and filters counts accordingly\n        val maxCount = getMaxCount(counts)\n\
    \        val histogram = getHistogram(counts, maxCount)\n        return histogram",
  "        var histogram = HashMap[String,Long]()\n        test.split(\" \").map(letter\
    \ => {\n            var count = histogram.getOrElse(letter, 0)\n            histogram\
    \ += (letter -> (count + 1))\n        })\n        histogram.filter(x => x._2 ==\
    \ histogram.values.max)", "        // YOUR CODE HERE\n        null", "    \tif\
    \ (test.isEmpty) return Map()\n    \tval str = test.split(\" \")\n    \tval count\
    \ = Map[String,Long]()\n    \tvar highest = 0\n    \tfor (i <- 0 until str.length)\
    \ {\n    \t\tif (count.contains(str(i))) {\n    \t\t\tval num = count(str(i))\
    \ + 1\n    \t\t\tcount(str(i)) = num\n    \t\t\tif (num > highest) highest = num\n\
    \    \t\t} else {\n    \t\t\tcount(str(i)) = 1\n    \t\t\tif (1 > highest) highest\
    \ = 1\n    \t\t}\n    \t}\n    \tvar result = Map[String,Long]()\n    \tfor ((k,v)\
    \ <- count) {\n    \t\tif (v == highest) result += (k -> v)\n    \t}\n    \tresult",
  "        val map = test.split(\" \").groupBy(x => x).map(x => (x._1, x._2.length.toLong))\n\
    \        val max = map.maxBy(_._2)._2\n        val keys = map.filter(x => x._2\
    \ == max).keys\n        map.filter(x => keys.contains(x._1))", "        val split\
    \ = test.split(\" \").filter(!_.isEmpty())\n        if (split.length == 0) {\n\
    \            return Map()\n        }\n        val map = HashMap[String,Long]()\n\
    \        for (letter <- split) {\n            if (map.contains(letter)) {\n  \
    \              map(letter) += 1\n            } else {\n                map(letter)\
    \ = 1\n            }\n        }\n        val max = map.values.max\n        map.filter(kv\
    \ => kv._2 == max)", "        var map = scala.collection.mutable.Map[String,Long]()\n\
    \        var arr = test.split(\" \")\n        for (i <- 0 until arr.length) {\n\
    \            if (map.contains(arr(i))) {\n                var x = map(arr(i))\n\
    \                map += (arr(i) -> (x + 1))\n            }\n            else {\n\
    \                map += (arr(i) -> 1)\n            }\n        }\n        map.toMap",
  "        // Implement the solution here\n        return null", "        // Fill\
    \ in the code for the histogram function here.\n        val words = test.split(\"\
    \ \")\n        val res = Map[String,Long]()\n        for (i <- 0 until words.length)\
    \ {\n            if (res.contains(words(i))) {\n                val c = res(words(i))\n\
    \                res.put(words(i), c + 1)\n            } else {\n            \
    \    res.put(words(i), 1)\n            }\n        }\n        res", "        val\
    \ map = scala.collection.mutable.Map[String, Long]()\n        val str = test.split(\"\
    \ \")\n        for (s <- str) {\n            map(s) = map.getOrElse(s, 0) + 1\n\
    \        }\n        map.toMap", "        if (test.length == 0) return Map[String,Long]()\n\
    \        val map = Map[String,Long]()\n        val letters = test.split(\" \"\
    )\n        for (i <- 0 until letters.length) {\n            val letter = letters(i)\n\
    \            if (map.contains(letter)) {\n                map(letter) += 1\n \
    \           } else {\n                map(letter) = 1\n            }\n       \
    \ }\n        val maxValue = map.values.max\n        val newMap = Map[String,Long]()\n\
    \        for ((key, value) <- map) {\n            if (value == maxValue) {\n \
    \               newMap(key) = value\n            }\n        }\n        return\
    \ newMap", "        def counter(map : Map[String,Long], letter : String) : Map[String,Long]\
    \ = {\n            if (map.contains(letter)) map + (letter -> (map(letter) + 1))\n\
    \            else map + (letter -> 1)\n        }\n        val map = test.split(\"\
    \ \").foldLeft(Map[String,Long]())(counter)\n        val max = map.maxBy(_._2)._2\n\
    \        return map.filter(_._2 == max)", '        return Map[String,Long]()',
  "        // Fill up this function body\n        // You have to return a Map[String,Long]\n\
    \        // where the key represents a letter and the Long is the number of occurrences\n\
    \        null", "        // Fill in the code to return the answer\n        return\
    \ null", "        val map = new HashMap[String,Long]()\n        for (c <- test.split(\"\
    \ \")) {\n            if (map.contains(c)) {\n                map(c) += 1\n  \
    \          } else {\n                map(c) = 1\n            }\n        }\n  \
    \      var high = 1l\n        for (c <- map.keys) {\n            if (map(c) >\
    \ high) {\n                high = map(c)\n            }\n        }\n        val\
    \ fin = new HashMap[String,Long]()\n        for (c <- map.keys) {\n          \
    \  if (map(c) == high) {\n                fin(c) = map(c)\n            }\n   \
    \     }\n        fin", "        def createMap(str: String): Map[String, Long]\
    \ = {\n            val map = Map[String, Long]()\n            str.split(\" \"\
    ).foreach(\n                s => {\n                    val oldCount = map.getOrElse(s,\
    \ 0l)\n                    map += (s -> (oldCount + 1))\n                }\n \
    \           )\n            map\n        }\n        val map = createMap(test)\n\
    \        val maxValue = map.values.max\n        map.filter(m => m._2 == maxValue)",
  "        val l = test.split(\" \").groupBy(x => x).map(x => (x._1, x._2.length.toLong))\n\
    \        l.filter(x => x._2 == l.values.max)", "        var histogram = new HashMap[String,Long]()\n\
    \        for (char <- test.split(\" \")) {\n            var value = histogram.getOrElse(char,\
    \ 0)\n            histogram.put(char, value + 1)\n        }\n        var result\
    \ = Map[String,Long]()\n        for ((char,value) <- histogram) {\n          \
    \  if (value > result.values.max) {\n                result = Map(char -> value)\n\
    \            } else if (value == result.values.max) {\n                result\
    \ = result + (char -> value)\n            }\n        }\n        return result",
  '        test.split(" ").foldLeft(Map[String,Long]())((m, x) => m + (x -> (m.getOrElse(x,
    0l) + 1l)))', "        var map = new HashMap[String,Long]()\n        for (char\
    \ <- test.split(\" \")) {\n            if (map.contains(char)) {\n           \
    \     var count = map(char)\n                map += (char -> (count + 1))\n  \
    \          } else {\n                map += (char -> 1)\n            }\n     \
    \   }\n        map.filter(_._2 == map.values.max)", "        val histogram : Map[String,Long]\
    \ = HashMap()\n        test.split(\" \").foreach(element => {\n            histogram.get(element)\
    \ match {\n                case Some(value) => histogram.put(element, value +\
    \ 1)\n                case None => histogram.put(element, 1)\n            }\n\
    \        })\n        val maxValue = histogram.values.max\n        histogram.filter(pair\
    \ => pair._2 == maxValue)", "        val map = new HashMap[String,Long]\n    \
    \    for (letter <- test.split(\" \")) {\n            if (map.contains(letter))\
    \ map(letter) += 1l\n            else map(letter) = 1l\n        }\n        val\
    \ max = map.values.max\n        return map.filter(_._2 == max)", "        var\
    \ letters = test.split(\" \").toList\n        var map = new HashMap[String, Long]\n\
    \        for (letter <- letters) {\n            if (map.contains(letter)) {\n\
    \                map(letter) += 1\n            } else {\n                map(letter)\
    \ = 1\n            }\n        }\n        var maxValue = map.values.max\n     \
    \   var result = new HashMap[String, Long]\n        for ((key, value) <- map)\
    \ {\n            if (value == maxValue) {\n                result(key) = value\n\
    \            }\n        }\n        return result", '      return null;', "   \
    \     val freq = new HashMap[String,Long]\n        test.split(\" \").foreach(freq(_)\
    \ = freq.getOrElse(_, 0l) + 1l)\n        val maxFreq = freq.values.max\n     \
    \   freq.toList.filter({case (k,v) => v == maxFreq}).toMap", "        // Put code\
    \ here\n        null", "        var result = Map[String,Long]()\n        if (test.isEmpty)\n\
    \            return result\n        var mapping = test.split(\" \").groupBy((i)\
    \ => i).mapValues(_.length.toLong)\n        var max = mapping.values.max\n   \
    \     for ((k,v) <- mapping) {\n            if (v == max)\n                result\
    \ += (k -> v)\n        }\n        return result", "        // Write your code\
    \ here\n        Map[String,Long]()", '        test.split(" ").groupBy(x => x).map(x
    => (x._1, x._2.length.toLong)).filter(x => x._2 == test.split(" ").groupBy(x =>
    x).map(x => (x._1, x._2.length.toLong)).values.max)']
stop_tokens:
- "\n    }\n"
