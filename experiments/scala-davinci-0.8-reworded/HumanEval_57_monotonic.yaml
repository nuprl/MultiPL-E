name: HumanEval_57_monotonic
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return true is list elements are monotonically increasing or decreasing.\n\
  \    // >>> monotonic((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 20l.toLong)))\n\
  \    // (true)\n    // >>> monotonic((List[Long](1l.toLong, 20l.toLong, 4l.toLong,\
  \ 10l.toLong)))\n    // (false)\n    // >>> monotonic((List[Long](4l.toLong, 1l.toLong,\
  \ 0l.toLong, -10l.toLong)))\n    // (true)\n    def monotonic(l : List[Long]) :\
  \ Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(monotonic((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 10l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 20l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong,\
  \ 20l.toLong, 4l.toLong, 10l.toLong))) == (false));\n    assert(monotonic((List[Long](4l.toLong,\
  \ 1l.toLong, 0l.toLong, -10l.toLong))) == (true));\n    assert(monotonic((List[Long](4l.toLong,\
  \ 1l.toLong, 1l.toLong, 0l.toLong))) == (true));\n    assert(monotonic((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 5l.toLong, 60l.toLong))) == (false));\n    assert(monotonic((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 60l.toLong))) == (true));\n    assert(monotonic((List[Long](9l.toLong,\
  \ 9l.toLong, 9l.toLong, 9l.toLong))) == (true));\n    }\n\n}\n"
completions: ["        var (isIncreasing, result) = (true, true)\n        val arr\
    \ = l.toArray\n        if (arr.length > 1) {\n            isIncreasing = arr(0)\
    \ < arr(1)\n            for (i <- 1 until arr.length - 1) {\n                if\
    \ (isIncreasing && arr(i) > arr(i + 1)) {\n                    result = false\n\
    \                    return result\n                }\n                if (!isIncreasing\
    \ && arr(i) < arr(i + 1)) {\n                    result = false\n            \
    \        return result\n                }\n            }\n        }\n        result",
  "        val positive = l.sliding(2).filter(_.size == 2).forall(x => x(0) < x(1))\n\
    \        val negative = l.sliding(2).filter(_.size == 2).forall(x => x(0) > x(1))\n\
    \        return positive || negative", "      if (l.length == 0) return true\n\
    \      var is_increasing = true\n      var is_decreasing = true\n      var previous\
    \ = l(0)\n      for (e <- l) {\n        if (e < previous) is_increasing = false\n\
    \        if (e > previous) is_decreasing = false\n        previous = e\n     \
    \ }\n      return is_increasing || is_decreasing", "        var m : Boolean =\
    \ true\n        val sign = if (l(0) < l(1)) 1 else -1\n        for (i <- Range(1,\
    \ l.length)) {\n            if (sign * (l(i - 1) - l(i)) > 0) {\n            \
    \    m = false\n                break\n            }\n        }\n        m", " \
    \       var isIncreasing = true\n        var isDecreasing = true\n        for\
    \ (i <- 1 until l.length) {\n            isIncreasing = isIncreasing && (l(i)\
    \ >= l(i - 1))\n            isDecreasing = isDecreasing && (l(i) <= l(i - 1))\n\
    \        }\n        isIncreasing || isDecreasing", "        val d = l.sliding(2).map(x\
    \ => x(1) - x(0)).toList\n        d.forall(x => x == d(0))", "        if (l.size\
    \ < 2) true\n        else if (l(0) > l(1)) monotonic(l.tail)\n        else if\
    \ (l(0) < l(1)) monotonic(l.tail.map(_ * -1))\n        else false", "        def\
    \ m(p : Long, l : List[Long]) : Boolean = l match {\n            case Nil => true\n\
    \            case x :: xs => if (p < x) m(x, xs) else if (p > x) m(x, xs) else\
    \ false\n        }\n        l match {\n            case Nil => true\n        \
    \    case x :: xs => m(x, xs)\n        }", "        var b : Boolean = true\n \
    \       for (k <- 0 until l.length - 1) {\n            if ((l(k + 1) - l(k)) *\
    \ (l(1) - l(0)) < 0) {\n                b = false\n            }\n        }\n\
    \        return b", "        if (l.length == 1) true\n        else {\n       \
    \     val diff = l.tail.zip(l).map(x => x._1 - x._2)\n            diff.forall(x\
    \ => x == 0) || diff.forall(x => x > 0) || diff.forall(x => x < 0)\n        }",
  "        l match {\n            case Nil => true\n            case List(x) => true\n\
    \            case x :: xs => {\n                val n = xs.head\n            \
    \    // If a != n, then only one of the following can be true:\n             \
    \   //      a < n\n                //      a > n\n                // In either\
    \ case, the monotonic property is satisfied, so the\n                // function\
    \ returns true. Otherwise, one of the following is true:\n                // \
    \     a == n\n                //      a != n && a > n\n                //    \
    \  a != n && a < n\n                // In any of these cases, recursively call\
    \ monotonic with the\n                // rest of the list.\n                if\
    \ (x != n) true\n                else monotonic(xs)\n            }\n        }",
  "        var increasing = true\n        var decreasing = true\n        for (i <-\
    \ 1 until l.length) {\n            if (l(i) > l(i - 1)) decreasing = false\n \
    \           if (l(i) < l(i - 1)) increasing = false\n        }\n        increasing\
    \ || decreasing", "        if (l.size < 2) return true\n        var a = l(0)\n\
    \        var b = l(1)\n        var current = false\n        var positive = false\n\
    \        if (a < b) { positive = true }\n        for (i <- 1 until l.size) {\n\
    \            a = l(i - 1)\n            b = l(i)\n            if (positive) {\n\
    \                if (a > b) {\n                    if (current) { return false\
    \ }\n                    current = true\n                }\n            } else\
    \ {\n                if (a < b) {\n                    if (current) { return false\
    \ }\n                    current = true\n                }\n            }\n  \
    \      }\n        return true", "        var ret = true\n        if (l.size >=\
    \ 2) {\n            val diffs = l.sliding(2).map(p => p(1) - p(0)).toList\n  \
    \          val isIncreasing = diffs.exists(_ > 0)\n            val isDecreasing\
    \ = diffs.exists(_ < 0)\n            ret = isIncreasing && !isDecreasing || !isIncreasing\
    \ && isDecreasing\n        }\n        ret", "        if (l.size <= 1) true\n \
    \       else {\n            var b = true\n            var direction = 0\n    \
    \        for (i <- 1 until l.size) {\n                if (direction == 0) {\n\
    \                    if (l(i - 1) < l(i)) direction = 1\n                    else\
    \ if (l(i - 1) > l(i)) direction = -1\n                }\n                else\
    \ if (direction == 1) {\n                    if (l(i - 1) > l(i)) {\n        \
    \                b = false\n                        direction = 0\n          \
    \          }\n                }\n                else if (direction == -1) {\n\
    \                    if (l(i - 1) < l(i)) {\n                        b = false\n\
    \                        direction = 0\n                    }\n              \
    \  }\n            }\n            b\n        }", "        def helper(d : Int, l\
    \ : List[Long]) : Boolean = {\n            if (l.length == 1) true\n         \
    \   else {\n                val s = l.head.signum * l.tail.head.signum\n     \
    \           if (s == d || s == 0) helper(d, l.tail)\n                else false\n\
    \            }\n        }\n        helper(l.head.signum, l)", "        val list1\
    \ = l.zip(l.tail)\n        val list2 = l.zip(l.tail).map(Function.tupled((n, m)\
    \ => n - m))\n        val result = list2.forall(x => x == 0 || x > 0) || list2.forall(x\
    \ => x == 0 || x < 0)\n        return result", "        val diffs = l.sliding(2).map(x\
    \ => x(1) - x(0)).toList\n        if (diffs.size == 0) true\n        else if (diffs.head\
    \ >= 0) (diffs.filter(x => x < 0).size == 0)\n        else (diffs.filter(x =>\
    \ x > 0).size == 0)", "      var direction = 0;\n      var prevValue = l(0);\n\
    \      for (value <- l) {\n        if (direction == 0) {\n          if (value\
    \ < prevValue) direction = -1;\n          else if (value > prevValue) direction\
    \ = 1;\n        }\n        else if (direction == -1 && value > prevValue) return\
    \ false;\n        else if (direction == 1 && value < prevValue) return false;\n\
    \        prevValue = value;\n      }\n      return true;", "        var ascending\
    \ = true\n        var descending = true\n        for (i <- 0 until l.length -\
    \ 1) {\n            if (l(i) > l(i + 1)) ascending = false\n            if (l(i)\
    \ < l(i + 1)) descending = false\n        }\n        ascending || descending",
  "        if (l.length <= 1) true\n        else {\n            val ds = l.sliding(2).map(i\
    \ => i(1) - i(0)).toList\n            val ds2 = ds.map(Math.abs(_))\n        \
    \    val d = ds(0)\n            ds2.forall(_ == d)\n        }", "        if (l.length\
    \ == 1) return true\n        var diffs = List[Long]()\n        for (i <- 1 until\
    \ l.length) {\n            diffs = diffs :+ (l(i) - l(i - 1))\n        }\n   \
    \     val dir = diffs(0) / abs(diffs(0))\n        for (diff <- diffs) {\n    \
    \        if (diff / abs(diff) != dir) return false\n        }\n        return\
    \ true", "        val direction = new Array[Int](l.length - 1)\n        for (i\
    \ <- 0 until l.length - 1) {\n            direction(i) = (l(i + 1) - l(i)).signum\n\
    \        }\n        val s = Set(direction : _*)\n        s.size <= 1", "     \
    \   var (increasing, decreasing) = (true, true)\n        var p = l.head\n    \
    \    for (x <- l.tail) {\n            if (x < p) increasing = false\n        \
    \    if (x > p) decreasing = false\n            p = x\n        }\n        increasing\
    \ || decreasing", "        var isIncreasing = true\n        var isDecreasing =\
    \ true\n        var i = 0\n        while (i < l.length - 1) {\n            isIncreasing\
    \ = isIncreasing && (l(i) <= l(i + 1))\n            isDecreasing = isDecreasing\
    \ && (l(i) >= l(i + 1))\n            i += 1\n        }\n        isIncreasing ||\
    \ isDecreasing", "        if (l.length == 1) true\n        else if (l.length ==\
    \ 2) true\n        else if (l(0) < l(1)) {\n            var increasing = true\n\
    \            for (i <- 0 until l.length - 1) if (l(i) > l(i + 1)) increasing =\
    \ false\n            increasing\n        }\n        else {\n            var decreasing\
    \ = true\n            for (i <- 0 until l.length - 1) if (l(i) < l(i + 1)) decreasing\
    \ = false\n            decreasing\n        }", "        if (l.length < 2) true\n\
    \        else if (l(0) < l(1)) l.sliding(2).forall(p => p(0) <= p(1))\n      \
    \  else l.sliding(2).forall(p => p(0) >= p(1))", "        if (l.size < 2) return\
    \ true\n        var direc = 0\n        for (i <- 0 until l.size - 1) {\n     \
    \       val diff = l(i + 1) - l(i)\n            if (diff == 0) continue\n    \
    \        if (direc == 0) direc = if (diff > 0) 1 else -1\n            else if\
    \ (direc * diff < 0) return false\n        }\n        return true", "        if\
    \ (l.size == 1) return true\n        if (l.size == 2) return true\n        val\
    \ diff = l(1) - l(0)\n        for (i <- 1 until l.size - 1) {\n            if\
    \ (diff == 0) return false\n            val diff1 = l(i + 1) - l(i)\n        \
    \    if (diff1 == 0) return false\n            if (diff1 * diff < 0) return false\n\
    \        }\n        return true", "        val n = l.length\n        if (n ==\
    \ 1) return true\n        if (n == 2) return (l(0) <= l(1)) || (l(0) >= l(1))\n\
    \        var inc = 0\n        var dec = 0\n        for (i <- 0 until n - 1) {\n\
    \            if (l(i) < l(i + 1)) inc += 1\n            if (l(i) > l(i + 1)) dec\
    \ += 1\n        }\n        return (inc == n - 1) || (dec == n - 1)", "       \
    \ if (l.size == 1) return true\n        var sign = signum(l(1) - l(0))\n     \
    \   for (i <- 1 until l.size) {\n            if (signum(l(i) - l(i - 1)) != sign)\
    \ return false\n        }\n        return true", "        l.size match {\n   \
    \         case 0 => true\n            case 1 => true\n            case _ => {\n\
    \                val p = l.tail\n                ((p.size == 1) || (p.size ==\
    \ 0)) || (p.head > p.tail.head) == (l.head > l.tail.head) && monotonic(p)\n  \
    \          }\n        }", "        var direction = l(1) - l(0)\n        for (i\
    \ <- 2 until l.length) {\n            val curDirection = l(i) - l(i - 1)\n   \
    \         if (curDirection != 0 && curDirection != direction && curDirection !=\
    \ -direction) return false\n            direction = curDirection\n        }\n\
    \        return true", "        if (l.size <= 1) true\n        else {\n      \
    \      val slope = l(1) - l(0)\n            val actualSlope = l.tail.foldLeft(slope)((slope,\
    \ x) => {\n                val currentSlope = x - l(l.indexOf(x) - 1)\n      \
    \          if (slope == 0) currentSlope\n                else if (slope * currentSlope\
    \ < 0) false\n                else slope\n            })\n            actualSlope\
    \ != false\n        }", "        def helper(l : List[Long], flag : Boolean) :\
    \ Boolean = {\n            if (l.size == 1) true\n            else if (flag) {\n\
    \                if (l(0) <= l(1)) helper(l.tail, flag)\n                else\
    \ false\n            }\n            else {\n                if (l(0) >= l(1))\
    \ helper(l.tail, flag)\n                else false\n            }\n        }\n\
    \        if (l.size == 1) true\n        else if (l(0) <= l(1)) helper(l.tail,\
    \ true)\n        else helper(l.tail, false)", "        var increasing = true\n\
    \        var decreasing = true\n        for (i <- 0 until l.length - 1) {\n  \
    \          if (l(i) < l(i + 1)) decreasing = false\n            if (l(i) > l(i\
    \ + 1)) increasing = false\n        }\n        increasing || decreasing", "  \
    \      if (l.length <= 1) return true\n        val d = l(1) - l(0)\n        l.sliding(2).forall(t\
    \ => t(1) - t(0) == d)", "        def reduce(l1 : List[Long], l2 : List[Long])\
    \ : Boolean = {\n            if (l1.isEmpty) true\n            else {\n      \
    \          if (l1.size == 1) true\n                else {\n                  \
    \  if (l1.head > l1.tail.head) {\n                        if (l2.head < l2.tail.head)\
    \ false\n                        else reduce(l1.tail, l2.tail)\n             \
    \       }\n                    else if (l1.head < l1.tail.head) {\n          \
    \              if (l2.head > l2.tail.head) false\n                        else\
    \ reduce(l1.tail, l2.tail)\n                    }\n                    else {\n\
    \                        reduce(l1.tail, l2.tail)\n                    }\n   \
    \             }\n            }\n        }\n        reduce(l, l)", "        if\
    \ (l.size == 1) return true\n        var (i, j) = (0, 1)\n        val c = l(0)\
    \ - l(1)\n        while (j < l.size) {\n            if (c * (l(i) - l(j)) < 0)\
    \ return false\n            i += 1\n            j += 1\n        }\n        return\
    \ true", "        var res = true\n        var f = 0\n        for (i <- 1 until\
    \ l.length) {\n            if (l(i) > l(i - 1)) {\n                if (f == 0)\
    \ f = 1\n                else if (f == -1) {\n                    res = false\n\
    \                    return res\n                }\n            }\n          \
    \  else if (l(i) < l(i - 1)) {\n                if (f == 0) f = -1\n         \
    \       else if (f == 1) {\n                    res = false\n                \
    \    return res\n                }\n            }\n        }\n        res", " \
    \       if (l.size <= 1) true\n        else {\n            val d = l(1) - l(0)\n\
    \            l.sliding(2).forall(p => {\n                val d1 = p(1) - p(0)\n\
    \                d1 == 0 || d1 == d || d1 == -d\n            })\n        }", " \
    \       val it = l.sliding(2)\n        val diffs = (for (pair <- it) yield {\n\
    \            pair(1) - pair(0)\n        }).toList\n        val diffs2 = diffs.take(diffs.length\
    \ - 1)\n        val diffs3 = diffs.drop(1)\n        val diffs4 = diffs2 zip diffs3\n\
    \        for (pair <- diffs4) {\n            if (pair._1 < 0 && pair._2 > 0) return\
    \ false\n            if (pair._1 > 0 && pair._2 < 0) return false\n        }\n\
    \        return true", "      def isIncreasing(l : List[Long]) : Boolean = {\n\
    \        l match {\n          case Nil => true\n          case x :: Nil => true\n\
    \          case x :: y :: zs => {\n            if (x > y) false\n            else\
    \ isIncreasing(y :: zs)\n          }\n        }\n      }\n      def isDecreasing(l\
    \ : List[Long]) : Boolean = {\n        l match {\n          case Nil => true\n\
    \          case x :: Nil => true\n          case x :: y :: zs => {\n         \
    \   if (x < y) false\n            else isDecreasing(y :: zs)\n          }\n  \
    \      }\n      }\n      isIncreasing(l) || isDecreasing(l)", "        if (l.length\
    \ <= 1) true\n        else {\n            val sign = l(1) - l(0)\n           \
    \ if (sign != 0) {\n                val allSameSign = l.forall(e => (e - l(0))\
    \ * sign >= 0)\n                allSameSign\n            }\n            else monotonic(l.slice(1,\
    \ l.length))\n        }", "        var m = 0\n        for (i <- 0 until l.length\
    \ - 1) {\n            val a = l(i)\n            val b = l(i + 1)\n           \
    \ if (b > a) {\n                if (m == -1) return false\n                m =\
    \ 1\n            } else if (b < a) {\n                if (m == 1) return false\n\
    \                m = -1\n            }\n        }\n        true", "        if\
    \ (l.length == 1) true\n        else {\n            val sign = l(1) - l(0)\n \
    \           if (sign == 0) monotonic(l.tail)\n            else l.sliding(2).forall(l\
    \ => {(l(1) - l(0)) * sign >= 0})\n        }", "        val a = l.zip(l.tail)\n\
    \        a.forall(x => x._1 < x._2) || a.forall(x => x._1 > x._2)", "      def\
    \ helper(is_increasing : Boolean, prev : Long, ls : List[Long]) : Boolean = {\n\
    \        if (ls.isEmpty) true\n        else {\n          val cur = ls.head\n \
    \         val valid = if (is_increasing) prev <= cur else prev >= cur\n      \
    \    valid && helper(is_increasing, cur, ls.tail)\n        }\n      }\n      val\
    \ first = l.head\n      val second = l.tail.head\n      val is_increasing = first\
    \ < second\n      helper(is_increasing, first, l.tail)", "        val n = l.length\n\
    \        var direction = None : Option[Boolean]\n        for (i <- 0 until n -\
    \ 1) {\n            val d = l(i) < l(i + 1)\n            if (direction == None)\
    \ direction = Some(d)\n            else if (direction.get != d) return false\n\
    \        }\n        return true", "        if (l.length == 1) return true\n  \
    \      val step = l(1) - l(0)\n        var i = 1\n        while (i < l.length)\
    \ {\n            if (step != (l(i) - l(i - 1))) {\n                return false\n\
    \            }\n            i += 1\n        }\n        return true", "       \
    \ var inc : Boolean = true\n        var dec : Boolean = true\n        for (i <-\
    \ 1 until l.length) {\n            if (l(i) < l(i - 1)) inc = false\n        \
    \    if (l(i) > l(i - 1)) dec = false\n        }\n        inc || dec", "     \
    \   if (l.length <= 1) return true\n        var monotonicInc = true\n        var\
    \ monotonicDec = true\n        var prev = l(0)\n        for (x <- l) {\n     \
    \       if (x < prev) monotonicInc = false\n            if (x > prev) monotonicDec\
    \ = false\n            prev = x\n        }\n        return monotonicInc || monotonicDec",
  "        val d = l.tail.foldLeft((true, 0))((x, y) => if (x._2 == 0) if (x._1 &&\
    \ (y - x._2 > 0)) (true, y) else (false, 0) else if (x._1 && (y - x._2) * (y -\
    \ x._2) <= 0) (true, y) else (false, 0))._1\n        d", "        if (l.size <\
    \ 2) true\n        else {\n            var monotonic = true\n            val list\
    \ = l.sortWith(_ < _)\n            for (i <- 1 until list.size) {\n          \
    \      if (list(i) <= list(i - 1)) {\n                    monotonic = false\n\
    \                    break\n                }\n            }\n            monotonic\n\
    \        }", "      if (l.length == 1) return true\n      val list = l.sortWith((x,\
    \ y) => if (x < y) true else false)\n      list == l || list.reverse == l", " \
    \       val l1 = l.map(_.toDouble)\n        val l2 = l.map(_.toDouble)\n     \
    \   val l3 = l.map(_.toDouble)\n        l1.sliding(2).foreach(x => {if (x(0) >=\
    \ x(1)) return false})\n        l2.sliding(2).foreach(x => {if (x(0) <= x(1))\
    \ return false})\n        return true", "        // Any one element or 0 element\
    \ list is monotonic.\n        if (l.size <= 1)\n            return true\n    \
    \    var i = 0\n        var increasing = true\n        while (i < l.size - 1)\
    \ {\n            if (l(i) < l(i + 1)) {\n                if (!increasing)\n  \
    \                  return false\n            }\n            else if (l(i) > l(i\
    \ + 1)) {\n                if (increasing)\n                    increasing = false\n\
    \            }\n            i += 1\n        }\n        return true", "       \
    \ val d = l.sliding(2).map(x => x(1) - x(0)).toList\n        d.filter(_ < 0).size\
    \ == 0 || d.filter(_ > 0).size == 0", "        if (l.length < 2) return true\n\
    \        val order = l(1) - l(0)\n        if (order == 0) {\n            return\
    \ monotonic(l.tail)\n        }\n        return l.sliding(2).map(x => (x(1) - x(0)).signum\
    \ == order.signum).reduce(_ && _)", "        l.sliding(2).forall(pair => if (pair.length\
    \ == 2) {\n            val greater = pair(0) < pair(1)\n            if (greater)\
    \ {\n                l.drop(1).sliding(2).forall(pair => if (pair.length == 2)\
    \ pair(0) < pair(1) else true)\n            } else {\n                l.drop(1).sliding(2).forall(pair\
    \ => if (pair.length == 2) pair(0) > pair(1) else true)\n            }\n     \
    \   } else true)", "        if (l.length == 1) return true\n        var ret =\
    \ true\n        var prev = l(0)\n        for (next <- l.slice(1, l.length)) {\n\
    \            ret = ret && prev != next\n            prev = next\n        }\n \
    \       return ret", '        (l, l.tail).zipped.forall(_ <= _) || (l, l.tail).zipped.forall(_
    >= _)', "        var result = true\n        for (i <- 0 until l.length - 1)\n\
    \            if (l(i) <= l(i + 1)) {\n                result = false\n       \
    \         return result\n            }\n        return result", "        def monotonicHelper(i\
    \ : Int, inc : Boolean) : Boolean = {\n            if (i == l.length - 1) true\n\
    \            else if (inc) {\n                if (l(i) < l(i + 1)) monotonicHelper(i\
    \ + 1, true)\n                else false\n            }\n            else {\n\
    \                if (l(i) > l(i + 1)) monotonicHelper(i + 1, false)\n        \
    \        else false\n            }\n        }\n        if (l.length <= 1) true\n\
    \        else {\n            if (l(0) > l(1)) monotonicHelper(1, false)\n    \
    \        else if (l(0) < l(1)) monotonicHelper(1, true)\n            else monotonicHelper(1,\
    \ true)\n        }", "        if (l.length <= 1)\n            return true\n  \
    \      var incr = 0\n        var decr = 0\n        for (i <- 1 until l.length)\
    \ {\n            if (l(i) > l(i - 1)) {\n                incr += 1\n         \
    \   } else if (l(i) < l(i - 1)) {\n                decr += 1\n            }\n\
    \        }\n        if (incr == 0 || decr == 0)\n            return true\n   \
    \     return false", "        if (l.size < 2) return true\n        var increasing\
    \ = true\n        var decreasing = true\n        for (i <- 1 until l.size) {\n\
    \            if (l(i) > l(i - 1)) decreasing = false\n            if (l(i) < l(i\
    \ - 1)) increasing = false\n        }\n        return increasing || decreasing",
  "        var increasing = true\n        var decreasing = true\n        for (i <-\
    \ 1 until l.length) {\n            if (l(i) < l(i - 1)) increasing = false\n \
    \           if (l(i) > l(i - 1)) decreasing = false\n        }\n        increasing\
    \ || decreasing", "        var increasing = false\n        var decreasing = false\n\
    \        for (i <- 1 until l.length) {\n            if (l(i) > l(i - 1)) {\n \
    \               increasing = true\n            } else if (l(i) < l(i - 1)) {\n\
    \                decreasing = true\n            }\n            if (increasing\
    \ && decreasing) return false\n        }\n        return true", "        val length\
    \ = l.length\n        var sign = 0\n        for (i <- 0 until length - 1) {\n\
    \            if (sign == 0) {\n                if (l(i) < l(i + 1)) sign = 1\n\
    \                else if (l(i) > l(i + 1)) sign = -1\n            }\n        \
    \    else if (sign == 1) {\n                if (l(i) > l(i + 1)) return false\n\
    \            }\n            else if (sign == -1) {\n                if (l(i) <\
    \ l(i + 1)) return false\n            }\n        }\n        true", "        if\
    \ (l.size < 2) {\n            true\n        } else {\n            val first =\
    \ l.head\n            val rest = l.tail\n            val (inc, dec) = rest.partition(x\
    \ => x > first)\n            inc.size > 0 && dec.size > 0 && monotonic(inc) &&\
    \ monotonic(dec)\n        }", "        if (l.length <= 1) return true\n      \
    \  else {\n            val n = l.length\n            var i = 1\n            while\
    \ (i < n && l(i - 1) == l(i)) i += 1\n            if (i == n) return true\n  \
    \          val c = l(i - 1) < l(i)\n            i += 1\n            while (i <\
    \ n) {\n                if (c != (l(i - 1) < l(i))) return false\n           \
    \     i += 1\n            }\n            return true\n        }", "        if\
    \ (l.length <= 1)\n            return true\n        val (s, t) = (l.head < l.tail.head,\
    \ l.head > l.tail.head)\n        if (!s && !t)\n            return false\n   \
    \     val z = (t, l.tail.zip(l.tail.tail).forall(x => (x._1 > x._2)))\n      \
    \  (s, z) match {\n            case (true, (true, _)) => true\n            case\
    \ (true, (false, b)) => b\n            case (false, (true, _)) => true\n     \
    \       case (false, (false, b)) => b\n        }", "        var (prev, b) = (l(0),\
    \ true)\n        for (i <- 1 until l.length) {\n            if (abs(l(i) - prev)\
    \ != 1) b = false\n            prev = l(i)\n        }\n        b", "        val\
    \ sl = l.sortWith((x, y) => x <= y)\n        return sl == l || sl.reverse == l",
  "        val (increasing, decreasing) = l.foldLeft((true, true))((x, y) => (x._1\
    \ && y >= l.head, x._2 && y <= l.head))\n        increasing || decreasing", " \
    \       val list = l.toArray\n        def f(i : Int) : Boolean = {\n         \
    \   if (i == list.length - 1) return true\n            if (list(i) < list(i +\
    \ 1)) {\n                if (f(i + 1)) return true\n                else return\
    \ false\n            }\n            else if (list(i) > list(i + 1)) {\n      \
    \          if (f(i + 1)) return true\n                else return false\n    \
    \        }\n            else return false\n        }\n        f(0)", "       \
    \ l.foldLeft(0)((acc, i) => {\n            if (acc == 0)\n                i.signum\n\
    \            else if (acc == i.signum)\n                acc\n            else\n\
    \                -1\n        }) != -1", "        var a = l.head\n        var increasing\
    \ = true\n        var decreasing = true\n        for (b <- l.tail) {\n       \
    \     if (b < a) increasing = false\n            if (b > a) decreasing = false\n\
    \            a = b\n        }\n        increasing || decreasing", "      var i\
    \ = 0\n      while (i < l.length - 1) {\n        val diff = l(i) - l(i + 1)\n\
    \        if (diff != 0 && diff != abs(diff)) return false\n        i += 1\n  \
    \    }\n      true", "        val n = l.length\n        if (n <= 1) true\n   \
    \     else {\n            var increasing = true\n            var decreasing =\
    \ true\n            var c = 0\n            while (c < n - 1) {\n             \
    \   if (l(c) > l(c + 1)) increasing = false\n                if (l(c) < l(c +\
    \ 1)) decreasing = false\n                c += 1\n            }\n            increasing\
    \ || decreasing\n        }", "        var mono = true\n        if (l.size > 1)\
    \ {\n            var direction = l(1) - l(0)\n            for (i <- 2 until l.size)\
    \ {\n                if (direction == 0) {\n                    return false\n\
    \                }\n                if (l(i) - l(i - 1) == 0) {\n            \
    \        continue\n                }\n                if (direction > 0 && l(i)\
    \ - l(i - 1) < 0) {\n                    return false\n                }\n   \
    \             if (direction < 0 && l(i) - l(i - 1) > 0) {\n                  \
    \  return false\n                }\n            }\n        }\n        return mono",
  "      val n = l.length\n      var diff = new Array[Long](n - 1)\n      for (i <-\
    \ 0 until n - 1) {\n        diff(i) = l(i + 1) - l(i)\n      }\n      val allNonNegative\
    \ = diff.forall(x => x >= 0)\n      val allNonPositive = diff.forall(x => x <=\
    \ 0)\n      allNonNegative || allNonPositive", "        val d = l.zip(l.tail).map(p\
    \ => p._1 - p._2)\n        d.forall(_ == 0) || d.forall(_ > 0) || d.forall(_ <\
    \ 0)", "        if (l.size <= 1) true\n        else {\n            val d1 = l(1)\
    \ - l(0)\n            (2 until l.size).map(i => (l(i) - l(i - 1)) * d1 <= 0).reduceLeft(_\
    \ && _)\n        }", "        if (l.length < 2) true\n        else {\n       \
    \     var increasing = l(0) < l(1)\n            for (i <- 1 until l.length - 1)\
    \ if (increasing != (l(i) < l(i + 1))) return false\n            true\n      \
    \  }", "        var diff = (l(1) - l(0)) > 0\n        var i = 2\n        while\
    \ (i < l.length) {\n            if (((l(i) - l(i - 1)) > 0) != diff) return false\n\
    \            i += 1\n        }\n        return true", "        var result = true\n\
    \        var fwd = true\n        var prev = 0l\n        for (x <- l) {\n     \
    \       if (fwd) {\n                if (x < prev) {\n                    fwd =\
    \ false\n                }\n            } else {\n                if (x > prev)\
    \ {\n                    result = false\n                    return result\n \
    \               }\n            }\n            prev = x\n        }\n        return\
    \ result", "        var s : Boolean = true\n        for (i <- 1 until l.length)\
    \ {\n            if (l(i) - l(i - 1) > 0) {\n                if (s == false) {\n\
    \                    return false\n                }\n            } else if (l(i)\
    \ - l(i - 1) < 0) {\n                if (s == true) {\n                    s =\
    \ false\n                }\n            }\n        }\n        return true", " \
    \       // These two calls are equivalent.\n        // (l zip l.tail) forall {case\
    \ (x, y) => x <= y}\n        (l zip l.tail) forall {t => t._1 <= t._2} || (l zip\
    \ l.tail) forall {t => t._1 >= t._2}", "      def isDecreasing(l : List[Long])\
    \ : Boolean = {\n        if (l.size <= 1) {\n          true\n        } else {\n\
    \          if (l.head <= l.tail.head) false else isDecreasing(l.tail)\n      \
    \  }\n      }\n      if (l.size <= 1) {\n        true\n      } else {\n      \
    \  if (l.head <= l.tail.head) isDecreasing(l.tail) else isDecreasing(l.reverse)\n\
    \      }", "        def check(l : List[Long], inc : Boolean) : Boolean = {\n \
    \           if (l.length <= 1)\n                true\n            else {\n   \
    \             val m = l.head\n                val l2 = l.tail\n              \
    \  l2.forall(e => e == m || (inc && e > m) || (!inc && e < m)) && check(l2, inc\
    \ || e > m)\n            }\n        }\n        check(l, false)", "        if (l.length\
    \ == 1) true\n        else if (l.length == 2) {\n            val (x, y) = (l(0),\
    \ l(1))\n            y >= x\n        }\n        else {\n            val (x, y,\
    \ z) = (l(0), l(1), l(2))\n            if (y >= x && y >= z) monotonic(List(y,\
    \ z))\n            else if (y <= x && y <= z) monotonic(List(y, z))\n        \
    \    else false\n        }", "        def monotonic(l : List[Long], decreasing\
    \ : Boolean) : Boolean = l match {\n            case a::b::t => {\n          \
    \      if (decreasing) {\n                    if (a < b) return false\n      \
    \              else monotonic(b::t, decreasing)\n                } else {\n  \
    \                  if (a > b) return false\n                    else monotonic(b::t,\
    \ decreasing)\n                }\n            }\n            case _ => true\n\
    \        }\n        if (l.size < 2) return true\n        val d = l(0) < l(1)\n\
    \        monotonic(l, d)", "        var d = l(1) - l(0)\n        for (i <- 1 until\
    \ l.length) {\n            if (signum(l(i) - l(i - 1)) != signum(d)) return false\n\
    \        }\n        return true", "        if (l.size == 1) return true\n    \
    \    var s = l(0)\n        var i = 1\n        while (i < l.size) {\n         \
    \   if (s * l(i) < 0) return false\n            s = l(i)\n            i += 1\n\
    \        }\n        return true", "        if (l.size == 1) return true\n    \
    \    var incr = true\n        var decr = true\n        for (i <- 1 until l.size)\
    \ {\n            if (l(i) < l(i - 1)) incr = false\n            if (l(i) > l(i\
    \ - 1)) decr = false\n        }\n        return incr || decr", "        val d\
    \ = l.zip(l.tail).map(x => x._1 - x._2)\n        d.length == 0 || d.max == d.min",
  "        l.sliding(2).toList.map(x => x(1) - x(0)).foldLeft(true)((acc, elem) =>\
    \ acc && (elem >= 0)) ||\n        l.sliding(2).toList.map(x => x(1) - x(0)).foldLeft(true)((acc,\
    \ elem) => acc && (elem <= 0))", "        val n = l.length\n        var i = 0\n\
    \        var inc = true\n        var dec = true\n        while (i < n - 1) {\n\
    \            if (l(i) > l(i + 1)) inc = false\n            if (l(i) < l(i + 1))\
    \ dec = false\n            i += 1\n        }\n        return inc || dec", "  \
    \      var monotonic = true\n        for (i <- 0 until l.length - 1) {\n     \
    \       if (l(i) < l(i + 1)) {\n                monotonic = monotonic && true\n\
    \            } else if (l(i) > l(i + 1)) {\n                monotonic = monotonic\
    \ && true\n            } else {\n                monotonic = false\n         \
    \   }\n        }\n        return monotonic", '        return (l.size < 2) || ((l.size
    == 2) && (l(0) == l(1))) || ((l(0) <= l(1)) && monotonic(l.slice(1, l.size)))
    || ((l(0) >= l(1)) && monotonic(l.slice(1, l.size)))', "        var increasing\
    \ = true\n        var decreasing = true\n        for (i <- 0 until l.length -\
    \ 1) {\n            if (l(i) > l(i + 1)) increasing = false\n            if (l(i)\
    \ < l(i + 1)) decreasing = false\n        }\n        return increasing || decreasing",
  "        if (l.size < 2) return true\n        val l2 = l.tail\n        val delta\
    \ = l2.head - l.head\n        val isIncreasing = delta > 0\n        l2.zip(l).forall(e\
    \ => {\n            val delta = e._1 - e._2\n            if (isIncreasing) delta\
    \ >= 0 else delta <= 0\n        })", "        if (l.length < 2) return true\n\
    \        var inc : Boolean = l(0) < l(1)\n        for (i <- 1 until l.length -\
    \ 1) {\n            if (inc) {\n                if (l(i) > l(i + 1)) return false\n\
    \            } else {\n                if (l(i) < l(i + 1)) return false\n   \
    \         }\n        }\n        return true", "        val sl = l.sliding(2)\n\
    \        val first = sl.next.head\n        val test = sl.forall(v => (first <=\
    \ v.head && v.head <= v.last) || (first >= v.head && v.head >= v.last))\n    \
    \    test", "      val zipped = l.zip(l.tail)\n      zipped.forall(x => (x._1\
    \ < x._2) || (x._1 > x._2))", "        val s = l.sliding(2).toList\n        val\
    \ m = (s(0)(0) <= s(0)(1))\n        for (i <- s) {\n            if (m && (i(0)\
    \ > i(1))) return false\n            if (!m && (i(0) < i(1))) return false\n \
    \       }\n        return true", "        if (l.length < 2) {\n            return\
    \ true\n        }\n        val sign = abs(l(1) - l(0)) / (l(1) - l(0))\n     \
    \   for (i <- 1 until l.length - 1) {\n            if (sign != abs(l(i + 1) -\
    \ l(i)) / (l(i + 1) - l(i))) {\n                return false\n            }\n\
    \        }\n        return true", "        var x = 0\n        var y = 0\n    \
    \    var z = 0\n        for (i <- l) {\n            if (x > i) y += 1\n      \
    \      if (x < i) z += 1\n            x = i\n        }\n        if (y > 0 && z\
    \ > 0) return false\n        else return true", "        var increasing = true\n\
    \        var decreasing = true\n        for (i <- 0 until l.length - 1) {\n  \
    \          if (l(i) > l(i + 1)) increasing = false\n            if (l(i) < l(i\
    \ + 1)) decreasing = false\n        }\n        increasing || decreasing", "  \
    \      if (l.size <= 1) true\n        else {\n            val d1 = l(1) - l(0)\n\
    \            l.drop(2).foreach(a => if ((a - l(0)) * d1 < 0) return false)\n \
    \           true\n        }", "        if (l.size <= 1) return true\n        var\
    \ s = l(0)\n        var d = s - l(1)\n        for (i <- 1 until l.size) {\n  \
    \          val n = l(i)\n            if (d > 0) {\n                if (n > s)\
    \ return false\n            } else if (d < 0) {\n                if (n < s) return\
    \ false\n            }\n            s = n\n            d = s - l(i)\n        }\n\
    \        return true", "        val f = l.headOption.getOrElse(true)\n       \
    \ val l = l.lastOption.getOrElse(true)\n        if ((f < l) && ((l - f) == l.length\
    \ - 1)) true\n        else if ((f > l) && ((f - l) == l.length - 1)) true\n  \
    \      else false", "        val n = l.length\n        if (n == 1) {\n       \
    \     return true\n        }\n        val diff = l(1) - l(0)\n        for (i <-\
    \ 2 until n) {\n            if (diff * (l(i) - l(i - 1)) < 0) {\n            \
    \    return false\n            }\n        }\n        return true", "        val\
    \ d : List[Long] = l.drop(1).zip(l).map(t => t._1 - t._2)\n        d.forall(_\
    \ == d(0))", "        val n = l.length\n        var i = 0\n        while (i <\
    \ n - 1) {\n            if (l(i) != l(i + 1)) {\n                if ((l(i) > l(i\
    \ + 1)) && !monotonic(l.slice(i + 1, n))) return false\n                if ((l(i)\
    \ < l(i + 1)) && !monotonic(l.slice(i + 1, n).reverse)) return false\n       \
    \         return true\n            }\n            i += 1\n        }\n        true",
  "        l match {\n            case a::b::c::xs => (a - b) * (b - c) >= 0 && monotonic(b::c::xs)\n\
    \            case a::b::xs => true\n            case _ => true\n        }", " \
    \       if (l.length == 1) true\n        else {\n            var i = 1\n     \
    \       var diff = (l(i) - l(i - 1)) >= 0\n            while (i < l.length) {\n\
    \                if (((l(i) - l(i - 1)) >= 0) != diff) return false\n        \
    \        i += 1\n            }\n            true\n        }", "        var increasing\
    \ = true\n        var decreasing = true\n        for (i <- 1 until l.length) {\n\
    \            if (l(i) > l(i - 1)) decreasing = false\n            if (l(i) < l(i\
    \ - 1)) increasing = false\n        }\n        increasing || decreasing", "  \
    \      var i = 1\n        var increasing = true\n        var decreasing = true\n\
    \        while (i < l.length) {\n            if (l(i) < l(i - 1)) increasing =\
    \ false\n            if (l(i) > l(i - 1)) decreasing = false\n            i +=\
    \ 1\n        }\n        increasing || decreasing", "        val s = l.sort(_ <\
    \ _)\n        val r = l.sort(_ > _)\n        return l == s || l == r", "     \
    \ if (l.length <= 1) return true\n      val s = l.sorted\n      if (s == l) return\
    \ true\n      if (s.reverse == l) return true\n      return false", "        var\
    \ m : Int = 0\n        for (i <- 1 until l.length) {\n            val c = (l(i\
    \ - 1) - l(i)).signum\n            if (c == 0) return false\n            if (m\
    \ == 0) m = c\n            else if (m != c) return false\n        }\n        return\
    \ true", '        return l.reverse.tail.zip(l.reverse).map(x => x._1 - x._2).forall(x
    => x == 0) || l.tail.zip(l).map(x => x._1 - x._2).forall(x => x == 0)', "    \
    \    def m(l : List[Long], dir : Int) : Boolean = l match {\n            case\
    \ Nil => true\n            case x :: Nil => true\n            case x :: y :: rest\
    \ => {\n                if (dir == 0) m(y :: rest, signum(y - x).toInt)\n    \
    \            else if (signum(y - x).toInt == dir) m(y :: rest, dir)\n        \
    \        else false\n            }\n        }\n        m(l, 0)", "      if (l.length\
    \ == 1) true\n      else {\n        val positive = l(0) <= l(1)\n        var cur\
    \ = positive\n        for (i <- 1 until l.length - 1) {\n          if (positive)\
    \ cur = cur && l(i) <= l(i + 1)\n          else cur = cur && l(i) >= l(i + 1)\n\
    \        }\n        cur\n      }", "        var result = true\n        var ll\
    \ = l\n        if (ll.length > 1) {\n            val x0 = ll.head\n          \
    \  ll = ll.tail\n            var x1 = ll.head\n            ll = ll.tail\n    \
    \        if (x0 < x1) {\n                while (!ll.isEmpty && result) {\n   \
    \                 val x2 = ll.head\n                    result = (x1 <= x2)\n\
    \                    x1 = x2\n                    ll = ll.tail\n             \
    \   }\n            } else {\n                while (!ll.isEmpty && result) {\n\
    \                    val x2 = ll.head\n                    result = (x1 >= x2)\n\
    \                    x1 = x2\n                    ll = ll.tail\n             \
    \   }\n            }\n        }\n        result", "        val direction = l.reduceLeft((x,\
    \ y) => abs(x - y))\n        val n = l.length\n        for (i <- 0 until n - 1)\
    \ if (abs(l(i) - l(i + 1)) != direction) return false\n        return true", " \
    \       if (l.length == 1) true\n        else if (l.length == 2) (l(0) <= l(1))\
    \ || (l(0) >= l(1))\n        else {\n            val x1 = l(0)\n            val\
    \ x2 = l(1)\n            val x3 = l(2)\n            if ((x1 - x2) * (x2 - x3)\
    \ < 0) false\n            else monotonic(l.tail)\n        }", "        l match\
    \ {\n            case a :: b :: c :: d => \n                if (a < b && b < c\
    \ && c < d) true\n                else if (a > b && b > c && c > d) true\n   \
    \             else false\n            case _ => true\n        }", "        if\
    \ (l.length <= 1) return true\n        var direction = 0\n        var prev = l(0)\n\
    \        for (i <- 1 until l.length) {\n            if (l(i) > prev) {\n     \
    \           if (direction == -1) return false\n                direction = 1\n\
    \            } else if (l(i) < prev) {\n                if (direction == 1) return\
    \ false\n                direction = -1\n            }\n            prev = l(i)\n\
    \        }\n        return true", "      val ns = l.zipWithIndex.map(x => (x._1,\
    \ x._2, if (x._2 < l.length - 1) l(x._2 + 1) - x._1 else 0))\n      val result\
    \ = ns.map(x => if (x._3 == 0) 0 else if (x._3 > 0) 1 else -1)\n      result.forall(x\
    \ => x == 0 || x == result(0))", "        var order = 0\n        for (i <- 1 until\
    \ l.length) {\n            if (l(i) - l(i - 1) == 0) order = 0\n            else\
    \ if (l(i) - l(i - 1) > 0) {\n                if (order == 0) order = 1\n    \
    \            else if (order == -1) return false\n            }\n            else\
    \ {\n                if (order == 0) order = -1\n                else if (order\
    \ == 1) return false\n            }\n        }\n        return true", "      \
    \  var inc = true\n        var dec = true\n        var max = l(0)\n        var\
    \ min = l(0)\n        for (i <- 1 until l.length) {\n            if (l(i) < max)\
    \ inc = false\n            if (l(i) > min) dec = false\n            max = math.max(max,\
    \ l(i))\n            min = math.min(min, l(i))\n        }\n        return inc\
    \ || dec", "      l match {\n        case Nil => true\n        case a :: Nil =>\
    \ true\n        case a :: b :: rest =>\n          if (b - a > 0) {\n         \
    \   rest.forall(x => x > a)\n          } else {\n            rest.forall(x =>\
    \ x < a)\n          }\n      }", "        val n = l.length\n        var isIncreasing\
    \ = true\n        var isDecreasing = true\n        for (i <- 1 until n) {\n  \
    \          if (l(i) < l(i - 1)) isIncreasing = false\n            if (l(i) > l(i\
    \ - 1)) isDecreasing = false\n        }\n        isIncreasing || isDecreasing",
  "        var r = true\n        for (i <- 0 until l.length - 1) {\n            r\
    \ = r && (l(i) - l(i + 1) == 0 || l(i) - l(i + 1) == l(i) - l(i) * 2)\n      \
    \  }\n        r", "        var incre = true\n        var decre = true\n      \
    \  var prev = l(0)\n        for (item <- l) {\n            if (item < prev) decre\
    \ = false\n            if (item > prev) incre = false\n            prev = item\n\
    \        }\n        return incre || decre", "        val n = l.length\n      \
    \  var up = true\n        var down = true\n        for (i <- 1 until n) {\n  \
    \          if (l(i) < l(i - 1))\n                up = false\n            if (l(i)\
    \ > l(i - 1))\n                down = false\n        }\n        return up || down",
  '        l.sliding(2).forall(p => p(0) == p(1) || p(0) < p(1) || p(0) > p(1))',
  "        val l2 = l.drop(1)\n        val l3 = l.dropRight(1)\n        val d = l.zip(l2).map((e)\
    \ => e._1 - e._2)\n        val d2 = l3.zip(l.dropRight(1)).map((e) => e._1 - e._2)\n\
    \        val v = d.forall((x) => x == 0) || (d.forall((x) => x > 0) && d2.forall((x)\
    \ => x >= 0)) || (d.forall((x) => x < 0) && d2.forall((x) => x <= 0))\n      \
    \  return v", "        if (l.length < 2) {\n            return true\n        }\n\
    \        var monotonic : Boolean = true\n        var ascending : Boolean = true\n\
    \        var descending : Boolean = true\n        for (i <- 1 until l.length)\
    \ {\n            if (l(i) < l(i - 1)) {\n                ascending = false\n \
    \           }\n            if (l(i) > l(i - 1)) {\n                descending\
    \ = false\n            }\n        }\n        monotonic = ascending || descending\n\
    \        return monotonic", "        if (l.size < 2) {\n            true\n   \
    \     } else {\n            val head = l.head\n            val tail = l.tail\n\
    \            tail.foldLeft(true)((b, x) => {\n                if (b == false)\
    \ {\n                    false\n                } else {\n                   \
    \ if (x == head) {\n                        true\n                    } else if\
    \ (x < head) {\n                        tail.foldLeft(true)((y, z) => {\n    \
    \                        if (y == false) {\n                                false\n\
    \                            } else {\n                                z <= x\n\
    \                            }\n                        })\n                 \
    \   } else {\n                        tail.foldLeft(true)((y, z) => {\n      \
    \                      if (y == false) {\n                                false\n\
    \                            } else {\n                                z >= x\n\
    \                            }\n                        })\n                 \
    \   }\n                }\n            })\n        }", "        var (increasing,\
    \ decreasing) = (true, true)\n        for (i <- 1 until l.length) {\n        \
    \    if (l(i) < l(i - 1)) increasing = false\n            if (l(i) > l(i - 1))\
    \ decreasing = false\n        }\n        return increasing || decreasing", " \
    \       if (l.size <= 1) true\n        else {\n            val s = l.size\n  \
    \          for (i <- 0 until s - 1) if (l(i) < l(i + 1)) return false\n      \
    \      for (i <- 0 until s - 1) if (l(i) > l(i + 1)) return false\n          \
    \  true\n        }", "        if (l.length < 2) true\n        else {\n       \
    \     val (m, last) = l.splitAt(l.length - 1)\n            val (increasing, decreasing)\
    \ = m.zip(last).foldLeft((true, true)) {\n                case ((inc, dec), (left,\
    \ right)) =>\n                    if (inc) (left <= right, dec)\n            \
    \        else if (dec) (inc, left >= right)\n                    else (inc, dec)\n\
    \            }\n            increasing || decreasing\n        }", "        var\
    \ increasing = true\n        var decreasing = true\n        if (l.length == 1)\
    \ return true\n        for (i <- (1 until l.length)) {\n            if (l(i) <\
    \ l(i - 1)) increasing = false\n            if (l(i) > l(i - 1)) decreasing =\
    \ false\n        }\n        return increasing || decreasing", "        (l, l.tail).zipped.forall((a,\
    \ b) => a <= b) ||\n        (l, l.tail).zipped.forall((a, b) => a >= b)", "  \
    \      val diffs = (l zip l.tail).map(x => x._2 - x._1)\n        diffs.count(_\
    \ > 0) == 0 || diffs.count(_ < 0) == 0", "        if (l.length <= 1)\n       \
    \     return true\n        var a = l(0)\n        var inc = true\n        var dec\
    \ = true\n        for (i <- 1 until l.length) {\n            if (l(i) < a)\n \
    \               inc = false\n            if (l(i) > a)\n                dec =\
    \ false\n            a = l(i)\n        }\n        return inc || dec", "      \
    \  var m = 0\n        for (i <- 1 until l.length) {\n            if (l(i) - l(i\
    \ - 1) > 0) {\n                if (m == -1) return false\n                m =\
    \ 1\n            } else if (l(i) - l(i - 1) < 0) {\n                if (m == 1)\
    \ return false\n                m = -1\n            }\n        }\n        return\
    \ true", "        var inc = true\n        var dec = true\n        for (i <- 1\
    \ until l.length) {\n            if (l(i) < l(i - 1)) inc = false\n          \
    \  if (l(i) > l(i - 1)) dec = false\n        }\n        inc || dec", "       \
    \ val a = l.sliding(2).filter(x => x.size == 2).map(x => if (x(0) <= x(1)) 1 else\
    \ -1).toList\n        a.forall(x => x == a(0))", "        if (l.length <= 1) true\n\
    \        else {\n            def next(m : Int, l : List[Long]) : Boolean = {\n\
    \                if (l.length <= 1) true\n                else if (m == 0) next(l(0)\
    \ compare l(1), l.tail)\n                else if (m * (l(0) compare l(1)) < 0)\
    \ false\n                else next(m, l.tail)\n            }\n            next(0,\
    \ l)\n        }", "        val s = l.sortWith((a, b) => a < b)\n        val r\
    \ = l.sortWith((a, b) => a > b)\n        l == s || l == r", "        if (l.size\
    \ == 1) {\n            true\n        } else {\n            val d = l(1) - l(0)\n\
    \            l.sliding(2).forall(x => x(1) - x(0) == d)\n        }", "       \
    \ var increasing = true\n        var decreasing = true\n        for (i <- 1 until\
    \ l.length) {\n            if (l(i) < l(i - 1)) increasing = false\n         \
    \   if (l(i) > l(i - 1)) decreasing = false\n        }\n        return increasing\
    \ || decreasing", "        if (l.length == 1) {\n            return true\n   \
    \     }\n        if (l.head <= l.tail.head) {\n            return monotonic(l.tail)\n\
    \        }\n        else {\n            return monotonic(l.reverse)\n        }",
  "        var increasing = true\n        var decreasing = true\n        var x = -1l\n\
    \        for (e <- l) {\n            if (x != -1l) {\n                if (x >\
    \ e) increasing = false\n                if (x < e) decreasing = false\n     \
    \       }\n            x = e\n        }\n        return increasing || decreasing",
  "        if (l.length < 2) true\n        else {\n            var diffs = l.tail.zip(l).map(x\
    \ => x._1 - x._2)\n            diffs.forall(_ == diffs(0))\n        }", "    \
    \    if (l.length < 2) return true\n        var temp = l(0)\n        var sign\
    \ = 0\n        for (i <- l) {\n            if (i < temp) {\n                if\
    \ (sign == 1) return false\n                else sign = -1\n            }\n  \
    \          else if (i > temp) {\n                if (sign == -1) return false\n\
    \                else sign = 1\n            }\n            temp = i\n        }\n\
    \        return true", "        val order = for (i <- 0 until l.length - 1) yield\
    \ l(i) <= l(i + 1)\n        order.forall(x => x) || order.forall(x => !x)", " \
    \       val (isDec, _) = l.zip(l.tail).foldLeft((true, true))((a, b) => {\n  \
    \          (a._1 && b._1 <= b._2, a._2 && b._1 >= b._2)\n        })\n        isDec\
    \ || _", "        if (l.size < 2) return true\n        val s = l.head - l.tail.head\n\
    \        l.sliding(2).forall((r) => (r.head - r.tail.head) * s >= 0)", "     \
    \   var s = Set[Long]()\n        for (x <- l) {\n            if (s.contains(x))\
    \ return false\n            s += x\n        }\n        return true", "       \
    \ if (l.length < 2) return true\n        var increasing = true\n        var decreasing\
    \ = true\n        for (i <- 1 until l.length) {\n            if (l(i) > l(i -\
    \ 1)) decreasing = false\n            if (l(i) < l(i - 1)) increasing = false\n\
    \        }\n        return increasing || decreasing", "        val (a, b) = l.span(_\
    \ == l.head)\n        if (a.size == l.size) true\n        else if (b.size == 0)\
    \ false\n        else {\n            val (c, d) = b.span(_ == b.head)\n      \
    \      if (c.size == b.size) {\n                if (c.head > a.head) d.forall(_\
    \ >= c.head)\n                else d.forall(_ <= c.head)\n            }\n    \
    \        else false\n        }", '        l.zip(l.tail).forall(x => if (x._1 ==
    x._2) true else x._1 < x._2 || x._1 > x._2)', "        val ll = l.zip(l.tail)\n\
    \        ll.forall({ case (a, b) => a == b || a < b || a > b })", "        val\
    \ check = l(0) < l(1)\n        l.zip(l.tail).forall(x => if (check) x._1 < x._2\
    \ else x._1 > x._2)", "        var up = true\n        var down = true\n      \
    \  for (i <- 0 until l.length - 1) {\n            up = up && (l(i) <= l(i + 1))\n\
    \            down = down && (l(i) >= l(i + 1))\n        }\n        up || down",
  "      val n = l.length\n      if (n <= 1) return true\n      var positive = true\n\
    \      var negative = true\n      for (i <- 0 until n - 1) {\n        if (l(i)\
    \ > l(i + 1)) positive = false\n        if (l(i) < l(i + 1)) negative = false\n\
    \      }\n      return positive || negative", "      // Return true if the list\
    \ is monotonically increasing.\n      def f(l : List[Long]) : Boolean = {\n  \
    \      l match {\n          case (x1 :: x2 :: xs) => if (x1 <= x2) f(x2 :: xs)\
    \ else false\n          case _ => true\n        }\n      }\n      // Return true\
    \ if the list is monotonically decreasing.\n      def g(l : List[Long]) : Boolean\
    \ = {\n        l match {\n          case (x1 :: x2 :: xs) => if (x1 >= x2) g(x2\
    \ :: xs) else false\n          case _ => true\n        }\n      }\n      (f(l))\
    \ || (g(l))", "        val dl = (l.drop(1) zip l).map(p => p._1 - p._2)\n    \
    \    if (dl.forall(_ > 0)) true\n        else if (dl.forall(_ < 0)) true\n   \
    \     else false", "        val s = l.sorted\n        (s == l) || (s.reverse ==\
    \ l)", "        val dir = l.slice(1, l.length).zip(l.slice(0, l.length - 1)).map(t\
    \ => t._1 - t._2).filter(t => t != 0).headOption\n        dir match {\n      \
    \      case Some(0) => false\n            case Some(d) => l.slice(1, l.length).zip(l.slice(0,\
    \ l.length - 1)).map(t => t._1 - t._2).filter(t => t != 0).forall(t => t * d >\
    \ 0)\n            case None => true\n        }", "        var result = true\n\
    \        var sign = 0\n        for (i <- 0 until l.length - 1) {\n           \
    \ if (sign == 0) {\n                sign = l(i).toInt - l(i + 1).toInt\n     \
    \       } else {\n                if (sign * (l(i).toInt - l(i + 1).toInt) < 0)\
    \ {\n                    result = false\n                    return result\n \
    \               }\n            }\n        }\n        return result", "       \
    \ if (l.size <= 1) true\n        else if (l.size == 2) abs(l(0) - l(1)) != 1\n\
    \        else if (l(0) < l(1)) l.sliding(2).forall({case List(a, b) => a < b})\n\
    \        else l.sliding(2).forall({case List(a, b) => a > b})", "        val (increasing,\
    \ decreasing) = (for (List(x, y) <- l.sliding(2)\n            if x < y) yield\
    \ true).size > 0 && (for (List(x, y) <- l.sliding(2)\n            if x > y) yield\
    \ true).size > 0\n        increasing || decreasing", "        val sorted = l.sorted\n\
    \        val reversed = l.sorted.reverse\n        return sorted == l || reversed\
    \ == l", "      val n = l.length\n      val d = l.map(x => x - l(0)).toArray\n\
    \      if (d.count(_ == 0) == n) return true // All elements are the same\n  \
    \    val m = (d.map(x => if (x < 0) -1 else 1)).toArray\n      if (m.count(_ ==\
    \ 0) == n) return true // All elements are the same\n      val s = m.mkString(\"\
    \")\n      if (s == \"1\" * n || s == \"-1\" * n) return true\n      false", " \
    \       val len = l.length\n        val delta = l.map(x => l(0) - x)\n       \
    \ val change = delta.map(x => abs(x))\n        val diff = change.map(x => (change(0)\
    \ - x) == 0).count(x => x == true)\n        if (diff == len) true else false",
  "        if (l.size == 1) {\n            return true\n        }\n        var sign\
    \ = l(1) - l(0)\n        for (i <- 1 until l.size) {\n            val d = l(i)\
    \ - l(i - 1)\n            if (d * sign < 0) {\n                return false\n\
    \            }\n        }\n        return true", "        if (l.size == 1) true\n\
    \        else if (l.size == 2) true\n        else if (l(0) < l(1)) l.sliding(2).forall(t\
    \ => t(0) <= t(1))\n        else l.sliding(2).forall(t => t(0) >= t(1))", '      l.map(_.toString).reduceLeft(_
    + _).forall(x => x == l.head.toString.head)', "        if (l.length < 2) true\n\
    \        else {\n            val t = l.sliding(2).toList\n            val (asc,\
    \ desc) = t.foldLeft((true, true)) { case ((asc, desc), List(a, b)) => (asc &&\
    \ a <= b, desc && a >= b) }\n            asc || desc\n        }", "        var\
    \ s = l.head\n        var down = false\n        var up = false\n        for (i\
    \ <- 1 until l.length) {\n            val x = l(i)\n            if (x > s) {\n\
    \                up = true\n            } else if (x < s) {\n                down\
    \ = true\n            }\n            if (up && down) return false\n          \
    \  s = x\n        }\n        return true", "        if (l.length == 1) return\
    \ true\n        val d = (l(1) - l(0)) / abs(l(1) - l(0))\n        for (i <- 0\
    \ until l.length - 1) {\n            if (d != (l(i + 1) - l(i)) / abs(l(i + 1)\
    \ - l(i))) return false\n        }\n        return true", "        if (l.length\
    \ == 1) return true\n        var direction = 0\n        var i = 0\n        while\
    \ (i < l.length - 1) {\n            val d = l(i + 1) - l(i)\n            if (direction\
    \ == 0) {\n                if (d == 0) {\n                    direction = 0\n\
    \                } else if (d > 0) {\n                    direction = 1\n    \
    \            } else {\n                    direction = -1\n                }\n\
    \            } else if (direction == 1) {\n                if (d < 0) return false\n\
    \            } else {\n                if (d > 0) return false\n            }\n\
    \            i += 1\n        }\n        return true", "        if (l.length <=\
    \ 1) return true\n        val diff = (l.drop(1) zip l).map(x => x._1 - x._2)\n\
    \        diff.forall(x => x == 0 || x == diff(0))", "        if (l.size == 1)\
    \ true\n        else {\n            if (l(0) < l(1)) {\n                for (i\
    \ <- 1 until l.size - 1) {\n                    if (l(i) > l(i + 1)) return false\n\
    \                }\n            }\n            else {\n                for (i\
    \ <- 1 until l.size - 1) {\n                    if (l(i) < l(i + 1)) return false\n\
    \                }\n            }\n            true\n        }", "        val\
    \ m = l.size\n        def monotonicR(i : Int, acc : Boolean) : Boolean = {\n \
    \           if (i + 1 >= m) acc\n            else {\n                val a = l(i)\n\
    \                val b = l(i + 1)\n                if (a < b) monotonicR(i + 1,\
    \ true)\n                else if (a > b) monotonicR(i + 1, false)\n          \
    \      else monotonicR(i + 1, acc)\n            }\n        }\n        monotonicR(0,\
    \ true)", "      if (l.size < 2) true\n      else if (l(0) == l(1)) monotonic(l.slice(1,\
    \ l.size))\n      else if (l(0) < l(1)) {\n        if (l.size < 3) true\n    \
    \    else if (l(1) < l(2)) monotonic(l.slice(1, l.size))\n        else false\n\
    \      }\n      else {\n        if (l.size < 3) true\n        else if (l(1) >\
    \ l(2)) monotonic(l.slice(1, l.size))\n        else false\n      }", "       \
    \ if (l.length <= 1) return true\n        val diffs = l.zip(l.tail).map((t) =>\
    \ t._2 - t._1)\n        diffs.distinct.length == 1 || diffs.distinct.length ==\
    \ 2 && diffs.distinct.contains(0)", "        if (l.size <= 1) return true\n  \
    \      var increasing = l(0) < l(1)\n        var i = 1\n        while (i < l.size\
    \ - 1) {\n            val condition = (l(i) < l(i + 1))\n            if (increasing\
    \ != condition) return false\n            i += 1\n        }\n        return true",
  "        val n = l.length\n        var increasing = true\n        var decreasing\
    \ = true\n        for (i <- 0 until n - 1) {\n            if (l(i) > l(i + 1))\
    \ increasing = false\n            if (l(i) < l(i + 1)) decreasing = false\n  \
    \      }\n        increasing || decreasing", "        if (l.length < 2) return\
    \ true\n        var increasing = 0\n        if (l(0) <= l(1)) increasing = 1\n\
    \        else increasing = -1\n        var last = l(0)\n        var i = 1\n  \
    \      while (i < l.length) {\n            if (increasing == 1 && l(i) < last)\
    \ return false\n            if (increasing == -1 && l(i) > last) return false\n\
    \            last = l(i)\n            i += 1\n        }\n        return true",
  '        return (l.sorted.sameElements(l) || l.sorted.reverse.sameElements(l))',
  "        var m = 1\n        l.foldLeft(1) { (acc, v) => \n            if (acc >\
    \ 0) {\n                if (v < m) {\n                    -1\n               \
    \ } else {\n                    m = v\n                    1\n               \
    \ }\n            } else if (acc < 0) {\n                if (v > m) {\n       \
    \             1\n                } else {\n                    m = v\n       \
    \             -1\n                }\n            } else {\n                m =\
    \ v\n                1\n            }\n        } > 0", '        return (l.distinct.length
    == 1) || (isIncreasing(l) || isDecreasing(l))']
stop_tokens:
- "\n    }\n"
