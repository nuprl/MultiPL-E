name: HumanEval_69_search
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n    // zero, and has a frequency greater than or\
  \ equal to the value of the integer itself. \n    // The frequency of an integer\
  \ is the number of times it appears in the list.\n    // If no such a value exist,\
  \ return -1.\n    // Examples:\n    // >>> search((List[Long](4l.toLong, 1l.toLong,\
  \ 2l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\n    // (2l)\n    // >>> search((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))\n\
  \    // (3l)\n    // >>> search((List[Long](5l.toLong, 5l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong)))\n    // (-1l)\n    def search(lst : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(search((List[Long](5l.toLong,\
  \ 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](4l.toLong,\
  \ 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](3l.toLong,\
  \ 3l.toLong))) == (-1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong,\
  \ 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));\n    assert(search((List[Long](2l.toLong,\
  \ 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](2l.toLong,\
  \ 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong,\
  \ 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));\n\
  \    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) ==\
  \ (2l));\n    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong,\
  \ 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong,\
  \ 7l.toLong, 9l.toLong))) == (1l));\n    assert(search((List[Long](1l.toLong, 9l.toLong,\
  \ 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong,\
  \ 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong,\
  \ 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (5l));\n    assert(search((List[Long](1l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong,\
  \ 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong,\
  \ 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong,\
  \ 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
  \ 5l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong,\
  \ 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong,\
  \ 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong,\
  \ 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong,\
  \ 3l.toLong))) == (1l));\n    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong,\
  \ 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong,\
  \ 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong,\
  \ 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong,\
  \ 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong,\
  \ 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong,\
  \ 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong)))\
  \ == (4l));\n    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong,\
  \ 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong,\
  \ 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong,\
  \ 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong,\
  \ 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong,\
  \ 10l.toLong, 8l.toLong))) == (-1l));\n    assert(search((List[Long](10l.toLong)))\
  \ == (-1l));\n    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong,\
  \ 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong,\
  \ 7l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 4l.toLong,\
  \ 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong,\
  \ 1l.toLong, 8l.toLong))) == (1l));\n    assert(search((List[Long](7l.toLong, 9l.toLong,\
  \ 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong,\
  \ 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong,\
  \ 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));\n    }\n\n}\n"
completions: ["        def searchRec(lst : List[Long], cnt : Map[Long, Long]) : Long\
    \ = {\n            if (lst.length == 0) -1\n            else {\n             \
    \   val first = lst.head\n                if (cnt.getOrElse(first, 0l) + 1 >=\
    \ first) first\n                else searchRec(lst.tail, cnt.updated(first, cnt.getOrElse(first,\
    \ 0l) + 1))\n            }\n        }\n        searchRec(lst, Map[Long, Long]())",
  "        var cnt : Map[Long, Long] = Map()\n        for (i <- lst) {\n         \
    \   cnt(i) = cnt.getOrElse(i, 0l) + 1\n        }\n        var ans : Long = -1\n\
    \        for (i <- lst) {\n            if (cnt(i) >= i && ans < i) ans = i\n \
    \       }\n        return ans", "        val counter = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            counter(i) = counter.getOrElse(i, 0) +\
    \ 1\n        }\n        var result = -1l\n        for (i <- lst) {\n         \
    \   if (i >= counter(i) && i > result) result = i\n        }\n        result",
  "        val ht = lst.groupBy(identity).map(x => (x._1, x._2.length))\n        var\
    \ ans = -1l\n        for ((k, v) <- ht) {\n            if (k <= v && v > ans)\
    \ ans = k\n        }\n        ans", "        var dct = new HashMap[Long, Int]\n\
    \        for (x <- lst) {\n            if (dct.contains(x)) dct(x) += 1\n    \
    \        else dct(x) = 1\n        }\n        val values = dct.toList.sortBy(_._1).reverse\n\
    \        var ret = -1l\n        for (x <- values) {\n            if (x._1 <= x._2)\
    \ ret = x._1\n        }\n        ret", "        val xs = lst.groupBy(i => i).toList.map(i\
    \ => (i._1, i._2.length))\n        xs.sortBy(i => i._1).reverse.foreach(println)\n\
    \        for (x <- xs.sortBy(i => i._1).reverse) if (x._1 <= x._2) return x._1\n\
    \        return -1", "        val m = new HashMap[Long, Long]()\n        for (i\
    \ <- lst) {\n            if (m.contains(i)) m(i) += 1\n            else m += (i\
    \ -> 1)\n        }\n        if (m.isEmpty) -1\n        else {\n            var\
    \ res = -1l\n            var f = 0l\n            for (i <- m.keys) {\n       \
    \         if (i <= m(i) && i > f) {\n                    res = i\n           \
    \         f = m(i)\n                }\n            }\n            res\n      \
    \  }", "    \tval occurrences = lst.groupBy(identity).mapValues(_.size)\n    \t\
    for (i <- (1l until lst.length + 1).reverse) {\n    \t\tif (occurrences.getOrElse(i,\
    \ 0) >= i) return i\n    \t}\n    \treturn -1", "        val count = new HashMap[Long,\
    \ Long]()\n        for (v <- lst) {\n            if (count.contains(v)) count(v)\
    \ += 1\n            else count(v) = 1\n        }\n        for (k <- count.keys.toList.sorted.reverse)\
    \ {\n            if (k <= count(k)) return k\n        }\n        return -1", " \
    \       val m = scala.collection.mutable.HashMap[Long, Int]()\n        for (i\
    \ <- lst) {\n            m(i) = m.getOrElse(i, 0) + 1\n        }\n        var\
    \ g = -1l\n        var c = 0\n        for (i <- lst) {\n            if (m(i) >=\
    \ i && i > c) {\n                g = i\n                c = i\n            }\n\
    \        }\n        g", "      // Fill up this function body\n      // You can\
    \ add another function as well, if required\n      var ret : Long = -1\n     \
    \ if(lst.length != 0) {\n        val y = lst.sorted\n        val z = y.groupBy(s\
    \ => s)\n        var arr : Array[Long] = Array()\n        z.foreach( t => {\n\
    \          if(t._1 <= t._2.length && t._1 > ret) {\n            ret = t._1\n \
    \         }\n        })\n      }\n      ret", "        val map = new HashMap[Long,\
    \ Long]\n        lst.foreach(num => {\n            if (!map.contains(num)) map(num)\
    \ = 1\n            else map(num) += 1\n        })\n        val sorted = map.toList.sortWith((t1,\
    \ t2) => t1._1 > t2._1)\n        for (i <- sorted.indices) {\n            if (sorted(i)._1\
    \ <= sorted(i)._2) return sorted(i)._1\n        }\n        -1", "        val str\
    \ = lst.mkString(\"\")\n        val map = scala.collection.mutable.Map[Char, Int]()\n\
    \        for (c <- str) {\n            map(c) = map.getOrElse(c, 0) + 1\n    \
    \    }\n        val x = map.filter(x => x._2 >= x._1.toString.toInt)\n       \
    \ if (x.size > 0) x.maxBy(_._1)._1.toString.toInt.toLong else -1", "        //\
    \ max\n        // lst.max\n        // max by frequency\n        lst.groupBy(x\
    \ => x).map(x => (x._1, x._2.length)).maxBy(x => x._2)._1", "        val map =\
    \ new HashMap[Long, Long]\n        for (l <- lst) {\n            map(l) = map.getOrElse(l,\
    \ 0) + 1\n        }\n        for (i <- (1 to 1000000).reverse) {\n           \
    \ if (map.getOrElse(i, 0) >= i) return i\n        }\n        return -1", "   \
    \ \tval m = lst.groupBy(identity).mapValues(_.size)\n    \t// if(m.getOrElse(2l,\
    \ 0) >= 2) 2l else -1l\n    \tif(m.keySet.toList.sortWith(_ > _).filter(x => m.getOrElse(x,\
    \ 0) >= x).length != 0) m.keySet.toList.sortWith(_ > _).filter(x => m.getOrElse(x,\
    \ 0) >= x)(0) else -1l", "        var freq = 0\n        for (v <- lst) {\n   \
    \         if (lst.count(x => v == x) >= v) return v\n        }\n        return\
    \ -1l", "        val m = HashMap[Long, Long]()\n        for (i <- lst) {\n   \
    \         if (m.contains(i)) m(i) += 1\n            else m += (i -> 1)\n     \
    \   }\n        for (i <- m.keys.filter(_ != 0)) {\n            if (m(i) >= i)\
    \ return i\n        }\n        return -1", "        val m = lst.groupBy(x => x).mapValues(_.size)\n\
    \        if (m.keys.max < m.values.max) m.values.max else -1", "        var ret\
    \ : Long = -1\n        val table = new HashMap[Long, Long]()\n        for (x <-\
    \ lst) {\n            val y = table.getOrElse(x, 0l)\n            table.put(x,\
    \ y + 1)\n        }\n        for (k <- table.keys.toList.sorted.reverse) {\n \
    \           if (k == table(k)) ret = k\n        }\n        return ret", "    \
    \    def searchHelper(lst : List[Long], map : HashMap[Long, Long]) : Long = {\n\
    \            if (lst.isEmpty) -1\n            else {\n                val h =\
    \ lst.head\n                if (map.contains(h)) map(h) += 1 else map(h) = 1\n\
    \                searchHelper(lst.tail, map)\n            }\n        }\n     \
    \   val map = HashMap[Long, Long]()\n        searchHelper(lst, map)\n        val\
    \ max = map.values.max\n        for (key <- map.keys.toList.sorted) {\n      \
    \      if (map(key) >= key && map(key) == max) return key\n        }\n       \
    \ -1", "        val a = lst.sorted\n        val b = a.toSet\n        var t = List[Long]()\n\
    \        for (n <- b) {\n        \tval p = a.filter(x => x == n)\n        \tif\
    \ (p.length >= n) t = t :+ n\n        }\n        if (t.isEmpty) -1l else t.sorted.reverse.head",
  "        val counts = lst.groupBy(n => n).map(x => (x._1, x._2.length)).toMap\n\
    \        val filtered = counts.filter(x => x._1 <= x._2)\n        if (filtered.isEmpty)\
    \ -1 else filtered.keys.max", "        if (lst.isEmpty) -1l\n        else {\n\
    \            var map = lst.groupBy(x => x).mapValues(_.size).toList.sortBy(_._1)\n\
    \            var index = lst.size - 1\n            for (index <- lst.size - 1\
    \ to 0 by -1) {\n                val m = map(index)\n                if (m._1\
    \ <= m._2) return m._1\n            }\n            -1l\n        }", "      val\
    \ m = lst.groupBy(x => x).mapValues(_.size)\n      m.filter(p => p._1 == p._2).maxBy(p\
    \ => p._1)._1", "        lst.toArray.sortWith(_ > _).toList match {\n        \
    \    case Nil => -1l\n            case (h :: t) => {\n                //if(lst.count(_\
    \ == h) >= h) h else search(t)\n                val m = new HashMap[Long, Long]()\n\
    \                lst.foreach(e => {\n                    if(m.contains(e)) m(e)\
    \ += 1l else m += e -> 1l\n                })\n                //println(m)\n\
    \                val mm = m.filter(_._2 >= _._1)\n                //println(mm)\n\
    \                if(mm.isEmpty) -1l else mm.toArray.sortWith(_._1 > _._1)(0)._1\n\
    \            }\n        }", "        // My idea is to sort the list and return\
    \ the value at the index where the value is equal to its frequency\n        //\
    \ If there is no such value then return -1\n        // lst.sorted.indexWhere(x\
    \ => lst.count(_ == x) == x)\n        lst.sorted.indexWhere(x => lst.count(_ ==\
    \ x) >= x) match {\n            case -1 => -1\n            case i => lst.sorted(i)\n\
    \        }", "        val m = lst.groupBy(x => x).map(x => (x._1, x._2.length))\n\
    \        val n = m.filter(x => (x._1 <= x._2))\n        return if (n.isEmpty)\
    \ -1 else n.maxBy(x => x._1)._1", "        val m = new HashMap[Long, Long]\n \
    \       for (n <- lst) {\n            if (m.contains(n)) m(n) += 1\n         \
    \   else m(n) = 1\n        }\n        if (m.size > 0) m.maxBy(_._2)._1\n     \
    \   else -1", "        val sortedList = lst.sortWith((l, r) => l < r)\n      \
    \  val countList = new ListBuffer[Int]()\n        var curNum = sortedList(0)\n\
    \        var curCount = 0\n        for (i <- 0 until sortedList.length) {\n  \
    \          if (sortedList(i) == curNum) {\n                curCount += 1\n   \
    \         } else {\n                countList += curCount\n                curNum\
    \ = sortedList(i)\n                curCount = 1\n            }\n        }\n  \
    \      countList += curCount\n        var max = -1\n        for (i <- 0 until\
    \ countList.length) {\n            if (countList(i) >= i + 1) {\n            \
    \    max = i + 1\n            }\n        }\n        return max", "        var\
    \ hashmap = new HashMap[Long, Long]\n        var result = -1l\n        for (i\
    \ <- lst) {\n            if (hashmap.contains(i)) {\n                hashmap.put(i,\
    \ hashmap(i) + 1)\n            } else {\n                hashmap.put(i, 1)\n \
    \           }\n        }\n        for (i <- lst) {\n            if (hashmap(i)\
    \ >= i) {\n                result = max(result, i)\n            }\n        }\n\
    \        return result", "        var map = Map[Long, Long]()\n        for (i\
    \ <- lst) {\n            if (map.contains(i)) map(i) += 1\n            else map(i)\
    \ = 1\n        }\n        var max = -1l\n        for (i <- map.keys) {\n     \
    \       if (i <= map(i) && i > max) max = i\n        }\n        return max", " \
    \       val g : List[Long] = lst.groupBy(identity).map(l => (l._1, l._2.length)).toList.sortBy(_._1).reverse\n\
    \        g.find(l => l._1 <= l._2) match {\n            case Some(a) => a._1\n\
    \            case None => -1\n        }", "        val freqMap = lst.groupBy(identity).mapValues(_.size)\n\
    \        val result = freqMap.filterKeys(_ > 0).filter(x => x._2 >= x._1).toList.sortBy(_._1).lastOption\n\
    \        result match {\n            case Some(l) => l._1\n            case None\
    \ => -1\n        }", "        // Fill up this function body\n        // 'lst'\
    \ is the list of integers.\n        // Return the frequency of the integer, if\
    \ it has the frequency greater than\n        // or equal to the value of the integer\
    \ itself. Else, return -1.\n        lst.groupBy(x => x).map(x => (x._1, x._2.length)).maxBy(x\
    \ => x._2)._1", "        val cnt = ListBuffer[Long]()\n        var ind = 0\n \
    \       while (ind < lst.length) {\n            val k = lst(ind)\n           \
    \ var cntk = 0\n            for (i <- 0 until lst.length) {\n                if\
    \ (lst(i) == k) cntk += 1\n            }\n            if (cntk >= k) {\n     \
    \           cnt += cntk\n            }\n            ind += 1\n        }\n    \
    \    if (cnt.length == 0) -1 else cnt.max", "        var m : Map[Long, Long] =\
    \ Map.empty;\n        var maxInt : Long = Long.MinValue;\n        var maxFreq\
    \ : Long = Long.MinValue;\n        for (i <- lst) {\n            if (m.contains(i))\
    \ m(i) += 1;\n            else m(i) = 1;\n            if (i > maxInt) maxInt =\
    \ i;\n            if (m(i) > maxFreq) maxFreq = m(i);\n        }\n        for\
    \ (i <- maxInt to 1 by -1) {\n            if (m.contains(i) && m(i) >= i && i\
    \ >= maxFreq) return i;\n        }\n        return -1;", "        var m = new\
    \ HashMap[Long, Long]\n        for (x <- lst) {\n            var y = x\n     \
    \       if (m.contains(y)) m(y) += 1\n            else m += (y -> 1)\n       \
    \ }\n        var flag = true\n        for (x <- lst) {\n            var y = x\n\
    \            if (m(y) >= y) {\n                println(y)\n                flag\
    \ = false\n                return y\n            }\n        }\n        if (flag)\
    \ return -1\n        return -1", "        val map = lst.groupBy(identity).mapValues(_.size)\n\
    \        var result = -1l\n        map.foreach(x => {\n            if(x._1 <=\
    \ x._2 && x._1 > result) result = x._1\n        })\n        result", "       \
    \ val table = HashMap[Long, Long]()\n        lst.foreach(x => table.update(x,\
    \ table.getOrElse(x, 0) + 1))\n        val keys = table.keys.toList.sorted\n \
    \       val frequency = keys.map(x => (x, table(x)))\n        val values = frequency.map(x\
    \ => (x._1, x._2 >= x._1))\n        if (values.filter(x => x._2).length > 0)\n\
    \        \treturn values.filter(x => x._2).head._1\n        return -1", "    \t\
    val frequencyTable = new HashMap[Long, Long]()\n    \tlst.foreach(x => {\n   \
    \ \t\tif (!frequencyTable.contains(x)) frequencyTable(x) = 0\n    \t\tfrequencyTable(x)\
    \ += 1\n    \t})\n    \tfrequencyTable.filter(x => x._1 <= x._2).toList.sortBy(x\
    \ => x._1).lastOption match {\n    \t\tcase Some(v) => v._1\n    \t\tcase None\
    \ => -1\n    \t}", "        if (lst.size == 0) return -1l\n        val m = new\
    \ HashMap[Long, Long]()\n        for (x <- lst) {\n            m(x) = m.getOrElse(x,\
    \ 0l) + 1l\n        }\n        var ans = -1l\n        var max = 0l\n        for\
    \ (k <- m.keys) {\n            if (k <= m(k) && k > max) {\n                ans\
    \ = k\n                max = k\n            }\n        }\n        return ans",
  "        val numSet = lst.toSet\n        val histogram = (Map[Long, Int]() /: lst)\
    \ {\n            (map, x) => map + (x -> (map.getOrElse(x, 0) + 1))\n        }\n\
    \        var maxFreq = 0\n        var result = -1\n        for (num <- numSet)\
    \ {\n            val freq = histogram(num)\n            if (freq >= num && num\
    \ > result) {\n                result = num\n                maxFreq = freq\n\
    \            }\n        }\n        return result", "        val s = lst.sorted\n\
    \        var result = -1l\n        var index = s.length - 1\n        while (index\
    \ >= 0) {\n            val value = s(index)\n            val count = s.count(_\
    \ == value)\n            if (value <= count) result = value\n            index\
    \ -= 1\n        }\n        result", "        var freq = new HashMap[Long, Long]()\n\
    \        for (num <- lst) {\n            if (freq.contains(num)) freq(num) +=\
    \ 1 else freq(num) = 1\n        }\n        var result = -1\n        for (k <-\
    \ freq.keys) {\n            if (k <= freq(k) && k > result) result = k\n     \
    \   }\n        return result", "        var count = Map[Long, Long]()\n      \
    \  for (a <- lst) count(a) = count.getOrElse(a, 0l) + 1\n        val c = count.toList.sortWith((a,\
    \ b) => a._1 > b._1)\n        for (a <- c) if (a._1 <= a._2) return a._1\n   \
    \     return -1", "        val map = new HashMap[Long, Long]\n        for (i <-\
    \ lst) {\n            if (map.contains(i)) map(i) += 1 else map += (i -> 1)\n\
    \        }\n        val maxValue = map.toList.maxBy(_._2)._2\n        val res\
    \ = map.filter(x => (x._2 >= x._1) && (x._2 == maxValue)).keys.toList.max\n  \
    \      if (res == 0) -1 else res", "\t\t// Your Code Here\n\t\tnull", "      \
    \  var freq = new HashMap[Long, Int]\n        for (i <- lst) freq(i) = freq.getOrElse(i,\
    \ 0) + 1\n        val sorted = freq.toList.sortWith((t1, t2) => t1._1 > t2._1)\n\
    \        for (i <- sorted) {\n            if (i._1 <= i._2) return i._1\n    \
    \    }\n        return -1", "\t\tvar m = new HashMap[Long, Int]\n\t\tfor (i <-\
    \ lst) {\n\t\t\tif (m.contains(i)) m(i) += 1\n\t\t\telse m(i) = 1\n\t\t}\n\t\t\
    var a = new ArrayBuffer[Long]\n\t\tfor (i <- m.keys) {\n\t\t\tif (i == m(i)) a\
    \ += i\n\t\t}\n\t\tif (a.isEmpty) -1\n\t\telse {\n\t\t\tvar r = 0l\n\t\t\tfor\
    \ (i <- a) {\n\t\t\t\tif (i > r) r = i\n\t\t\t}\n\t\t\tr\n\t\t}", "        //return\
    \ -1l\n        lst.groupBy(identity).map(m => (m._1, m._2.length)).filter(m =>\
    \ m._1 <= m._2).maxBy(m => m._1)._1", "        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        var uniq\
    \ = ArrayBuffer[Long]()\n        var freq = ArrayBuffer[Long]()\n        var max\
    \ = 0l\n        var flag = false\n        lst.sorted.foreach(i => {\n        \
    \    var t = uniq.indexOf(i)\n            if (t == -1) {\n                uniq\
    \ += i\n                freq += 1\n            }\n            else freq(t) +=\
    \ 1\n        })\n        uniq.foreach(i => {\n            if (i != 1) {\n    \
    \            var t = freq.indexOf(i)\n                if (t != -1) {\n       \
    \             if (uniq(t) > max) max = uniq(t)\n                    flag = true\n\
    \                }\n            }\n        })\n        if (flag) max else -1",
  "        val lst2 = lst.groupBy(identity).toList.map(x => (x._1, x._2.length)).sortBy(x\
    \ => x._1)\n        if (lst2.length == 0) return -1l\n        return lst2.filter(x\
    \ => x._1 <= x._2).sortBy(x => x._1).last._1", "        def search_itr(lst : List[Long],\
    \ m : HashMap[Long, Long]) : Long = {\n            lst match {\n             \
    \   case Nil => if (m.size == 0) -1 else {\n                    val sorted = m.toList.sortWith(_._2\
    \ > _._2)\n                    var candidate = sorted(0)._1\n                \
    \    var count = sorted(0)._2\n                    if (count >= candidate) candidate\
    \ else -1\n                }\n                case x :: rest => {\n          \
    \          if (m.contains(x)) m(x) += 1\n                    else m += (x -> 1)\n\
    \                    search_itr(rest, m)\n                }\n            }\n \
    \       }\n        search_itr(lst, HashMap[Long, Long]())", "        val count\
    \ : Map[Long, Long] = Map()\n        for (v <- lst) {\n            if (count.contains(v))\
    \ count(v) += 1\n            else count(v) = 1\n        }\n        var max = 0l\n\
    \        for (v <- count.keys) {\n            if (v <= count(v) && v > max) max\
    \ = v\n        }\n        if (max == 0) -1 else max", "        val n = lst.length\n\
    \        var list = List[Long]()\n        for (item <- lst) {\n            if\
    \ (item > 0 && item <= n) list = item :: list\n        }\n        var result =\
    \ -1l\n        val counts = list.groupBy(x => x).mapValues(_.size)\n        for\
    \ (item <- counts) {\n            if (item._1 <= item._2) {\n                if\
    \ (result == -1l) result = item._1\n                else if (item._1 > result)\
    \ result = item._1\n            }\n        }\n        result", "        var map\
    \ = new HashMap[Long, Long]()\n        for (i <- lst) {\n            if (map.contains(i))\
    \ map(i) += 1\n            else map += (i -> 1)\n        }\n        for (i <-\
    \ lst.distinct.sortWith(_>_)) if (i <= map(i)) return i\n        return -1", " \
    \       val m = scala.collection.mutable.Map[Long, Long]()\n        lst.foreach(x\
    \ => m(x) = m.getOrElse(x, 0l) + 1)\n        val result = lst.sorted.filter(x\
    \ => m(x) >= x).reverse\n        if (result.length > 0) result(0) else -1", " \
    \       // Your Code Here\n        0", "        val count = collection.mutable.Map[Long,\
    \ Long]()\n        lst.foreach(x => count(x) = count.getOrElse(x, 0l) + 1)\n \
    \       val keys = count.keys.toList.sortWith(_ > _)\n        keys.foreach(x =>\
    \ if (x <= count(x)) return x)\n        -1l", "        val frequencyMap = Map[Long,\
    \ Long]()\n        for (i <- lst) {\n            if (frequencyMap.contains(i))\
    \ {\n                frequencyMap(i) += 1\n            } else {\n            \
    \    frequencyMap += (i -> 1)\n            }\n        }\n        val mapIter =\
    \ frequencyMap.iterator\n        var ret = -1l\n        while (mapIter.hasNext)\
    \ {\n            val (key, value) = mapIter.next\n            if (key >= value\
    \ && key > ret) {\n                ret = key\n            }\n        }\n     \
    \   ret", "\t\t// Type your solution here\n        if (lst.isEmpty) -1l\n    \
    \    else {\n            val group = lst.groupBy(x => x)\n            val sorted\
    \ = group.toList.sortBy(x => (-x._2.length, x._1))\n            if (sorted.head._2.length\
    \ < sorted.head._1) -1l\n            else sorted.head._1\n        }", "      \
    \  val m = Map[Long, Long]()\n        lst.foreach(e => {\n            if (m.contains(e))\
    \ m(e) += 1\n            else m(e) = 1\n        })\n        val max = m.keys.max\n\
    \        (for (i <- 1 to max.toInt) yield {\n            if (m.contains(i.toLong)\
    \ && m(i.toLong) >= i) i\n            else -1\n        }).max", "        var newlst\
    \ = lst.sortWith(_ < _)\n        var current = newlst.head\n        var freq =\
    \ 0\n        for (i <- newlst) {\n            if (i == current) freq += 1\n  \
    \          else {\n                if (freq >= current) return current\n     \
    \           else {\n                    current = i\n                    freq\
    \ = 1\n                }\n            }\n        }\n        if (freq >= current)\
    \ return current\n        else return -1", "        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        var dic:Map[Long,Long]\
    \ = Map()\n        lst.foreach(x => if(dic.contains(x)) dic = dic.updated(x,dic(x)+1)\
    \ else dic = dic + (x -> 1))\n        var value = -1l\n        for(x <- lst){\n\
    \            if(dic(x) >= x && x>value) value = x\n        }\n        return value",
  "        if (lst.size == 0) return -1\n        val counts = Array.fill(100001)(0)\n\
    \        for (i <- lst) counts(i.toInt) += 1\n        for (i <- 100000 to 1 by\
    \ -1) if (counts(i) >= i) return i\n        return -1", "        if (lst.length\
    \ == 0) return -1l\n        val freq = HashMap[Long, Long]()\n        for (x <-\
    \ lst) {\n            freq(x) = freq.getOrElse(x, 0l) + 1l\n        }\n      \
    \  val sorted = freq.toList.sortWith((a, b) => a._1 > b._1)\n        for (x <-\
    \ sorted) {\n            if (x._1 <= x._2) return x._1\n        }\n        return\
    \ -1l", "        val map = scala.collection.mutable.Map[Long, Int]()\n       \
    \ for (i <- lst) {\n            if (map.contains(i)) {\n                map(i)\
    \ += 1\n            } else {\n                map(i) = 1\n            }\n    \
    \    }\n        var ans = -1l\n        for (key <- map.keys) {\n            if\
    \ (key <= map(key) && key > ans) {\n                ans = key\n            }\n\
    \        }\n        ans", "        // Creates a map of frequency.\n        val\
    \ freq = lst.groupBy(x => x).mapValues(_.size)\n        // Creates a map of values\
    \ that are greater than or equal to the frequency of the element.\n        val\
    \ freqFilter = freq.filter(x => x._1 >= x._2)\n        if (freqFilter.isEmpty)\
    \ -1l\n        else freqFilter.maxBy(_._1)._1", "        val frequency = lst.groupBy(x\
    \ => x).mapValues(_.size)\n        val values = frequency.toSeq.sortBy(_._1).map(_._1)\n\
    \        val freq_values = frequency.toSeq.sortBy(_._1).map(_._2)\n        val\
    \ freq_greater_values = frequency.toSeq.sortBy(_._1).map(x => x._2 >= x._1)\n\
    \        var result = -1l\n        for (i <- 0 until values.length) {\n      \
    \      if (freq_greater_values(i)) result = values(i)\n        }\n        return\
    \ result", "        def f(x : List[Long], map : Map[Long, Long]) : Long = {\n\
    \            if (x.isEmpty) {\n                var (max, count) = map.maxBy(_._2)\n\
    \                if (count >= max) max else -1\n            } else {\n       \
    \         val count = map.getOrElse(x.head, 0) + 1\n                map += (x.head\
    \ -> count)\n                f(x.tail, map)\n            }\n        }\n      \
    \  f(lst, Map[Long, Long]())", "        val dict = lst.groupBy(x => x).mapValues(_.size)\n\
    \        dict.filter(x => x._1 == x._2).maxBy(_._1)._1", "        val hs = new\
    \ HashMap[Long, Long]()\n        for (e <- lst) {\n            hs(e) = hs.getOrElse(e,\
    \ 0l) + 1\n        }\n        var mx : Long = -1\n        for (e <- hs.keySet)\
    \ {\n            if (e >= hs(e) && e > mx) {\n                mx = e\n       \
    \     }\n        }\n        return mx", "        val r = lst.groupBy(x => x).map(x\
    \ => (x._1, x._2.length)).filter(x => x._1 <= x._2).toList.sortBy(x => x._1)\n\
    \        if (r.length == 0) return -1l\n        r.last._1", "        val freq\
    \ = collection.mutable.Map[Long, Long]()\n        var s = 0l\n        for (i <-\
    \ lst) {\n            if (freq.contains(i)) freq(i) += 1\n            else freq\
    \ += (i -> 1)\n            if (freq(i) >= i) s = max(s, i)\n        }\n      \
    \  if (s > 0) s else -1", "        var map = scala.collection.mutable.Map[Long,\
    \ Long]()\n        for (i <- lst) {\n            if (map.contains(i)) map(i) +=\
    \ 1\n            else map += (i -> 1)\n        }\n        val ans = map.filter(x\
    \ => x._1 <= x._2).toList.sortWith((x, y) => x._1 < y._1)\n        if (ans.length\
    \ == 0) -1\n        else ans.last._1", '        return -1l', "        val groups\
    \ = lst.groupBy(p => p).map(p => (p._1, p._2.length))\n        val r1 = groups.filter(p\
    \ => p._1 <= p._2).toList.sortBy(p => -p._1)\n        if (r1.isEmpty) -1 else\
    \ r1.head._1", "        val map = HashMap[Long, Long]()\n        for (x <- lst)\
    \ {\n            if (map.contains(x)) {\n                map(x) += 1\n       \
    \     } else {\n                map(x) = 1\n            }\n        }\n       \
    \ var answer = -1l\n        for (pair <- map) {\n            if (pair._1 <= pair._2\
    \ && pair._1 > answer) {\n                answer = pair._1\n            }\n  \
    \      }\n        return answer", "    \tval map = new HashMap[Long, Int]\n  \
    \  \tfor (x <- lst) {\n    \t\tif (map.contains(x)) map(x) += 1\n    \t\telse\
    \ map(x) = 1\n    \t}\n    \tval lst2 = lst.sortWith((x, y) => x > y)\n    \t\
    for (x <- lst2) {\n    \t\tif (map(x) >= x) return x\n    \t}\n    \treturn -1",
  "        // We have a list of Longs - a map of the Int representing each long value,\
    \ to the frequency \n        // of that long value.\n        var frequencyMap\
    \ = new HashMap[Int, Long]\n        for (i <- lst) {\n            if (frequencyMap.contains(i.toInt))\
    \ {\n                frequencyMap.put(i.toInt, frequencyMap.get(i.toInt).get +\
    \ 1)\n            } else {\n                frequencyMap.put(i.toInt, 1)\n   \
    \         }\n        }\n        var found = false\n        var i = 0\n       \
    \ var res = -1l\n        while (!found && i < lst.length) {\n            var key\
    \ = lst(i).toInt\n            if (frequencyMap.get(key).get >= key) {\n      \
    \          res = key\n                found = true\n            }\n          \
    \  i += 1\n        }\n        res", "        val m = new HashMap[Long, Long]()\n\
    \        for (a <- lst) m(a) = m.getOrElse(a, 0l) + 1\n        for (a <- lst)\
    \ if (a <= m(a)) return a\n        return -1", "        // Edge case\n       \
    \ if (lst.length == 0) return -1l.toLong\n        // Get the count of all numbers\
    \ in the list\n        val m = Map[Long, Long]()\n        for (n <- lst) m(n)\
    \ = m.getOrElse(n, 0l.toLong) + 1l.toLong\n        // Return greatest frequency\
    \ that is greater than the integer itself\n        var res = -1l.toLong\n    \
    \    for (e <- m) if (e._1 <= e._2 && e._2 > res) res = e._2\n        res", " \
    \       var map = new HashMap[Long, Long]()\n        for (i <- lst) {\n      \
    \      if (map.contains(i)) map.put(i, map(i) + 1)\n            else map.put(i,\
    \ 1)\n        }\n        var candidate = lst.max\n        while (candidate > 0)\
    \ {\n            if (map.contains(candidate) && map(candidate) >= candidate) return\
    \ candidate\n            candidate -= 1\n        }\n        return -1", "    \
    \    val n : Long = lst.length\n        var table : Array[Long] = new Array[Long](n.toInt)\n\
    \        var result : Long = -1\n        for (i <- 0 until n.toInt) {\n      \
    \      table(i) = 1\n            for (j <- 0 until i) {\n                if (lst(j)\
    \ == lst(i)) {\n                    table(i) += 1\n                }\n       \
    \     }\n            if (table(i) >= lst(i) && lst(i) > result) {\n          \
    \      result = lst(i)\n            }\n        }\n        return result", "  \
    \      val groups = lst.groupBy(x => x)\n        val r = groups.keys.filter(x\
    \ => x <= groups(x).length)\n        if (r.length == 0) -1 else r.max", "    \
    \    val freq = lst.groupBy(identity).mapValues(_.size)\n        val greatest\
    \ = freq.filter(x => x._1 <= x._2).keySet.max\n        if (greatest != null) return\
    \ greatest else return -1", "        var greaterThanZero = lst.filter(e => e >\
    \ 0l)\n        var maximum = greaterThanZero.foldLeft(1l)((x, y) => max(x, y))\n\
    \        var counts = Array.fill(maximum.toInt + 1)(0)\n        for (i <- 0 until\
    \ greaterThanZero.length) {\n            counts(greaterThanZero(i).toInt) += 1\n\
    \        }\n        for (i <- maximum.toInt to 1 by -1) {\n            if (counts(i)\
    \ >= i) return i.toLong\n        }\n        return -1l", "        // Assumptions:\
    \ None\n        // Note: Long, allowing negative numbers\n        // Approach:\
    \ \n        // Complexity: O(n)\n        // Expected: O(n)\n        // Got: O(n)\n\
    \        // Note: The solution is trivial\n        val answer = new ListBuffer[Long]()\n\
    \        val mp = new HashMap[Long, Long]()\n        lst.foreach(x => {\n    \
    \        mp(x) = if (mp.contains(x)) mp(x) + 1 else 1\n        })\n        val\
    \ sorted = mp.toList.sortBy(x => x._1)\n        sorted.foreach(x => {\n      \
    \      if (x._1 <= x._2) {\n                answer += x._1\n            }\n  \
    \      })\n        answer.reverse.headOption match {\n            case Some(x)\
    \ => x\n            case None => -1\n        }", "        var count = 0l\n   \
    \     var greatestCount = 0l\n        var greatestValue = 0l\n        var valueMap\
    \ = new HashMap[Long, Long]()\n        for (i <- lst) {\n            if (valueMap.contains(i))\
    \ {\n                count = valueMap(i)\n                valueMap.update(i, count\
    \ + 1)\n            } else {\n                valueMap.put(i, 1)\n           \
    \ }\n        }\n        for (i <- valueMap.keys) {\n            if (valueMap(i)\
    \ >= i) {\n                if (valueMap(i) > greatestCount) {\n              \
    \      greatestCount = valueMap(i)\n                    greatestValue = i\n  \
    \              }\n            }\n        }\n        if (greatestValue == 0) -1\
    \ else greatestValue", "        var m = Map[Long, Long]()\n        for (i <- lst)\
    \ {\n            if (m.contains(i)) m(i) += 1\n            else m(i) = 1\n   \
    \     }\n        var m2 = Map[Long, Long]()\n        for (i <- m.keys) {\n   \
    \         if (m2.contains(m(i))) m2(m(i)) += 1\n            else m2(m(i)) = 1\n\
    \        }\n        var best = -1l\n        for (i <- m2.keys) {\n           \
    \ if (i >= m2(i) && i > best) best = i\n        }\n        if (best != -1) m2(best)\n\
    \        else -1", "        val map = lst.groupBy(identity).mapValues(_.size)\n\
    \        val m = map.maxBy(_._2)\n        if (m._2 >= m._1) m._1 else -1", "\t\t\
    // Fill up this function body\n\t\t// You can add another function as well, if\
    \ required\n\t\t-1l", "        var freq = new HashMap[Long, Long]\n        for\
    \ (i <- lst) {\n            if (freq.contains(i)) {\n                freq(i) +=\
    \ 1\n            } else {\n                freq(i) = 1\n            }\n      \
    \  }\n        var res = -1l\n        for (i <- freq.keys.toList.sorted) {\n  \
    \          if (freq(i) >= i) {\n                res = i\n            }\n     \
    \   }\n        return res", "        def loop(lst : List[Long], result : Long,\
    \ memo : Map[Long, Long]) : Long = {\n            if (lst.isEmpty) result\n  \
    \          else {\n                val head = lst.head\n                val occurrence\
    \ = memo.getOrElse(head, 0l) + 1l\n                if (occurrence >= head && head\
    \ > result) loop(lst.tail, head, memo + (head -> occurrence))\n              \
    \  else loop(lst.tail, result, memo + (head -> occurrence))\n            }\n \
    \       }\n        loop(lst, -1l, Map())", "        // Build a map from the list.\n\
    \        val m = new HashMap[Long, Long]\n        lst.foreach(i => m(i) = (m.getOrElse(i,\
    \ 0l.toLong) + 1l.toLong))\n        var ans = (-1l.toLong)\n        // Iterate\
    \ through the map, find the max value.\n        m.foreach(i => ans = (max(i._1,\
    \ i._2, ans)))\n        return ans", "        // Fill up this function body\n\
    \        // 'lst' is list of positive integers.\n        // You have to return\
    \ the greatest integer that is greater than zero, and has a frequency greater\
    \ than or equal to the value of the integer itself.\n        // If no such a value\
    \ exist, return -1.\n        val map = scala.collection.mutable.Map[Long, Long]()\n\
    \        for (i <- lst) {\n            if (map.contains(i)) {\n              \
    \  map(i) += 1\n            } else {\n                map(i) = 1\n           \
    \ }\n        }\n        var max = 0l\n        for (i <- map.keys) {\n        \
    \    if (i != 0 && map(i) >= i && max < i) {\n                max = i\n      \
    \      }\n        }\n        if (max == 0) {\n            -1\n        } else {\n\
    \            max\n        }", "        val dict = new HashMap[Long, Long]()\n\
    \        for (i <- lst) {\n            if (dict.contains(i)) dict.update(i, dict(i)\
    \ + 1)\n            else dict += (i -> 1)\n        }\n        var ans = -1l\n\
    \        for (i <- dict.keys) {\n            if (i > 0 && dict(i) >= i && i >\
    \ ans) ans = i\n        }\n        ans", "\t\tval map = lst.groupBy(x => x).map(x\
    \ => (x._1, x._2.length))\n\t\tif (map.size == 1) {\n\t\t\tval m = map.values.toList(0)\n\
    \t\t\tif (m == 1) {\n\t\t\t\t-1\n\t\t\t} else {\n\t\t\t\tmap.keys.toList(0)\n\t\
    \t\t}\n\t\t} else {\n\t\t\tval l = map.toList.filter(x => x._2 >= x._1).sortBy(x\
    \ => x._1)\n\t\t\tif (l.size == 0) {\n\t\t\t\t-1\n\t\t\t} else {\n\t\t\t\tl(l.size\
    \ - 1)._1\n\t\t\t}\n\t\t}", "        var m = scala.collection.mutable.HashMap[Long,\
    \ Int]()\n        for (x <- lst) {\n            if (m.contains(x)) {\n       \
    \         m(x) += 1\n            } else {\n                m(x) = 1\n        \
    \    }\n        }\n        var ret = -1l\n        for (x <- m.keys) {\n      \
    \      if (x == m(x) && ret < x) {\n                ret = x\n            }\n \
    \       }\n        return ret", "        // Fill up this function body\n     \
    \   // You can add another function as well, if required\n        var array =\
    \ new Array[Long]((lst.max) toInt)\n        for (i <- 0 to (lst.length - 1)) {\n\
    \            array(lst(i).toInt - 1) += 1\n        }\n        for (i <- 0 to (array.length\
    \ - 1)) {\n            if (array(i) >= (i + 1)) {\n                return i +\
    \ 1\n            }\n        }\n        return -1", "        val mp = lst.groupBy(identity).map(x\
    \ => (x._1, x._2.length))\n        var result = -1\n        for ((k, v) <- mp)\
    \ {\n            if (k <= v && v > result) result = k\n        }\n        return\
    \ result", "        var frequen = HashMap[Long, Int]()\n        for (elem <- lst)\
    \ {\n            if (frequen.contains(elem)) {\n                frequen(elem)\
    \ += 1\n            } else {\n                frequen(elem) = 1\n            }\n\
    \        }\n        var result = (-1).toLong\n        for (elem <- frequen.keys)\
    \ {\n            if (elem <= frequen(elem) && elem > result) {\n             \
    \   result = elem\n            }\n        }\n        return result", "       \
    \ if (lst.isEmpty) return -1l.toLong\n        // (value, frequency)\n        val\
    \ map = HashMap[Long, Long]()\n        for (x <- lst) {\n            if (map.contains(x))\
    \ map(x) += 1\n            else map += (x -> 1)\n        }\n        var result\
    \ = -1l.toLong\n        for (i <- map.keySet) {\n            if (i <= map(i) &&\
    \ i > result) result = i\n        }\n        return result", "        var result\
    \ : Long = 0\n        val counter = mutable.Map[Long, Int]()\n        for (i <-\
    \ lst) {\n            if (counter.contains(i)) counter(i) += 1\n            else\
    \ counter(i) = 1\n        }\n        for (i <- lst) {\n            if (counter(i)\
    \ >= i) {\n                if (i > result) result = i\n            }\n       \
    \ }\n        if (result == 0) result = -1\n        return result", "        val\
    \ m = lst.groupBy(x => x).mapValues(_.size)\n        val max = m.maxBy(_._2)\n\
    \        if (max._2 >= max._1) max._1 else -1", "        // your code here\n \
    \       null", "        // a solution function that returns the greatest integer\
    \ that has a frequency greater than or equal to the value of the integer itself\n\
    \        // if no such a value exist, return -1\n        def searchSolution(d\
    \ : Map[Long, Long], m : Long) : Long = {\n            if (d.contains(m) && d(m)\
    \ >= m) m\n            else if (m <= 1) -1\n            else searchSolution(d,\
    \ m - 1)\n        }\n        // d is a dictionary that maps from integer to frequency\
    \ of that integer\n        val d = Map[Long, Long]()\n        // iterate through\
    \ lst, adding the frequency of each integer to d\n        for (x <- lst) {\n \
    \           if (d.contains(x)) d(x) += 1\n            else d(x) = 1\n        }\n\
    \        searchSolution(d, d.keys.max)", "        var result = -1l\n        var\
    \ freq = lst.length\n        val map = new HashMap[Long, Long]()\n        for\
    \ (i <- lst) {\n            map.put(i, map.getOrElse(i, 0l) + 1)\n        }\n\
    \        for (i <- lst) {\n            val v = map.getOrElse(i, 0l)\n        \
    \    if (v >= i && v <= freq) {\n                result = i\n                freq\
    \ = v\n            }\n        }\n        return result", "        def searchHelper(lst\
    \ : List[Long], freq : Map[Long, Long]) : Long = {\n            if (lst.isEmpty)\
    \ {\n                freq.maxBy(_._2)._1\n            } else {\n             \
    \   val nextFreq = freq.getOrElse(lst.head, 0l) + 1\n                searchHelper(lst.tail,\
    \ freq + (lst.head -> nextFreq))\n            }\n        }\n        val result\
    \ = searchHelper(lst, Map[Long, Long]())\n        if (result <= lst.length) result\
    \ else -1", "        if (lst.length < 1) return -1\n        var l = lst.sorted\n\
    \        if (l(0) == 1) return -1\n        var x = -1l\n        var y = -1l\n\
    \        var length = 0\n        var tmp = 0\n        while (length < l.length)\
    \ {\n            var num = l(length)\n            while (length < l.length &&\
    \ l(length) == num) {\n                tmp += 1\n                length += 1\n\
    \            }\n            if (num >= tmp) {\n                y = num\n     \
    \           break\n            }\n            tmp = 0\n        }\n        if (y\
    \ < 0) return -1\n        var i = 0\n        var count = 0\n        while (i <\
    \ l.length) {\n            if (l(i) == y) count += 1\n            i += 1\n   \
    \     }\n        if (count >= y) return y\n        else return -1", "        //\
    \ Fill up this function body\n        // You can add another function as well,\
    \ if required\n        return 0l", "        var map = Map[Long, Long]()\n    \
    \    for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n        \
    \    else map(i) = 1\n        }\n        var max = -1l\n        for (i <- map.keys)\
    \ {\n            if (i >= map(i) && i > max) max = i\n        }\n        return\
    \ max", "        def searchRec(map : SortedMap[Long, Int], maxKey : Long) : Long\
    \ = {\n            if (map.head._1 > maxKey) searchRec(map.tail, maxKey)\n   \
    \         else if (map.head._1 == maxKey) maxKey\n            else -1\n      \
    \  }\n        val counts = lst.groupBy(identity).mapValues(_.size).toMap\n   \
    \     val countsSorted = SortedMap(counts.toSeq:_*)\n        val maxKey = countsSorted.values.max\n\
    \        searchRec(countsSorted, maxKey)", "        val m = new HashMap[Long,\
    \ Long]\n        for (x <- lst) {\n            if (m.contains(x)) {\n        \
    \        m(x) += 1\n            } else {\n                m(x) = 1\n         \
    \   }\n        }\n        var result = -1l\n        var max = 0l\n        for\
    \ (x <- m.keys) {\n            if (x >= m(x) && m(x) > max) {\n              \
    \  max = m(x)\n                result = x\n            }\n        }\n        result",
  "        var map = Map[Long, Long]()\n        for (e <- lst) {\n            if (map.contains(e))\
    \ map(e) += 1\n            else map(e) = 1\n        }\n        var max = 0l\n\
    \        for (e <- map) {\n            if (e._1 >= e._2 && e._1 > max) max = e._1\n\
    \        }\n        if (max == 0) -1 else max", "        val count = Map[Long,\
    \ Int]()\n        for (v <- lst) {\n            if (count.contains(v)) {\n   \
    \             count(v) += 1\n            } else {\n                count(v) =\
    \ 1\n            }\n        }\n        var result = -1l\n        for (i <- 0 to\
    \ lst.length) {\n            if (count.contains(i) && count(i) >= i) {\n     \
    \           result = i\n            }\n        }\n        return result", "  \
    \      val frequency = lst.groupBy(identity).mapValues(_.size)\n        val number\
    \ = frequency.map{case (k, v) => k > v match {\n            case true => -1\n\
    \            case false => k}\n        }.toList.sorted.last\n        return number",
  "        var map = new scala.collection.mutable.HashMap[Long, Int]()\n        lst.foreach(f\
    \ => {\n            if (map.contains(f)) map(f) += 1\n            else map(f)\
    \ = 1\n        })\n        val map2 = map.filter(f => f._1 <= f._2).toList\n \
    \       if (map2.length > 0) map2.maxBy(f => f._1)._1\n        else -1", "   \
    \     val f = lst.groupBy(x => x).mapValues(_.size)\n        (1l to lst.size).filter(x\
    \ => f.contains(x) && f(x) >= x).sorted.lastOption.getOrElse(-1l)", "        val\
    \ freqMap = new HashMap[Long, Long]\n        lst.foreach(x => freqMap(x) = freqMap.getOrElse(x,\
    \ 0l) + 1)\n        val ans = freqMap.filter(x => x._1 <= x._2).maxBy(x => x._1)\n\
    \        if (ans._1 == ans._2) ans._1 else -1", "        val map = new HashMap[Long,\
    \ Long]()\n        for (e <- lst) {\n            if (map.contains(e)) map(e) +=\
    \ 1\n            else map += (e -> 1)\n        }\n        var res = -1l\n    \
    \    for (e <- map.keySet) {\n            if (e <= map(e) && e > res) res = e\n\
    \        }\n        res", "        var m = lst.groupBy(x => x).mapValues(_.size)\n\
    \        val max = lst.max\n        val maxInt = m.get(max).get\n        if (maxInt\
    \ >= max) max else -1", "        var frequencyMap = Map[Long, Long]()\n      \
    \  lst.foreach(i => {\n            val currentFreq = frequencyMap.getOrElse(i,\
    \ 0l)\n            frequencyMap += (i -> (currentFreq + 1))\n        })\n    \
    \    frequencyMap.filter(i => i._1 <= i._2).maxBy(i => i._1)._1", "        val\
    \ a = lst.groupBy(x => x).map(x => (x._1, x._2.length))\n        for (i <- 0 to\
    \ lst.length - 1) {\n            if (a.get(lst(i)).getOrElse(0) >= lst(i)) {\n\
    \                return lst(i)\n            }\n        }\n        return -1l",
  "        val map = new HashMap[Long, Long]()\n        for (i <- lst) {\n       \
    \     if (map.contains(i)) map(i) += 1 else map += i -> 1\n        }\n       \
    \ var result = 0l\n        for (i <- map.keys) {\n            if (i > 0 && map(i)\
    \ >= i && i > result) result = i\n        }\n        if (result == 0) -1 else\
    \ result", '        return lst.groupBy(identity).mapValues(_.size).maxBy(_._2)._1',
  "        val m = lst.groupBy(x => x).map(x => (x._1, x._2.length))\n        var\
    \ results = List[Long]()\n        for (i <- m) {\n            if (i._1 > 0 &&\
    \ i._1 <= i._2) {\n                results = i._1 :: results\n            }\n\
    \        }\n        if (results.length > 0) {\n            results.max\n     \
    \   } else {\n            -1\n        }", "        val freq = Map[Long, Int]()\n\
    \        for (i <- lst) {\n            freq.get(i) match {\n                case\
    \ Some(x) => freq(i) = x + 1\n                case None => freq(i) = 1\n     \
    \       }\n        }\n        val freqList = freq.toList.sortWith(_._1 > _._1)\n\
    \        for (i <- freqList) {\n            if (i._1 <= i._2) return i._1\n  \
    \      }\n        return -1", "        val map = new HashMap[Long, Long]\n   \
    \     for (i <- lst) {\n            if (map.contains(i)) map(i) += 1 else map(i)\
    \ = 1\n        }\n        val n = (1l to lst.length).map(i => i * i * i * i *\
    \ i * i * i * i * i).max\n        for (i <- n to 1 by -1) {\n            if (map.contains(i)\
    \ && i <= map(i)) return i\n        }\n        return -1", "        val freq =\
    \ new HashMap[Long, Long]\n        lst.foreach(i => {\n            freq(i) = freq.getOrElse(i,\
    \ 0l) + 1l\n        })\n        val max = freq.keySet.max\n        for (i <- max\
    \ to 1 by -1) {\n            if (freq.getOrElse(i, 0l) >= i) {\n             \
    \   return i\n            }\n        }\n        return -1l", "        val m =\
    \ new HashMap[Long, Long]\n        lst.foreach(i => {\n            val c = m.getOrElse(i,\
    \ 0l)\n            m += (i -> (c + 1))\n        })\n        val maxF = m.map(x\
    \ => x._2).max\n        for (i <- 1l to maxF) if (m.contains(i) && i <= m(i))\
    \ return i\n        return -1", "        val hist = new HashMap[Long, Long]\n\
    \        for (e <- lst) {\n            if (hist.contains(e)) hist(e) += 1 else\
    \ hist(e) = 1\n        }\n        val k = hist.keys\n        var result = -1l\n\
    \        for (e <- k) {\n            if (e <= hist(e) && e > result) result =\
    \ e\n        }\n        return result", '        lst.groupBy(identity).mapValues(_.size).filter(e
    => e._1 <= e._2).keys.toList.sorted.lastOption.getOrElse(-1l)', "        val freq\
    \ = new HashMap[Long, Long]\n        for (v <- lst) {\n            if (freq.contains(v))\
    \ freq(v) += 1\n            else freq += (v -> 1)\n        }\n        var ret\
    \ = -1l\n        for (k <- freq.keys) {\n            if (k > 0 && freq(k) >= k\
    \ && k > ret) ret = k\n        }\n        ret", "        if (lst.length == 0)\
    \ return -1\n        var maxValue = 0\n        val freq = new HashMap[Long, Int]\n\
    \        for (x <- lst) {\n            if (freq.contains(x)) freq(x) += 1\n  \
    \          else freq(x) = 1\n            if (x > maxValue) maxValue = x.toInt\n\
    \        }\n        var selectedValue = -1\n        for (x <- lst) {\n       \
    \     if (freq(x) >= x && x > selectedValue) selectedValue = x.toInt\n       \
    \ }\n        return selectedValue", "        val freq = new HashMap[Long, Long]\n\
    \        lst.foreach(k => {\n            if (freq.contains(k)) freq(k) += 1\n\
    \            else freq(k) = 1\n        })\n        val lst2 = lst.sortBy(k =>\
    \ -k)\n        for (i <- lst2) {\n            if (freq(i) >= i) return i\n   \
    \     }\n        return -1", "        var mymap = new HashMap[Long, Int]\n   \
    \     lst.foreach(x => {\n            if (mymap.contains(x)) {\n             \
    \   mymap(x) += 1\n            } else {\n                mymap(x) = 1\n      \
    \      }\n        })\n        var answer = -1l\n        for (i <- 1l to lst.length)\
    \ {\n            if (mymap.contains(i) && mymap(i) >= i) {\n                answer\
    \ = i\n            }\n        }\n        return answer", "        val frequencies\
    \ = HashMap[Long, Long]()\n        for (element <- lst) {\n            if (frequencies.contains(element))\
    \ frequencies(element) += 1\n            else frequencies(element) = 1\n     \
    \   }\n        var value = Long.MinValue\n        for (element <- lst) {\n   \
    \         if (element == frequencies(element) && element > value) value = element\n\
    \        }\n        if (value == Long.MinValue) -1 else value", "        val freq\
    \ = new HashMap[Long, Long]()\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1 else freq += (i -> 1)\n        }\n        val x = lst.sorted.find(i\
    \ => freq(i) >= i)\n        if (x.isEmpty) -1 else x.get", "        var frequency\
    \ = Map[Long, Long]()\n        var max = 0l\n        for (i <- lst) {\n      \
    \      frequency(i) = frequency.getOrElse(i, 0l) + 1\n            if (frequency(i)\
    \ >= i && i > max) max = i\n        }\n        if (max == 0) -1 else max", " \
    \       val m = new HashMap[Long, Long]\n        for (i <- lst) m(i) = m.getOrElse(i,\
    \ 0l) + 1\n        val m2 = m.filter(x => x._1 >= x._2)\n        if (m2.size >\
    \ 0) m2.maxBy(_._2)._1 else -1", "        val freq : Map[Long, Long] = Map()\n\
    \        for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n  \
    \          else freq(i) = 1\n        }\n        for (i <- lst.sorted.reverse)\
    \ {\n            if (freq(i) >= i) return i\n        }\n        return -1", " \
    \       val map = lst.groupBy(identity).mapValues(_.size)\n        if (map.keySet.contains(map.values.max))\
    \ {\n            map.keySet.reduceLeft((x, y) => if (x > y) x else y)\n      \
    \  } else {\n            -1\n        }", "        var frequency = Map[Long, Long]()\n\
    \        for (i <- lst) {\n            if (frequency.contains(i)) {\n        \
    \        frequency(i) += 1\n            } else {\n                frequency(i)\
    \ = 1\n            }\n        }\n        var max = (-1l, -1l)\n        for (i\
    \ <- frequency) {\n            if (i._1 <= i._2 && i._1 > max._1) {\n        \
    \        max = i\n            }\n        }\n        max._1", "        val frequency\
    \ = lst.groupBy(identity).mapValues(_.size)\n        frequency.filter(f => f._1\
    \ <= f._2).toList.sortBy(f => (-f._2, f._1)).headOption match {\n            case\
    \ Some(f) => f._1\n            case None => -1\n        }", "        val min =\
    \ lst.min\n        // Hashmap, hold counts of each number\n        val count =\
    \ scala.collection.mutable.HashMap[Long, Int]()\n        // Iterate through list,\
    \ increment each number count by 1\n        for (i <- lst) {\n            if (count.contains(i))\
    \ {\n                count(i) += 1\n            } else {\n                count\
    \ += i -> 1\n            }\n        }\n        // Iterate through all values of\
    \ the HashMap and check if count >= key\n        for (k <- count.keys) {\n   \
    \         if (count(k) >= k && k > min) {\n                return k\n        \
    \    }\n        }\n        return -1", "        //val map = lst.groupBy(x => x).map(x\
    \ => (x._1, x._2.length)).filter(x => x._1 <= x._2).maxBy(x => x._1)\n       \
    \ val map = lst.groupBy(x => x).map(x => (x._1, x._2.length)).filter(x => x._1\
    \ <= x._2).maxBy(x => x._1)\n        if (map._1 == map._2) map._1 else -1", "\t\t\
    var max = 0l\n\t\tvar freq = 0l\n\t\tvar count = 0l\n\t\tval dct = new HashMap[Long,\
    \ Long]()\n\t\tfor (n <- lst) {\n\t\t\tdct.update(n, dct.getOrElse(n, 0l) + 1)\n\
    \t\t}\n\t\tfor (key <- dct.keys) {\n\t\t\tif (key > max && dct(key) >= key) {\n\
    \t\t\t\tmax = key\n\t\t\t\tfreq = dct(key)\n\t\t\t}\n\t\t}\n\t\tmax", "      \
    \  if (lst.length == 0) -1\n        else {\n            var freq = 0\n       \
    \     for (i <- lst.indices) {\n                var num = lst(i)\n           \
    \     if (num == lst(i + 1)) {\n                    freq += 1\n              \
    \  }\n            }\n            if (freq >= num) freq\n            else -1\n\
    \        }", "    \tif (lst.length == 0) return -1\n    \tval longest = lst.foldLeft(0l.toLong)((x,\
    \ y) => if (x < y) y else x)\n    \tval lst2 = lst.map(x => (x, 1l.toLong)).groupBy(_._1).mapValues(_.foldLeft(0l.toLong)((x,\
    \ y) => x + y._2))\n    \tvar r = -1l.toLong\n    \tfor (i <- 1l.toLong to longest)\
    \ {\n    \t\tif (lst2.contains(i) && lst2(i) >= i) {\n    \t\t\tr = i\n    \t\t\
    }\n    \t}\n    \tr", "        var frequencyMap = Map[Long, Long]()\n        for\
    \ (i <- lst) {\n            var frequency = frequencyMap.getOrElse(i, 0l)\n  \
    \          frequencyMap += (i -> (frequency + 1))\n        }\n        var maxValue\
    \ = 0l\n        for (i <- lst) {\n            if (i > 0 && i >= frequencyMap(i)\
    \ && i > maxValue) maxValue = i\n        }\n        if (maxValue == 0) -1l else\
    \ maxValue", "\t\tvar cnt = lst.groupBy(x => x).mapValues(_.size)\n\t\tvar x =\
    \ cnt.filter(x => x._1 > x._2).maxBy(_._1)\n\t\tif (x._1 == x._2) x._1 else -1",
  "        if (lst.size <= 0) -1l else {\n            var maxVal = 0l\n          \
    \  var minVal = Long.MaxValue\n            for (i <- lst) {\n                maxVal\
    \ = max(maxVal, i)\n                minVal = min(minVal, i)\n            }\n \
    \           val count = Array.fill(maxVal.toInt + 1)(0)\n            for (i <-\
    \ lst) count(i.toInt) += 1\n            var result = -1l\n            for (i <-\
    \ count.indices) {\n                if (count(i) >= i && count(i) >= minVal) result\
    \ = i\n            }\n            result\n        }", "        var sorted = List[Long]()\n\
    \        var m = Map[Long, Int]()\n        var ans = -1l\n        for (i <- lst)\
    \ {\n            if (m.contains(i)) m(i) += 1\n            else m(i) = 1\n   \
    \     }\n        for (i <- lst) {\n            if (m(i) >= i && ans < i) ans =\
    \ i\n        }\n        ans", "        val gr = lst.groupBy(identity).mapValues(_.size)\n\
    \        val res = gr.filter(g => g._1 <= g._2).keySet.toList.sorted.lastOption.getOrElse(-1l)\n\
    \        res", "        val map = lst.groupBy(x => x).mapValues(_.size)\n    \
    \    val sorted = map.toList.sortBy(_._1)\n        if (sorted.length == 0) return\
    \ -1l\n        sorted.filter(x => (x._1 <= x._2)).maxBy(_._1)._1", '        lst.groupBy(identity).map(e
    => (e._1, e._2.length)).filter(e => e._1 < e._2).maxBy(e => e._1)._1', "    \t\
    \tif (lst.isEmpty) -1\n    \t\telse {\n    \t\t\tval lst2 = lst.toSet.toList.sorted\n\
    \    \t\t\tdef search(lst : List[Long], prev : Long, sum : Long) : Long = {\n\
    \    \t\t\t\tif (lst.isEmpty) -1\n    \t\t\t\telse {\n    \t\t\t\t\tval curr =\
    \ lst.head\n    \t\t\t\t\tif (prev != curr) {\n    \t\t\t\t\t\tif (curr > sum)\
    \ curr\n    \t\t\t\t\t\telse search(lst.tail, curr, 1)\n    \t\t\t\t\t}\n    \t\
    \t\t\t\telse search(lst.tail, curr, sum + 1)\n    \t\t\t\t}\n    \t\t\t}\n   \
    \ \t\t\tsearch(lst2, 0, 0)\n    \t\t}", "        val m = scala.collection.mutable.Map[Long,\
    \ Int]()\n        for (x <- lst) {\n            if (m.contains(x)) m(x) += 1\n\
    \            else m += (x -> 1)\n        }\n        var max = 0l\n        for\
    \ (x <- m.keys) {\n            if (x == m(x) && x > max) max = x\n        }\n\
    \        if (max == 0) -1 else max", "        var m = lst.groupBy(x => x).mapValues(_.size)\n\
    \        var maxVal = -1l.toLong\n        for (e <- m) {\n            if (e._1\
    \ >= e._2 && e._1 > maxVal) maxVal = e._1\n        }\n        return maxVal",
  "        var map = new HashMap[Long, Long]()\n        lst.foreach(p => {\n     \
    \       if (map.contains(p)) map(p) += 1\n            else map += (p -> 1)\n \
    \       })\n        var res = -1l\n        for (item <- map) {\n            if\
    \ (item._1 == item._2 && item._1 > res) res = item._1\n        }\n        res",
  "        val grouped = lst.groupBy(x => x)\n        val result = grouped.filter(x\
    \ => x._1 >= x._2.length).maxBy(x => x._1)\n        if (result._1 > result._2.length)\
    \ -1 else result._1", "        val xs = lst.sortWith((x, y) => x < y)\n      \
    \  var last = -1l\n        var count = 1\n        for (i <- 0 until xs.length)\
    \ {\n            if (xs(i) == last) {\n                count += 1\n          \
    \  } else {\n                if (xs(i) >= count) return xs(i)\n              \
    \  last = xs(i)\n                count = 1\n            }\n        }\n       \
    \ return -1l", "        var result : Long = -1\n        if (lst.length > 0) {\n\
    \            val freq = lst.groupBy(a => a).map(a => (a._1, a._2.length))\n  \
    \          val freqList = freq.toList.filter(a => a._1 > 0).sortBy(_._1)\n   \
    \         freqList.foreach(a => if (a._2 >= a._1) result = a._1)\n        }\n\
    \        return result", "        var m = new HashMap[Long, Int]()\n        for\
    \ (i <- lst) {\n            if (m.contains(i)) m(i) += 1\n            else m(i)\
    \ = 1\n        }\n        var n = 0\n        for (i <- 1l to lst.length) {\n \
    \           if (m.contains(i) && m(i) >= i) {\n                n = i\n       \
    \     }\n        }\n        if (n == 0) return -1\n        return n", "      \
    \  val m = lst.groupBy(i => i).mapValues(_.size)\n        val sorted = m.toSeq.sortBy(_._1)\n\
    \        val top = sorted.find(t => t._1 <= t._2).getOrElse((-1l, 0))\n      \
    \  if (top._1 == -1) -1l else top._1", "        val dict = lst.foldLeft(HashMap[Long,\
    \ Int]())((acc, x) => acc.get(x) match {\n            case Some(y) => acc += x\
    \ -> (y + 1)\n            case None => acc += x -> 1\n        })\n        (1l\
    \ to lst.max).filter(dict(_) >= _).max", "        val g = lst.groupBy(x => x).map(x\
    \ => (x._1, x._2.length)).toList.filter(x => x._1 > x._2)\n        if (g.length\
    \ == 0) -1l else g.sortBy(x => -x._1).head._1", "        val l = lst.toList.sorted\n\
    \        val m = l.groupBy(identity).mapValues(_.size)\n        var max : Long\
    \ = -1\n        for (i <- l.distinct) {\n            if (m(i) >= i && i > max)\
    \ max = i\n        }\n        return max", "        val freq_map = Map[Long, Long]()\n\
    \        for (v <- lst) {\n            if (freq_map.contains(v)) freq_map(v) +=\
    \ 1\n            else freq_map(v) = 1\n        }\n        val sorted_pairs = freq_map.toList.sortWith(_._2\
    \ > _._2)\n        for (i <- 0 until sorted_pairs.length) {\n            if (sorted_pairs(i)._1\
    \ >= sorted_pairs(i)._2) return sorted_pairs(i)._1\n        }\n        return\
    \ -1", "        var map = new HashMap[Long, Long]()\n        for (i <- lst) map(i)\
    \ = map.getOrElse(i, 0l) + 1\n        var max = 0l\n        var ans = -1l\n  \
    \      for (i <- map.keys) {\n            val freq = map(i)\n            if (freq\
    \ >= i && i > max) {\n                max = i\n                ans = i\n     \
    \       }\n        }\n        ans", "        val table = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            if (table.contains(i)) table.put(i, table(i)\
    \ + 1)\n            else table.put(i, 1)\n        }\n        var max = -1\n  \
    \      for (i <- table.keys) {\n            if (i <= table(i) && i > max) max\
    \ = i.toInt\n        }\n        return max", "        val intOccuranceMap = HashMap[Long,\
    \ Int]()\n        for (x <- lst) {\n            intOccuranceMap.get(x) match {\n\
    \                case Some(i) => intOccuranceMap(x) = i + 1\n                case\
    \ None => intOccuranceMap(x) = 1\n            }\n        }\n        var max :\
    \ Option[Long] = None\n        for (x <- intOccuranceMap.keys) {\n           \
    \ if (intOccuranceMap(x) >= x) {\n                max match {\n              \
    \      case Some(y) => max = Some(max(x, y))\n                    case None =>\
    \ max = Some(x)\n                }\n            }\n        }\n        max match\
    \ {\n            case Some(y) => y\n            case None => -1\n        }", " \
    \       var map = Map[Long, Long]()\n        for (num <- lst) {\n            if\
    \ (map.contains(num)) map(num) += 1 else map(num) = 1\n        }\n        var\
    \ max = -1l\n        for (num <- lst) {\n            if (map(num) >= num && num\
    \ > max) max = num\n        }\n        return max", "        val dic = new mutable.HashMap[Long,\
    \ Int]().withDefaultValue(0)\n        for (item <- lst) {\n            dic(item)\
    \ += 1\n        }\n        val maxKey = dic.maxBy(_._1)._1\n        for (i <-\
    \ maxKey to 1 by -1) {\n            if (dic(i) >= i) return i\n        }\n   \
    \     return -1", "        // Creates a sorted set with all frequencies\n    \
    \    var set = new TreeSet[Long]\n        // Creates a map between integers and\
    \ their frequencies\n        var map = new HashMap[Long, Long]\n        // Fills\
    \ up the map\n        for (num <- lst) {\n            map.put(num, map.getOrElse(num,\
    \ 0l) + 1l)\n        }\n        // Fills up the set\n        for (num <- map.keys)\
    \ {\n            set.add(map(num))\n        }\n        // Iterates the set from\
    \ greatest to smallest\n        for (f <- set.reverse) {\n            for (num\
    \ <- map.keys) {\n                if (f >= num) {\n                    return\
    \ num\n                }\n            }\n        }\n        return -1l", "   \
    \     val m = new HashMap[Long, Long]()\n        for (i <- lst) m(i) = (m.getOrElse(i,\
    \ 0l) + 1l)\n        val s = m.keys.toList.sort(_ < _)\n        s.filter(i =>\
    \ m(i) >= i).lastOption.getOrElse(-1l)", "    \tval m = new HashMap[Long, Int]()\n\
    \    \tfor (i <- lst) {\n    \t\tif (m.contains(i)) m(i) += 1\n    \t\telse m(i)\
    \ = 1\n    \t}\n    \tvar max = (-1).toLong\n    \tfor (i <- lst) {\n    \t\t\
    if (i >= m(i) && i > max) max = i\n    \t}\n    \treturn max", "        val m\
    \ = new HashMap[Long, Long]()\n        for (i <- lst) {\n            if (m.contains(i))\
    \ {\n                m(i) += 1\n            } else {\n                m(i) = 1\n\
    \            }\n        }\n        var ans = -1l\n        for (i <- m.keys) {\n\
    \            if (i <= m(i) && i > ans) {\n                ans = i\n          \
    \  }\n        }\n        ans", "        var lst2 = lst.groupBy(i => i).toList.sortBy(_._1)\n\
    \        var result = lst2.find(i => i._1 == i._2.length)\n        if (result\
    \ == None) return -1\n        return result.get._1", "        // a very good solution\
    \ by someone else in the same course\n        val group = lst.groupBy(identity).map(item\
    \ => (item._1, item._2.length))\n        val res = group.filter(item => item._1\
    \ <= item._2).toList.sortBy(item => item._1).reverse\n        if (res.isEmpty)\
    \ -1 else res.head._1", "        def searchIter(lst : List[Long], freq : List[Long])\
    \ : Long = {\n            if (lst.isEmpty) {\n                var max = -1l.toLong\n\
    \                for (i <- 0 until freq.length) {\n                    if (freq(i)\
    \ >= i + 1) {\n                        max = max max (i + 1)\n               \
    \     }\n                }\n                return max\n            }\n      \
    \      var newFreq = freq.clone\n            newFreq(lst.head.toInt - 1) += 1\n\
    \            return searchIter(lst.tail, newFreq)\n        }\n        return searchIter(lst,\
    \ List.fill(lst.max.toInt)(0l.toLong))", '        lst.distinct.foldLeft(0l)((acc,
    x) => if (lst.count(_ == x) >= x) max(acc, x) else acc)', "        var a : Array[Long]\
    \ = new Array[Long](lst.size)\n        a = lst.toArray\n        var result : Long\
    \ = -1\n        var i : Int = 0\n        while (i < a.size) {\n            if\
    \ (i != 0) {\n                var j : Int = 0\n                var cur : Long\
    \ = a(i)\n                var cnt : Int = 0\n                while (j < i) {\n\
    \                    if (a(j) == cur) cnt += 1\n                    j += 1\n \
    \               }\n                if (cnt + 1 >= cur && cur > result) result\
    \ = cur\n            }\n            i += 1\n        }\n        return result",
  "        if (lst.isEmpty) return -1\n        var m = ListMap[Long, Long]()\n   \
    \     lst.foreach(x => m += (x -> 0))\n        var ans = -1\n        lst.foreach(x\
    \ => m += (x -> (m(x) + 1)))\n        for (x <- m.keys) {\n            if (m(x)\
    \ >= x && x > ans) ans = x\n        }\n        return ans", "        if (lst.isEmpty)\
    \ {\n            return -1l\n        }\n        val m = lst.groupBy(identity).mapValues(_.size)\n\
    \        if (m.isEmpty) {\n            return -1l\n        }\n        return m.maxBy(x\
    \ => (x._2, -x._1))._1", "        // your code here\n        return 0", "    \
    \    if (lst.length == 0) return -1\n        val freq = lst.groupBy(x => x).map(x\
    \ => (x._1, x._2.length)).toList.filter(x => x._1 > 0 && x._1 <= x._2).sortBy(x\
    \ => -x._1)\n        if (freq.length == 0) return -1\n        freq(0)._1", " \
    \       val map = new HashMap[Long, Long]\n        for (x <- lst) {\n        \
    \    if (map.contains(x)) map(x) += 1\n            else map(x) = 1\n        }\n\
    \        val values = map.values.toArray\n        scala.util.Sorting.quickSort(values)\n\
    \        var index = values.length - 1\n        while (index >= 0) {\n       \
    \     if (values(index) >= index + 1) return index + 1\n            index -= 1\n\
    \        }\n        -1", "    \tval lstSorted = lst.sorted.reverse\n    \tval\
    \ lstSortedSet = lstSorted.toSet\n    \tval lstSortedCounter = lstSorted.groupBy(identity).mapValues(_.size)\n\
    \    \tlstSortedSet.foreach(i => if (lstSortedCounter(i) >= i) return i)\n   \
    \ \treturn -1", "        val dist = lst.distinct\n        val result = dist.filter(x\
    \ => lst.count(_ == x) >= x).max\n        if (result > 0) result else -1", " \
    \       val m = ListMap[Long, Int]()\n        lst.foreach(x => {\n           \
    \ if (m.contains(x)) m(x) += 1\n            else m += x -> 1\n        })\n   \
    \     val keys = m.keys.toList.sorted\n        var i = 0\n        while (i < keys.length)\
    \ {\n            if (m(keys(i)) >= keys(i)) return keys(i)\n            i += 1\n\
    \        }\n        -1", "        var m = Map[Long, Long]()\n        for (x <-\
    \ lst) m(x) = m.getOrElse(x, 0l) + 1\n        var res = -1l\n        for (x <-\
    \ lst) {\n            if (m(x) >= x && x > res) res = x\n        }\n        return\
    \ res", "        val groupedLst = lst.groupBy(x => x)\n        val freqLst = groupedLst.values.map(x\
    \ => x.length).toList\n        val maxFreqLst = freqLst.max\n        if (maxFreqLst\
    \ == 0) return -1\n        if (freqLst.diff(List(maxFreqLst)).isEmpty) return\
    \ -1\n        val posLst = freqLst.zipWithIndex.filter(x => x._1 == maxFreqLst).map(x\
    \ => x._2)\n        val retLst = posLst.filter(x => x <= maxFreqLst)\n       \
    \ val maxPos = retLst.max\n        if (maxPos == 0) return -1\n        return\
    \ lst(maxPos)", "        val dic = new HashMap[Long, Long]\n        for (i <-\
    \ lst) {\n            if (dic.contains(i)) dic(i) += 1 else dic(i) = 1\n     \
    \   }\n        var ans = -1l\n        for (i <- lst) {\n            if (dic(i)\
    \ >= i && i > ans) ans = i\n        }\n        ans", "        if (lst.length ==\
    \ 0) return -1l\n        val counts = new HashMap[Long, Long]\n        val maxs\
    \ = new HashMap[Long, Long]\n        for (l <- lst) {\n            if (counts.contains(l))\
    \ counts(l) += 1\n            else counts(l) = 1\n            if (maxs.contains(counts(l)))\
    \ maxs(counts(l)) = max(maxs(counts(l)), l)\n            else maxs(counts(l))\
    \ = l\n        }\n        for (i <- 1l to lst.length) if (maxs.contains(i) &&\
    \ maxs(i) >= i) return maxs(i)\n        return -1l", "        var result : Long\
    \ = -1\n        var m : Map[Long, Long] = lst.groupBy(identity).mapValues(_.size)\n\
    \        for (i <- 1 to m.size) {\n            if (m.contains(i.toLong) && m(i.toLong)\
    \ >= i) result = i.toLong\n        }\n        return result", "        var counter\
    \ = Map[Long, Long]()\n        for (i <- lst) {\n            counter(i) = counter.getOrElse(i,\
    \ 0) + 1\n        }\n        var highest : Long = -1\n        for (i <- counter.keys)\
    \ {\n            if (i <= counter(i) && i > highest) highest = i\n        }\n\
    \        return highest", "        val freq = new HashMap[Long, Long]()\n    \
    \    lst.foreach(x => {\n            if (freq.contains(x)) freq(x) += 1\n    \
    \        else freq(x) = 1\n        })\n        var max = -1l\n        for (k <-\
    \ freq.keys if freq(k) >= k && k > max) max = k\n        return max"]
stop_tokens:
- "\n    }\n"
