language: scala
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.trim.split(\" \").map(x => {\n            var depth\
    \ = 0l\n            var maxDepth = 0l\n            x.foreach(c => {\n        \
    \        if (c == '(') depth += 1\n                else if (c == ')') depth -=\
    \ 1\n                if (depth > maxDepth) maxDepth = depth\n            })\n\
    \            maxDepth\n        }).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028479
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Here stack is a stack of tuples. Tuple (i, j) contains the number\
    \ of opening parentheses up to the\n        // current point and the number of\
    \ closed parentheses up to this point.\n        // When a closing parenthesis\
    \ is found, the tuple (i + 1, j) is added to the stack.\n        // When the number\
    \ of closed parentheses equals the number of opened parentheses, the maximum level\
    \ of\n        // nesting is equal to j + 1.\n        // Example:\n        // Input:\
    \ ((()))\n        // Stack at step 1, 2, 3, 4, 5:\n        // (0, 0)\n       \
    \ // (1, 0)\n        // (1, 1)\n        // (2, 1)\n        // (2, 2)\n       \
    \ // Output: 3\n        var stack = ListBuffer[(Int, Int)]()\n        stack +=\
    \ ((0, 0))\n        var out = ListBuffer[Long]()\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                val (i, j) = stack.last\n  \
    \              stack += ((i + 1, j))\n            } else if (c == ')') {\n   \
    \             val (i, j) = stack.last\n                if (i == j + 1) {\n   \
    \                 out += (j + 1)\n                    stack += ((i, j + 1))\n\
    \                } else {\n                    stack += ((i, j + 1))\n       \
    \         }\n            }\n        }\n        out.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4nplebf8.scala:44)\n\tat Problem.main(tmp4nplebf8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028479
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var paren = List[Char]()\n   \
    \     for (i <- 0 until paren_string.length) {\n            val c = paren_string(i)\n\
    \            if (c == '(') {\n                paren = c :: paren\n           \
    \ } else if (c == ')') {\n                if (paren.length == 0) {\n         \
    \           return List(-1l.toLong)\n                }\n                paren\
    \ = paren.tail\n            } else if (c == ' ') {\n                result = paren.length.toLong\
    \ :: result\n                paren = List[Char]()\n            }\n        }\n\
    \        if (paren.length > 0) {\n            return List(-1l.toLong)\n      \
    \  }\n        result.reverse\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpztw7g6m_.scala:32)\n\tat Problem.main(tmpztw7g6m_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var maximum_levels\
    \ = List[Long]()\n        for (paren_group <- paren_groups) {\n            maximum_levels\
    \ = parseOneNestedParens(paren_group) :: maximum_levels\n        }\n        maximum_levels.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5r1sk072.scala:13:29 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            maximum_levels = parseOneNestedParens(paren_group)\
    \ :: maximum_levels\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: parseOneNestedParens\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028471
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.replaceAll(\" \", \"\").toCharArray\n \
    \       val nestedParens = new ListBuffer[Long]\n        var maxDepth = 0\n  \
    \      var currentDepth = 0\n        for (i <- 0 until parens.length) {\n    \
    \        parens(i) match {\n                case '(' => {\n                  \
    \  currentDepth += 1\n                    maxDepth = max(maxDepth, currentDepth)\n\
    \                }\n                case ')' => {\n                    currentDepth\
    \ -= 1\n                    if (currentDepth == 0) {\n                       \
    \ nestedParens += maxDepth\n                        maxDepth = 0\n           \
    \         }\n                }\n            }\n        }\n        nestedParens.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val groups : Array[String] = paren_string.split(\" \")\n      val nestings\
    \ : ListBuffer[Long] = new ListBuffer[Long]\n      for (group <- groups) {\n \
    \         nestings += getNestingLevel(group)\n      }\n      nestings.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpup0eruea.scala:13:22 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m          nestings += getNestingLevel(group)\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: getNestingLevel\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028471
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // The string could be treated as a stream/list of chars and therefore\
    \ could be parsed using recursive decent.\n        // We use a stack to keep track\
    \ of whether we are within nested parentheses.\n        var paren_level = 0\n\
    \        var nested_parens = List[Long]()\n        for (c <- paren_string) {\n\
    \            c match {\n                case '(' => paren_level += 1\n       \
    \         case ')' => paren_level -= 1\n                case ' ' => {\n      \
    \              if (paren_level > 0) nested_parens = nested_parens :+ paren_level\n\
    \                    paren_level = 0\n                }\n                case\
    \ _ => ()\n            }\n        }\n        nested_parens\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn2k7nsod.scala:28)\n\tat Problem.main(tmpn2k7nsod.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028478
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(x => x.toList.foldLeft(List[Long](),\
    \ 0l)((y, z) => {\n            if (z == '(') (y._1 :+ (y._2 + 1), y._2 + 1)\n\
    \            else if (z == ')') (y._1 :+ (y._2 - 1), y._2 - 1)\n            else\
    \ (y._1, y._2)\n        })._1.map(max(_, 0l)).max).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028479
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        for (group <- paren_string.split(\"\
    \ \")) {\n            var stack = Stack[Char]()\n            var count = 0\n \
    \           var maxCount = 0\n            for (char <- group) {\n            \
    \    if (char == '(') {\n                    stack.push(char)\n              \
    \      count += 1\n                    maxCount = max(maxCount, count)\n     \
    \           } else if (char == ')') {\n                    if (stack.isEmpty)\
    \ throw new Exception(\"Wrong number of parentheses\")\n                    stack.pop\n\
    \                    count -= 1\n                }\n            }\n          \
    \  if (!stack.isEmpty) throw new Exception(\"Wrong number of parentheses\")\n\
    \            result = result :+ maxCount\n        }\n        result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028479
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // This is a recursive function.\n        // Let n be the nesting\
    \ level of parentheses for a group of parentheses.\n        // 0 <= n <= INF\n\
    \        // A group of parentheses is balanced if it starts with an open parenthesis\
    \ and ends with a close parenthesis.\n        // The objective is to compute the\
    \ maximum value of n across all the groups of parentheses.\n        // 0 <= number\
    \ of groups <= INF\n        // The total number of parentheses can be large.\n\
    \        // >>> parseNestedParens(\"((()))\")\n        // 3\n        // >>> parseNestedParens(\"\
    (()()) ((())) () ((())()())\")\n        // List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong)\n        // >>> parseNestedParens(\"((()()(()))((()))) ((())) ()\"\
    )\n        // List[Long](4l.toLong, 3l.toLong, 1l.toLong)\n        // >>> parseNestedParens(\"\
    (((()))((())))\")\n        // 4\n        // >>> parseNestedParens(\"((()()((()))))\"\
    )\n        // 5\n        // >>> parseNestedParens(\"(()())\")\n        // 2\n\
    \        // >>> parseNestedParens(\"()\")\n        // 1\n        // >>> parseNestedParens(\"\
    \")\n        // 0\n        // >>> parseNestedParens(\"()()()\")\n        // 1\n\
    \        // >>> parseNestedParens(\"(())()()\")\n        // 2\n        // >>>\
    \ parseNestedParens(\"(()())(())(()(()))\")\n        // 2\n        // >>> parseNestedParens(\"\
    ((()()(()))((()))) ((())) ()\")\n        // List[Long](4l.toLong, 3l.toLong, 1l.toLong)\n\
    \        def maxNesting(paren_string : String) : Long = {\n            // This\
    \ is a recursive function.\n            // Let n be the nesting level of parentheses\
    \ for a group of parentheses.\n            // 0 <= n <= INF\n            // A\
    \ group of parentheses is balanced if it starts with an open parenthesis and ends\
    \ with a close parenthesis.\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphb62kkm0.scala:54:0 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphb62kkm0.scala:41:55\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mdef\e[0m \e[36mmaxNesting\e\
    [0m(\e[36mparen_string\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e\
    [31m   |\e[0m                                                       ^\e[0m\n\e\
    [31m   |\e[0m                                                       Found:   \
    \ Unit\n\e[31m   |\e[0m                                                      \
    \ Required: Long\n\e[31m42 |\e[0m            \e[34m// This is a recursive function.\e\
    [0m\n\e[31m43 |\e[0m            \e[34m// Let n be the nesting level of parentheses\
    \ for a group of parentheses.\e[0m\n\e[31m44 |\e[0m            \e[34m// 0 <= n\
    \ <= INF\e[0m\n\e[31m45 |\e[0m            \e[34m// A group of parentheses is balanced\
    \ if it starts with an open parenthesis and ends with a close parenthesis.\e[0m\n\
    \e[31m46 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphb62kkm0.scala:53:1\
    \ ---------------------\e[0m\e[0m\n\e[31m53 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmphb62kkm0.scala:47:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m47 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660028477
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def getMaxNesting(str : String) : Long = {\n            val parens\
    \ = str.toList.filter(c => c == '(' || c == ')')\n            var max_nesting\
    \ = 0\n            var cur_nesting = 0\n            for (paren <- parens) {\n\
    \                if (paren == '(') cur_nesting += 1\n                else cur_nesting\
    \ -= 1\n                max_nesting = max(max_nesting, cur_nesting)\n        \
    \    }\n            max_nesting\n        }\n        val groups = paren_string.split(\"\
    \ \")\n        groups.map(getMaxNesting).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028479
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var output = List[Long]()\n        for (paren_string_group <- paren_string.split(\"\
    \ \")) {\n            var stack = Stack[Int]()\n            var max_level = 0\n\
    \            for (i <- 0 until paren_string_group.length) {\n                val\
    \ c = paren_string_group(i)\n                if (c == '(') {\n               \
    \     stack.push(i)\n                } else if (c == ')') {\n                \
    \    stack.pop\n                    if (stack.isEmpty) {\n                   \
    \     max_level = i\n                    } else {\n                        max_level\
    \ = max(max_level, i - stack.top)\n                    }\n                }\n\
    \            }\n            output ::= max_level\n        }\n        output.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv0dslfhb.scala:32)\n\tat Problem.main(tmpv0dslfhb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028479
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result : List[Long] = List[Long]()\n        var current_level\
    \ : Long = 0\n        var current_max : Long = 0\n        for (char <- paren_string)\
    \ {\n            if (char == '(') {\n                current_level += 1\n    \
    \            if (current_level > current_max) current_max = current_level\n  \
    \          }\n            else if (char == ')') {\n                current_level\
    \ -= 1\n            }\n            else if (char == ' ') {\n                result\
    \ = result :+ current_max\n                current_level = 0\n               \
    \ current_max = 0\n            }\n        }\n        result = result :+ current_max\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var i = 0;\n        var res = new ListBuffer[Long]();\n        while\
    \ (i < paren_string.length) {\n            if (paren_string(i) == '(') {\n   \
    \             var j = i + 1;\n                var max = 0l;\n                var\
    \ count = 0l;\n                while (j < paren_string.length) {\n           \
    \         if (paren_string(j) == '(') count += 1;\n                    else if\
    \ (paren_string(j) == ')') {\n                        count -= 1;\n          \
    \              if (count == 0) {\n                            res += max;\n  \
    \                          i = j + 1;\n                            break;\n  \
    \                      }\n                    }\n                    max = max.max(count);\n\
    \                    j += 1;\n                }\n            }\n            else\
    \ i += 1;\n        }\n        return res.toList;\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk6ujoph0.scala:24:28 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                            break;\n\e[31m\e[31m   |\e\
    [0m                            ^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \         Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028472
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list = paren_string.split(\" \").toList\n        val paren_level_list\
    \ = paren_list.map(x => x.filter(x => (x == '(' || x == ')'))).map(x => paren_level(x))\n\
    \        paren_level_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp17i7q4yv.scala:11:99 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparen_level_list\e[0m =\
    \ paren_list.map(\e[36mx\e[0m => x.filter(\e[36mx\e[0m => (x == \e[31m'('\e[0m\
    \ || x == \e[31m')'\e[0m))).map(\e[36mx\e[0m => paren_level(x))\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                                       Not found: paren_level\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660028471
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        //println(parens)\n\
    \        val res = new ListBuffer[Long]\n        for (p <- parens) {\n       \
    \ \tvar maxLevel = 0\n        \tvar curLevel = 0\n        \tfor (i <- 0 until\
    \ p.length) {\n        \t\tif (p(i) == '(') curLevel += 1\n        \t\telse curLevel\
    \ -= 1\n        \t\tmaxLevel = max(maxLevel, curLevel)\n        \t}\n        \t\
    res += maxLevel\n        }\n        res.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028479
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(group => group.scanLeft(0l.toLong)((l,\
    \ c) => if (c == '(') l + 1 else l - 1).max).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = for (paren_group <- paren_groups) yield {\n            val nested_levels =\
    \ paren_group.map(c => if (c == '(') 1 else -1).scanLeft(0)(_ + _).filter(_ >\
    \ 0)\n            nested_levels.max\n        }\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp58b0jiwj.scala:15:15\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        result.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    List[\e\
    [1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e[32mLong\e[0m]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028477
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parentheses_list = paren_string.split(\" \").toList\n       \
    \ parentheses_list.map(x => {\n            if (x.contains(\"()\")) {\n       \
    \         val index = x.indexOf(\"()\")\n                if (index == 0) {\n \
    \                   1\n                } else {\n                    val left\
    \ = x.slice(0, index)\n                    val right = x.slice(index + 2, x.length)\n\
    \                    val left_depth = parseNestedParens(left)\n              \
    \      val right_depth = parseNestedParens(right)\n                    if (left_depth.isEmpty\
    \ && right_depth.isEmpty) {\n                        1\n                    }\
    \ else if (left_depth.isEmpty) {\n                        right_depth.max + 1\n\
    \                    } else if (right_depth.isEmpty) {\n                     \
    \   left_depth.max + 1\n                    } else {\n                       \
    \ max(left_depth.max, right_depth.max) + 1\n                    }\n          \
    \      }\n            } else {\n                1\n            }\n        }).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj2ics88y.scala:37)\n\tat Problem.main(tmpj2ics88y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028479
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parsed = paren_string.split(\" \").toList\n        val result\
    \ = ArrayBuffer[Long]()\n        for (p <- parsed) {\n            var d = 0\n\
    \            var l = 0\n            for (i <- 0 until p.length) {\n          \
    \      if (p(i) == '(') {\n                    d += 1\n                    l =\
    \ max(l, d)\n                } else if (p(i) == ')') {\n                    d\
    \ -= 1\n                }\n            }\n            result += l\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028479
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        groups.map(parseNestedParen).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmfic6li2.scala:11:19 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        groups.map(parseNestedParen).toList\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \            Not found: parseNestedParen\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpmfic6li2.scala:11:36 -----------------------------------------\e[0m\e\
    [0m\n\e[31m11 |\e[0m        groups.map(parseNestedParen).toList\n\e[31m\e[31m\
    \   |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m        \
    \                            No ClassTag available for B\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m                                    where:    B is a type variable\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028477
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val tokens = paren_string.split(\" \")\n      tokens.map(token => parseNestedParensForGroup(token)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm6wj1ugj.scala:11:26 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m      tokens.map(\e[36mtoken\e[0m => parseNestedParensForGroup(token)).toList\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: parseNestedParensForGroup\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpm6wj1ugj.scala:11:59 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m      tokens.map(\e[36mtoken\e[0m => parseNestedParensForGroup(token)).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \   ^\e[0m\n\e[31m   |\e[0m                                          No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                          \
    \                where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660028476
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        var count = 0\n \
    \       var list : List[Long] = List()\n        for (p <- parens) {\n        \
    \    count = 0\n            for (i <- 0 until p.length) {\n                if\
    \ (p(i) == '(') count += 1\n                else if (p(i) == ')') count -= 1\n\
    \            }\n            list = count :: list\n        }\n        list.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_7pva3ew.scala:24)\n\tat Problem.main(tmp_7pva3ew.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028479
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val paren_groups_no_empty\
    \ = paren_groups.filter(x => x.length > 0)\n        val max_nesting_levels = paren_groups_no_empty.map(pg\
    \ => getNestingLevels(pg)).toList\n        max_nesting_levels\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwnjs10p3.scala:12:65 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mmax_nesting_levels\e[0m\
    \ = paren_groups_no_empty.map(\e[36mpg\e[0m => getNestingLevels(pg)).toList\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \       ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \              Not found: getNestingLevels\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpwnjs10p3.scala:12:86 -----------------------------------------\e[0m\e\
    [0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mmax_nesting_levels\e[0m = paren_groups_no_empty.map(\e\
    [36mpg\e[0m => getNestingLevels(pg)).toList\n\e[31m\e[31m   |\e[0m           \
    \                                                                           ^\e\
    [0m\n\e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660028488
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens_groups = paren_string.split(\" \")\n        val ans =\
    \ ArrayBuffer[Long]()\n        for (i <- 0 until parens_groups.length) {\n   \
    \         val parens = parens_groups(i)\n            var c = 0\n            var\
    \ ans1 = 0\n            for (j <- 0 until parens.length) {\n                if\
    \ (parens(j) == '(') c += 1\n                else if (parens(j) == ')') c -= 1\n\
    \                ans1 = max(ans1, c)\n            }\n            ans += ans1\n\
    \        }\n        ans.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028494
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        var output = List[Long]()\n\
    \        for (group <- groups) {\n            var depth = 0\n            var max_depth\
    \ = 0\n            for (i <- 0 until group.length) {\n                val c =\
    \ group(i)\n                if (c == '(') depth += 1\n                else if\
    \ (c == ')') depth -= 1\n                if (depth > max_depth) max_depth = depth\n\
    \            }\n            output = output :+ max_depth\n        }\n        return\
    \ output\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028492
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(x => {\n            val arr = x.toCharArray\n\
    \            var stack = new Stack[Char]\n            var max = 0\n          \
    \  var temp = 0\n            for (i <- 0 until arr.length) {\n               \
    \ if (arr(i) == '(') {\n                    stack.push(arr(i))\n             \
    \       temp += 1\n                    max = max.max(temp)\n                }\n\
    \                else if (arr(i) == ')') {\n                    if (stack.isEmpty)\
    \ return List(0)\n                    else {\n                        stack.pop\n\
    \                        temp -= 1\n                    }\n                }\n\
    \            }\n            if (stack.isEmpty) max.toLong else 0\n        }).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028494
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- paren_groups) {\n            var maximum_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                maximum_depth = max(maximum_depth, depth)\n            }\n  \
    \          result = result :+ maximum_depth\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var nested = List[Long]()\n        var i = 0\n        for (paren\
    \ <- paren_string.split(\" \")) {\n            var stack = new Stack[Char]()\n\
    \            var level = 0\n            for (c <- paren) {\n                if\
    \ (c == '(') {\n                    stack.push(c)\n                    level +=\
    \ 1\n                } else if (c == ')') {\n                    stack.pop()\n\
    \                    level += 1\n                }\n            }\n          \
    \  if (stack.size == 0) nested ::= level\n        }\n        nested.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4barqrkl.scala:29)\n\tat Problem.main(tmp4barqrkl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        parens.map(x => {\n\
    \            val paren = x.toList\n            var count = 0\n            var\
    \ longest = 0\n            paren.foreach(paren => {\n                if (paren\
    \ == '(') {\n                    count += 1\n                    if (count > longest)\
    \ longest = count\n                }\n                else if (paren == ')') count\
    \ -= 1\n            })\n            longest\n        }).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy_wbfouq.scala:23:11\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        parens.map(\e[36mx\e\
    [0m => {\n\e[31m12 |\e[0m            \e[33mval\e[0m \e[36mparen\e[0m = x.toList\n\
    \e[31m13 |\e[0m            \e[33mvar\e[0m \e[36mcount\e[0m = \e[31m0\e[0m\n\e\
    [31m14 |\e[0m            \e[33mvar\e[0m \e[36mlongest\e[0m = \e[31m0\e[0m\n\e\
    [31m15 |\e[0m            paren.foreach(\e[36mparen\e[0m => {\n\e[31m16 |\e[0m\
    \                \e[33mif\e[0m (paren == \e[31m'('\e[0m) {\n\e[31m17 |\e[0m  \
    \                  count += \e[31m1\e[0m\n\e[31m18 |\e[0m                    \e\
    [33mif\e[0m (count > longest) longest = count\n\e[31m19 |\e[0m               \
    \ }\n\e[31m20 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (paren == \e\
    [31m')'\e[0m) count -= \e[31m1\e[0m\n\e[31m21 |\e[0m            })\n\e[31m22 |\e\
    [0m            longest\n\e[31m23 |\e[0m        }).toList\n\e[31m\e[31m   |\e[0m\
    \        ^\e[0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e\
    [31m   |\e[0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660028494
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val items = paren_string.split(\" \")\n      var output : List[Long]\
    \ = List()\n      for (item <- items) {\n        var current_max = 0\n       \
    \ var current_level = 0\n        for (i <- 0 until item.length) {\n          if\
    \ (item(i) == '(') {\n            current_level += 1\n            if (current_level\
    \ > current_max) current_max = current_level\n          } else if (item(i) ==\
    \ ')') {\n            current_level -= 1\n          }\n        }\n        output\
    \ = output :+ current_max\n      }\n      output\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028497
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_group = paren_string.split(\" \")\n        var max_depth\
    \ = 0\n        var depth = 0\n        var max_depths = List[Long]()\n        for\
    \ (pg <- paren_group) {\n            for (p <- pg) {\n                if (p ==\
    \ '(') {\n                    depth += 1\n                    if (depth > max_depth)\
    \ max_depth = depth\n                }\n                else if (p == ')') {\n\
    \                    depth -= 1\n                }\n            }\n          \
    \  max_depths = max_depths :+ max_depth.toLong\n            max_depth = 0\n  \
    \          depth = 0\n        }\n        return max_depths\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val groups = paren_string.split(\" \")\n      val parens = new ArrayBuffer[Long]()\n\
    \      for (group <- groups) {\n        parens += parseNestedParensHelper(group)\n\
    \      }\n      parens.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuwo7vg3e.scala:13:18 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        parens += parseNestedParensHelper(group)\n\e\
    [31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                  Not found: parseNestedParensHelper\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660028492
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val lst = paren_string.split(\" \").toList\n        lst.map(x =>\n\
    \            x.foldLeft(0l)((a, b) =>\n                a + (if (b == '(') 1 else\
    \ -1)).max\n        )\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy2eyb_j3.scala:12:12\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m            x.foldLeft(\e[31m0l\e\
    [0m)((\e[36ma\e[0m, \e[36mb\e[0m) =>\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\
    \e[31m   |\e[0m            Found:    Long => Long\n\e[31m   |\e[0m           \
    \ Required: Long\n\e[31m13 |\e[0m                a + (\e[33mif\e[0m (b == \e[31m'('\e\
    [0m) \e[31m1\e[0m \e[33melse\e[0m -\e[31m1\e[0m)).max\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660028496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def getMaxDepth(pos : Int, parens : String, current_depth : Int,\
    \ max_depth : Int) : (Int, Int) = {\n            if (pos == parens.length) return\
    \ (current_depth, max_depth)\n            parens(pos) match {\n              \
    \  case '(' => getMaxDepth(pos + 1, parens, current_depth + 1, max(current_depth\
    \ + 1, max_depth))\n                case ')' => getMaxDepth(pos + 1, parens, current_depth\
    \ - 1, max(current_depth - 1, max_depth))\n                case _ => getMaxDepth(pos\
    \ + 1, parens, current_depth, max_depth)\n            }\n        }\n        val\
    \ parens = paren_string.replaceAll(\" \", \"\")\n        val depth = getMaxDepth(0,\
    \ parens, 0, 0)._2\n        List[Long](depth.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb13jsyy8.scala:23)\n\tat Problem.main(tmpb13jsyy8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val str_list = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (str <- str_list) {\n            val list = Stack[Char]()\n     \
    \       var max_depth = 0\n            var cur_depth = 0\n            for (c <-\
    \ str) {\n                if (c == '(') {\n                    list.push(c)\n\
    \                    cur_depth += 1\n                    max_depth = max(max_depth,\
    \ cur_depth)\n                } else if (c == ')') {\n                    if (list.isEmpty\
    \ || list.pop() != '(') {\n                        max_depth = -1\n          \
    \              break\n                    }\n                    cur_depth -=\
    \ 1\n                }\n            }\n            if (!list.isEmpty) max_depth\
    \ = -1\n            result ::= max_depth\n        }\n        result.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp185awcmn.scala:24:24 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028491
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var paren_groups_nesting_level\
    \ = List[Long]()\n        paren_groups.foreach(x => {\n            var paren_stack\
    \ = new Stack[Char]()\n            var max_nesting_level = 0\n            var\
    \ current_nesting_level = 0\n            x.foreach(y => {\n                if\
    \ (y == '(') {\n                    paren_stack.push(y)\n                    current_nesting_level\
    \ += 1\n                    if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                else if (y == ')')\
    \ {\n                    paren_stack.pop\n                    current_nesting_level\
    \ -= 1\n                }\n            })\n            paren_groups_nesting_level\
    \ = paren_groups_nesting_level :+ max_nesting_level\n        })\n        paren_groups_nesting_level\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028498
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Map of the parenthesis type to level of the parenthesis.\n   \
    \     var paren_map = Map[Char, Long]()\n        // Extract the groups to be processed.\n\
    \        val groups = paren_string.split(\" \")\n        // Output list.\n   \
    \     var result = List[Long]()\n        // Iterate over the groups and compute\
    \ the result.\n        for (group <- groups) {\n            var max_level = 0l\n\
    \            for (ch <- group) {\n                if (ch == '(') {\n         \
    \           // If the current character is (, then the level will increase.\n\
    \                    paren_map += (ch -> (paren_map.getOrElse(ch, 0l) + 1))\n\
    \                    // Update the maximum.\n                    max_level = max(max_level,\
    \ paren_map(ch))\n                } else if (ch == ')') {\n                  \
    \  // If the current character is ), then the level will decrease.\n         \
    \           paren_map += (ch -> (paren_map.getOrElse(ch, 0l) - 1))\n         \
    \       }\n            }\n            // Compute the maximum depth for this group.\n\
    \            val depth = (max_level - paren_map.getOrElse(')', 0l))\n        \
    \    // Update the result for this group.\n            result = depth :: result\n\
    \        }\n        // Return the result in the reverse order.\n        result.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvtjjylx6.scala:39)\n\tat Problem.main(tmpvtjjylx6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028499
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var stack : List[Int] = List.empty\n        var maxDepth : Long =\
    \ 0\n        for (ch <- paren_string) {\n            if (ch == '(') {\n      \
    \          stack = stack :+ 0\n            } else if (ch == ')') {\n         \
    \       stack = stack.dropRight(1)\n            } else if (ch == ' ') {\n    \
    \            if (stack.length > maxDepth) maxDepth = stack.length\n          \
    \  }\n        }\n        if (stack.length > maxDepth) maxDepth = stack.length\n\
    \        List.fill(paren_string.count(_ == ' ') + 1)(maxDepth)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbq3ird31.scala:25)\n\tat Problem.main(tmpbq3ird31.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028498
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val char_array = paren_string.toCharArray\n        val result = ArrayBuffer[Long]()\n\
    \        var depth = 0\n        for (i <- 0 until char_array.length) {\n     \
    \       char_array(i) match {\n                case '(' => depth += 1\n      \
    \          case ')' => {\n                    result += depth\n              \
    \      depth -= 1\n                }\n                case _ =>\n            }\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_vp9dthl.scala:26)\n\tat Problem.main(tmp_vp9dthl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val open = \"(\"\n        val close = \")\"\n        val groups =\
    \ paren_string.split(\" \")\n        val num = groups.length\n        val group_list\
    \ = new ListBuffer[String]\n        for (i <- 0 until num) {\n            group_list\
    \ += groups(i)\n        }\n        val result = new ListBuffer[Long]\n       \
    \ for (i <- 0 until num) {\n            result += parseNestedParensHelper(group_list(i),\
    \ open, close)\n        }\n        return result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3fzcu9mg.scala:20:22 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            result += parseNestedParensHelper(group_list(i),\
    \ open, close)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: parseNestedParensHelper\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028493
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val split_paren_string = paren_string.split(\" \")\n        // println(split_paren_string)\n\
    \        var nesting_levels = new ListBuffer[Long]()\n        for (str <- split_paren_string)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (ch <- str) {\n                if (ch == '(') level += 1\n                else\
    \ if (ch == ')') level -= 1\n                if (level > max_level) max_level\
    \ = level\n            }\n            nesting_levels += max_level\n        }\n\
    \        return nesting_levels.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028500
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_level = 0\n        var level = 0\n        var parentheses\
    \ = List[Long]()\n        for (ch <- paren_string) {\n            if (ch == '(')\
    \ {\n                level += 1\n                max_level = max(max_level, level)\n\
    \            } else if (ch == ')') {\n                level -= 1\n           \
    \ } else if (ch == ' ') {\n                parentheses = max_level :: parentheses\n\
    \                max_level = 0\n                level = 0\n            }\n   \
    \     }\n        parentheses.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfsd84fh5.scala:28)\n\tat Problem.main(tmpfsd84fh5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028499
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val result = ListBuffer[Long]()\n        for (group <- paren_string.split(\"\
    \ \")) {\n            var max_depth = 0\n            var cur_depth = 0\n     \
    \       for (c <- group) {\n                if (c == '(') {\n                \
    \    cur_depth += 1\n                    max_depth = max(max_depth, cur_depth)\n\
    \                } else if (c == ')') {\n                    cur_depth -= 1\n\
    \                }\n            }\n            result += max_depth\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        var results = List[Long]()\n\
    \        for (g <- groups) {\n            results = results :+ maxNestedLevel(g)\n\
    \        }\n        results\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpidy1fn86.scala:13:33 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            results = results :+ maxNestedLevel(g)\n\e\
    [31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 Not found: maxNestedLevel\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660028494
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        val ret = new ListBuffer[Long]()\n\
    \        for (group <- groups) {\n            var depthest = 0\n            var\
    \ depth = 0\n            for (c <- group) {\n                if (c == '(') depth\
    \ += 1\n                else depth -= 1\n                depthest = max(depthest,\
    \ depth)\n            }\n            ret += depthest\n        }\n        ret.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028500
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(paren_group => paren_group.toList.foldLeft(0l.toLong,\
    \ 0l.toLong, 0l.toLong){ case ((deepest, curr_depth, max_depth), char) =>\n  \
    \          char match {\n                case '(' => (max(deepest, curr_depth\
    \ + 1), curr_depth + 1, max_depth)\n                case ')' => (max(deepest,\
    \ curr_depth), curr_depth - 1, max_depth)\n                case _ => (deepest,\
    \ curr_depth, max_depth)\n            }\n        }._1).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028511
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(x => getDeepestLevelOfNesting(x)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn_8jvt7t.scala:10:41 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e[31m\" \"\e[0m).map(\e[36mx\e\
    [0m => getDeepestLevelOfNesting(x)).toList\n\e[31m\e[31m   |\e[0m            \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                    Not found: getDeepestLevelOfNesting\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpn_8jvt7t.scala:10:69 -----------------------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e[31m\" \"\e[0m).map(\e[36mx\e\
    [0m => getDeepestLevelOfNesting(x)).toList\n\e[31m\e[31m   |\e[0m            \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                          No ClassTag available for B\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m                                          where:  \
    \  B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660028508
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Create an empty queue for our solution\n        val nestedParens\
    \ = new Queue[Long]\n        // Create an iterable for the string\n        val\
    \ parens = paren_string.iterator\n        // Set a variable for the current level\
    \ of nesting\n        var currentLevel = 0l\n        // Take the first character\
    \ from the string\n        val paren = parens.next\n        // This while loop\
    \ is to go through the entire string\n        while (parens.hasNext) {\n     \
    \       // If the current character is an open paren, increment the level\n  \
    \          if (paren == '(') currentLevel += 1\n            // If the current\
    \ character is a closed paren, then either add the current level of nesting to\
    \ the queue\n            // or do nothing if it is negative (this means it is\
    \ outside of the group)\n            else if (paren == ')') {\n              \
    \  if (currentLevel > 0) nestedParens += currentLevel\n                currentLevel\
    \ -= 1\n            }\n            // If the current character is a space, then\
    \ add the current level of nesting if it is positive\n            // to the queue,\
    \ and reset the current level to 0 because we are outside of the group\n     \
    \       else if (paren == ' ') {\n                if (currentLevel > 0) nestedParens\
    \ += currentLevel\n                currentLevel = 0\n            }\n         \
    \   // Take the next character from the string\n            paren = parens.next\n\
    \        }\n        // Convert the queue to a list to match the output signature\n\
    \        nestedParens.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp9d66bx88.scala:35:18 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            paren = parens.next\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val paren\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028504
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var level = 0\n        var max_level = 0\n        var result = new\
    \ ListBuffer[Long]()\n        for (i <- 0 until paren_string.length) {\n     \
    \       if (paren_string(i) == '(') {\n                level += 1\n          \
    \      max_level = max(max_level, level)\n            } else if (paren_string(i)\
    \ == ')') {\n                level -= 1\n            } else if (paren_string(i)\
    \ == ' ') {\n                result += max_level\n                max_level =\
    \ 0\n                level = 0\n            }\n        }\n        result += max_level\n\
    \        return result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val m = \"((()))\".toList\n      val nested_parens = paren_string.split(\"\
    \ \").map(paren => paren.toList)\n      nested_parens.map(paren => deepestParenthesesNesting(paren)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw1rowjjl.scala:12:33 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m      nested_parens.map(\e[36mparen\e[0m => deepestParenthesesNesting(paren)).toList\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Not found: deepestParenthesesNesting\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpw1rowjjl.scala:12:66 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m      nested_parens.map(\e[36mparen\e[0m => deepestParenthesesNesting(paren)).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \          ^\e[0m\n\e[31m   |\e[0m                                          No\
    \ ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                 \
    \                         where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660028510
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_regex = new Regex(\"\\\\(+\\\\)+\")\n        val paren_groups\
    \ = paren_regex.findAllIn(paren_string).toList\n        paren_groups.map(x =>\
    \ x.length.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw_pa6f_w.scala:10:30 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mparen_regex\e[0m = \e[33mnew\e\
    [0m \e[35mRegex\e[0m(\e[31m\"\\\\(+\\\\)+\"\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \      Not found: type Regex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028504
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = paren_groups.map(group => {\n            // Parse paren group\n          \
    \  val paren_stack = new Stack[Char]\n            var depth = 0\n            var\
    \ max_depth = 0\n            group.foreach(paren => {\n                if (paren\
    \ == '(') {\n                    paren_stack.push(paren)\n                   \
    \ depth += 1\n                    max_depth = max(max_depth, depth)\n        \
    \        } else if (paren == ')') {\n                    paren_stack.pop\n   \
    \                 depth -= 1\n                }\n            })\n            max_depth\n\
    \        }).toList\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp29pxgd4q.scala:28:8\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Int])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028513
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        return paren_string.split(\" \").toList.map(i => {\n            var\
    \ level = 0\n            var max = 0\n            i.foreach(c => {\n         \
    \       if (c == '(') {\n                    level += 1\n                    max\
    \ = max.max(level)\n                } else if (c == ')') {\n                 \
    \   level -= 1\n                }\n            })\n            max\n        })\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028515
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_array = paren_string.split(\" \")\n        val count_list\
    \ = new ListBuffer[Long]()\n        for (i <- 0 until paren_array.length) {\n\
    \            val paren = paren_array(i)\n            val count = new ListBuffer[Long]()\n\
    \            var depth = 0l\n            for (j <- 0 until paren.length) {\n \
    \               val p = paren(j)\n                if (p == '(') {\n          \
    \          depth += 1\n                } else if (p == ')') {\n              \
    \      count += depth\n                    depth -= 1\n                }\n   \
    \         }\n            count_list += count.max\n        }\n        count_list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028516
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(x => {\n          var stack = Stack[Char]()\n\
    \          var maxdepth = 0\n          var depth = 0\n          for (i <- 0 until\
    \ x.length) {\n            x(i) match {\n              case '(' => {\n       \
    \         stack.push('(')\n                depth += 1\n                maxdepth\
    \ = max(maxdepth, depth)\n              }\n              case ')' => {\n     \
    \           stack.pop\n                depth -= 1\n              }\n         \
    \   }\n          }\n          maxdepth\n        }).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp81jql_u_.scala:28:11\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e\
    [31m\" \"\e[0m).map(\e[36mx\e[0m => {\n\e[31m11 |\e[0m          \e[33mvar\e[0m\
    \ \e[36mstack\e[0m = Stack[\e[35mChar\e[0m]()\n\e[31m12 |\e[0m          \e[33mvar\e\
    [0m \e[36mmaxdepth\e[0m = \e[31m0\e[0m\n\e[31m13 |\e[0m          \e[33mvar\e[0m\
    \ \e[36mdepth\e[0m = \e[31m0\e[0m\n\e[31m14 |\e[0m          \e[33mfor\e[0m (i\
    \ <- \e[31m0\e[0m until x.length) {\n\e[31m15 |\e[0m            x(i) \e[33mmatch\e\
    [0m {\n\e[31m16 |\e[0m              \e[33mcase\e[0m \e[31m'('\e[0m => {\n\e[31m17\
    \ |\e[0m                stack.push(\e[31m'('\e[0m)\n\e[31m18 |\e[0m          \
    \      depth += \e[31m1\e[0m\n\e[31m19 |\e[0m                maxdepth = max(maxdepth,\
    \ depth)\n\e[31m20 |\e[0m              }\n\e[31m21 |\e[0m              \e[33mcase\e\
    [0m \e[31m')'\e[0m => {\n\e[31m22 |\e[0m                stack.pop\n\e[31m23 |\e\
    [0m                depth -= \e[31m1\e[0m\n\e[31m24 |\e[0m              }\n\e[31m25\
    \ |\e[0m            }\n\e[31m26 |\e[0m          }\n\e[31m27 |\e[0m          maxdepth\n\
    \e[31m28 |\e[0m        }).toList\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m       \
    \ Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028514
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      // Given a string of parens, output the maximum nesting of parentheses\n\
    \      // Example:\n      // >>> getMaxNesting(\"((()))()((())())\")\n      //\
    \ 3\n      def getMaxNesting(paren_string : String) : Long = {\n        var depth\
    \ = 0\n        var max_depth = 0\n        for (c <- paren_string) {\n        \
    \  if (c == '(') depth += 1\n          else depth -= 1\n          max_depth =\
    \ max(max_depth, depth)\n        }\n        max_depth\n      }\n      paren_string.split(\"\
    \ \").map(getMaxNesting(_)).toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.trim.split(\" \").toList.map(x => getNesting(x.toList))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj9woz4x3.scala:10:53 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.trim.split(\e[31m\" \"\e[0m).toList.map(\e\
    [36mx\e[0m => getNesting(x.toList))\n\e[31m\e[31m   |\e[0m                   \
    \                                  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                         Not found: getNesting\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660028510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var results = new ListBuffer[Long]()\n        for (group <- paren_string.split(\"\
    \ \")) {\n            var max_level = 0\n            var current_level = 0\n \
    \           for (c <- group) {\n                if (c == '(') {\n            \
    \        current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            results += max_level\n    \
    \    }\n        return results.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      // Put your code here\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo9fq5nfd.scala:9:64\
    \ ---------------------\e[0m\e[0m\n\e[31m 9 |\e[0m    \e[33mdef\e[0m \e[36mparseNestedParens\e\
    [0m(\e[36mparen_string\e[0m : \e[35mString\e[0m) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \                 Found:    Unit\n\e[31m   |\e[0m                            \
    \                        Required: List[Long]\n\e[31m10 |\e[0m      \e[34m// Put\
    \ your code here\e[0m\n\e[31m11 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028516
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        val results = for\
    \ (group <- groups) yield parseNestedParensInGroup(group)\n        results.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqb2hy2ap.scala:11:50 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresults\e[0m = \e[33mfor\e\
    [0m (group <- groups) \e[33myield\e[0m parseNestedParensInGroup(group)\n\e[31m\e\
    [31m   |\e[0m                                                  ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Not found: parseNestedParensInGroup\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpqb2hy2ap.scala:11:81 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresults\e[0m = \e[33mfor\e\
    [0m (group <- groups) \e[33myield\e[0m parseNestedParensInGroup(group)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \      No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m         \
    \                                 where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660028517
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_stack = new ListBuffer[Char]\n        var cur_level = 0\n\
    \        var max_level = 0\n        var result = new ListBuffer[Long]\n      \
    \  paren_string.foreach(c => {\n            if (c == '(') {\n                paren_stack\
    \ += c\n                cur_level += 1\n                max_level = max(max_level,\
    \ cur_level)\n            } else if (c == ')') {\n                if (paren_stack.size\
    \ > 0) {\n                    paren_stack.remove(paren_stack.size - 1)\n     \
    \               cur_level -= 1\n                } else {\n                   \
    \ cur_level = 0\n                }\n            } else if (c == ' ') {\n     \
    \           if (paren_stack.size == 0) {\n                    result += max_level\n\
    \                    max_level = 0\n                    cur_level = 0\n      \
    \          }\n            }\n        })\n        if (paren_stack.size == 0) result\
    \ += max_level\n        return result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var groups = paren_string.split(\" \")\n        var max_levels :\
    \ List[Long] = List[Long]()\n        for (group <- groups) {\n            max_levels\
    \ = max_levels :+ processParenGroup(group)\n        }\n        return max_levels\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1vzzc2tb.scala:13:39 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            max_levels = max_levels :+ processParenGroup(group)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Not found: processParenGroup\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028513
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the string into groups of parenthesis\n        val paren_groups\
    \ = paren_string.split(\" \")\n        // Iterate over each group and find the\
    \ maximum level of nesting of parenthesis.\n        // That is done by keeping\
    \ a count of the number of '(' and ')'\n        var max_nesting = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var nesting = 0\n        \
    \    var max_nesting_so_far = 0\n            for (char <- group) {\n         \
    \       if (char == '(') nesting += 1\n                else if (char == ')') nesting\
    \ -= 1\n                max_nesting_so_far = max(max_nesting_so_far, nesting)\n\
    \            }\n            max_nesting = max_nesting :+ max_nesting_so_far\n\
    \        }\n        return max_nesting\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Using an integer to represent the current level of nesting.\n\
    \        // We will constantly update this during the parsing.\n        // >>>\
    \ parseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))\n        val parsed_parens = paren_string.split(\"\
    \ \").map(x => {\n            var level = 0\n            var max_level = 0\n \
    \           var i = 0\n            while (i < x.length) {\n                if\
    \ (x(i) == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (x(i) == ')') {\n       \
    \             level -= 1\n                }\n                i += 1\n        \
    \    }\n            max_level\n        }).toList\n        parsed_parens\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn_5s65mv.scala:29:8\
    \ ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m        parsed_parens\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (parsed_parens\
    \ : List[Int])\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660028518
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (paren_group <- paren_groups) {\n            var\
    \ nest_level = 0\n            var max_nest_level = 0\n            for (paren <-\
    \ paren_group) {\n                if (paren == '(') nest_level += 1\n        \
    \        else if (paren == ')') nest_level -= 1\n                if (nest_level\
    \ > max_nest_level) max_nest_level = nest_level\n            }\n            result\
    \ = result :+ max_nest_level\n        }\n        return result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var parens = paren_string.split(\" \").toList\n        for (paren\
    \ <- parens) {\n            if (paren.length % 2 != 0) {\n                return\
    \ List()\n            }\n        }\n        var result = new ListBuffer[Long]()\n\
    \        for (paren <- parens) {\n            var counts = new ListBuffer[Long]()\n\
    \            var current_count = 0\n            for (c <- paren) {\n         \
    \       if (c == '(') {\n                    current_count += 1\n            \
    \    } else {\n                    counts += current_count\n                 \
    \   current_count -= 1\n                }\n            }\n            result +=\
    \ counts.max\n        }\n        return result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.trim.split(\" \")\n        var result\
    \ : List[Long] = List()\n        for (group <- paren_groups) {\n            var\
    \ max_nesting : Long = 0\n            var nesting : Long = 0\n            for\
    \ (i <- 0 until group.length) {\n                if (group(i) == '(') {\n    \
    \                nesting += 1\n                    max_nesting = max(max_nesting,\
    \ nesting)\n                } else if (group(i) == ')') {\n                  \
    \  nesting -= 1\n                }\n            }\n            result = result\
    \ :+ max_nesting\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028521
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Keep track of current level of nesting.\n        // Have to be\
    \ careful to start with 1 as no nesting is allowed if the first character is \"\
    )\"\n        var current_nesting_level = 1\n        var max_nesting_level = 1\n\
    \        var results = List[Long]()\n        for (i <- paren_string) {\n     \
    \       if (i == '(') {\n                current_nesting_level += 1\n        \
    \        if (current_nesting_level > max_nesting_level) {\n                  \
    \  max_nesting_level = current_nesting_level\n                }\n            }\
    \ else if (i == ')') {\n                if (current_nesting_level == 1) {\n  \
    \                  // Cannot have a closing bracket at the first character.\n\
    \                    // Therefore, stop parsing and return empty list.\n     \
    \               return List[Long]()\n                }\n                current_nesting_level\
    \ -= 1\n            } else if (i == ' ') {\n                results = max_nesting_level\
    \ :: results\n                current_nesting_level = 1\n                max_nesting_level\
    \ = 1\n            }\n        }\n        results = max_nesting_level :: results\n\
    \        results.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp__eu2756.scala:38)\n\tat Problem.main(tmp__eu2756.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parenthesis_strings = paren_string.split(\" \")\n        val\
    \ parenthesis_groups = parenthesis_strings.map(x => x.toList)\n        parenthesis_groups.map(group\
    \ => {\n            var max_depth = 0\n            var current_depth = 0\n   \
    \         group.foreach(char => {\n                if (char == '(') current_depth\
    \ += 1\n                else if (char == ')') current_depth -= 1\n           \
    \     if (current_depth > max_depth) max_depth = current_depth\n            })\n\
    \            max_depth\n        }).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_rn5hdjm.scala:21:11\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        parenthesis_groups.map(\e\
    [36mgroup\e[0m => {\n\e[31m13 |\e[0m            \e[33mvar\e[0m \e[36mmax_depth\e\
    [0m = \e[31m0\e[0m\n\e[31m14 |\e[0m            \e[33mvar\e[0m \e[36mcurrent_depth\e\
    [0m = \e[31m0\e[0m\n\e[31m15 |\e[0m            group.foreach(\e[36mchar\e[0m =>\
    \ {\n\e[31m16 |\e[0m                \e[33mif\e[0m (char == \e[31m'('\e[0m) current_depth\
    \ += \e[31m1\e[0m\n\e[31m17 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m\
    \ (char == \e[31m')'\e[0m) current_depth -= \e[31m1\e[0m\n\e[31m18 |\e[0m    \
    \            \e[33mif\e[0m (current_depth > max_depth) max_depth = current_depth\n\
    \e[31m19 |\e[0m            })\n\e[31m20 |\e[0m            max_depth\n\e[31m21\
    \ |\e[0m        }).toList\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m\
    \        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required:\
    \ List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028524
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var level_array = new ArrayBuffer[Long]\n        var current_level\
    \ = 0l\n        var i = 0\n        while (i < paren_string.length) {\n       \
    \     if (paren_string(i) == '(') {\n                current_level += 1\n    \
    \        } else if (paren_string(i) == ')') {\n                current_level -=\
    \ 1\n            } else if (paren_string(i) == ' ') {\n                level_array\
    \ += current_level\n                current_level = 0\n            }\n       \
    \     i += 1\n        }\n        level_array += current_level\n        return\
    \ level_array.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2wwwg_sf.scala:28)\n\tat Problem.main(tmp2wwwg_sf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      paren_string.split(\" \").map(getNestedDepth).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl_53fyrf.scala:10:34 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m      paren_string.split(\e[31m\" \"\e[0m).map(getNestedDepth).toList\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                  Not found: getNestedDepth\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpl_53fyrf.scala:10:49 -----------------------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m      paren_string.split(\e[31m\" \"\e[0m).map(getNestedDepth).toList\n\
    \e[31m\e[31m   |\e[0m                                                 ^\e[0m\n\
    \e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660028527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val g = paren_string.split(\" \")\n      val l = new ListBuffer[Long]()\n\
    \      for (i <- 0 until g.length) {\n        l += parseNestedParensHelper(g(i))\n\
    \      }\n      l.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp14g5dsrt.scala:13:13 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        l += parseNestedParensHelper(g(i))\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \       Not found: parseNestedParensHelper\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(x => parseSingleNestedParens(x)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2a8xav6m.scala:10:41 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e[31m\" \"\e[0m).map(\e[36mx\e\
    [0m => parseSingleNestedParens(x)).toList\n\e[31m\e[31m   |\e[0m             \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                   Not found: parseSingleNestedParens\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp2a8xav6m.scala:10:68 -----------------------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e[31m\" \"\e[0m).map(\e[36mx\e\
    [0m => parseSingleNestedParens(x)).toList\n\e[31m\e[31m   |\e[0m             \
    \                                                       ^\e[0m\n\e[31m   |\e[0m\
    \                                          No ClassTag available for B\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m                                          where:  \
    \  B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660028528
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        groups.map(group\
    \ => {\n            var depth = 0l\n            var max_depth = 0l\n         \
    \   for (c <- group) {\n                if (c == '(') {\n                    depth\
    \ += 1\n                    max_depth = max(max_depth, depth)\n              \
    \  } else if (c == ')') {\n                    depth -= 1\n                }\n\
    \            }\n            max_depth\n        }).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028533
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Write your code here.\n        val parentheses = paren_string.split(\"\
    \ \")\n        val parenDeep = ListBuffer[Long]()\n        for (paren <- parentheses)\
    \ {\n            val strChar = paren.toCharArray\n            var deep = 0\n \
    \           var maxDeep = 0\n            for (i <- 0 until strChar.length) {\n\
    \                if (strChar(i) == '(') {\n                    deep += 1\n   \
    \                 if (deep > maxDeep) maxDeep = deep\n                } else if\
    \ (strChar(i) == ')') {\n                    deep -= 1\n                }\n  \
    \          }\n            parenDeep += maxDeep\n        }\n        parenDeep.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028534
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(_.toList).map(parenGroup => parenGroup.foldLeft(List[Long](0))((accum,\
    \ paren) => {\n            if (paren == '(') accum :+ (accum.last + 1)\n     \
    \       else accum :+ (accum.last - 1)\n        }).max).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028536
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the string on each space character to get individual groups\
    \ of parentheses\n        val split_paren_string = paren_string.split(\" \")\n\
    \        val split_paren_list = split_paren_string.toList\n        // Iterate\
    \ over the list of groups to find the deepest level of nesting for each group\n\
    \        val nesting_depth_list = for (group <- split_paren_list) yield {\n  \
    \          var stack = Stack[Char]()\n            var max_depth = 0\n        \
    \    for (paren <- group) {\n                paren match {\n                 \
    \   case '(' => {\n                        stack.push(paren)\n               \
    \         max_depth = max(max_depth, stack.size)\n                    }\n    \
    \                case ')' => {\n                        stack.pop\n          \
    \          }\n                    case _ => ()\n                }\n          \
    \  }\n            max_depth\n        }\n        nesting_depth_list\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwae749j3.scala:31:8\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m        nesting_depth_list\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    (nesting_depth_list : List[Int])\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the string based on spaces\n        val parens = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (i <- 0 until\
    \ parens.length) {\n            var paren = parens(i)\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (j <- 0 until paren.length)\
    \ {\n                if (paren(j) == '(') {\n                    depth += 1\n\
    \                    if (depth > max_depth) {\n                        max_depth\
    \ = depth\n                    }\n                } else if (paren(j) == ')')\
    \ {\n                    depth -= 1\n                }\n            }\n      \
    \      result += max_depth\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028536
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(x => x.toCharArray.filter(x => x ==\
    \ '(' || x == ')').foldLeft(List[Long](0l.toLong))((q, c) => {\n          if (c\
    \ == '(') {\n            q.slice(0, q.length - 1) :+ (q.last + 1)\n          }\
    \ else {\n            q.slice(0, q.length - 1) :+ (q.last - 1)\n          }\n\
    \        }).last).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpixxx59ph.scala:19)\n\tat Problem.main(tmpixxx59ph.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028537
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Build a list of lists of characters.\n        // The level of\
    \ the lists represent the nesting of parens.\n        // E.g. (()()) is represented\
    \ as List(List(('(', 0), (')', 1), ('(', 0), (')', 1), ('(', 0), (')', 1)))\n\
    \        val paren_chars : List[List[(Char, Int)]] = paren_string.toList.foldLeft(List(List[(Char,\
    \ Int)]()))((acc, char) => {\n            if (char == '(') {\n               \
    \ val new_list = List[(Char, Int)]()\n                val new_nested_list = new_list\
    \ :: acc\n                new_nested_list\n            } else if (char == ')')\
    \ {\n                val next_list = (')', acc.head.head._2 + 1) :: acc.head\n\
    \                val new_nested_list = next_list :: acc.tail\n               \
    \ new_nested_list\n            } else if (char == ' ') {\n                acc\n\
    \            } else {\n                throw new IllegalArgumentException(\"Invalid\
    \ character: \" + char)\n            }\n        })\n        // Returns the deepest\
    \ level of nesting of parens.\n        paren_chars.map(list => list.map(paren_char\
    \ => paren_char._2).max)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.$anonfun$1(tmp_jvcjnlt.scala:19)\n\
    \tat Problem$.$anonfun$adapted$1(tmp_jvcjnlt.scala:27)\n\tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\
    \tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\
    \tat Problem$.parseNestedParens(tmp_jvcjnlt.scala:27)\n\tat Problem$.main(tmp_jvcjnlt.scala:32)\n\
    \tat Problem.main(tmp_jvcjnlt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028538
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var res = List[Long]()\n        var parens = List[Char]()\n     \
    \   var current_level = 0l\n        var max_level = 0l\n        var i = 0\n  \
    \      while (i < paren_string.length) {\n            val c = paren_string(i)\n\
    \            if (c == '(') {\n                current_level += 1\n           \
    \     max_level = max(max_level, current_level)\n                parens ::= c\n\
    \            } else if (c == ')') {\n                parens ::= c\n          \
    \      current_level -= 1\n            } else if (c == ' ') {\n              \
    \  res ::= max_level\n                max_level = 0\n                parens =\
    \ List[Char]()\n            }\n            i += 1\n        }\n        res.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8xbz_e2w.scala:34)\n\tat Problem.main(tmp8xbz_e2w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028537
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(x => {\n        \tval chars = x.toCharArray\n\
    \        \tvar max_level = 0l\n        \tvar level = 0l\n        \tfor (i <- 0\
    \ until chars.length) {\n        \t\tchars(i) match {\n        \t\t\tcase '('\
    \ => level += 1\n        \t\t\tcase ')' => level -= 1\n        \t\t\tcase _ =>\n\
    \        \t\t}\n        \t\tmax_level = max(max_level, level)\n        \t}\n \
    \       \tmax_level\n        }).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val parens = paren_string.split(\" \")\n      var max_nest_level =\
    \ 0\n      var nested_parens = List[Long]()\n      for (paren <- parens) {\n \
    \       var nest_level = 0\n        var max_nest_level = 0\n        for (ch <-\
    \ paren) {\n          if (ch == '(') {\n            nest_level += 1\n        \
    \    if (nest_level > max_nest_level) {\n              max_nest_level = nest_level\n\
    \            }\n          } else if (ch == ')') {\n            nest_level -= 1\n\
    \          }\n        }\n        nested_parens = nested_parens :+ max_nest_level\n\
    \      }\n      nested_parens\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028539
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Remove spaces from input, split paren_string into individual groups\
    \ separated by ')'.\n        val groups = paren_string.replaceAll(\"\\\\s\", \"\
    \").split(')').filter(!_.isEmpty)\n        groups.map(group => countParentheses(group)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaifz3n75.scala:12:28 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        groups.map(\e[36mgroup\e[0m => countParentheses(group)).toList\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: countParentheses\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpaifz3n75.scala:12:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        groups.map(\e[36mgroup\e[0m => countParentheses(group)).toList\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660028537
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // The stack is used to simulate nested parentheses algorithm.\n\
    \        var stk = new Stack[Int]()\n        var depth = 0\n        var max_depth\
    \ = 0\n        for (c <- paren_string) {\n            if (c == '(') {\n      \
    \          depth += 1\n                max_depth = max(max_depth, depth)\n   \
    \             stk.push(depth)\n            } else if (c == ')') {\n          \
    \      stk.pop()\n                depth -= 1\n            }\n        }\n     \
    \   return List[Long](max_depth.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprhz8wq0q.scala:27)\n\tat Problem.main(tmprhz8wq0q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      var max_depth : Long = 0\n      var depth : Long = 0\n      for (paren\
    \ <- paren_string.toList) {\n          if (paren == '(') depth += 1\n        \
    \  else if (paren == ')') depth -= 1\n          max_depth = max(max_depth, depth)\n\
    \      }\n      var result : List[Long] = Nil\n      depth = 0\n      var last_char\
    \ = ' '\n      for (paren <- paren_string.toList) {\n          if (paren == '(')\
    \ depth += 1\n          else if (paren == ')') depth -= 1\n          if (paren\
    \ == ' ' && last_char == ')') result = result :+ max_depth\n          max_depth\
    \ = max(max_depth, depth)\n          last_char = paren\n      }\n      result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt8qx0908.scala:30)\n\tat Problem.main(tmpt8qx0908.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028542
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        if (paren_string.isEmpty) return List[Long]()\n        val paren_list\
    \ = paren_string.split(\" \").toList\n        val result_list = new ListBuffer[Long]()\n\
    \        for (paren <- paren_list) {\n            var stack = new Stack[Char]()\n\
    \            var level = 0\n            var max_level = 0\n            for (i\
    \ <- 0 until paren.length) {\n                val c = paren(i)\n             \
    \   if (c == '(') {\n                    stack.push(c)\n                    level\
    \ += 1\n                    max_level = max(max_level, level)\n              \
    \  } else if (c == ')') {\n                    level -= 1\n                }\n\
    \            }\n            result_list += max_level\n        }\n        result_list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028542
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val paren_groups = paren_string.split(\" \")\n      var ans = List[Long]()\n\
    \      for (pg <- paren_groups) {\n        val cnt = Array.fill(pg.length)(0)\n\
    \        var maxDepth = 0\n        for (i <- 0 until pg.length) {\n          if\
    \ (pg(i) == '(') cnt(i) = 1\n          else {\n            var d = 0\n       \
    \     while (pg(i - d) != '(') d += 1\n            cnt(i) = 1 + cnt(i - d)\n \
    \         }\n          maxDepth = max(maxDepth, cnt(i))\n        }\n        ans\
    \ = ans :+ maxDepth\n      }\n      ans\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp84sj2kju.scala:29)\n\tat Problem.main(tmp84sj2kju.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028543
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var parenStack = Stack[Char]()\n        var result = List[Long]()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    parenStack.push(c)\n            } else if (c == ')') {\n                if\
    \ (parenStack.isEmpty) {\n                    throw new IllegalArgumentException(\"\
    Invalid string with unbalanced parenthesis.\")\n                } else {\n   \
    \                 parenStack.pop\n                    result = result :+ parenStack.size\n\
    \                }\n            }\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0gj7e9uu.scala:27)\n\tat Problem.main(tmp0gj7e9uu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028543
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list = paren_string.split(\" \").toList\n        var max_depth_list\
    \ = List[Long]()\n        for (x <- paren_list) {\n            var max_depth =\
    \ 0l\n            var current_depth = 0l\n            for (y <- x) {\n       \
    \         if (y == '(') {\n                    current_depth += 1\n          \
    \          if (current_depth > max_depth) max_depth = current_depth\n        \
    \        }\n                else if (y == ')') {\n                    current_depth\
    \ -= 1\n                }\n            }\n            max_depth_list = max_depth_list\
    \ :+ max_depth\n        }\n        return max_depth_list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028543
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (g <- paren_groups) {\n            var level = 0\n\
    \            var max_level = 0\n            for (c <- g) {\n                if\
    \ (c == '(') level += 1\n                else if (c == ')') level -= 1\n     \
    \           max_level = max(max_level, level)\n            }\n            result\
    \ = result :+ max_level\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028543
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list = paren_string.split(\" \").toList\n        def getLevel(paren_group\
    \ : String) : Long = {\n            def loop(stack : List[Int], level : Int, max_level\
    \ : Int) : Int = {\n                if (stack.isEmpty) max_level\n           \
    \     else {\n                    if (stack.head == -1) loop(stack.tail, level\
    \ + 1, max(max_level, level))\n                    else if (stack.head == 1) loop(stack.tail,\
    \ level - 1, max_level)\n                    else throw new RuntimeException(\"\
    Invalid paren stack\")\n                }\n            }\n            loop(paren_group.map(x\
    \ => if (x == '(') 1 else if (x == ')') -1 else throw new RuntimeException(\"\
    Invalid paren string\")).toList, 0, 0)\n        }\n        paren_list.map(x =>\
    \ getLevel(x))\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0186y_6h.scala:25)\n\tat Problem.main(tmp0186y_6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028546
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        if (paren_string.length() == 0) return List[Long]()\n        paren_string.split(\"\
    \ \").map(paren_group => {\n            var stack = new Stack[Char]()\n      \
    \      var max_depth = 0\n            var current_depth = 0\n            for (c\
    \ <- paren_group) {\n                if (c == '(') {\n                    stack.push(c)\n\
    \                    current_depth += 1\n                    max_depth = max(max_depth,\
    \ current_depth)\n                } else if (c == ')') {\n                   \
    \ stack.pop()\n                    current_depth -= 1\n                }\n   \
    \         }\n            max_depth\n        }).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn2rtrlqs.scala:26:11\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        paren_string.split(\e\
    [31m\" \"\e[0m).map(\e[36mparen_group\e[0m => {\n\e[31m12 |\e[0m            \e\
    [33mvar\e[0m \e[36mstack\e[0m = \e[33mnew\e[0m \e[35mStack\e[0m[\e[35mChar\e[0m]()\n\
    \e[31m13 |\e[0m            \e[33mvar\e[0m \e[36mmax_depth\e[0m = \e[31m0\e[0m\n\
    \e[31m14 |\e[0m            \e[33mvar\e[0m \e[36mcurrent_depth\e[0m = \e[31m0\e\
    [0m\n\e[31m15 |\e[0m            \e[33mfor\e[0m (c <- paren_group) {\n\e[31m16\
    \ |\e[0m                \e[33mif\e[0m (c == \e[31m'('\e[0m) {\n\e[31m17 |\e[0m\
    \                    stack.push(c)\n\e[31m18 |\e[0m                    current_depth\
    \ += \e[31m1\e[0m\n\e[31m19 |\e[0m                    max_depth = max(max_depth,\
    \ current_depth)\n\e[31m20 |\e[0m                } \e[33melse\e[0m \e[33mif\e\
    [0m (c == \e[31m')'\e[0m) {\n\e[31m21 |\e[0m                    stack.pop()\n\e\
    [31m22 |\e[0m                    current_depth -= \e[31m1\e[0m\n\e[31m23 |\e[0m\
    \                }\n\e[31m24 |\e[0m            }\n\e[31m25 |\e[0m            max_depth\n\
    \e[31m26 |\e[0m        }).toList\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m       \
    \ Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028542
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(a => {\n            var count = 0;\n\
    \            var result = 0;\n            for (c <- a) {\n                if (c\
    \ == '(') {\n                    count += 1;\n                    result = max(result,\
    \ count);\n                } else {\n                    count -= 1;\n       \
    \         }\n            }\n            result;\n        }).toList;\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw1jcm0m_.scala:22:11\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e\
    [31m\" \"\e[0m).map(\e[36ma\e[0m => {\n\e[31m11 |\e[0m            \e[33mvar\e\
    [0m \e[36mcount\e[0m = \e[31m0\e[0m;\n\e[31m12 |\e[0m            \e[33mvar\e[0m\
    \ \e[36mresult\e[0m = \e[31m0\e[0m;\n\e[31m13 |\e[0m            \e[33mfor\e[0m\
    \ (c <- a) {\n\e[31m14 |\e[0m                \e[33mif\e[0m (c == \e[31m'('\e[0m)\
    \ {\n\e[31m15 |\e[0m                    count += \e[31m1\e[0m;\n\e[31m16 |\e[0m\
    \                    result = max(result, count);\n\e[31m17 |\e[0m           \
    \     } \e[33melse\e[0m {\n\e[31m18 |\e[0m                    count -= \e[31m1\e\
    [0m;\n\e[31m19 |\e[0m                }\n\e[31m20 |\e[0m            }\n\e[31m21\
    \ |\e[0m            result;\n\e[31m22 |\e[0m        }).toList;\n\e[31m\e[31m \
    \  |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e\
    [0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660028544
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var ret = List[Long]()\n        paren_string.split(\" \").foreach\
    \ {x => {\n            var start = -1\n            var end = -1\n            var\
    \ count = 0\n            var level = 0\n            for (i <- 0 until x.length)\
    \ {\n                if (x(i) == '(') {\n                    if (count == 0) {\n\
    \                        start = i\n                        count += 1\n     \
    \               }\n                    else {\n                        count +=\
    \ 1\n                    }\n                }\n                else if (x(i) ==\
    \ ')') {\n                    count -= 1\n                    if (count == 0)\
    \ {\n                        end = i\n                        if (end - start\
    \ > 0) {\n                            level = max(level, parseNestedParens(x.substring(start\
    \ + 1, end)).max)\n                        }\n                    }\n        \
    \        }\n            }\n            ret = ret :+ (level + 1)\n        }}\n\
    \        return ret\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_l_zs_2l.scala:31:47\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                            level\
    \ = max(level, parseNestedParens(x.substring(start + \e[31m1\e[0m, end)).max)\n\
    \e[31m\e[31m   |\e[0m                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                               Found:    Long\n\
    \e[31m   |\e[0m                                               Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028544
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(x => {\n            var max_depth =\
    \ 0\n            var current_depth = 0\n            for (c <- x) {\n         \
    \       if (c == '(') {\n                    current_depth += 1\n            \
    \        max_depth = max(max_depth, current_depth)\n                } else if\
    \ (c == ')') {\n                    current_depth -= 1\n                }\n  \
    \          }\n            max_depth\n        }).toList.map(x => x.toLong)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val tokenized = paren_string.split(\"\\\\s+\")\n        //println(tokenized.mkString(\"\
    ,\"))\n        tokenized.map((arg : String) => {\n            //println(arg)\n\
    \            var level = 0\n            var maxLevel = 0\n            for (letter\
    \ <- arg) {\n                if (letter == '(') {\n                    level +=\
    \ 1\n                    if (level > maxLevel) maxLevel = level\n            \
    \    }\n                else if (letter == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            maxLevel\n        }).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa7988i5b.scala:26:11\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        tokenized.map((\e[36marg\e\
    [0m : \e[35mString\e[0m) => {\n\e[31m13 |\e[0m            \e[34m//println(arg)\e\
    [0m\n\e[31m14 |\e[0m            \e[33mvar\e[0m \e[36mlevel\e[0m = \e[31m0\e[0m\n\
    \e[31m15 |\e[0m            \e[33mvar\e[0m \e[36mmaxLevel\e[0m = \e[31m0\e[0m\n\
    \e[31m16 |\e[0m            \e[33mfor\e[0m (letter <- arg) {\n\e[31m17 |\e[0m \
    \               \e[33mif\e[0m (letter == \e[31m'('\e[0m) {\n\e[31m18 |\e[0m  \
    \                  level += \e[31m1\e[0m\n\e[31m19 |\e[0m                    \e\
    [33mif\e[0m (level > maxLevel) maxLevel = level\n\e[31m20 |\e[0m             \
    \   }\n\e[31m21 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (letter ==\
    \ \e[31m')'\e[0m) {\n\e[31m22 |\e[0m                    level -= \e[31m1\e[0m\n\
    \e[31m23 |\e[0m                }\n\e[31m24 |\e[0m            }\n\e[31m25 |\e[0m\
    \            maxLevel\n\e[31m26 |\e[0m        }).toList\n\e[31m\e[31m   |\e[0m\
    \        ^\e[0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e\
    [31m   |\e[0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660028550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def iter(paren_string : String, i : Int, max_level : Int, current_level\
    \ : Int, result : List[Long]) : List[Long] = {\n            if (i == paren_string.length)\
    \ {\n                if (max_level > current_level) max_level else current_level\
    \ :: result\n            } else {\n                paren_string(i) match {\n \
    \                   case '(' => iter(paren_string, i + 1, max(max_level, current_level\
    \ + 1), current_level + 1, result)\n                    case ')' => iter(paren_string,\
    \ i + 1, max_level, current_level - 1, result)\n                    case ' ' =>\
    \ max_level :: result ::: iter(paren_string, i + 1, 0, 0, Nil)\n             \
    \   }\n            }\n        }\n        iter(paren_string, 0, 0, 0, Nil).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpix8mvqd6.scala:12:47\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m                \e[33mif\e[0m\
    \ (max_level > current_level) max_level \e[33melse\e[0m current_level :: result\n\
    \e[31m\e[31m   |\e[0m                                               ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    (max_level\
    \ : Int)\n\e[31m   |\e[0m                                             Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Return list of (max depth, current depth) pair.\n        val parens\
    \ = paren_string.filter(c => c == '(' || c == ')').toCharArray\n        var level\
    \ = 0\n        var maxLevel = 0\n        var levels = List[(Int, Int)]()\n   \
    \     for (p <- parens) {\n            if (p == '(') {\n                level\
    \ += 1\n                if (level > maxLevel) maxLevel = level\n            }\
    \ else {\n                levels ::= (maxLevel, level)\n                level\
    \ -= 1\n            }\n        }\n        levels.map(x => x._1).reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr6tof2ak.scala:24:30\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        levels.map(\e[36mx\e\
    [0m => x._1).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028552
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list = paren_string.split(\" \").toList\n        paren_list.map(group\
    \ => {\n            var current_level = 0\n            var max_level = 0\n   \
    \         for (c <- group) {\n                if (c == '(') {\n              \
    \      current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            max_level\n        })\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028558
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val paren_regex = \"\"\"(\\(([^()]+)\\))\"\"\".r\n      val regex_result\
    \ = paren_regex.findAllIn(paren_string)\n      val paren_string_list = regex_result.map(_.toString).toList\n\
    \      val paren_string_list_filtered = paren_string_list.filter(_.length > 2)\n\
    \      val paren_string_list_final = paren_string_list_filtered.map(_.replace(\"\
    (\", \"\").replace(\")\", \"\"))\n      return paren_string_list_final.map(x =>\
    \ x.length).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5cxfrlic.scala:15:56\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m      \e[33mreturn\e[0m paren_string_list_final.map(\e\
    [36mx\e[0m => x.length).toList\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m \
    \  |\e[0m             Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660028554
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        return paren_string.split(\" \").map(s => s.filter(c => c != '('\
    \ && c != ')').length.toLong).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb500qsm6.scala:13)\n\tat Problem.main(tmpb500qsm6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028558
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val num_groups = paren_string.split(\" \").length\n        var results\
    \ = List[Long]()\n        for (i <- 0 until num_groups) {\n            var current_paren_string\
    \ = paren_string.split(\" \")(i)\n            var temp_count = 0\n           \
    \ var max_count = 0\n            for (j <- 0 until current_paren_string.length)\
    \ {\n                if (current_paren_string(j) == '(') {\n                 \
    \   temp_count += 1\n                    if (temp_count > max_count) max_count\
    \ = temp_count\n                }\n                else if (current_paren_string(j)\
    \ == ')') {\n                    temp_count -= 1\n                }\n        \
    \    }\n            results = results :+ max_count\n        }\n        results\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028560
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_list = paren_string.split(\" \").toList\n        val level_list\
    \ = paren_list.map(x => {\n            var level = 0l\n            var max_level\
    \ = 0l\n            for (x <- x) {\n                if (x == '(') {\n        \
    \            level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (x == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            max_level\n        })\n        level_list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028558
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        return paren_string.split(\" \").toList.map(group => group.toList.foldLeft(Stack[Char]())((stack,\
    \ paren) => {\n            if (paren == '(') stack.push(paren)\n            else\
    \ if (paren == ')') stack.pop\n            stack\n        }).size.toLong)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplj6i87bl.scala:17)\n\tat Problem.main(tmplj6i87bl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028560
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- groups) {\n            var maxLevel = 0\n            var\
    \ level = 0\n            for (ch <- group) {\n                if (ch == '(') {\n\
    \                    level += 1\n                    maxLevel = max(maxLevel,\
    \ level)\n                } else if (ch == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += maxLevel\n      \
    \  }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        if (paren_string.isEmpty) return Nil\n        val data = paren_string.split(\"\
    \ \")\n        val res = new ListBuffer[Long]\n        for (paren <- data) {\n\
    \            var (open, max) = (0, 0)\n            for (c <- paren) {\n      \
    \          if (c == '(') open += 1\n                else if (c == ')') open -=\
    \ 1\n                if (open > max) max = open\n            }\n            res\
    \ += max\n        }\n        res.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var results = List[Long]()\n        var curr_depth = 0\n        var\
    \ max_depth = 0\n        for (i <- 0 until paren_string.length) {\n          \
    \  if (paren_string(i) == '(') {\n                curr_depth += 1\n          \
    \      max_depth = max(max_depth, curr_depth)\n            } else if (paren_string(i)\
    \ == ')') {\n                curr_depth -= 1\n            } else if (paren_string(i)\
    \ == ' ') {\n                results = results :+ max_depth\n                max_depth\
    \ = 0\n                curr_depth = 0\n            }\n        }\n        results\
    \ = results :+ max_depth\n        return results\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n    \tval groups = paren_string.split(\" \")\n    \tval x = new ListBuffer[Long]()\n\
    \    \tfor (group <- groups) {\n    \t\tval s = group.toList\n    \t\tvar count\
    \ = 0\n    \t\tvar maxCount = 0\n    \t\tfor (c <- s) {\n    \t\t\tif (c == '(')\
    \ count += 1\n    \t\t\telse if (c == ')') count -= 1\n    \t\t\tmaxCount = max(maxCount,\
    \ count)\n    \t\t}\n    \t\tx += maxCount\n    \t}\n    \tx.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028564
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var res = List[Long]()\n        paren_string.split(\" \").foreach(i\
    \ => {\n            var s = i.toCharArray\n            var m = 0\n           \
    \ var n = 0\n            s.foreach(j => {\n                if (j == '(') m +=\
    \ 1\n                else n += 1\n                m = max(m, n)\n            })\n\
    \            res = res :+ m\n        })\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4no1ju2j.scala:25)\n\tat Problem.main(tmp4no1ju2j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028563
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val l = paren_string.split(\" \").toList\n        val max_depth_vec\
    \ = new ListBuffer[Long]\n        for (i <- 0 until l.length) {\n            var\
    \ depth = 0\n            var max_depth = 0\n            for (c <- l(i)) {\n  \
    \              if (c == '(') {\n                    depth += 1\n             \
    \       if (depth > max_depth) max_depth = depth\n                }\n        \
    \        else if (c == ')') depth -= 1\n            }\n            max_depth_vec\
    \ += max_depth\n        }\n        max_depth_vec.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028565
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val openParentheses = '('\n        val closeParentheses = ')'\n \
    \       var stack = new Stack[Long]()\n        var max_depth = 0l\n        var\
    \ depths = new ListBuffer[Long]()\n        for (i <- 0 until paren_string.length)\
    \ {\n            val c = paren_string(i)\n            if (c == openParentheses)\
    \ {\n                if (stack.isEmpty) {\n                    stack.push(1l)\n\
    \                } else {\n                    stack.push(stack.top + 1)\n   \
    \             }\n                max_depth = max(max_depth, stack.top)\n     \
    \       } else if (c == closeParentheses) {\n                if (stack.isEmpty)\
    \ {\n                    max_depth = max(max_depth, 1l)\n                } else\
    \ {\n                    stack.pop\n                }\n            } else if (c\
    \ == ' ') {\n                depths += max_depth\n                max_depth =\
    \ 0l\n            }\n        }\n        depths += max_depth\n        depths.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028564
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(s => (s.count(_ == '(') - s.count(_\
    \ == ')')) / 2).toList.map(_.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk45ukucz.scala:13)\n\tat Problem.main(tmpk45ukucz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028565
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var depth = 0\n        var max_depth = 0\n        var depths = ArrayBuffer[Long]()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    depth += 1\n                max_depth = max(max_depth, depth)\n         \
    \   } else if (c == ')') {\n                depths += max_depth\n            \
    \    depth -= 1\n                max_depth = max(max_depth, depth)\n         \
    \   }\n        }\n        return depths.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp52xxywg3.scala:26)\n\tat Problem.main(tmp52xxywg3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028564
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        var deepest = List[Long]()\n\
    \        for (group <- groups) {\n            var currentCount = 0\n         \
    \   var maxCount = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    currentCount += 1\n                    maxCount\
    \ = max(maxCount, currentCount)\n                } else if (c == ')') {\n    \
    \                currentCount -= 1\n                }\n            }\n       \
    \     deepest ::= maxCount\n        }\n        deepest.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028565
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_level : Long = 0\n        var output : List[Long] = List()\n\
    \        var max_level : Long = 0\n        for (c <- paren_string) {\n       \
    \     if (c == '(') {\n                paren_level += 1\n                max_level\
    \ = max(max_level, paren_level)\n            } else if (c == ')') {\n        \
    \        paren_level -= 1\n            } else if (c == ' ') {\n              \
    \  output = output :+ max_level\n                max_level = 0\n            }\n\
    \        }\n        output = output :+ max_level\n        return output\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028565
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val paren_groups = paren_string.split(\" \")\n      val result = ListBuffer[Long]()\n\
    \      for (group <- paren_groups) {\n        var count = 0\n        var max_count\
    \ = 0\n        for (ch <- group) {\n          if (ch == '(') {\n            count\
    \ += 1\n            max_count = max(max_count, count)\n          } else if (ch\
    \ == ')') {\n            count -= 1\n          }\n        }\n        result +=\
    \ max_count\n      }\n      result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028565
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Your code here\n        val s = paren_string.replaceAll(\"\\\\\
    s\", \"\")\n        println(s)\n        val stack = new Stack[Char]\n        var\
    \ max = 0\n        var count = 0\n        var start = 0\n        var i = 0\n \
    \       while (i < s.length) {\n            if (s(i) == '(') {\n             \
    \   stack.push(s(i))\n                if (stack.length > max) max = stack.length\n\
    \            } else if (s(i) == ')') {\n                stack.pop\n          \
    \  }\n            i += 1\n        }\n        return List(max.toLong)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwdpzta4d.scala:30)\n\tat Problem.main(tmpwdpzta4d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: '(()())((()))()((())()())

    '
  timestamp: 1660028567
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val regex = \"\\\\(\".r\n        val regex2 = \"\\\\)\".r\n     \
    \   val parenStrings = paren_string.split(\" \")\n        val parens = parenStrings.map(parenStr\
    \ => (parenStr, new HashMap[Long, Long]))\n        parens.foreach(p => p._2.put(0l,\
    \ 0l))\n        parens.foreach(p => regex.findAllIn(p._1).foreach(regexMatch =>\
    \ {\n            val index = regexMatch.indexOf(\"(\")\n            p._2.put(index.toLong,\
    \ 0l)\n        }))\n        parens.foreach(p => regex2.findAllIn(p._1).foreach(regexMatch\
    \ => {\n            val index = regexMatch.indexOf(\")\")\n            p._2.put(index.toLong,\
    \ 0l)\n        }))\n        parens.foreach(p => {\n            var stack = List[Long]()\n\
    \            p._2.foreach(kv => {\n                if (kv._1 == 0) {\n       \
    \             stack = stack.::(0l)\n                } else if (kv._1 % 2 == 0)\
    \ {\n                    p._2.put(kv._1, stack.length.toLong)\n              \
    \      stack = stack.::(stack.length.toLong)\n                } else {\n     \
    \               stack = stack.tail\n                }\n            })\n      \
    \  })\n        parens.map(p => p._2.map(kv => kv._2).max).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0q33gy1g.scala:39)\n\tat Problem.main(tmp0q33gy1g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // This is a character array and not a string because this is more\
    \ efficient.\n        // The idea is to iterate over the characters of the string\
    \ using a for loop.\n        // The input string is immutable and hence creating\
    \ a new string every time a character is consumed is an expensive operation.\n\
    \        // So a character array is used.\n        val paren_char_array = paren_string.toCharArray\n\
    \        // This is an array of the maximum number of nested parens for each group.\n\
    \        // The value at index i of this array is the deepest level of nesting\
    \ of parens for the ith group.\n        // Note that this is a mutable array.\n\
    \        val paren_levels = ArrayBuffer[Long]()\n        // This is used to keep\
    \ track of the current index of the character array that is being consumed by\
    \ the for loop.\n        var current_index = 0\n        // This is the size of\
    \ the character array.\n        val paren_char_array_size = paren_char_array.size\n\
    \        // This for loop iterates over the character array.\n        // A loop\
    \ like this will iterate over the entire string and check for the deepest level\
    \ of nesting of parens for each group.\n        // This is essentially a finite\
    \ state machine with three states as follows.\n        // 0: Nothing consumed\
    \ yet\n        // 1: Consumed (\n        // 2: Consumed everything\n        //\
    \ The variable state is used to keep track of the current state.\n        // E.g.\
    \ If the state is 1 and a ) is consumed, then the deepest level of nesting for\
    \ that group has been calculated.\n        // The variable level is used to keep\
    \ track of the deepest level of nesting of parens for the current group.\n   \
    \     // It is incremented every time a ( is consumed and decremented every time\
    \ a ) is consumed.\n        // This variable is always initialized to 0.\n   \
    \     var state = 0\n        var level = 0\n        for (index <- current_index\
    \ until paren_char_array_size) {\n            val current_char = paren_char_array(index)\n\
    \            state match {\n                case 0 => current_char match {\n \
    \                   case '(' => {\n                        level += 1\n      \
    \                  state = 1\n                    }\n                    case\
    \ ')' => state = 2\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpifs08sjq.scala:53:0 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpifs08sjq.scala:36:8\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mfor\e[0m (index\
    \ <- current_index until paren_char_array_size) {\n\e[31m\e[31m   |\e[0m     \
    \   ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36mcurrent_char\e[0m\
    \ = paren_char_array(index)\n\e[31m38 |\e[0m            state \e[33mmatch\e[0m\
    \ {\n\e[31m39 |\e[0m                \e[33mcase\e[0m \e[31m0\e[0m => current_char\
    \ \e[33mmatch\e[0m {\n\e[31m40 |\e[0m                    \e[33mcase\e[0m \e[31m'('\e\
    [0m => {\n\e[31m41 |\e[0m                        level += \e[31m1\e[0m\n\e[31m42\
    \ |\e[0m                        state = \e[31m1\e[0m\n\e[31m43 |\e[0m        \
    \            }\n\e[31m44 |\e[0m                    \e[33mcase\e[0m \e[31m')'\e\
    [0m => state = \e[31m2\e[0m\n\e[31m45 |\e[0m    }\n\e[31m46 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m47 |\e[0m    assert(parseNestedParens((\e[31m\"(()()) ((())) () ((())()())\"\
    \e[0m)).equals((List[\e[35mLong\e[0m](\e[31m2l\e[0m.toLong, \e[31m3l\e[0m.toLong,\
    \ \e[31m1l\e[0m.toLong, \e[31m3l\e[0m.toLong))));\n\e[31m48 |\e[0m    assert(parseNestedParens((\e\
    [31m\"() (()) ((())) (((())))\"\e[0m)).equals((List[\e[35mLong\e[0m](\e[31m1l\e\
    [0m.toLong, \e[31m2l\e[0m.toLong, \e[31m3l\e[0m.toLong, \e[31m4l\e[0m.toLong))));\n\
    \e[31m49 |\e[0m    assert(parseNestedParens((\e[31m\"(()(())((())))\"\e[0m)).equals((List[\e\
    [35mLong\e[0m](\e[31m4l\e[0m.toLong))));\n\e[31m50 |\e[0m    }\n\e[31m51 |\e[0m}\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028569
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_stack = new scala.collection.mutable.Stack[Char]\n    \
    \    var paren_count = 0\n        var deepest_nesting = 0\n        var deepest_nesting_list\
    \ = List[Long]()\n        for (i <- 0 until paren_string.length) {\n         \
    \   paren_string(i) match {\n                case '(' => {\n                 \
    \   paren_stack.push('(')\n                    paren_count += 1\n            \
    \        if (paren_count > deepest_nesting) {\n                        deepest_nesting\
    \ = paren_count\n                    }\n                }\n                case\
    \ ')' => {\n                    paren_stack.pop\n                    paren_count\
    \ -= 1\n                }\n                case ' ' => {\n                   \
    \ deepest_nesting_list = deepest_nesting_list :+ deepest_nesting\n           \
    \         deepest_nesting = 0\n                    paren_count = 0\n         \
    \       }\n            }\n        }\n        deepest_nesting_list\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt0i1kyzz.scala:37)\n\tat Problem.main(tmpt0i1kyzz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n    \tval paren_groups = paren_string.split(\" \")\n    \t// Keeps track\
    \ of deepest nest level.\n    \tvar max_nest = 0\n    \t// Keeps track of the\
    \ current nest level.\n    \tvar current_nest = 0\n    \t// Init a buffer to hold\
    \ the results.\n    \tvar result = new ListBuffer[Long]()\n    \t// Iterate through\
    \ each paren group.\n    \tfor (group <- paren_groups) {\n    \t\t// Reset current\
    \ nest value.\n    \t\tcurrent_nest = 0\n    \t\t// Iterate through each character\
    \ in the group.\n    \t\tfor (i <- 0 until group.length) {\n    \t\t\t// If we\
    \ found a left paren, increment current nest by 1.\n    \t\t\tif (group(i) ==\
    \ '(') current_nest += 1\n    \t\t\t// If we found a right paren, decrement current\
    \ nest by 1.\n    \t\t\telse if (group(i) == ')') current_nest -= 1\n    \t\t\t\
    // Update the max nest if needed.\n    \t\t\tif (current_nest > max_nest) max_nest\
    \ = current_nest\n    \t\t}\n    \t\t// After iterating through each character\
    \ in the group, we can add the max nest to the results.\n    \t\tresult += max_nest\n\
    \    \t}\n    \t// Return results.\n    \tresult.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphbnfjlpi.scala:37)\n\tat Problem.main(tmphbnfjlpi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028573
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      var output : List[Long] = List()\n      for (group <- paren_string.split(\"\
    \ \")) {\n        var level = 0\n        var max = 0\n        for (c <- group)\
    \ {\n          if (c == '(') {\n            level += 1\n            max = max\
    \ max level\n          } else if (c == ')') {\n            level -= 1\n      \
    \    }\n        }\n        output ::= max\n      }\n      output.reverse\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028575
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result : List[Long] = List[Long]()\n        var i = 0\n     \
    \   while (i < paren_string.length) {\n            var max_so_far = 0\n      \
    \      var current_max = 0\n            if (paren_string(i) == '(') {\n      \
    \          while (i < paren_string.length && paren_string(i) != ')') {\n     \
    \               if (paren_string(i) == '(') {\n                        current_max\
    \ += 1\n                        max_so_far = max(max_so_far, current_max)\n  \
    \                  }\n                    else if (paren_string(i) == ')') {\n\
    \                        current_max -= 1\n                    }\n           \
    \         i += 1\n                }\n                result = result :+ max_so_far\n\
    \            }\n            else if (paren_string(i) == ')') {\n             \
    \   i += 1\n            }\n            else {\n                i += 1\n      \
    \      }\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqxf0_v0a.scala:38)\n\tat Problem.main(tmpqxf0_v0a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028577
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def depth(stack : Stack[Char], paren_string : String) : Long = {\n\
    \            if (paren_string.length == 0) {\n                if (stack.length\
    \ == 0) 0 else -1\n            } else {\n                val current_char = paren_string.charAt(0)\n\
    \                if (current_char == '(') {\n                    stack.push(current_char)\n\
    \                    depth(stack, paren_string.substring(1))\n               \
    \ } else if (current_char == ')') {\n                    if (stack.length == 0)\
    \ -1 else {\n                        stack.pop\n                        depth(stack,\
    \ paren_string.substring(1))\n                    }\n                } else depth(stack,\
    \ paren_string.substring(1))\n            }\n        }\n        paren_string.split(\"\
    \ \").map(depth(Stack[Char](), _)).filter(_ >= 0).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpotycf957.scala:29)\n\tat Problem.main(tmpotycf957.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def depth(paren_string : String, depth : Long) : Long = {\n     \
    \       if (paren_string.isEmpty) depth\n            else {\n                paren_string.head\
    \ match {\n                    case '(' => depth(paren_string.tail, depth + 1)\n\
    \                    case ')' => depth(paren_string.tail, depth - 1)\n       \
    \             case _ => depth(paren_string.tail, depth)\n                }\n \
    \           }\n        }\n        val a = paren_string.split(\" \")\n        a.map(depth(_,\
    \ 0)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpmsqmyka0.scala:14:32 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                    \e[33mcase\e[0m \e[31m'('\e[0m =>\
    \ depth(paren_string.tail, depth + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                          ^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \         \e[33mparameter\e[0m \e[35mdepth\e[0m does not take parameters\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E050] Type Error: /tmp/tmpmsqmyka0.scala:15:32 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                    \e[33mcase\e[0m \e[31m')'\e[0m =>\
    \ depth(paren_string.tail, depth - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                          ^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \         \e[33mparameter\e[0m \e[35mdepth\e[0m does not take parameters\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E050] Type Error: /tmp/tmpmsqmyka0.scala:16:30 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                    \e[33mcase\e[0m _ => depth(paren_string.tail,\
    \ depth)\n\e[31m\e[31m   |\e[0m                              ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                              \e[33mparameter\e[0m \e[35mdepth\e[0m\
    \ does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660028572
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val all_parens_levels\
    \ = new ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n    \
    \        all_parens_levels += calcParensLevel(paren_group)\n        }\n      \
    \  return all_parens_levels.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuxc729k2.scala:13:33 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            all_parens_levels += calcParensLevel(paren_group)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                 Not found: calcParensLevel\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660028572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map( group => group.foldLeft(0l.toLong)\
    \ { (level, paren) =>\n            if (paren == '(') level + 1\n            else\
    \ if (paren == ')') level - 1\n            else level\n        }).toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpltolsuno.scala:17)\n\tat Problem.main(tmpltolsuno.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028580
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def parenHelper(paren_string : String, curr_level : Long, max_level\
    \ : Long) : (Long, Long) = {\n            if (paren_string.isEmpty) {\n      \
    \          (curr_level, max_level)\n            } else {\n                paren_string.head\
    \ match {\n                    case '(' => {\n                        val (curr_level2,\
    \ max_level2) = parenHelper(paren_string.tail, curr_level + 1, max(curr_level\
    \ + 1, max_level))\n                        (curr_level2, max_level2)\n      \
    \              }\n                    case ')' => {\n                        val\
    \ (curr_level2, max_level2) = parenHelper(paren_string.tail, curr_level - 1, max(curr_level\
    \ - 1, max_level))\n                        (curr_level2, max_level2)\n      \
    \              }\n                    case _ => {\n                        val\
    \ (curr_level2, max_level2) = parenHelper(paren_string.tail, curr_level, max(curr_level,\
    \ max_level))\n                        (curr_level2, max_level2)\n           \
    \         }\n                }\n            }\n        }\n        paren_string.split(\"\
    \ \").map(paren_string => {\n            val (curr_level, max_level) = parenHelper(paren_string,\
    \ 0, 0)\n            if (curr_level != 0) throw new IllegalArgumentException(\"\
    Parentheses not matched\")\n            max_level\n        }).toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val group_parens = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (group <- group_parens) {\n            var stack\
    \ = Stack[Char]()\n            var max_level = 0\n            var current_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               stack.push(c)\n                    current_level += 1\n      \
    \              max_level = max(max_level, current_level)\n                } else\
    \ if (c == ')') {\n                    stack.pop\n                    current_level\
    \ -= 1\n                }\n            }\n            result = result :+ max_level\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_level = List[Long]()\n        var temp_max = 0\n        var\
    \ current_level = 0\n        for (x <- paren_string) {\n            if (x == '(')\
    \ {\n                current_level += 1\n                if (current_level > temp_max)\
    \ {\n                    temp_max = current_level\n                }\n       \
    \     }\n            else if (x == ')') {\n                current_level -= 1\n\
    \            }\n            else if (x == ' ') {\n                max_level =\
    \ max_level :+ temp_max\n                temp_max = 0\n                current_level\
    \ = 0\n            }\n        }\n        max_level = max_level :+ temp_max\n \
    \       return max_level\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028582
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val strings = paren_string.split(\" \")\n        val output = new\
    \ ListBuffer[Long]()\n        for (str <- strings) {\n            var maxlevel\
    \ = 0\n            var level = 0\n            for (i <- 0 until str.length) {\n\
    \                if (str(i) == '(') {\n                    level += 1\n      \
    \              maxlevel = max(maxlevel, level)\n                } else if (str(i)\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            output += maxlevel\n        }\n        output.toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.trim.split(\" \")\n        groups.map(g\
    \ => findGroupDepth(g)).toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5725s099.scala:11:24 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        groups.map(\e[36mg\e[0m => findGroupDepth(g)).toList\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: findGroupDepth\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmp5725s099.scala:11:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        groups.map(\e[36mg\e[0m => findGroupDepth(g)).toList\n\
    \e[31m\e[31m   |\e[0m                                          ^\e[0m\n\e[31m\
    \   |\e[0m                                          No ClassTag available for\
    \ B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                        \
    \  where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660028583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        parens.map(paren\
    \ => {\n            var max_nesting = 0\n            var nesting = 0\n       \
    \     for (ch <- paren) {\n                if (ch == '(') nesting += 1\n     \
    \           else if (ch == ')') nesting -= 1\n                max_nesting = max(max_nesting,\
    \ nesting)\n            }\n            max_nesting\n        }).toList.map(num\
    \ => num.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028585
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n    \tdef calcNestingDepth(index : Int, paren_string : String, level : Int,\
    \ max_level : Int) : (Int, Int) = {\n    \t\tif (index == paren_string.length)\
    \ return (level, max_level)\n    \t\tval c = paren_string(index)\n    \t\tif (c\
    \ == '(') return calcNestingDepth(index + 1, paren_string, level + 1, max(max_level,\
    \ level + 1))\n    \t\tif (c == ')') return calcNestingDepth(index + 1, paren_string,\
    \ level - 1, max_level)\n    \t\tcalcNestingDepth(index + 1, paren_string, level,\
    \ max_level)\n    \t}\n    \tdef parseNestedParensHelper(index : Int, paren_string\
    \ : String, result : List[Long]) : List[Long] = {\n    \t\tif (index == paren_string.length)\
    \ return result\n    \t\tval c = paren_string(index)\n    \t\tif (c == '(') {\n\
    \    \t\t\tval next_index = paren_string.indexOf(')', index)\n    \t\t\tif (next_index\
    \ != -1) {\n    \t\t\t\tval (level, max_level) = calcNestingDepth(index + 1, paren_string,\
    \ 1, 1)\n    \t\t\t\tparseNestedParensHelper(next_index + 1, paren_string, max_level\
    \ :: result)\n    \t\t\t} else {\n    \t\t\t\tparseNestedParensHelper(index +\
    \ 1, paren_string, result)\n    \t\t\t}\n    \t\t} else {\n    \t\t\tparseNestedParensHelper(index\
    \ + 1, paren_string, result)\n    \t\t}\n    \t}\n    \tparseNestedParensHelper(0,\
    \ paren_string, List())\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphkazknhs.scala:35)\n\tat Problem.main(tmphkazknhs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028586
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val opening_paren = new HashMap[Long, Long]()\n        var balance\
    \ = 0\n        var max_balance = 0\n        for (i <- 0 until paren_string.length)\
    \ {\n            val c = paren_string(i)\n            if (c == '(') {\n      \
    \          balance += 1\n                max_balance = max(max_balance, balance)\n\
    \                opening_paren(balance) = i\n            } else if (c == ')')\
    \ {\n                val index = opening_paren(balance)\n                opening_paren.remove(balance)\n\
    \                balance -= 1\n            }\n        }\n        return opening_paren.keys.toList.map(x\
    \ => max_balance - x + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjvn7wgki.scala:28)\n\tat Problem.main(tmpjvn7wgki.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (g <- groups) {\n            val depth = parseDepth(g)\n        \
    \    result = result :+ depth\n        }\n        return result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpakqgpzca.scala:13:24 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mval\e[0m \e[36mdepth\e[0m = parseDepth(g)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        Not found: parseDepth\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028579
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        val max_nesting =\
    \ new ListBuffer[Long]\n        for (i <- 0 until parens.length) {\n         \
    \   var max_nest = 0l\n            var cur_nest = 0l\n            for (j <- 0\
    \ until parens(i).length) {\n                if (parens(i)(j) == '(') {\n    \
    \                cur_nest += 1\n                    max_nest = max(max_nest, cur_nest)\n\
    \                }\n                else {\n                    cur_nest -= 1\n\
    \                }\n            }\n            max_nesting += max_nest\n     \
    \   }\n        max_nesting.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028586
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.toList\n        var result = new ListBuffer[Long]()\n\
    \        var current_max = 0l\n        var current_depth = 0l\n        for (p\
    \ <- parens) {\n            if (p == '(') {\n                current_depth +=\
    \ 1\n                if (current_depth > current_max) {\n                    current_max\
    \ = current_depth\n                }\n            } else if (p == ')') {\n   \
    \             current_depth -= 1\n            } else if (p == ' ') {\n       \
    \         result += current_max\n                current_max = 0\n           \
    \     current_depth = 0\n            }\n        }\n        result += current_max\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028587
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_nesting = 0\n        var nesting = 0\n        var res = new\
    \ ListBuffer[Long]()\n        for (i <- 0 until paren_string.length) {\n     \
    \       val c = paren_string(i)\n            if (c == '(') {\n               \
    \ nesting += 1\n                max_nesting = max(max_nesting, nesting)\n    \
    \        } else if (c == ')') {\n                nesting -= 1\n            } else\
    \ if (c == ' ') {\n                res += max_nesting\n                max_nesting\
    \ = 0\n                nesting = 0\n            }\n        }\n        res += max_nesting\n\
    \        res.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028586
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = new ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n\
    \            var currentMaxLevel = 0\n            var currentLevel = 0\n     \
    \       for (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') {\n                    currentLevel += 1\n                    if (currentLevel\
    \ > currentMaxLevel) currentMaxLevel = currentLevel\n                }\n     \
    \           else if (paren_groups(i)(j) == ')') {\n                    currentLevel\
    \ -= 1\n                }\n            }\n            result += currentMaxLevel\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028588
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Brute force approach.\n        // For each character, if its an\
    \ open parenthesis, we add one to the level.\n        // If its a close parenthesis,\
    \ we subtract one from the level.\n        // If we reach a close parenthesis\
    \ with a level of 0, that means that we have a complete group, so we reset the\
    \ level.\n        // We keep track of the deepest level of nesting of parentheses.\n\
    \        var level = 0l\n        var deepest_level = 0l\n        val result =\
    \ new ListBuffer[Long]\n        for (c <- paren_string) {\n            if (c ==\
    \ '(') {\n                level += 1\n                if (level > deepest_level)\
    \ deepest_level = level\n            }\n            else if (c == ')') {\n   \
    \             level -= 1\n                if (level == 0) {\n                \
    \    result += deepest_level\n                    deepest_level = 0\n        \
    \        }\n            }\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028590
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(_.toList).map(str => {\n          \
    \  val list = ListBuffer[Int]()\n            var maximum = 0\n            for\
    \ (c <- str) {\n                if (c == '(') {\n                    list += 1\n\
    \                    maximum = maximum.max(list.length)\n                } else\
    \ {\n                    list.remove(list.length - 1)\n                }\n   \
    \         }\n            maximum\n        }).toList.map(_.toLong)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028593
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val paren_strings = paren_string.split(\" \")\n      val paren_arrays\
    \ = paren_strings.map(paren_string => paren_string.toCharArray.toList)\n     \
    \ // Each element in the list is a List of the characters in the input.\n    \
    \  val paren_arrays_list = paren_arrays.toList\n      // Traverse through the\
    \ input array list, and record the maximum depth at each level.\n      // If the\
    \ nested parentheses are valid, then the maximum depth must increase by one at\
    \ every opening parenthesis and decrease by one at every closing parenthesis.\n\
    \      // If it remains the same or increases without there being an opening parenthesis,\
    \ the nested parentheses are invalid.\n      // If the maximum depth becomes less\
    \ than zero at any point, the nested parentheses are invalid.\n      paren_arrays_list.map(paren_array\
    \ => {\n        var max_depth = 0\n        var cur_depth = 0\n        paren_array.foreach(paren\
    \ => {\n          if (paren == '(') {\n            cur_depth += 1\n          \
    \  if (cur_depth > max_depth) max_depth = cur_depth\n          }\n          else\
    \ if (paren == ')') {\n            cur_depth -= 1\n            if (cur_depth <\
    \ 0) {\n              println(\"Invalid nest parentheses!\")\n              return\
    \ -1\n            }\n          }\n        })\n        if (cur_depth != 0) {\n\
    \          println(\"Invalid nest parentheses!\")\n          return -1\n     \
    \   }\n        max_depth\n      })\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvzeqebzu.scala:30:21\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m              \e[33mreturn\e\
    [0m -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                     ^^\e[0m\n\e[31m \
    \  |\e[0m                     Found:    (\e[31m-1\e[0m : Int)\n\e[31m   |\e[0m\
    \                     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpvzeqebzu.scala:36:17 --------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m          \e[33mreturn\e[0m -\e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                 ^^\e[0m\n\e[31m   |\e[0m                 Found:    (\e\
    [31m-1\e[0m : Int)\n\e[31m   |\e[0m                 Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028590
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Keep track of how many parentheses have been encountered\n   \
    \     var stack_level = 0\n        // Keep track of maximum stack level encountered\
    \ so far\n        var max_stack_level = 0\n        // Keep track of the maximum\
    \ stack level for each group\n        var max_stack_levels = List[Long]()\n  \
    \      for (i <- 0 until paren_string.length) {\n            if (paren_string(i)\
    \ == '(') {\n                stack_level += 1\n                if (stack_level\
    \ > max_stack_level) max_stack_level = stack_level\n            }\n          \
    \  else if (paren_string(i) == ')') {\n                if (stack_level == 0) return\
    \ List()\n                stack_level -= 1\n            }\n            else if\
    \ (paren_string(i) == ' ') {\n                if (stack_level != 0) return List()\n\
    \                max_stack_levels = max_stack_levels :+ max_stack_level\n    \
    \            max_stack_level = 0\n            }\n        }\n        // If there\
    \ are any closing parentheses without opening ones, return empty list\n      \
    \  if (stack_level != 0) return List()\n        max_stack_levels = max_stack_levels\
    \ :+ max_stack_level\n        max_stack_levels\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028594
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_level = 0l\n        var level = 0l\n        var output =\
    \ List[Long]()\n        for (ch <- paren_string) {\n            if (ch == '(')\
    \ {\n                level += 1\n                max_level = max(max_level, level)\n\
    \            } else if (ch == ')') {\n                level -= 1\n           \
    \ } else if (ch == ' ') {\n                output = output :+ max_level\n    \
    \            max_level = 0l\n                level = 0l\n            }\n     \
    \   }\n        output\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp54prztht.scala:28)\n\tat Problem.main(tmp54prztht.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028594
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Split the string by space to get each of the group.\n        val\
    \ paren_groups = paren_string.split(\" \")\n        var max_count = 0\n      \
    \  val max_nested_paren_counts = new ListBuffer[Long]()\n        // Iterate over\
    \ each of the group and get the maximum level of nested parens.\n        paren_groups.foreach(group\
    \ => {\n            var paren_stack = new Stack[Char]()\n            var max_nested_paren_count\
    \ = 0\n            var curr_nested_paren_count = 0\n            for (i <- 0 until\
    \ group.length) {\n                if (group(i) == '(') {\n                  \
    \  paren_stack.push(group(i))\n                    curr_nested_paren_count +=\
    \ 1\n                    if (curr_nested_paren_count > max_nested_paren_count)\
    \ max_nested_paren_count = curr_nested_paren_count\n                }\n      \
    \          else if (group(i) == ')') {\n                    paren_stack.pop()\n\
    \                    curr_nested_paren_count -= 1\n                }\n       \
    \     }\n            // Add the current maximum level of nested parens to the\
    \ list buffer.\n            max_nested_paren_counts += max_nested_paren_count\n\
    \        })\n        max_nested_paren_counts.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        var res = List[Long]()\n\
    \        for (group <- groups) {\n            res = res :+ parseNestedParens_helper(group)\n\
    \        }\n        return res\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw6mj7zrj.scala:13:25 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            res = res :+ parseNestedParens_helper(group)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: parseNestedParens_helper\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028589
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val strings = paren_string.split(\" \")\n        var answer = List[Long]()\n\
    \        for (paren <- strings) {\n            var stack = Stack[String]()\n \
    \           var max = 0\n            for (ch <- paren) {\n                if (ch\
    \ == '(') {\n                    stack.push(\"(\")\n                    max =\
    \ max + 1\n                } else {\n                    stack.pop()\n       \
    \         }\n            }\n            answer = answer :+ max\n        }\n  \
    \      return answer\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjtjz7r08.scala:28)\n\tat Problem.main(tmpjtjz7r08.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028598
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val group_strings = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group_string <- group_strings) {\n      \
    \      var level = 0l\n            var max_level = 0l\n            for (char <-\
    \ group_string) {\n                if (char == '(') {\n                    level\
    \ += 1\n                    max_level = max(max_level, level)\n              \
    \  } else if (char == ')') {\n                    level -= 1\n               \
    \ }\n            }\n            result += max_level\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028601
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var ret = List[Long]()\n        var paren_list = List[Char]()\n \
    \       var level = 0\n        var max_level = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                level += 1\n               \
    \ if (level > max_level) max_level = level\n            }\n            else if\
    \ (c == ')') {\n                level -= 1\n                if (level == 0) {\n\
    \                    ret = ret :+ max_level\n                    max_level = 0\n\
    \                }\n            }\n        }\n        return ret\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // For each individual group\n        val groups = paren_string.split(\"\
    \ \")\n        groups.map(group => {\n            // Number of open parentheses\n\
    \            var num_open = 0\n            // Maximum number of open parentheses\n\
    \            var max_open = 0\n            for (c <- group) {\n              \
    \  if (c == '(') {\n                    num_open += 1\n                    max_open\
    \ = max(max_open, num_open)\n                } else if (c == ')') {\n        \
    \            num_open -= 1\n                }\n            }\n            max_open\n\
    \        }).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph_8av9id.scala:26:11\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        groups.map(\e[36mgroup\e\
    [0m => {\n\e[31m13 |\e[0m            \e[34m// Number of open parentheses\e[0m\n\
    \e[31m14 |\e[0m            \e[33mvar\e[0m \e[36mnum_open\e[0m = \e[31m0\e[0m\n\
    \e[31m15 |\e[0m            \e[34m// Maximum number of open parentheses\e[0m\n\e\
    [31m16 |\e[0m            \e[33mvar\e[0m \e[36mmax_open\e[0m = \e[31m0\e[0m\n\e\
    [31m17 |\e[0m            \e[33mfor\e[0m (c <- group) {\n\e[31m18 |\e[0m      \
    \          \e[33mif\e[0m (c == \e[31m'('\e[0m) {\n\e[31m19 |\e[0m            \
    \        num_open += \e[31m1\e[0m\n\e[31m20 |\e[0m                    max_open\
    \ = max(max_open, num_open)\n\e[31m21 |\e[0m                } \e[33melse\e[0m\
    \ \e[33mif\e[0m (c == \e[31m')'\e[0m) {\n\e[31m22 |\e[0m                    num_open\
    \ -= \e[31m1\e[0m\n\e[31m23 |\e[0m                }\n\e[31m24 |\e[0m         \
    \   }\n\e[31m25 |\e[0m            max_open\n\e[31m26 |\e[0m        }).toList\n\
    \e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    List[\e\
    [1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e[32mLong\e[0m]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028598
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // YOUR CODE HERE\n        return List()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn78hykqg.scala:14)\n\tat Problem.main(tmpn78hykqg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028602
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      def helper(stack : Stack[Char], count : Long, result : List[Long])\
    \ : List[Long] = {\n        if (stack.isEmpty) {\n          count :: result\n\
    \        } else {\n          stack.pop match {\n            case '(' => {\n  \
    \            if (stack.isEmpty) {\n                count :: result\n         \
    \     } else {\n                helper(stack, count + 1, result)\n           \
    \   }\n            }\n            case ')' => {\n              if (stack.isEmpty)\
    \ {\n                count :: result\n              } else {\n               \
    \ helper(stack, count, result)\n              }\n            }\n          }\n\
    \        }\n      }\n      var stack = new Stack[Char]\n      var count = 0\n\
    \      var results = List[Long]()\n      for (c <- paren_string) {\n        if\
    \ (c == '(') {\n          stack.push(c)\n        } else if (c == ')') {\n    \
    \      if (stack.isEmpty) {\n            count = 0\n          } else {\n     \
    \       stack.pop\n            count += 1\n          }\n        } else if (c ==\
    \ ' ') {\n          results = helper(stack, count, results)\n          count =\
    \ 0\n        }\n      }\n      results = helper(stack, count, results)\n     \
    \ results\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxqw107dr.scala:54)\n\tat Problem.main(tmpxqw107dr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028604
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = new ListBuffer[Long]\n        for (paren_group <- paren_string.split(\"\
    \ \")) {\n            var depth = 0\n            var max_depth = 0\n         \
    \   for (ch <- paren_group) {\n                if (ch == '(') depth += 1\n   \
    \             else if (ch == ')') depth -= 1\n                if (depth > max_depth)\
    \ max_depth = depth\n            }\n            result += max_depth\n        }\n\
    \        return result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028603
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def iter(str : String, level : Long, max : Long, result : List[Long])\
    \ : List[Long] = {\n            if (str.length == 0) result\n            else\
    \ if (str.head == '(') iter(str.tail, level + 1, max + 1, result)\n          \
    \  else if (str.head == ')') iter(str.tail, level - 1, max, result :+ max)\n \
    \           else if (str.head == ' ') iter(str.tail, 0, 0, result :+ max)\n  \
    \          else throw new RuntimeException(\"Unrecognized input: \" + str.head)\n\
    \        }\n        iter(paren_string, 0, 0, List[Long]())\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnw_fukdu.scala:20)\n\tat Problem.main(tmpnw_fukdu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028604
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        groups.map(x => {\n\
    \            val groups = x.split(\"\").toList\n            val depth = Stack[Char]()\n\
    \            var maxDepth = 0\n            for (c <- groups) {\n             \
    \   if (c == \"(\") {\n                    depth.push(c)\n                   \
    \ maxDepth = max(maxDepth, depth.size)\n                } else if (c == \")\"\
    ) {\n                    depth.pop\n                }\n            }\n       \
    \     maxDepth\n        }).toList.map(x => x.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb5l5t1oh.scala:17:31\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m                    depth.push(c)\n\
    \e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m  \
    \                             Found:    (c : String)\n\e[31m   |\e[0m        \
    \                       Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(s => {\n            val stack = new\
    \ Stack[Int]()\n            stack.push(0)\n            for (ch <- s) {\n     \
    \           if (ch == '(') {\n                    stack.push(stack.top + 1)\n\
    \                } else if (ch == ')') {\n                    stack.pop()\n  \
    \              }\n            }\n            stack.top\n        }).toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj0eboj3f.scala:21:11\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        paren_string.split(\e\
    [31m\" \"\e[0m).map(\e[36ms\e[0m => {\n\e[31m11 |\e[0m            \e[33mval\e\
    [0m \e[36mstack\e[0m = \e[33mnew\e[0m \e[35mStack\e[0m[\e[35mInt\e[0m]()\n\e[31m12\
    \ |\e[0m            stack.push(\e[31m0\e[0m)\n\e[31m13 |\e[0m            \e[33mfor\e\
    [0m (ch <- s) {\n\e[31m14 |\e[0m                \e[33mif\e[0m (ch == \e[31m'('\e\
    [0m) {\n\e[31m15 |\e[0m                    stack.push(stack.top + \e[31m1\e[0m)\n\
    \e[31m16 |\e[0m                } \e[33melse\e[0m \e[33mif\e[0m (ch == \e[31m')'\e\
    [0m) {\n\e[31m17 |\e[0m                    stack.pop()\n\e[31m18 |\e[0m      \
    \          }\n\e[31m19 |\e[0m            }\n\e[31m20 |\e[0m            stack.top\n\
    \e[31m21 |\e[0m        }).toList\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m       \
    \ Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028604
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // This is for the purpose of trimming the space between groups.\n\
    \        val temp_string = paren_string.replaceAll(\" \", \"\")\n        val paren_groups\
    \ = temp_string.split(\"\\\\)\\\\(\")\n        val result = ListBuffer[Long]()\n\
    \        for (i <- 0 until paren_groups.length) {\n            val s = paren_groups(i)\n\
    \            if (s.length == 0) result += 0\n            else {\n            \
    \    var max_cnt = 0\n                var cnt = 0\n                for (j <- 0\
    \ until s.length) {\n                    if (s(j) == '(') cnt += 1\n         \
    \           else if (s(j) == ')') cnt -= 1\n                    max_cnt = max(max_cnt,\
    \ cnt)\n                }\n                result += max_cnt\n            }\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph3k26w2i.scala:31)\n\tat Problem.main(tmph3k26w2i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028607
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val groups = paren_string.split(\" \")\n      val rs = new ListBuffer[Long]\n\
    \      for (g <- groups) {\n        val parens = g.toCharArray\n        var counter\
    \ = 0\n        var max = 0\n        for (c <- parens) {\n          if (c == '(')\
    \ counter += 1\n          else counter -= 1\n          max = max.max(counter)\n\
    \        }\n        rs += max\n      }\n      rs.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028608
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(group => {\n            var level =\
    \ 0;\n            var max_level = 0;\n            for (c <- group) {\n       \
    \         if (c == '(') {\n                    level += 1;\n                 \
    \   max_level = max(max_level, level);\n                } else if (c == ')') {\n\
    \                    level -= 1;\n                }\n            }\n         \
    \   max_level;\n        }).toList.map(x => x.toLong);\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028607
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val char_array = paren_string.toCharArray\n        var result = new\
    \ ListBuffer[Long]()\n        var max = 0\n        var count = 0\n        for\
    \ (char <- char_array) {\n            if (char == '(') {\n                count\
    \ += 1\n                max = max.max(count)\n            } else if (char == ')')\
    \ {\n                count -= 1\n            } else if (char == ' ') {\n     \
    \           result += max\n                max = 0\n                count = 0\n\
    \            }\n        }\n        result += max\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028608
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        groups.map(_.foldLeft(0l)((acc,\
    \ x) => {\n            if (x == '(') acc + 1\n            else if (x == ')') acc\
    \ - 1\n            else acc\n        })).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps2jo6isy.scala:18)\n\tat Problem.main(tmps2jo6isy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028608
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val paren_groups = paren_string.split(\" \")\n      val result_list\
    \ = Buffer[Long]()\n      var paren_stack = Stack[Char]()\n      var current_max\
    \ = 0\n      var local_max = 0\n      for (paren_group <- paren_groups) {\n  \
    \      for (paren <- paren_group) {\n          if (paren == '(') {\n         \
    \   paren_stack.push(paren)\n            local_max += 1\n            if (local_max\
    \ > current_max) current_max = local_max\n          }\n          else if (paren\
    \ == ')') {\n            if (paren_stack.isEmpty) throw new Exception(\"Empty\
    \ stack when encountering closing parenthesis.\")\n            if (paren_stack.pop\
    \ != '(') throw new Exception(\"Error in parenthesis matching.\")\n          \
    \  if (local_max > 0) local_max -= 1\n          }\n        }\n        result_list\
    \ += current_max\n        current_max = 0\n        local_max = 0\n      }\n  \
    \    result_list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028610
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var paren_stack = new Stack[Char]\n        var levels = new ListBuffer[Long]\n\
    \        var max_level = 0l\n        var i = 0\n        while (i < paren_string.length)\
    \ {\n            paren_string(i) match {\n                case '(' => {\n    \
    \                paren_stack.push('(')\n                    if (paren_stack.length\
    \ > max_level) max_level = paren_stack.length\n                }\n           \
    \     case ')' => {\n                    if (paren_stack.length > 0) paren_stack.pop\n\
    \                    else throw new Exception(\"Malformed parentheses string\"\
    )\n                }\n                case ' ' => {\n                    if (paren_stack.length\
    \ == 0) {\n                        levels += max_level\n                     \
    \   max_level = 0\n                    }\n                }\n                case\
    \ _ => throw new Exception(\"Invalid character in parentheses string\")\n    \
    \        }\n            i += 1\n        }\n        levels.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppgn47yca.scala:37)\n\tat Problem.main(tmppgn47yca.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028610
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").map(s => {\n            var stack = new\
    \ Stack[Char]\n            var max = 0\n            for (c <- s) {\n         \
    \       if (c == '(') {\n                    stack.push(c)\n                 \
    \   max = max max stack.size\n                } else if (c == ')') {\n       \
    \             stack.pop\n                }\n            }\n            max\n \
    \       }).toList.map(_.toLong)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028611
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val strings = paren_string.split(\" \").toList\n        for (str\
    \ <- strings) yield {\n            val stack = new ArrayStack[Char]\n        \
    \    var maxLevel = 0\n            var curLevel = 0\n            for (c <- str)\
    \ {\n                if (c == '(') {\n                    stack.push(c)\n    \
    \                curLevel += 1\n                    maxLevel = max(maxLevel, curLevel)\n\
    \                } else if (c == ')') {\n                    stack.pop\n     \
    \               curLevel -= 1\n                }\n            }\n            maxLevel\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028612
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val result = ListBuffer[Long]()\n        val parenGroups = paren_string.split(\"\
    \ \")\n        for (group <- parenGroups) {\n            var stack = List[Char]()\n\
    \            var currentDepth = 0\n            var maxDepth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    stack =\
    \ c :: stack\n                    currentDepth += 1\n                    maxDepth\
    \ = max(maxDepth, currentDepth)\n                } else if (c == ')') {\n    \
    \                stack = stack.tail\n                    currentDepth -= 1\n \
    \               }\n            }\n            result += maxDepth\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028615
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var output = List[Long]()\n        var paren = paren_string.split(\"\
    \ \")\n        for (i <- 0 until paren.length) {\n            var current = paren(i)\n\
    \            var count = 0\n            var result = 0\n            for (j <-\
    \ 0 until current.length) {\n                if (current(j) == '(') {\n      \
    \              count += 1\n                    result = max(result, count)\n \
    \               } else if (current(j) == ')') {\n                    count -=\
    \ 1\n                }\n            }\n            output ::= result\n       \
    \ }\n        output.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Map closing parentheses to opening parentheses\n        val paren_map\
    \ = Map('(' -> ')')\n        // input: \"(()())\"\n        // output: List(())\n\
    \        val result = paren_string.split(\" \").map(paren_substring => {\n   \
    \         val stack = Stack[Char]()\n            // max_depth stores the maximum\
    \ depth of nested parentheses in current substring.\n            var max_depth\
    \ = 0\n            // depth stores the depth of nested parentheses in current\
    \ substring.\n            var depth = 0\n            for (paren <- paren_substring)\
    \ {\n                if (paren == '(') {\n                    depth += 1\n   \
    \                 if (depth > max_depth) max_depth = depth\n                 \
    \   stack.push(paren)\n                } else if (paren == ')') {\n          \
    \          depth -= 1\n                    if (stack.isEmpty || paren_map(stack.pop)\
    \ != paren) throw new Exception(\"Invalid string: \" + paren_string)\n       \
    \         }\n            }\n            max_depth\n        }).toList\n       \
    \ // Return list of depths of nested parentheses.\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf3plqo94.scala:33:8\
    \ ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Int])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028613
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val num_groups = paren_string.split(\" \").length\n        val group_strs\
    \ = paren_string.split(\" \")\n        val depth_list = new ListBuffer[Long]()\n\
    \        for (i <- 0 until num_groups) {\n            var depth = 0\n        \
    \    var nested = 0\n            val group_str = group_strs(i)\n            for\
    \ (j <- 0 until group_str.length) {\n                val c = group_str(j)\n  \
    \              if (c == '(') {\n                    depth += 1\n             \
    \       nested = max(nested, depth)\n                } else if (c == ')') {\n\
    \                    depth -= 1\n                }\n            }\n          \
    \  depth_list += nested\n        }\n        depth_list.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028616
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        //System.out.println(paren_string)\n        val nested_parens = paren_string.split(\"\
    \ \")\n        val depths = new ListBuffer[Long]()\n        for (paren <- nested_parens)\
    \ {\n            depths += paren.count(x => x == '(') - paren.count(x => x ==\
    \ ')')\n        }\n        depths.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp09idm1ey.scala:19)\n\tat Problem.main(tmp09idm1ey.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        var output = List[Long]()\n\
    \        for (i <- 0 until parens.length) {\n            val paren = parens(i)\n\
    \            var left = 0\n            var right = 0\n            var max = 0\n\
    \            for (j <- 0 until paren.length) {\n                val c = paren(j)\n\
    \                if (c == '(') left += 1\n                else if (c == ')') right\
    \ += 1\n                if (left == right) max = max.max(left)\n            }\n\
    \            output ::= max\n        }\n        output.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3eld6y4z.scala:28)\n\tat Problem.main(tmp3eld6y4z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028620
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var depthList = new ListBuffer[Long]()\n        for (group <- paren_string.split(\"\
    \ \")) {\n            var currentDepth = 0l\n            var maxDepth = 0l\n \
    \           for (paren <- group) {\n                if (paren == '(') currentDepth\
    \ += 1l\n                else if (paren == ')') currentDepth -= 1l\n         \
    \       maxDepth = max(maxDepth, currentDepth)\n            }\n            depthList\
    \ += maxDepth\n        }\n        depthList.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028622
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var stack : Stack[Long] = new Stack()\n        var max_stack : Stack[Long]\
    \ = new Stack()\n        var max_level : Long = 0l\n        stack.push(0l)\n \
    \       max_stack.push(0l)\n        var list_of_max_levels : List[Long] = List()\n\
    \        for (paren <- paren_string) {\n            if (paren == '(') {\n    \
    \            stack.push(stack.top + 1)\n                if (stack.top > max_stack.top)\
    \ max_stack.push(stack.top)\n            }\n            else if (paren == ')')\
    \ {\n                stack.pop\n                if (stack.top == max_stack.top)\
    \ {\n                    max_stack.pop\n                    if (max_stack.size\
    \ == 0) max_stack.push(0l)\n                }\n            }\n            else\
    \ if (paren == ' ') {\n                list_of_max_levels = list_of_max_levels\
    \ :+ max_stack.top\n                stack.clear\n                max_stack.clear\n\
    \                stack.push(0l)\n                max_stack.push(0l)\n        \
    \    }\n        }\n        list_of_max_levels = list_of_max_levels :+ max_stack.top\n\
    \        return list_of_max_levels\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      val parenGroups = paren_string.split(\" \")\n      for (group <- parenGroups)\
    \ yield {\n        var depth : Long = 0\n        var max_depth : Long = 0\n  \
    \      for (ch <- group) {\n          if (ch == '(') depth += 1\n          else\
    \ if (ch == ')') depth -= 1\n          if (depth > max_depth) max_depth = depth\n\
    \        }\n        max_depth\n      }.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpao0dt93n.scala:20:8 -------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m      \e[33mfor\e[0m (group <- parenGroups) \e[33myield\e\
    [0m {\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mdepth\e[0m : \e[35mLong\e[0m\
    \ = \e[31m0\e[0m\n\e[31m13 |\e[0m        \e[33mvar\e[0m \e[36mmax_depth\e[0m :\
    \ \e[35mLong\e[0m = \e[31m0\e[0m\n\e[31m14 |\e[0m        \e[33mfor\e[0m (ch <-\
    \ group) {\n\e[31m15 |\e[0m          \e[33mif\e[0m (ch == \e[31m'('\e[0m) depth\
    \ += \e[31m1\e[0m\n\e[31m16 |\e[0m          \e[33melse\e[0m \e[33mif\e[0m (ch\
    \ == \e[31m')'\e[0m) depth -= \e[31m1\e[0m\n\e[31m17 |\e[0m          \e[33mif\e\
    [0m (depth > max_depth) max_depth = depth\n\e[31m18 |\e[0m        }\n\e[31m19\
    \ |\e[0m        max_depth\n\e[31m20 |\e[0m      }.toList\n\e[31m\e[31m   |\e[0m\
    \                                       ^\e[0m\n\e[31m   |\e[0m         value\
    \ toList is not a member of Long - did you mean Long.toInt?\n1 error found\n"
  stdout: ''
  timestamp: 1660028619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var subparen_strings = paren_string.split(\" \").toList\n       \
    \ var result : List[Long] = Nil\n        subparen_strings.foreach(n => result\
    \ = result :+ getDepth(n))\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw9gax187.scala:12:57 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        subparen_strings.foreach(\e[36mn\e[0m => result\
    \ = result :+ getDepth(n))\n\e[31m\e[31m   |\e[0m                            \
    \                             ^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                                    Not found: getDepth\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660028616
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val pairs = paren_string.split(\" \").map(x => x.toList)\n      \
    \  var result = List[Long]()\n        pairs.foreach { x =>\n            result\
    \ = result :+ x.foldLeft(0l)((acc, cur) => {\n                    if (cur == '(')\n\
    \                        acc + 1\n                    else if (cur == ')')\n \
    \                       acc - 1\n                    else \n                 \
    \       acc\n                })\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxszw552d.scala:25)\n\tat Problem.main(tmpxszw552d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      return paren_string.split(\" \").map(x => getMaxNestingParens(x)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyzlh8rdm.scala:10:46 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m      \e[33mreturn\e[0m paren_string.split(\e[31m\" \"\
    \e[0m).map(\e[36mx\e[0m => getMaxNestingParens(x)).toList\n\e[31m\e[31m   |\e\
    [0m                                              ^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                          Not found: getMaxNestingParens\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpyzlh8rdm.scala:10:69 -----------------------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m      \e[33mreturn\e[0m paren_string.split(\e[31m\" \"\
    \e[0m).map(\e[36mx\e[0m => getMaxNestingParens(x)).toList\n\e[31m\e[31m   |\e\
    [0m                                                                     ^\e[0m\n\
    \e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660028622
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var max_nesting_levels : ArrayBuffer[Long] = new ArrayBuffer[Long]\n\
    \        var temp_stack : ArrayBuffer[Char] = new ArrayBuffer[Char]\n        for\
    \ (paren_group <- paren_string.split(\" \")) {\n            var local_nesting_level\
    \ : Long = 0\n            for (paren <- paren_group) {\n                if (paren\
    \ == '(') {\n                    temp_stack += paren\n                    local_nesting_level\
    \ += 1\n                }\n                else if (paren == ')') {\n        \
    \            if (temp_stack.length > 0) {\n                        temp_stack\
    \ -= temp_stack.last\n                        local_nesting_level -= 1\n     \
    \               }\n                }\n            }\n            max_nesting_levels\
    \ += local_nesting_level\n        }\n        return max_nesting_levels.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxy1cp5b9.scala:31)\n\tat Problem.main(tmpxy1cp5b9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028625
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Stores the state of parens as 0 (not-inside), 1 (inside), or -1\
    \ (error)\n        var state : List[Long] = List(0l.toLong)\n        var max_state\
    \ : Long = 0l.toLong\n        for (ch <- paren_string) {\n            ch match\
    \ {\n                case '(' => {\n                    state = (state.head +\
    \ 1l.toLong) :: state\n                    max_state = max(max_state, state.head)\n\
    \                }\n                case ')' => {\n                    if (state.head\
    \ > 0) {\n                        state = (state.head - 1l.toLong) :: state.tail\n\
    \                    } else {\n                        state = (-1l.toLong) ::\
    \ state\n                    }\n                }\n                case ' ' =>\
    \ {\n                    if (state.head != 0) {\n                        state\
    \ = (state.head + 1l.toLong) :: state\n                    } else {\n        \
    \                state = (state.head) :: state\n                    }\n      \
    \          }\n                case _ => {\n                    state = (state.head)\
    \ :: state\n                }\n            }\n        }\n        return state.map((x\
    \ : Long) => {\n            if (x == -1) max_state else x\n        })\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_7d_x0gw.scala:43)\n\tat Problem.main(tmp_7d_x0gw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028625
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var stack : Stack[Char] = new Stack\n        var maxDepth : Long\
    \ = 0\n        for (ch <- paren_string) {\n            if (ch == '(') {\n    \
    \            stack.push(ch)\n                maxDepth = max(maxDepth, stack.size)\n\
    \            } else if (ch == ')') {\n                stack.pop\n            }\n\
    \        }\n        return List[Long](maxDepth)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcmhfkdzx.scala:23)\n\tat Problem.main(tmpcmhfkdzx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028627
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        var index = 0\n        while (index\
    \ < paren_string.length) {\n            var current_char = paren_string(index)\n\
    \            if (current_char == '(') {\n                var nest_count = 0\n\
    \                while (current_char != ')' && index < paren_string.length) {\n\
    \                    index += 1\n                    if (current_char == '(')\
    \ {\n                        nest_count += 1\n                    }\n        \
    \            current_char = paren_string(index)\n                }\n         \
    \       result = nest_count :: result\n            }\n            else {\n   \
    \             index += 1\n            }\n        }\n        return result\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2s2dnruz.scala:32)\n\tat Problem.main(tmp2s2dnruz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028627
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_stack = new Stack[Char]\n        var max_level = 0\n  \
    \      var max_level_for_each_group = new ListBuffer[Long]\n        for (c <-\
    \ paren_string) {\n            if (c == '(') {\n                paren_stack.push(c)\n\
    \                max_level += 1\n            }\n            else if (c == ')')\
    \ {\n                paren_stack.pop\n                max_level -= 1\n       \
    \     }\n            else if (c == ' ') {\n                if (paren_stack.isEmpty)\
    \ {\n                    max_level_for_each_group += max_level\n             \
    \       max_level = 0\n                }\n            }\n        }\n        max_level_for_each_group\
    \ += max_level\n        max_level_for_each_group.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplui7l2a8.scala:33)\n\tat Problem.main(tmplui7l2a8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028627
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        def parse(paren_group\
    \ : String) : Long = {\n            def parseR(paren_group : String, current_nesting\
    \ : Long, max_nesting : Long) : Long = {\n                if (paren_group.isEmpty)\
    \ max_nesting\n                else if (paren_group.charAt(0) == '(') parseR(paren_group.tail,\
    \ current_nesting + 1, max(current_nesting + 1, max_nesting))\n              \
    \  else if (paren_group.charAt(0) == ')') parseR(paren_group.tail, current_nesting\
    \ - 1, max(current_nesting - 1, max_nesting))\n                else parseR(paren_group.tail,\
    \ current_nesting, max_nesting)\n            }\n            parseR(paren_group,\
    \ 0, 0)\n        }\n        paren_groups.map(parse(_)).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val paren_groups = paren_string.split(\" \")\n        var results\
    \ = List[Long]()\n        for (p <- paren_groups) {\n            results = results\
    \ :+ (findDeepestLevel(p))\n        }\n        results\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphrqzmu_j.scala:13:34 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            results = results :+ (findDeepestLevel(p))\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Not found: findDeepestLevel\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028621
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parens = paren_string.split(\" \")\n        var answer = List[Long]()\n\
    \        for (paren <- parens) {\n            var stack = Stack[Char]()\n    \
    \        var maximum = 0\n            var current = 0\n            for (ch <-\
    \ paren) {\n                if (ch == '(') {\n                    stack.push(ch)\n\
    \                    current += 1\n                    maximum = max(maximum,\
    \ current)\n                } else if (ch == ')') {\n                    if (stack.size\
    \ > 0) {\n                        stack.pop\n                        current -=\
    \ 1\n                    }\n                }\n            }\n            answer\
    \ = answer :+ maximum\n        }\n        answer\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028630
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result : List[Long] = List()\n        var depth : Long = 0\n\
    \        for (c <- paren_string) {\n            c match {\n                case\
    \ '(' => depth += 1\n                case ')' => {\n                    result\
    \ = depth :: result\n                    depth -= 1\n                }\n     \
    \           case _ => Unit\n            }\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp57n1tapv.scala:19:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m _ => Unit\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^\e[0m\n\e[31m   |\e[0mReference to \e\
    [33mobject\e[0m \e[35mUnit\e[0m in \e[33mpackage\e[0m \e[35mscala\e[0m should\
    \ not have survived,\n\e[31m   |\e[0mit should have been processed and eliminated\
    \ during expansion of an enclosing macro or term erasure.\n1 error found\n"
  stdout: ''
  timestamp: 1660028626
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val groups = paren_string.split(\" \")\n        val nested_levels\
    \ = new ListBuffer[Long]()\n        for (group <- groups) {\n            var max\
    \ = 0\n            var current = 0\n            for (paren <- group) {\n     \
    \           if (paren == '(') {\n                    current += 1\n          \
    \          max = max.max(current)\n                } else if (paren == ')') {\n\
    \                    current -= 1\n                }\n            }\n        \
    \    nested_levels += max\n        }\n        nested_levels.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028630
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val parenStrings = paren_string.trim.split(\" \")\n        var result\
    \ = List[Long]()\n        for (parenString <- parenStrings) {\n            var\
    \ level = 0\n            var maxLevel = 0\n            for (i <- 0 until parenString.length)\
    \ {\n                val c = parenString(i)\n                if (c == '(') {\n\
    \                    level += 1\n                    maxLevel = max(maxLevel,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result ::= maxLevel\n     \
    \   }\n        result.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028630
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        paren_string.split(\" \").toList.map(s => {\n            var depth\
    \ = 0l\n            var max_depth = 0l\n            for (c <- s) {\n         \
    \       if (c == '(') depth += 1\n                else if (c == ')') depth -=\
    \ 1\n                max_depth = max(max_depth, depth)\n            }\n      \
    \      max_depth\n        })\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028630
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Write your own\n        val s : Array[String] = paren_string.split(\"\
    \ \")\n        val n : Int = s.length\n        val f : Array[Long] = new Array[Long](n)\n\
    \        for (i <- 0 until n) {\n        \tvar l : Int = 0\n        \tvar ret\
    \ : Long = 0\n        \tfor (c <- s(i)) {\n        \t\tif (c == '(') l += 1\n\
    \        \t\telse if (c == ')') l -= 1\n        \t\tret = ret max l\n        \t\
    }\n        \tf(i) = ret\n        }\n        f.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        // Strategy: go through the whole string character by character.\n\
    \        // Keep a stack of ( and ). When we see a (, push it. When we see a ),\
    \ pop it.\n        // The maximum stack size will be the deepest level of nesting.\n\
    \        // The stack size will be 0 when there is no (parentheses.\n        //\
    \ The maximum stack size will be the deepest level of nesting.\n        var stack\
    \ = new ArrayStack[Char]()\n        var max_stack_size = 0\n        var output\
    \ = List[Long]()\n        paren_string.foreach {\n            c =>\n         \
    \       if (c == '(') {\n                    stack.push(c)\n                 \
    \   max_stack_size = max(max_stack_size, stack.size)\n                } else if\
    \ (c == ')') {\n                    stack.pop()\n                } else if (c\
    \ == ' ') {\n                    output = output :+ max_stack_size.toLong\n  \
    \                  max_stack_size = 0\n                }\n        }\n        output\
    \ = output :+ max_stack_size.toLong\n        return output\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var res = List[Long]()\n        for (group <- paren_string.split(\"\
    \ \")) {\n            var level = 0\n            var max_level = 0\n         \
    \   for (i <- 0 until group.length) {\n                val c = group(i)\n    \
    \            if (c == '(') level += 1\n                else if (c == ')') level\
    \ -= 1\n                max_level = max(max_level, level)\n            }\n   \
    \         res = res :+ max_level\n        }\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"\
    () (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val result = ListBuffer[Long]()\n        for (paren_group <- paren_string.split(\"\
    \ \")) {\n            var count = 0\n            var max_count = 0\n         \
    \   for (c <- paren_group) {\n                if (c == '(') count += 1\n     \
    \           else if (c == ')') count -= 1\n                if (count > max_count)\
    \ max_count = count\n            }\n            result += max_count\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        var result = List[Long]()\n        paren_string.split(\" \").foreach(paren_group\
    \ => {\n            var max_level = 0\n            var current_level = 0\n   \
    \         for (i <- 0 until paren_group.length) {\n                if (paren_group(i)\
    \ == '(') {\n                    current_level += 1\n                    max_level\
    \ = max(max_level, current_level)\n                } else if (paren_group(i) ==\
    \ ')') {\n                    current_level -= 1\n                }\n        \
    \    }\n            result = result :+ max_level\n        })\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n      var stack = new Stack[Char]()\n      var result = new ListBuffer[Long]()\n\
    \      var maxnest = 0\n      var nest = 0\n      for (c <- paren_string) {\n\
    \        if (c == ' ') {\n          if (stack.isEmpty) {\n            result +=\
    \ maxnest\n            maxnest = 0\n            nest = 0\n          }\n      \
    \  } else if (c == '(') {\n          stack.push(c)\n          nest += 1\n    \
    \      maxnest = max(maxnest, nest)\n        } else if (c == ')') {\n        \
    \  stack.pop\n          nest -= 1\n        }\n      }\n      result += maxnest\n\
    \      result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        def getNestedLevel(chars : List[Char]) : Long = {\n            def\
    \ go(level : Long, chars : List[Char]) : Long = {\n                if (chars.isEmpty)\
    \ level\n                else if (chars.head == '(') go(level + 1, chars.tail)\n\
    \                else if (chars.head == ')') go(level - 1, chars.tail)\n     \
    \           else go(level, chars.tail)\n            }\n            go(0, chars)\n\
    \        }\n        def go(paren_string : String) : List[Long] = {\n         \
    \   if (paren_string.isEmpty) List()\n            else if (paren_string.head ==\
    \ ' ') go(paren_string.tail)\n            else {\n                val leftParenIndex\
    \ = paren_string.indexOf(\" \")\n                if (leftParenIndex == -1) {\n\
    \                    val nestedLevel = getNestedLevel(paren_string.toList)\n \
    \                   List(nestedLevel)\n                }\n                else\
    \ {\n                    val nestedLevel = getNestedLevel(paren_string.substring(0,\
    \ leftParenIndex).toList)\n                    nestedLevel :: go(paren_string.substring(leftParenIndex))\n\
    \                }\n            }\n        }\n        go(paren_string)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa_pzf3rc.scala:37)\n\tat Problem.main(tmpa_pzf3rc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n    // For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] =\
    \ {\n        val group_strings = paren_string.split(\" \")\n        var max_paren_level_list\
    \ = List[Long]()\n        for (group_string <- group_strings) {\n            var\
    \ current_paren_level = 0\n            var max_paren_level = 0\n            for\
    \ (ch <- group_string) {\n                if (ch == '(') {\n                 \
    \   current_paren_level += 1\n                    if (current_paren_level > max_paren_level)\
    \ max_paren_level = current_paren_level\n                }\n                else\
    \ if (ch == ')') {\n                    current_paren_level -= 1\n           \
    \     }\n            }\n            max_paren_level_list = max_paren_level_list\
    \ :+ max_paren_level\n        }\n        return max_paren_level_list\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028633
