language: scala
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        var pn = n\n        var power\
    \ = 1l\n        while (pn > 1) {\n            var factor = n / pn\n          \
    \  var rem = n - pn * factor\n            power = (power * factor) % p\n     \
    \       if (power == 0) return 1\n            n = pn\n            pn = rem\n \
    \       }\n        return power\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp5edzq4wq.scala:24:14 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            n = pn\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val n\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009878
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        for (i <- 0 until n.toInt) res = (res\
    \ * 2l) % p\n        return res\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009882
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def modp(n : Long, b : Long, p : Long) : Long = if (n ==\
    \ 0) 1 else if (n % 2 == 0) modp(n / 2, (b * b) % p, p) else (b * modp(n - 1,\
    \ b, p)) % p\n        modp(n, n, p)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4x539glr.scala:20)\n\tat Problem.main(tmp4x539glr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        var r = modp(n / 2, p)\n \
    \       r = (r * r) % p\n        if (n % 2 == 1) r = (r * 2) % p\n        return\
    \ r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // Precondition: n >= 0\n        if (n == 0) {\n       \
    \     return 1\n        }\n        var x = modp(n / 2, p)\n        var x_times_x\
    \ = (x * x) % p\n        if (n % 2 == 1) {\n            x_times_x *= 2\n     \
    \   }\n        return x_times_x % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1l\n        var r = modp(n / 2, p)\n\
    \        var t = r * r % p\n        if (n % 2 == 1) t = t * 2 % p\n        return\
    \ t\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var r = n % p\n        if (r < 0) r += p\n        r\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqxc8h1cx.scala:22)\n\tat Problem.main(tmpqxc8h1cx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var r = 1l\n        var b = 2l\n        var e = n\n    \
    \    while (e > 0) {\n            if (e % 2 == 1) {\n                r = (r *\
    \ b) % p\n            }\n            e = e / 2\n            b = (b * b) % p\n\
    \        }\n        return r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) {\n            1\n        } else {\n       \
    \     val modp_rec = modp(n / 2, p)\n            if (n % 2 == 0) {\n         \
    \       (modp_rec * modp_rec) % p\n            } else {\n                (modp_rec\
    \ * modp_rec * 2) % p\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def pow(x : Long, n : Long) : Long = {\n            if (n\
    \ == 0) 1 else\n            if (n % 2 == 0) pow(x * x % p, n / 2)\n          \
    \  else pow(x * x % p, n / 2) * x % p\n        }\n        pow(2, n) % p\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009881
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        var nn = n\n        while (nn > 0)\
    \ {\n            if ((nn & 1) == 1) res = (res * n) % p\n            nn = nn >>\
    \ 1\n            n = (n * n) % p\n        }\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpzr19zxkz.scala:21:14 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009877
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var sum = 1l\n        for (i <- 1 to n.toInt) {\n      \
    \      sum = (sum * 2l) % p\n        }\n        return sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) {\n            return 1\n        }\n       \
    \ var c = 1l\n        var a = 2l\n        var b = n\n        while (b > 0) {\n\
    \            if ((b & 1) != 0) {\n                c = (c * a) % p\n          \
    \  }\n            a = (a * a) % p\n            b >>= 1\n        }\n        return\
    \ c\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def calc(x : Long, n : Long, p : Long) : Long = {\n    \
    \        n match {\n                case 0 => 1\n                case _ => {\n\
    \                    val y = calc(x, n / 2, p)\n                    val yy = (y\
    \ * y) % p\n                    if (n % 2 == 0) yy else (x * yy) % p\n       \
    \         }\n            }\n        }\n        calc(n, p - 2, p)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqhffhiz9.scala:29)\n\tat Problem.main(tmpqhffhiz9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        var i : Long = 0\n      \
    \  for(i <- 0l to n) {\n            result = (result * 2) % p\n        }\n   \
    \     return result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqcdffzfp.scala:24)\n\tat Problem.main(tmpqcdffzfp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009881
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < 0) modp(p - (abs(n) % p), p)\n        else if (n\
    \ == 0) 1\n        else if (n == 1) n\n        else {\n            var a = 2l\n\
    \            var b = 1l\n            var c = 1l\n            var d = 0l\n    \
    \        while (a != 1) {\n                val quotient = n / a\n            \
    \    d += quotient * c\n                d %= p\n                b = n % a\n  \
    \              n = a\n                a = b\n                c = d\n         \
    \       d = b\n            }\n            n % p\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpumo0wsta.scala:29:18 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                n = a\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val n\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var a = 1l\n        var b = n\n        while (b > 0) {\n\
    \            if ((b & 1) == 1) a = (a * n) % p\n            b >>= 1\n        \
    \    n = (n * n) % p\n        }\n        return a\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpaqta_6qp.scala:21:14 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var s = 1l\n        var x = n\n        while (x > 0) {\n\
    \            if ((x & 1) == 1) {\n                s = (s * n) % p\n          \
    \  }\n            x >>= 1\n            n = (n * n) % p\n        }\n        return\
    \ s\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp9e7r2yre.scala:23:14 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009878
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var r = 1l\n        var d = 2l\n        var e = n\n    \
    \    while (e > 0) {\n            if ((e & 1) != 0) {\n                r = (r\
    \ * d) % p\n            }\n            d = (d * d) % p\n            e >>= 1\n\
    \        }\n        return r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        var a : Long = 2\n      \
    \  var b : Long = n\n        while (b > 0) {\n            if ((b & 1) > 0) {\n\
    \                result = (result * a) % p\n            }\n            a = (a\
    \ * a) % p\n            b >>= 1\n        }\n        return result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n \
    \   assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n\
    \    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n\
    \    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) {\n            1\n        } else {\n       \
    \     var ans = modp(n / 2, p)\n            ans = (ans * ans) % p\n          \
    \  if (n % 2 == 1) ans = (ans * 2) % p\n            ans\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        val res = modp(n / 2, p)\n\
    \        val res2 = (res * res) % p\n        if (n % 2 == 0) {\n            res2\n\
    \        } else {\n            (res2 * 2) % p\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        var u = n % p\n        var v = p\n\
    \        while (u > 0) {\n            if ((u & 1) == 1) res = (res * u) % p\n\
    \            u = u >> 1\n            v = (v * v) % p\n        }\n        res\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuwp6uugi.scala:28)\n\tat Problem.main(tmpuwp6uugi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var a = 1l\n        var b = n\n        while (b > 0) {\n\
    \            if ((b & 1) == 1) a = (a * n) % p\n            b >>= 1\n        \
    \    n = (n * n) % p\n        }\n        return a\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpaqta_6qp.scala:21:14 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009878
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        if (n % 2 == 0) {\n      \
    \      val m = modp(n / 2, p)\n            return (m * m) % p\n        }\n   \
    \     else return (modp(n - 1, p) * n) % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd2i8gf5q.scala:25)\n\tat Problem.main(tmpd2i8gf5q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009886
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var pow = n\n        var result = 1l\n        while (pow\
    \ > 0) {\n            if ((pow & 1) == 1) {\n                result = (result\
    \ * n) % p\n            }\n            pow >>= 1\n            n = (n * n) % p\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpvlrqppv_.scala:23:14 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        var accum = 1l\n        for\
    \ (x <- 1 to abs(n).toInt) {\n            accum = (accum * 2) % p\n        }\n\
    \        if (n > 0) accum else (p - accum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var n_ = BigInt(n)\n        val p_ = BigInt(p)\n       \
    \ var prod = BigInt(1)\n        for (i <- 0 until 32) {\n            if ((n_ &\
    \ (1 << i)) != 0) prod = (prod * pow(2, i)).mod(p_)\n        }\n        prod.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9ctvd482.scala:20:56\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m ((n_\
    \ & (\e[31m1\e[0m << i)) != \e[31m0\e[0m) prod = (prod * pow(\e[31m2\e[0m, i)).mod(p_)\n\
    \e[31m\e[31m   |\e[0m                                                     ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                     Found:\
    \    Double\n\e[31m   |\e[0m                                                 \
    \    Required: BigInt\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009887
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var c = 1l\n        for (i <- 0l until n) {\n          \
    \  c = c * 2l\n            c = c % p\n        }\n        return c\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n \
    \   assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n\
    \    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n\
    \    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // Implement this function yourself\n        var res = 1L\n\
    \        var pw = n\n        var mod = p\n        while (pw > 0) {\n         \
    \   if ((pw & 1) == 1) {\n                res = (res * mod) % p\n            }\n\
    \            pw = pw >> 1\n            mod = (mod * mod) % p\n        }\n    \
    \    return res\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo5dbbyf2.scala:30)\n\tat Problem.main(tmpo5dbbyf2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        var value : Long = 2\n  \
    \      while (n > 0) {\n            if ((n & 1) != 0) result = (result * value)\
    \ % p\n            value = (value * value) % p\n            n >>= 1\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx_jp2rao.scala:21:14 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            n >>= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^\e[0m\n\e[31m   |\e[0m            value >>= is not a member\
    \ of Long - did you mean n.>=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var x = 1l\n        var power = n\n        var i = 1l\n\
    \        while (i <= p) {\n            if ((i & p) != 0) {\n                x\
    \ = (x * power) % p\n            }\n            power = (power * power) % p\n\
    \            i = i << 1\n        }\n        return x\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk6dc98jt.scala:30)\n\tat Problem.main(tmpk6dc98jt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) {\n            1\n        } else {\n       \
    \     if (n % 2 == 0) {\n                val l = modp(n / 2, p)\n            \
    \    (l * l) % p\n            } else {\n                (2 * modp(n - 1, p)) %\
    \ p\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        var base : Long = 2\n   \
    \     var exp : Long = n\n        while (exp > 0) {\n            if ((exp & 1)\
    \ == 1) {\n                result = (result * base) % p\n            }\n     \
    \       exp >>= 1\n            base = (base * base) % p\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      if (n == 0) {\n        return 1\n      }\n      if (n % 2\
    \ == 0) {\n        val m = modp(n / 2, p)\n        return ((m * m) % p)\n    \
    \  }\n      else {\n        return ((modp(n - 1, p) * 2) % p)\n      }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        var base : Long = 2\n   \
    \     var exp : Long = n\n        while (exp > 0) {\n            if ((exp & 1)\
    \ == 1) result = (result * base) % p\n            exp >>= 1\n            base\
    \ = (base * base) % p\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var a = Array.fill[Long](100)(0)\n        var x = n\n  \
    \      var i = 0\n        while (x > 0) {\n            a(i) = x % 2\n        \
    \    x /= 2\n            i += 1\n        }\n        var t = a.length - 1\n   \
    \     var k = 1l\n        while (t >= 0) {\n            k = (k * k) % p\n    \
    \        if (a(t) == 1) {\n                k = (k * n) % p\n            }\n  \
    \          t -= 1\n        }\n        k\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkymlrn06.scala:36)\n\tat Problem.main(tmpkymlrn06.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < 0) modp(n + p, p)\n        else if (n < p) n\n \
    \       else {\n            val q = n / p\n            val r = n - q * p\n   \
    \         if (2 * r >= p) r - p\n            else r\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg63z37gz.scala:27)\n\tat Problem.main(tmpg63z37gz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def mp(n : Long, p : Long, r : Long) : Long = {\n      \
    \      if (n == 0) return r\n            if (n % 2 == 0) mp(n / 2, p * p % p,\
    \ r)\n            else mp(n - 1, p * p % p, (r * p) % p)\n        }\n        mp(n,\
    \ p, 1)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.mp$1(tmp0a7ipoxp.scala:18)\n\
    \tat Problem$.modp(tmp0a7ipoxp.scala:21)\n\tat Problem$.main(tmp0a7ipoxp.scala:24)\n\
    \tat Problem.main(tmp0a7ipoxp.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var m = p\n        var a = n\n        var b = p\n      \
    \  var x = 0l\n        var y = 1l\n        while (a > 1) {\n            val q\
    \ = a / b\n            val t = b\n            b = a % b\n            a = t\n \
    \           val t2 = x\n            x = y - q * x\n            y = t2\n      \
    \  }\n        if (y < 0) y += m\n        y\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbtqqfkza.scala:34)\n\tat Problem.main(tmpbtqqfkza.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var x = n\n        var y = 1l\n        var b = 2l\n    \
    \    while (x > 0) {\n            if ((x & 1) == 1) {\n                y = (y\
    \ * b) % p\n            }\n            x >>= 1\n            b = (b * b) % p\n\
    \        }\n        y\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1l\n        if (n % 2 == 0) {\n     \
    \       val m = modp(n / 2, p)\n            return (m * m) % p\n        }\n  \
    \      else {\n            val m = modp(n - 1, p)\n            return (2 * m)\
    \ % p\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1l\n        var i : Long = 0l\n    \
    \    while (i < n) {\n            result = (result * 2l) % p\n            i +=\
    \ 1l\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def f(n : Long, p : Long, result : Long) : Long = {\n  \
    \          if (n == 0) result\n            else if (n % 2 == 0) f(n / 2, p * p\
    \ % 1000000007, result)\n            else f(n - 1, p, result * p % 1000000007)\n\
    \        }\n        f(n, 1, 1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpks1_ulao.scala:24)\n\tat Problem.main(tmpks1_ulao.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def helper(n : Long, x : Long, p : Long) : Long = {\n  \
    \          if (n == 0) 1 else if (n % 2 == 0) (helper(n / 2, x * x % p, p) % p)\
    \ else (x * helper(n - 1, x, p) % p)\n        }\n        helper(n, 2, p)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var v = 0l\n        var a = 1l\n        var b = n\n    \
    \    while (b > 0) {\n            if ((b & 1) == 1) {\n                v = (v\
    \ + a) % p\n            }\n            a = (a * 2) % p\n            b >>= 1\n\
    \        }\n        v\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9du_qzu0.scala:30)\n\tat Problem.main(tmp9du_qzu0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      var nd = n\n      var prod = 1l\n      while (nd > 0) {\n\
    \        if ((nd & 1) == 1) prod = (prod * 2) % p\n        nd >>= 1\n      }\n\
    \      prod\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpibgk5y9v.scala:25)\n\tat Problem.main(tmpibgk5y9v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      var ans = 1l\n      var curr = 2l\n      var pow = n\n   \
    \   while (pow > 0) {\n        if (pow % 2 == 1) ans = (ans * curr) % p\n    \
    \    curr = (curr * curr) % p\n        pow /= 2\n      }\n      ans\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < 0) {\n            modp(n + p, p)\n        } else\
    \ if (n < p) {\n            n\n        } else {\n            n % p\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph09o42c_.scala:26)\n\tat Problem.main(tmph09o42c_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // Return 2^n modulo p (be aware of numerics).\n       \
    \ // >>> modp((3l), (5l))\n        // (3l)\n        // >>> modp((1101l), (101l))\n\
    \        // (2l)\n        // >>> modp((0l), (101l))\n        // (1l)\n       \
    \ // >>> modp((3l), (11l))\n        // (8l)\n        // >>> modp((100l), (101l))\n\
    \        // (1l)\n        var b = 2l\n        var c = 1l\n        var i = 0l\n\
    \        while (i < n) {\n            {\n                if ((i % 100l) == 0l)\
    \ c = (c * b) % p\n                i += 1l\n            }\n        }\n       \
    \ c\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbsmkaq5g.scala:39)\n\tat Problem.main(tmpbsmkaq5g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009897
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var m = n\n        var ans = BigInt(1)\n        while (m\
    \ > 0) {\n            if ((m & 1) == 1) {\n                ans = (ans * 2) % p\n\
    \            }\n            m = m >> 1\n        }\n        ans.toLong\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi6v6yt06.scala:27)\n\tat Problem.main(tmpi6v6yt06.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val b = ArrayBuffer[Int]()\n        var n1 = n\n       \
    \ while (n1 > 0) {\n            b += ((n1 % 2).toInt)\n            n1 /= 2\n \
    \       }\n        b.reverse\n        var power = BigInt(1)\n        var base\
    \ = BigInt(2)\n        var num = BigInt(1)\n        for (d <- b) {\n         \
    \   if (d == 1) {\n                num = (num * base) % p\n            }\n   \
    \         base = (base * base) % p\n        }\n        num.toLong\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n \
    \   assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n\
    \    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n\
    \    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        var k = n\n        var i = p - 2l\n\
    \        while (i > 0) {\n            if (i % 2l == 1l) {\n                res\
    \ = (res * k) % p\n            }\n            k = (k * k) % p\n            i /=\
    \ 2l\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6jnsgk69.scala:29)\n\tat Problem.main(tmp6jnsgk69.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009898
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var nn = n\n        var pp = p\n        var r = 1l\n   \
    \     while (nn > 0) {\n            if ((nn & 1) != 0) {\n                r =\
    \ (r * n) % p\n            }\n            nn >>= 1\n            n = (n * n) %\
    \ p\n        }\n        return r\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpt3na303d.scala:24:14 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var r : Long = 1\n        var b : Long = 2\n        var\
    \ e : Long = n\n        while (e > 0) {\n            if ((e & 1) != 0) {\n   \
    \             r = (r * b) % p\n            }\n            e >>= 1\n          \
    \  b = (b * b) % p\n        }\n        return r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      var nn = n\n      var pp = p\n      if (nn == 0) return 1\n\
    \      var r = 0l\n      if (nn % 2 == 1) {\n        r = modp(nn - 1, pp) * 2\
    \ % pp\n      } else {\n        r = modp(nn / 2, pp)\n        r = r * r % pp\n\
    \      }\n      return r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1 else (modp(n / 2, p) * (if (n % 2 == 0) 1\
    \ else 2)) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd3lrv91e.scala:19)\n\tat Problem.main(tmpd3lrv91e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009897
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        var bitval : Long = 2\n \
    \       var exp : Long = n\n        while (exp > 0) {\n            if ((exp &\
    \ 1) == 1) {\n                result = (result * bitval) % p\n            }\n\
    \            bitval = (bitval * bitval) % p\n            exp >>= 1\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009897
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1l\n        var power : Long = n\n \
    \       var base : Long = 2l\n        while (power > 0) {\n            if ((power\
    \ & 1) == 1) {\n                result = (result * base) % p\n            }\n\
    \            base = (base * base) % p\n            power >>= 1\n        }\n  \
    \      return result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) {\n            return 1\n        }\n       \
    \ var k = n / 2\n        var ret = modp(k, p)\n        if (n % 2 == 0) {\n   \
    \         return ret * ret % p\n        } else {\n            return ret * ret\
    \ * 2 % p\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        var power : Long = n\n  \
    \      var index : Long = 1\n        while (index <= p) {\n            if ((index\
    \ & p) != 0) {\n                result = (result * power) % p\n            }\n\
    \            power = (power * power) % p\n            index = index << 1\n   \
    \     }\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9i6yggkk.scala:30)\n\tat Problem.main(tmp9i6yggkk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // assert(n >= 0)\n        if (n == 0) return 1\n      \
    \  else if (n % 2 == 0) {\n            val x = modp(n / 2, p)\n            (x\
    \ * x) % p\n        } else {\n            (2 * modp(n - 1, p)) % p\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def binaryExp(n : Long, p : Long) : Long = {\n         \
    \   if (n == 0) 1\n            else if (n % 2 == 0) {\n                val res\
    \ = binaryExp(n / 2, p)\n                (res * res) % p\n            } else {\n\
    \                (2 * binaryExp(n - 1, p)) % p\n            }\n        }\n   \
    \     binaryExp(n, p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009898
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        var r = (n / 2) % p\n    \
    \    r = r * modp(n - r * 2, p) % p\n        if (n % 2 == 0) return r else return\
    \ (p - r) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.modp(tmpahoqwcxi.scala:15)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.scala:18)\n\tat Problem$.modp(tmpahoqwcxi.scala:18)\n\
    \tat Problem$.modp(tmpahoqwcxi.sc"
  stdout: ''
  timestamp: 1660009898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) {\n            1\n        } else {\n       \
    \     val x = modp(n / 2, p)\n            if (n % 2 == 0) {\n                (x\
    \ * x) % p\n            } else {\n                (((x * x) % p) * 2) % p\n  \
    \          }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      if (n == 0) return 1\n      if (n % 2 == 0) {\n        var\
    \ res = modp(n / 2, p)\n        res = (res * res) % p\n        return res\n  \
    \    }\n      else {\n        var res = (modp(n - 1, p) * n) % p\n        return\
    \ res\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp93qmdqb8.scala:29)\n\tat Problem.main(tmp93qmdqb8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009898
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        var n_ = n\n        var p_ = p\n \
    \       while (n_ > 0) {\n            if ((n_ & 1) != 0) {\n                res\
    \ = (res * n_) % p_\n            }\n            n_ = n_ >> 1\n            n_ =\
    \ (n_ * n_) % p_\n        }\n        return res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009903
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var a = 1l\n        var e = n\n        var b = 2l\n    \
    \    while (e > 0) {\n            if (e % 2 == 1) a = (a * b) % p\n          \
    \  e /= 2\n            b = (b * b) % p\n        }\n        a\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1l\n        var base : Long = 2l\n \
    \       var exponent : Long = n\n        while (exponent > 0) {\n            if\
    \ ((exponent & 1) == 1) {\n                result = (result * base) % p\n    \
    \        }\n            exponent >>= 1\n            base = (base * base) % p\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var q = n\n        var res = 1l\n        while (q > 0) {\n\
    \            if ((q & 1) != 0) res = (res * 2) % p\n            q >>= 1\n    \
    \    }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwidrdg_3.scala:25)\n\tat Problem.main(tmpwidrdg_3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009900
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // >>> p = 101l\n        // >>> a = 3l\n        // >>> a\n\
    \        // (3l)\n        // >>> b = a\n        // >>> b\n        // (3l)\n  \
    \      // >>> a = a*b\n        // >>> a\n        // (9l)\n        // >>> b = a\n\
    \        // >>> b\n        // (9l)\n        // >>> a = a*b\n        // >>> a\n\
    \        // (81l)\n        // >>> b = a\n        // >>> b\n        // (81l)\n\
    \        // >>> a = a*b\n        // >>> a\n        // (6561l)\n        // >>>\
    \ b = a\n        // >>> b\n        // (6561l)\n        // >>> a = a*b\n      \
    \  // >>> a\n        // (43046721l)\n        // >>> b = a\n        // >>> b\n\
    \        // (43046721l)\n        // >>> a = a*b\n        // >>> a\n        //\
    \ (1853020188851841l)\n        // >>> b = a\n        // >>> b\n        // (1853020188851841l)\n\
    \        // >>> a = a*b\n        // >>> a\n        // (3433683820292512484657849089281l)\n\
    \        // >>> b = a\n        // >>> b\n        // (3433683820292512484657849089281l)\n\
    \        // >>> a = a*b\n        // >>> a\n        // (11751797696928776958918342240575993783888509146890965449l)\n\
    \        // >>> b = a\n        // >>> b\n        // (11751797696928776958918342240575993783888509146890965449l)\n\
    \        // >>> a = a*b\n        // >>> a\n        // (59806422392206446239364652927368907056553355687628370764809l)\n\
    \        // >>> b = a\n        // >>> b\n        // (59806422392206446239364652927368907056553355687628370764\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp13zdp_mg.scala:15:42\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m    \e[33mdef\e[0m \e[36mmodp\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m, \e[36mp\e[0m : \e[35mLong\e[0m) : \e[35mLong\e\
    [0m = {\n\e[31m\e[31m   |\e[0m                                          ^\e[0m\n\
    \e[31m   |\e[0m                                          Found:    Unit\n\e[31m\
    \   |\e[0m                                          Required: Long\n\e[31m16 |\e\
    [0m        \e[34m// >>> p = 101l\e[0m\n\e[31m17 |\e[0m        \e[34m// >>> a =\
    \ 3l\e[0m\n\e[31m18 |\e[0m        \e[34m// >>> a\e[0m\n\e[31m19 |\e[0m       \
    \ \e[34m// (3l)\e[0m\n\e[31m20 |\e[0m        \e[34m// >>> b = a\e[0m\n\e[31m21\
    \ |\e[0m        \e[34m// >>> b\e[0m\n\e[31m22 |\e[0m        \e[34m// (3l)\e[0m\n\
    \e[31m23 |\e[0m        \e[34m// >>> a = a*b\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ >>> a\e[0m\n\e[31m25 |\e[0m        \e[34m// (9l)\e[0m\n\e[31m26 |\e[0m     \
    \   \e[34m// >>> b = a\e[0m\n\e[31m27 |\e[0m        \e[34m// >>> b\e[0m\n\e[31m28\
    \ |\e[0m        \e[34m// (9l)\e[0m\n\e[31m29 |\e[0m        \e[34m// >>> a = a*b\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// >>> a\e[0m\n\e[31m31 |\e[0m        \e[34m//\
    \ (81l)\e[0m\n\e[31m32 |\e[0m        \e[34m// >>> b = a\e[0m\n\e[31m33 |\e[0m\
    \        \e[34m// >>> b\e[0m\n\e[31m34 |\e[0m        \e[34m// (81l)\e[0m\n\e[31m35\
    \ |\e[0m        \e[34m// >>> a = a*b\e[0m\n\e[31m36 |\e[0m        \e[34m// >>>\
    \ a\e[0m\n\e[31m37 |\e[0m        \e[34m// (6561l)\e[0m\n\e[31m38 |\e[0m      \
    \  \e[34m// >>> b = a\e[0m\n\e[31m39 |\e[0m        \e[34m// >>> b\e[0m\n\e[31m40\
    \ |\e[0m        \e[34m// (6561l)\e[0m\n\e[31m41 |\e[0m        \e[34m// >>> a =\
    \ a*b\e[0m\n\e[31m42 |\e[0m        \e[34m// >>> a\e[0m\n\e[31m43 |\e[0m      \
    \  \e[34m// (43046721l)\e[0m\n\e[31m44 |\e[0m        \e[34m// >>> b = a\e[0m\n\
    \e[31m45 |\e[0m        \e[34m// >>> b\e[0m\n\e[31m46 |\e[0m        \e[34m// (43046721l)\e\
    [0m\n\e[31m47 |\e[0m        \e[34m// >>> a = a*b\e[0m\n\e[31m48 |\e[0m       \
    \ \e[34m// >>> a\e[0m\n\e[31m49 |\e[0m        \e[34m// (1853020188851841l)\e[0m\n\
    \e[31m50 |\e[0m        \e[34m// >>> b = a\e[0m\n\e[31m51 |\e[0m        \e[34m//\
    \ >>> b\e[0m\n\e[31m52 |\e[0m        \e[34m// (1853020188851841l)\e[0m\n\e[31m53\
    \ |\e[0m        \e[34m// >>> a = a*b\e[0m\n\e[31m54 |\e[0m        \e[34m// "
  stdout: ''
  timestamp: 1660009901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        var acc = 1l\n        for\
    \ (i <- 1 to n.toInt) {\n            acc = acc * 2\n            if (acc > p) acc\
    \ = acc % p\n        }\n        return acc\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009905
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def f(n : Long, p : Long, acc : Long) : Long = {\n     \
    \       if (n == 0) return acc\n            else {\n                var r = acc\n\
    \                var x = 1l\n                var t = n\n                while\
    \ (t != 0) {\n                    if ((t & 1) == 1) r = (r * x) % p\n        \
    \            x = (x * x) % p\n                    t = t >> 1\n               \
    \ }\n                r\n            }\n        }\n        if (n == 0) return 1\n\
    \        else return f(n, p, 1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx5myeh9t.scala:34)\n\tat Problem.main(tmpx5myeh9t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009904
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var a = 1l\n        for (i <- 0 until n.toInt) {\n     \
    \       a = (a * 2l) % p\n        }\n        return a\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var power = 1l\n        var result = 1l\n        var base\
    \ = 2l\n        while (power <= n) {\n            if ((power & n) != 0) result\
    \ = (result * base) % p\n            base = (base * base) % p\n            power\
    \ *= 2\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1l\n        var base : Long = 2l\n \
    \       var exponent : Long = n\n        while (exponent > 0) {\n            if\
    \ ((exponent & 1) > 0) {\n                result = (result * base) % p\n     \
    \       }\n            exponent >>= 1\n            base = (base * base) % p\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) {\n            return 1\n        }\n       \
    \ if (n % 2 == 0) {\n            val x = modp(n / 2, p)\n            val res =\
    \ (x * x) % p\n            return res\n        }\n        val x = modp(n - 1,\
    \ p)\n        val res = (x * 2) % p\n        return res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        for (i <- 0 until n.toInt)\
    \ {\n            result = (result * 2) % p\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1\n        else if (n % 2 == 0) {\n        \
    \    val t = modp(n / 2, p)\n            (t * t) % p\n        } else {\n     \
    \       (modp(n - 1, p) * 2) % p\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var r = 1l\n        var b = n\n        var e = p - 2l\n\
    \        while (e > 0) {\n            if (e % 2 == 1) r = (r * b) % p\n      \
    \      b = (b * b) % p\n            e /= 2\n        }\n        r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps8sdmxt7.scala:27)\n\tat Problem.main(tmps8sdmxt7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        var res = 1l\n        var\
    \ base = 2l\n        while (n > 0) {\n            if ((n & 1) != 0) res = res\
    \ * base % p\n            base = base * base % p\n            n >>= 1\n      \
    \  }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg_5zvs51.scala:22:14 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            n >>= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^\e[0m\n\e[31m   |\e[0m            value >>= is not a member\
    \ of Long - did you mean n.>=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def t(n : Long, p : Long, power : Long, m : Long) : Long\
    \ = {\n            if (n == 0) m\n            else if (n % 2 == 0) t(n / 2, p,\
    \ power * power % p, m)\n            else t(n - 1, p, power * power % p, (m *\
    \ power) % p)\n        }\n        t(n, p, 2, 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2jpcqwzp.scala:24)\n\tat Problem.main(tmp2jpcqwzp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val r = (1l << n) % p\n        r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz7cwfggk.scala:21)\n\tat Problem.main(tmpz7cwfggk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      var sum = 1l\n      var power = n\n      var ite = 0\n   \
    \   while (ite < 64) {\n        if ((p & (1l << ite)) != 0) {\n          sum =\
    \ (sum * power) % p\n        }\n        power = (power * power) % p\n        ite\
    \ += 1\n      }\n      sum\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9se3afx7.scala:30)\n\tat Problem.main(tmp9se3afx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        assert(n >= 0)\n        var mod : Long = n\n        for\
    \ (i <- 2l to n) {\n            mod = (mod * n) % p\n        }\n        return\
    \ mod\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvvl_wf9f.scala:24)\n\tat Problem.main(tmpvvl_wf9f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var ans = BigInt(2).modPow(n, p)\n        ans.longValue\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1\n        else if (n % 2 == 0)\n          \
    \  (((modp(n/2, p)) % p) * ((modp(n/2, p)) % p)) % p\n        else\n         \
    \   ((((modp(n/2, p)) % p) * ((modp(n/2, p)) % p)) % p) * (2 % p) % p\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        val half = modp(n / 2, p)\n\
    \        val remainder = n % 2\n        val first = (half * half) % p\n      \
    \  val second = if (remainder == 0) 1 else half\n        (first * second) % p\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvgpmjgw2.scala:24)\n\tat Problem.main(tmpvgpmjgw2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < 100) return pow(2, n).toLong % p\n        val r\
    \ = modp(n / 2, p)\n        val rr = (r * r) % p\n        if (n % 2 == 0) return\
    \ rr\n        else return (2 * rr) % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa6le9uva.scala:24)\n\tat Problem.main(tmpa6le9uva.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1l\n        var mult : Long = 2l\n \
    \       var exp : Long = n\n        while (exp > 0) {\n            if ((exp &\
    \ 1) == 1) {\n                result = (result * mult) % p\n            }\n  \
    \          mult = (mult * mult) % p\n            exp >>= 1\n        }\n      \
    \  return result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009909
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        var b = n\n        var a = p\n   \
    \     while (b > 0) {\n            if ((b & 1) > 0) res = (res * a) % p\n    \
    \        b >>= 1\n            a = (a * a) % p\n        }\n        res\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_ts63fpt.scala:27)\n\tat Problem.main(tmp_ts63fpt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009909
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var a = n\n        var i = p\n        while (i > 0) {\n\
    \            if ((i & 1) == 1) {\n                a = a * n % p\n            }\n\
    \            n = n * n % p\n            i >>= 1\n        }\n        return a\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp8125qjg1.scala:22:14 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            n = n * n % p\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val n\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = (1l)\n        var b = (n)\n        var e = (p\
    \ - (2l))\n        while (e > (0l)) {\n            if ((e & (1l)) > (0l)) {\n\
    \                res = (res * b) % p\n            }\n            e >>= (1l)\n\
    \            b = (b * b) % p\n        }\n        return res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcxmit8i4.scala:29)\n\tat Problem.main(tmpcxmit8i4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009910
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        var res = 1l\n        var\
    \ b = 2l\n        var e = n\n        while (e > 0) {\n            if (e % 2 ==\
    \ 1) res = (res * b) % p\n            b = (b * b) % p\n            e /= 2\n  \
    \      }\n        return res\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009912
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var pow = 1l\n        var x = n\n        while (x > 0) {\n\
    \            if ((x & 1) != 0) pow = (pow * n) % p\n            n = (n * n) %\
    \ p\n            x = x >> 1\n        }\n        pow\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpolt70amt.scala:20:14 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009909
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var sum = 1l\n        var mul = 2l\n        var m = n\n\
    \        while (m > 0) {\n            if ((m & 1) == 1) {\n                sum\
    \ = (sum * mul) % p\n            }\n            mul = (mul * mul) % p\n      \
    \      m = m >> 1\n        }\n        sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009914
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1\n        else {\n            val d = modp(n\
    \ / 2, p)\n            val t = (d * d) % p\n            if (n % 2 == 0) t\n  \
    \          else (t * 2) % p\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val b = 2l\n        val m = BigInt(b).modPow(n, p)\n   \
    \     val r = m.toLong\n        r\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // Complete this function\n        var result = BigInt(1)\n\
    \        for (i <- 0 until n.toInt) {\n            result = result * 2 % p\n \
    \       }\n        result.toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009916
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1\n        else if (n % 2 == 0) {\n        \
    \    val x = modp(n / 2, p)\n            ((x * x) % p)\n        } else {\n   \
    \         ((2 * modp(n - 1, p)) % p)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        var halfp = modp(n / 2, p)\n\
    \        var mod = (halfp * halfp) % p\n        if (n % 2 == 1) mod = (mod * 2)\
    \ % p\n        return mod\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        var i = 0l\n        var a = n\n  \
    \      while (i < 60) {\n            if ((a & 1) == 1) res = (res * 2) % p\n \
    \           a = a >> 1\n            i += 1\n        }\n        res\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgb_g2c74.scala:27)\n\tat Problem.main(tmpgb_g2c74.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009916
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def iter(n : Long, p : Long, power : Long, result : Long)\
    \ : Long = {\n            if (n == 0) result\n            else {\n           \
    \     if ((n & 1) == 1) iter(n >> 1, p, power * 2 % p, (result + power) % p)\n\
    \                else iter(n >> 1, p, power * 2 % p, result)\n            }\n\
    \        }\n        iter(n, p, 1, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpomubzvfo.scala:27)\n\tat Problem.main(tmpomubzvfo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        //log.debug(\"modp(%d, %d)\".format(n, p))\n        if (n\
    \ < 0) return modp(n + p, p)\n        if (n < p) return n\n        if (n % 2 ==\
    \ 0) return modp(n / 2, p) * 2 % p\n        if (n % 2 == 1) return modp(n / 2,\
    \ p) * 2 % p + 1\n        throw new IllegalStateException(\"modp invariant violated\"\
    )\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_eurwgqr.scala:25)\n\tat Problem.main(tmp_eurwgqr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var r = 1l\n        var m = n\n        var k = 1l\n    \
    \    while (k <= m) {\n            if ((k & m) != 0) {\n                r = (r\
    \ * n) % p\n            }\n            k <<= 1\n            n = (n * n) % p\n\
    \        }\n        return r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmphzldrzpw.scala:24:14 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009914
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1l\n        if (n % 2 == 0) {\n     \
    \       val a = modp(n / 2, p)\n            a * a % p\n        } else {\n    \
    \        (2 * modp(n - 1, p)) % p\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var modp = n\n        while (modp >= p) {\n            modp\
    \ -= p\n        }\n        modp\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_lnhlt1u.scala:24)\n\tat Problem.main(tmp_lnhlt1u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009916
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1l\n        if (n == 1) return 2l\n \
    \       if (n % 2 == 0) return modp(n / 2, p) * modp(n / 2, p) % p\n        return\
    \ modp(n / 2, p) * modp(n / 2, p) * 2 % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009916
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      def modpHelper(n : Long, p : Long, m : Long) : Long = {\n\
    \        if (n == 0) m\n        else if (n % 2 == 0) modpHelper(n / 2, p, (m *\
    \ m) % p)\n        else modpHelper(n - 1, p, (m * m) % p)\n      }\n      modpHelper(n,\
    \ p, 1)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc1zci4vn.scala:24)\n\tat Problem.main(tmpc1zci4vn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009916
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        var i : Long = n\n      \
    \  var j : Long = p\n        while (i > 0) {\n            if ((i & 1) == 1) {\n\
    \                result = (result * 2) % j\n            }\n            i = i >>\
    \ 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4_ctbiyk.scala:28)\n\tat Problem.main(tmp4_ctbiyk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009916
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        var m = n\n        var e =\
    \ 2\n        var result = m\n        while (e <= n) {\n            m = (m * m)\
    \ % p\n            if ((e & n) != 0) {\n                result = (result * m)\
    \ % p\n            }\n            e = e << 1\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp41u3lfk7.scala:30)\n\tat Problem.main(tmp41u3lfk7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009916
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) {\n            1l\n        } else {\n      \
    \      if (n % 2 == 0) {\n                var t = modp(n / 2, p)\n           \
    \     t * t % p\n            } else {\n                2 * modp(n - 1, p) % p\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009916
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var ans = 1l\n        var base = 2l\n        var bpow =\
    \ n\n        while (bpow > 0) {\n            if ((bpow & 1) == 1) {\n        \
    \        ans = (ans * base) % p\n            }\n            base = (base * base)\
    \ % p\n            bpow >>= 1\n        }\n        return ans\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009917
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        if (n == 1) return 2\n   \
    \     val temp = modp(n >> 1, p)\n        val result = (temp * temp) % p\n   \
    \     if ((n & 1) == 1) {\n            return (result * 2) % p\n        } else\
    \ {\n            return result\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009917
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // computes (a * b) % c\n        def mulmod(a : Long, b\
    \ : Long, c : Long) : Long = {\n            if (a > c || b > c)\n            \
    \    mulmod(a % c, b % c, c)\n            else {\n                val res = (a\
    \ * b) % c\n                if (res < 0) res + c else res\n            }\n   \
    \     }\n        // computes a^e % p\n        def modpow(a : Long, e : Long, p\
    \ : Long) : Long = {\n            if (e == 0)\n                1\n           \
    \ else if (e % 2 == 0)\n                mulmod(modpow(a, e / 2, p), modpow(a,\
    \ e / 2, p), p)\n            else\n                mulmod(a, modpow(a, e - 1,\
    \ p), p)\n        }\n        modpow(2, n, p)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009918
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        for (i <- 1 to n.toInt) res = (res\
    \ * 2l) % p\n        return res\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var r : Long = 1l\n        for (e <- 0 until n.toInt) {\n\
    \            r = (r * 2l) % p\n        }\n        return r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val b = scala.collection.mutable.ListBuffer[Int]()\n   \
    \     var t = n\n        while (t > 0) {\n            b += ((t % 2).toInt)\n \
    \           t /= 2\n        }\n        var r = 1l\n        for (i <- 0 until b.length)\
    \ {\n            r = (r * r) % p\n            if (b(i) == 1) r = (r * n) % p\n\
    \        }\n        return r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpubfhvvvx.scala:30)\n\tat Problem.main(tmpubfhvvvx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009922
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < p - 1) n else {\n            if (n < 2 * (p - 1))\
    \ n - p else {\n                var m = n\n                var a = 1l\n      \
    \          var b = p\n                while (m >= 2 * b) {\n                 \
    \   if (m % 2 == 1) a = (a * 2) % p\n                    b = (b * 2) % p\n   \
    \                 m /= 2\n                }\n                (a + b) % p\n   \
    \         }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009926
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def modpacc(b : Long, a : Long, n : Long, p : Long) : Long\
    \ = {\n            if (n == 0) a\n            else {\n                if ((n &\
    \ 1) == 1) modpacc(b * b % p, a * b % p, n >> 1, p)\n                else modpacc(b\
    \ * b % p, a, n >> 1, p)\n            }\n        }\n        modpacc(2, 1, n, p)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009923
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var ans = BigInt(1)\n        var base = BigInt(2)\n    \
    \    var i = BigInt(n)\n        while (i > 0) {\n            if (i % 2 == 1) {\n\
    \                ans = ans * base % p\n            }\n            base = base\
    \ * base % p\n            i /= 2\n        }\n        ans.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val res = modp(n, 1, p, p)\n        res._1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0s7b05wr.scala:16:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = modp(n, \e[31m1\e\
    [0m, p, p)\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m \
    \  |\e[0mtoo many arguments for \e[33mmethod\e[0m \e[35mmodp\e[0m in \e[33mobject\e\
    [0m \e[35mProblem\e[0m: (n: Long, p: Long): Long\n1 error found\n"
  stdout: ''
  timestamp: 1660009921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def modpR(n : Long, p : Long, a : Long) : Long = {\n   \
    \         if (n == 0) a\n            else if (n % 2 == 0) modpR(n / 2, p, a *\
    \ a % p)\n            else modpR(n - 1, p, a * a % p * a % p)\n        }\n   \
    \     modpR(n, p, 1)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpit3to7b3.scala:24)\n\tat Problem.main(tmpit3to7b3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var (result, n) = (1l, n % p)\n        for (bit <- 0 until\
    \ 64) {\n            if ((n & (1l << bit)) != 0) {\n                result = (result\
    \ * (2l)) % p\n            }\n        }\n        return result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpl64uhkd_.scala:16:21 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m (result, n) = (\e[31m1l\e[0m,\
    \ n % p)\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m  \
    \                   Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009922
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val nf = new BigInt(n.toString)\n        val pf = new BigInt(p.toString)\n\
    \        val b = new BigInt(2.toString)\n        val a = b.modPow(nf, pf)\n  \
    \      a.longValue\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb73r7zq3.scala:16:28\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnf\e\
    [0m = \e[33mnew\e[0m \e[35mBigInt\e[0m(n.toString)\n\e[31m\e[31m   |\e[0m    \
    \                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \        Found:    String\n\e[31m   |\e[0m                            Required:\
    \ java.math.BigInteger\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb73r7zq3.scala:17:28\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mpf\e\
    [0m = \e[33mnew\e[0m \e[35mBigInt\e[0m(p.toString)\n\e[31m\e[31m   |\e[0m    \
    \                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \        Found:    String\n\e[31m   |\e[0m                            Required:\
    \ java.math.BigInteger\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb73r7zq3.scala:18:27\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mb\e\
    [0m = \e[33mnew\e[0m \e[35mBigInt\e[0m(\e[31m2\e[0m.toString)\n\e[31m\e[31m  \
    \ |\e[0m                           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                 Found:    String\n\e[31m   |\e[0m                          \
    \ Required: java.math.BigInteger\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        var x = n\n        var y = p\n   \
    \     while (x > 0) {\n            if ((x & 1) == 1) res = (res * n) % p\n   \
    \         x >>= 1\n            n = (n * n) % p\n        }\n        res\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpmc68c2g0.scala:22:14 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009922
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        var nn = n\n        while (nn > 0)\
    \ {\n            if ((nn & 1) == 1) res = (res * n) % p\n            nn >>= 1\n\
    \            n = (n * n) % p\n        }\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpiw16n2bd.scala:21:14 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009922
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var (n1, p1) = (n, p)\n        var result = 1l\n       \
    \ while (n1 > 0) {\n            if ((n1 & 1) == 1) {\n                result =\
    \ (result * n) % p\n            }\n            n1 >>= 1\n            n = (n *\
    \ n) % p\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp19c576mb.scala:23:14 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009923
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var y = 1l\n        var x = n\n        var b = 2l\n    \
    \    while (b <= n) {\n            if ((x & b) != 0) {\n                y = (y\
    \ * n) % p\n            }\n            x = (x * x) % p\n            b = b * 2\n\
    \        }\n        return y\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfd2xwbhm.scala:30)\n\tat Problem.main(tmpfd2xwbhm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009925
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val r = BigInt(2).modPow(n, p).longValue\n        if (r\
    \ >= p) r - p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009925
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < p) {\n            return n;\n        }\n       \
    \ else {\n            return (modp((2 * n) / p, p) * 2) % p;\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyezn4_lw.scala:25)\n\tat Problem.main(tmpyezn4_lw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009925
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) {\n            1\n        } else {\n       \
    \     val res = modp(n / 2, p)\n            if (n % 2 == 0) {\n              \
    \  (res * res) % p\n            } else {\n                (res * res * 2) % p\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009925
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var n1 = n\n        var m = 1l\n        while (n1 > 0) {\n\
    \            if ((n1 & 1) != 0) m = (m * 2) % p\n            n1 >>= 1\n      \
    \  }\n        m\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo0vvry1g.scala:25)\n\tat Problem.main(tmpo0vvry1g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009925
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        val sqrt = modp(n / 2, p)\n\
    \        val sqrt2 = (sqrt * sqrt) % p\n        if (n % 2 == 0) sqrt2 else (sqrt2\
    \ * (2l)) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009925
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // assert(n >= 0)\n        // assert(p >= 0)\n        if\
    \ (n == 0) return 1\n        if (n % 2 == 0) {\n            val x = modp(n / 2,\
    \ p)\n            return (x * x) % p\n        }\n        else {\n            return\
    \ ((2 % p) * modp(n - 1, p)) % p\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009926
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def mod(a : Long, b : Long) : Long = {\n            val\
    \ r = a % b\n            if (r < 0) r + b else r\n        }\n        var k = 1l\n\
    \        var b = 2l\n        var res = 1l\n        while (k <= n) {\n        \
    \    if ((k & n) != 0) {\n                res = mod(res * b, p)\n            }\n\
    \            k <<= 1\n            b = mod(b * b, p)\n        }\n        res\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009926
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val inv2 = modinv(2l, p)\n        modp(n, p, inv2)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpalgesaut.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36minv2\e[0m = modinv(\e[31m2l\e\
    [0m, p)\n\e[31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                   Not found: modinv\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpalgesaut.scala:17:19 -----------------------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        modp(n, p, inv2)\n\e[31m\e[31m   |\e[0m          \
    \         ^^^^\e[0m\n\e[31m   |\e[0mtoo many arguments for \e[33mmethod\e[0m \e\
    [35mmodp\e[0m in \e[33mobject\e[0m \e[35mProblem\e[0m: (n: Long, p: Long): Long\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009923
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val t = 2l\n        var r = 1l\n        var x = t % p\n\
    \        var nn = n\n        while (nn > 0) {\n            if ((nn & 1) != 0)\
    \ {\n                r = (r * x) % p\n            }\n            x = (x * x) %\
    \ p\n            nn >>= 1\n        }\n        r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009928
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def modp_rec(n : Long, p : Long, r : Long) : Long = n match\
    \ {\n            case 0 => r\n            case _ => modp_rec(n / 2, p, if (n %\
    \ 2 == 0) (r * r) % p else (r * r * 2) % p)\n        }\n        modp_rec(n, p,\
    \ 1)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9hle46v_.scala:24)\n\tat Problem.main(tmp9hle46v_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009929
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1 else {\n            val a = modp(n >> 1, p)\n\
    \            val b = a * a % p\n            if ((n & 1) == 0) b else b * 2 % p\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var sum = 1L\n        var current = 2L\n        var j =\
    \ n\n        while (j > 0) {\n            if (j % 2 == 1) {\n                sum\
    \ = sum * current % p\n            }\n            current = current * current\
    \ % p\n            j /= 2\n        }\n        sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var m = 1l\n        var e = n\n        var mod = p\n   \
    \     while (e > 0) {\n            if ((e & 1) != 0) {\n                m = (m\
    \ * n) % mod\n            }\n            n = (n * n) % mod\n            e = e\
    \ >> 1\n        }\n        return m\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpsgjfqi0p.scala:23:14 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            n = (n * n) % mod\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to\
    \ val n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009928
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        var x = n\n        var m = p\n   \
    \     while (x > 0) {\n            if ((x & 1) != 0) {\n                res =\
    \ (res * n) % p\n            }\n            x = x >> 1\n            n = (n * n)\
    \ % p\n        }\n        return res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpb9urihma.scala:24:14 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009928
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var total = 1l\n        var i = n\n        var x = 2l\n\
    \        while (i > 0) {\n            if (i % 2 == 1) {\n                total\
    \ = (total * x) % p\n            }\n            x = (x * x) % p\n            i\
    \ /= 2\n        }\n        return total\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009931
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var r = 1l\n        var s = 2l\n        var t = n\n    \
    \    while (t > 0) {\n            if (t % 2 == 1) r = (r * s) % p\n          \
    \  s = (s * s) % p\n            t /= 2\n        }\n        r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009931
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1l\n        var base : Long = 2l\n \
    \       var exponent : Long = n\n        while (exponent > 0) {\n            if\
    \ ((exponent & 1) == 1) {\n                result = (result * base) % p\n    \
    \        }\n            exponent >>= 1\n            base = (base * base) % p\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var nn = n\n        var pp = p\n        var result = 1l\n\
    \        while (nn > 0) {\n            if ((nn & 1) == 1) result = (result * n)\
    \ % p\n            nn >>= 1\n            n = (n * n) % p\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpu3yt735k.scala:22:14 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009929
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var r : Long = 1\n        var m : Long = 2\n        var\
    \ x : Long = n\n        while (x > 0) {\n            if ((x & 1) == 1) {\n   \
    \             r = (r * m) % p\n            }\n            m = (m * m) % p\n  \
    \          x >>= 1\n        }\n        return r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009933
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1\n        var b : Long = 2\n      \
    \  var bp : Long = b % p\n        var r : Long = n\n        while (r > 0) {\n\
    \            if ((r & 1) > 0) result = (result * bp) % p\n            r >>= 1\n\
    \            bp = (bp * bp) % p\n        }\n        return result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n \
    \   assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n\
    \    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n\
    \    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009933
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var a = 1l\n        var b = n\n        while (b > 0) {\n\
    \            if ((b & 1) != 0) {\n                a = (a * n) % p\n          \
    \  }\n            b >>= 1\n            n = (n * n) % p\n        }\n        return\
    \ a\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp0jbpfrmj.scala:23:14 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val nmodp = n % p\n        if (nmodp < 0) {\n          \
    \  nmodp + p\n        } else {\n            nmodp\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg4kq9dm8.scala:25)\n\tat Problem.main(tmpg4kq9dm8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009934
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var x = 1l\n        var y = n\n        while (y > 0) {\n\
    \            if ((y & 1) > 0) x = (x * n) % p\n            y >>= 1\n         \
    \   n = (n * n) % p\n        }\n        return x\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpaodi21gs.scala:21:14 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009931
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val result = ((BigInt(2).modPow(n, p)).toLong)\n       \
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009935
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var a = 1l\n        for (i <- 1 to n.toInt) {\n        \
    \    a = (a * 2l) % p\n        }\n        return a\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009935
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        var k = n\n        var y = 2l\n  \
    \      while (k > 0) {\n            if (k % 2 == 1) {\n                res = (res\
    \ * y) % p\n            }\n            y = (y * y) % p\n            k /= 2\n \
    \       }\n        return res\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009935
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val (d, r) = n /% p\n        (r + p) % p\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnh5jyquq.scala:16:23 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m (d, r) = n /% p\n\e[31m\e[31m\
    \   |\e[0m                     ^^^^\e[0m\n\e[31m   |\e[0mvalue /% is not a member\
    \ of Long, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.BigDecimal.long2bigDecimal\n\e[31m   |\e[0m\
    \  import math.BigInt.long2bigInt\n\e[31m   |\e[0m  import math.Numeric.LongIsIntegral.mkNumericOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnh5jyquq.scala:16:13 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m (d, r) = n /% p\n\e[31m\e[31m\
    \   |\e[0m             ^\e[0m\n\e[31m   |\e[0m             Recursive \e[33mvalue\e\
    [0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpnh5jyquq.scala:16:16 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m (d, r) = n /% p\n\e[31m\e[31m   |\e[0m        \
    \        ^\e[0m\n\e[31m   |\e[0m                Recursive \e[33mvalue\e[0m \e\
    [35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009935
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var n2 = n\n        var p2 = p\n        var r = (1l)\n \
    \       while (n2 > (0l)) {\n            if ((n2 & (1l)) > (0l)) {\n         \
    \       r = (((r * (2l)) % p2) + p2) % p2\n            }\n            n2 = n2\
    \ >> (1)\n            r = (((r * r) % p2) + p2) % p2\n        }\n        return\
    \ r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe17zjdkw.scala:29)\n\tat Problem.main(tmpe17zjdkw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < 0) modp(n + p, p)\n        else if (n < p) n\n \
    \       else {\n            var x = 1L\n            var k = 0L\n            while\
    \ (k < n) {\n                x = (x * 2) % p\n                k += 1\n       \
    \     }\n            x\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq8e2lcu3.scala:31)\n\tat Problem.main(tmpq8e2lcu3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009935
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def modp(n : Long, m : Long, p : Long) : Long = {\n    \
    \        if (m == 0) 1\n            else if (m % 2 == 0) modp(n * n % p, m / 2,\
    \ p)\n            else n * modp(n, m - 1, p) % p\n        }\n        modp(n, n,\
    \ p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6w_5sxxa.scala:24)\n\tat Problem.main(tmp6w_5sxxa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009935
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var result : Long = 1l\n        var power : Long = n\n \
    \       var exponent : Long = p\n        while (exponent > 0) {\n            if\
    \ ((exponent & 1) == 1) {\n                result = (result * power) % p\n   \
    \         }\n            power = (power * power) % p\n            exponent = exponent\
    \ >> 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb0fgzk2k.scala:30)\n\tat Problem.main(tmpb0fgzk2k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009936
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var x = 1l\n        var pow = n\n        var res = 0l\n\
    \        for (i <- 0 to 63) {\n            val d = pow % 2\n            pow /=\
    \ 2\n            res = (res + x * d) % p\n            x = (x * 2) % p\n      \
    \  }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfjf1j26w.scala:29)\n\tat Problem.main(tmpfjf1j26w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        var cn = n\n        while (cn > 0)\
    \ {\n            if ((cn & 1) == 1) res = (res * 2) % p\n            cn >>= 1\n\
    \        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6o5vsrur.scala:25)\n\tat Problem.main(tmp6o5vsrur.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n      var pow = 1l\n      var pow2 = 2l\n      var pow2n = pow2\n\
    \      for (i <- 1 to n.toInt) {\n        pow = (pow * pow2n) % p\n        pow2n\
    \ = (pow2n * pow2) % p\n      }\n      return pow\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeovz4wy2.scala:26)\n\tat Problem.main(tmpeovz4wy2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < 0 || p < 0) throw new Exception(\"modulo: negative\
    \ arguments\")\n        if (n == 0) return 1\n        var ans = 1l\n        for\
    \ (i <- (0 until n.toInt)) {\n            ans = (ans * 2) % p\n        }\n   \
    \     return ans\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009939
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        if (n % 2 == 0) {\n      \
    \      val res = modp(n / 2, p)\n            (res * res) % p\n        } else {\n\
    \            val res = modp(n - 1, p)\n            ((2 * res) % p)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var i = 0l\n        var val2 = 1l\n        while (i < n)\
    \ {\n            val2 = (val2 * 2l) % p\n            i += 1l\n        }\n    \
    \    return val2\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009939
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1 else {\n            var res = 1l\n       \
    \     var b = n\n            var a = 2l\n            while (b > 0) {\n       \
    \         if ((b & 1) == 1) res = (res * a) % p\n                a = (a * a) %\
    \ p\n                b = b >> 1\n            }\n            res\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        def modp0(m : Long, a : Long, b : Long) : Long = {\n   \
    \         if (a == 0) return b\n            if (a % 2 == 0) modp0(m, a / 2, b\
    \ * 2 % m)\n            else modp0(m, a - 1, b * m % a)\n        }\n        modp0(n,\
    \ p, 1)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbpqfp3x8.scala:24)\n\tat Problem.main(tmpbpqfp3x8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009939
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1\n        else {\n            val mod = n %\
    \ p\n            if (mod >= ((p / 2) + 1))\n                ((mod - p) + 2)\n\
    \            else mod\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdtmcqf8k.scala:25)\n\tat Problem.main(tmpdtmcqf8k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val base = Vector(1l, 2l)\n        var res = 0l\n      \
    \  for (i <- (0 to 62).reverse) {\n            res = (res * base(Math.abs(res\
    \ * res * 2 - 1).toInt)).toLong % p\n            if ((n & (1l << i)) != 0) {\n\
    \                res = (res * 2) % p\n            }\n        }\n        res\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqxz_irtu.scala:27)\n\tat Problem.main(tmpqxz_irtu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        if (n == 1) return 2\n   \
    \     val r = if (n % 2 == 0) modp(n / 2, p) else 2 * modp(n - 1, p)\n       \
    \ return if (r >= p) r % p else r\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpffr1fwjn.scala:22)\n\tat Problem.main(tmpffr1fwjn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        if (n == 1) return 2\n   \
    \     if (n % 2 == 0) {\n            val x = modp(n / 2, p)\n            return\
    \ (x * x) % p\n        }\n        (2 * modp(n - 1, p)) % p\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009941
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var n1 = n\n        var p1 = p\n        if (n1 == 0) return\
    \ 1\n        var res = 1l\n        var exp = n1 % (p1 - 1)\n        var base =\
    \ n1 % p1\n        while (exp > 0) {\n            if (exp % 2 == 1) {\n      \
    \          res = (res * base) % p1\n            }\n            base = (base *\
    \ base) % p1\n            exp = exp / 2\n        }\n        return res\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvlo4ktnc.scala:32)\n\tat Problem.main(tmpvlo4ktnc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009941
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var s = BigInt(1)\n        var i = BigInt(0)\n        var\
    \ p1 = BigInt(p)\n        var n1 = BigInt(n)\n        while(i < n1) {\n      \
    \      s = (s * 2) % p1\n            i += 1\n        }\n        s.toLong\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val b = new StringBuilder()\n        b.append(n)\n     \
    \   val digits = b.reverse.toString\n        var out = 1l\n        for (i <- 0\
    \ until digits.length) {\n            out = (out * out) % p\n            if (digits(i)\
    \ == '1') out = (out * 2) % p\n        }\n        out\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tgz0ybm.scala:27)\n\tat Problem.main(tmp0tgz0ybm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009944
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        val res = ((BigInt(2).modPow(n, BigInt(p)) % p)).toLong\n\
    \        res\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009944
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1l\n        if (n % 2 == 0) {\n     \
    \       val t = modp(n / 2, p)\n            (t * t) % p\n        } else {\n  \
    \          (2 * modp(n - 1, p)) % p\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009943
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < 0) throw new Exception(\"n is negative\")\n    \
    \    if (p < 0) throw new Exception(\"p is negative\")\n        if (n == 0) return\
    \ 1\n        if (n == 1) return 2\n        if (n % 2 == 0) {\n            val\
    \ m = modp(n / 2, p)\n            return (m * m) % p\n        }\n        else\
    \ {\n            val m = modp(n - 1, p)\n            return (2 * m) % p\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009944
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) {\n            return 1\n        }\n       \
    \ var result : Long = modp(n / 2, p)\n        result = (result * result) % p\n\
    \        if (n % 2 == 1) {\n            result = (result * 2) % p\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009944
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        var temp = n\n        while (temp\
    \ > 0) {\n            if ((temp & 1) == 1) res = res * n % p\n            temp\
    \ >>= 1\n            n = n * n % p\n        }\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp4ec2zoru.scala:21:14 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            n = n * n % p\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val n\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009941
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        var result = 1l\n        var\
    \ factor = 2l\n        var nn = n\n        while (nn > 0) {\n            if (nn\
    \ % 2 == 1) {\n                result = (result * factor) % p\n            }\n\
    \            factor = (factor * factor) % p\n            nn /= 2\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009944
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // 2^(k-1) * 2^n_k * 2^(k-1) = 2^k * 2^(k-2) = 2^(2k-2)\n\
    \        // 2^(2k-2) = (2^k)^2 = (2^(k-1) * 2)^2\n        // 2^(2k-2) % p = ((2^(k-1)\
    \ * 2)^2) % p\n        // 2^(2k-2) % p = ((2^(k-1) % p) * (2 % p))^2 % p\n   \
    \     // 2^(2k-2) % p = ((2^(k-1) % p)^2 * (2 % p)^2) % p\n        // (since 2\
    \ % p = 2)\n        // 2^(2k-2) % p = ((2^(k-1) % p)^2 * 4) % p\n        // 2^(2k-2)\
    \ % p = ((2^(k-1) % p)^2 * 2 * 2) % p\n        // 2^(2k-2) % p = ((2^(k-1) % p)^2\
    \ * 2) % p\n        // (mod is associative)\n        // 2^(2k-2) % p = ((2^(k-1)\
    \ % p) * 2) % p\n        // (mod is distributive)\n        // 2^(2k-2) % p = ((2^(k-1)\
    \ % p) * (2^1 % p)) % p\n        // 2^n % p = ((2^(k-1) % p) * (2^(n_k) % p))\
    \ % p\n        // (where n = k + n_k)\n        // We can start with the k = 1\
    \ case.\n        // 2^1 % p = ((2^0 % p) * (2^1 % p)) % p\n        // 2^1 % p\
    \ = ((1 % p) * (2^1 % p)) % p\n        // 2^1 % p = ((1 % p) * (2 % p)) % p\n\
    \        // 2^1 %\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7cmtyknk.scala:15:42\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m    \e[33mdef\e[0m \e[36mmodp\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m, \e[36mp\e[0m : \e[35mLong\e[0m) : \e[35mLong\e\
    [0m = {\n\e[31m\e[31m   |\e[0m                                          ^\e[0m\n\
    \e[31m   |\e[0m                                          Found:    Unit\n\e[31m\
    \   |\e[0m                                          Required: Long\n\e[31m16 |\e\
    [0m        \e[34m// 2^(k-1) * 2^n_k * 2^(k-1) = 2^k * 2^(k-2) = 2^(2k-2)\e[0m\n\
    \e[31m17 |\e[0m        \e[34m// 2^(2k-2) = (2^k)^2 = (2^(k-1) * 2)^2\e[0m\n\e\
    [31m18 |\e[0m        \e[34m// 2^(2k-2) % p = ((2^(k-1) * 2)^2) % p\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// 2^(2k-2) % p = ((2^(k-1) % p) * (2 % p))^2 % p\e[0m\n\
    \e[31m20 |\e[0m        \e[34m// 2^(2k-2) % p = ((2^(k-1) % p)^2 * (2 % p)^2) %\
    \ p\e[0m\n\e[31m21 |\e[0m        \e[34m// (since 2 % p = 2)\e[0m\n\e[31m22 |\e\
    [0m        \e[34m// 2^(2k-2) % p = ((2^(k-1) % p)^2 * 4) % p\e[0m\n\e[31m23 |\e\
    [0m        \e[34m// 2^(2k-2) % p = ((2^(k-1) % p)^2 * 2 * 2) % p\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// 2^(2k-2) % p = ((2^(k-1) % p)^2 * 2) % p\e[0m\n\e[31m25\
    \ |\e[0m        \e[34m// (mod is associative)\e[0m\n\e[31m26 |\e[0m        \e\
    [34m// 2^(2k-2) % p = ((2^(k-1) % p) * 2) % p\e[0m\n\e[31m27 |\e[0m        \e\
    [34m// (mod is distributive)\e[0m\n\e[31m28 |\e[0m        \e[34m// 2^(2k-2) %\
    \ p = ((2^(k-1) % p) * (2^1 % p)) % p\e[0m\n\e[31m29 |\e[0m        \e[34m// 2^n\
    \ % p = ((2^(k-1) % p) * (2^(n_k) % p)) % p\e[0m\n\e[31m30 |\e[0m        \e[34m//\
    \ (where n = k + n_k)\e[0m\n\e[31m31 |\e[0m        \e[34m// We can start with\
    \ the k = 1 case.\e[0m\n\e[31m32 |\e[0m        \e[34m// 2^1 % p = ((2^0 % p) *\
    \ (2^1 % p)) % p\e[0m\n\e[31m33 |\e[0m        \e[34m// 2^1 % p = ((1 % p) * (2^1\
    \ % p)) % p\e[0m\n\e[31m34 |\e[0m        \e[34m// 2^1 % p = ((1 % p) * (2 % p))\
    \ % p\e[0m\n\e[31m35 |\e[0m        \e[34m// 2^1 %\e[0m\n\e[31m36 |\e[0m    }\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009944
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1l else ((2l * modp(n - 1, p)) % p)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < 0) return modp(n + p, p)\n        if (n < p) return\
    \ n\n        if (n == 0) return 1\n        if (n == p) return 0\n        if (n\
    \ % 2 == 0) return modp(n / 2, p) * modp(2, p) % p\n        else return modp(n\
    \ / 2, p) * modp(2, p) * modp(1, p) % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj8320c9m.scala:25)\n\tat Problem.main(tmpj8320c9m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        //assert(p > 1)\n        if (n == 0) 1 else (1l to n).foldLeft(1l)((x,\
    \ y) => x * 2 % p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009947
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var pmod = 1L\n        var i = 0L\n        while (i < n)\
    \ {\n            pmod = (pmod * 2L) % p\n            i += 1L\n        }\n    \
    \    return pmod\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009947
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        // For example, 5**3 mod 7 = 1 + 5 * (1 + 5 * (1 + 5 * 1))\
    \ mod 7 = 6\n        var result = 1l\n        var b = n\n        var e = p\n \
    \       while (e != 0) {\n            if ((e & 1) != 0) result = (result * b)\
    \ % p\n            e >>= 1\n            b = (b * b) % p\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp2jfbwsd.scala:29)\n\tat Problem.main(tmpp2jfbwsd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009947
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n < p) n\n        else if (n % 2 == 0) modp(n/2, p)\
    \ * 2 % p\n        else (modp(n/2, p) * 2 + p - 1) % p\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprb6hj5m1.scala:22)\n\tat Problem.main(tmprb6hj5m1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009947
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var res = 1l\n        var k = n\n        var b = 2l\n  \
    \      while (k > 0) {\n            if (k % 2 == 1) {\n                res = (res\
    \ * b) % p\n            }\n            k = k / 2\n            b = (b * b) % p\n\
    \        }\n        return res\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009947
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) return 1\n        if (n % 2 == 0) {\n      \
    \      var tmp = modp(n / 2, p)\n            return (tmp * tmp) % p\n        }\n\
    \        return (modp(n - 1, p) * 2) % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009948
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var r = 1l\n        var b = 2l\n        var e = n\n    \
    \    while (e > 0) {\n            if (e % 2 == 1) {\n                r = (r *\
    \ b) % p\n            }\n            e = e / 2\n            b = (b * b) % p\n\
    \        }\n        return r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var pow = n\n        var ans = 1l\n        for (i <- 0 to\
    \ 63) {\n            if ((pow & (1l << i)) != 0) {\n                ans = (ans\
    \ * 2l) % p\n            }\n        }\n        return ans\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwjy5s3pv.scala:26)\n\tat Problem.main(tmpwjy5s3pv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009948
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        n match {\n            case 0 => 1\n            case 1 =>\
    \ 2\n            case _ => modp(n - 1, p) * 2 % p\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009948
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var ans = 1l\n        var pow = n\n        while (p > 0)\
    \ {\n            if ((p & 1) > 0) {\n                ans = (ans * pow) % p\n \
    \           }\n            pow = (pow * pow) % p\n            p >>= 1\n      \
    \  }\n        return ans\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc3jlv0t4.scala:23:14 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            p >>= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^\e[0m\n\e[31m   |\e[0m            value >>= is not a member\
    \ of Long - did you mean p.>=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009948
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var a = n\n        var b = p\n        var pow = 1l\n   \
    \     while (a != 0) {\n            if ((a & 1) == 1) pow = (pow * b) % p\n  \
    \          a = a >> 1\n            b = (b * b) % p\n        }\n        pow\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr4enpyvq.scala:27)\n\tat Problem.main(tmpr4enpyvq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009948
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) {\n            1\n        } else {\n       \
    \     if (n % 2 == 0) {\n                val b = modp(n / 2, p)\n            \
    \    (b * b) % p\n            } else {\n                ((2 * modp(n - 1, p))\
    \ % p)\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009948
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var b = 1l\n        var c = n\n        while (c > 0) {\n\
    \            if ((c & 1) == 1) {\n                b = (b * n) % p\n          \
    \  }\n            c >>= 1\n            n = (n * n) % p\n        }\n        return\
    \ b\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpzvakpw5p.scala:23:14 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009947
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        var ret = 1l\n        var pow = n\n        var mod = p\n\
    \        while (pow > 0) {\n            if ((pow & 1) == 1) ret = (ret * n) %\
    \ p\n            pow >>= 1\n            n = (n * n) % p\n        }\n        return\
    \ ret\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpo36v0ill.scala:22:14 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            n = (n * n) % p\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val\
    \ n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009948
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        if (n == 0) 1 else {\n            val x = modp(n / 2, p)\n\
    \            if (n % 2 == 0) (x * x) % p else (x * x * 2) % p\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l),\
    \ (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>>\
    \ modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n\
    \    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long)\
    \ : Long = {\n        n match {\n            case 0 => 1\n            case n if\
    \ n % 2 == 0 => modp(n / 2, p) * modp(n / 2, p) % p\n            case n => n *\
    \ modp(n - 1, p) % p\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfwd765oc.scala:24)\n\tat Problem.main(tmpfwd765oc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009949
