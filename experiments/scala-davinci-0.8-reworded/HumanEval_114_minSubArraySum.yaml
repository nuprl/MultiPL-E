name: HumanEval_114_minSubArraySum
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a list of integers nums, find the minimum sum of any non-empty sub-list\n\
  \    // of nums.\n    // Example\n    // >>> minSubArraySum((List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong)))\n    // (1l)\n    //\
  \ >>> minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)))\n    // (-6l)\n\
  \    def minSubArraySum(nums : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(minSubArraySum((List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong))) == (1l));\n    assert(minSubArraySum((List[Long](-1l.toLong,\
  \ -2l.toLong, -3l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](-1l.toLong,\
  \ -2l.toLong, -3l.toLong, 2l.toLong, -10l.toLong))) == (-14l));\n    assert(minSubArraySum((List[Long](-9999999999999999l.toLong)))\
  \ == (-9999999999999999l));\n    assert(minSubArraySum((List[Long](0l.toLong, 10l.toLong,\
  \ 20l.toLong, 1000000l.toLong))) == (0l));\n    assert(minSubArraySum((List[Long](-1l.toLong,\
  \ -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](100l.toLong,\
  \ -1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n   \
  \ assert(minSubArraySum((List[Long](10l.toLong, 11l.toLong, 13l.toLong, 8l.toLong,\
  \ 3l.toLong, 4l.toLong))) == (3l));\n    assert(minSubArraySum((List[Long](100l.toLong,\
  \ -33l.toLong, 32l.toLong, -1l.toLong, 0l.toLong, -2l.toLong))) == (-33l));\n  \
  \  assert(minSubArraySum((List[Long](-10l.toLong))) == (-10l));\n    assert(minSubArraySum((List[Long](7l.toLong)))\
  \ == (7l));\n    assert(minSubArraySum((List[Long](1l.toLong, -1l.toLong))) == (-1l));\n\
  \    }\n\n}\n"
completions: ["        // This solution is brute force, where we try to find the min\
    \ sum by adding\n        // all sub-arrays.\n        // The algorithm is given\
    \ by the following recursive definition:\n        // Base case:\n        // \t\
    f(nums) = nums(0)\n        // Recursion:\n        // \tf(nums(i, ..., n)) = min(f(nums(i,\
    \ ..., n-1)), f(nums(i, ..., n-1)) + nums(n))\n        // This solution runs in\
    \ O(n^2) time.\n        // Space complexity is O(n).\n        var sums = HashMap[Int,\
    \ Long]()\n        def f(i : Int) : Long = {\n            if (i < 0) 0\n     \
    \       else if (sums.contains(i)) sums(i)\n            else {\n             \
    \   val value = min(f(i - 1), f(i - 1) + nums(i))\n                sums += (i\
    \ -> value)\n                value\n            }\n        }\n        return f(nums.length\
    \ - 1)", "        // Make sure that the list of integers at least has 1 element\n\
    \        require(nums.size > 0)\n        // Initialize the minimum sum of any\
    \ sub-list of nums\n        var minSum = nums(0)\n        // Initialize the sum\
    \ of any sub-list of nums\n        var sum = nums(0)\n        // Iterate through\
    \ all elements of nums\n        for (i <- 1 until nums.size) {\n            //\
    \ Update the sum of any sub-list of nums\n            sum = sum + nums(i)\n  \
    \          // Update the minimum sum of any sub-list of nums\n            minSum\
    \ = min(minSum, sum)\n            // Update the sum of any sub-list of nums\n\
    \            sum = max(sum, 0)\n        }\n        // Return the minimum sum of\
    \ any sub-list of nums\n        minSum", "        if (nums.isEmpty) throw new\
    \ Exception(\"nums is empty\")\n        else {\n            def aux(nums : List[Long],\
    \ i : Int, j : Int, curSum : Long, minSum : Long) : Long = {\n               \
    \ if (j == nums.length) minSum\n                else if (curSum > 0) aux(nums,\
    \ i + 1, j, curSum + nums(j), min(minSum, curSum + nums(j)))\n               \
    \ else aux(nums, i, j + 1, curSum + nums(j), min(minSum, curSum + nums(j)))\n\
    \            }\n            aux(nums, 0, 0, 0, 0)\n        }", "        val n\
    \ = nums.length\n        var min_ending_here = 0L\n        var min_so_far = Long.MaxValue\n\
    \        for (x <- nums) {\n            min_ending_here = min(min_ending_here\
    \ + x, x)\n            min_so_far = min(min_so_far, min_ending_here)\n       \
    \ }\n        min_so_far", "        val l = new Array[Long](nums.length + 1)\n\
    \        l(0) = 0\n        for (i <- 1 to nums.length) l(i) = l(i - 1) + nums(i\
    \ - 1)\n        var min = Long.MaxValue\n        for (i <- 0 to nums.length) {\n\
    \            for (j <- i + 1 to nums.length) {\n                min = min(min,\
    \ l(j) - l(i))\n            }\n        }\n        min", "      val n = nums.length\n\
    \      val m = Array.ofDim[Long](n + 1, n + 1)\n      for (i <- 1 to n) {\n  \
    \      for (j <- 1 to n) {\n          if (i == j) {\n            m(i)(j) = nums(i\
    \ - 1)\n          } else {\n            m(i)(j) = m(i)(j - 1) + nums(j - 1)\n\
    \          }\n        }\n      }\n      m(1)(n).min(m(2)(n).min(m(3)(n).min(m(4)(n).min(m(5)(n).min(m(6)(n))))))",
  "        // >>> Long.MaxValue - 2l.toLong\n        // 9223372036854775805\n    \
    \    // >>> Long.MaxValue - 1l.toLong\n        // 9223372036854775806\n      \
    \  // >>> Long.MaxValue - (-1l.toLong)\n        // 9223372036854775807\n     \
    \   // >>> Long.MaxValue - (-2l.toLong)\n        // 9223372036854775808\n    \
    \    // >>> -Long.MaxValue + (-1l.toLong)\n        // 9223372036854775807\n  \
    \      // >>> -Long.MaxValue + (-2l.toLong)\n        // 9223372036854775806\n\
    \        // >>> -Long.MaxValue + (-3l.toLong)\n        // 9223372036854775805\n\
    \        // >>> -Long.MaxValue + (-4l.toLong)\n        // 9223372036854775804\n\
    \        // >>> -Long.MaxValue + (-5l.toLong)\n        // 9223372036854775803\n\
    \        // >>> -Long.MaxValue + (-6l.toLong)\n        // 9223372036854775802\n\
    \        // >>> -Long.MaxValue + (-7l.toLong)\n        // 9223372036854775801\n\
    \        // >>> -Long.MaxValue + (-8l.toLong)\n        // 9223372036854775800\n\
    \        // >>> -Long.MaxValue + (-9l.toLong)\n        // 9223372036854775799\n\
    \        // >>> -Long.MaxValue + (-10l.toLong)\n        // 9223372036854775798\n\
    \        // >>> -Long.MaxValue + (-11l.toLong)\n        // 9223372036854775797\n\
    \        // >>> -Long.MaxValue + (-12l.toLong)\n        // 9223372036854775796\n\
    \        // >>> -Long.MaxValue + (-13l.toLong)\n        // 9223372036854775795\n\
    \        // >>> -Long.MaxValue + (-14l.toLong)\n        // 92233720368547", " \
    \       // Fill in the code here\n        var minSum = 0l\n        for (i <- nums)\
    \ {\n            if (i < minSum) minSum = i\n        }\n        var runningSum\
    \ = 0l\n        var currentMin = 0l\n        for (i <- nums) {\n            runningSum\
    \ += i\n            if (runningSum < currentMin) currentMin = runningSum\n   \
    \         if (runningSum - currentMin < minSum) minSum = runningSum - currentMin\n\
    \        }\n        return minSum", "        val sums = new Array[Long](nums.length)\n\
    \        sums(0) = nums(0)\n        var min = sums(0)\n        for (i <- 1 until\
    \ nums.length) {\n            sums(i) = sums(i - 1) + nums(i)\n            if\
    \ (sums(i) < min) min = sums(i)\n        }\n        var result = Long.MaxValue\n\
    \        for (i <- 0 until nums.length) {\n            val current = sums(i)\n\
    \            if (current < 0) {\n                val currentResult = sums(i) -\
    \ min\n                if (currentResult < result) result = currentResult\n  \
    \          }\n        }\n        if (result == Long.MaxValue) 0l else result",
  "        var mins = Long.MaxValue\n        for (l <- 1 to nums.length) {\n     \
    \       for (i <- 0 to nums.length - l) {\n                val sum = nums.slice(i,\
    \ i + l).sum\n                if (sum < mins) mins = sum\n            }\n    \
    \    }\n        mins", "        // We break the problem down as follows:\n   \
    \     // - We initialize the accumulator to the first element of the list\n  \
    \      // - Let P be the path we take through the list\n        // - Let a_i be\
    \ the last element of P\n        // - Let M(P) be the value of the minimum element\
    \ in P\n        // - Let L(P) be the length of P\n        // - Let s_P be the\
    \ sum of P\n        // Then we want to find a path P such that s_P - M(P) < s_L\
    \ - M(L) for all P, L\n        // s.t. L is a sub-list of the input and L is not\
    \ equal to P.\n        // We can re-write this as s_P - M(P) < s_L - M(L) as\n\
    \        // s_P - s_L < M(L) - M(P)\n        //\n        // Or s_P < s_L + M(L)\
    \ - M(P)\n        //\n        // Or M(P) > s_P - s_L - M(L)\n        // Then we\
    \ find the path P that maximizes the right-hand side of this inequality.\n   \
    \     //\n        // Let's try to find a P that maximizes M(P)\n        // Since\
    \ M(P) <= M(L) and M(L) <= 0, the value of M(P) is minimized when P contains\n\
    \        // the minimum element of the list. Thus we only consider paths P where\n\
    \        // M(P) = min(nums)\n        // Then we want to find a path P such that\
    \ max(s_P - M(P))\n        // Or s_P > s_L - M(L) for all L s.t. L is a sub-list\
    \ of the input.\n        // We can re-write this as s_P > s_L - M(L) as s_P >\
    \ s_L + M(L)\n        // Then we find the path P that maximizes the right-hand\
    \ side of this inequality.\n        //\n        // In the worst case, we have\
    \ a list of all positive numbers. Then all sub-lists\n        // have positive\
    \ sums. So we just want to find the path that", "        // Return a list of the\
    \ minimum subarray sums ending at this index.\n        def minSums(index : Int)\
    \ : List[Long] = {\n            // Find the minimum sums for each subarray ending\
    \ at the last element.\n            def minSumsLoop(index : Int, minSums : List[Long])\
    \ : List[Long] = {\n                if (index < 0) minSums\n                else\
    \ {\n                    val min = min(nums(index), nums(index) + minSums.head)\n\
    \                    minSumsLoop(index - 1, min :: minSums)\n                }\n\
    \            }\n            if (index == 0) nums\n            else {\n       \
    \         val lastSums = minSums(index - 1)\n                val thisSums = minSumsLoop(index\
    \ - 1, List(nums(index)))\n                // Combine the two lists of minimum\
    \ sums.\n                (lastSums, thisSums).zipped.map(_ min _)\n          \
    \  }\n        }\n        val numsSize = nums.size\n        minSums(numsSize -\
    \ 1)(0)", "        var buffer = 0l\n        var minSum = Long.MaxValue\n     \
    \   for (n <- nums) {\n            buffer += n\n            if (buffer < minSum)\
    \ minSum = buffer\n            if (buffer > 0) buffer = 0\n        }\n       \
    \ return minSum", "        def minSubArraySumIter(nums : List[Long], acc : (Long,\
    \ Long)) : Long = {\n            if (nums.length == 0) acc._2\n            else\
    \ {\n                val value = nums.head\n                val sum = acc._1 +\
    \ value\n                val min = if (sum < acc._2) sum else acc._2\n       \
    \         minSubArraySumIter(nums.tail, (sum, min))\n            }\n        }\n\
    \        minSubArraySumIter(nums, (0l, 0l))", "        // EDGE CASE\n        if\
    \ (nums.length == 0) {\n            0l\n        } else {\n            val s =\
    \ new Array[Long](nums.length + 1)\n            val min : Array[Long] = Array.fill(nums.length\
    \ + 1)(Long.MaxValue)\n            var result : Long = Long.MaxValue\n       \
    \     for (i <- 1 to nums.length) {\n                s(i) = s(i - 1) + nums(i\
    \ - 1)\n                for (j <- 0 until i) {\n                    result = min(j)\
    \ + s(i) - s(j)\n                    min(i) = min(i) min result\n            \
    \    }\n            }\n            min(nums.length)\n        }", "        val\
    \ zero : Long = 0\n        val negative : Long = -1\n        if (nums.isEmpty)\
    \ {\n            return zero\n        }\n        var min : Long = nums.apply(0)\n\
    \        var sum : Long = zero\n        for (num <- nums) {\n            if (sum\
    \ + num < min) {\n                min = sum + num\n            }\n           \
    \ if (sum + num < zero) {\n                sum = zero\n            } else {\n\
    \                sum = sum + num\n            }\n        }\n        if (min <\
    \ zero) {\n            return min\n        } else {\n            return zero\n\
    \        }", "        var sum = Long.MaxValue;\n        var t = 0l;\n        for\
    \ (num <- nums) {\n            t += num;\n            if (t < sum) sum = t;\n\
    \            if (t > 0) t = 0;\n        }\n        sum", "        var minSum =\
    \ Long.MaxValue\n        var sum = 0l\n        for (x <- nums) {\n           \
    \ sum += x\n            if (sum < minSum) minSum = sum\n            if (sum >\
    \ 0) sum = 0\n        }\n        minSum", "        var minSum = nums(0)\n    \
    \    var currentSum = 0\n        for (num <- nums) {\n            currentSum +=\
    \ num\n            if (currentSum < minSum) minSum = currentSum\n            if\
    \ (currentSum > 0) currentSum = 0\n        }\n        return minSum", "      //\
    \ Fill in the missing code.\n      val maxValue = (Long.MaxValue/2)\n      val\
    \ minValue = -maxValue\n      val n = nums.length\n      var minSum = maxValue\n\
    \      var sum = 0\n      for (i <- 0 until n) {\n        sum += nums(i)\n   \
    \     minSum = min(minSum, sum)\n        if (sum > 0) sum = 0\n      }\n     \
    \ minSum", "        //Given nums = [2, 3, 4, 1, 2, 4]\n        //nums.scanLeft(0l)(_\
    \ + _) = [0, 2, 5, 9, 10, 12, 16]\n        //nums.scanLeft(0l)(_ + _).tail = [2,\
    \ 5, 9, 10, 12, 16]\n        //nums.scanLeft(0l)(_ + _).tail.sorted = [2, 5, 9,\
    \ 10, 12, 16]\n        val sums = nums.scanLeft(0l)(_ + _).tail.sorted\n     \
    \   //sums = [2, 5, 9, 10, 12, 16]\n        //sums(0) = 2\n        //sums(1) =\
    \ 5\n        //sums(2) = 9\n        //sums(3) = 10\n        //sums(4) = 12\n \
    \       //sums(5) = 16\n        val minimumSum = sums(0)\n        //minimumSum\
    \ = 2\n        //minimumSum = 5\n        //minimumSum = 9\n        //minimumSum\
    \ = 10\n        //minimumSum = 12\n        //minimumSum = 16\n        for (i <-\
    \ 1 until sums.length) {\n            //sums(i) = 5\n            //sums(i) = 9\n\
    \            //sums(i) = 10\n            //sums(i) = 12\n            //sums(i)\
    \ = 16\n            val current = sums(i)\n            //current = 5\n       \
    \     //current = 9\n            //current = 10\n            //current = 12\n\
    \            //current = 16\n            val prev = sums(i - 1)\n            //prev\
    \ = 2\n            //prev = 5\n            //prev = 9\n            //prev = 10\n\
    \            //prev = 12\n            val diff = current - prev\n            //diff\
    \ = 3\n            //diff = 4\n            //diff = 1\n            //diff = 2\n\
    \            //diff = 4\n            minimumSum = min(minimumSum, diff)\n    \
    \        //minimumSum = 2\n            //minimumSum = 2\n            //minimumSum\
    \ = 1\n            //minimumSum = 1\n            //minimumSum = 1\n        }\n\
    \        //minimumSum = 1\n        minimumSum", "        //import scala.collection.mutable.HashMap\n\
    \        def optimize(nums : List[Long], cache : HashMap[Long, Long]) : Long =\
    \ {\n            nums match {\n                case (x :: Nil) => cache(x) = x\n\
    \                case (x :: xs) => {\n                    cache(x) = min(x, x\
    \ + cache(xs.head))\n                    optimize(xs, cache)\n               \
    \ }\n            }\n            cache(nums.head)\n        }\n        optimize(nums,\
    \ HashMap[Long, Long]())", "        if (nums.isEmpty) return 0\n        var result\
    \ = nums.head\n        var sum = 0\n        for (num <- nums) {\n            sum\
    \ += num\n            result = min(result, sum)\n            if (sum > 0) sum\
    \ = 0\n        }\n        return result", "        def minSubArraySumHelper(nums\
    \ : List[Long], currSum : Long, minSum : Long) : Long = {\n            if (nums.isEmpty)\
    \ minSum\n            else {\n                val currValue = nums.head\n    \
    \            val newSum = currSum + currValue\n                val minSumNow =\
    \ min(newSum, minSum)\n                if (newSum < 0) minSubArraySumHelper(nums.tail,\
    \ 0, minSumNow)\n                else minSubArraySumHelper(nums.tail, newSum,\
    \ minSumNow)\n            }\n        }\n        minSubArraySumHelper(nums, 0,\
    \ nums.head)", "        // Define a suffix sum array, where the ith element of\
    \ the array is the sum\n        // of the elements from the ith element to the\
    \ end of the original array.\n        var s : List[Long] = nums.scanLeft(0l)(_\
    \ + _).tail\n        // The minimum suffix sum will occur at some index, i.\n\
    \        // Minimum sum sub-list has length i + 1.\n        s.foldLeft((s.head,\
    \ 1))({\n            (acc : (Long, Int), v : Long) => {\n                val (minSum\
    \ : Long, minIndex : Int) = acc\n                if (v < minSum) (v, 0) else (minSum,\
    \ minIndex + 1)\n            }\n        })._1", "        if (nums.isEmpty) return\
    \ 0l\n        var minSum = nums.head\n        var curSum = nums.head\n       \
    \ for (i <- 1 until nums.length) {\n            curSum = min(curSum + nums(i),\
    \ nums(i))\n            minSum = min(minSum, curSum)\n        }\n        return\
    \ minSum", "        def helper(nums : List[Long], memo : Map[List[Long], Long])\
    \ : Long = {\n            if (memo.contains(nums)) memo(nums)\n            else\
    \ {\n                val r = nums match {\n                    case Nil => 0l\n\
    \                    case x :: Nil => min(0l, x)\n                    case x ::\
    \ y :: Nil => min(x, y, x + y)\n                    case _ =>\n              \
    \          val first = nums.head\n                        val last = nums.last\n\
    \                        val x = min(first, last, last + first)\n            \
    \            val x1 = min(first, last, last + first, last + minSubArraySum(nums.init))\n\
    \                        val x2 = min(first, last, last + first, first + minSubArraySum(nums.tail))\n\
    \                        min(x, x1, x2)\n                }\n                memo\
    \ += nums -> r\n                r\n            }\n        }\n        helper(nums,\
    \ Map())", "        // Fill in the function body\n        var min = Long.MaxValue\n\
    \        var cum = 0l\n        for (j <- 0 until nums.length) {\n            cum\
    \ += nums(j)\n            if (cum < min) min = cum\n            if (cum > 0) cum\
    \ = 0\n        }\n        return min", "        def helper(nums : List[Long],\
    \ prefixSum : Long, minSum : Long) : Long = {\n            if (nums.length ==\
    \ 0) minSum\n            else helper(nums.tail, prefixSum + nums.head, min(prefixSum\
    \ + nums.head, minSum))\n        }\n        if (nums.length == 0) 0\n        else\
    \ if (nums.length == 1) nums.head\n        else helper(nums.tail, nums.head, nums.head)",
  "        var minSum = Long.MaxValue\n        var sum = 0l\n        for (num <- nums)\
    \ {\n            sum += num\n            if (sum < minSum) minSum = sum\n    \
    \        if (sum > 0) sum = 0\n        }\n        minSum", "        if (nums.isEmpty)\
    \ return 0l.toLong\n        val minSums = ListBuffer[Long]()\n        for (i <-\
    \ 0 until nums.length) {\n            for (j <- i until nums.length) {\n     \
    \           minSums += nums.slice(i, j + 1).sum\n            }\n        }\n  \
    \      minSums.min", "        val dp = Array.fill(nums.length)(0l)\n        for\
    \ (i <- 1 until nums.length) {\n            dp(i) = max(dp(i - 1) + nums(i), nums(i))\n\
    \        }\n        dp.min", "      // Fill up this function body\n      // You\
    \ have to return the minimum sum\n      // Example:\n      // >>>> val nums =\
    \ List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong)\n\
    \      // >>>> minSubArraySum(nums)\n      // (1l)\n      return 1l", "      \
    \  // Recursive helper function\n        def minSubArraySumHelper(nums : List[Long],\
    \ currentSum : Long, minimumSum : Long) : Long = {\n            if (nums.isEmpty)\
    \ minimumSum\n            else {\n                val newSum = currentSum + nums.head\n\
    \                if (newSum < minimumSum) minSubArraySumHelper(nums.tail, newSum,\
    \ newSum)\n                else minSubArraySumHelper(nums.tail, newSum, minimumSum)\n\
    \            }\n        }\n        // Boundary case\n        if (nums.isEmpty)\
    \ 0\n        else minSubArraySumHelper(nums.tail, nums.head, nums.head)", "  \
    \      // Given a list of integers, find the minimum sum of any non-empty sub-list\n\
    \        // of integers.\n        // We use Kadane's algorithm with a minor modification.\n\
    \        // We also remember the min sum, min start, and min end.\n        //\
    \ >>> minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ 4l.toLong)))\n        // (List[Long](1l.toLong, 2l.toLong, 4l.toLong))\n   \
    \     def minSubArraySum(nums : List[Long], minSum : Long, minStart : Int, minEnd\
    \ : Int, currStart : Int, currSum : Long) : (Long, Int, Int) = {\n           \
    \ if (nums.isEmpty) {\n                (minSum, minStart, minEnd)\n          \
    \  } else {\n                val first = nums.head\n                val newSum\
    \ = currSum + first\n                if (newSum < 0) {\n                    minSubArraySum(nums.tail,\
    \ min(minSum, newSum), currStart + 1, currStart + 1, currStart + 1, 0)\n     \
    \           } else {\n                    minSubArraySum(nums.tail, min(minSum,\
    \ newSum), minStart, currStart + 1, currStart, newSum)\n                }\n  \
    \          }\n        }\n        minSubArraySum(nums, Long.MaxValue, 0, 0, 0,\
    \ 0)._1", "        val prefixSums = nums.scanLeft(0l)(_ + _)\n        val minSums\
    \ = prefixSums.drop(1).scanLeft(nums.head)(min(_, _))\n        prefixSums.drop(1).zip(minSums).map(x\
    \ => x._1 - x._2).min", "        val n = nums.length\n        val dp = Array.fill(n)(0l)\n\
    \        dp(0) = nums(0)\n        var sum = dp(0)\n        var min = dp(0)\n \
    \       for (i <- 1 until n) {\n            dp(i) = max(dp(i - 1) + nums(i), nums(i))\n\
    \            sum += nums(i)\n            min = min min dp(i)\n        }\n    \
    \    return min min sum", "        // val l = nums.length\n        val l = nums.size\n\
    \        // Return the min value of (1) nums(i) + minSubArraySum(nums(i+1)) and\
    \ (2) nums(i)\n        // def search(i : Int) : Long = {\n        //     if (i\
    \ >= l) throw new Exception\n        //     if (i == l - 1) nums(i)\n        //\
    \     else min(nums(i) + search(i + 1), nums(i))\n        // }\n        // //\
    \ return search(0)\n        // search(0)\n        // Iterative approach\n    \
    \    if (l == 0) return 0l\n        var min_sum = nums(0)\n        var max_sum\
    \ = nums(0)\n        for (i <- 1 until l) {\n            max_sum = max(nums(i),\
    \ max_sum + nums(i))\n            min_sum = min(min_sum, max_sum)\n        }\n\
    \        min_sum", "        var min = 0l\n        var acc = 0l\n        var minFound\
    \ = false\n        nums.foreach(num => {\n            acc += num\n           \
    \ if (acc < min || !minFound) {\n                min = acc\n                minFound\
    \ = true\n            }\n            if (acc > 0) acc = 0\n        })\n      \
    \  min", "        val n = nums.length\n        val f = Array.fill(n, n)(0l)\n\
    \        for (i <- 0 until n) {\n            f(i)(i) = nums(i)\n            for\
    \ (j <- i + 1 until n) {\n                f(i)(j) = f(i)(j - 1) + nums(j)\n  \
    \          }\n        }\n        var res = Long.MaxValue\n        for (i <- 0\
    \ until n) {\n            for (j <- i until n) {\n                res = min(res,\
    \ f(i)(j))\n            }\n        }\n        res", "      // Fill up this function\
    \ body\n      // You have to return a long (as shown in the example)\n      var\
    \ m = Map[Long, Long]()\n      var index = 0l.toLong\n      for (i <- nums) {\n\
    \        m += (index -> i)\n        index += 1\n      }\n      var minSum = Long.MaxValue\n\
    \      index = 0l.toLong\n      for (i <- nums) {\n        var sum = 0l.toLong\n\
    \        for (j <- index to (index + nums.length - 1)) {\n          sum += m(j\
    \ % nums.length)\n          if (sum < minSum) {\n            minSum = sum\n  \
    \        }\n        }\n        index += 1\n      }\n      return minSum", "  \
    \      var min = Long.MaxValue\n        var temp = 0L\n        var start = 0\n\
    \        var end = 0\n        while (end < nums.length) {\n            temp +=\
    \ nums(end)\n            while (temp >= 0) {\n                min = min min temp\n\
    \                temp -= nums(start)\n                start += 1\n           \
    \ }\n            end += 1\n        }\n        return min", '        return 0',
  "        // We will first use the Kadane's algorithm to find the minimum sub-array\n\
    \        // sum\n        // that ends at each index.\n        // Then we'll find\
    \ the minimum of these minimums.\n        // >>> minimums = Kadane((List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong)))\n        // >>> minimums.min\n\
    \        // (1l)\n        val minimums = Kadane(nums)\n        minimums.min",
  "        // Time complexity: O(n)\n        // Space complexity: O(1)\n        //\
    \ Pre-sum array\n        val cumulativeSum = new Array[Long](nums.length + 1)\n\
    \        for (i <- 1 to nums.length) cumulativeSum(i) = cumulativeSum(i - 1) +\
    \ nums(i - 1)\n        var minSum = Long.MaxValue\n        for (i <- 1 to nums.length)\
    \ for (j <- 0 until i) minSum = min(minSum, cumulativeSum(i) - cumulativeSum(j))\n\
    \        minSum", "        // We will be using the sliding window technique for\
    \ this problem\n        var l : Int = 0;\n        var r : Int = 0;\n        var\
    \ currSum : Long = 0;\n        var minSum : Long = 0;\n        var numsLen : Int\
    \ = nums.length;\n        while (r < numsLen) {\n            // We will be going\
    \ through all the sub arrays\n            // and find the one with the minimum\
    \ sum\n            currSum += nums(r);\n            // If the current sum is less\
    \ than the minimum sum\n            // then we update the minimum sum to the current\
    \ sum\n            if (currSum < minSum) {\n                minSum = currSum;\n\
    \            }\n            r += 1;\n        }\n        // If the minimum sum\
    \ is greater than or equal to 0\n        // then we return 0\n        if (minSum\
    \ >= 0) {\n            return 0;\n        }\n        return minSum;", "      \
    \  var minSum = nums(0)\n        var currentSum = nums(0)\n        for (i <- 1\
    \ until nums.length) {\n            currentSum = min(currentSum + nums(i), nums(i))\n\
    \            minSum = min(minSum, currentSum)\n        }\n        minSum", " \
    \       val l = nums.length\n        var i = 0\n        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        while (i < l) {\n            sum += nums(i)\n \
    \           if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \            i += 1\n        }\n        minSum", "        // Fill this in.\n \
    \       val minInList = nums.min\n        if (minInList < 0) return minInList\n\
    \        var minSum = Long.MaxValue\n        var sum = 0l\n        for (n <- nums)\
    \ {\n            sum += n\n            if (sum < minSum) minSum = sum\n      \
    \      if (sum > 0) sum = 0\n        }\n        return minSum", "        // Fill\
    \ in the code here\n        nums.foldLeft(nums.tail.foldLeft(nums.head)((m, i)\
    \ => min(m, i)))((m, i) => min(m, i))", "        var min = Long.MaxValue\n   \
    \     for (i <- 0 until nums.length) {\n            var sum = 0l\n           \
    \ for (j <- i until nums.length) {\n                sum += nums(j)\n         \
    \       if (sum < min) min = sum\n            }\n        }\n        min", "  \
    \      var minSum = nums(0)\n        var curSum = 0\n        for (i <- 0 until\
    \ nums.length) {\n            curSum += nums(i)\n            if (curSum < minSum)\
    \ minSum = curSum\n            if (curSum > 0) curSum = 0\n        }\n       \
    \ return minSum", "        // Calculate the prefix sums\n        val prefixSum\
    \ = new Array[Long](nums.length + 1)\n        prefixSum(0) = 0\n        for (i\
    \ <- 0 until nums.length) {\n            prefixSum(i + 1) = prefixSum(i) + nums(i)\n\
    \        }\n        // Start with the maximum possible value\n        var result\
    \ = Long.MaxValue\n        for (i <- 0 until nums.length) {\n            for (j\
    \ <- i + 1 until nums.length + 1) {\n                result = min(result, prefixSum(j)\
    \ - prefixSum(i))\n            }\n        }\n        return result", "       \
    \ val sum = new Array[Long](nums.length)\n        sum(0) = nums(0)\n        for\
    \ (i <- 1 until nums.length) {\n            sum(i) = nums(i) + sum(i - 1)\n  \
    \      }\n        val min = new Array[Long](nums.length)\n        min(0) = sum(0)\n\
    \        for (i <- 1 until sum.length) {\n            min(i) = min(i - 1) min\
    \ sum(i)\n        }\n        min.max", "        val m : Long = 0;\n        val\
    \ p : Long = 0;\n        var (c, a) = (m, p);\n        for (i <- 0 until nums.length)\
    \ {\n            c = max(c + nums(i), m);\n            a = min(a, c);\n      \
    \  }\n        return a;", "        var minValue = Long.MaxValue;\n        for\
    \ (subList <- nums.sublists) {\n            val sum = subList.sum\n          \
    \  if (sum < minValue) {\n                minValue = sum\n            }\n    \
    \    }\n        return minValue", "        var result : Long = Long.MaxValue\n\
    \        var sum : Long = 0\n        var currentMin : Long = 0\n        var currentMinIdx\
    \ : Int = 0\n        var i : Int = 0\n        while(i < nums.length) {\n     \
    \       sum += nums(i)\n            if(sum - currentMin < result) result = sum\
    \ - currentMin\n            if(sum < currentMin) {\n                currentMin\
    \ = sum\n                currentMinIdx = i\n            }\n            i += 1\n\
    \        }\n        return result", "        val n = nums.length\n        val\
    \ dp = new Array[Long](n)\n        dp(0) = nums(0)\n        for (i <- 1 until\
    \ n) {\n            dp(i) = min(dp(i - 1) + nums(i), nums(i))\n        }\n   \
    \     var sum = Long.MaxValue\n        for (i <- 0 until n) {\n            sum\
    \ = min(sum, dp(i))\n        }\n        sum", "        // Fill in the blanks...\n\
    \        val n = nums.length\n        if (n == 0) return 0\n        var minSum\
    \ = Long.MaxValue\n        for (i <- 0 until n) {\n            var sum = 0l\n\
    \            for (j <- i until n) {\n                sum += nums(j)\n        \
    \        minSum = min(minSum, sum)\n            }\n        }\n        return minSum",
  "        var minSum = Long.MaxValue\n        var sum = 0\n        nums.foreach(x\
    \ => {\n            sum += x\n            if (sum < minSum) minSum = sum\n   \
    \         if (sum > 0) sum = 0\n        })\n        minSum", "        if (nums.length\
    \ == 0) 0\n        else {\n            var minSum = Long.MaxValue\n          \
    \  var minStart = 0\n            var minEnd = 0\n            var start = 0\n \
    \           var end = 0\n            var curSum = 0l\n            while (end <\
    \ nums.length) {\n                curSum += nums(end)\n                if (curSum\
    \ < minSum) {\n                    minSum = curSum\n                    minStart\
    \ = start\n                    minEnd = end\n                }\n             \
    \   if (curSum > 0) {\n                    curSum = 0\n                    start\
    \ = end + 1\n                }\n                end += 1\n            }\n    \
    \        minSum\n        }", "        // Fill in the implementation\n        val\
    \ solution: Long = 0\n        return solution", "        var minSum = nums(0)\n\
    \        var currentSum = nums(0)\n        var index = 1\n        while (index\
    \ < nums.length) {\n            if (currentSum < 0) {\n                currentSum\
    \ = nums(index)\n            } else {\n                currentSum += nums(index)\n\
    \            }\n            if (currentSum < minSum) {\n                minSum\
    \ = currentSum\n            }\n            index += 1\n        }\n        return\
    \ minSum", "        // your code here\n        val subSums = for (i <- 0 until\
    \ nums.length) yield {\n        \tvar sum = 0l\n        \tfor (j <- i until nums.length)\
    \ {\n        \t\tsum += nums(j)\n        \t\tsum\n        \t}\n        }\n   \
    \     subSums.flatten.filter(_ > 0).min", "        // (n^2) time.\n        var\
    \ minimum : Long = nums.sum\n        for (i <- 0 until nums.length) {\n      \
    \      var sum : Long = 0\n            for (j <- i until nums.length) {\n    \
    \            sum += nums(j)\n                if (sum < minimum) minimum = sum\n\
    \            }\n        }\n        return minimum", '        return 0', "    \
    \    // IMPLEMENT ME\n        return 0l", "        // Time Complexity: O(n^2)\n\
    \        // Space Complexity: O(1)\n        var minimum = nums.sum\n        var\
    \ start = 0\n        while (start < nums.length) {\n            var subSum = 0l\n\
    \            var end = start\n            while (end < nums.length) {\n      \
    \          subSum += nums(end)\n                minimum = min(minimum, subSum)\n\
    \                end += 1\n            }\n            start += 1\n        }\n\
    \        return minimum", "        // Impl\n        var min = nums(0)\n      \
    \  val map = new HashMap[Int, Long]\n        map(0) = nums(0)\n        for (i\
    \ <- 1 until nums.length) {\n            if (map(i - 1) < 0) map(i) = nums(i)\n\
    \            else map(i) = map(i - 1) + nums(i)\n            if (map(i) < min)\
    \ min = map(i)\n        }\n        min", "        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        minSum", "        var minSum = nums(0)\n        var currentSum\
    \ = 0\n        for (num <- nums) {\n            currentSum += num\n          \
    \  if (currentSum < minSum) minSum = currentSum\n            if (currentSum >\
    \ 0) currentSum = 0\n        }\n        return minSum", "        val sum = nums.sum\n\
    \        def loop(left : Long, right : Long, current : Long, temp : Long) : Long\
    \ = {\n            if (left == right) current\n            else {\n          \
    \      if (temp < 0) loop(left + 1, right, min(current, temp), temp + nums(left.toInt))\n\
    \                else loop(left + 1, right, current, temp + nums(left.toInt))\n\
    \            }\n        }\n        loop(0, nums.length, sum, 0)", "        var\
    \ prev : Long = 0\n        var min : Long = 0\n        val l = nums.length\n \
    \       for (i <- 0 until l) {\n            if (nums(i) > 0) prev += nums(i)\n\
    \            else {\n                if (prev < min) min = prev\n            \
    \    prev = 0\n            }\n        }\n        if (prev < min) min = prev\n\
    \        if (min == 0) return nums.min\n        return min", "        var minSum\
    \ = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n       \
    \     sum += num\n            if (sum < minSum) minSum = sum\n            if (sum\
    \ > 0) sum = 0\n        }\n        minSum", "        var min_ending_here = 0l\n\
    \        var min_so_far = 0l\n        var i = 0\n        while(i < nums.length)\
    \ {\n            min_ending_here = min(0, min_ending_here + nums(i))\n       \
    \     min_so_far = min(min_so_far, min_ending_here)\n            i += 1\n    \
    \    }\n        return min_so_far", "        var lowest = Long.MaxValue\n    \
    \    var sum = 0l\n        for (i <- 0 until nums.length) {\n            sum +=\
    \ nums(i)\n            lowest = min(lowest, sum)\n            if (sum < 0) sum\
    \ = 0\n        }\n        return lowest", "        def helper(index : Int, currentSum\
    \ : Long, minSum : Long) : Long = {\n            if (index >= nums.length) minSum\n\
    \            else {\n                val currentNum = nums(index)\n          \
    \      helper(index + 1, currentSum + currentNum, min(minSum, currentSum + currentNum))\n\
    \            }\n        }\n        helper(0, 0, helper(0, 0, nums(0)))", "   \
    \     def helper(nums : List[Long], currSum : Long, minSum : Long) : Long = {\n\
    \            nums match {\n                case Nil => minSum\n              \
    \  case x :: xs => {\n                    val newCurrSum = if (currSum <= 0) x\
    \ else x + currSum\n                    val newMinSum = if (newCurrSum < minSum)\
    \ newCurrSum else minSum\n                    helper(xs, newCurrSum, newMinSum)\n\
    \                }\n            }\n        }\n        if (nums.length == 0) 0\
    \ else helper(nums, 0, Long.MaxValue)", "        val l = nums.length\n       \
    \ val mins = Array.fill(l)(0l)\n        var min = nums(0)\n        mins(0) = nums(0)\n\
    \        for (i <- 1 until l) {\n            mins(i) = mins(i - 1) + nums(i)\n\
    \            min = min min mins(i)\n        }\n        for (i <- 0 until l) {\n\
    \            mins(i) = mins(i) - min\n        }\n        for (i <- 0 until l)\
    \ {\n            if (mins(i) == 0) return min\n        }\n        min", "    \
    \    // Precompute a prefix sum.\n        val prefixSum = Array.fill(nums.length)(0l)\n\
    \        var sum = 0l\n        for (i <- 0 until nums.length) {\n            sum\
    \ += nums(i)\n            prefixSum(i) = sum\n        }\n        var minSum =\
    \ Long.MaxValue\n        // Iterate through all sub-arrays, using the prefix sum\
    \ to calculate the sum of\n        // the sub-array in constant time.\n      \
    \  for (i <- 0 until nums.length) {\n            for (j <- i until nums.length)\
    \ {\n                val subSum = if (i == 0) prefixSum(j) else prefixSum(j) -\
    \ prefixSum(i - 1)\n                minSum = min(minSum, subSum)\n           \
    \ }\n        }\n        minSum", "        // Fill in the function body\n     \
    \   val sum = nums.sum\n        var maxSum = 0l\n        for (i <- 0 until nums.length)\
    \ {\n            maxSum = max(maxSum, nums(i))\n        }\n        var left =\
    \ maxSum\n        var right = sum\n        while (left < right) {\n          \
    \  val mid = (left + right) / 2\n            if (canSum(nums, mid)) {\n      \
    \          right = mid\n            } else {\n                left = mid + 1\n\
    \            }\n        }\n        return left", "        // Your code here\n\
    \        throw new Exception(\"Not Implemented\")", "        val n = nums.length\n\
    \        var ans = nums(0)\n        var sum = 0l\n        for (i <- 0 until n)\
    \ {\n            sum += nums(i)\n            ans = min(ans, sum)\n           \
    \ if (sum > 0) sum = 0\n        }\n        ans", "        var minSum = nums(0)\n\
    \        var sum = nums(0)\n        for (i <- 1 until nums.length) {\n       \
    \     sum = min(sum + nums(i), nums(i))\n            minSum = min(minSum, sum)\n\
    \        }\n        minSum", "        val prefixSum = new Array[Long](nums.length)\n\
    \        prefixSum(0) = nums(0)\n        for (i <- 1 until nums.length) prefixSum(i)\
    \ = prefixSum(i - 1) + nums(i)\n        var min = prefixSum(0)\n        for (i\
    \ <- 0 until nums.length - 1) {\n            min = min min (prefixSum(nums.length\
    \ - 1) - prefixSum(i))\n        }\n        min", "        // We're looking for\
    \ a contiguous sub-array whose sum is the least.\n        // For example, the\
    \ sub-array [2, 3, 4, 1, 2, 4] has the least sum.\n        // The key insight\
    \ is to construct an array called \"sums\" of the same length\n        // as nums,\
    \ where sums(i) = sum of nums(0) to nums(i).\n        // Then we can compute the\
    \ sum of any sub-array in constant time.\n        // E.g. given [2, 3, 4, 1, 2,\
    \ 4], nums = [2, 3, 4, 1, 2, 4],\n        // and sums = [2, 5, 9, 10, 12, 16].\n\
    \        // The sum of the sub-array [2, 3, 4, 1, 2, 4] is 16 - 2 = 14.\n    \
    \    // The sum of the sub-array [3, 4, 1, 2, 4] is 16 - 5 = 11.\n        // The\
    \ sum of the sub-array [4, 1, 2, 4] is 16 - 9 = 7.\n        // The sum of the\
    \ sub-array [1, 2, 4] is 16 - 10 = 6.\n        // The sum of the sub-array [2,\
    \ 4] is 16 - 12 = 4.\n        // The sum of the sub-array [4] is 16 - 16 = 0.\n\
    \        // The minimum is 4.\n        val sums = ListBuffer[Long]()\n       \
    \ sums += nums(0)\n        for (i <- 1 until nums.length) sums += sums(i - 1)\
    \ + nums(i)\n        var minimum = sums(sums.length - 1)\n        for (i <- 0\
    \ until sums.length) {\n            val complement = sums(sums.length - 1) - sums(i)\n\
    \            if (complement < minimum) minimum = complement\n        }\n     \
    \   minimum", "        // Fill this in.\n        nums.min", "        val maxPossible\
    \ : Long = Long.MaxValue\n        val memo : Array[Long] = new Array[Long](nums.length)\n\
    \        for (i <- nums.indices) memo(i) = maxPossible\n        memo(0) = nums(0)\n\
    \        for (i <- 1 until nums.length) {\n            memo(i) = min(memo(i -\
    \ 1) + nums(i), nums(i))\n        }\n        var minSum : Long = maxPossible\n\
    \        for (i <- memo.indices) {\n            minSum = min(minSum, memo(i))\n\
    \        }\n        minSum", "        val inf = Long.MaxValue / 2\n        val\
    \ n = nums.length\n        val dp = Array.fill(n + 1)(inf)\n        dp(0) = 0\n\
    \        for (i <- 1 to n) dp(i) = min(dp(i - 1) + nums(i - 1), nums(i - 1))\n\
    \        dp.tail.min", "        var minSum = nums(0)\n        var curSum = 0l\n\
    \        var start = 0\n        for(i <- nums.indices) {\n            curSum +=\
    \ nums(i)\n            if(curSum < minSum) {\n                minSum = curSum\n\
    \                start = i\n            }\n            if(curSum > 0) {\n    \
    \            curSum = 0\n            }\n        }\n        return minSum", " \
    \       val max = Long.MaxValue\n        val min = Long.MinValue\n        var\
    \ minSum = max\n        var sum = 0\n        for (i <- 0 until nums.length) {\n\
    \            sum += nums(i)\n            if (sum < minSum) minSum = sum\n    \
    \        if (sum < 0) sum = 0\n        }\n        return minSum", '        return
    0l', "        // Naive solution for now\n        // All sub-lists are consecutive\
    \ elements of the list\n        val subLists = for (i <- 0 until nums.length)\
    \ yield {\n            nums.slice(i, nums.length)\n        }\n        // Return\
    \ the minimum sum\n        return subLists.map(l => l.sum).min", "        var\
    \ minSum = nums(0)\n        var curSum = nums(0)\n        for (i <- 1 until nums.length)\
    \ {\n            curSum = max(nums(i), curSum + nums(i))\n            minSum =\
    \ min(minSum, curSum)\n        }\n        minSum", "        val nums2 = nums.map(x\
    \ => abs(x))\n        val n = nums2.length\n        var sums = new Array[Long](n\
    \ + 1)\n        sums(0) = 0\n        for (i <- 0 until n) {\n            sums(i\
    \ + 1) = sums(i) + nums2(i)\n        }\n        var minPrefixSum = 0\n       \
    \ var minSuffixSum = 0\n        var minSuffixSumIndex = 0\n        var minPrefixSumIndex\
    \ = 0\n        var minSum = sums(n)\n        for (i <- 0 until n) {\n        \
    \    if (sums(i) - minPrefixSum < minSum) {\n                minPrefixSum = sums(i)\n\
    \                minPrefixSumIndex = i\n            }\n            if (sums(n)\
    \ - sums(i) - minSuffixSum < minSum) {\n                minSuffixSum = sums(n)\
    \ - sums(i)\n                minSuffixSumIndex = i\n            }\n        }\n\
    \        // Iterate through the sub-list, and check if we can make the sum smaller\n\
    \        for (i <- minPrefixSumIndex until minSuffixSumIndex) {\n            val\
    \ sum = sums(minSuffixSumIndex) - sums(i)\n            if (sum < minSum) {\n \
    \               minSum = sum\n            }\n        }\n        val numSigns =\
    \ nums.map(x => signum(x))\n        val numNegativeSigns = numSigns.filter(x =>\
    \ x == -1).length\n        if (numNegativeSigns % 2 == 0) {\n            minSum\n\
    \        } else {\n            -minSum\n        }", "        var minSum = Long.MaxValue;\n\
    \        var sum = 0l;\n        nums.foreach(x => {\n            sum += x;\n \
    \           if (sum < minSum) minSum = sum;\n            if (sum > 0) sum = 0;\n\
    \        });\n        return minSum;", "        var last = 0l\n        var lastMin\
    \ = 0l\n        for (i <- 0 until nums.length) {\n            val c = nums(i)\n\
    \            last = last + c\n            if (last < lastMin) lastMin = last\n\
    \            if (last > 0) last = 0\n        }\n        lastMin", "        var\
    \ sum = Long.MaxValue\n        var curr = 0l\n        for (i <- 0 until nums.length)\
    \ {\n            curr += nums(i)\n            sum = min(sum, curr)\n         \
    \   if (curr > 0) curr = 0\n        }\n        sum", "        // Fill in the solution\
    \ here\n        return 0", "        var (minSubArray, minSubArraySum) = (nums,\
    \ Long.MaxValue)\n        for (i <- 0 until nums.length) {\n            var (subArray,\
    \ subArraySum) = (nums.slice(i, nums.length), 0l)\n            while (subArray.length\
    \ > 0) {\n                subArraySum += subArray.head\n                if (subArraySum\
    \ < minSubArraySum) {\n                    minSubArray = subArray\n          \
    \          minSubArraySum = subArraySum\n                }\n                subArray\
    \ = subArray.tail\n            }\n        }\n        minSubArraySum", "      \
    \  var result : Long = 0\n        var index : Int = 0\n        while (index <\
    \ nums.length) {\n            var sum : Long = 0\n            var subindex : Int\
    \ = index\n            while (subindex < nums.length) {\n                sum +=\
    \ nums(subindex)\n                if (index == 0 && subindex == 0) result = sum\n\
    \                if (sum < result) result = sum\n                subindex += 1\n\
    \            }\n            index += 1\n        }\n        return result", " \
    \       // We know that the minimum sum of any sub-list must be either the minimum\
    \ sum\n        // of a sub-list that starts from the second element or the minimum\
    \ sum of a\n        // sub-list that starts from the first element.\n        //\
    \ Since we have no knowledge of the sub-list, we have to examine all sub-lists\n\
    \        // that starts from the second element and all sub-lists that starts\
    \ from the\n        // first element.\n        // We know that all minimum sub-lists\
    \ must either consist of only the first\n        // element or include the first\
    \ element.\n        // We can use a lazy list to discover the minimum sum of all\
    \ sub-lists that\n        // includes the first element and then take the minimum\
    \ of all three.\n        def minimums(i : Int, list : List[Long]) : Stream[Long]\
    \ = {\n            if (i == list.length) Stream()\n            else {\n      \
    \          val p = list.drop(i).scanLeft(0l)((a, b) => a + b).min\n          \
    \      Stream.cons(p, minimums(i + 1, list))\n            }\n        }\n     \
    \   val s = minimums(1, nums)\n        s.append(Stream(nums(0))).min", "     \
    \   // Let's try a simple O(n^2) solution first.\n        // We iterate through\
    \ all possible sub-arrays,\n        // keeping track of the minimum sum that we've\
    \ seen so far.\n        var minSum = Long.MaxValue\n        for (s <- nums.indices)\
    \ {\n            for (e <- (s to nums.size - 1)) {\n                var sum =\
    \ 0\n                for (i <- s to e) {\n                    sum += nums(i)\n\
    \                }\n                if (sum < minSum) {\n                    minSum\
    \ = sum\n                }\n            }\n        }\n        return minSum",
  "        def minSubArraySumAcc(acc : Long, nums : List[Long]) : Long = {\n     \
    \       if (nums.length == 0) acc\n            else minSubArraySumAcc(min(acc,\
    \ nums.sum), nums.tail)\n        }\n        if (nums.length == 0) 0l\n       \
    \ else minSubArraySumAcc(nums.sum, nums)", "        def minSubArraySumHelper(nums\
    \ : List[Long], minSoFar : Long) : Long = {\n            if (nums.length == 0)\
    \ return minSoFar\n            var subSum = 0l\n            for (i <- 0 until\
    \ nums.length) {\n                subSum += nums(i)\n                minSoFar\
    \ = min(minSoFar, subSum)\n                if (subSum > 0) subSum = 0\n      \
    \      }\n            minSoFar\n        }\n        minSubArraySumHelper(nums,\
    \ Long.MaxValue)", "        // Fill in the function here\n        return 0l",
  "        val minL = new Array[Long](nums.length)\n        var result = nums(0)\n\
    \        minL(0) = nums(0)\n        for (i <- 1 until nums.length) {\n       \
    \     if (minL(i - 1) > 0) {\n                minL(i) = nums(i)\n            }\
    \ else {\n                minL(i) = minL(i - 1) + nums(i)\n            }\n   \
    \         result = min(result, minL(i))\n        }\n        result", "       \
    \ var minimum = nums.min\n        var sum = 0l\n        for (i <- 0 until nums.length)\
    \ {\n            sum = 0l\n            for (j <- i until nums.length) {\n    \
    \            sum += nums(j)\n                if (sum < minimum) minimum = sum\n\
    \            }\n        }\n        return minimum", "        // Fill in the blanks\n\
    \        var min = nums(0)\n        var sum = 0l\n        for (x <- nums) {\n\
    \            sum += x\n            if (sum < min) min = sum\n            if (sum\
    \ > 0) sum = 0\n        }\n        min", "        // Fill in the function body\n\
    \        return -1l", "        // Fill in the blank\n        (0l)", "        var\
    \ minimum = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n\
    \            sum += num\n            if (sum < minimum) minimum = sum\n      \
    \      if (sum > 0) sum = 0\n        }\n        minimum", "        // Good luck!\n\
    \        nums.reduceLeft(min(_, _))", "        // Fill this in.\n        if (nums.isEmpty)\
    \ 0l\n        else nums.tail.foldLeft((nums.head, nums.head)) { (m, n) =>\n  \
    \          if (m._2 > 0) (min(m._1, m._2 + n), m._2 + n)\n            else (min(m._1,\
    \ n), n)\n        }._1", "        // Fill this in.\n        val cumArray = nums.scanLeft(0l)(_\
    \ + _)\n        println(cumArray)\n        cumArray.last - cumArray.dropRight(1).min",
  "        val n = nums.length\n        val sum = Array.fill(n)(0l)\n        for (i\
    \ <- 0 until n) {\n            sum(i) = (if (i == 0) 0 else sum(i - 1)) + nums(i)\n\
    \        }\n        val dp = Array.fill(n)(0l)\n        dp(0) = sum(0)\n     \
    \   var res = Long.MaxValue\n        for (i <- 1 until n) {\n            if (dp(i\
    \ - 1) > 0) dp(i) = sum(i)\n            else dp(i) = sum(i) - dp(i - 1)\n    \
    \        res = min(res, dp(i))\n        }\n        res", "        var min = Long.MaxValue\n\
    \        var currentSum = 0l\n        nums.foreach(num => {\n            currentSum\
    \ += num\n            if (currentSum < min) min = currentSum\n            if (currentSum\
    \ > 0) currentSum = 0\n        })\n        min", "        val windows = (1 to\
    \ nums.length).map(i => nums.sliding(i).map(_.sum).min).min\n        return windows",
  "        val n = nums.length\n        var dp = new Array[Long](n + 1)\n        var\
    \ minSum = Long.MaxValue\n        dp(0) = 0\n        for (i <- 1 to n) {\n   \
    \         dp(i) = max(dp(i - 1) + nums(i - 1), 0)\n            minSum = min(minSum,\
    \ dp(i))\n        }\n        minSum", "        // Define a function that finds\
    \ the minimum sum of any non-empty sub-list of\n        // nums.\n        def\
    \ findMinimum(prevSum : Long, prevMinimum : Long, nums : List[Long]) : Long =\
    \ {\n            if (nums.isEmpty) prevMinimum\n            else {\n         \
    \       val currentSum = prevSum + nums.head\n                val currentMinimum\
    \ = if (currentSum < prevMinimum) currentSum else prevMinimum\n              \
    \  findMinimum(currentSum, currentMinimum, nums.tail)\n            }\n       \
    \ }\n        findMinimum(0, 0, nums)", "        // Time: O(n)\n        var minSum\
    \ = Long.MaxValue\n        var curSum = 0l\n        for (num <- nums) {\n    \
    \        curSum += num\n            if (curSum < minSum) minSum = curSum\n   \
    \         if (curSum > 0) curSum = 0\n        }\n        minSum", "        //\
    \ >>> NOTE: The sum of a sub-list is not inclusive of its first and last elements\n\
    \        // >>> NOTE: If the original list is empty, return 0l.toLong\n      \
    \  // >>> NOTE: If the original list is a single element, return that element\n\
    \        // >>> NOTE: If the original list is a single element, return that element\n\
    \        // >>> NOTE: If all elements are negative, return the element with the\
    \ largest absolute value\n        // >>> NOTE: If all elements are positive, return\
    \ the element with the smallest absolute value\n        // >>> NOTE: If all elements\
    \ are 0, return 0l.toLong\n        // >>> NOTE: If the original list is unsorted,\
    \ sort it in ascending order\n        if (nums.isEmpty) {\n            return\
    \ 0l.toLong\n        }\n        else if (nums.length == 1) {\n            return\
    \ nums(0)\n        }\n        else {\n            // If all elements are negative,\
    \ return the element with the largest absolute value\n            if (nums.forall(e\
    \ => e < 0)) {\n                return nums.reduce((a, b) => if (abs(a) > abs(b))\
    \ a else b)\n            }\n            // If all elements are positive, return\
    \ the element with the smallest absolute value\n            else if (nums.forall(e\
    \ => e > 0)) {\n                return nums.reduce((a, b) => if (abs(a) < abs(b))\
    \ a else b)\n            }\n            // If all elements are 0, return 0l.toLong\n\
    \            else if (nums.forall(e => e == 0)) {\n                return 0l.toLong\n\
    \            }\n            else {\n                // >>> NOTE: If the original\
    \ list is unsorted, sort it in ascending order\n                val sortedNums\
    \ = nums.sorted\n                // Initialize an empty list of sub-lists\n  \
    \              val subListNums = ListBuffer[List[Long]]()\n                //\
    \ Create a list of sub-lists from the original list\n                for (i <-\
    \ 0 until sortedNums.length) {\n                    for (j <- i + 1 until sortedNums.length)\
    \ {\n                        subListNums += sortedNums.slice(i, j)\n         \
    \           }\n               ", "        // O(n)\n        var minSum = nums(0)\n\
    \        var sum = 0l\n        nums.foreach(n => {\n            sum += n\n   \
    \         if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n \
    \       })\n        minSum", "        // Given that the problem is asking for\
    \ the min sum of sub-lists, this\n        // problem is best approached with a\
    \ dynamic programming approach.\n        // We can use a list (table) to store\
    \ minimum sums as we calculate them.\n        // We can let each entry in the\
    \ table be the minimum sum of all\n        // sub-lists that end at that index.\n\
    \        // The final answer is the minimum of all the values in the table.\n\
    \        // The minimum sum of all sub-lists that end at a given index i is the\n\
    \        // minimum between the current value and the minimum sum of all sub-lists\n\
    \        // that end at i - 1.\n        // >>> val table = ListBuffer[Long](-1l.toLong,\
    \ -2l.toLong, -3l.toLong)\n        // >>> for(i <- Range(1, table.length)) {\n\
    \        //      table(i) = min(table(i), table(i - 1) + table(i))\n        //\
    \  }\n        // >>> table\n        // (ListBuffer(-1l, -2l, -3l))\n        //\
    \ >>> table.min\n        // (-6l)\n        val table = ListBuffer[Long](nums(0))\n\
    \        for(i <- Range(1, nums.length)) {\n            table += min(nums(i),\
    \ table(i - 1) + nums(i))\n        }\n        return table.min", "        // Let's\
    \ call the number of items in the list \"m\" and let's call the size of\n    \
    \    // the subarray of the minimum sum \"n\". If n = m, then the minumum sum\
    \ is\n        // the sum of the items in the list. Else, let's take the first\
    \ m - n items\n        // and add them to the sum of the last n items. If the\
    \ first m - n items have\n        // a sum greater than the sum of the last n\
    \ items, then the sum of the last n\n        // items is smaller than the minimum\
    \ sum. Otherwise, the sum of the first m - n\n        // items is smaller than\
    \ the minimum sum. We can continue applying this strategy\n        // to our new\
    \ subarray until we have a subarray of size 1.\n        //\n        // Time complexity:\
    \ O(m)\n        // Space complexity: O(1)\n        def helper(nums : List[Long],\
    \ sum : Long, minSum : Long) : Long = {\n            if (nums.length == 1) {\n\
    \                return List(sum, minSum).min\n            }\n            val\
    \ newSum = sum + nums.head - nums.last\n            val newMinSum = List(sum,\
    \ minSum).min\n            helper(nums.tail, newSum, newMinSum)\n        }\n \
    \       helper(nums, nums.sum, nums.sum)", "        // We will build up a list\
    \ of sum of all prefixes of list\n        // sum(i) = sum(i - 1) + nums(i)\n \
    \       // sum(0) = nums(0)\n        // Then we can find all sub-arrays from 2,\
    \ ..., n by looking at all\n        // possible pairs of start and end: sum(end)\
    \ - sum(start)\n        // This works because for each sub-array, there exist\
    \ a unique start and end\n        // such that the sum of the sub-array can be\
    \ computed as the difference of\n        // the sums of all prefixes up to start\
    \ and all prefixes up to end.\n        // This can be done in linear time, since\
    \ the algorithm takes only one pass.\n        // Since the list is non-empty,\
    \ we can return 0 if the list is empty.\n        // Since a sub-array is a non-empty\
    \ array, we can return the minimum of\n        // the list itself if the list\
    \ has size 1.\n        // We can return min(nums) if nums has size <= 1.\n   \
    \     if (nums.size <= 1) return nums.min\n        // Otherwise, build up a list\
    \ of sum of all prefixes.\n        val sums = new Array[Long](nums.size)\n   \
    \     sums(0) = nums(0)\n        for (i <- 1 until nums.size) {\n            sums(i)\
    \ = sums(i - 1) + nums(i)\n        }\n        // Then, compute the minimum sum.\n\
    \        // This can be done by finding the minimum sum in pairs of all start\
    \ and end.\n        // We can find the minimum sum in pairs by looking at the\
    \ minimum prefix\n        // sum up to the end - the minimum prefix sum up to\
    \ the start (which is\n        // guaranteed to exist because start is guaranteed\
    \ to be less than or equal\n        // to end).\n        // This can be done by\
    \ using a pair of prefix sums, one that is minimum up\n        // to the start\
    \ and one that is minimum up to the end.\n        // To find the minimum prefix\
    \ sum up to the start, we can observe that the\n        // minimum prefix sum\
    \ up to the current start is just the minimum prefix\n        // sum up to the\
    \ previous start if the prefix sum up to", '        ???', "        // Fill this\
    \ in.\n        var m = Int.MaxValue\n        var s = 0\n        for (x <- nums)\
    \ {\n            if (x < m) m = x\n            s += x\n        }\n        if (s\
    \ < 0) return s\n        else return m", "        // init\n        var min = Int.MaxValue\n\
    \        var sum = 0\n        // loop\n        for (x <- nums) {\n           \
    \ if (sum + x < 0) {\n                sum = 0\n            } else {\n        \
    \        sum += x\n                min = min.min(sum)\n            }\n       \
    \ }\n        min.toLong", "        // We use Kadane's algorithm to find this minimum\
    \ sum.\n        // We have a running sum, and the minimum sum.\n        // We\
    \ update the minimum sum to be the minimum between the current minimum\n     \
    \   // sum and the current number, if the running sum of the numbers that make\
    \ up\n        // the sub-list is smaller than the current minimum sum. Otherwise,\
    \ we reset\n        // the running sum to the current number.\n        var minSum\
    \ = nums(0)\n        var runningSum = nums(0)\n        var i = 1\n        while\
    \ (i < nums.length) {\n            if (runningSum < minSum) {\n              \
    \  minSum = runningSum\n            }\n            if (runningSum + nums(i) <\
    \ nums(i)) {\n                runningSum = nums(i)\n            } else {\n   \
    \             runningSum += nums(i)\n            }\n            i += 1\n     \
    \   }\n        if (runningSum < minSum) {\n            minSum = runningSum\n \
    \       }\n        minSum", "        val P = nums.reduce(_ + _)\n        val minSubArraySumRec\
    \ = (P : Long, Q : Long, R : Long, nums : List[Long]) => {\n            if (nums.isEmpty)\
    \ (P, Q)\n            else {\n                val num = nums.head\n          \
    \      val q = R + num\n                val p = P - num\n                val r\
    \ = min(q, p)\n                val (newP, newQ) = minSubArraySumRec(p, Q, r, nums.tail)\n\
    \                (newP, min(newQ, r))\n            }\n        }\n        minSubArraySumRec(P,\
    \ P, 0, nums)._2", "        var minSum = nums(0)\n        var sum = 0\n      \
    \  for (num <- nums) {\n            sum += num\n            if (sum < minSum)\
    \ minSum = sum\n            if (sum > 0) sum = 0\n        }\n        minSum",
  "        // We are given the input will be a list of integers.\n        // We know\
    \ the minimum sum will be the minimum number in the list,\n        // or a negative\
    \ number.\n        // We can brute force by calculating every possible sublist\
    \ and checking\n        // its sum.\n        // This is O(n ^ 2)\n        def\
    \ min(a : Long, b : Long) : Long = {\n            if (a < b) a else b\n      \
    \  }\n        var minSum = nums(0)\n        for (i <- 0 until nums.length) {\n\
    \            var currentSum = 0l\n            for (j <- i until nums.length) {\n\
    \                currentSum += nums(j)\n                minSum = min(minSum, currentSum)\n\
    \            }\n        }\n        return minSum", "        // This problem can\
    \ be solved in O(n^2) time by finding the sum of each sub-list\n        // and\
    \ then finding the minimum sum of the sub-lists.\n        // However, we are looking\
    \ for a more efficient solution.\n        // The following solution runs in O(n)\
    \ time using Kadane's algorithm, which\n        // efficiently computes a maximum\
    \ sub-array sum for a given array.\n        // However, we wish to compute a minimum\
    \ sub-array sum, so this problem can be\n        // solved by first finding the\
    \ maximum negative sub-array sum (using\n        // Kadane's algorithm), and then\
    \ taking the negative of this sum to find the\n        // minimum sub-array sum.\n\
    \        // The key observation that enables this is that the minimum sub-array\
    \ sum must\n        // have a negative value.\n        // Proof by contradiction:\n\
    \        // Suppose that the minimum sub-array sum is positive.\n        // Then,\
    \ the sum of any non-empty sub-list must be non-negative, so the\n        // minimum\
    \ sub-array sum must be 0.\n        // This contradicts the assumption that the\
    \ minimum sub-array sum is positive.\n        // QED\n        // So, if the maximum\
    \ negative sub-array sum is -a, then the minimum sub-array\n        // sum is\
    \ a.\n        // Note that the maximum negative sub-array sum is -INF if the array\
    \ is not\n        // negative, and thus the minimum sub-array sum is INF.\n  \
    \      // However, the problem statement specifies that we can always find a sub-list\n\
    \        // with a positive sum, so the minimum sub-array sum is 0 in this case.\n\
    \        if (nums.exists(_ >= 0)) 0 else (-maxSubArraySum(nums.map(-_)))", " \
    \       var i = 0\n        var currentSum = 0l\n        var minSum = Long.MaxValue\n\
    \        while (i < nums.length) {\n            currentSum += nums(i)\n      \
    \      if (currentSum < minSum) minSum = currentSum\n            if (currentSum\
    \ >= 0) currentSum = 0\n            i += 1\n        }\n        minSum", "    \
    \    // Fill this out\n        var min = nums(0)\n        for (i <- 0 until nums.length)\
    \ {\n            var sum = 0l\n            for (j <- i until nums.length) {\n\
    \                sum += nums(j)\n                if (sum < min) min = sum\n  \
    \          }\n        }\n        min", "        var min = nums(0)\n        val\
    \ prefix = ArrayBuffer.fill(nums.length)(0l)\n        prefix(0) = nums(0)\n  \
    \      for (i <- 1 until nums.length) {\n            prefix(i) = prefix(i - 1)\
    \ + nums(i)\n            min = min(prefix(i), nums(i))\n        }\n        min",
  "        var result : Long = nums(0)\n        val subarray = nums.view.scanLeft(0l)(_\
    \ + _)\n        for (i <- 0 until nums.length) {\n            val prefix = subarray(i)\n\
    \            for (j <- i + 1 until nums.length) {\n                val suffix\
    \ = subarray(j)\n                val sum = suffix - prefix\n                if\
    \ (sum < result) result = sum\n            }\n        }\n        return result",
  "        if (nums.length == 0) throw new Exception(\"nums is empty\")\n        var\
    \ minSum = nums(0)\n        var sum = 0l\n        for (n <- nums) {\n        \
    \    sum += n\n            if (sum < minSum) minSum = sum\n            if (sum\
    \ > 0) sum = 0\n        }\n        minSum", "        // Fill in the code\n   \
    \     return 0l", "        var minSum = nums(0)\n        var sum = 0\n       \
    \ for (num <- nums) {\n            sum += num\n            if (sum < minSum) minSum\
    \ = sum\n            if (sum > 0) sum = 0\n        }\n        minSum", "     \
    \   var s = 0L\n        var min = Long.MaxValue\n        for (n <- nums) {\n \
    \           s += n\n            if (s < min) min = s\n            if (s > 0) s\
    \ = 0\n        }\n        return min", "        val windowSum : Long = nums.sum\n\
    \        if (windowSum >= 0) 0\n        else {\n            var result : Long\
    \ = windowSum\n            var currentSum : Long = 0\n            for (num <-\
    \ nums) {\n                currentSum += num\n                if (currentSum <\
    \ result) result = currentSum\n                if (currentSum > 0) currentSum\
    \ = 0\n            }\n            result\n        }", "        // We use Kadane's\
    \ algorithm to solve this problem in O(n) time\n        // http://en.wikipedia.org/wiki/Maximum_subarray_problem\n\
    \        // The idea is that if we have a list xs, then for each index in the\
    \ list,\n        // we keep track of the maximum sum up to that index.\n     \
    \   // Then, we can look at the subarrays from i to j as xs(i, maxSum(i)) to xs(j,\
    \ maxSum(j))\n        // and we can compare those subarrays by looking at maxSum(j)\
    \ - maxSum(i)\n        var maxSum = new Array[Long](nums.length)\n        var\
    \ minSum = maxSum(0) = nums(0)\n        for (i <- 1 until nums.length) {\n   \
    \         maxSum(i) = max(nums(i), maxSum(i - 1) + nums(i))\n            minSum\
    \ = min(minSum, maxSum(i))\n        }\n        minSum", "        var min = nums(0)\n\
    \        var sum = 0l\n        for (i <- 0 until nums.length) {\n            sum\
    \ += nums(i)\n            if (sum < min) min = sum\n            if (sum > 0) sum\
    \ = 0\n        }\n        return min", "        def minSubArraySumRec(nums : List[Long],\
    \ sums : List[Long]) : Long = {\n            sums match {\n                case\
    \ head :: tail => nums match {\n                    case Nil => head\n       \
    \             case first :: second => {\n                        val sum = head\
    \ + first\n                        if (sum < 0) minSubArraySumRec(second, sums.tail)\n\
    \                        else minSubArraySumRec(second, sum :: sums.tail)\n  \
    \                  }\n                }\n                case Nil => {\n     \
    \               nums match {\n                        case head :: tail => minSubArraySumRec(tail,\
    \ head :: Nil)\n                        case Nil => 0\n                    }\n\
    \                }\n            }\n        }\n        minSubArraySumRec(nums,\
    \ Nil)", "      if (nums.isEmpty) return 0\n      var min = nums.head\n      var\
    \ curr = 0\n      for (a <- nums) {\n        curr += a\n        if (curr < min)\
    \ min = curr\n        if (curr > 0) curr = 0\n      }\n      return min", "  \
    \      // Fill up this function body\n        // You have to return the minimum\
    \ sum of any non-empty sub-list of nums\n        // Constraints:\n        // -1\
    \ <= len(nums) <= 10**5\n        // -10**9 <= nums[i] <= 10**9\n        // Example:\n\
    \        // >>> minSubArraySum((List[Long](2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong)))\n        // (1l)\n        // >>> minSubArraySum((List[Long](-1l.toLong,\
    \ -2l.toLong, -3l.toLong)))\n        // (-6l)\n        // Hint:\n        // -\
    \ Solve it in O(n) time and O(1) space\n        // - Solve it in O(n**2) time\
    \ and O(1) space\n        var min = (1l.toLong << 63) - 1l\n        var cur =\
    \ 0l\n        for (i <- 0 until nums.length) {\n            cur += nums(i)\n \
    \           if (cur < min) min = cur\n            if (cur > 0) cur = 0\n     \
    \   }\n        return min", "        // This problem is basically searching for\
    \ the minimum \"ending\" of sub-arrays\n        var subArraySum : Long = nums(0)\n\
    \        var minSubArraySum : Long = subArraySum\n        for (i <- 1 until nums.length)\
    \ {\n            subArraySum = min(subArraySum + nums(i), nums(i))\n         \
    \   minSubArraySum = min(minSubArraySum, subArraySum)\n        }\n        return\
    \ minSubArraySum", "        // Initialize\n        var maxSums = new Array[Long](nums.length\
    \ + 1)\n        var minSums = new Array[Long](nums.length + 1)\n        maxSums(0)\
    \ = 0\n        minSums(0) = 0\n        for (i <- 1 to nums.length) {\n       \
    \     maxSums(i) = max(nums(i - 1), maxSums(i - 1) + nums(i - 1))\n          \
    \  minSums(i) = min(nums(i - 1), minSums(i - 1) + nums(i - 1))\n        }\n  \
    \      // Compute\n        return minSums.max", "        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (i <- 0 until nums.length) {\n            sum\
    \ += nums(i)\n            minSum = min(minSum, sum)\n            if (sum < 0)\
    \ sum = 0\n        }\n        minSum", "        var min = nums(0)\n        var\
    \ cur = nums(0)\n        for (i <- 1 until nums.length) {\n            if (cur\
    \ > 0) cur = nums(i)\n            else cur += nums(i)\n            if (cur < min)\
    \ min = cur\n        }\n        return min", "        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        minSum", "        // @Note: This is the O(n) linear solution\
    \ from LeetCode.\n        var minSum = Long.MaxValue\n        var sum = 0\n  \
    \      for (i <- 0 until nums.length) {\n            sum += nums(i)\n        \
    \    minSum = min(minSum, sum)\n            sum = max(sum, 0)\n        }\n   \
    \     return minSum", "        if (nums.isEmpty) {\n            return 0\n   \
    \     }\n        var min = Long.MaxValue\n        var prefixSum = 0l\n       \
    \ val seen = HashMap[Long, Long]()\n        for (n <- nums) {\n            prefixSum\
    \ += n\n            if (seen.contains(prefixSum)) {\n                min = min.min(prefixSum\
    \ - seen(prefixSum))\n            }\n            else {\n                seen\
    \ += prefixSum -> prefixSum\n            }\n        }\n        min.min(nums.sum)",
  "        // Good luck!\n        val n = nums.length\n        val sum_array = new\
    \ Array[Long](n)\n        for (i <- 0 until n) {\n            if (i == 0) sum_array(i)\
    \ = nums(i)\n            else sum_array(i) = sum_array(i - 1) + nums(i)\n    \
    \    }\n        val min_range = new Array[Long](n)\n        for (i <- 0 until\
    \ n) {\n            if (i == 0) min_range(i) = sum_array(i)\n            else\
    \ {\n                val min_p = min_range(i - 1)\n                if (sum_array(i)\
    \ < min_p) min_range(i) = sum_array(i)\n                else min_range(i) = min_p\n\
    \            }\n        }\n        var result = Long.MaxValue\n        for (i\
    \ <- 0 until n) {\n            val temp = sum_array(i) - min_range(i)\n      \
    \      if (temp < result) result = temp\n        }\n        result", "       \
    \ // Fill this stuff in.\n        return -1", "        var minimum = nums.head\n\
    \        for (i <- 0 until nums.length) {\n            var sum = 0l\n        \
    \    for (j <- i until nums.length) {\n                sum += nums(j)\n      \
    \          if (sum < minimum) minimum = sum\n            }\n        }\n      \
    \  return minimum", "        // Fill up this function body\n        // 'nums'\
    \ is a list of integers\n        // Return the minimum sum of any non-empty sub-list\
    \ of 'nums'\n        var minimum = nums(0)\n        var previous = nums(0)\n \
    \       var current = nums(0)\n        for (i <- 1 until nums.length) {\n    \
    \        current = max(nums(i), current + nums(i))\n            minimum = min(minimum,\
    \ current)\n        }\n        minimum", "        if (nums.isEmpty) {\n      \
    \      return 0l.toLong\n        }\n        var _nums = nums\n        _nums =\
    \ _nums.sorted\n        var bestSum = _nums.head\n        var curSum = 0l.toLong\n\
    \        for (num <- _nums) {\n            curSum += num\n            if (curSum\
    \ < bestSum) {\n                bestSum = curSum\n            }\n        }\n \
    \       return bestSum", "        def solve(ans : Long, cur : Long, nums : List[Long])\
    \ : Long = {\n            if (nums.length == 0) ans\n            else if (cur\
    \ < 0) solve(min(ans, cur), nums.head, nums.tail)\n            else solve(ans,\
    \ cur + nums.head, nums.tail)\n        }\n        solve(nums.head, nums.head,\
    \ nums.tail)", "        var l = nums.length\n        var start = 0\n        var\
    \ end = 0\n        var min = Long.MaxValue\n        var max = Long.MinValue\n\
    \        var current = 0l\n        while(end < l) {\n            current += nums(end)\n\
    \            if(current < min) min = current\n            else if(current - min\
    \ > max) max = current - min\n            end += 1\n        }\n        max", " \
    \       // Time: O(n)\n        // Space: O(1)\n        var min : Long = nums(0)\n\
    \        var sum : Long = 0\n        for (i <- 0 until nums.length) {\n      \
    \      sum += nums(i)\n            if (sum < min) min = sum\n            if (sum\
    \ > 0) sum = 0\n        }\n        return min", "        // Type your solution\
    \ here\n        val s = nums.sum\n        var m = Long.MaxValue\n        for (i\
    \ <- 0 until nums.length) {\n            var ss = 0l\n            for (j <- i\
    \ until nums.length) {\n                ss += nums(j)\n                if (ss\
    \ < m) m = ss\n            }\n        }\n        m", "        // Time Complexity:\
    \ O(n)\n        // Space Complexity: O(1)\n        var minsofar = Long.MaxValue\n\
    \        var sumsofar = 0l\n        for (i <- 0 until nums.length) {\n       \
    \     sumsofar += nums(i)\n            minsofar = min(minsofar, sumsofar)\n  \
    \          if (sumsofar > 0) sumsofar = 0\n        }\n        minsofar", "   \
    \     var minSum = Long.MaxValue\n        var sum = 0l\n        for (num <- nums)\
    \ {\n            sum += num\n            if (sum < minSum) minSum = sum\n    \
    \        if (sum > 0) sum = 0\n        }\n        minSum", "        val n = nums.length\n\
    \        val dp = Array.fill(n)(0l)\n        dp(0) = nums(0)\n        for (i <-\
    \ 1 until n) {\n            dp(i) = min(dp(i - 1) + nums(i), nums(i))\n      \
    \  }\n        dp.min", "        // Fill up this function body\n        // Note:\
    \ You can add another function as well, if required\n        var min: Long = nums(0)\n\
    \        for (i <- 0 until nums.length) {\n            var j = i\n           \
    \ var sum: Long = 0\n            while (j < nums.length) {\n                sum\
    \ += nums(j)\n                if (sum < min) {\n                    min = sum\n\
    \                }\n                j += 1\n            }\n        }\n       \
    \ return min", "        var minSubArraySum : Long = nums.head\n        var minSubArraySumCurrent\
    \ : Long = nums.head\n        var index : Int = 1\n        while (index < nums.length)\
    \ {\n            minSubArraySumCurrent = min(minSubArraySumCurrent + nums(index),\
    \ nums(index))\n            minSubArraySum = min(minSubArraySum, minSubArraySumCurrent)\n\
    \            index += 1\n        }\n        return minSubArraySum", "        //\
    \ Fill in the missing code\n        var minSum = Long.MaxValue\n        var sum\
    \ = 0L\n        for (num <- nums) {\n            sum += num\n            if (sum\
    \ < minSum) minSum = sum\n            if (sum > 0) sum = 0\n        }\n      \
    \  minSum", "        // Good luck!\n        nums.min", "        // Implement this\
    \ placeholder.\n        return 0", "        // if the list contains only non-positive\
    \ numbers, the result will be the sum of the list\n        // for each sub-list,\
    \ compute the sum and try to keep the smallest one;\n        // assume nums.size()\
    \ > 0\n        val min = nums.sum\n        for (i <- 0 until nums.size) {\n  \
    \          var sum = 0\n            for (j <- i until nums.size) {\n         \
    \       sum += nums(j)\n                if (sum < min) min = sum\n           \
    \ }\n        }\n        min", '        nums.reduceLeft((x, y) => if (x < y) x
    else y)', "        // Have two options:\n        // 1) Add new number to all existing\
    \ sub-arrays\n        // 2) Start a new sub-array\n        // To make the calculation\
    \ simpler, always treat the new sub-array with\n        // the maximum negative\
    \ sum seen so far as the upper bound for the new sub-array\n        // for calculation.\
    \ It will never cause the sum to be greater than zero.\n        var minSum : Long\
    \ = nums(0)\n        var prev : Long = nums(0)\n        var maxNegativeSum : Long\
    \ = nums(0)\n        for (num <- nums.tail) {\n            var newMinSum = min(minSum\
    \ + num, maxNegativeSum + num)\n            var newPrev = max(prev + num, num)\n\
    \            var newMaxNegativeSum = min(maxNegativeSum, prev + num)\n       \
    \     minSum = newMinSum\n            prev = newPrev\n            maxNegativeSum\
    \ = newMaxNegativeSum\n        }\n        minSum", "        var minV = nums(0)\n\
    \        var sum = 0l\n        for (n <- nums) {\n            sum += n\n     \
    \       if (sum < minV) minV = sum\n            if (sum > 0) sum = 0\n       \
    \ }\n        minV", "        // We will use a deque to store indices of nums.\
    \ The deque is used to ensure the\n        // sum is the minimum possible.\n \
    \       // If the head of the deque is negative, we remove it because its presence\n\
    \        // increases the sum of the subarray. We keep doing this until the head\
    \ is\n        // positive or the deque is empty.\n        // When we update the\
    \ minimum sum, we remove elements from the end of the deque\n        // until\
    \ the tail is at most the minimum sum minus the sum of the deque. This\n     \
    \   // is because the sum of the deque is smaller than the minimum sum, and the\n\
    \        // tail is greater than the minimum sum minus the sum of the deque, so\
    \ the\n        // tail cannot be part of any minimum subarray.\n        // We\
    \ keep doing this until we have added every element of nums to the deque.\n  \
    \      var deque = new ArrayDeque[Int]()\n        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (n <- nums.indices) {\n            deque.addLast(n)\n\
    \            sum += nums(n)\n            while (deque.nonEmpty && nums(deque.peekFirst())\
    \ < 0) {\n                val head = deque.removeFirst()\n                sum\
    \ -= nums(head)\n            }\n            if (sum < minSum) {\n            \
    \    minSum = sum\n                while (deque.nonEmpty && nums(deque.peekLast())\
    \ > minSum - sum) {\n                    val tail = deque.removeLast()\n     \
    \               sum -= nums(tail)\n                }\n            }\n        }\n\
    \        return minSum", "        // Precompute running sums.\n        var sum\
    \ : Long = 0\n        var minimum : Long = Long.MaxValue\n        val runningSum\
    \ = nums.map(x => {\n            sum += x\n            sum\n        })\n     \
    \   // Nested loops: find all sub-arrays.\n        for (i <- 0 until nums.length)\
    \ {\n            for (j <- i + 1 until nums.length) {\n                val subArraySum\
    \ = runningSum(j) - runningSum(i) + nums(i)\n                if (subArraySum <\
    \ minimum) minimum = subArraySum\n            }\n        }\n        return minimum",
  "        var min = nums(0)\n        var sum = 0l\n        for (num <- nums) {\n\
    \            sum += num\n            if (sum < min) min = sum\n            if\
    \ (sum > 0) sum = 0\n        }\n        return min", "        // Your code goes\
    \ here\n        return 0", "        var minSum = Long.MaxValue\n        var start\
    \ = 0\n        var end = 0\n        var sum = 0l\n        while (end < nums.length)\
    \ {\n            sum += nums(end)\n            if (sum > 0) {\n              \
    \  start = end + 1\n                sum = 0\n            } else {\n          \
    \      if (sum < minSum) minSum = sum\n            }\n            end += 1\n \
    \       }\n        if (minSum == Long.MaxValue) minSum = 0\n        return minSum",
  "        var subSum = 0l\n        var minSubSum = 0l\n        var first = true\n\
    \        for (num <- nums) {\n            subSum += num\n            if (first)\
    \ {\n                minSubSum = subSum\n                first = false\n     \
    \       } else if (subSum < minSubSum) {\n                minSubSum = subSum\n\
    \            }\n            if (subSum > 0) {\n                subSum = 0\n  \
    \          }\n        }\n        return minSubSum", "        if (nums.length ==\
    \ 0) return 0l\n        var n = nums.length\n        var min_so_far = (1l << 60)\n\
    \        var min_ending_here = 0l\n        var i = 0\n        while (i < n) {\n\
    \            min_ending_here = min(min_ending_here + nums(i), nums(i))\n     \
    \       min_so_far = min(min_so_far, min_ending_here)\n            i += 1\n  \
    \      }\n        return min_so_far", "        // We are to find the minimum contiguous\
    \ sum so we can do this using a prefix sum array.\n        // We construct a prefix\
    \ sum array (0, nums(0), nums(0) + nums(1), ...) and store the sums\n        //\
    \ in a queue. We then traverse the array backwards and take the minimum sum as\
    \ we go.\n        val prefixSums = new Queue[Long]\n        var sum = 0l\n   \
    \     nums.foreach(num => {\n            sum += num\n            prefixSums.enqueue(sum)\n\
    \        })\n        var currentMin = prefixSums.dequeue\n        while (!prefixSums.isEmpty)\
    \ {\n            val currentSum = prefixSums.dequeue\n            if (currentSum\
    \ < currentMin) currentMin = currentSum\n        }\n        return currentMin",
  "        var minSum = Long.MaxValue\n        for (i <- 0 until nums.length) {\n\
    \            var sum = 0l\n            for (j <- i until nums.length) {\n    \
    \            sum += nums(j)\n                if (sum < minSum) minSum = sum\n\
    \            }\n        }\n        minSum", "        var min = nums(0)\n     \
    \   var cur = nums(0)\n        for (i <- 1 until nums.length) {\n            if\
    \ (cur < 0) cur = 0\n            cur += nums(i)\n            min = min min cur\n\
    \        }\n        min", "        // Fill in the code for the above here\n  \
    \      val min = (x : List[Long]) => x.foldLeft(x.head)((a,b) => min(a,b))\n \
    \       val max = (x : List[Long]) => x.foldLeft(x.head)((a,b) => max(a,b))\n\
    \        val sum = (x : List[Long]) => x.foldLeft(0l)((a,b) => a + b)\n      \
    \  val product = (x : List[Long]) => x.foldLeft(1l)((a,b) => a * b)\n        def\
    \ getSubArrays(array : List[Long]) : List[List[Long]] = {\n            val n =\
    \ array.length\n            def helper(k : Int) : List[List[Long]] = {\n     \
    \           if (k == n) {\n                    Nil\n                } else {\n\
    \                    for {\n                        i <- (k until n).toList\n\
    \                        subarray <- (k to i).toList :: helper(i + 1)\n      \
    \              } yield subarray\n                }\n            }\n          \
    \  helper(0)\n        }\n        val lst = getSubArrays(nums)\n        var res\
    \ = sum(nums)\n        for (i <- lst) {\n            val x = sum(i)\n        \
    \    if (x < res) res = x\n        }\n        res", "        var minimum : Long\
    \ = nums.sum\n        for (i <- 0 until nums.length) {\n            var sum :\
    \ Long = 0\n            for (j <- i until nums.length) {\n                sum\
    \ += nums(j)\n                if (sum < minimum) minimum = sum\n            }\n\
    \        }\n        return minimum", "        val result = nums.filter(_ >= 0).foldLeft(Long.MaxValue)((res,\
    \ cur) => {\n            if (res < cur) res else cur\n        })\n        val\
    \ x = nums.foldLeft(0l)((res, cur) => {\n            res + cur\n        })\n \
    \       if (x < 0) return x\n        return result", "        // Sum of all elements\
    \ in the sub-array\n        var sum = 0l\n        // Minimum sum of any sub-array\n\
    \        var minSum = Long.MaxValue\n        // Iterate through each element of\
    \ the array\n        for (i <- 0 until nums.length) {\n            // If the sum\
    \ is negative, start the next sub-array with the current element\n           \
    \ if (sum < 0) {\n                sum = nums(i)\n            }\n            //\
    \ Otherwise, the sub-array continues\n            else {\n                sum\
    \ += nums(i)\n            }\n            // Update the minimum sum\n         \
    \   minSum = min(minSum, sum)\n        }\n        // Return the minimum sum\n\
    \        minSum", "      def helper(nums : List[Long], min : Long, sum : Long)\
    \ : Long = {\n        if (nums.isEmpty) min\n        else {\n          val nextSum\
    \ = sum + nums.head\n          val nextMin = min min nextSum\n          helper(nums.tail,\
    \ nextMin, nextSum)\n        }\n      }\n      helper(nums, 0l, 0l)", "      \
    \  // Since sub-list is contiguous, we will use sliding window method\n      \
    \  // We will compare the sum of the window to the minSum variable\n        var\
    \ minSum = nums(0)\n        var sum = 0l\n        var left = 0\n        var right\
    \ = 0\n        while (right < nums.length) {\n            sum += nums(right)\n\
    \            while (sum >= 0) {\n                minSum = min(minSum, sum)\n \
    \               sum -= nums(left)\n                left += 1\n            }\n\
    \            right += 1\n        }\n        minSum", "        var minSum = 0l\n\
    \        var currentSum = 0l\n        for (i <- 0 until nums.length) {\n     \
    \       currentSum += nums(i)\n            if (currentSum > 0) currentSum = 0\n\
    \            if (currentSum < minSum) minSum = currentSum\n        }\n       \
    \ return -minSum", "        // Fill this up\n        var min = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           if (sum < min) min = sum\n            if (sum > 0) sum = 0\n     \
    \   }\n        min", "        /**\n         * The idea here is to create a cumulative\
    \ sum for the list and then for each\n         * number in the list iterate over\
    \ the cumulative sums to see if a sub-list sums\n         * to a value smaller\
    \ than any other sub-list we've found. The first value of the\n         * cumulative\
    \ sum array is zero.\n         */\n        val cumSum = (0l.toLong +: nums.scanLeft(0l.toLong)(_\
    \ + _)).toArray\n        var min = 1e10.toLong\n        val n = nums.length\n\
    \        for (i <- 0 until n) {\n            for (j <- i until n) {\n        \
    \        val subListSum = cumSum(j + 1) - cumSum(i)\n                if (subListSum\
    \ < min) {\n                    min = subListSum\n                }\n        \
    \    }\n        }\n        min", "      // Fill in the code. You can use the helper\
    \ functions.\n      return -1l", "        var sum : Long = 0\n        var result\
    \ : Long = Long.MaxValue\n        for (num <- nums) {\n            sum += num\n\
    \            result = min(result, sum)\n            if (sum < 0) sum = 0\n   \
    \     }\n        return result", "        // Define the recursive function.\n\
    \        def helper(list : List[Long], acc : Long, currMin : Long) : Long = {\n\
    \            // If the list is empty, return the current minimum.\n          \
    \  if (list.isEmpty) currMin\n            // Otherwise, get the next value.\n\
    \            else {\n                val nextValue = list.head\n             \
    \   // Get the candidate minimum.\n                val candidateMin = min(currMin,\
    \ acc + nextValue)\n                // Recurse.\n                helper(list.tail,\
    \ max(0, acc + nextValue), candidateMin)\n            }\n        }\n        //\
    \ Initialize values.\n        val firstNum = nums.head\n        // Call the recursive\
    \ function.\n        helper(nums.tail, firstNum, firstNum)", "        // Usual\
    \ brute force approach is to iterate through all sub-lists and calculate\n   \
    \     // sum of each sub-list and return minimum from that set.\n        // This\
    \ approach takes time O(N^2) and space O(1).\n        // We can improve by noticing\
    \ that the minimum sum of a sub-list is\n        // either the minimum of the\
    \ previous sub-list or the current sub-list.\n        // This takes time O(N)\
    \ and space O(1).\n        if (nums.isEmpty) 0l\n        else {\n            var\
    \ minSum = nums.head\n            var currentSum = nums.head\n            for\
    \ (num <- nums.tail) {\n                currentSum = min(currentSum + num, num)\n\
    \                minSum = min(minSum, currentSum)\n            }\n           \
    \ minSum\n        }", "        // Fill this\n        0l"]
stop_tokens:
- "\n    }\n"
