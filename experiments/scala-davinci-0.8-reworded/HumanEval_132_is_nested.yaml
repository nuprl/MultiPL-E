name: HumanEval_132_is_nested
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that takes a string as input which contains only square\
  \ brackets.\n    // The function should return true if and only if there is a valid\
  \ subsequence of brackets \n    // where at least one bracket in the subsequence\
  \ is nested.\n    // >>> isNested((\"[[]]\"))\n    // (true)\n    // >>> isNested((\"\
  []]]]]]][[[[[]\"))\n    // (false)\n    // >>> isNested((\"[][]\"))\n    // (false)\n\
  \    // >>> isNested((\"[]\"))\n    // (false)\n    // >>> isNested((\"[[][]]\"\
  ))\n    // (true)\n    // >>> isNested((\"[[]][[\"))\n    // (true)\n    def isNested(string\
  \ : String) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(isNested((\"[[]]\"\
  )) == (true));\n    assert(isNested((\"[]]]]]]][[[[[]\")) == (false));\n    assert(isNested((\"\
  [][]\")) == (false));\n    assert(isNested((\"[]\")) == (false));\n    assert(isNested((\"\
  [[[[]]]]\")) == (true));\n    assert(isNested((\"[]]]]]]]]]]\")) == (false));\n\
  \    assert(isNested((\"[][][[]]\")) == (true));\n    assert(isNested((\"[[]\"))\
  \ == (false));\n    assert(isNested((\"[]]\")) == (false));\n    assert(isNested((\"\
  [[]][[\")) == (true));\n    assert(isNested((\"[[][]]\")) == (true));\n    assert(isNested((\"\
  \")) == (false));\n    assert(isNested((\"[[[[[[[[\")) == (false));\n    assert(isNested((\"\
  ]]]]]]]]\")) == (false));\n    }\n\n}\n"
completions: ["        if (string.length == 0) return false\n        val check = Array.fill(string.length)(0)\n\
    \        string.toList.zipWithIndex.foreach(x => if (x._1 == '[') check(x._2)\
    \ = 1 else check(x._2) = -1)\n        var sum = 0\n        for (i <- 0 until check.length)\
    \ {\n            sum += check(i)\n            if (sum < 0) return false\n    \
    \    }\n        return true", "        var stack = new Stack[Char]\n        for\
    \ (index <- 0 until string.length()) {\n            if (string(index) == '[')\
    \ {\n                stack.push('[')\n            } else {\n                if\
    \ (stack.length == 0) {\n                    return false\n                } else\
    \ {\n                    stack.pop()\n                }\n            }\n     \
    \   }\n        if (stack.length > 0) {\n            return false\n        }\n\
    \        return true", "        // Stack to keep track of opening brackets\n \
    \       var stack = new Stack[Char]()\n        // Iterate through each character\
    \ of the string\n        for (char <- string) {\n            // If the character\
    \ is an opening bracket, add it to the stack\n            if (char == '[') {\n\
    \                stack.push(char)\n            }\n            // If the character\
    \ is a closing bracket\n            else if (char == ']') {\n                //\
    \ If the stack is empty, there is no way to balance\n                if (stack.isEmpty)\
    \ {\n                    return false\n                }\n                // If\
    \ the last character was an opening bracket, pop it off\n                if (stack.top\
    \ == '[') {\n                    stack.pop\n                }\n              \
    \  // If the last character was a closing bracket, we have an unbalanced bracket\n\
    \                else {\n                    return false\n                }\n\
    \            }\n        }\n        // If there are no opening brackets left in\
    \ the stack, we were able to balance\n        if (stack.isEmpty) {\n         \
    \   return true\n        }\n        // If there are opening brackets left in the\
    \ stack, we were unable to balance\n        else {\n            return false\n\
    \        }", "        // Create a stack\n        var stack = new Stack[Char]\n\
    \        // Create a boolean called 'isNested'\n        var isNested = false\n\
    \        // For every character in the input string\n        for (character <-\
    \ string) {\n            // If the character is an opening bracket\n         \
    \   if (character == '[') {\n                // Push the character to the stack\n\
    \                stack.push(character)\n            }\n            // Else\n \
    \           else {\n                // Pop the last character from the stack\n\
    \                val poppedCharacter = stack.pop\n                // If the popped\
    \ character is an opening bracket\n                if (poppedCharacter == '[')\
    \ {\n                    // Set isNested to true\n                    isNested\
    \ = true\n                }\n            }\n        }\n        // Return isNested\n\
    \        isNested", "        var stringArray = string.toCharArray()\n        var\
    \ bracketStack = new Stack[Char]()\n        for (bracket <- stringArray) {\n \
    \           if (bracket == '[') bracketStack.push(bracket)\n            else if\
    \ (bracket == ']') {\n                if (bracketStack.isEmpty || bracketStack.pop()\
    \ != '[') return false\n            }\n        }\n        return bracketStack.isEmpty",
  "        val s = string.toList\n        if (s.isEmpty) return false\n        var\
    \ count = 0\n        var indexes = new HashSet[Int]\n        for (index <- 0 until\
    \ s.length) {\n            if (s(index) == '[') count += 1\n            else if\
    \ (s(index) == ']') count -= 1\n            if (count < 0) return false\n    \
    \        if (count > 0) indexes += index\n        }\n        return indexes.size\
    \ > 0", "        var open = 0\n        for (i <- 0 until string.length()) {\n\
    \            if (string(i) == '[') {\n                open += 1\n            }\
    \ else {\n                if (open > 0) {\n                    open -= 1\n   \
    \             } else {\n                    return false\n                }\n\
    \            }\n        }\n        return open == 0", "    \tvar stack = new Stack[Char]()\n\
    \    \tvar result = false\n    \tfor (i <- 0 until string.length) {\n    \t\t\
    if (string(i) == '[') {\n    \t\t\tstack.push(string(i))\n    \t\t} else {\n \
    \   \t\t\tif (stack.isEmpty) {\n    \t\t\t\tresult = false\n    \t\t\t} else {\n\
    \    \t\t\t\tstack.pop()\n    \t\t\t\tresult = true\n    \t\t\t}\n    \t\t}\n\
    \    \t}\n    \treturn result", "        var tempStack = new Stack[Char]()\n \
    \       string.foreach(x => {\n            if (x == '[') {\n                tempStack.push(x)\n\
    \            } else {\n                if (tempStack.isEmpty) {\n            \
    \        return false\n                } else {\n                    tempStack.pop()\n\
    \                }\n            }\n        })\n        return tempStack.size ==\
    \ 0", "        val chars = string.toCharArray\n        val stack = new Stack[Char]\n\
    \        for (c <- chars) {\n            if (c == '[') stack.push(c)\n       \
    \     else if (c == ']') {\n                if (stack.isEmpty) return false\n\
    \                stack.pop\n            }\n        }\n        !stack.isEmpty",
  "        var openBrackets = 0\n        var closedBrackets = 0\n        var isNested\
    \ = false\n        for (c <- string) {\n            if (c == '[') openBrackets\
    \ += 1\n            else if (c == ']') closedBrackets += 1\n            if (closedBrackets\
    \ > openBrackets) return false\n            if (closedBrackets > 0 && closedBrackets\
    \ == openBrackets) isNested = true\n        }\n        return isNested", "   \
    \     if (string.isEmpty) return false\n        var count = 0\n        var found\
    \ = false\n        for (ch <- string) {\n            if (ch == '[') count += 1\n\
    \            else count -= 1\n            if (count < 0) return false\n      \
    \      if (count > 0) found = true\n        }\n        found", "        if (string.length\
    \ == 0) return false\n        // Approach: pop the first square bracket we see\
    \ into a stack (stratify)\n        // and then pop and check the next square bracket\
    \ we see (while loop)\n        // >>> [][]\n        // Stack: [\n        // >>>\
    \ [][]\n        // Stack: []\n        // >>> [][]\n        // Stack: []\n    \
    \    // Note that the second square bracket we see is not the same square bracket\n\
    \        // >>> [][]\n        // Stack: []\n        // >>> [][]\n        // Stack:\
    \ [\n        // Note that the second square bracket we see is not the same square\
    \ bracket\n        // We return true if we ever manage to stratify the whole sequence,\
    \ and false otherwise\n        var stack = new Stack[Char]\n        string.foreach(x\
    \ => x match {\n            case '[' => stack.push(x)\n            case ']' =>\
    \ if (stack.isEmpty || stack.pop() != '[') return false\n        })\n        return\
    \ stack.isEmpty", "        var st = List.empty[Char]\n        for (c <- string)\
    \ {\n            if (c == '[') st = c :: st\n            else {\n            \
    \    if (st.nonEmpty && st.head == '[') st = st.tail\n                else return\
    \ false\n            }\n        }\n        true", '        return false', "  \
    \      val stack = new Stack[Char]\n        for (s <- string) {\n            if\
    \ (s == '[') {\n                stack.push(s)\n            } else {\n        \
    \        if (stack.isEmpty) return false\n                stack.pop\n        \
    \    }\n        }\n        true", "        val table = new HashMap[Int, Int]\n\
    \        for (i <- 0 until string.length) {\n            if (string(i) == '[')\
    \ {\n                table(i) = table.getOrElse(i - 1, 0) + 1\n            } else\
    \ {\n                table(i) = table.getOrElse(i - 1, 0) - 1\n            }\n\
    \        }\n        if (table.values.sum != 0) {\n            return false\n \
    \       }\n        val positive = table.values.filter(_ > 0)\n        val negative\
    \ = table.values.filter(_ < 0)\n        if (positive.isEmpty || negative.isEmpty)\
    \ {\n            return false\n        }\n        if (positive.min < negative.max)\
    \ {\n            return true\n        }\n        return false", "        def isNested(string\
    \ : String, stack : Stack[Char]) : Boolean = {\n            if (string.length\
    \ == 0) return false\n            if (string.length == 1) return false\n     \
    \       if (string.head == ']' && stack.isEmpty) return false\n            if\
    \ (string.head == '[' && string.last == ']') return true\n            if (string.head\
    \ == '[') {\n                stack.push(string.head)\n                return isNested(string.tail,\
    \ stack)\n            }\n            if (string.head == ']') {\n             \
    \   stack.pop\n                return isNested(string.tail, stack)\n         \
    \   }\n            return isNested(string.tail, stack)\n        }\n        isNested(string,\
    \ Stack[Char]())", "        var (left, right) = (0, 0)\n        for (i <- 0 until\
    \ string.length) {\n            if (string(i) == '[') left += 1\n            else\
    \ if (string(i) == ']') right += 1\n            if (right > left) return false\n\
    \        }\n        left == right", "        var stack = new Stack[Char]\n   \
    \     for (ch <- string) {\n            if (ch == '[') {\n                stack.push(ch)\n\
    \            } else {\n                if (stack.isEmpty) {\n                \
    \    return false\n                } else {\n                    stack.pop\n \
    \               }\n            }\n        }\n        if (stack.isEmpty) {\n  \
    \          true\n        } else {\n            false\n        }", "        val\
    \ stack = Stack[Char]()\n        for (char <- string) {\n            if (char\
    \ == '[') stack.push(char)\n            else if (char == ']') if (stack.isEmpty)\
    \ return false else stack.pop\n        }\n        if (stack.isEmpty) return false\n\
    \        true", "        var leftBrackets : Stack[Char] = new Stack[Char]()\n\
    \        var isNested : Boolean = false\n        for (i <- 0 until string.length)\
    \ {\n            if (string(i) == '[') {\n                leftBrackets.push(string(i))\n\
    \            } else {\n                if (leftBrackets.isEmpty) {\n         \
    \           return false\n                } else {\n                    leftBrackets.pop()\n\
    \                    if (leftBrackets.isEmpty) {\n                        isNested\
    \ = true\n                    }\n                }\n            }\n        }\n\
    \        if (leftBrackets.isEmpty) {\n            return isNested\n        } else\
    \ {\n            return false\n        }", "        var result = false\n     \
    \   var rest = string\n        var last = ' '\n        var current = ' '\n   \
    \     while (rest.length != 0) {\n            last = current\n            current\
    \ = rest.charAt(0)\n            rest = rest.substring(1)\n            if (current\
    \ == ']' && last == '[') {\n                result = true\n            }\n   \
    \     }\n        return result", "        def char_case(a : Char) : Char = {\n\
    \            if (a == '[') '('\n            else ')'\n        }\n        def helper(string\
    \ : String, stack : Stack[Char]) : Boolean = {\n            if (string.isEmpty)\
    \ {\n                if (stack.isEmpty) true\n                else false\n   \
    \         }\n            else {\n                if (stack.isEmpty) {\n      \
    \              if (string.head == '[') {\n                        stack.push(char_case(string.head))\n\
    \                        helper(string.tail, stack)\n                    }\n \
    \                   else {\n                        false\n                  \
    \  }\n                }\n                else {\n                    if (string.head\
    \ == '[') {\n                        stack.push(char_case(string.head))\n    \
    \                    helper(string.tail, stack)\n                    }\n     \
    \               else {\n                        if (stack.top == string.head)\
    \ {\n                            stack.pop\n                            helper(string.tail,\
    \ stack)\n                        }\n                        else {\n        \
    \                    false\n                        }\n                    }\n\
    \                }\n            }\n        }\n        helper(string, Stack())",
  "        val stack = new Stack[Char]\n        for (c <- string) {\n            if\
    \ (c == '[') {\n                stack.push(c)\n            } else {\n        \
    \        if (stack.isEmpty) return false\n                else stack.pop\n   \
    \         }\n        }\n        return !stack.isEmpty", "    \tdef rec(str : String,\
    \ idx : Int, stack : Stack[Char]) : Boolean = {\n    \t\tif (idx >= str.length)\
    \ return stack.isEmpty\n    \t\tif (str(idx) == '[') stack.push('[')\n    \t\t\
    else {\n    \t\t\tif (stack.isEmpty) return false\n    \t\t\tstack.pop\n    \t\
    \t}\n    \t\trec(str, idx + 1, stack)\n    \t}\n    \trec(string, 0, new Stack)",
  "        // stores an integer that represents the number of open brackets\n    \
    \    var bracketCount = 0\n        // stores an integer that represents the minimum\
    \ number of open brackets\n        var minBracketCount = 0\n        // stores\
    \ the length of the string\n        val length = string.length\n        // loop\
    \ through each character of the string\n        for (i <- 0 until length) {\n\
    \            // get a character\n            val ch = string(i)\n            //\
    \ if the character is an open bracket\n            if (ch == '[') {\n        \
    \        // increment the number of open brackets\n                bracketCount\
    \ += 1\n                // if the number of open brackets is greater than the\
    \ minimum number of open brackets\n                if (bracketCount > minBracketCount)\
    \ {\n                    // set the minimum number of open brackets\n        \
    \            minBracketCount = bracketCount\n                }\n            }\n\
    \            // if the character is a closed bracket\n            else if (ch\
    \ == ']') {\n                // decrement the number of open brackets\n      \
    \          bracketCount -= 1\n            }\n        }\n        // at least one\
    \ bracket is nested if the number of open brackets is non-zero\n        bracketCount\
    \ != 0", "        var stack = new Stack[Char]()\n        for (ch <- string) {\n\
    \            if (ch == '[') {\n                stack.push(ch)\n            } else\
    \ {\n                if (stack.isEmpty) {\n                    return false\n\
    \                } else {\n                    stack.pop()\n                }\n\
    \            }\n        }\n        if (stack.isEmpty) {\n            return true\n\
    \        } else {\n            return false\n        }", "        // String is\
    \ nested if the string is reduced to an empty string.\n        // String is reduced\
    \ by matching pairs of opening and closing brackets.\n        def isNestedHelper(string\
    \ : String) : Boolean = {\n            if (string.length() == 0) return true\n\
    \            else {\n                var leftBracketIndex = string.indexOf('[')\n\
    \                if (leftBracketIndex == -1) return false\n                var\
    \ rightBracketIndex = string.indexOf(']')\n                if (rightBracketIndex\
    \ == -1) return false\n                if (rightBracketIndex < leftBracketIndex)\
    \ return false\n                isNestedHelper(string.substring(0, leftBracketIndex)\
    \ + string.substring(rightBracketIndex + 1))\n            }\n        }\n     \
    \   // String is nested if the string is reduced to an empty string.\n       \
    \ // String is reduced by matching pairs of opening and closing brackets.\n  \
    \      def isNestedHelper(string : String) : Boolean = {\n            if (string.length()\
    \ == 0) return true\n            else {\n                val splitString = string.split(\"\
    \\\\]\")\n                if (splitString.length == 1) return false\n        \
    \        for (i <- 0 until splitString.length) {\n                    val splitString2\
    \ = splitString(i).split(\"\\\\[\")\n                    if (splitString2.length\
    \ == 1) return false\n                    if (splitString2.length > 1) {\n   \
    \                     var splitString3 = \"\"\n                        for (j\
    \ <- 1 until splitString2.length) {\n                            splitString3\
    \ += splitString2(j)\n                        }\n                        return\
    \ isNestedHelper(splitString3)\n                    }\n                }\n   \
    \             return false\n            }\n        }\n        isNestedHelper(string)",
  "        // Trie\n        // Create a class for the Trie node that contains a map\
    \ that has a \n        // String (the character) as a key and a Trie node as the\
    \ value. \n        // Also have a boolean endOfWord variable which indicates whether\
    \ \n        // that node is the end of a word.\n        class TrieNode(\n    \
    \        val children : mutable.Map[String, TrieNode] = mutable.Map(),\n     \
    \       var endOfWord : Boolean = false\n        )\n        // Create an empty\
    \ root node.\n        val root = new TrieNode()\n        // Create a function\
    \ that adds a word to the trie.\n        def addWord(word : String) : Unit = {\n\
    \            // Initialize a node to use as a tracker.\n            var node =\
    \ root\n            // Iterate through the characters of the word and add them\
    \ to the trie,\n            // and if the character is the last one, set that\
    \ node's endOfWord to true.\n            for (c <- word) {\n                node.children.get(c.toString)\
    \ match {\n                    case Some(n) => node = n\n                    case\
    \ None => {\n                        val newNode = new TrieNode()\n          \
    \              node.children += (c.toString -> newNode)\n                    \
    \    node = newNode\n                    }\n                }\n            }\n\
    \            node.endOfWord = true\n        }\n        // Add words to the trie.\n\
    \        addWord(\"[[]]\")\n        addWord(\"[]]]]]]][[[[[]\")\n        addWord(\"\
    [][]\")\n        addWord(\"[]\")\n        addWord(\"[[][]]\")\n        addWord(\"\
    [[]][[\")\n        // Initialize a node to use as a tracker.\n        var node\
    \ = root\n        // Iterate through the string and look for nodes in the trie\
    \ and when one is not found,\n        // return false. If the end of the string\
    \ is reached and the endOfWord is true, return true.\n        for (c <- string)\
    \ {\n            node.children.get(c.toString) match {\n                case Some(n)\
    \ => node = n\n                case None => return false\n            }\n    \
    \    }\n        return node.endOfWord", "        string.map(_ match {\n      \
    \      case '[' => 1\n            case ']' => -1\n        }).scanLeft(0)(_ + _).max\
    \ > 0", "    \tvar stack = new Stack[Char]\n    \tfor (x <- string.toCharArray)\
    \ {\n    \t\tif (x == '[') stack.push(x)\n    \t\telse if (x == ']') {\n    \t\
    \t\tif (stack.isEmpty) return false\n    \t\t\telse stack.pop\n    \t\t}\n   \
    \ \t}\n    \tif (stack.isEmpty) return false\n    \telse return true", "     \
    \   var numberOfOpenBrackets = 0\n        var numberOfCloseBrackets = 0\n    \
    \    var isThereANestedBracket = false\n        for (i <- 0 until string.length)\
    \ {\n            if (string(i) == '[') {\n                numberOfOpenBrackets\
    \ += 1\n            } else {\n                numberOfCloseBrackets += 1\n   \
    \         }\n            if (numberOfOpenBrackets < numberOfCloseBrackets) {\n\
    \                return false\n            }\n            if (numberOfOpenBrackets\
    \ > numberOfCloseBrackets) {\n                isThereANestedBracket = true\n \
    \           }\n        }\n        if (numberOfOpenBrackets != numberOfCloseBrackets)\
    \ {\n            return false\n        }\n        return isThereANestedBracket",
  "        if (string.isEmpty()) return false\n        var depth = 0\n        var\
    \ foundNested = false\n        for (c <- string) {\n            if (c == '[')\
    \ depth += 1\n            else if (c == ']') depth -= 1\n            if (depth\
    \ < 0) return false\n            if (depth == 1) foundNested = true\n        }\n\
    \        return depth == 0 && foundNested", "        if(string.length == 0) return\
    \ false\n        var stack = Stack[Char]()\n        for(c <- string) {\n     \
    \       if(c == '[') stack.push(c)\n            else if(c == ']') {\n        \
    \        if(stack.isEmpty) return false\n                else stack.pop\n    \
    \        }\n        }\n        if(stack.isEmpty) true else false", "        var\
    \ stack = new Stack[Char]\n        val toList = string.toList\n        var i =\
    \ 0\n        while (i < toList.length) {\n            if (toList(i) == '[') stack.push(toList(i))\n\
    \            else if (toList(i) == ']') {\n                if (stack.isEmpty)\
    \ return false\n                else stack.pop\n            }\n            i +=\
    \ 1\n        }\n        if (stack.isEmpty) return false\n        else return true",
  "        for (i <- 0 until string.length if string(i) == '[') \n            for\
    \ (j <- (i + 1) until string.length if string(j) == ']') \n                return\
    \ true\n        return false", "        val stack = Stack[Char]()\n        for\
    \ (c <- string) {\n            if (c == '[') stack.push(c)\n            else if\
    \ (c == ']') {\n                if (stack.isEmpty) return false\n            \
    \    else stack.pop\n            }\n        }\n        if (stack.isEmpty) return\
    \ false\n        return true", "        def f(s : String, b : Boolean) : Boolean\
    \ = {\n            if (s.isEmpty) b\n            else if (s.head == '[') f(s.tail,\
    \ true)\n            else if (s.head == ']') b\n            else f(s.tail, b)\n\
    \        }\n        f(string, false)", "        var stack = new Stack[Char]()\n\
    \        for (c <- string) {\n            if (c == '[') {\n                stack.push(c)\n\
    \            } else if (c == ']') {\n                if (stack.size > 0) {\n \
    \                   stack.pop()\n                } else {\n                  \
    \  return false\n                }\n            }\n        }\n        return stack.size\
    \ > 0", "        // Write your code here\n        var stack = new Stack[Char]\n\
    \        string.foreach(c => {\n            if (c == '[') stack.push(c)\n    \
    \        else {\n                if (stack.isEmpty) return false\n           \
    \     else if (stack.pop != '[') return false\n            }\n        })\n   \
    \     return stack.isEmpty", "        val square = List('[', ']')\n        val\
    \ squareStack = new Stack[Char]\n        var isNested = false\n        for (c\
    \ <- string) {\n            if (square.contains(c)) {\n                if (c ==\
    \ '[') {\n                    squareStack.push(c)\n                } else {\n\
    \                    if (squareStack.isEmpty) {\n                        return\
    \ false\n                    } else {\n                        squareStack.pop\n\
    \                        isNested = true\n                    }\n            \
    \    }\n            }\n        }\n        if (squareStack.isEmpty) {\n       \
    \     return isNested\n        } else {\n            return false\n        }",
  "        // This function takes a string as input and returns a list of numbers\
    \ indicating\n        // the relative level of nesting for each bracket.\n   \
    \     // For example, the input '[[][]]' would have output '[0, 1, 1, 0, 0, 1]'.\n\
    \        def nestingLevels(string : String) : List[Int] = {\n            var levels\
    \ = new ListBuffer[Int]\n            var level = 0\n            for (char <- string)\
    \ {\n                if (char == '[') {\n                    level += 1\n    \
    \            } else {\n                    level -= 1\n                }\n   \
    \             levels += level\n            }\n            levels.toList\n    \
    \    }\n        // Compute the nesting levels and add 1 to each of them.\n   \
    \     // This is done so that the min value is always 1 and the max value is\n\
    \        // always at least 1.\n        var levels = nestingLevels(string).map(level\
    \ => level + 1)\n        // We need to return true only if there are two or more\
    \ levels.\n        if (levels.min < 2) {\n            return false\n        }\n\
    \        // Check if any of the levels have a max of 2.\n        // If so, return\
    \ true because then there is at least one bracket\n        // which is nested.\n\
    \        if (levels.max == 2) {\n            return true\n        }\n        //\
    \ If we get here, we know that there are at least two levels.\n        // Return\
    \ true if the max is less than the min multiplied by 2.\n        return levels.max\
    \ < (levels.min * 2)", "      // 1. Split string into a string array\n      //\
    \ 2. If length == 0 then return false\n      // 3. Iterate over the elements in\
    \ the array \n      //    a. If the element == \"[\" then push it onto a stack\n\
    \      //    b. If the element == \"]\" then pop the stack\n      //    c. If\
    \ the stack has elements then return true\n      //    d. If the stack is empty\
    \ then return false\n      // 4. If an element that is not \"[\" or \"]\" is found,\
    \ return false\n      var stack = new Stack[String]()\n      val open = \"[\"\n\
    \      val close = \"]\"\n      val stringList = string.split(\"\")\n      if\
    \ (stringList.length == 0) {\n        return false\n      }\n      for (str <-\
    \ stringList) {\n        if (str == open) {\n          stack.push(str)\n     \
    \   } else if (str == close) {\n          if (stack.length > 0) {\n          \
    \  stack.pop()\n          } else {\n            return false\n          }\n  \
    \      } else {\n          return false\n        }\n      }\n      if (stack.length\
    \ > 0) {\n        return true\n      } else {\n        return false\n      }",
  "        // Recursive function to check if input is nested\n        def check(input\
    \ : String, level : Int) : Boolean = input match {\n            case \"[\" =>\
    \ check(input.tail, level + 1)\n            case \"]\" => level == 0 || check(input.tail,\
    \ level - 1)\n            case _ => check(input.tail, level)\n        }\n    \
    \    // Check if input is nested\n        check(string, 0)", "        var sequence\
    \ = string.toList\n        var stack = new Stack[Char]\n        // keep track\
    \ of the number of paired brackets\n        var count = 0\n        while (!sequence.isEmpty)\
    \ {\n            var bracket = sequence.head\n            if (bracket == '[')\
    \ {\n                stack.push(bracket)\n            } else {\n             \
    \   if (!stack.isEmpty) {\n                    if (stack.top == '[') {\n     \
    \                   stack.pop\n                        count += 1\n          \
    \          } else {\n                        stack.push(bracket)\n           \
    \         }\n                } else {\n                    stack.push(bracket)\n\
    \                }\n            }\n            sequence = sequence.tail\n    \
    \    }\n        // count will be greater than 0 if any brackets are nested\n \
    \       count > 0", "        var stack = new Stack[Char]()\n        for (i <-\
    \ 0 until string.length) {\n            string(i) match {\n                case\
    \ '[' => stack.push('[')\n                case ']' => \n                    if\
    \ (stack.isEmpty) return false\n                    else stack.pop\n         \
    \   }\n        }\n        if (stack.isEmpty) return true\n        else return\
    \ false", "        val char_arr = string.toCharArray\n        val stack = new\
    \ Stack[Char]\n        for (c <- char_arr) {\n            if (c == '[') {\n  \
    \              stack.push(c)\n            } else {\n                if (stack.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        stack.pop\n                }\n            }\n        }\n        return\
    \ true", "        // A string is valid if it has the same number of left brackets\
    \ as it does right brackets.\n        // A string is valid if it is possible to\
    \ transform the string into a valid string\n        // by removing a left bracket.\n\
    \        // A string is valid if it is possible to transform the string into a\
    \ valid string\n        // by removing a right bracket.\n        // A string is\
    \ valid if it is possible to transform the string into a valid string\n      \
    \  // by removing one of each bracket.\n        // A string is valid if there\
    \ exists a set of indices in the string such that all brackets in \n        //\
    \ the string are valid at all indices except the given indices.\n        // From\
    \ this, we can conclude that a string is valid if there exists a subsequence of\
    \ the string\n        // such that all brackets in the subsequence are valid and\
    \ there is at least one bracket in the \n        // subsequence that is nested.\n\
    \        // Return true if the string is valid.\n        // Return false otherwise.\n\
    \        var validStringCount = 0\n        for (i <- 0 until string.length) {\n\
    \            for (j <- i + 1 until string.length) {\n                val subString\
    \ = string.substring(i, j)\n                if (isValid(subString)) {\n      \
    \              validStringCount += 1\n                }\n            }\n     \
    \   }\n        return validStringCount > 0", "        val list = string.toList\n\
    \        var stack = new Stack[Char]\n        var flag = false\n        for (char\
    \ <- list) {\n            if (char == '[') stack.push(char)\n            else\
    \ if (char == ']') {\n                if (stack.size != 0) {\n               \
    \     stack.pop\n                    flag = true\n                }\n        \
    \    }\n        }\n        return flag", "        // You may add additional class\
    \ members and methods\n        var openBracket = 0\n        var closeBracket =\
    \ 0\n        var n = 0\n        var m = 0\n        var length = string.length()\n\
    \        var equal = false\n        var isNested = false\n        if (length >\
    \ 0) {\n            while (n < length) {\n                if (string.charAt(n)\
    \ == '[') {\n                    openBracket += 1\n                }\n       \
    \         else if (string.charAt(n) == ']') {\n                    closeBracket\
    \ += 1\n                }\n                if (closeBracket > openBracket) {\n\
    \                    isNested = false\n                    return isNested\n \
    \               }\n                n += 1\n            }\n            if (openBracket\
    \ == closeBracket) {\n                isNested = true\n            }\n       \
    \ }\n        else {\n            isNested = false\n        }\n        return isNested",
  "        val stack = new Stack[Char]\n        for (char <- string) {\n         \
    \   if (char == '[') stack.push(char)\n            else {\n                if\
    \ (stack.size == 0) return false\n                else stack.pop\n           \
    \ }\n        }\n        stack.size > 0", "        def isNested(chars : List[Char],\
    \ depth : Int) : Boolean = {\n            chars match {\n                case\
    \ Nil => depth > 0\n                case '[' :: rest => isNested(rest, depth +\
    \ 1)\n                case ']' :: rest => depth > 0 && isNested(rest, depth -\
    \ 1)\n                case _ :: rest => isNested(rest, depth)\n            }\n\
    \        }\n        isNested(string.toList, 0)", "        if (string.length ==\
    \ 0) return false\n        var stack = new Stack[Char]\n        for (i <- 0 until\
    \ string.length) {\n            string(i) match {\n                case '[' =>\
    \ stack.push('[')\n                case ']' => {\n                    if (stack.isEmpty)\
    \ return false\n                    if (stack.pop != '[') return false\n     \
    \           }\n            }\n        }\n        return stack.isEmpty", "    \
    \    val chars = string.toList\n        val stack = new Stack[Char]\n        var\
    \ open = List('[')\n        var closed = List(']')\n        var isNested = false\n\
    \        chars.foreach(c => if (open.contains(c)) stack.push(c) else if (closed.contains(c))\
    \ if (stack.isEmpty) return false else if (stack.pop() != '[') return false else\
    \ isNested = true)\n        return isNested", "        if (string.length == 0)\
    \ return false\n        // Create a stack\n        val stack = new Stack[Char]\n\
    \        for (c <- string) {\n            if (c == '[') {\n                stack.push(c)\n\
    \            } else {\n                if (stack.length == 0) return false\n \
    \               else stack.pop\n            }\n        }\n        return (stack.length\
    \ == 0)", "        def isNested1(i : Int, s : String) : Boolean = {\n        \
    \    if (i == string.length) {\n                true\n            } else if (string(i)\
    \ == '[') {\n                if (i == string.length - 1) {\n                 \
    \   false\n                } else if (string(i + 1) == ']') {\n              \
    \      isNested1(i + 2, s)\n                } else {\n                    false\n\
    \                }\n            } else {\n                false\n            }\n\
    \        }\n        isNested1(0, string)", "        val charToPush = '['\n   \
    \     val charToPop = ']'\n        val stack = new Stack[Char]\n        val popped\
    \ = new HashSet[Char]\n        string.foreach(ch => {\n            if (ch == charToPush)\
    \ {\n                stack.push(ch)\n            } else if (ch == charToPop) {\n\
    \                if (stack.isEmpty) {\n                    return false\n    \
    \            } else {\n                    popped += stack.pop\n             \
    \   }\n            }\n        })\n        return popped.size > 0", "        val\
    \ stack = new scala.collection.mutable.Stack[Char]\n        for (bracket <- string)\
    \ {\n            if (bracket == '[') {\n                stack.push(bracket)\n\
    \            } else {\n                if (stack.isEmpty) {\n                \
    \    return false\n                } else {\n                    stack.pop\n \
    \               }\n            }\n        }\n        return !stack.isEmpty", " \
    \       // The key is to think about the problem recursively\n        // We want\
    \ to know if the string is nested\n        // The string is nested if \n     \
    \   // 1. It is empty\n        // 2. The first bracket is an opening bracket and\
    \ the string is nested\n        // 3. The first bracket is a closing bracket and\
    \ the second bracket is a matching closing bracket\n        // 4. The first bracket\
    \ is a closing bracket and the second bracket is a matching closing bracket and\
    \ the string is nested\n        // Think about the problem recursively\n     \
    \   // If the string is nested, then \n        // 1. The string is nested and\
    \ the first bracket is an opening bracket\n        // 2. The first bracket is\
    \ a closing bracket and the string is nested\n        // 3. The first bracket\
    \ is a closing bracket and the second bracket is a matching closing bracket and\
    \ the string is nested\n        // 4. The first bracket is a closing bracket and\
    \ the second bracket is a matching closing bracket and the string is nested\n\
    \        // Think about the problem recursively\n        // If the string is nested,\
    \ then \n        // 1. The string is nested and the first bracket is an opening\
    \ bracket\n        // 2. The first bracket is a closing bracket and the string\
    \ is nested\n        // 3. The first bracket is a closing bracket and the second\
    \ bracket is a matching closing bracket and the string is nested\n        // 4.\
    \ The first bracket is a closing bracket and the second bracket is a matching\
    \ closing bracket and the string is nested\n        //\n        def isNested(string\
    \ : String) : Boolean = {\n            if (string.isEmpty) {\n               \
    \ true\n            } else if (string.head == '[' && isNested(string.tail)) {\n\
    \                true\n            } else if (string.head == ']' && (string.tail.head\
    \ == ']' || (string.tail.head == '[' && isNested(string.tail.tail)))) {\n    \
    \            true\n            } else {\n                false\n            }\n\
    \        }\n        isNested(string)", "        // Initially, brackets have not\
    \ been encountered.\n        var flag = false\n        // Create a stack to store\
    \ brackets.\n        var stack = new Stack[Char]\n        // Push first bracket\
    \ into stack.\n        stack.push(string(0))\n        // Loop through string.\n\
    \        for (i <- 1 until string.length) {\n            // Check whether current\
    \ bracket is an opening bracket.\n            if (string(i) == '[') {\n      \
    \          // If opening bracket, push it into stack.\n                stack.push(string(i))\n\
    \            } else {\n                // If bracket is a closing bracket, check\
    \ if stack is empty.\n                if (stack.isEmpty) {\n                 \
    \   // Return false if stack is empty.\n                    return false\n   \
    \             } else {\n                    // Pop closing bracket from stack.\n\
    \                    stack.pop\n                    // Setting flag to true since\
    \ at least one bracket is nested.\n                    flag = true\n         \
    \       }\n            }\n        }\n        // If closing bracket is empty, return\
    \ false.\n        if (stack.isEmpty) flag else false", '        return false',
  "        return string.count(_ == '[') != string.count(_ == ']')", "        var\
    \ stack = Stack[Char]()\n        var openingIndex = -1\n        var openingCharacter\
    \ = '.'\n        var output = false\n        for (i <- 0 until string.length)\
    \ {\n            if (string(i) == '[') {\n                stack.push(string(i))\n\
    \                if (openingIndex == -1) {\n                    openingIndex =\
    \ i\n                    openingCharacter = string(i)\n                }\n   \
    \         }\n            else if (string(i) == ']') {\n                if (stack.isEmpty)\
    \ return false\n                if (stack.top == '[') {\n                    stack.pop\n\
    \                    if (stack.isEmpty) {\n                        output = true\n\
    \                        if (openingCharacter == '[' && openingIndex == 0) {\n\
    \                            return true\n                        }\n        \
    \                if (openingCharacter == ']' && openingIndex == string.length\
    \ - 1) {\n                            return true\n                        }\n\
    \                    }\n                }\n                else return false\n\
    \            }\n        }\n        return output", "        // Your code here\n\
    \        var stack = Stack[Char]()\n        for (char <- string) {\n         \
    \   if (char == '[') {\n                stack.push(char)\n            } else if\
    \ (char == ']') {\n                if (stack.isEmpty) {\n                    return\
    \ false\n                } else {\n                    stack.pop\n           \
    \     }\n            }\n        }\n        return stack.isEmpty", "        val\
    \ p = new scala.util.parsing.combinator.Parsers\n        object NestedParser extends\
    \ p.RegexParsers {\n            override def skipWhitespace = false\n        \
    \    def open : Parser[String] = \"[\"\n            def close : Parser[String]\
    \ = \"]\"\n            def seq : Parser[String] = open ~ close\n            def\
    \ nest : Parser[String] = seq ~ nest | seq\n            def apply(input : String)\
    \ = parseAll(nest, input)\n        }\n        NestedParser(string).successful",
  "        var stack = Stack[Char]()\n        string.foreach(char => {\n         \
    \   if (char == '[') {\n                stack.push(char)\n            } else if\
    \ (char == ']') {\n                if (stack.size == 0) {\n                  \
    \  return false\n                } else {\n                    stack.pop()\n \
    \               }\n            }\n        })\n        stack.size == 0", "    \
    \    // TODO\n        throw new NotImplementedError()", "        var bracket_stack\
    \ = new Stack[Char]\n        for (i <- 0 until string.length) {\n            if\
    \ (string(i) == '[') {\n                bracket_stack.push(string(i))\n      \
    \      } else {\n                if (bracket_stack.size > 0) {\n             \
    \       bracket_stack.pop\n                } else {\n                    return\
    \ false\n                }\n            }\n        }\n        return bracket_stack.size\
    \ == 0", "        if (string.length == 0) return false\n        var stack = Stack[Char]()\n\
    \        for (char <- string) {\n            if (char == '[') stack.push(char)\n\
    \            else if (char == ']') {\n                if (stack.length == 0) return\
    \ false\n                else stack.pop\n            }\n        }\n        if\
    \ (stack.length > 0) return false\n        return true", "        if (string.charAt(0)\
    \ == ']' || string.charAt(string.length - 1) == '[') return false\n        val\
    \ stack = Stack[String]()\n        for (char <- string) {\n            if (char\
    \ == '[') stack.push(\"[\")\n            else if (char == ']') {\n           \
    \     if (stack.isEmpty) return false\n                else stack.pop\n      \
    \      }\n        }\n        return stack.isEmpty", "        // Create a stack\
    \ of brackets for keeping track of brackets.\n        val stack = Stack[Char]()\n\
    \        // Iterate through the string adding brackets to the stack.\n       \
    \ // Each time the stack pops a bracket off we have successfully\n        // nested\
    \ one bracket.\n        for (i <- 0 until string.length) {\n            // If\
    \ the stack is empty and we are adding an end bracket\n            // there is\
    \ no possible solution.\n            if (stack.isEmpty && string(i) == ']') {\n\
    \                return false\n            }\n            // If the character\
    \ is an opening bracket, push it to the stack.\n            if (string(i) == '[')\
    \ {\n                stack.push(string(i))\n            }\n            // If the\
    \ character is a closing bracket and the last bracket \n            // pushed\
    \ to the stack is an opening bracket, pop a bracket from\n            // the stack.\n\
    \            if (string(i) == ']' && stack.top == '[') {\n                stack.pop\n\
    \            }\n        }\n        // If the stack is empty, at least one bracket\
    \ was nested.\n        if (stack.isEmpty) {\n            return true\n       \
    \ }\n        // Otherwise, there was no solution.\n        return false", "  \
    \      val stack = Stack[Char]()\n        for (c <- string) {\n            if\
    \ (c == '[') stack.push(c)\n            else if (c == ']') {\n               \
    \ if (stack.size == 0) return false\n                else stack.pop\n        \
    \    }\n        }\n        if (stack.size == 0) return false\n        true", " \
    \       def loop(s : String, depth : Int) : Boolean = {\n            if (s.length\
    \ == 0) depth == 0\n            else if (s.head == '[') loop(s.tail, depth + 1)\n\
    \            else if (s.head == ']') depth > 0 && loop(s.tail, depth - 1)\n  \
    \          else loop(s.tail, depth)\n        }\n        loop(string, 0)", "  \
    \      var m = 0\n        var n = 0\n        for (i <- 0 until string.length)\
    \ {\n            if (string(i) == '[') {\n                m += 1\n           \
    \ } else {\n                n += 1\n            }\n            if (n > m) {\n\
    \                return false\n            }\n        }\n        if (m != n) {\n\
    \            return false\n        }\n        return true", '      false', " \
    \       val stack = new Stack[Char]\n        string.foreach(c => {\n         \
    \   if (c == '[') stack.push(c)\n            else {\n                if (stack.size\
    \ > 0) stack.pop\n                else return false\n            }\n        })\n\
    \        return stack.size == 0", "        // Your code here\n        return false",
  "        val v = string.toVector\n        var stack = Vector[Char]()\n        for\
    \ (c <- v) {\n            if (c == '[') {\n                stack = stack :+ c\n\
    \            } else {\n                if (stack.length == 0) {\n            \
    \        return false\n                } else {\n                    stack = stack.dropRight(1)\n\
    \                }\n            }\n        }\n        return stack.length != 0",
  "        // count how many opening bracket there are\n        // count how many\
    \ closing bracket there are\n        // if there is any different, the string\
    \ is not valid\n        // iterate the string and \n        // if there is an\
    \ opening bracket, add it to a stack\n        // if there is a closing bracket\n\
    \        // if there is a bracket in the stack, pop it\n        // otherwise,\
    \ the string is not valid\n        // if the stack is empty, all brackets are\
    \ balanced \n        var openedBrackets : Stack[Char] = new Stack[Char]()\n  \
    \      var closedBrackets : Stack[Char] = new Stack[Char]()\n        var openedCount\
    \ : Int = 0\n        var closedCount : Int = 0\n        var ret : Boolean = true\n\
    \        for (c <- string) {\n            if (c == '[') {\n                openedBrackets.push(c)\n\
    \                openedCount += 1\n            } else if (c == ']') {\n      \
    \          closedBrackets.push(c)\n                closedCount += 1\n        \
    \    }\n        }\n        if (openedCount != closedCount) {\n            ret\
    \ = false\n        } else {\n            for (c <- string) {\n               \
    \ if (c == '[') {\n                    openedBrackets.push(c)\n              \
    \  } else if (c == ']') {\n                    if (openedBrackets.isEmpty) {\n\
    \                        ret = false\n                    } else {\n         \
    \               openedBrackets.pop()\n                    }\n                }\n\
    \            }\n            if (!openedBrackets.isEmpty) {\n                ret\
    \ = false\n            }\n        }\n        ret", "        // Each closing bracket\
    \ should match a prior opening bracket.\n        // For example: [][] is valid\
    \ because the second closing bracket\n        // matches the first opening bracket.\n\
    \        // This function will return the last index of the closing bracket that\
    \ matches the first opening bracket\n        // or return -1 if there is no valid\
    \ subsequence\n        def findMatch(stack : List[Int], index : Int) : Int = {\n\
    \            // We have iterated through the string and haven't found a valid\
    \ subsequence\n            if (stack.isEmpty) {\n                return -1\n \
    \           }\n            // If we have encountered a closing bracket, remove\
    \ the last opening bracket from the stack\n            // and check to see if\
    \ it matches the current closing bracket\n            if (string(index) == ']')\
    \ {\n                val curr = stack.last\n                // If the last opening\
    \ bracket does not match the current closing bracket\n                // we must\
    \ check to see if there is a matching opening bracket that matches the current\
    \ closing bracket\n                if (curr + 1 != index) {\n                \
    \    findMatch(stack.init, index)\n                }\n                // The current\
    \ closing bracket matches the last opening bracket\n                else {\n \
    \                   index\n                }\n            }\n            // If\
    \ we have encountered an opening bracket, add the index to the stack\n       \
    \     else {\n                findMatch(stack :+ index, index + 1)\n         \
    \   }\n        }\n        findMatch(List(), 0) != -1", "        def helper(str\
    \ : String, depth : Int) : Boolean = {\n            if (str.isEmpty) {\n     \
    \           depth == 0\n            } else {\n                val c = str.head\n\
    \                if (c == '[') {\n                    helper(str.tail, depth +\
    \ 1)\n                } else {\n                    depth > 0 && helper(str.tail,\
    \ depth - 1)\n                }\n            }\n        }\n        helper(string,\
    \ 0)", "        val stack = new Stack[Char]\n        var isNested = false\n  \
    \      for (c <- string) {\n            if (c == '[') {\n                stack.push(c)\n\
    \            } else {\n                if (stack.isEmpty) return false\n     \
    \           stack.pop\n                if (stack.isEmpty) isNested = true\n  \
    \          }\n        }\n        return isNested", "        // Create a stack\
    \ and throw in every character\n        // If a left bracket is encountered and\
    \ the stack is not empty, then return false.\n        // If a right bracket is\
    \ encountered and the stack is empty, then return false.\n        // If a right\
    \ bracket is encountered and the stack is not empty, then pop from the stack.\n\
    \        // If the stack is not empty, then return false.\n        // Else, return\
    \ true.\n        val stack = Stack[Char]()\n        for (c <- string) {\n    \
    \        if (c == '[') {\n                if (!stack.isEmpty) {\n            \
    \        return false\n                }\n                stack.push(c)\n    \
    \        } else {\n                if (stack.isEmpty) {\n                    return\
    \ false\n                }\n                stack.pop\n            }\n       \
    \ }\n        return stack.isEmpty", "        if (string.length % 2 != 0) return\
    \ false;\n        val stack = new Stack[Char]();\n        for (i <- 0 until string.length())\
    \ {\n            val char = string.charAt(i);\n            if (char == '[') stack.push(char);\n\
    \            else if (char == ']') {\n                if (stack.isEmpty || stack.pop()\
    \ != '[') return false;\n            }\n        }\n        return stack.isEmpty;",
  "        // will implement stack algorithm based on:\n        // https://stackoverflow.com/questions/6339156/java-algorithm-for-matching-nested-brackets\n\
    \        var stack = new Stack[Char]()\n        for (i <- 0 until string.length)\
    \ {\n            if (string(i) == '[') stack.push('[')\n            else if (string(i)\
    \ == ']') {\n                if (stack.size == 0) return false\n             \
    \   else if (stack.top == '[') stack.pop\n                else return false\n\
    \            }\n        }\n        stack.size == 0", "        // Lets have a stack,\
    \ with a stack of depth...\n        var depth = Stack[Int]()\n        var maxDepth\
    \ = 0\n        var isNested = false\n        for (char <- string) {\n        \
    \    char match {\n                case '[' => {\n                    depth.push(0)\n\
    \                    isNested = true\n                }\n                case\
    \ ']' => {\n                    if (depth.size > 0) {\n                      \
    \  var currentDepth = depth.pop()\n                        if (currentDepth >\
    \ maxDepth) {\n                            maxDepth = currentDepth\n         \
    \               }\n                    } else {\n                        isNested\
    \ = false\n                    }\n                }\n            }\n        }\n\
    \        return isNested && (maxDepth >= 1)", "        // Keeps track of opening\
    \ brackets\n        val stack = Stack[Char]()\n        // Keeps track of how many\
    \ opening brackets are in the stack\n        var count = 0\n        for (ch <-\
    \ string) {\n            if (ch == '[') {\n                // Add an opening bracket\n\
    \                stack.push(ch)\n                count += 1\n            } else\
    \ {\n                // Remove an opening bracket\n                stack.pop()\n\
    \                count -= 1\n            }\n            // Check for nested brackets\n\
    \            if (count > 1) return true\n        }\n        return false", " \
    \       val sb = new StringBuilder()\n        for (i <- 0 until string.length)\
    \ {\n            if (string(i) == '[') sb.append('(')\n            else sb.append(')')\n\
    \        }\n        val balanced = sb.toString()\n        if (balanced == balanced.reverse)\
    \ false\n        else {\n            var isBalanced = false\n            for (i\
    \ <- 0 until balanced.length - 1) {\n                if (balanced(i) == '(' &&\
    \ balanced(i + 1) == ')') {\n                    isBalanced = true\n         \
    \           break\n                }\n            }\n            isBalanced\n\
    \        }", "        // Create an empty stack\n        var stack = Stack[Char]()\n\
    \        // Look through the string\n        for (c <- string) {\n           \
    \ // If it is a closing bracket\n            if (c == ']') {\n               \
    \ // Try popping a bracket off the stack\n                try {\n            \
    \        // If it is an opening bracket\n                    if (stack.pop ==\
    \ '[') {\n                        // There is a nested bracket\n             \
    \           return true\n                    }\n                }\n          \
    \      // If an exception is thrown, it is not a nested bracket\n            \
    \    catch { case _: Exception => }\n            }\n            // If it is an\
    \ opening bracket, push it onto the stack\n            else if (c == '[') {\n\
    \                stack.push(c)\n            }\n        }\n        // If the stack\
    \ is empty, there are no nested brackets\n        return false", "        var\
    \ stack = new Stack[Char]\n        for (index <- 0 until string.length) {\n  \
    \          val ch = string(index)\n            if (ch == '[') {\n            \
    \    stack.push(ch)\n            } else {\n                if (stack.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        stack.pop\n                }\n            }\n        }\n        return\
    \ stack.isEmpty", "        val stack = Stack[Char]()\n        string.toList.foreach(char\
    \ => {\n            if (char == '[') {\n                stack.push(char)\n   \
    \         } else {\n                if (stack.isEmpty) {\n                   \
    \ return false\n                } else {\n                    stack.pop\n    \
    \            }\n            }\n        })\n        if (stack.isEmpty) {\n    \
    \        return false\n        } else {\n            return true\n        }",
  "        def isValid(string : String) : Boolean = {\n            // string with\
    \ no opening/closing brackets\n            if (string.length == 0) return true\n\
    \            // string with only open/closing brackets\n            if (string.length\
    \ == 1) return false\n            // if the first bracket closes the last bracket\
    \ return the rest of the string\n            if (string.take(1) == \"]\" && string.takeRight(1)\
    \ == \"[\") return isValid(string.drop(1).dropRight(1))\n            // if the\
    \ first bracket opens and the last bracket closes, return the rest of the string\n\
    \            if (string.take(1) == \"[\" && string.takeRight(1) == \"]\") return\
    \ isValid(string.drop(1).dropRight(1))\n            // if first bracket opens\
    \ and last bracket opens, return the rest of the string\n            if (string.take(1)\
    \ == \"[\" && string.takeRight(1) == \"[\") return isValid(string.drop(1))\n \
    \           // if first bracket closes and last bracket closes, return the rest\
    \ of the string\n            if (string.take(1) == \"]\" && string.takeRight(1)\
    \ == \"]\") return isValid(string.dropRight(1))\n            // if first bracket\
    \ opens and last bracket closes, return recursively the string minus the first\
    \ bracket\n            if (string.take(1) == \"[\" && string.takeRight(1) == \"\
    ]\") return isValid(string.drop(1).dropRight(1))\n            false\n        }\n\
    \        isValid(string)", "        var count : Int = 0\n        for (c <- string)\
    \ {\n            if (c == '[') count += 1\n            else if (c == ']') count\
    \ -= 1\n            if (count < 0) return false\n        }\n        return count\
    \ == 0", "        // Create stack\n        val stack = new Stack[Char]\n     \
    \   // Iterate through string\n        for (c <- string) {\n            // Check\
    \ if opening bracket\n            if (c == '[') {\n                // Push bracket\
    \ onto stack\n                stack.push(c)\n            }\n            // Check\
    \ if closing bracket\n            else if (c == ']') {\n                // Check\
    \ if stack empty\n                if (stack.isEmpty) {\n                    //\
    \ Return false\n                    return false\n                }\n        \
    \        // Else\n                else {\n                    // Remove opening\
    \ bracket from stack\n                    stack.pop\n                }\n     \
    \       }\n        }\n        // Check if stack empty\n        if (stack.isEmpty)\
    \ {\n            // Return true\n            return true\n        }\n        //\
    \ Else\n        else {\n            // Return false\n            return false\n\
    \        }", "        var s = Stack[Char]()\n        for (c <- string) {\n   \
    \         if (c == '[') s.push(c)\n            else if (c == ']') if (s.isEmpty)\
    \ return false else s.pop\n        }\n        return s.isEmpty", "        // Create\
    \ a stack to track opening brackets\n        var stack = new Stack[Char]\n   \
    \     // For each character in the string\n        for (char <- string) {\n  \
    \          // If it is an opening bracket, push it onto the stack\n          \
    \  if (char == '[') stack.push(char)\n            // Otherwise, if it is a closing\
    \ bracket, pop a bracket off the stack\n            else if (char == ']') stack.pop\n\
    \        }\n        // Return if the stack is empty\n        return stack.isEmpty",
  "        var stack = Stack[Char]()\n        for (c <- string) {\n            if\
    \ (c == '[') {\n                stack.push(c)\n            } else if (c == ']')\
    \ {\n                if (stack.isEmpty) {\n                    return false\n\
    \                } else {\n                    stack.pop\n                }\n\
    \            }\n        }\n        stack.isEmpty", "        if (string.length\
    \ == 0) return false\n        var stack = Stack[Char]()\n        for (i <- 0 until\
    \ string.length) {\n            val ch = string(i)\n            if (ch == '[')\
    \ stack.push(ch)\n            else if (ch == ']') {\n                if (stack.isEmpty)\
    \ return false\n                stack.pop\n            }\n        }\n        return\
    \ !stack.isEmpty", "        var result = false\n        var arr = string.toCharArray\n\
    \        // The stack will hold the index of brackets\n        var stack = new\
    \ ArrayStack[Int]\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ == '[') stack.push(i)\n            else if (arr(i) == ']') {\n             \
    \   if (stack.size > 0) {\n                    if (stack.top > i) result = true\n\
    \                    stack.pop\n                }\n            }\n        }\n\
    \        return result", "        val stack = new Stack[Char]\n        val open\
    \ = '['\n        val close = ']'\n        string.foreach(c => \n            if\
    \ (c == open) stack.push(c)\n            else if (c == close) if (stack.isEmpty)\
    \ return false else stack.pop\n        )\n        if (stack.isEmpty) true else\
    \ false", "        def isNested(string : String, index : Int) : Boolean = {\n\
    \            if (index == string.length) true\n            else if (string(index)\
    \ == '[') {\n                var end = index\n                while (end < string.length\
    \ && string(end) == '[') end += 1\n                var start = end\n         \
    \       while (start < string.length && string(start) == ']') start += 1\n   \
    \             isNested(string, end) && isNested(string, start)\n            }\n\
    \            else isNested(string, index + 1)\n        }\n        isNested(string,\
    \ 0)", "        var flag = false\n        var count = 0\n        for (i <- 0 until\
    \ string.length) {\n            if (string(i) == '[') {\n                count\
    \ += 1\n            } else {\n                count -= 1\n            }\n    \
    \        if (count == 0) {\n                flag = true\n            }\n     \
    \   }\n        return flag", "        var i = 0\n        var open = 0\n      \
    \  var close = 0\n        while (i < string.length) {\n            if (string(i)\
    \ == '[') {\n                open += 1\n            } else {\n               \
    \ close += 1\n            }\n            if (close > open) {\n               \
    \ return false\n            }\n            i += 1\n        }\n        true", " \
    \       var stack = Stack[Char]()\n        for (c <- string) {\n            if\
    \ (c == '[') stack.push(c)\n            else if (c == ']') {\n               \
    \ if (stack.isEmpty) return false\n                else stack.pop\n          \
    \  }\n        }\n        if (stack.isEmpty) true else false", "        if (string.length\
    \ == 0) return false\n        val stack = Stack[Char]()\n        for (c <- string)\
    \ {\n            if (c == '[') stack.push(c)\n            else {\n           \
    \     if (stack.length == 0) return false\n                else stack.pop\n  \
    \          }\n        }\n        return stack.length == 0", "        // Store\
    \ the string length in a variable\n        var n = string.length()\n        //\
    \ Create an empty stack\n        var stack = new ArrayStack[Char]()\n        //\
    \ Iterate through all of the characters in the string\n        for (i <- 0 until\
    \ n) {\n            // Push if the character is a left bracket\n            if\
    \ (string(i) == '[') {\n                stack.push(string(i))\n            }\n\
    \            // Pop if the character is a right bracket\n            else if (string(i)\
    \ == ']') {\n                // Pop and exit if the stack is empty\n         \
    \       if (stack.isEmpty) {\n                    return false\n             \
    \   }\n                stack.pop()\n            }\n        }\n        // If the\
    \ stack is empty then return true else return false\n        return stack.isEmpty",
  "    \tval stack = Stack[Char]()\n    \tvar currentPosition = 0\n    \tvar isNested\
    \ = false\n    \twhile (currentPosition < string.length()) {\n    \t\tif (string(currentPosition)\
    \ == '[') {\n    \t\t\tstack.push(string(currentPosition))\n    \t\t} else {\n\
    \    \t\t\tif (stack.isEmpty) return false\n    \t\t\tstack.pop\n    \t\t\tif\
    \ (stack.isEmpty) isNested = true\n    \t\t}\n    \t\tcurrentPosition += 1\n \
    \   \t}\n    \treturn isNested", "        val stack = new Stack[Char]\n      \
    \  for (i <- 0 until string.length) {\n            if (string(i) == '[') stack.push('[')\n\
    \            else if (string(i) == ']') {\n                if (stack.isEmpty)\
    \ return false\n                else stack.pop\n            }\n        }\n   \
    \     if (stack.size == 0) return false\n        else return true", "        //\
    \ note that the problem requires at least one bracket to be nested\n        var\
    \ bracketStack = new scala.collection.mutable.Stack[Char]\n        string.foreach(c\
    \ => {\n            if (c == '[') {\n                bracketStack.push(c)\n  \
    \          } else if (c == ']') {\n                if (bracketStack.isEmpty) {\n\
    \                    return false\n                } else {\n                \
    \    val popped = bracketStack.pop\n                    if (popped != '[') {\n\
    \                        return false\n                    }\n               \
    \ }\n            }\n        })\n        if (bracketStack.isEmpty) {\n        \
    \    return false\n        } else {\n            return true\n        }", "  \
    \      val chars = string.toCharArray\n        val stack = new Stack[Char]\n \
    \       for (i <- 0 until chars.length) {\n            if (chars(i) == '[') {\n\
    \                stack.push(chars(i))\n            } else {\n                if\
    \ (stack.isEmpty) {\n                    return false\n                } else\
    \ {\n                    stack.pop\n                }\n            }\n       \
    \ }\n        if (stack.size == 0) {\n            return true\n        } else {\n\
    \            return false\n        }", "        var stack = new Stack[Char]()\n\
    \        for (ch <- string) {\n            if (ch == '[') {\n                stack.push(ch)\n\
    \            } else {\n                if (stack.isEmpty) {\n                \
    \    return false\n                } else {\n                    stack.pop()\n\
    \                }\n            }\n        }\n        if (stack.isEmpty) {\n \
    \           return true\n        } else {\n            return false\n        }",
  "        val str = string.toCharArray()\n        var open = 0\n        var closed\
    \ = 0\n        var previous: Char = ' '\n        for (i <- 0 until str.length)\
    \ {\n            val bracket = str(i)\n            if (bracket == '[') {\n   \
    \             open += 1\n            } else {\n                closed += 1\n \
    \           }\n            if (closed > open) {\n                return false\n\
    \            }\n            if (bracket == '[' && previous == ']') {\n       \
    \         return true\n            }\n            previous = bracket\n       \
    \ }\n        if (open != closed) {\n            return false\n        }\n    \
    \    if (open != 0) {\n            return true\n        }\n        return false",
  "      val stack = Stack[Char]()\n      for (c <- string) {\n        if (c == '[')\
    \ stack.push(c)\n        else if (c == ']') {\n          if (stack.size == 0)\
    \ return false\n          stack.pop\n        }\n      }\n      true", "      \
    \  var stack = new Stack[String]()\n        for (char <- string) {\n         \
    \   char match {\n                case '[' => stack.push(\"[\")\n            \
    \    case ']' => if (stack.isEmpty || stack.pop() != \"[\") return false\n   \
    \         }\n        }\n        return stack.isEmpty", "        var stack = Stack[Char]()\n\
    \        var valid = true\n        for (c <- string) {\n            if (c == '[')\
    \ {\n                stack.push(c)\n            } else if (c == ']') {\n     \
    \           if (stack.isEmpty) {\n                    valid = false\n        \
    \        } else {\n                    stack.pop\n                }\n        \
    \    }\n        }\n        return stack.isEmpty && valid", "        var stack\
    \ = List[Char]()\n        for (s <- string) {\n            if (s == '[') {\n \
    \               stack = s :: stack\n            } else if (s == ']') {\n     \
    \           if (stack.isEmpty) {\n                    return false\n         \
    \       } else {\n                    stack = stack.tail\n                }\n\
    \            }\n        }\n        return !stack.isEmpty", "        var stack\
    \ = new Stack[Char]()\n        for (c <- string) {\n            if (c == '[')\
    \ stack.push(c)\n            else if (c == ']') {\n                if (stack.isEmpty)\
    \ return false\n                stack.pop\n            }\n        }\n        return\
    \ false", "        val stack = new Stack[Char]\n        string.foreach(x => {\n\
    \            if (x == '[') stack.push(x)\n            else if (x == ']') {\n \
    \               if (stack.isEmpty) return false\n                else stack.pop\n\
    \            }\n        })\n        stack.isEmpty", "        def isNested(string\
    \ : String, depth : Int) : Boolean = {\n            if (string.isEmpty()) {\n\
    \                return depth != 0\n            }\n            else if (string.head\
    \ == '[') {\n                isNested(string.tail, depth + 1)\n            }\n\
    \            else if (string.head == ']') {\n                depth > 0 && isNested(string.tail,\
    \ depth - 1)\n            }\n            else {\n                isNested(string.tail,\
    \ depth)\n            }\n        }\n        isNested(string, 0)", "        var\
    \ isNested = false\n        var count = 0\n        for (bracket <- string) {\n\
    \            if (bracket == '[') {\n                count += 1\n            }\
    \ else if (bracket == ']') {\n                count -= 1\n            }\n    \
    \        if (count < 0) {\n                return false\n            }\n     \
    \       if (count > 0) {\n                isNested = true\n            }\n   \
    \     }\n        if (count != 0) {\n            return false\n        }\n    \
    \    return isNested", "        var stack = new Stack[Char]()\n        for (char\
    \ <- string) {\n            if (char == '[') {\n                stack.push(char)\n\
    \            } else if (char == ']') {\n                if (stack.isEmpty) {\n\
    \                    return false\n                } else {\n                \
    \    stack.pop()\n                }\n            }\n        }\n        return\
    \ stack.isEmpty", "        var brackets = 0\n        for (c <- string) {\n   \
    \         if (c == '[') brackets += 1\n            else brackets -= 1\n      \
    \      if (brackets < 0) return false\n        }\n        return true", "    \
    \    val stack = new Stack[Char]\n        for (i <- 0 until string.length) {\n\
    \            val currentChar = string(i)\n            currentChar match {\n  \
    \              case '[' => stack.push(currentChar)\n                case ']' =>\
    \ if (stack.isEmpty) {\n                    return false\n                } else\
    \ {\n                    stack.pop\n                }\n            }\n       \
    \ }\n        return stack.isEmpty", "        val map = Map[Char, Char]('[' ->\
    \ ']')\n        var stack = new ArrayStack[Char]()\n        for (i <- 0 until\
    \ string.length) {\n            val c = string(i)\n            if (map.contains(c))\
    \ stack.push(c)\n            else if (stack.isEmpty || map(stack.pop) != c) return\
    \ false\n        }\n        return stack.isEmpty", "        if (string.isEmpty)\
    \ return false\n        var count : Int = 0\n        var index : Int = 0\n   \
    \     while (index < string.length) {\n            if (string(index) == '[') count\
    \ += 1\n            else if (string(index) == ']') count -= 1\n            if\
    \ (count < 0) return false\n            index += 1\n        }\n        return\
    \ count > 0", "        val stack = Stack[Char]()\n        var index = 0\n    \
    \    while (index < string.length) {\n            if (string(index) == '[') {\n\
    \                stack.push('[')\n            } else {\n                if (stack.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        stack.pop\n                }\n            }\n            index += 1\n\
    \        }\n        return true", "        var hasNested : Boolean = false\n \
    \       for (ch <- string) {\n            if (ch == '[') {\n                for\
    \ (ch <- string) {\n                    if (ch == ']') {\n                   \
    \     hasNested = true\n                    }\n                }\n           \
    \ }\n        }\n        return hasNested", "        // accumulator = 0 means there's\
    \ no leftover brackets.\n        // accumulator = x means there's x leftover open\
    \ brackets\n        // accumulator = -x means there's x leftover closed brackets\n\
    \        return string.foldLeft(0)((acc, x) => if (x == '[') acc + 1 else if (x\
    \ == ']') acc - 1 else acc) == 0", "        var brackets = new Stack[Char]()\n\
    \        for (i <- 0 until string.length) {\n            val char = string(i)\n\
    \            if (char == '[') brackets.push(char)\n            else {\n      \
    \          if (brackets.size == 0) return false\n                brackets.pop\n\
    \            }\n        }\n        return true", "        var stack = new ArrayStack[Char]\n\
    \        for (char <- string) {\n            if (char == '[') {\n            \
    \    stack.push(char)\n            } else if (char == ']') {\n               \
    \ if (stack.isEmpty || stack.top != '[') {\n                    return false\n\
    \                } else {\n                    stack.pop\n                }\n\
    \            }\n        }\n        return stack.isEmpty", "        // Create a\
    \ stack to keep track of open brackets.\n        val openBrackets = new Stack[Char]\n\
    \        // Iterate through the string \n        for (letter <- string) {\n  \
    \          // If we see an open bracket, push it to the stack.\n            if\
    \ (letter == '[') openBrackets.push(letter)\n            // If we see a closed\
    \ bracket, check to see if the stack is empty.\n            // If it is empty,\
    \ then return false, since we have a closed bracket with\n            // no corresponding\
    \ open bracket.\n            else if (letter == ']') {\n                if (openBrackets.isEmpty)\
    \ return false\n                // Otherwise, pop an open bracket from the stack.\n\
    \                openBrackets.pop\n            }\n        }\n        // If the\
    \ stack is empty, return false. Otherwise, return true.\n        !openBrackets.isEmpty",
  "        val stack = new Stack[Char]\n        for (char <- string) {\n         \
    \   if (char == '[') {\n                stack.push(char)\n            } else {\n\
    \                if (stack.isEmpty) {\n                    return false\n    \
    \            } else {\n                    stack.pop\n                }\n    \
    \        }\n        }\n        !stack.isEmpty", "        var stack = new Stack[Char]()\n\
    \        for (i <- 0 until string.length) {\n            if (string(i) == '[')\
    \ {\n                stack.push(string(i))\n            } else {\n           \
    \     if (stack.size == 0) {\n                    return false\n             \
    \   } else {\n                    stack.pop()\n                }\n           \
    \ }\n        }\n        if (stack.size == 0) {\n            return false\n   \
    \     } else {\n            return true\n        }", "        var stack = List[Char]()\n\
    \        for (c <- string) {\n            if (c == '[') {\n                stack\
    \ = c :: stack\n            } else if (c == ']') {\n                if (stack.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        stack = stack.tail\n                }\n            }\n        }\n   \
    \     if (stack.isEmpty) {\n            return false\n        } else {\n     \
    \       return true\n        }", "        val stack = Stack[Char]()\n        for\
    \ (character <- string) {\n            if (character == '[') stack.push(character)\n\
    \            else if (character == ']') {\n                if (stack.isEmpty)\
    \ return false\n                else stack.pop\n            }\n        }\n   \
    \     if (stack.isEmpty) return false\n        for (i <- 0 until stack.length)\
    \ {\n            if (stack(i) == '[') return true\n        }\n        return false",
  "        var stack = List[Char]()\n        var parenthese : Array[Char] = Array('(',\
    \ ')', '[', ']', '{', '}')\n        for (s <- string) {\n            if (s ==\
    \ parenthese(0) || s == parenthese(2) || s == parenthese(4)) {\n             \
    \   stack = s :: stack\n            } else if ((s == parenthese(1) && stack.nonEmpty\
    \ && stack.head == parenthese(0)) ||\n                       (s == parenthese(3)\
    \ && stack.nonEmpty && stack.head == parenthese(2)) ||\n                     \
    \  (s == parenthese(5) && stack.nonEmpty && stack.head == parenthese(4))) {\n\
    \                stack = stack.tail\n            } else {\n                return\
    \ false\n            }\n        }\n        return stack.isEmpty", "        if\
    \ (string.length == 0) return false\n        var stack = new Stack[Char]\n   \
    \     for (c <- string) {\n            if (c == '[') stack.push(c)\n         \
    \   else {\n                if (stack.length == 0) return false\n            \
    \    stack.pop\n            }\n        }\n        if (stack.length == 0) true\
    \ else false", "        def isNested(string : String, depth : Int, flag : Boolean)\
    \ : Boolean = {\n            if (string.length == 0) {\n                depth\
    \ == 0 && flag\n            } else {\n                if (string.charAt(0) ==\
    \ '[') {\n                    isNested(string.substring(1), depth + 1, true)\n\
    \                } else {\n                    if (depth == 0) false\n       \
    \             else isNested(string.substring(1), depth - 1, flag)\n          \
    \      }\n            }\n        }\n        isNested(string, 0, false)", "   \
    \     var stack = Stack[Char]()\n        for (letter <- string) {\n          \
    \  if (letter == '[') stack.push(letter)\n            else if (letter == ']')\
    \ {\n                if (stack.isEmpty) return false\n                stack.pop\n\
    \            }\n        }\n        if (stack.isEmpty) true else false", "    \
    \    var stack = Stack[String]()\n        for (i <- 0 until string.length) {\n\
    \            if (string(i) == '[') {\n                stack.push(\"[\")\n    \
    \        } else {\n                if (stack.isEmpty) {\n                    return\
    \ false\n                } else {\n                    stack.pop\n           \
    \     }\n            }\n        }\n        if (stack.isEmpty) {\n            return\
    \ true\n        } else {\n            return false\n        }", "        var stack\
    \ = new Stack[Char]\n        for (c <- string) {\n            if (c == '[') stack.push(c)\n\
    \            else if (c == ']') {\n                if (stack.size == 0) return\
    \ false\n                else stack.pop\n            }\n        }\n        stack.size\
    \ == 0", "        def getDepth(string : String) : Int = {\n            var depth\
    \ = 0\n            for (ch <- string) {\n                if (ch == '[') depth\
    \ += 1\n                else if (ch == ']') depth -= 1\n                if (depth\
    \ < 0) return -1\n            }\n            return depth\n        }\n       \
    \ def getBracketIndices(string : String) : List[Int] = {\n            var indices\
    \ = List[Int]()\n            for (i <- 0 until string.length) {\n            \
    \    if (string(i) == '[' || string(i) == ']') indices = indices :+ i\n      \
    \      }\n            return indices\n        }\n        def chop(string : String,\
    \ indices : List[Int]) : String = {\n            var result = string\n       \
    \     for (index <- indices) {\n                result = result.substring(0, index)\
    \ + result.substring(index + 1)\n            }\n            return result\n  \
    \      }\n        if (getDepth(string) != 0) return false\n        val bracketIndices\
    \ = getBracketIndices(string)\n        val bracketIndicesCombinations = bracketIndices.combinations(bracketIndices.length\
    \ / 2).toList\n        for (combination <- bracketIndicesCombinations) {\n   \
    \         if (getDepth(chop(string, combination)) == 0) return true\n        }\n\
    \        return false", "    \tval stack = Stack[Char]()\n    \tval openBrackets\
    \ = Set('[')\n    \tval closedBrackets = Set(']')\n    \tfor (c <- string) {\n\
    \    \t\tif (openBrackets.contains(c)) {\n    \t\t\tstack.push(c)\n    \t\t} else\
    \ if (closedBrackets.contains(c)) {\n    \t\t\tif (stack.isEmpty) {\n    \t\t\t\
    \treturn false\n    \t\t\t} else {\n    \t\t\t\tstack.pop\n    \t\t\t}\n    \t\
    \t}\n    \t}\n    \treturn !stack.isEmpty", "        var stack = Stack[Char]()\n\
    \        for (i <- 0 until string.length) {\n            if (string(i) == '[')\
    \ stack.push('[')\n            else {\n                if (stack.isEmpty) return\
    \ false\n                else stack.pop\n            }\n        }\n        return\
    \ true", "        val stack = new Stack[Char]\n        for (ch <- string) {\n\
    \            if (ch == '[') stack.push(ch)\n            else if (ch == ']') {\n\
    \                if (stack.isEmpty) return false\n                else stack.pop\n\
    \            }\n        }\n        stack.isEmpty", "        val arr = string.toCharArray()\n\
    \        val stack = new Stack[Char]()\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) == '[') stack.push(arr(i))\n            else if (arr(i)\
    \ == ']') {\n                if (stack.isEmpty || stack.pop() != '[') return false\n\
    \            }\n        }\n        stack.isEmpty", "        var left_buffer =\
    \ 0\n        var right_buffer = 0\n        for (c <- string) {\n            if\
    \ (c == '[') {\n                left_buffer += 1\n            } else {\n     \
    \           if (left_buffer > 0) {\n                    left_buffer -= 1\n   \
    \             } else {\n                    right_buffer += 1\n              \
    \  }\n            }\n        }\n        left_buffer == 0 && right_buffer == 0",
  "        // use a stack\n        val stack = Stack[Char]()\n        for (c <- string)\
    \ {\n            if (c == '[') stack.push(c)\n            else if (c == ']') {\n\
    \                if (stack.isEmpty) return false\n                stack.pop\n\
    \            }\n        }\n        return !stack.isEmpty", "        val stack\
    \ = new Stack[Char]\n        var res = false\n        for (c <- string) {\n  \
    \          if (c == '[') {\n                stack.push(c)\n            } else\
    \ {\n                // Make sure the stack is not empty before popping off an\
    \ element\n                if (!stack.isEmpty) {\n                    stack.pop\n\
    \                    res = true\n                }\n            }\n        }\n\
    \        res", "        // Sanity check the input. If an opening bracket is present,\
    \ we must have a matching closing bracket.\n        if (string.count(_ == '[')\
    \ != string.count(_ == ']')) {\n            return false\n        }\n        //\
    \ Walk backwards and check if we find a matching opening bracket.\n        var\
    \ count = 0\n        var nested = false\n        for (i <- string.length - 1 to\
    \ 0 by -1) {\n            if (string(i) == ']') {\n                count += 1\n\
    \            } else if (string(i) == '[') {\n                if (count > 0) {\n\
    \                    nested = true\n                }\n                count -=\
    \ 1\n            }\n        }\n        return nested", "        val stack = Stack[Char]()\n\
    \        var subseq = false\n        for (c <- string) {\n            if (c ==\
    \ '[') {\n                if (stack.isEmpty) subseq = true\n                stack.push(c)\n\
    \            } else {\n                if (stack.isEmpty) return false\n     \
    \           stack.pop\n            }\n        }\n        if (stack.isEmpty) subseq\n\
    \        else false", "        var left = 0\n        var right = 0\n        var\
    \ i = 0\n        var result = false\n        while (i < string.length) {\n   \
    \         if (string(i) == '[') {\n                left += 1\n            } else\
    \ {\n                right += 1\n            }\n            if (right > left)\
    \ {\n                return false\n            }\n            if (left == right)\
    \ {\n                result = true\n            }\n            i += 1\n      \
    \  }\n        return result", "        // Helper method that checks if a string\
    \ is balanced at a given index.\n        def isBalanced(string : String, index\
    \ : Int) : Boolean = {\n            // If the string is empty, then it is balanced.\n\
    \            if (string.isEmpty) true\n            // Else, check that the first\
    \ and last characters in the string\n            // are opening and closing brackets\
    \ respectively.\n            else if (string.head == '[' && string.last == ']')\
    \ {\n                // If so, then this string is balanced, so call the helper\
    \ method\n                // on the substring without the opening and closing\
    \ brackets.\n                isBalanced(string.substring(1, string.length - 1),\
    \ index + 1)\n            }\n            // If the first character is an opening\
    \ bracket and the last character\n            // is not a closing bracket, check\
    \ that the remaining string from\n            // the last character to the end\
    \ is balanced.\n            else if (string.head == '[' && string.last != ']')\
    \ {\n                // If the remaining string is not balanced, then this string\n\
    \                // is not balanced.\n                if (!isBalanced(string.substring(index,\
    \ string.length), index)) false\n                // Else, the remaining string\
    \ is balanced.\n                else {\n                    // Check that the\
    \ remaining string from the second character\n                    // to the last\
    \ character is balanced.\n                    if (!isBalanced(string.substring(1,\
    \ string.length - 1), index + 1)) false\n                    // Else, this string\
    \ is balanced.\n                    else true\n                }\n           \
    \ }\n            // If the first character is not an opening bracket, then this\
    \ string\n            // is not balanced.\n            else false\n        }\n\
    \        // Check that the string is balanced at the first index.\n        isBalanced(string,\
    \ 0)", "        def isNested(string : String, stack : ArrayBuffer[Char]) : Boolean\
    \ = {\n            if (string.isEmpty) {\n                stack.isEmpty\n    \
    \        } else {\n                val head = string.head\n                val\
    \ tail = string.tail\n                if (head == '[') {\n                   \
    \ stack.append(head)\n                    isNested(tail, stack)\n            \
    \    } else {\n                    if (stack.isEmpty) {\n                    \
    \    false\n                    } else {\n                        stack.remove(stack.length\
    \ - 1)\n                        isNested(tail, stack)\n                    }\n\
    \                }\n            }\n        }\n        isNested(string, ArrayBuffer[Char]())",
  "        // Create a function\n        def helper(string : String, level : Int,\
    \ isNested : Boolean) : Boolean = {\n            if (string.isEmpty) isNested\n\
    \            else if (string.head == '[') helper(string.tail, level + 1, true)\n\
    \            else if (string.head == ']') helper(string.tail, level - 1, isNested)\n\
    \            else helper(string.tail, level, isNested)\n        }\n        //\
    \ Call helper function\n        helper(string, 0, false)", "        if (string.length\
    \ == 0) return false\n        else {\n            var isNested = false\n     \
    \       var n = 0\n            while (n < string.length) {\n                if\
    \ (string(n) == '[') {\n                    var i = n\n                    while\
    \ (i < string.length) {\n                        if (string(i) == ']') {\n   \
    \                         isNested = true\n                            return\
    \ isNested\n                        }\n                        i += 1\n      \
    \              }\n                }\n                n += 1\n            }\n \
    \           return isNested\n        }", "        var openCount = 0\n        var\
    \ closeCount = 0\n        var isNested = false\n        for (bracket <- string)\
    \ {\n            if (bracket == '[') {\n                openCount += 1\n     \
    \       } else if (bracket == ']') {\n                closeCount += 1\n      \
    \      }\n            if (closeCount > openCount) {\n                return false\n\
    \            }\n            if (openCount > 0 && closeCount > 0) {\n         \
    \       isNested = true\n            }\n        }\n        isNested", "      \
    \  string.map(c => if (c == '[') 1 else -1).scanLeft(0)(_ + _).exists(_ == 0)",
  "        var stack = new Stack[Char]\n        for (ch <- string) {\n           \
    \ if (ch == '[') {\n                stack.push(ch)\n            } else {\n   \
    \             if (stack.isEmpty) {\n                    return false\n       \
    \         } else {\n                    stack.pop\n                }\n       \
    \     }\n        }\n        return true", "        var stack = new Stack[Char]()\n\
    \        for (c <- string) {\n            if (c == '[') {\n                stack.push(c)\n\
    \            } else if (c == ']') {\n                if (stack.isEmpty) {\n  \
    \                  return false\n                } else {\n                  \
    \  stack.pop()\n                }\n            }\n        }\n        if (stack.isEmpty)\
    \ {\n            return false\n        } else {\n            return true\n   \
    \     }", '        return false', "        def inner(chars : List[Char], counter\
    \ : Int) : Boolean = {\n            if (chars.isEmpty) {\n                false\n\
    \            } else {\n                val first = chars.head\n              \
    \  val rest = chars.tail\n                if (first == '[') {\n              \
    \      inner(rest, counter + 1)\n                } else {\n                  \
    \  if (counter == 0) {\n                        false\n                    } else\
    \ {\n                        true\n                    }\n                }\n\
    \            }\n        }\n        if (string.length == 0) {\n            false\n\
    \        } else {\n            inner(string.toList, 0)\n        }", "        if\
    \ (string.length() % 2 != 0) return false\n        var max_depth = 0\n       \
    \ var min_depth = 0\n        for (i <- 0 until string.length()) {\n          \
    \  val depth = (string(i) == '[') match {\n                case true => 1\n  \
    \              case false => -1\n            }\n            min_depth = min(min_depth\
    \ + depth, 0)\n            max_depth = max(max_depth + depth, 0)\n           \
    \ if (max_depth == 0 && i != string.length() - 1) return false\n        }\n  \
    \      if (min_depth != 0) return false\n        return true", "        val dp\
    \ = new HashMap[String, Boolean]\n        dp(\"\") = false\n        dp(\"[]\"\
    ) = false\n        dp(\"[[\") = false\n        dp(\"]]\") = false\n        def\
    \ check(str : String) : Boolean = {\n            if (dp.contains(str)) {\n   \
    \             dp(str)\n            } else {\n                val result = str.split(\"\
    \").foldLeft((true, true))((acc, str) => {\n                    (acc._1 && str\
    \ == \"[\", acc._2 && str == \"]\")\n                })\n                dp(str)\
    \ = (result._1 && result._2)\n                dp(str)\n            }\n       \
    \ }\n        var result = false\n        for (i <- 0 to string.length - 1) {\n\
    \            for (j <- i + 1 to string.length) {\n                result = result\
    \ || check(string.substring(i, j))\n            }\n        }\n        result",
  "        var right = false\n        var left = false\n        for (c <- string)\
    \ c match {\n            case '[' => left = true\n            case ']' => right\
    \ = true\n        }\n        return left && right", "        string.map(c => c\
    \ == '[').zip(string.map(c => c == ']').reverse).foreach(x => if (x._1 && x._2)\
    \ return true)\n        return false", "        val array = string.toArray\n \
    \       var stack = Stack[Char]()\n        var hasNested = false\n        for\
    \ (i <- 0 until array.length) {\n            val character = array(i)\n      \
    \      if (character == '[') {\n                stack.push(character)\n      \
    \      } else {\n                val top = stack.pop\n                if (top\
    \ == '[' && character == ']') {\n                    hasNested = true\n      \
    \          }\n            }\n        }\n        hasNested", "        string.head\
    \ == '[' && string.last == ']'", "        var inBracket = false\n        var bracketCount\
    \ = 0\n        var nested = false\n        for (i <- 0 until string.length) {\n\
    \            if (string(i) == '[') {\n                if (inBracket) {\n     \
    \               nested = true\n                }\n                inBracket =\
    \ true\n                bracketCount += 1\n            } else if (string(i) ==\
    \ ']') {\n                bracketCount -= 1\n                if (bracketCount\
    \ == 0) {\n                    inBracket = false\n                }\n        \
    \    }\n        }\n        return nested", "        var bracketStack = ListBuffer[Char]()\n\
    \        var currentList = ListBuffer[Char]()\n        for (c <- string) {\n \
    \           currentList += c\n            if (c == '[') {\n                bracketStack\
    \ += c\n            } else if (c == ']') {\n                if (bracketStack.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        bracketStack.remove(bracketStack.length - 1)\n                }\n   \
    \         }\n        }\n        if (bracketStack.isEmpty) {\n            return\
    \ false\n        }\n        for (i <- 0 until bracketStack.length) {\n       \
    \     if (bracketStack(i) == '[') {\n                currentList += ']'\n    \
    \        } else {\n                currentList += '['\n            }\n       \
    \ }\n        println(currentList)\n        var c = 0\n        var temp = ListBuffer[Char]()\n\
    \        while (c < currentList.length) {\n            if (currentList(c) == '[')\
    \ {\n                temp += currentList(c)\n            } else {\n          \
    \      if (temp.isEmpty) {\n                    return false\n               \
    \ } else {\n                    temp.remove(temp.length - 1)\n               \
    \ }\n            }\n            c += 1\n        }\n        return true", "   \
    \     var flag = false\n        var stack = new Stack[Char]\n        var flag2\
    \ = false\n        for (i <- 0 until string.length) {\n            if (string(i)\
    \ == '[') {\n                stack.push(string(i))\n            } else {\n   \
    \             if (stack.size > 0) {\n                    stack.pop\n         \
    \           flag = true\n                } else {\n                    flag2 =\
    \ true\n                }\n            }\n        }\n        flag && !flag2",
  "        if (string.length % 2 != 0) {\n            return false\n        }\n  \
    \      var stack = new Stack[Char]\n        for (i <- 0 until string.length) {\n\
    \            if (string(i) == '[') {\n                stack.push(string(i))\n\
    \            } else {\n                if (stack.isEmpty) {\n                \
    \    return false\n                } else {\n                    stack.pop\n \
    \               }\n            }\n        }\n        return true", "        var\
    \ count : Int = 0\n        var isNested : Boolean = false\n        for (char <-\
    \ string) {\n            if (char == '[') {\n                count += 1\n    \
    \        } else if (char == ']') {\n                count -= 1\n            }\n\
    \            if (count == 0) {\n                isNested = true\n            }\n\
    \        }\n        isNested", "        // Create a stack to hold all the left\
    \ brackets\n        val stack = new Stack[Char]\n        // Iterate through the\
    \ string and check each character\n        for (char <- string) {\n          \
    \  // If the current character is a right bracket\n            if (char == ']')\
    \ {\n                // If the stack is empty, return false because the right\
    \ bracket has no left bracket partner\n                if (stack.isEmpty) return\
    \ false\n                // Pop the top element from the stack, if the top element\
    \ is a right bracket, return false\n                if (stack.pop == '[') return\
    \ false\n            }\n            // If the current character is a left bracket,\
    \ push it to the stack\n            else if (char == '[') stack.push(char)\n \
    \       }\n        // If the stack is empty, there is a valid subsequence of brackets\n\
    \        stack.isEmpty", "        val openList = new Stack[Int]()\n        val\
    \ closeList = new Stack[Int]()\n        val openPos = string.indexOf('[')\n  \
    \      val closePos = string.indexOf(']')\n        if (openPos == -1 || closePos\
    \ == -1) {\n            return false\n        }\n        if (openPos == string.length()\
    \ - 1 || closePos == 0) {\n            return false\n        }\n        for (i\
    \ <- 0 until string.length()) {\n            val ch = string.charAt(i)\n     \
    \       if (ch == '[') {\n                openList.push(i)\n            } else\
    \ if (ch == ']') {\n                closeList.push(i)\n            }\n       \
    \ }\n        if (openList.length != closeList.length) {\n            return false\n\
    \        }\n        val len = openList.length\n        for (i <- 0 until len)\
    \ {\n            val openPos = openList.pop()\n            val closePos = closeList.pop()\n\
    \            if (openPos > closePos) {\n                return false\n       \
    \     }\n        }\n        true", "        // TODO: implement\n        return\
    \ false", "        var stack = Stack[Char]()\n        var count = 0\n        string.foreach(i\
    \ => \n            i match {\n                case '[' => {\n                \
    \    stack.push(i)\n                    count += 1\n                }\n      \
    \          case ']' => {\n                    if (stack.top == '[') {\n      \
    \                  stack.pop\n                        count -= 1\n           \
    \         }\n                }\n            }\n        )\n        return count\
    \ == 0", "        var list = Array[Char]()\n        var result = false\n     \
    \   for (c <- string) {\n            if (c == '[') list = list :+ c\n        \
    \    else {\n                if (list.length == 0) return false\n            \
    \    list = list.dropRight(1)\n                if (list.length == 0) result =\
    \ true\n            }\n        }\n        return result", "        val charArray\
    \ = string.toCharArray\n        val stack = new Stack[Int]\n        val result\
    \ = new Stack[Boolean]\n        for (i <- 0 until charArray.length) {\n      \
    \      if (charArray(i) == '[') stack.push(1)\n            else {\n          \
    \      if (stack.isEmpty) return false\n                stack.pop\n          \
    \      result.push(true)\n            }\n        }\n        if (stack.isEmpty\
    \ && result.nonEmpty) true\n        else false", '        return true', "    \
    \    val sorted = string.sorted\n        val sortedReversed = sorted.reverse\n\
    \        sorted == sortedReversed", "        var stack = new Stack[Char]()\n \
    \       var flag = false\n        for (char <- string) {\n            if (char\
    \ == '[') {\n                stack.push(char)\n            } else {\n        \
    \        if (stack.isEmpty) return false\n                stack.pop()\n      \
    \          if (stack.isEmpty) flag = true\n            }\n        }\n        if\
    \ (stack.nonEmpty) return false\n        flag", "    \tdef isValid(string : String)\
    \ : Boolean = {\n    \t\tval stack = Stack[Char]()\n    \t\tstring.foreach(x =>\
    \ {\n    \t\t\tx match {\n    \t\t\t\tcase '[' => stack.push(x)\n    \t\t\t\t\
    case ']' => if(stack.isEmpty || stack.pop != '[') return false\n    \t\t\t}\n\
    \    \t\t})\n    \t\tif(stack.isEmpty) true else false\n    \t}\n    \tfor(i <-\
    \ 0 to string.length) {\n    \t\tif(isValid(string.substring(0, i))) return true\n\
    \    \t}\n    \tfalse", "        var stack = new Stack[Char]()\n        for (i\
    \ <- 0 until string.length()) {\n            var currentChar = string.charAt(i)\n\
    \            if (currentChar == '[') {\n                stack.push(currentChar)\n\
    \            } else if (currentChar == ']') {\n                if (stack.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        stack.pop()\n                }\n            }\n        }\n        return\
    \ stack.isEmpty", "        val parens : List[String] = List(\"()\", \"[]\", \"\
    {}\")\n        // Recursively call until it comes out empty\n        def isNestedRecursive(string\
    \ : String) : Boolean = {\n            val originalString : String = string\n\
    \            // println(string)\n            // If reached the end, the string\
    \ must be nested\n            if (string.length == 0) true\n            else {\n\
    \                // First create a list of the parens\n                for (paren\
    \ <- parens) {\n                    // Replace the parens and check if the length\
    \ is reduced\n                    // If so, we have found a paren that can be\
    \ removed\n                    if (string.replace(paren, \"\").length < string.length)\
    \ {\n                        // Recursively call after removing the paren\n  \
    \                      return isNestedRecursive(string.replace(paren, \"\"))\n\
    \                    }\n                }\n                // Otherwise we haven't\
    \ found a paren and the string is not nested\n                false\n        \
    \    }\n        }\n        // Call the recursive function\n        isNestedRecursive(string)",
  "        // Loop through string, keeping track of opening brackets.\n        //\
    \ If we have seen an opening bracket and we see a closing bracket,\n        //\
    \ then at least one bracket has been nested.\n        val openingBrackets = \"\
    ([{\"\n        val closingBrackets = \")]}\"\n        val mapping = Map(\")\"\
    \ -> \"(\", \"]\" -> \"[\", \"}\" -> \"{\")\n        val stack = Stack[Char]()\n\
    \        for (char <- string) {\n            if (openingBrackets.contains(char))\
    \ {\n                stack.push(char)\n            } else if (closingBrackets.contains(char))\
    \ {\n                val top = stack.pop()\n                if (top != mapping(char))\
    \ {\n                    return false\n                }\n            }\n    \
    \    }\n        // If we have any brackets left over, they were not nested.\n\
    \        return stack.isEmpty", "        var counter = 0\n        for (char <-\
    \ string) {\n            if (char == '[') {\n                counter += 1\n  \
    \          } else if (char == ']') {\n                counter -= 1\n         \
    \   }\n            if (counter < 0) {\n                return false\n        \
    \    }\n        }\n        if (counter == 0) {\n            return false\n   \
    \     }\n        return true", "      var stack = new Stack[Char]\n      for (character\
    \ <- string) {\n        if (character == '[') {\n          stack.push(character)\n\
    \        } else if (character == ']') {\n          if (stack.length == 0) {\n\
    \            return false\n          } else {\n            stack.pop\n       \
    \   }\n        }\n      }\n      return stack.length != 0", "        if(string.length()\
    \ == 0) {\n            return false\n        }\n        val hashMap = new HashMap[Char,\
    \ Int]()\n        var bracketStack = ListBuffer[Char]()\n        var openingBracketCount\
    \ = 0\n        var closingBracketCount = 0\n        for(x <- string) {\n     \
    \       if(x == '[') {\n                openingBracketCount += 1\n           \
    \     bracketStack += x\n            } else if(x == ']') {\n                closingBracketCount\
    \ += 1\n                if(bracketStack.length > 0) {\n                    bracketStack.remove(bracketStack.length\
    \ - 1)\n                }\n            }\n        }\n        if(bracketStack.length\
    \ > 0) {\n            return false\n        }\n        var diff = abs(openingBracketCount\
    \ - closingBracketCount)\n        if(diff == 0 || diff % 2 == 0) {\n         \
    \   return true\n        }\n        return false", "        // Your code goes\
    \ here\n        val s = new Stack[Char]\n        for (c <- string) {\n       \
    \     if (c == '[') s.push(c)\n            else {\n                if (s.size\
    \ == 0) return false\n                if (s.pop() != '[') return false\n     \
    \       }\n        }\n        return s.size == 0", "        val stack = new Stack[Char]\n\
    \        var flag = false\n        string.foreach(ch => {\n            if (ch\
    \ == '[') {\n                stack.push(ch)\n            } else {\n          \
    \      if (stack.isEmpty || stack.pop != '[') return false\n                if\
    \ (stack.isEmpty) flag = true\n            }\n        })\n        if (stack.isEmpty\
    \ && flag) return true\n        false", "        var isNested = false\n      \
    \  val stack = new scala.collection.mutable.Stack[Char]\n        for (c <- string)\
    \ {\n            c match {\n                case '[' => stack.push(c)\n      \
    \          case ']' => \n                    if (stack.nonEmpty) {\n         \
    \               isNested = true\n                        stack.pop\n         \
    \           }\n            }\n        }\n        return isNested", "        var\
    \ s : List[Char] = List()\n        for (c <- string) {\n            if (c == '[')\
    \ s ::= c\n            else {\n                if (s.isEmpty) return false\n \
    \               s = s.tail\n            }\n        }\n        return true", " \
    \       var result = false\n        for (i <- 0 until string.length) {\n     \
    \       if (string(i) == '[') {\n                var current = i + 1\n       \
    \         while (current < string.length && string(current) != ']') {\n      \
    \              if (string(current) == '[') result = true\n                   \
    \ current += 1\n                }\n            }\n        }\n        result",
  "        // initialize a stack to count the number of \"[\"\n        var stack =\
    \ new Stack[Char]()\n        // loop through the string to find any \"]\"\n  \
    \      for (c <- string) {\n            if (c == ']') {\n                // if\
    \ we find a \"]\", then we need to see whether the stack contains a \"[\"\n  \
    \              if (stack.contains('[')) {\n                    // if yes, we remove\
    \ the \"[\" and continue\n                    stack.pop()\n                } else\
    \ {\n                    // if not, it is an invalid string\n                \
    \    return false\n                }\n            } else {\n                //\
    \ if we find a \"[\", push it into the stack\n                stack.push(c)\n\
    \            }\n        }\n        // if we loop through the string and the stack\
    \ is empty, return true\n        // otherwise, return false\n        if (stack.isEmpty)\
    \ {\n            true\n        } else {\n            false\n        }", "    \
    \    // A depth of 0 means that the overall brackets are balanced.\n        //\
    \ A depth of -1 means that the overall brackets are not balanced.\n        var\
    \ depth = 0\n        // Add the depth of each character together to get the depth\
    \ after the string.\n        string.foreach(char => depth += if (char == '[')\
    \ 1 else -1)\n        // If the depth after the string is 0, then it is balanced.\n\
    \        depth == 0", "    \tvar s = new Stack[Char]()\n    \tfor (i <- 0 until\
    \ string.length) {\n    \t\tstring(i) match {\n    \t\t\tcase '[' => s.push('[')\n\
    \    \t\t\tcase ']' => s.pop\n    \t\t}\n    \t}\n    \t!s.isEmpty", "       \
    \ var stack = new Stack[Char]()\n        var hasNested = false\n        for (ch\
    \ <- string) {\n            if (ch == '[') {\n                stack.push(ch)\n\
    \            } else {\n                if (stack.isEmpty) return false\n     \
    \           val pch = stack.pop\n                if (pch == '[') {\n         \
    \           hasNested = true\n                }\n            }\n        }\n  \
    \      return stack.isEmpty && hasNested", "        val stack = new Stack[Char]\n\
    \        for (char <- string) {\n            if (char == '[') {\n            \
    \    stack.push(char)\n            } else {\n                if (stack.isEmpty)\
    \ {\n                    return false\n                } else {\n            \
    \        stack.pop\n                }\n            }\n        }\n        stack.isEmpty"]
stop_tokens:
- "\n    }\n"
