name: HumanEval_43_pairs_sum_to_zero
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // pairs_sum_to_zero takes a list of integers as an input.\n    // it returns\
  \ true if there are two distinct elements in the list that\n    // sum to zero,\
  \ and false otherwise.\n    // >>> pairsSumToZero((List[Long](1l.toLong, 3l.toLong,\
  \ 5l.toLong, 0l.toLong)))\n    // (false)\n    // >>> pairsSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, -2l.toLong, 1l.toLong)))\n    // (false)\n    // >>> pairsSumToZero((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 7l.toLong)))\n    // (false)\n    // >>> pairsSumToZero((List[Long](2l.toLong,\
  \ 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (true)\n   \
  \ // >>> pairsSumToZero((List[Long](1l.toLong)))\n    // (false)\n    def pairsSumToZero(l\
  \ : List[Long]) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(pairsSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, 5l.toLong, 0l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, -2l.toLong, 1l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 7l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](2l.toLong,\
  \ 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](1l.toLong)))\
  \ == (false));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong,\
  \ 3l.toLong, 2l.toLong, 30l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](-3l.toLong,\
  \ 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 31l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](-3l.toLong,\
  \ 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 30l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](-3l.toLong,\
  \ 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 31l.toLong))) == (false));\n    }\n\
  \n}\n"
completions: ["        val h = HashSet[Long]()\n        for (i <- l) {\n         \
    \   if (h.contains(-i)) {\n                return true\n            }\n      \
    \      h.add(i)\n        }\n        return false", "        val set : Set[Long]\
    \ = l.toSet\n        val c : Int = set.count(x => set.contains(0l - x))\n    \
    \    return c > 1", "        //return true\n        if (l.size < 2) {\n      \
    \      return false\n        }\n        var map = HashMap[Long, Int]()\n     \
    \   for (i <- 0 until l.size) {\n            map(l(i)) = 1\n        }\n      \
    \  for (i <- 0 until l.size) {\n            if (map.contains(-l(i))) {\n     \
    \           return true\n            }\n        }\n        return false", "  \
    \      val sum = l.sum\n        if (sum % 2 == 0) {\n            val half_sum\
    \ = sum / 2\n            val is_half_sum_present = l.contains(half_sum)\n    \
    \        is_half_sum_present\n        } else {\n            false\n        }",
  "        // we need to loop through each element in the list\n        for (x <-\
    \ l) {\n            // and for each element we need to check if it can be added\
    \ to\n            // another element in the list to get zero\n            for\
    \ (y <- l) {\n                // but we can't add an element to itself because\
    \ obviously\n                // it will not be zero\n                if (x !=\
    \ y) {\n                    // so if x + y is zero then we found two numbers that\
    \ sum\n                    // to zero, return true\n                    if (x\
    \ + y == 0) return true\n                }\n            }\n        }\n       \
    \ // otherwise return false because we did not find any numbers that\n       \
    \ // sum to zero\n        return false", "        val buffer = new HashSet[Long]\n\
    \        for (x <- l) {\n            if (buffer.contains(-x)) return true\n  \
    \          buffer.add(x)\n        }\n        return false", "        var s : Set[Long]\
    \ = Set[Long]()\n        l.foreach((x : Long) => {\n            if (s.contains(-x))\
    \ return true\n            s = s + x\n        })\n        return false", '        l.combinations(2).filter(i
    => i(0) + i(1) == 0).size > 0', "        // We use a set to speed up the computation.\n\
    \        val s = Set[Long]()\n        for (x <- l) {\n            if (s.contains(-x))\
    \ {\n                return true\n            }\n            s.add(x)\n      \
    \  }\n        return false", "        val h = HashSet[Long]()\n        for (x\
    \ <- l) {\n            if (h.contains(-x)) return true\n            h += x\n \
    \       }\n        return false", "        var sumZero : Boolean = false\n   \
    \     var i : Int = 0\n        var j : Int = 1\n        while ((i < l.length)\
    \ && (!sumZero)) {\n            j = i + 1\n            while ((j < l.length) &&\
    \ (!sumZero)) {\n                if ((l(i) + l(j)) == 0) {\n                 \
    \   sumZero = true\n                }\n                j = j + 1\n           \
    \ }\n            i = i + 1\n        }\n        return sumZero", "        val nums\
    \ = l.sorted\n        var left = 0\n        var right = nums.length - 1\n    \
    \    while (left < right) {\n            val sum = nums(left) + nums(right)\n\
    \            if (sum == 0) return true\n            else if (sum < 0) left +=\
    \ 1\n            else right -= 1\n        }\n        return false", "        var\
    \ s : Set[Long] = Set.empty\n        l.foreach(i => if (s.contains(-i)) return\
    \ true else s += i)\n        return false", "        var d = scala.collection.mutable.HashSet[Long]()\n\
    \        for (n <- l) {\n            if (d.contains(-n)) {\n                return\
    \ true\n            }\n            d.add(n)\n        }\n        return false",
  "        var s = l.toSet\n        var t = l.toSet\n        var sum = 0l\n      \
    \  while (!s.isEmpty) {\n            sum = 0 - s.head\n            s = s.tail\n\
    \            if (t.contains(sum)) {\n                return true\n           \
    \ }\n        }\n        return false", "        // Your code here\n        val\
    \ distinct_values = l.distinct\n        if (distinct_values.length < 2) {\n  \
    \          return false\n        }\n        else {\n            val set = distinct_values.toSet\n\
    \            distinct_values.foreach { x =>\n                if (set.contains(-x))\
    \ {\n                    return true\n                }\n            }\n     \
    \       return false\n        }", "        // your code here\n        return false",
  "        // Set is a mutable (unlike immutable list) collection of unique elements.\n\
    \        // this has the advantage of being much faster at checking if an element\n\
    \        // is in the set.\n        var s = Set[Long]()\n        for (i <- l)\
    \ {\n            if (s.contains(-i)) {\n                return true\n        \
    \    }\n            s += i\n        }\n        return false", "        l.length\
    \ match {\n            case 0 => false\n            case 1 => false\n        \
    \    case _ => {\n                val zero:HashSet[Long] = new HashSet[Long]()\n\
    \                for (i <- 0 until l.length) {\n                    zero.add(l(i))\n\
    \                }\n                for (i <- 0 until l.length) {\n          \
    \          if (zero.contains(-l(i))) {\n                        return true\n\
    \                    }\n                }\n                return false\n    \
    \        }\n        }", "        // TODO: implement this function\n        return\
    \ false", "        if (l.length <= 1) false\n        else {\n            var m\
    \ = new HashMap[Long, Int]\n            for (x <- l) {\n                if (m.contains(x))\
    \ m(x) += 1\n                else m(x) = 1\n            }\n            for (x\
    \ <- l) if (m.contains(-x)) return true\n            false\n        }", "    \
    \  var l1 = l\n      while (l1.length > 1) {\n        if (l1.tail.contains(0l\
    \ - l1.head)) return true\n        l1 = l1.tail\n      }\n      return false",
  "        if (l.isEmpty) false\n        else {\n            val result = l.map(n\
    \ => -n).intersect(l)\n            if (result.size == 2) true\n            else\
    \ false\n        }", "      val l2 = l.toSet\n      val l3 = l2.subsets.filter(s\
    \ => s.size == 2).filter(s => s.reduceLeft(_ + _) == 0).size > 0\n      val l4\
    \ = if (l3) true else false\n      l4", '        return l.isEmpty || l.length
    == 1', "        // YOUR CODE HERE\n        return false", "        // your code\
    \ here\n        var flag = false\n        var map = HashMap[Long, Long]()\n  \
    \      for (i <- l) {\n            if (map.contains(i))\n                flag\
    \ = true\n            else \n                map += (i -> 0)\n        }\n    \
    \    for (i <- l) {\n            if (map.contains(-i))\n                flag =\
    \ true\n            else \n                map += (-i -> 0)\n        }\n     \
    \   return flag", "        // you can write a single line of code that uses some\
    \ Scala library\n        // functions to do this. but you shouldn't do it in a\
    \ single line.\n        // you should write readable code.\n        var m = new\
    \ HashMap[Long, Long]()\n        for (x <- l) {\n            if (m.contains(x))\
    \ {\n                return true\n            }\n            else {\n        \
    \        m.put(x, -x)\n            }\n        }\n        false", '        null',
  '        false', "        // The algorithm is simple.\n        // We traverse the\
    \ list using an index.\n        // If we find two elements that sum to zero, we\
    \ return true.\n        // Otherwise, we return false.\n        // The algorithm\
    \ runs in O(n) time.\n        // The algorithm runs in O(1) space.\n        var\
    \ i = 0\n        while (i < l.length) {\n            var j = i + 1\n         \
    \   while (j < l.length) {\n                if (l(i) + l(j) == 0) {\n        \
    \            return true\n                }\n                j += 1\n        \
    \    }\n            i += 1\n        }\n        return false", "        if (l.length\
    \ == 0) return false\n        for (i <- l) {\n            for (j <- l) {\n   \
    \             if (i != j && i + j == 0) return true\n            }\n        }\n\
    \        return false", '        return false', "        var map = ListMap[Long,\
    \ Int]()\n        for (x <- l) {\n            map.put(x, map.getOrElse(x, 0) +\
    \ 1)\n        }\n        for (x <- l) {\n            val y = -x\n            if\
    \ (x == y) {\n                if (map.getOrElse(x, 0) >= 2) {\n              \
    \      return true\n                }\n            } else {\n                if\
    \ (map.contains(y)) {\n                    return true\n                }\n  \
    \          }\n        }\n        return false", "        def pairsSumToZeroHelper(l\
    \ : List[Long], s : Set[Long]) : Boolean = {\n            // base case\n     \
    \       if (l.isEmpty) {\n                false\n            } else {\n      \
    \          // recursive case\n                val first = l.head\n           \
    \     val rest = l.tail\n                val new_s = s + first\n             \
    \   if (new_s.contains(0l - first)) {\n                    true\n            \
    \    } else {\n                    pairsSumToZeroHelper(rest, new_s)\n       \
    \         }\n            }\n        }\n        pairsSumToZeroHelper(l, Set[Long]())",
  "        if (l.length < 2) {\n            return false\n        }\n        l.tail.foreach((x\
    \ : Long) => {\n            if (l.contains(-x)) {\n                return true\n\
    \            }\n        })\n        return false", "        def f(l : List[Long],\
    \ i : Int) : Boolean = {\n            if (i >= l.length) false\n            else\
    \ if (i == l.length - 1) l.contains(-l(i))\n            else if (l.contains(-l(i)))\
    \ true\n            else f(l, i + 1)\n        }\n        f(l, 0)", "        val\
    \ m = l.toSet.groupBy(x => x)\n        m.keys.map(x => if (m.contains(-x)) true\
    \ else false).contains(true)", "        // The time complexity of pairsSumToZero\
    \ is O(n^2) where n is the size of l\n        // and the space complexity is O(1).\n\
    \        var sums = ListBuffer[Long]()\n        var pairs = ListBuffer[(Long,\
    \ Long)]()\n        for (i <- 0 until l.length) {\n            for (j <- 0 until\
    \ l.length) {\n                if (i != j) {\n                    if (!sums.contains(l(i)\
    \ + l(j))) {\n                        sums += (l(i) + l(j))\n                \
    \        pairs += ((l(i), l(j)))\n                    }\n                }\n \
    \           }\n        }\n        var result = false\n        for (i <- 0 until\
    \ pairs.length) {\n            if (pairs(i)._1 + pairs(i)._2 == 0) {\n       \
    \         result = true\n            }\n        }\n        return result", " \
    \       // TODO: replace the line below with the correct answer.\n        return\
    \ false", '        l.toSet.subsets(2).exists(_.sum == 0)', "        // >>> pairsSumToZero((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong, 0l.toLong)))\n        // (false)\n        // >>> pairsSumToZero((List[Long](1l.toLong,\
    \ 3l.toLong, -2l.toLong, 1l.toLong)))\n        // (false)\n        // >>> pairsSumToZero((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 7l.toLong)))\n        // (false)\n        // >>> pairsSumToZero((List[Long](2l.toLong,\
    \ 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n        // (true)\n\
    \        // >>> pairsSumToZero((List[Long](1l.toLong)))\n        // (false)\n\
    \        if (l.length < 2) return false\n        val n = l.length\n        val\
    \ s = l.toSet\n        var result = false\n        for (i <- 0 until n) {\n  \
    \          if (s.contains(-l(i))) {\n                result = true\n         \
    \       return result\n            }\n        }\n        result", "        var\
    \ i : Int = 0\n        var j : Int = 0\n        for (i <- 0 to l.length - 1) {\n\
    \            for (j <- i + 1 to l.length - 1) {\n                if (l(i) + l(j)\
    \ == 0) return true\n            }\n        }\n        return false", "      \
    \  // fill in your implementation here\n        return false", "        // This\
    \ method should be completed using a folding operation\n        // The function\
    \ used in the folding operation will have to\n        // create a map, for example\
    \ with a mutable.HashMap.\n        // The map will be used to check if a given\
    \ element\n        // of the list has a twin (an element that sums to zero)\n\
    \        // in the list, and to check if that element has been seen\n        //\
    \ before (this is a requirement for the value of the twin\n        // to be in\
    \ the map).\n        //\n        // Note that you do not have to return the map\
    \ you are\n        // creating, only return true if there is a pair of values\n\
    \        // that sum to zero.\n        //\n        // val map = HashMap[Long,\
    \ Boolean]()\n        // l.foldLeft(map)(/* TODO */ )\n        // map.containsValue(true)\n\
    \        l.foldLeft(HashMap[Long, Boolean]())((acc, x) => if (acc.contains(x *\
    \ -1)) { acc.put(x, true); acc } else { acc.put(x, false); acc }).containsValue(true)",
  '        l.exists(x => l.contains(-x) && x != 0)', "        // your code here\n\t\
    \tvar hashSet = scala.collection.mutable.HashSet[Long]()\n\t\tfor(item <- l){\n\
    \t\t\tif(hashSet.contains(-item)){\n\t\t\t\treturn true\n\t\t\t}\n\t\t\thashSet.add(item)\n\
    \t\t}\n\t\tfalse", "      val m = scala.collection.mutable.HashMap[Long, Int]()\n\
    \      for (x <- l) {\n        if (m.contains(x)) {\n          m.update(x, m(x)\
    \ + 1)\n        } else {\n          m += (x -> 1)\n        }\n      }\n      for\
    \ (x <- l) {\n        if (m.contains(-x)) {\n          if (-x == x && m(-x) <\
    \ 2) {\n            m.remove(-x)\n          } else {\n            return true\n\
    \          }\n        }\n      }\n      return false", "        var psum = l.zipWithIndex.map(x\
    \ => (x._1, x._2)).groupBy(x => x._1).map(x => (x._1, x._2.map(y => y._2))).toList\n\
    \        psum.foreach(x => {\n            if (x._2.length > 1) {\n           \
    \     return true\n            }\n        })\n        psum = psum.map(x => (x._1,\
    \ (psum.map(y => (x._1 + y._1, y._2)).filter(z => !z._2.isEmpty)))).filter(x =>\
    \ !x._2.isEmpty)\n        psum.foreach(x => {\n            x._2.foreach(y => {\n\
    \                if (x._2.length != y._2.length) {\n                    if (!(x._2.map(z\
    \ => z._2).flatten.distinct).intersect(y._2.flatten.distinct).isEmpty) {\n   \
    \                     return true\n                    }\n                }\n\
    \            })\n        })\n        false", "        if (l.length < 2) {\n  \
    \          return false\n        }\n        val h = new HashSet[Long]\n      \
    \  for (i <- 0 until l.length) {\n            val x = l(i)\n            if (h.contains(-x))\
    \ {\n                return true\n            }\n            h.add(x)\n      \
    \  }\n        return false", "        var s = Set[Long]()\n        for (i <- l)\
    \ s.add(i)\n        for (i <- l) {\n            if (s.contains(-i)) return true\n\
    \        }\n        return false", "      var list = l.toSet\n      var res =\
    \ false\n      list.foreach(x => if(list.contains(-x)) res = true)\n      res",
  '        l.indices.exists(i => l.indices.exists(j => l(i) + l(j) == 0 && j != i))',
  "        val set = new HashSet[Long]()\n        for (x <- l) {\n            if (set.contains(-x))\
    \ {\n                return true\n            }\n            set.add(x)\n    \
    \    }\n        return false", "        var s = l.toSet\n        for (e <- s)\
    \ {\n            if (s.contains(-e)) return true\n        }\n        return false",
  "        // YOUR CODE HERE\n        var set = new mutable.HashSet[Long]\n      \
    \  for (i <- l) {\n            if (set.contains(-i)) {\n                return\
    \ true\n            }\n            set.add(i)\n        }\n        return false",
  "        val hs = new HashSet[Long]\n        for (i <- l) {\n            if (hs.contains(-i))\
    \ {\n                return true\n            }\n            hs.add(i)\n     \
    \   }\n        return false", "        // YOUR CODE HERE\n        var hashTable\
    \ = HashMap[Long, Int]()\n        if (l.length == 1) return false\n        for\
    \ (i <- 0 until l.length) {\n            if (hashTable.contains(l(i))) return\
    \ true\n            hashTable(l(i) * -1) = i\n        }\n        return false",
  "        val multiset = MultiSet(l:_*)\n        for (x <- l) {\n            if (multiset.count(_\
    \ == -x) >= 1) {\n                return true\n            }\n        }\n    \
    \    return false", "        val m = scala.collection.mutable.Map[Long, Boolean]()\n\
    \        for (x <- l) {\n            if (m.contains(-x)) return true\n       \
    \     m(x) = true\n        }\n        return false", "        // Base case, if\
    \ list is empty, then no pairs are present that could sum to zero.\n        if\
    \ (l.isEmpty) return false\n        // If l is non-empty, create a temp list that\
    \ stores the values that have been seen.\n        var temp : List[Long] = List()\n\
    \        // Iterate through the original list and compare each element in the\
    \ list with\n        // the remaining elements in the list. If any of the remaining\
    \ elements sum\n        // to zero with the element that we are checking, return\
    \ true. Otherwise, add\n        // the element that we are checking to the temp\
    \ list, so that it is known that we\n        // have seen this element. If none\
    \ of the elements in the list sum to zero, then\n        // return false at the\
    \ end of the function.\n        for (e <- l) {\n            for (e1 <- l.filterNot(_\
    \ == e)) {\n                if (e + e1 == 0) return true\n            }\n    \
    \        temp = e :: temp\n        }\n        false", "        // Create a hashtable\
    \ and add the first element of l to it.\n        val h = HashMap[Long, Boolean]()\n\
    \        h.update(l.head, true)\n        for (x <- l.tail) {\n            // If\
    \ the negative of the current element of l is in the hashtable,\n            //\
    \ return true.\n            if (h.contains(-x)) return true\n            // Otherwise,\
    \ add the current element of l to the hashtable.\n            h.update(x, true)\n\
    \        }\n        // If we iterate through l without finding two numbers that\
    \ sum to zero,\n        // return false.\n        false", "        var seen =\
    \ Set[Long]()\n        for (i <- l) {\n            if (seen.contains(-i)) {\n\
    \                return true\n            }\n            seen = seen + i\n   \
    \     }\n        return false", "        if (l.length == 0) {\n            return\
    \ false\n        }\n        var m = new HashMap[Long, Boolean]()\n        for\
    \ (x <- l) {\n            m.put(x, true)\n        }\n        for (x <- l) {\n\
    \            if (m.contains(-x)) {\n                return true\n            }\n\
    \        }\n        return false", "        // return your solution by replacing\
    \ the default return value\n        false", "        // Your code here\n     \
    \   l.combinations(2).map(x => x.sum).contains(0)", "        var list = l.sorted\n\
    \        var i = 0\n        while (i < list.length) {\n            var j = list.length\
    \ - 1\n            while (j > i) {\n                if (list(i) + list(j) == 0)\
    \ {\n                    return true\n                }\n                j -=\
    \ 1\n            }\n            i += 1\n        }\n        return false", "  \
    \      var s : HashSet[Long] = new HashSet[Long]()\n        for (v <- l) {\n \
    \           if (s.contains(-v)) {\n                return true\n            }\n\
    \            s.add(v)\n        }\n        return false", "        val s = new\
    \ HashSet[Long]()\n        for (i <- l) {\n            if (s.contains(-i)) return\
    \ true\n            s.add(i)\n        }\n        return false", "        // This\
    \ is wrong. It should return false even if there are pairs that sum to zero.\n\
    \        // Make sure you test it on the examples.\n        l.contains(0)", " \
    \       var set = Set[Long]()\n        for (x <- l) {\n            if (set.contains(-x))\
    \ {\n                return true\n            }\n            set += x\n      \
    \  }\n        return false", "        val mySet = l.toSet\n        for (\n   \
    \         i <- l;\n            if (mySet.contains(-i))\n        ) return true\n\
    \        return false", "        // Fill in this function.\n        // You can\
    \ use an intermediate data structure if you would like.\n        // You can use\
    \ any combination of Scala's mutable and immutable data structures.\n        var\
    \ i = 0;\n        var list = scala.collection.mutable.Set[Long]()\n        var\
    \ notFound = true\n        if (l.length == 1) {\n            return false\n  \
    \      }\n        while (i < l.length && notFound) {\n            if (list.contains(0-l(i)))\
    \ {\n                notFound = false\n            }\n            else {\n   \
    \             list.add(l(i))\n            }\n            i += 1\n        }\n \
    \       return !notFound", "        val s = Set[Long]()\n        l.foreach { x\
    \ =>\n            if (s.contains(-x)) return true\n            s += x\n      \
    \  }\n        false", "        // findPairs takes a list of integers, a set of\
    \ integers, and a set of\n        // pairs of integers as an input.  It uses these\
    \ parameters to\n        // recursively find all pairs of distinct integers in\
    \ the input list\n        // that sum to zero.  It returns a tuple of a boolean,\
    \ representing\n        // whether it found any such pairs, and a set of such\
    \ pairs.\n        def findPairs(l : List[Long], singletonSet : Set[Long], pairSet\
    \ : Set[Tuple2[Long, Long]]) : Tuple2[Boolean, Set[Tuple2[Long, Long]]] = {\n\
    \            // base case: if the list is empty, return (false, pairSet)\n   \
    \         if (l.isEmpty) {\n                return ((false, pairSet))\n      \
    \      }\n            // if the head of the list is in the singleton set, add\
    \ it to the\n            // pair set and return (true, pairSet)\n            if\
    \ (singletonSet.contains(l.head)) {\n                return ((true, pairSet +\
    \ ((l.head, -l.head))))\n            }\n            // otherwise, recursively\
    \ find pairs using the tail of the list and\n            // a new singleton set\
    \ that contains the head of the list, plus the\n            // current singleton\
    \ set\n            else {\n                val nextSingletonSet = singletonSet\
    \ + l.head\n                val nextPairSet = pairSet\n                return\
    \ findPairs(l.tail, nextSingletonSet, nextPairSet)\n            }\n        }\n\
    \        val (foundPairs, pairs) = findPairs(l, Set[Long](), Set[Tuple2[Long,\
    \ Long]]())\n        return foundPairs", "        val s = l.toSet\n        l.foreach(i\
    \ => if (s.contains(-i)) return true)\n        false", "        if (l.length <\
    \ 2) {\n            return false\n        }\n        var seen = ArrayBuffer[Long]()\n\
    \        for (e <- l) {\n            if (seen.contains(-e)) {\n              \
    \  return true\n            }\n            seen += e\n        }\n        return\
    \ false", "        var result : Boolean = false\n        val visited = new HashSet[Long]()\n\
    \        for (x <- l) {\n            val y = -x\n            if (visited.contains(y))\
    \ {\n                result = true\n            }\n            visited.add(x)\n\
    \        }\n        return result", "        // >>> your_code_here\n        return\
    \ false", "        if (l.length == 0)\n            return false\n        if (l.length\
    \ == 1)\n            return false\n        val set = new HashSet[Long]()\n   \
    \     for (e <- l) {\n            if (set.contains(-e))\n                return\
    \ true\n            set.add(e)\n        }\n        return false", "        val\
    \ set = l.toSet\n        val flag = false\n        var i = 0\n        while (i\
    \ < l.length) {\n            if (set.contains(-l(i))) {\n                flag\
    \ == true\n            }\n            i += 1\n        }\n        flag", '        false',
  "        // we use sets to search for integers in l\n        val set = Set[Long]()\n\
    \        for (num <- l) {\n            // if -num is in set, then we have found\
    \ a pair of integers that sum to zero\n            if (set.contains(-num)) {\n\
    \                return true\n            }\n            // otherwise, add num\
    \ to the set\n            set.add(num)\n        }\n        // if we go through\
    \ all the elements of l and don't find a pair that sums to zero,\n        // then\
    \ we can just return false\n        return false", "        if (l.length == 0)\
    \ {\n            false\n        } else {\n            var myset = Set[Long]()\n\
    \            for (i <- l) {\n                if (myset.contains(i)) {\n      \
    \              return true\n                } else {\n                    myset\
    \ += -i\n                }\n            }\n            false\n        }", "  \
    \      val set = Set[Long]()\n        for (a <- l) {\n            val b = -a\n\
    \            if (set.contains(b)) {\n                return true\n           \
    \ }\n            set.add(a)\n        }\n        return false", "        val d\
    \ : scala.collection.mutable.HashSet[Long] = new scala.collection.mutable.HashSet[Long]()\n\
    \        var r : Boolean = false\n        var i : Long = 0l\n        while (i\
    \ < l.length && !r) {\n            {\n                if (d.contains(-l(i.toInt)))\
    \ {\n                    r = true\n                }\n                else {\n\
    \                    d.add(l(i.toInt))\n                }\n            }\n   \
    \         ({\n                i += 1; i - 1\n            })\n        }\n     \
    \   return r", '        return l.exists((x : Long) => l.contains(-x))', "    \
    \    val set1 = new HashSet[Long]\n        for (i <- l) {\n            if (set1.contains(-i))\
    \ return true\n            set1 += i\n        }\n        return false", "    \
    \    var m = Map[Long, Long]()\n        for (i <- l) {\n            if (m.contains(i))\
    \ {\n                return true\n            }\n            else {\n        \
    \        m += (-i -> i)\n            }\n        }\n        return false", "  \
    \      // Write a correct implementation for this function.\n        val buf =\
    \ l.toBuffer\n        val sorted = buf.sorted\n        for (i <- 0 until sorted.length)\
    \ {\n          for (j <- i + 1 until sorted.length) {\n            if (sorted(i)\
    \ + sorted(j) == 0) return true\n          }\n        }\n        return false",
  "        if (l.isEmpty) {\n            false\n        } else {\n            val\
    \ xs = l.sorted\n            var (i,j) = (0,xs.length-1)\n            while (i\
    \ < j) {\n                val (a,b) = (xs(i),xs(j))\n                if (a + b\
    \ == 0) {\n                    return true\n                } else if (a + b <\
    \ 0) {\n                    i += 1\n                } else {\n               \
    \     j -= 1\n                }\n            }\n            false\n        }",
  "        val array = l.toArray\n        val set = new HashSet[Long]\n        for\
    \ (i <- 0 until array.length) {\n            val elem = array(i)\n           \
    \ if (set.contains(-elem)) return true\n            set.add(elem)\n        }\n\
    \        return false", "        var hm = new HashMap[Long, Long]\n        for\
    \ (i <- l) {\n            if (hm.contains(i)) {\n                return true\n\
    \            }\n            else {\n                hm += (i -> 0)\n         \
    \   }\n        }\n        for (i <- l) {\n            if (hm.contains(-i)) {\n\
    \                return true\n            }\n        }\n        return false",
  "        val s = new HashSet[Long]()\n        var i = 0\n        for (i <- 0 until\
    \ l.length) {\n            if (s.contains(-1 * l(i))) {\n                return\
    \ true\n            }\n            s.add(l(i))\n        }\n        return false",
  "        val m = Map[Long, Int]()\n        l.foreach(v => {\n            if (m.contains(v))\
    \ m(v) += 1 else m(v) = 1\n        })\n        l.foreach(v => {\n            if\
    \ (m.contains(-v)) return true\n        })\n        return false", "      def\
    \ pairsSumToZeroHelper(l : List[Long], visited : HashSet[Long]) : Boolean = {\n\
    \        if (l.length == 0) return false\n        if (visited.contains(l.head))\
    \ return pairsSumToZeroHelper(l.tail, visited)\n        else {\n          if (visited.contains(-l.head))\
    \ return true\n          else {\n            visited.add(l.head)\n           \
    \ return pairsSumToZeroHelper(l.tail, visited)\n          }\n        }\n     \
    \ }\n      if (l.length == 0) return false\n      return pairsSumToZeroHelper(l,\
    \ new HashSet())", "        if(l.size <= 1) return false\n        var set = new\
    \ HashSet[Long]()\n        for(e <- l) {\n            if(set.contains(-e)) return\
    \ true\n            set.add(e)\n        }\n        return false", "        val\
    \ h = HashSet[Long]()\n        var flag = false\n        for (i <- l) {\n    \
    \        if (h.contains(-i)) {\n                flag = true\n            }\n \
    \           h.add(i)\n        }\n        flag", "        val v = new HashSet[Long]\n\
    \        for (x <- l) {\n            val y = -x\n            if (v.contains(y))\
    \ return true\n            v.add(x)\n        }\n        return false", "     \
    \   var sumDict = new HashMap[Long, Boolean]()\n        for (i <- l) {\n     \
    \       if (sumDict.contains(i)) {\n                return true\n            }\n\
    \            else {\n                sumDict.put(-i, true)\n            }\n  \
    \      }\n        return false", "        val distinct = l.distinct\n        for\
    \ (i <- 0 until distinct.length) {\n            for (j <- 0 until distinct.length)\
    \ {\n                if (i != j && distinct(i) + distinct(j) == 0) return true\n\
    \            }\n        }\n        return false", "        val l_with_neg = (for\
    \ (i <- l) yield -i)\n        val pairs = l.zip(l_with_neg)\n        (for (p <-\
    \ pairs) yield p._1 == p._2).exists(x => x == true)", "        val s = l.toSet\n\
    \        s.exists(x => s.contains(-x))", "        if (l.length < 2) return false\n\
    \        val s = l.toSet\n        for (i <- 0 until l.length)\n            if\
    \ (s.contains(-l(i))) return true\n        return false", "        val a : Array[Long]\
    \ = l.toArray\n        val n : Int = a.length\n        val distinct_a : Array[Long]\
    \ = a.distinct\n        val m : Int = distinct_a.length\n        val sorted_a\
    \ : Array[Long] = distinct_a.sorted\n        var b : Boolean = false\n       \
    \ for (j <- 0 to m - 1) {\n            val i : Int = (-sorted_a(j)).toInt\n  \
    \          val (ind1, ind2) : (Int, Int) = getBoundaryIndices(sorted_a, i)\n \
    \           if (ind1 != -1 && ind2 != -1) {\n                if (sorted_a(ind1)\
    \ + sorted_a(ind2) == i) {\n                    b = true\n                   \
    \ j = m\n                }\n            }\n        }\n        b", "        if\
    \ (l.length < 2) {\n            return false\n        }\n        // pairsSumToZeroHelper\
    \ returns a List[Long] that contains all distinct\n        // elements in the\
    \ input that sum to zero with the first element of the\n        // input.\n  \
    \      // >>> pairsSumToZeroHelper((List[Long](2l.toLong, 4l.toLong, -5l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong)), 2l.toLong)\n        // (List[Long](-2l.toLong))\n\
    \        // >>> pairsSumToZeroHelper((List[Long](2l.toLong, 4l.toLong, -5l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong)), 4l.toLong)\n        // (List[Long](-2l.toLong))\n\
    \        // >>> pairsSumToZeroHelper((List[Long](2l.toLong, 4l.toLong, -5l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong)), -5l.toLong)\n        // (List[Long](2l.toLong,\
    \ 7l.toLong))\n        // >>> pairsSumToZeroHelper((List[Long](2l.toLong, 4l.toLong,\
    \ -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)), 3l.toLong)\n        // (List[Long](-2l.toLong))\n\
    \        // >>> pairsSumToZeroHelper((List[Long](2l.toLong, 4l.toLong, -5l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong)), 5l.toLong)\n        // (List[Long](-5l.toLong))\n\
    \        // >>> pairsSumToZeroHelper((List[Long](2l.toLong, 4l.toLong, -5l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong)), 7l.toLong)\n        // (List[Long](-5l.toLong))\n\
    \        def pairsSumToZeroHelper(l : List[Long], n", '        l.toSet.subsets(2).map(x
    => x.toList).filter(x => x.sum == 0).size != 0', "        var h = new HashSet[Long]\n\
    \        for (i <- l) {\n            if (h.contains(-i)) return true\n       \
    \     h.add(i)\n        }\n        return false", "        val hash = scala.collection.mutable.HashSet[Long]()\n\
    \        l.foreach(x => if (hash.contains(-x)) return true else hash.add(x))\n\
    \        return false", "      var nums = l.distinct\n      for (i <- 0 until\
    \ nums.length) {\n        for (j <- i + 1 until nums.length) {\n          if (nums(i)\
    \ + nums(j) == 0) return true\n        }\n      }\n      return false", '        return
    l.size <= 1', "        // Your code here!\n        val ls = l.distinct.sorted\n\
    \        val len = ls.length\n        for (i <- 0 until len; j <- 0 until len)\
    \ {\n            if (i != j && ls(i) + ls(j) == 0) return true\n        }\n  \
    \      false", "        var s = scala.collection.mutable.Set[Long]()\n       \
    \ for (e <- l) {\n            if (s.contains(-e)) return true\n            s.add(e)\n\
    \        }\n        return false", "      //???\n      return false", "      \
    \  // REPLACE WITH YOUR CODE\n        return false", '        return false', " \
    \       val s = Set[Long]()\n        for (x <- l) {\n            if (s.contains(-x))\
    \ {\n                return true\n            }\n            s.add(x)\n      \
    \  }\n        return false", '        return l.distinct.combinations(2).exists((x)
    => x(0) + x(1) == 0)', "        // Your code here.\n        false", "        var\
    \ m = Map[Long, Int]()\n        for (i <- l) {\n            if (m.contains(i))\
    \ m += (i -> (m(i) + 1))\n            else m += (i -> 1)\n        }\n        for\
    \ (i <- l) {\n            if (m.contains(-i)) {\n                if (i != 0 ||\
    \ m(i) > 1) return true\n            }\n        }\n        return false", "\t\t\
    false", "        val set = new HashSet[Long]\n        for (i <- l) {\n       \
    \     if (set.contains(-i)) return true\n            set.add(i)\n        }\n \
    \       return false", "      var h : HashSet[Long] = new HashSet[Long]()\n  \
    \    for (e <- l) {\n        if (h.contains(-e)) {\n          return true\n  \
    \      }\n        h.add(e)\n      }\n      return false", "        // insert your\
    \ code here\n        false", "        val q = new Queue[Long]\n        val h =\
    \ HashSet[Long]()\n        q ++= l\n        while(!q.isEmpty) {\n            val\
    \ f = q.dequeue\n            if(h.contains(-f)) return true\n            h +=\
    \ f\n        }\n        return false", "        var a : List[Long] = List()\n\
    \        var b : List[Long] = List()\n        var s : Long = 0l\n        while\
    \ (s < l.length) {\n            var e : Long = 0l\n            while (e < l.length)\
    \ {\n                if (l(s.toInt) == l(e.toInt)) {\n                    a =\
    \ a :+ l(s.toInt)\n                }\n                e = e + 1l\n           \
    \ }\n            s = s + 1l\n        }\n        s = 0l\n        while (s < a.length)\
    \ {\n            var e : Long = 0l\n            while (e < a.length) {\n     \
    \           if (a(s.toInt) == -a(e.toInt)) {\n                    b = b :+ a(s.toInt)\n\
    \                }\n                e = e + 1l\n            }\n            s =\
    \ s + 1l\n        }\n        var c : Long = 0l\n        s = 0l\n        while\
    \ (s < b.length) {\n            var e : Long = 0l\n            while (e < b.length)\
    \ {\n                if (b(s.toInt) == b(e.toInt)) {\n                    c =\
    \ c + 1l\n                }\n                e = e + 1l\n            }\n     \
    \       s = s + 1l\n        }\n        return c >= 2l", "        // your code\
    \ here\n        var bool : Boolean = false\n        for (i <- l.indices) {\n \
    \           for (j <- i+1 until l.length) {\n                if (l(i) + l(j) ==\
    \ 0) {\n                    bool = true\n                }\n            }\n  \
    \      }\n        bool", "        if (l.isEmpty) {\n            false\n      \
    \  } else {\n            var i = 0\n            var m = scala.collection.mutable.Map[Long,\
    \ Boolean]()\n            while (i < l.length) {\n                if (m.contains(0\
    \ - l(i))) {\n                    return true\n                } else {\n    \
    \                m += (l(i) -> true)\n                }\n                i +=\
    \ 1\n            }\n            false\n        }", '        return l.toSet.contains(0l)',
  "\t\tif (l.length == 0) false else\n\t\t{\n\t\t\tval set = Set[Long]()\n\t\t\tl.map(x\
    \ => set.add(x))\n\t\t\tl.map(x => x * -1).map(y => set.contains(y)).contains(true)\n\
    \t\t}", "      // Fill in the missing code here\n      return false", '        l.length
    == 0', '        false', "        var valid : Boolean = false\n        val arr\
    \ = l.toArray\n        val set = new HashSet[Long]\n        for (e <- arr) {\n\
    \            if (set.contains(-e)) {\n                valid = true\n         \
    \   }\n            set.add(e)\n        }\n        valid", "        // return true\
    \ if there are two distinct elements in l that sum to zero\n        // false otherwise\n\
    \        var r : Boolean = false\n        val nums = l.sorted\n        var lo\
    \ = 0\n        var hi = nums.length - 1\n        while (lo < hi) {\n         \
    \   val sum = nums(lo) + nums(hi)\n            if (sum == 0) {\n             \
    \   r = true\n                lo = hi\n            } else if (sum < 0) {\n   \
    \             lo += 1\n            } else {\n                hi -= 1\n       \
    \     }\n        }\n        r", "        var summation = 0l\n        for (x <-\
    \ l) {\n            for (y <- l) {\n                if (x != y) {\n          \
    \          summation = x + y\n                    if (summation == 0) {\n    \
    \                    return true\n                    }\n                }\n \
    \           }\n        }\n        return false", "        val is = Set[Long]()\n\
    \        for (i <- l) {\n            if (is.contains(-i)) return true\n      \
    \      is += i\n        }\n        return false", "        val n = l.length\n\
    \        for (i <- 0 until n - 1) {\n            for (j <- i + 1 until n) {\n\
    \                if (l(i) + l(j) == 0) return true\n            }\n        }\n\
    \        return false", "        // your code here.\n        if (l.isEmpty) false\n\
    \        else l.head + l.last == 0 || pairsSumToZero(l.tail)", '        null',
  "        val sorted_l = l.sorted\n        for (i <- 0 until sorted_l.length - 1)\
    \ {\n            for (j <- i + 1 until sorted_l.length) {\n                if\
    \ (sorted_l(i) + sorted_l(j) == 0) {\n                    return true\n      \
    \          }\n            }\n        }\n        return false", '        l.filter(x
    => x != 0l.toLong).forall(l.contains(_ * -1l.toLong))', "        val s = l.toSet\n\
    \        for (x <- s) {\n            if (s.contains(-x)) {\n                return\
    \ true\n            }\n        }\n        return false", "        val h = HashSet[Long]()\n\
    \        for (x <- l) {\n            if (h.contains(-x)) {\n                return\
    \ true\n            }\n            h.add(x)\n        }\n        return false",
  "        val n = l.length\n        // this seems to be an impossible problem, because\
    \ of the runtime limit\n        var ret = false\n        for (i <- 0 until n)\
    \ {\n            for (j <- i + 1 until n) {\n                if (l(i) + l(j) ==\
    \ 0) {\n                    ret = true\n                }\n            }\n   \
    \     }\n        ret", "        var isPairs : Boolean = false\n        var hash\
    \ : HashMap[Long,Long] = new HashMap[Long,Long]()\n        for (x <- l) {\n  \
    \          if (!(hash.contains(x))) {\n                hash(x) = x\n         \
    \   }\n        }\n        for (x <- l) {\n            var negative : Long = x\
    \ * -1\n            if (hash.contains(negative)) {\n                isPairs =\
    \ true\n            }\n        }\n        return isPairs", "        var d : Set[Long]\
    \ = new HashSet[Long]()\n        var s : Long = 0\n        for (s <- l) {\n  \
    \          if (d.contains(s)) {\n                return true\n            }\n\
    \            d.add(s)\n        }\n        return false", "        var s = Set[Long]()\n\
    \        l.foreach((x) => if (s.contains(-x)) return true; else s += x)\n    \
    \    return false", "        // your solution here\n        l.size > 1 && {\n\
    \            val set = l.toSet\n            val input = l.sorted\n           \
    \ input.zipWithIndex.exists {\n                case (value, index) =>\n      \
    \              val tmp = -value\n                    val result = set.contains(tmp)\n\
    \                    if (result) {\n                        val indexB = input.indexOf(tmp)\n\
    \                        indexB > index\n                    } else {\n      \
    \                  false\n                    }\n            }\n        }", " \
    \       var s = new HashSet[Long]\n        for (i <- l) {\n            if (s.contains(-i))\
    \ return true\n            s.add(i)\n        }\n        return false", "     \
    \   val hm = new HashMap[Long, Long]\n        l.foreach(e => hm(e) = 1)\n    \
    \    l.foreach(e => if (hm.contains(-e)) return true)\n        false", "     \
    \   val hm = new HashMap[Long, Int]()\n        for (i <- l) {\n            if\
    \ (hm.contains(i)) {\n                hm(i) += 1\n            } else {\n     \
    \           hm(i) = 1\n            }\n        }\n        for (i <- l) {\n    \
    \        if (hm.contains(-i)) {\n                if (i != 0 || hm(i) > 1) {\n\
    \                    return true\n                }\n            }\n        }\n\
    \        return false", '        return false', "        val sorted = l.sorted\n\
    \        var start = 0\n        var end = sorted.length - 1\n        while (start\
    \ < end) {\n            if (sorted(start) + sorted(end) == 0) return true\n  \
    \          else if (sorted(start) + sorted(end) < 0) start += 1\n            else\
    \ end -= 1\n        }\n        return false", "        if (l.length == 0) {\n\
    \            return false\n        }\n        val s = new HashSet[Long]\n    \
    \    for (x <- l) {\n            if (s.contains(-x)) {\n                return\
    \ true\n            }\n            s.add(x)\n        }\n        return false",
  "        l.isEmpty match {\n            case true => false\n            case false\
    \ => {\n                val first_element = l.head\n                val second_list\
    \ = l.tail\n                second_list.contains(-first_element) match {\n   \
    \                 case true => true\n                    case false => pairsSumToZero(second_list)\n\
    \                }\n            }\n        }", "        var m = Map[Long, Int]()\n\
    \        for (a <- l) {\n            if (m.contains(a))\n                m(a)\
    \ += 1\n            else\n                m(a) = 1\n        }\n        for (a\
    \ <- l) {\n            if (m(a) > 1)\n                return true\n          \
    \  if (m.contains(-a))\n                return true\n        }\n        return\
    \ false", "        def pairsSumToZeroHelper(l : List[Long], hashSet : HashSet[Long])\
    \ : Boolean = {\n            if (l.length == 0) false\n            else if (hashSet.contains(-l.head))\
    \ true\n            else {\n                hashSet += l.head\n              \
    \  pairsSumToZeroHelper(l.tail, hashSet)\n            }\n        }\n        if\
    \ (l.length < 2) false\n        else pairsSumToZeroHelper(l, HashSet[Long]())",
  "        var sum : Long = 0\n        val pairs = new HashMap[Long, Int]\n      \
    \  for (i <- l) {\n            if (pairs.contains(i)) {\n                return\
    \ true\n            }\n            pairs(i) = 1\n        }\n        return false",
  "        if(l.length == 1) return false\n        var set = Set[Long]()\n       \
    \ for(i <- l) {\n            if(set.contains(-i)) return true\n            set\
    \ += i\n        }\n        return false", "        var t = List[Long]()\n    \
    \    val s = l.toSet\n        for (x <- s) {\n            if (s.contains(-x))\
    \ {\n                t = x :: t\n            }\n        }\n        t.distinct.length\
    \ != 0", "        // Please fill in the body of this function\n        // to return\
    \ the correct output.\n        var sum = 0\n        for (i <- 0 to l.length-1)\
    \ {\n            for (j <- i+1 to l.length-1) {\n                if (l(i) + l(j)\
    \ == 0) {\n                    sum += 1\n                }\n            }\n  \
    \      }\n        if (sum > 0) {\n            return true\n        }\n       \
    \ else {\n            return false\n        }", "        val map = new HashMap[Long,\
    \ Boolean]\n        for (i <- l) map(i) = true\n        for (i <- l) {\n     \
    \       if (map.contains(-i)) return true\n        }\n        return false", " \
    \       var i = 0;\n        var map = Map[Long, List[Long]]()\n        for (n\
    \ <- l) {\n            map += (n -> (map.getOrElse(n, List[Long]()) :+ i))\n \
    \           i += 1\n        }\n        var found = false\n        for (n <- l)\
    \ {\n            if (map.contains(-n)) {\n                val l = map(-n)\n  \
    \              if (l.length > 1 || l(0) != i - 1) {\n                    found\
    \ = true\n                    break\n                }\n            }\n      \
    \  }\n        found", "        if (l.length == 0) return false\n        var d\
    \ = HashMap[Long, Int]()\n        for (i <- l) {\n            if (d.contains(i))\
    \ {\n                d(i) += 1\n            } else {\n                d(i) = 1\n\
    \            }\n        }\n        var ret = false\n        for (i <- l) {\n \
    \           if (d.contains(-i)) {\n                if (i == 0) {\n           \
    \         if (d(i) > 1) {\n                        ret = true\n              \
    \      }\n                } else {\n                    ret = true\n         \
    \       }\n            }\n        }\n        return ret", "        var set = Set[Long]()\n\
    \        for (i <- l) {\n            if (set.contains(-i)) return true\n     \
    \       set.add(i)\n        }\n        return false", "        // your code goes\
    \ here\n        // replace \"false\" by the correct boolean expression\n     \
    \   if (l.isEmpty) false\n        else{\n            var y = true\n          \
    \  for (i <- 0 until l.length - 1){\n                for (j <- i + 1 until l.length){\n\
    \                    if (l(i) + l(j) == 0){\n                        y = false\n\
    \                    }\n                }\n            }\n            y\n    \
    \    }", "        // REPLACE THE FOLLOWING LINE WITH YOUR CODE\n        val exist\
    \ = l.toArray.combinations(2).map(a => a(0) + a(1)).exists(_ == 0)\n        exist",
  "        // your code here\n        var flag = false\n        for (i <- 0 until\
    \ l.length) {\n            for (j <- 0 until l.length) {\n                if (i\
    \ != j && l(i) + l(j) == 0) {\n                    flag = true\n             \
    \   }\n            }\n        }\n        flag", "        // TODO: replace the\
    \ line below with a correct implementation.\n        val b = l.toSet.toList.exists(x\
    \ => l.toSet.toList.exists(y => x != y && x + y == 0))\n        b", "        if\
    \ (l.length == 0) {\n            return false\n        }\n        // l = [0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]\n        // s = [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]\n\
    \        val s = (l.zipWithIndex.map(x => x._1 + x._2).toList).map(x => x.toLong)\n\
    \        // println(s)\n        if (s.length == 1) {\n            return false\n\
    \        }\n        // t = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n        val t\
    \ = (s.zipWithIndex.map(x => x._1 + x._2).toList).map(x => x.toLong)\n       \
    \ // println(t)\n        val m = HashMap[Long, Boolean]()\n        // l = [0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        // t = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\
    \        // >>> m = HashMap[Long, Boolean]()\n        // >>> for (v <- t) {\n\
    \        //     |     m(v) = true\n        //     | }\n        // >>> m\n    \
    \    // HashMap[Long, Boolean](0.toLong -> true, 2.toLong -> true, 4.toLong ->\
    \ true, 6.toLong -> true, 8.toLong -> true, 10.toLong -> true, 12.toLong -> true,\
    \ 14.toLong -> true, 16.toLong -> true, 18.toLong -> true)\n        for (v <-\
    \ t) {\n            m(v) = true\n        }\n        // l = [0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9]\n        // s = [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]\n        //\
    \ >>> for (v <- s) {\n        //     |     if (m(v)) {\n        //     |     \
    \    println(true)\n        //     |     }\n        //     | }", "        val\
    \ groups = l.groupBy(x => abs(x))\n        groups.exists(x => x._2.length >= 2\
    \ && x._1 == 0) ||\n        groups.keys.toList.permutations.exists(x => x.zip(x.tail).exists(y\
    \ => groups(y._1).exists(x => groups(y._2).exists(z => x + z == 0))))", "    \
    \    var hm : HashMap[Long, Boolean] = new HashMap[Long, Boolean]()\n        for\
    \ (i <- l) {\n            if (hm.contains(-i)) return true\n            hm.put(i,\
    \ true)\n        }\n        return false", "        if (l.isEmpty) false\n   \
    \     else {\n            var set = Set.empty[Long]\n            for (v <- l)\
    \ {\n                val v2 = -v\n                if (set.contains(v2)) return\
    \ true\n                else set += v\n            }\n            false\n    \
    \    }", "        var list = l\n        var result = false\n        var zero =\
    \ 0l\n        var zero1 = 0l\n        if (list.isEmpty) {\n            result\
    \ = false\n        } else {\n            for (i <- list) {\n                for\
    \ (j <- list) {\n                    if (i == j) {\n                        zero\
    \ = 0l\n                    } else {\n                        zero = i + j\n \
    \                   }\n                    if (zero == zero1) {\n            \
    \            result = true\n                    }\n                }\n       \
    \     }\n        }\n        return result", "        var set = Set[Long]()\n \
    \       var exists = false\n        for (x <- l) {\n            if (set.contains(-x))\
    \ {\n                exists = true\n            }\n            set += x\n    \
    \    }\n        exists", "        // >>>>> FILL IN HERE <<<<<\n        val as\
    \ = l.toSet\n        as.foldLeft(false)((x,y) => if(x) true else as.contains(-y))",
  "        if (l.isEmpty) return false\n        var pos : List[Long] = l.filter(x\
    \ => x > 0)\n        var neg : List[Long] = l.filter(x => x < 0)\n        neg\
    \ = neg.map(x => -x)\n        if ((pos.isEmpty) || (neg.isEmpty)) return false\n\
    \        pos = pos.sortBy(identity)\n        neg = neg.sortBy(identity)\n    \
    \    var i : Int = 0\n        var j : Int = 0\n        while ((i < pos.length)\
    \ && (j < neg.length)) {\n            if (pos(i) == neg(j)) return true\n    \
    \        if (pos(i) < neg(j)) i += 1\n            else j += 1\n        }\n   \
    \     return false", "        // Inputs:\n        // l: List[Long]\n        //\
    \ Outputs:\n        // b: Boolean\n        // Constants:\n        // n: Int\n\
    \        // Variables:\n        // i: Int\n        // j: Int\n        // t1: List[Long]\n\
    \        // t2: List[Long]\n        // t3: List[Long]\n        // t4: List[Long]\n\
    \        // t5: List[Long]\n        // t6: List[Long]\n        // t7: List[Long]\n\
    \        // t8: List[Long]\n        // t9: List[Long]\n        // t10: List[Long]\n\
    \        // t11: List[Long]\n        // t12: List[Long]\n        // t13: List[Long]\n\
    \        // t14: List[Long]\n        // t15: List[Long]\n        // t16: List[Long]\n\
    \        // t17: List[Long]\n        // t18: List[Long]\n        // t19: List[Long]\n\
    \        // t20: List[Long]\n        // t21: List[Long]\n        // t22: List[Long]\n\
    \        // t23: List[Long]\n        // t24: List[Long]\n        // t25: List[Long]\n\
    \        // t26: List[Long]\n        // t27: List[Long]\n        // t28: List[Long]\n\
    \        // t29: List[Long]\n        // t30: List[Long]\n        // t31: List[Long]\n\
    \        // t32: List[Long]\n        // t33: List[Long]\n        // t34: List[Long]\n\
    \        // t35: List[Long]\n        // t36: List[Long]\n        // t37: List[Long]\n\
    \        // t38: List[Long]\n        // t39: List[Long]\n        // t40: List[Long]\n\
    \        // t41: List[Long]\n        // t42: List[Long]\n        // t43: List[Long]\n\
    \        // t44: List[Long]\n        // t45: List[Long]\n        // t46", "  \
    \      // YOUR CODE HERE\n        return true", "        // YOUR CODE HERE\n \
    \       var sum = false\n        for (i <- 0 until l.length) {\n            for\
    \ (j <- i+1 until l.length) {\n                if (l(i) + l(j) == 0) {\n     \
    \               sum = true\n                }\n            }\n        }\n    \
    \    sum", "        var result = false\n        for (i <- l) {\n            for\
    \ (j <- l) {\n                if (i + j == 0 && i != j) {\n                  \
    \  result = true\n                }\n            }\n        }\n        return\
    \ result", "        var map = Map[Long, Boolean]()\n        for (number <- l)\
    \ {\n            if (map.contains(number)) return true\n            map(number)\
    \ = true\n        }\n        for (number <- l) {\n            if (map.contains(-number))\
    \ return true\n        }\n        return false", "        // var m = Map[Long,Boolean]()\n\
    \        // l.map(x => {\n        //     if (m.contains(x)) return true\n    \
    \    //     m += (-x -> true)\n        // })\n        // return false\n      \
    \  l.map(x => l.contains(-x)).contains(true)", "        if (l.length < 2) return\
    \ false\n        else {\n            val set = l.tail.toSet\n            val flag\
    \ = set.exists((x : Long) => set.contains(-x))\n            return flag\n    \
    \    }", "        def helper(list : List[Long], set : Set[Long]) : Boolean = {\n\
    \            if (list.isEmpty) return false\n            val head = list.head\n\
    \            if (set.contains(-head)) return true\n            helper(list.tail,\
    \ set + head)\n        }\n        helper(l, Set())", '        return false', " \
    \       val lSorted = l.sorted\n        var i = 0\n        var j = lSorted.length\
    \ - 1\n        while (i < j) {\n            val sum = lSorted(i) + lSorted(j)\n\
    \            if (sum == 0) return true\n            else if (sum < 0) i += 1\n\
    \            else j -= 1\n        }\n        return false", '        return false',
  "        // your code here\n        val n = l.size\n        var num = l.sorted\n\
    \        var sum = 0\n        var i = 0\n        while (i < n) {\n           \
    \ var j = i+1\n            while (j < n) {\n                sum = num(i) + num(j)\n\
    \                if (sum == 0) {\n                    return true\n          \
    \      }\n                j += 1\n            }\n            i += 1\n        }\n\
    \        return false", "        val s = l.sorted\n        for (i <- 0 until s.length\
    \ - 1) {\n            val target = -s(i)\n            if (binarySearch(s, target,\
    \ i + 1, s.length - 1)) {\n                return true\n            }\n      \
    \  }\n        return false", "        var set : Set[Long] = Set.empty[Long]\n\
    \        for (i <- l) {\n            if (set.contains(-i)) {\n               \
    \ return true\n            }\n            set += i\n        }\n        return\
    \ false", "        var dict = new HashMap[Long, Boolean]()\n        for (i <-\
    \ l) {\n            if (dict.contains(i)) {\n                return true\n   \
    \         }\n            dict.put(i, true)\n        }\n        return false",
  "        var bucket : List[Long] = List[Long]()\n        if (l.length == 1) {\n\
    \            return false\n        }\n        for (i <- l) {\n            if (bucket.contains(-i))\
    \ {\n                return true\n            }\n            bucket = i :: bucket\n\
    \        }\n        return false", '        null', "        // >>> pairsSumToZero((List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong, 0l.toLong)))\n        // (false)\n        // >>> pairsSumToZero((List[Long](1l.toLong,\
    \ 3l.toLong, -2l.toLong, 1l.toLong)))\n        // (false)\n        // >>> pairsSumToZero((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 7l.toLong)))\n        // (false)\n        // >>> pairsSumToZero((List[Long](2l.toLong,\
    \ 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n        // (true)\n\
    \        // >>> pairsSumToZero((List[Long](1l.toLong)))\n        // (false)\n\
    \        var arr = new Array[Long](l.length)\n        var i = 0\n        for (x\
    \ <- l) {\n            arr(i) = x\n            i += 1\n        }\n        var\
    \ flag = false\n        for (i <- 0 until arr.length) {\n            for (j <-\
    \ i + 1 until arr.length) {\n                if (arr(i) + arr(j) == 0) {\n   \
    \                 flag = true\n                }\n            }\n        }\n \
    \       flag", "      val l1 = l.filter(_<0).sorted\n      val l2 = l.filter(_>=0).sorted\n\
    \      var l1r = l1.reverse\n      var i = 0\n      var j = 0\n      while (i\
    \ < l1.length && j < l2.length) {\n        if (-l1(i) > l2(j)) {\n          j\
    \ += 1\n        } else if (-l1(i) < l2(j)) {\n          i += 1\n        } else\
    \ {\n          return true\n        }\n      }\n      var i1 = 0\n      var j1\
    \ = 0\n      while (i1 < l1.length && j1 < l1r.length) {\n        if (l1(i1) +\
    \ l1r(j1) > 0) {\n          i1 += 1\n        } else if (l1(i1) + l1r(j1) < 0)\
    \ {\n          j1 += 1\n        } else {\n          return true\n        }\n \
    \     }\n      false", '        ???', "        val hashSet = new HashSet[Long]()\n\
    \        for (x <- l) {\n            if (hashSet.contains(-x)) {\n           \
    \     return true\n            }\n            hashSet.add(x)\n        }\n    \
    \    return false", "        var map = Map[Long, Boolean]()\n        for (k <-\
    \ l) {\n            map += (k -> true)\n        }\n        for (k <- l) {\n  \
    \          if (map.contains(-k)) {\n                return true\n            }\n\
    \        }\n        return false"]
stop_tokens:
- "\n    }\n"
