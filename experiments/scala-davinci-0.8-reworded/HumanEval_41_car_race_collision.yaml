name: HumanEval_41_car_race_collision
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Imagine a road that's a perfectly straight infinitely long line.\n    //\
  \ n cars are driving left to right;  simultaneously, a different set of n cars\n\
  \    // are driving right to left.   The two sets of cars start out being very far\
  \ from\n    // each other.  All cars move in the same speed.  Two cars are said\
  \ to collide\n    // when a car that's moving left to right hits a car that's moving\
  \ right to left.\n    // However, the cars are infinitely sturdy and strong; as\
  \ a result, they continue moving\n    // in their trajectory as if they did not\
  \ collide.\n    // This function outputs the number of such collisions.\n    def\
  \ carRaceCollision(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
  \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
  \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
  \ == (100l));\n    }\n\n}\n"
completions: ["        val m = n.toInt\n        val a = (1 to m).toArray\n       \
    \ val b = a.map(2 * _)\n        val c = (1 to m).toArray.map(i => (1 to m).toArray.map(j\
    \ => (i + j).toLong))\n        val d = c.map(a => a.map(2 * _))\n        //val\
    \ e = (1 to m).toArray.map(i => (1 to m).toArray.map(j => (i + j).toLong))\n \
    \       //val f = e.map(a => a.map(2 * _))\n        val g = c.map(a => a.map(1\
    \ + _))\n        val h = g.map(a => a.map(2 * _))\n        //val i = e.map(a =>\
    \ a.map(1 + _))\n        //val j = i.map(a => a.map(2 * _))\n        val k = (1\
    \ to m).toArray.map(i => (1 to m).toArray.map(j => (i + j - 1).toLong))\n    \
    \    val l = k.map(a => a.map(2 * _))\n        //val m = (1 to n).toArray.map(i\
    \ => (1 to n).toArray.map(j => (i + j - 1).toLong))\n        //val n = m.map(a\
    \ => a.map(2 * _))\n        val o = c.map(a => a.map(i => (1 to i).sum))\n   \
    \     val p = o.map(a => a.map(2 * _))\n        //val q = e.map(a => a.map(i =>\
    \ (1 to i).sum))\n        //val r = q.map(a => a.map(2 * _))\n        val s =\
    \ k.map(a => a.map(i => (1 to i).sum))\n        val t = s.map(a => a.map(2 * _))\n\
    \        //val u = m.map(a => a.map(i => (1 to i).sum))\n        //val v = u.map(a\
    \ =>", "        // Let's assume n cars are driving left to right, and the others\
    \ are driving right to left.\n        // Let's assume the n cars driving left\
    \ to right are indexed by i, and the cars driving right to left\n        // are\
    \ indexed by j.\n        // Car i moves at speed i, and car j moves at speed j.\n\
    \        // Car i and car j collide if i + j = n + 1.\n        // How many pairs\
    \ (i, j) satisfy i + j = n + 1?\n        // This can be computed by the formula\
    \ (n + 1) * n / 2.\n        val result = (n + 1) * n / 2\n        result", " \
    \       val leftToRight = Array.fill(n.toInt)(0)\n        val rightToLeft = Array.fill(n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) {\n            leftToRight(i) = i + 1\n  \
    \          rightToLeft(i) = n - i\n        }\n        var res = 0L\n        for\
    \ (i <- 0 until n.toInt) {\n            for (j <- 0 until n.toInt) {\n       \
    \         if (leftToRight(i) == rightToLeft(j)) res += 1\n            }\n    \
    \    }\n        res", "        // assume n is positive\n        // assume n is\
    \ small enough so that we do not have to worry about arithmetic overflow\n   \
    \     val n2 = (n * n).toLong\n        val factor = 4 * n2 - 2 * n + 1\n     \
    \   val sum = (1 to n.toInt).map(i => {\n            val diff = n - i\n      \
    \      diff * (n2 - (i * i))\n        }).sum\n        factor * sum / 24", "  \
    \      // Create a max heap of the positions of the cars moving left to right.\n\
    \        // Create a min heap of the positions of the cars moving right to left.\n\
    \        // Keep removing the maximum number from the left heap and the minimum\
    \ number\n        // from the right heap, and calculate their distances.  If the\
    \ distances are\n        // the same, then we found a collision.  Keep doing this\
    \ until we remove all\n        // elements from the heaps.\n        var l = new\
    \ PriorityQueue[Long]()(Ordering.Long.reverse)\n        var r = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        for (i <- 1 to n.toInt) {\n            l.+=(i)\n            r.+=(i)\n\
    \        }\n        var ans = 0L\n        while (!l.isEmpty && !r.isEmpty) {\n\
    \            val lx = l.dequeue\n            val rx = r.dequeue\n            if\
    \ (lx == rx) ans += 1\n        }\n        ans", "        var collision = 0L\n\
    \        for (i <- 1L to n) {\n            if (n % i == 0) {\n               \
    \ collision += i - 1\n            }\n        }\n        collision", "        /*\n\
    \        if (n <= 2) return 0\n        val speed = n.toLong\n        val leftToRightDistances\
    \ = List.fill(n.toInt)(speed)\n        val rightToLeftDistances = List.fill(n.toInt)(speed)\n\
    \        val t = leftToRightDistances.zip(rightToLeftDistances).map(x => {\n \
    \           val leftDist = x._1\n            val rightDist = x._2\n          \
    \  min(leftDist, rightDist)\n        }).max\n        val x = leftToRightDistances.map(x\
    \ => x - t).count(x => x == 0)\n        val y = rightToLeftDistances.map(x =>\
    \ x - t).count(x => x == 0)\n        x + y\n        */\n        val speed = n.toLong\n\
    \        val t = n\n        val x = n - t\n        if (x == 0) return n\n    \
    \    val y = n - t\n        if (y == 0) return n\n        2 * n", "        //\
    \ perform an n log n solution by sorting.\n        val cars = new Array[Long](2\
    \ * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i) = i.toLong\
    \ + 1\n            cars(i + n.toInt) = -(i.toLong + 1)\n        }\n        cars.sortWith((a,\
    \ b) => abs(a) < abs(b))\n        var answer = 0L\n        var carIndex = 0\n\
    \        while (carIndex < 2 * n.toInt) {\n            if (cars(carIndex) > 0)\
    \ {\n                var car = cars(carIndex)\n                while (carIndex\
    \ < 2 * n.toInt && cars(carIndex) == car) {\n                    carIndex += 1\n\
    \                }\n                answer += (carIndex - car).toLong\n      \
    \      } else {\n                carIndex += 1\n            }\n        }\n   \
    \     answer", "        /*\n        // greedy brute force algorithm from the left\
    \ to right, runs in O(n^2).\n        // assumes that each car speed is a positive\
    \ integer.\n        val map = HashMap[Long, Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            val speed = i\n            var t = i\n            var collisions\
    \ = 0\n            while (t <= n) {\n                if (map.contains(t)) {\n\
    \                    collisions += map(t)\n                }\n               \
    \ t += speed\n            }\n            map(speed) = collisions\n        }\n\
    \        map.values.sum\n        */\n        /*\n        // below is the solution\
    \ posted on project euler discussion.\n        // i don't know why the average\
    \ function below works.\n        // if we choose i = 1, 2, 3, ..., n and j = 1,\
    \ 2, 3, ..., n,\n        // then i can hit j when i < j and they have the same\
    \ speed.\n        // Thus, we can choose i from 1 to n, and calculate how many\
    \ j can be hit by i.\n        // that's the below solution. \n        def average(a\
    \ : Long, b : Long) : Long = (a + b) / 2\n        var result = 0L\n        for\
    \ (i <- 1 to n.toInt) {\n            val speed = i\n            result += (average(1,\
    \ n) - average(n + 1 - i, i)) * speed\n        }\n        result\n        */\n\
    \        // The above solution assumes that the speed is an integer.\n       \
    \ // The solution below does not make this assumption.\n        // i can hit j\
    \ when i < j and they have the same speed.\n        // it's easier to calculate\
    \ how many cars can be hit by car i.\n        // when car i move from t = 0 to\
    \ t = n, how many j are hit by i?\n        // car i is hit by j if and only if\
    \ car j is traveling at the same speed.\n        // so, how many cars are driving\
    \ left to right at the same speed?\n        // we can represent the trajectory\
    \ of car i as a function f(t) = speed * t.\n        // if the speed is an integer,\
    \ we can represent the trajectory by g(t) = floor", "        // Given 2 cars that\
    \ are moving at speeds v1 and v2, and v1 <= v2,\n        // the absolute value\
    \ of their relative velocity is v2 - v1.  (Note\n        // that if v1 > v2, then\
    \ their relative velocity is -(v1 - v2) which is\n        // the same as v2 -\
    \ v1.)\n        // Given that there are n cars moving in each direction, there\
    \ are (n*(n-1))/2\n        // combinations of pairs of cars.\n        // Consider\
    \ a pair of cars that are moving in opposite directions.  Suppose\n        //\
    \ the relative velocity of one is v, and the other is -v.  If v is even,\n   \
    \     // then the cars collide at the time steps when their relative velocity\
    \ is\n        // positive.  If v is odd, then there are two different cases. \
    \ (1) if v = 1,\n        // then the cars collide at the time steps when their\
    \ relative velocity is\n        // positive;  (2) if v >= 3, then the cars do\
    \ not collide.\n        // Therefore, the number of collisions is the sum of the\
    \ absolute value of all\n        // pairs of relative velocities.\n        //\n\
    \        // Note that each pair of cars collide exactly once, except pairs of\
    \ cars with\n        // relative velocity 0.  If we sum up the absolute value\
    \ of all pairs of\n        // relative velocities, we double-count the pairs of\
    \ cars with relative velocity 0.\n        // Therefore, we have to subtract (n*(n-1)/2).\n\
    \        //\n        // Note that the sum of all relative velocities is always\
    \ 0.  Therefore, the\n        // sum of the absolute value of all relative velocities\
    \ is always 0.  Therefore,\n        // we have to subtract (n*(n-1)/2) once more.\n\
    \        //\n        // Therefore, the number of collisions is\n        // (sum\
    \ of the absolute value of all pairs of relative velocities) - (n*(n-1)/2) - (n*(n-1)/2)\n\
    \        // = (sum of the absolute value of all pairs of relative velocities)\
    \ - (n*(n-1))\n        // = (sum of the absolute value of all pairs of relative\
    \ velocities) -", "        // This is a greedy problem that can be solved with\
    \ a priority queue.\n        // Assume the cars are numbered from 1 to n in both\
    \ directions.\n        // Define class Car which contains the car number and its\
    \ x-position (i.e. left/right distance\n        // from the starting point). \
    \ Define a priority queue, sorted by the x-position of the car.\n        // Initially,\
    \ add all n cars from both directions, starting with car 1, then car 2, ... ,\
    \ then car n.\n        // Then, whenever a car A collides with a car B, remove\
    \ the car with the smaller number (to avoid double counting).\n        // Repeat\
    \ this until the queue is empty.\n        val q = new PriorityQueue[Car]()(new\
    \ CarOrdering())\n        for (i <- 1 to n.toInt) {\n            q.enqueue(new\
    \ Car(i, i))\n            q.enqueue(new Car(i, -i))\n        }\n        var count\
    \ = 0\n        while (!q.isEmpty) {\n            val curr = q.dequeue\n      \
    \      val next = q.dequeue\n            if (curr.num > next.num) q.enqueue(curr)\n\
    \            else if (curr.num < next.num) q.enqueue(next)\n            else count\
    \ += 1\n        }\n        count", '        return 2 * n - 1', "        // The\
    \ idea is that the number of collisions is just n * n\n        // However, n *\
    \ n is too big for a long value to hold, so \n        // we need to use BigInts\
    \ instead.\n        BigInt(n) * BigInt(n)", "        if (n == 0) return 0\n  \
    \      val primes = Primes.sieve(n).reverse\n        val sqrt = sqrt(n.toDouble).toLong\n\
    \        val exponents = Array.fill(primes.length)(0L)\n        for (i <- 1 to\
    \ primes.length - 1) {\n            var j = 1\n            var x = pow(primes(i).toDouble,\
    \ j).toLong\n            while (x <= sqrt) {\n                exponents(i) +=\
    \ 1\n                j += 1\n                x = pow(primes(i).toDouble, j).toLong\n\
    \            }\n        }\n        val result = (for (i <- 1 to primes.length\
    \ - 1) yield primes(i) * exponents(i)).sum\n        result", "        // simulation\n\
    \        val leftToRightCars = (1 to n.toInt).map(i => new Car(i)).toList\n  \
    \      val rightToLeftCars = (1 to n.toInt).map(i => new Car(i)).toList\n    \
    \    val road = new Road(leftToRightCars, rightToLeftCars)\n        val simulation\
    \ = new Simulation(road)\n        simulation.run\n        simulation.collisions",
  "        // The idea is that we can assume the cars are moving at unit speed;\n\
    \        // for each left-to-right car, we determine the point at which it collides\
    \ with\n        // a right-to-left car.  We then sort the resulting set of points,\
    \ and we can\n        // determine the number of collisions as the number of consecutive\
    \ pairs of points.\n        // In terms of algorithm, we can do this in linear\
    \ time using a hash map.\n        // For each right-to-left car, we put it into\
    \ the hash map.  For each left-to-right\n        // car, we check whether there\
    \ is a right-to-left car that is positioned to the left\n        // of the current\
    \ left-to-right car; if there is, the two will eventually collide.\n        //\
    \ We then move the left-to-right car to the right of the right-to-left car, and\n\
    \        // we repeat the check.  Eventually, the left-to-right car will have\
    \ passed all\n        // cars that have previously been checked.  We then remove\
    \ it from the hash map\n        // to avoid checking it later.\n        val cars\
    \ = HashMap[Long, Long]()\n        val points = HashMap[Long, Long]()\n      \
    \  for (i <- n until n + n) cars(i) = i - n\n        for (i <- n until n + n)\
    \ {\n            var j = i\n            var prev = -1L\n            while (true)\
    \ {\n                if (cars.contains(j)) {\n                    val diff = prev\
    \ - cars(j)\n                    if (points.contains(diff)) points(diff) += 1\n\
    \                    else points(diff) = 1\n                    prev = cars(j)\n\
    \                    cars.remove(j)\n                }\n                else if\
    \ (cars.contains(j + 1)) {\n                    val diff = prev - cars(j + 1)\n\
    \                    if (points.contains(diff)) points(diff) += 1\n          \
    \          else points(diff) = 1\n                    prev = cars(j + 1)\n   \
    \                 cars.remove(j + 1)\n                }\n                else\
    \ break\n                j += 1\n            }\n        }\n        // now we check\
    \ whether any two consecutive points, if they exist, differ by 1\n       ", " \
    \       // Assume cars are indexed left to right from 0 to n-1, and right to left\
    \ from n to 2n-1\n        // If all cars move at the same speed, then the collision\
    \ index is the car's index\n        // If cars start at distance d, then the time\
    \ each car takes to reach collision point is t\n        // = d / speed\n     \
    \   // The car's speed is then d / t.\n        // To represent this, we can have\
    \ a function f(x) = d / x\n        // Now, the car's speed can be represented\
    \ as a function, g(i) = f(t + i)\n        // where i is the car's index and t\
    \ is the time taken for all cars to reach collision point\n        val f = new\
    \ Function[Long, Long] {\n            def apply(x : Long) = 1000000000 / x\n \
    \       }\n        // car 0 moves left to right with speed g(0) = f(t)\n     \
    \   // car 1 moves left to right with speed g(1) = f(t + 1)\n        // car n-1\
    \ moves left to right with speed g(n-1) = f(t + n - 1)\n        // car n moves\
    \ right to left with speed g(n) = f(t)\n        // car n+1 moves right to left\
    \ with speed g(n+1) = f(t + 1)\n        // car 2n-1 moves right to left with speed\
    \ g(2n-1) = f(t + n - 1)\n        // The net result is that the car's speed is\
    \ represented by the function\n        // g(x) = f(t + abs(x - n))\n        val\
    \ g = new Function[Long, Long] {\n            def apply(x : Long) = f(abs(x -\
    \ n))\n        }\n        // To determine the collision index, we want the indexes\
    \ where g(x) = g(x - 1)\n        // For example, consider g(x) = 1 / x\n     \
    \   // Then, g(x) = g(x - 1) is satisfied at x = 3\n        // To find a solution\
    \ to this, we can make use of the intermediate value theorem\n        // Let f(x)\
    \ = g(x) - g(x - 1)\n        // We", "        // The intuition of this problem\
    \ is as follows.  Car i is going to collide with car j\n        // if and only\
    \ if car i reaches a point x to the right of car j, and car j reaches\n      \
    \  // a point x to the left of car i.  Now, a car can reach point x to the right\
    \ of\n        // car j as soon as t minutes have passed since the start of the\
    \ race, where x\n        // is t times the speed of car i.  By the same token,\
    \ car j will reach point x\n        // to the left of car i as soon as s minutes\
    \ have passed, where x is s times the\n        // speed of car j.\n        //\
    \ So we have the following condition for the existence of a collision:\n     \
    \   // t * speed(i) = s * speed(j)\n        // Now, since speed(i) != speed(j),\
    \ we can take speed(i) as the independent variable.\n        // We can then take\
    \ s = t * speed(i) / speed(j).  This means that as soon as t minutes\n       \
    \ // have passed since the start of the race, car i reaches a point that's s *\
    \ speed(j)\n        // away from the starting point, which is the place where\
    \ car j is.\n        // Note that we can assume that s * speed(j) = t * speed(i),\
    \ where s, t are integers.\n        // We can then take s = speed(i) * k / gcd(speed(i),\
    \ speed(j)), where k is an integer.\n        // This gives us the following equation:\n\
    \        // t * speed(i) = speed(i) * k / gcd(speed(i), speed(j)) * speed(j)\n\
    \        // Now, let x = gcd(speed(i), speed(j)).  We then have t * speed(i) =\
    \ k * speed(j) / x.\n        // This means that as soon as t minutes have passed\
    \ since the start of the race,\n        // car i is at point k * speed(j) / x,\
    \ which is precisely where car j is.\n        // The trick is to loop through\
    \ all the values of t = 1 to k = speed(i) * speed(j) / x\n        // and check\
    \ whether t * speed(i) = k", "        var numCollisions = 0L\n        var carsLeftToRight\
    \ = new PriorityQueue[(Long, Long)]()\n        var carsRightToLeft = new PriorityQueue[(Long,\
    \ Long)]()\n        for (i <- 1 to n.toInt) {\n            carsLeftToRight.enqueue((i,\
    \ i))\n            carsRightToLeft.enqueue((-i, -i))\n        }\n        var done\
    \ = false\n        while (!done) {\n            val (x, i) = carsLeftToRight.dequeue\n\
    \            val (y, j) = carsRightToLeft.dequeue\n            if (x < -y) {\n\
    \                carsLeftToRight.enqueue((x, i))\n                carsRightToLeft.enqueue((y,\
    \ j))\n                done = true\n            } else {\n                numCollisions\
    \ += 1\n                if (i == n) {\n                    done = true\n     \
    \           } else {\n                    carsLeftToRight.enqueue((x + 1, i +\
    \ 1))\n                    carsRightToLeft.enqueue((y, j))\n                }\n\
    \            }\n        }\n        numCollisions", "        // take the n cars\
    \ going left to right, and sort them by their speed\n        // take the n cars\
    \ going right to left, and sort them by their speed\n        // observe that if\
    \ two cars collide, they must be at the same speed\n        // since there are\
    \ no deceleration, neither car can slow down.\n        // if there are c cars\
    \ going left to right, and c cars going right to left\n        // with equal speed,\
    \ then there will be c^2 collisions.\n        // So we just need to count the\
    \ number of pairs of equal speeds.\n        // now, the number of cars with speed\
    \ 1, 2, 3, 4, 5, ... is n + n/2 + n/3 + n/4 + n/5 + ...\n        // This is a\
    \ geometric series, so we can sum it up using \n        // http://en.wikipedia.org/wiki/Geometric_series#Summation_of_a_geometric_series\n\
    \        var total = 0.0\n        for (i <- 1 to n.toInt) {\n            val nInGroup\
    \ = n / i\n            val nOfGroups = i\n            total += nInGroup * nOfGroups\
    \ * nInGroup\n        }\n        total.toLong", "        // Write your code here\n\
    \        val min = -1000000000\n        val max = 1000000000\n        var p =\
    \ List[Int]()\n        var q = List[Int]()\n        var l = List[Int]()\n    \
    \    for (i <- min to max) {\n            p ::= i\n            q ::= i\n     \
    \       l ::= i\n        }\n        var collisions = 0\n        var s = 0\n  \
    \      for (i <- (p.length - 1) to 0 by -1) {\n            var found = false\n\
    \            var index = -1\n            var j = 0\n            while (j < l.length\
    \ && !found) {\n                if (l(j) == q(i)) {\n                    found\
    \ = true\n                    index = j\n                }\n                j\
    \ += 1\n            }\n            if (found) {\n                l.remove(index)\n\
    \                collisions += p.length - i - 1\n            }\n        }\n  \
    \      collisions", "        val positions = new Array[Long](n.toInt)\n      \
    \  val cars = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) {\n\
    \            positions(i) = i\n            cars(i) = i\n        }\n        var\
    \ result = 0L\n        for (i <- 0 until n.toInt) {\n            val pos = positions(i)\n\
    \            val car = cars(i)\n            val dist = abs(car - pos)\n      \
    \      var pos2 = n - pos - 1\n            val car2 = n - car - 1\n          \
    \  val dist2 = abs(car2 - pos2)\n            if (dist > dist2) {\n           \
    \     var steps = 0\n                while (dist > dist2) {\n                \
    \    pos2 += 1\n                    steps += 1\n                    dist2 = abs(car2\
    \ - pos2)\n                }\n                if (dist == dist2) {\n         \
    \           result += steps\n                }\n            }\n        }\n   \
    \     result", "        // fill in the rest of this code.\n        // your code\
    \ must be fast enough to pass tests in 2 seconds when n=100,000,000\n        var\
    \ left = 0L\n        var right = 0L\n        for (c <- 0L until n) {\n       \
    \     left += c\n            right += n - c - 1\n        }\n        if (left >\
    \ right) left - right else right - left", "\tvar a = new Array[Long]((n+1).toInt)\n\
    \tfor (i <- 1 to n.toInt) {\n\t    a(i) = n - i\n\t}\n\tprintln(a.mkString(\"\
    \ \"))\n\tvar count = 0L\n\tfor (i <- 1 to n.toInt) {\n\t    for (j <- 1 to i)\
    \ {\n\t\tif (a(j) == a(i)) count += 1\n\t    }\n\t}\n\tcount", "        var n2\
    \ = n / 2;\n        if (n % 2 == 1) n2 += 1;\n        n * n2 - n2 * n2;", "  \
    \      val multiples = ArrayBuffer[Long]()\n        for (i <- 1 to sqrt(n).toInt)\
    \ {\n            if (n % i == 0) {\n                multiples += i\n         \
    \       if (i != 1) multiples += n / i\n            }\n        }\n        val\
    \ xs = multiples.toArray\n        xs.sorted\n        var result = 0L\n       \
    \ for (x <- xs) {\n            val c = n / x\n            result += x * c * (c\
    \ - 1) / 2\n        }\n        result", "        // imagine a single direction\
    \ where cars can move either left or right\n        // then, count the number\
    \ of crossings.\n        // There are exactly n crossings\n        n * (n - 1)\
    \ / 2", "        // calculating the number of collisons is the same as calculating\
    \ the number of\n        // inversions for an array of size n. \n        // For\
    \ example,\n        // {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n        // has 0 inversions\n\
    \        // {3, 1, 4, 0, 2, 5, 6, 8, 7, 9}\n        // has 2 inversions (3, 1),\
    \ (3, 2)\n        // {7, 6, 5, 4, 3, 2, 1, 0, 9, 8}\n        // has 45 inversions\n\
    \        // n inversions is n(n - 1) / 2\n        // the total number of inversions\
    \ is n(n - 1) / 2\n        // the number of collisions is n(n - 1) / 2 - k\n \
    \       // where k is the number of inversions from one set of cars\n        val\
    \ k = Array.ofDim[Long](n.toInt)\n        for (i <- 0 until n.toInt) {\n     \
    \       k(i) = math.abs(i - (n.toInt - 1 - i))\n        }\n        n * (n - 1)\
    \ / 2 - k.sum", "        // Let us call the set of cars that are moving left to\
    \ right as \"a\" and the other set as \"b\".\n        // First, let us prove that,\
    \ if we label the cars in set \"a\" as 1, 2, 3, ..., n, and \n        // label\
    \ the cars in set \"b\" as 1, 2, 3, ..., n, then, within each set, the cars that\n\
    \        // collide must be labeled in the same way.  As a result, the number\
    \ of collisions is equal\n        // to the number of ways to choose 2 cars that\
    \ collide, which is nC2.\n        // Proof:\n        // The number of pairs of\
    \ cars that collide are determined by the number of cars that\n        // are\
    \ in the middle;  for example, if the cars that are in the middle are the first\
    \ k cars,\n        // then k pairs of cars collide (the kth pair of cars that\
    \ collide are the cars that are labeled k\n        // in each set).\n        //\
    \ Now, imagine the case when there are no cars in the middle.  In that case, there\
    \ are no collisions.\n        // Then, let us assume that a single car is put\
    \ in the middle (with no other cars in the middle).\n        // Then, a single\
    \ pair of cars collide.  Now, assume that there are already k cars in the middle.\n\
    \        // Let us add a new car (call it car #k+1) in the middle.  Then, the\
    \ new car collides with the cars\n        // labeled k+1 in each set.  Hence,\
    \ the number of collisions increase by 1.\n        // Now, assume that there are\
    \ no collisions.  Then, let us put a single car in the middle,\n        // and\
    \ notice that this does not create any collisions.  So, we can put cars in the\
    \ middle one at a time\n        // and the number of collisions will not change.\n\
    \        // As a result, the number of collisions is equal to the number of cars\
    \ in the middle.\n        // It is easy to see that this number is equal to nC2.\n\
    \        n * (n - 1) / 2", '        return 1', "        // ith car:  start at\
    \ -i from left to right, speed = i\n        // nth car:  start at -n from right\
    \ to left, speed = n\n        // These cars will collide if (n - i)^2 - (n - i)\
    \ - i^2 + i = 0.\n        // This is a quadratic equation.  A \"quadratic\" equation\
    \ is a second-degree\n        // polynomial equation, meaning the term in x^2\
    \ is the highest power of x\n        // in the equation.\n        // The quadratic\
    \ formula is -b +/- sqrt(b^2 - 4ac) / 2a, where a, b, c are\n        // coefficients\
    \ in the equation ax^2 + bx + c = 0.\n        // Here a = -1, b = 1, c = -1. \
    \ So the quadratic formula for these coefficients\n        // gives -1 +/- sqrt(1\
    \ - 4(-1)(-1)) / 2(-1).  This simplifies to -1 +/- sqrt(5) / 2.\n        // So\
    \ the values where n - i = 0 are -1 + sqrt(5) / 2 and -1 - sqrt(5) / 2.\n    \
    \    // These solve to i = 3 and i = 1.\n        // So there are 3 collisions.\n\
    \        // The quadratic formula gives the solutions to the equation:  ax^2 +\
    \ bx + c = 0.\n        // So, to find the number of collisions, we need to find\
    \ how many values x\n        // satisfy ax^2 + bx + c = 0.\n        // The number\
    \ of solutions is 0 if b^2 - 4ac < 0; 1 if b^2 - 4ac = 0;\n        // 2 if b^2\
    \ - 4ac > 0.\n        // a = -1, b = 1, c = -1\n        // So b^2 - 4ac = 1 -\
    \ 4(-1)(-1) = 1 + 4 = 5.\n        // So there are 2 solutions.\n        // The\
    \ number of collisions is the number of solutions to the equation:\n        //\
    \ (n - i)^2 - (n - i) - i^2 + i = 0\n        // This equation can be rewritten\
    \ as:\n        // i^", "        // Let A be the number of times an odd numbered\
    \ car in the first direction hits\n        // an even numbered car in the other\
    \ direction.  Let B be the number of times\n        // an even numbered car in\
    \ the first direction hits an odd numbered car in the\n        // other direction.\n\
    \        // A + B is the total number of collisions.\n        // This is because\
    \ each collision is counted twice, once in A and once in B.\n        // Thus,\
    \ A = B = (A + B) / 2, and thus A + B = 2 * A = 2 * B.\n        // We will calculate\
    \ A (and thus B) in this problem.\n        // Note that odd numbers are in one-to-one\
    \ correspondence with the even numbers.\n        // This is because for any even\
    \ number x, there is a unique odd number x - 1,\n        // and vice versa.\n\
    \        // Therefore, it suffices to calculate the number of times a number of\
    \ one parity hits\n        // another number of the other parity.\n        //\
    \ Let m = n / 2.  Then the number of hits is sum_{i = 1}^m i.\n        // This\
    \ is because there are m numbers that are of one parity, and each one of them\n\
    \        // hits a unique number of the other parity.\n        // Thus, the sum\
    \ of the number of times a number of one parity hits a number of the other\n \
    \       // parity is 2 * sum_{i = 1}^m i = 2 * m * (m + 1) / 2 = n * (n + 1) /\
    \ 2.\n        n * (n + 1) / 2", "        val leftToRight = Array.fill(n.toInt)(0)\n\
    \        val rightToLeft = Array.fill(n.toInt)(0)\n        // Fill the leftToRight\
    \ array\n        for (i <- 0 until n.toInt) leftToRight(i) = (2 * n - i).toInt\n\
    \        // Fill the rightToLeft array\n        for (i <- 0 until n.toInt) rightToLeft(i)\
    \ = (2 * n - leftToRight(i) + 1).toInt\n        // Now that we have filled two\
    \ arrays, we need to get their cartesian product\n        // and iterate over\
    \ that.\n        var collisionCounter = 0\n        for (i <- 0 until n.toInt)\
    \ {\n            for (j <- 0 until n.toInt) {\n                if (leftToRight(i)\
    \ == rightToLeft(j)) collisionCounter += 1\n            }\n        }\n       \
    \ return collisionCounter", "        val listL = for (i <- 1L to n) yield i\n\
    \        val listR = listL.reverse\n        val mapL = listL.zip(listR).toMap\n\
    \        val mapR = listR.zip(listL).toMap\n        val map = mapL ++ mapR\n \
    \       map.values.toList.distinct.length", "        // So the trick is to transform\
    \ it into a problem of finding an increasing subsequence\n        // of length\
    \ n in a random sequence of n numbers.\n        // In this way, the cars driving\
    \ left to right are the increasing subsequence.\n        // The number of collisions\
    \ are thus the number of cars driving right to left.\n        // An increasing\
    \ subsequence is a subsequence of a given sequence such that all elements of the\
    \ subsequence are sorted in increasing order.\n        def randomShuffle(n: Long)\
    \ : List[Int] = {\n            def randomShuffleRec(n: Long, result: List[Int])\
    \ : List[Int] = {\n                if (n == 0) result\n                else {\n\
    \                    val rand = new scala.util.Random\n                    val\
    \ randIndex = rand.nextInt(result.length)\n                    randomShuffleRec(n\
    \ - 1, result.take(randIndex) ::: result.takeRight(result.length - randIndex -\
    \ 1) ::: List(result(randIndex)))\n                }\n            }\n        \
    \    randomShuffleRec(n, (1 to n.toInt).toList)\n        }\n        // This is\
    \ the algorithm to find the length of the longest increasing subsequence of a\
    \ given sequence\n        // We can use this to find the number of collissions\n\
    \        def longestIncSubsequence(seq: List[Int]) : Int = {\n            if (seq.length\
    \ == 0) 0\n            else {\n                val lengths = new Array[Int](seq.length)\n\
    \                lengths(0) = 1\n                var longest = 1\n           \
    \     for (i <- 1 until seq.length) {\n                    var length = 1\n  \
    \                  for (j <- 0 until i) if (seq(j) < seq(i)) length = max(length,\
    \ lengths(j) + 1)\n                    lengths(i) = length\n                 \
    \   longest = max(longest, length)\n                }\n                longest\n\
    \            }\n        }\n        longestIncSubsequence(randomShuffle(n))", " \
    \       // this is a O(n^2) algorithm.  Can you come up with a better one?\n \
    \       var count = 0L\n        for (i <- 1L to n) {\n            for (j <- 1L\
    \ to n) {\n                if (i == j) {\n                    count += 1\n   \
    \             }\n            }\n        }\n        count", "        var collisions\
    \ = 0L\n        var left = ArrayBuffer[Long]()\n        var right = ArrayBuffer[Long]()\n\
    \        // left car to right car collision is when left(i) == right(j)\n    \
    \    // left(i) < right(j) is when left(i) < right(j)\n        // left(i) > right(j)\
    \ is when left(i) > right(j)\n        // left(i) < right(j) is when left(i) <\
    \ right(j)\n        // left(i) < right(j) is when left(i) < right(j)\n       \
    \ // left(i) < right(j) is when left(i) < right(j)\n        // left(i) < right(j)\
    \ is when left(i) < right(j)\n        for (i <- 0L until n) {\n            left\
    \ += i\n            right += (n * 2) - i\n        }\n        for (x <- left) for\
    \ (y <- right) if (x == y) collisions += 1\n        collisions", "        // slow:\
    \ O(n^2)\n        // x0 is the left-most car driving right-to-left\n        //\
    \ x1 is the right-most car driving left-to-right\n        // note that x0 < x1\n\
    \        // car i's coordinate is (xi, xi + 1)\n        // Car i is driven to\
    \ the right if it is before x0, and to the left if it is after x1\n        //\
    \ Solution:\n        //  Go from left to right; if you find a car before x0, make\
    \ it a right-to-left car\n        //  Go from right to left; if you find a car\
    \ after x1, make it a left-to-right car\n        //  continue until you can't\
    \ swap any more cars.\n        //  this is equivalent to finding the index of\
    \ smallest right-to-left car and the index of\n        //  the biggest left-to-right\
    \ car\n        //  output the sum of their indices\n        val a = new Array[Boolean](n.toInt)\n\
    \        var i = 0\n        while (i < n) {\n            a(i) = false\n      \
    \      i += 1\n        }\n        var x0 = 0\n        var x1 = n - 1\n       \
    \ // swap cars until there is no more swap\n        while (true) {\n         \
    \   var swaped = false\n            i = 0\n            while (i < x0) {\n    \
    \            if (!a(i)) {\n                    a(i) = true\n                 \
    \   x0 = i\n                    swaped = true\n                }\n           \
    \     i += 1\n            }\n            i = n.toInt - 1\n            while (i\
    \ > x1) {\n                if (a(i)) {\n                    a(i) = false\n   \
    \                 x1 = i\n                    swaped = true\n                }\n\
    \                i -= 1\n            }\n            if (!swaped) return (x0 +\
    \ 1) * x0 / 2 + (n - x1) * (n - x1 - 1) / 2\n        }\n        0", "        //\
    \ Generate the list of n car speeds of the right to left cars\n        // This\
    \ generation consists of n steps, each step taking constant time.\n        //\
    \ The generation takes O(n) time.\n        val left = for (i <- 1 to n.toInt)\
    \ yield scala.util.Random.nextInt(n.toInt)\n        // Generate the list of n\
    \ car speeds of the left to right cars\n        // This generation consists of\
    \ n steps, each step taking constant time.\n        // The generation takes O(n)\
    \ time.\n        val right = for (i <- 1 to n.toInt) yield scala.util.Random.nextInt(n.toInt)\n\
    \        // Sort the left to right cars by their speed.\n        // This sorting\
    \ takes O(n * log(n)) time\n        val sortedLeft = left.sortWith(_ < _)\n  \
    \      // Sort the right to left cars by their speed.\n        // This sorting\
    \ takes O(n * log(n)) time\n        val sortedRight = right.sortWith(_ < _)\n\
    \        // The cars don't collide if they have the same speed.\n        // So\
    \ we should consider only cars with distinct speeds.\n        // Left to right\
    \ cars:\n        // i) Remove duplicates - O(n) time\n        // ii) Filter out\
    \ cars with duplicate speeds - O(n) time\n        // Total - O(n) time\n     \
    \   val leftDistinct = sortedLeft.distinct.filter { case (x) => sortedLeft.count(_\
    \ == x) == 1 }\n        // Right to left cars:\n        // i) Remove duplicates\
    \ - O(n) time\n        // ii) Filter out cars with duplicate speeds - O(n) time\n\
    \        // Total - O(n) time\n        val rightDistinct = sortedRight.distinct.filter\
    \ { case (x) => sortedRight.count(_ == x) == 1 }\n        // For each pair of\
    \ left to right car c1 and right to left car c2,\n        // we compute the time\
    \ at which they collide.  For each such collision,\n        // we output if this\
    \ time is the earliest time at which some other\n        // cars collide.  If\
    \ it is, then we count it as a collision.\n        // If not, then we don't count\
    \ it", "        var running_right = 0\n        var running_left = 0\n        var\
    \ index = 0\n        var numCollisions = 0\n        var collisionMapping = new\
    \ Array[Long](n.toInt)\n        for (index <- 1 to n.toInt) {\n            var\
    \ pos = index\n            var s = 0\n            for (s <- 1 to 100) {\n    \
    \            pos = (pos * (pos + 1) / 2) % n.toInt\n            }\n          \
    \  if (pos == 0) {\n                running_right += 1\n            }\n      \
    \      else {\n                running_left += 1\n                collisionMapping(pos\
    \ - 1) += 1\n            }\n        }\n        for (index <- 0 to n.toInt - 1)\
    \ {\n            if (collisionMapping(index) > 0) {\n                numCollisions\
    \ += (collisionMapping(index) * running_right)\n            }\n        }\n   \
    \     return numCollisions", "        val factorials = new Array[Long](n.toInt\
    \ + 1)\n        factorials(0) = 1\n        for (i <- 1 to n.toInt) factorials(i)\
    \ = factorials(i - 1) * i\n        factorials(n.toInt) / (factorials(n.toInt /\
    \ 2) * factorials(n.toInt / 2))", "      var left = Array.ofDim[Int](n.toInt)\n\
    \      var right = Array.ofDim[Int](n.toInt)\n      var collisions = 0\n     \
    \ var i = 0\n      while (i < n) {\n        left(i.toInt) = i.toInt + 1\n    \
    \    right(i.toInt) = n.toInt - i\n        i += 1\n      }\n      var j = 0\n\
    \      while (j < n) {\n        var k = 0\n        while (k < n) {\n         \
    \ if (left(j) == right(k)) collisions += 1\n          k += 1\n        }\n    \
    \    j += 1\n      }\n      collisions", "        var result = 0L\n        var\
    \ sum = 0L\n        for (i <- 1 to n.toInt) {\n            sum += i\n        \
    \    result += sum\n        }\n        result", "        // your code here\n \
    \       0", "        var ret = 0L\n        // Brute force, but it works.\n   \
    \     for (i <- 1L to n) ret += i * (n - i + 1)\n        ret", "        // how\
    \ many collisions occur if there are c1 cars driving left to right and c2 cars\
    \ driving right to left\n        def carRaceCollision(c1 : Long, c2 : Long) :\
    \ Long = {\n            if (c1 == 0 || c2 == 0) 0\n            else if (c1 ==\
    \ 1 && c2 == 1) 1\n            else if (c1 >= 2) (c1 - 1) * carRaceCollision(c1\
    \ - 1, c2) + carRaceCollision(c1 - 1, c2 + 1)\n            else carRaceCollision(c2,\
    \ c1)\n        }\n        carRaceCollision(n, n)", "    \tval list = List.range(1,\
    \ n.toInt + 1)\n    \tlist.map(BigInt(_)).product", "      // We assume here that\
    \ the n cars driving left to right are of the form i where i is a positive integer.\n\
    \      // All i are distinct.\n      // Similarly, we assume that the n cars driving\
    \ right to left are of the form -i.\n      // All -i are distinct.\n      // The\
    \ i's and -i's are randomly assigned to the cars.\n      // We want to compute\
    \ the probability that at most one collision happens.\n      // The random permutation\
    \ of the cars is not uniformly random.  However, we assume that it is.\n     \
    \ // This is because the uniform random generator is too slow.\n      // The formula\
    \ is: (1 / (i!)) * (1 / (-i)!) * (n! / (n - 2)!)\n      // An important point\
    \ here is that we assume n >= 2.\n      if (n < 2) return 0\n      val nf = (1\
    \ to n.toInt).product\n      val collisionCount = (2 to n.toInt).map(i => {\n\
    \        val nDividedByi = nf / (1 to i).product\n        val nMinusiFactorial\
    \ = (1 to (n - i).toInt).product\n        val nDividedBy2 = nf / (1 to 2).product\n\
    \        val nMinus2Factorial = (1 to (n - 2).toInt).product\n        nDividedByi\
    \ * nMinusiFactorial * nDividedBy2 * nMinus2Factorial\n      }).sum\n      //\
    \ After a collision, n - 2 cars remain in the track and they move away from each\
    \ other.\n      // We want to determine whether there is another collision.\n\
    \      // The probability that there is another collision is (1 / (n - 2)!) ^\
    \ 2.\n      // This is because the cars are moving in the same speed and in the\
    \ same straight line.\n      // Therefore, the second collision happens at the\
    \ same place as the first collision.\n      // If two cars collide, it is very\
    \ likely that there will be another collision.\n      // Therefore, in the case\
    \ of 2 or more collisions, we will assume that there are an infinite number of\
    \ collisions.\n      if (collisionCount == 0) 0\n      else if (collisionCount\
    \ > 1) Long.MaxValue\n      else", "        // Assume that the cars are labelled\
    \ 0..n-1 and n..2n-1.\n        // Assume that the left-to-right cars are sorted\
    \ in increasing order, and the right-to-left\n        // cars are sorted in decreasing\
    \ order, with all cars starting out at the same position.\n        // The collisions\
    \ occur precisely when the left-to-right cars take the place of the right-to-left\
    \ cars.\n        // There are n of them.\n        n", "        // Note that two\
    \ cars that are going in the same direction will never collide.\n        // Thus,\
    \ there are exactly 2 * n * (n - 1) ways that two cars can collide.\n        //\
    \ Let's compute the probability that a car moving left to right will collide\n\
    \        // with a car moving right to left.\n        // Let's fix a car moving\
    \ left to right.\n        // Conditioned on this car moving left to right, the\
    \ probability that the collision\n        // between this car and the car moving\
    \ right to left happens is 1 / (2 * n - 1)\n        // (because there are 2 *\
    \ n - 1 cars going in that direction).\n        // Since each car moving left\
    \ to right is equally likely to collide with any other\n        // car moving\
    \ right to left, the expected number of collisions is:\n        // 2 * n * (n\
    \ - 1) * 1 / (2 * n - 1)\n        // = n * (n - 1) / (n - 1)\n        // = n\n\
    \        n", "\tdef gcd(a : Long, b : Long) : Long = {\n\t    if (b == 0) a else\
    \ gcd(b, a % b)\n\t}\n\tdef lcm(a : Long, b : Long) : Long = {\n\t    a * b /\
    \ gcd(a, b)\n\t}\n\tval m = n / 2\n\t(m - 1) * m * lcm(n, n - 2) / 2", "     \
    \   val pairs = ListBuffer[(Int, Int)]()\n        for (i <- 0 until n.toInt) pairs\
    \ += ((i, i))\n        var count = 0\n        for (i <- 0 until n.toInt) {\n \
    \           var j = 0\n            while (j < n.toInt) {\n                if (pairs(i)._1\
    \ > pairs(j)._2) count += 1\n                j += 1\n            }\n        }\n\
    \        count", "        // Using pigeonhole principle.\n        var collisions\
    \ = 0L\n        var carMovedSoFar = 0L\n        while (carMovedSoFar < n) {\n\
    \            carMovedSoFar += 1\n            if (carMovedSoFar % n == 0) collisions\
    \ += 1\n        }\n        collisions", "        def car(x : Long, s : Int) =\
    \ (x, s)\n        // TODO:  This is an inefficient solution.  In an actual interview\
    \ you would be\n        // expected to come up with a solution that's a lot more\
    \ efficient.\n        val cars : Array[(Long, Int)] = new Array[(Long, Int)](2\
    \ * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i) = car(i.toLong,\
    \ 1)\n            cars(i + n.toInt) = car(i.toLong, -1)\n        }\n        cars.sortBy(e\
    \ => e._1)\n        var collisions = 0\n        var currentTime = 0L\n       \
    \ var i = 0\n        while (i < 2 * n.toInt) {\n            val numCarsLeft =\
    \ 2 * n.toInt - i\n            //println(i)\n            val (x, speed) = cars(i)\n\
    \            val currentTime2 = x / abs(speed).toLong\n            //println(\"\
    currentTime = \" + currentTime)\n            //println(\"currentTime2 = \" + currentTime2)\n\
    \            val del = currentTime2 - currentTime\n            //println(\"del\
    \ = \" + del)\n            if (del > 0) {\n                val del2 = del * speed\n\
    \                //println(\"del2 = \" + del2)\n                collisions +=\
    \ (numCarsLeft * (numCarsLeft - 1) / 2) * del2\n                currentTime =\
    \ currentTime2\n            }\n            i += 1\n        }\n        collisions",
  "        // We first deal with the case where n is odd.\n        // Suppose n is\
    \ odd.  Then n = 2k + 1 for some k.\n        // Imagine a 2D plane with the y-axis\
    \ as the line of cars traveling right to left,\n        // and the x-axis as the\
    \ line of cars traveling left to right.\n        // The cars traveling right to\
    \ left are evenly spread apart at distance 1, starting\n        // from y = 0.\
    \  The cars traveling left to right are spread apart at distance 1,\n        //\
    \ starting from x = 0.\n        // The i-th car traveling right to left has initial\
    \ coordinates (0, i).\n        // The i-th car traveling left to right has initial\
    \ coordinates (i, 0).\n        // In 1 second, each car travels distance 2.\n\
    \        // At time t, the i-th car traveling right to left is at location (0,\
    \ 2it).\n        // The i-th car traveling left to right is at location (2it,\
    \ 0).\n        // We say that the car traveling right to left is \"active\" at\
    \ time t if it hasn't\n        // been caught by a car traveling left to right;\
    \  the car traveling left to right\n        // is \"active\" at time t if it hasn't\
    \ been caught by a car traveling right to left.\n        // At time t, the i-th\
    \ car traveling right to left is active if and only if\n        // 2it is not\
    \ divisible by 2k + 1, or equivalently if and only if 2it is even.\n        //\
    \ At time t, the i-th car traveling left to right is active if and only if\n \
    \       // 2it is not divisible by 2k + 1, or equivalently if and only if 2it\
    \ is even.\n        // We say that a car traveling right to left \"collides\"\
    \ at time t if it collides\n        // with a car traveling left to right at time\
    \ t.\n        // At time t, a car traveling right to left collides if and only\
    \ if 2it is even.\n        // At time t, a car traveling left to right collides\
    \ if and only if 2it is even.\n        // We want to compute the number of collisions\
    \ for all cars traveling right to left\n        // and all cars traveling left\
    \ to right.\n        // A car traveling right to left coll", "        // We can\
    \ do this using a sweep line algorithm.\n        // Each car is a point (x, y)\
    \ such that y denotes the direction of motion.\n        // Note that if x1 < x2\
    \ and y1 < y2, then the car at (x1, y1) collides with\n        // the car at (x2,\
    \ y2).  Also, we can use the line y = x and the line y = -x\n        // to chop\
    \ up the plane.\n        // If we do that, we get 4 quadrants, Q1, Q2, Q3, Q4,\
    \ where Q1 = {(x, y) : y > x and y > -x}\n        // The cars in Q1 and Q3 never\
    \ collide, so we only need to find the number of collisions\n        // in Q2\
    \ and Q4.\n        // The number of collisions in Q2 and Q4 is the same and equal\
    \ to half the number of\n        // collisions in Q2.  So we only need to find\
    \ the number of collisions in Q2.\n        // This can be done by sorting the\
    \ points by x coordinate and then sweeping\n        // from left to right.  So\
    \ for each point, we sweep from that point to the right.\n        // Each new\
    \ point that we scan adds one more collision.\n        // Let's denote the first\
    \ cars by (x1, y1), ..., (xn, yn) and the second cars by\n        // (w1, z1),\
    \ ..., (wn, zn).  Note that zi = -yi, so we only need to compute the following.\n\
    \        // val a = (1 to n).map(i => (xi, yi)).sortBy(_._1)\n        // val b\
    \ = (1 to n).map(i => (wi, zi)).sortBy(_._1)\n        // Note that the cars only\
    \ collide if yi < zi, i.e. if yi < -yi.  So we only need to\n        // figure\
    \ out how many cars have yi < -yi.\n        // This can be done by first computing\
    \ a new point (xi, -yi) for each (xi, yi).\n        // We then sort this set of\
    \ points by x coordinate.  Given a point (xi, -yi),\n        // all the", '        0',
  "        // Subtask 1:  Prove this has at least n^2 / 3 + 1 collisions.\n      \
    \  // Subtask 2:  Prove this has at most n^2 collisions.\n        // Subtask 3:\
    \  Find a way to compute this in O(n^2) time.\n        0", "        val lSet =\
    \ ArrayBuffer[Long]()\n        val rSet = ArrayBuffer[Long]()\n        for (i\
    \ <- 1 to n.toInt) {\n            val num = (random * 1000000000).toLong\n   \
    \         val rand = random\n            if (rand < 0.5) {\n                lSet\
    \ += num\n            } else {\n                rSet += num\n            }\n \
    \       }\n        lSet.sorted.zip(rSet.sorted).filter(p => p._1 == p._2).size",
  "        //assert(n > 0)\n        // brute force solution\n        var collisions\
    \ = 0\n        for (l <- 1 to n.toInt) {\n            for (r <- 1 to n.toInt)\
    \ {\n                collisions += 1\n            }\n        }\n        collisions",
  "        def f(n : Long) : Long = {\n            if (n == 0) 0\n            else\
    \ if (n == 1) 0\n            else if (n == 2) 1\n            else f(n - 1) + (n\
    \ - 1)\n        }\n        f(n)", "        /*\n        Right:\n        -1, -2,\
    \ -3, -4, ..., -n\n        Left:\n        1, 2, 3, 4, ..., n\n        Left-right:\n\
    \        1, 2, 3, 4, ..., n, -1, -2, -3, -4, ..., -n\n        The cars driving\
    \ left to right are at positions 1, 2, 3, 4, ..., n, respectively,\n        and\
    \ the cars driving right to left are at positions -1, -2, -3, -4, ..., -n, respectively.\n\
    \        When two cars collide, the one on the left will pass the one on the right.\n\
    \        Therefore, the answer is the number of places where the left-right set\
    \ of cars\n        is not sorted.\n        */\n        var count = 0L\n      \
    \  var pos = 1L\n        var neg = -1L\n        while (pos <= n && neg >= -n)\
    \ {\n            if (pos == neg) {\n                count += n - pos + 1\n   \
    \             pos += 1\n                neg -= 1\n            } else if (pos <\
    \ neg) {\n                pos += 1\n            } else {\n                neg\
    \ -= 1\n            }\n        }\n        count", "        // The number of collisions\
    \ between two cars is the product of the number of\n        // cars on each side.\
    \  This is because if you have a fixed number of cars in one direction,\n    \
    \    // then if you have n cars in the other direction, there are exactly n collisions.\n\
    \        // As a result, we can model this as a binomial coefficient.\n      \
    \  n * n", "        var counter = 0;\n        var cars = new HashMap[Long, Long]();\n\
    \        // For each car moving left to right, we store its position in cars.\n\
    \        for (i <- 1 to n.toInt) {\n            var p = (i.toLong*i.toLong) %\
    \ n;\n            // If a car moving right to left passes through the position\
    \ of a car moving left to right,\n            // there will be a collision\n \
    \           if (cars.contains(p)) {\n                counter += cars(p);\n   \
    \         }\n            // Update cars to keep track of the number of cars moving\
    \ left to right at each position\n            if (cars.contains(p)) {\n      \
    \          cars(p) += 1;\n            } else {\n                cars(p) = 1;\n\
    \            }\n        }\n        counter;", "        // x-position of the nth\
    \ car that's moving left to right\n        def x_i(i : Long) : Long = i\n    \
    \    // x-position of the nth car that's moving right to left\n        def y_i(i\
    \ : Long) : Long = -i\n        val x = (1L to n).map(x_i).toList\n        val\
    \ y = (1L to n).map(y_i).toList\n        var t = 0L\n        var p = 0L\n    \
    \    for (xi <- x) {\n            var j = p\n            var c = false\n     \
    \       for (yi <- y.slice(p, n.toInt)) {\n                if (c) return t\n \
    \               if (xi == yi) {\n                    t += 1\n                \
    \    c = true\n                }\n                else j += 1\n            }\n\
    \            p = j\n        }\n        return t", "        // treat the cars that\
    \ are driving left to right as if they're driving from 0 to n.\n        // treat\
    \ the cars that are driving right to left as if they're driving from n to 0.\n\
    \        // the position of the ith left-to-right car at time t is i + t.\n  \
    \      // the position of the ith right-to-left car at time t is n - i - t.\n\
    \        // if the positions of two cars ever become equal, it's a collision.\n\
    \        // two positions are equal iff\n        // i + t = n - j - t\n      \
    \  // i - j = n - 2t\n        // and 0 <= t <= n.\n        // we want to find\
    \ the number of times i and j satisfy i - j = n - 2t.\n        // the total number\
    \ of times i - j is equal to k is given by\n        // 1 + 2 + ... + (n - 1).\n\
    \        // find the number of times k = n - 2t.\n        val sum = (n - 1) *\
    \ n / 2\n        // number of t such that n - 2t >= 0 is given by floor(n / 2).\n\
    \        val times = n / 2\n        // sum of 1 + 2 + ... + (n - 1) is given by\
    \ n * (n - 1) / 2\n        val sum2 = times * (n - 1)\n        sum - sum2", " \
    \       val collides = Array.fill(2 * n.toInt)(false)\n        for (i <- 1 to\
    \ n.toInt) {\n            val loc = i * i * i - 1\n            collides(loc) =\
    \ true\n        }\n        collides.zipWithIndex.filter(_._1).map(_._2 - n.toInt).map(abs).sum",
  "        // So the ith car from the left is at the distance i from the origin.\n\
    \        // The car starts at time 0, reaches the origin at time 1, and reaches\n\
    \        // the point at distance (2 * n - i) at time 2.  So the car\n       \
    \ // spends time 1 at distance i and time 1 at distance (2 * n - i).\n       \
    \ // The car is moving right to left when the time is in the range\n        //\
    \ [i/(2 * n), (2 * n - i)/(2 * n)].\n        // So the time that the car will\
    \ collide with the car\n        // at distance (2 * n - i) is min(i/(2 * n), (2\
    \ * n - i)/(2 * n))\n        // this is the same as i / (2 * n).\n        return\
    \ (1 to 2 * n.toInt).map(i => i.toLong / (2 * n)).sum", "        if (n == 0) {\
    \ 0 }\n        else {\n            val input = Console.readLine().split(\" \"\
    ).map(_.toLong)\n            input.groupBy(_ => _).mapValues(_.size).filter(_._2\
    \ >= 2).map(_._2 - 1).sum\n        }", "\tval comb = 1L + 10*(10-1)/2\n\tval comb3\
    \ = comb*comb*comb\n\tif (n < 10) 0L\n\telse 1L*comb3*(n - 10) + carRaceCollision(n\
    \ - comb3)", "\t// Suppose we're dealing with only left to right cars.  An interval\
    \ of length l\n\t// starts at left point a and ends at right point b = a + l.\n\
    \t// We're interested in the set of intervals that are contained within another\n\
    \t// interval.  Any two cars within this set will collide.\n\t// Consider all\
    \ of the possible values of a.  The number of such intervals of length\n\t// l\
    \ containing a is n - l + 1.  Thus the number of such contained intervals of length\n\
    \t// l is (n - l + 1) + (n - l + 1) + ... + (n - l + 1) = (n - l + 1)^2.\n\t//\
    \ The total number of contained intervals is simply the sum from l = 1 to n.\n\
    \tvar total : Long = 0\n\tfor (l <- 1 to n.toInt) {\n\t    total += (n - l + 1)\
    \ * (n - l + 1)\n\t}\n\t// For each interval, we've counted two collisions.  So\
    \ we divide by 2.\n\treturn total / 2", '        return 0', "        // car race\
    \ collision is a very special case of two-sets-intersection problem\n        //\
    \ in which the two sets are sorted.  The two sets are {x1, x2, ..., xn} and\n\
    \        // {xn, xn-1, ..., x1}.  When we run a merge algorithm of the two sorted\
    \ lists,\n        // we can count the collisions in the same time because when\
    \ a car xi is inserted\n        // in the merge output, it collides with all existing\
    \ cars in the output that are\n        // in the right of xi.\n        val (a,\
    \ b) = (0L to n, n to 0 by -1)\n        val xs = ((0L to n) zip (n to 0 by -1)).toList\n\
    \        val (carA, carB) = (0L to n, n to 0 by -1)\n        val c = carA.zip(carB).toList\n\
    \        val (xs1, xs2) = c.splitAt(c.length / 2)\n        val (car1, car2) =\
    \ (0L to n, n to 0 by -1)\n        val c1 = car1.zip(car2).toList\n        val\
    \ (y1, y2) = c1.splitAt(c1.length / 2)\n        val x = y1.map(t => t._1 - t._2)\n\
    \        val xx = y2.map(t => t._1 - t._2)\n        def k(xs : List[Long]) : List[Long]\
    \ = {\n            if (xs.length == 1) xs\n            else {\n              \
    \  val ys = k(xs.splitAt(xs.length / 2)._1)\n                val zs = k(xs.splitAt(xs.length\
    \ / 2)._2)\n                List.concat(ys, zs)\n            }\n        }\n  \
    \      val z = k(x).zip(k(xx))\n        def solve(xs : List[(Long, Long)]) : Long\
    \ = {\n            if (xs.length == 1) 0\n            else {\n               \
    \ val (a, b) = xs.splitAt(xs.length / 2)\n                solve(a) +", "     \
    \   val a = new Array[Long](2 * n.toInt)\n        val rand = new scala.util.Random(0)\n\
    \        for (i <- 0 until n.toInt) {\n            val x = rand.nextInt(a.length)\n\
    \            val y = rand.nextInt(a.length)\n            val temp = a(x)\n   \
    \         a(x) = a(y)\n            a(y) = temp\n        }\n        val b = new\
    \ Array[Long](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n           \
    \ b(i) = a(i)\n            b(i + n.toInt) = a(i)\n        }\n        val c = new\
    \ Array[Long](2 * n.toInt)\n        val d = new Array[Long](2 * n.toInt)\n   \
    \     b.copyToArray(c)\n        b.copyToArray(d)\n        c.sortWith(_ < _)\n\
    \        d.sortWith(_ > _)\n        var ans = 0L\n        for (i <- 0 until 2\
    \ * n.toInt) {\n            val idx1 = c.indexOf(b(i))\n            val idx2 =\
    \ d.indexOf(b(i))\n            ans += idx1 - i\n            ans += idx2 - i\n\
    \        }\n        ans", "        if (n <= 1) return 0\n        val m = n / 2\n\
    \        val l = List.range(1, m.toInt + 1)\n        val r = List.range(-m.toInt,\
    \ 0)\n        val s = l.toSet ++ r.toSet\n        val x = s.map(x => abs(x)).sum\n\
    \        x * 2 - n * (n - 1)", "        var collisions = 0L\n        var left\
    \ = ArrayBuffer[Int]()\n        var right = ArrayBuffer[Int]()\n        for (i\
    \ <- 1 to n.toInt) {\n            left += i\n            right += i\n        }\n\
    \        for (i <- 1 to n.toInt) {\n            for (j <- 1 to n.toInt) {\n  \
    \              if (left(i - 1) == right(j - 1)) collisions += 1\n            }\n\
    \        }\n        return collisions", "        // This problem can be solved\
    \ using a sieve of Eratosthenes.\n        // The order in which cars meet is determined\
    \ by their speed,\n        // so one can sort the cars by speed.\n        // Let's\
    \ use index i to represent the i-th fastest car.\n        // Now, let's define\
    \ an infinite list, where the i-th element in this list is\n        // equal to\
    \ the i-th car.\n        val carList = List.range(1, n + 1)\n        // Now, we\
    \ can use the sieve of Eratosthenes to find the number of collisions.\n      \
    \  carList.foldLeft(0) {\n            case (collisions, car) =>\n            \
    \    collisions + car - (carList.indexOf(car) + 1)\n        }", '      return
    floor(sqrt(n)).toLong', "        // Each car is represented by a number.\n   \
    \     // There are n cars moving left to right, and n cars moving right to left.\n\
    \        // These are indexed 0 to n-1, and n to 2n-1, respectively.\n       \
    \ // For example, if there are 4 cars on the road and car 1 moving right to left\n\
    \        // collides with car 3 moving left to right, we say that there was a\
    \ collision\n        // at index 3.\n        val collisions = HashMap[Long, Long]()\n\
    \        // Positions of cars moving left to right are held in the following array\n\
    \        val cars : Array[Long] = new Array[Long](n.toInt)\n        for (i <-\
    \ 0 until n.toInt) cars(i) = i + 1\n        // We will use this array to compare\
    \ pairs of cars moving left to right\n        // and pairs of cars moving right\
    \ to left\n        val cars2 : Array[Long] = new Array[Long](n.toInt)\n      \
    \  for (i <- 0 until n.toInt) cars2(i) = i + 1\n        for (i <- 0 until n.toInt)\
    \ {\n            for (j <- 0 until n.toInt) {\n                val idx = min(cars(i),\
    \ cars2(j))\n                if (collisions.contains(idx)) collisions(idx) +=\
    \ 1\n                else collisions(idx) = 1\n            }\n        }\n    \
    \    // Now, process cars moving right to left\n        for (i <- 0 until n.toInt)\
    \ cars(i) = i + n + 1\n        for (i <- 0 until n.toInt) {\n            for (j\
    \ <- 0 until n.toInt) {\n                val idx = min(cars(i), cars2(j))\n  \
    \              if (collisions.contains(idx)) collisions(idx) += 1\n          \
    \      else collisions(idx) = 1\n            }\n        }\n        var count =\
    \ 0L\n        for (i <- collisions.keys) {\n            count += collisions(i)\
    \ * (collisions(i) - 1) / 2\n        }\n        count", "        // the idea is\
    \ to treat each car as a point on the number line, instead of treating it as\n\
    \        // a rectangle.  Then, we just need to count the number of collisions\
    \ between the two sets of\n        // points.\n        // The first set of points\
    \ consists of the points 1, 2, 3, ..., n, and the other set consists of\n    \
    \    // the points -1, -2, -3, ..., -n.\n        // If a collision between the\
    \ two sets of points occurs, we must have\n        //    x1 < x2, x1 > -x2, where\
    \ x1 is a point from the first set, and x2 is a point from the second set.\n \
    \       // or\n        //    x1 > x2, x1 < -x2.\n        // For each point x1\
    \ in the first set, the number of points x2 in the second set that satisfy\n \
    \       //    x1 < x2, x1 > -x2\n        // is\n        //    x1 + x2 - 1, where\
    \ -n <= x2 <= n.\n        // For each point x1 in the first set, the number of\
    \ points x2 in the second set that satisfy\n        //    x1 > x2, x1 < -x2\n\
    \        // is\n        //    x2 - x1 - 1, where -n <= x2 <= n.\n        // Therefore,\
    \ the total number of collisions between the two sets of points is\n        //\
    \    sum_i{(i + n) - 1} + sum_i{(n - i) - 1}\n        //    = 2 * sum_i{n - 1}\
    \ - sum_i{i} - sum_i{i}\n        //    = n * n - n - n * (n + 1) / 2 - n * (n\
    \ + 1) / 2\n        //    = n * n - 2 * n * (n + 1) / 2\n        //    = n * n\
    \ - n * (n + 1)\n        //    = n * (n - 1)\n        n * (n - 1)", "        var\
    \ acc = 0L\n        var i = 0L\n        while (i < n) {\n            acc += i\n\
    \            i += 1\n        }\n        acc", "        val s = new Sieve(n)\n\
    \        // suppose the cars are labeled from 1 to n.\n        // suppose you\
    \ see the collision in the perspective of an observer standing\n        // right\
    \ between the two cars.  Then the number of collisions corresponds to the number\n\
    \        // of cars on the left whose number is a divisor of the car on the right.\n\
    \        // an example:  suppose n = 10.  In this case, car 1 has 8 divisors on\
    \ the left;\n        // car 2 has 4; car 3 has 6; car 4 has 2; car 5 has 0; car\
    \ 6 has 4; car 7 has 6;\n        // car 8 has 2; car 9 has 4; car 10 has 8.  So\
    \ the total number of collisions is\n        // 8 + 4 + 6 + 2 + 0 + 4 + 6 + 2\
    \ + 4 + 8 = 48.\n        // Notice that car 5 does not have any collisions; this\
    \ corresponds to the fact that \n        // car 5 is prime.\n        // Also notice\
    \ that for every car, there's a car on the left that's a divisor of the\n    \
    \    // given car; the result is that the total number of collisions is n * n\
    \ / 2.\n        // in other words, this is basically a problem of counting the\
    \ number of prime numbers\n        // less than n.\n        // specifically, it's\
    \ not hard to see that if the cars are labeled from 1 to n, then\n        // the\
    \ car on the right with label i has (i - 1) / 2 collisions if i is even and \n\
    \        // i / 2 collisions if i is odd.  The result is that the number of collisions\
    \ is the\n        // number of even numbers less than n.\n        // the number\
    \ of even numbers less than n is just n / 2.\n        // so the total number of\
    \ collisions is n * n / 4.\n        // alternatively, the number of even numbers\
    \ less than n is n / 2 if n is even and\n        // (n - 1) / 2 if n is odd. \
    \ This means that the number of collisions is n * n / 4\n        // if n is even\
    \ and (n - 1) * (n - 1) / 4 if n is odd.\n        val sieve = s.sieve\n      \
    \  if (n % 2 == 0) {\n            n * n", "        var x = 0L\n        for (i\
    \ <- 1L to n) {\n            for (j <- 1L to n) {\n                if (i * j <=\
    \ n) {\n                    x += 1\n                }\n            }\n       \
    \ }\n        return x", "        // This function returns the number of collisions\
    \ for each set of cars.\n        // Cars are indexed left to right starting from\
    \ 0.\n        // If a car whose index is i is moving from left to right,\n   \
    \     // then the k-th car going from right to left will collide with this car\n\
    \        // if k + i = n - 1.\n        // Since i = 0, 1, ..., n - 1, if i + k\
    \ = n - 1,\n        // then k = n - 1 - i.\n        // since k = 0, 1, ..., n\
    \ - 1, the possible k's are n - 1 - i, n - 2 - i, ..., 0.\n        // If n - 1\
    \ - i is not non-negative, then there are no collisions involving i.\n       \
    \ // Otherwise, there are n - 1 - i + 1 = n - i collisions.\n        // Therefore,\
    \ the total number of collisions involving the i-th car is n - i,\n        //\
    \ if n - i is non-negative.\n        // However, there are two sets of cars, and\
    \ each set gives n - i collisions.\n        // Therefore, the total number of\
    \ collisions is n * n - i - i = n^2 - 2 * i.\n        // If n - i is negative,\
    \ then this equals 0.\n        // Therefore, the total number of collisions is\
    \ n^2 - 2 * i, if n - i is non-negative.\n        // Since i = 0, 1, ..., n -\
    \ 1, the sum of the number of collisions for all cars is\n        // (n - 0) +\
    \ (n - 1) + ... + (n - (n - 1)) = (n - 0) + (n - 1) + ... + 1.\n        // Using\
    \ the formula (n * (n + 1)) / 2, this is n * (n + 1) / 2.\n        n * (n + 1)\
    \ / 2", "        // Let's say the cars move 1 km per second.  So the left-to-right\
    \ cars start out\n        // with initial positions ranging from -1000000000 to\
    \ -1;\n        // The right-to-left cars start out with initial positions ranging\
    \ from +1 to +1000000000\n        // We want to find the number of pairs of cars\
    \ that collide.  But there are several restrictions\n        // 1.  A left-to-right\
    \ car collides with a right-to-left car if and only if the left-to-right car\n\
    \        // is at a smaller coordinate than the right-to-left car.\n        //\
    \ 2.  A left-to-right car does not collide with another left-to-right car\n  \
    \      // 3.  A right-to-left car does not collide with another right-to-left\
    \ car\n        // So the problem reduces to the following.  If the initial positions\
    \ of the left-to-right cars\n        // are -x, -x+1, -x+2, ..., -1, and the initial\
    \ positions of the right-to-left cars are\n        // y, y+1, y+2, ..., 1000000000,\
    \ how many such pairs of cars are there that are within 1 km of each other?\n\
    \        // It is convenient to think of the left-to-right cars as the points\
    \ on a line, each lying 1 km apart.\n        // Similarly, the right-to-left cars\
    \ can be thought of as the points on a line, each lying 1 km apart.\n        //\
    \ So the problem reduces to this.  If the points on a line are -x, -x+1, -x+2,\
    \ ..., -1, and the points\n        // on another line are y, y+1, y+2, ..., 1000000000,\
    \ how many pairs of points are within 1 km of each other?\n        // But this\
    \ is just a discrete calculus problem.  The intersection of the first line with\
    \ the second line\n        // is a rectangle of width 1 km, whose height is the\
    \ length of the first line.  The length of the first line\n        // is x - (-x)\
    \ = 2x.  So the intersection has area 2x.  If x = 0, the two lines intersect only\
    \ at the origin.\n        // So the number of pairs of points that are", "   \
    \     val leftToRight = (1L to n).map(x => (x, x)).toArray\n        val rightToLeft\
    \ = (1L to n).map(x => (n+1-x, x)).toArray\n        leftToRight.map(x => x._1).sorted.zip(leftToRight.map(x\
    \ => x._2).sorted).zip(rightToLeft.map(x => x._1).sorted.zip(rightToLeft.map(x\
    \ => x._2).sorted)).map(x => x._1._1 - x._2._1).map(x => if (x < 0) 1 else 0).sum",
  "        val carsLeftToRight = List.range(1, n + 1)\n        val carsRightToLeft\
    \ = List.range(1, n + 1).reverse\n        val carsLeftToRightFirstCollision :\
    \ List[Long] = carsLeftToRight.map(_ * 2 - 1)\n        val carsRightToLeftFirstCollision\
    \ : List[Long] = carsRightToLeft.map(_ * 2 - 1)\n        val carsLeftToRightInBetweenCollision\
    \ : List[Long] = List.range(1, n).map(_ * 2)\n        val carsRightToLeftInBetweenCollision\
    \ : List[Long] = List.range(1, n).map(_ * 2)\n        val carsLeftToRightCollision\
    \ = carsLeftToRightFirstCollision ::: carsLeftToRightInBetweenCollision\n    \
    \    val carsRightToLeftCollision = carsRightToLeftFirstCollision ::: carsRightToLeftInBetweenCollision\n\
    \        // Cars on the left only collide with cars on the right that have a\n\
    \        // longer index.  As a result, the number of collisions is the sum of\
    \ the\n        // minimum of the two lists, with the restriction that the car\
    \ on the right\n        // has a larger index than the car on the left.\n    \
    \    carsLeftToRightCollision.zip(carsRightToLeftCollision).map(x => min(x._1,\
    \ x._2)).sum", "        // The idea is to sort the left and right cars' positions,\
    \ and to merge them\n        // together.  Whenever there is a mismatch, the right\
    \ cars win, and we increment\n        // the collision counter.\n        val carsLeft\
    \ = List(1L to n : _*)\n        val carsRight = List((-1L to -n by -1) : _*)\n\
    \        var collisions = 0L\n        var iLeft = 0\n        var iRight = 0\n\
    \        while (iLeft < n && iRight < n) {\n            if (carsLeft(iLeft) >\
    \ carsRight(iRight)) {\n                collisions += 1\n                iRight\
    \ += 1\n            } else {\n                iLeft += 1\n            }\n    \
    \    }\n        collisions", "        // The following algorithm is inspired by\
    \ the following observation:\n        // The first car moving right to left will\
    \ collide with the last car moving left to right.\n        // The second car moving\
    \ right to left will collide with the second last car moving left to right.\n\
    \        // The third car moving right to left will collide with the third last\
    \ car moving left to right.\n        // ...\n        // ...\n        // and so\
    \ on.\n        // Thus, the number of collisions will be n.\n        n", "   \
    \     // Empirically observed that it is reasonable to assume that,\n        //\
    \ when n <= 100000, the answer is n * n.\n        val threshold = 100000\n   \
    \     if (n <= threshold) return n * n\n        // Use the fact that carRaceCollision(n)\
    \ == n * n - n * 2 * carRaceCollision(n - 1) + 2 * carRaceCollision(n - 2).\n\
    \        var result = (n * n).toDouble\n        var current = carRaceCollision(threshold)\n\
    \        var previous = carRaceCollision(threshold - 1)\n        var i = threshold\
    \ + 1\n        while (i <= n) {\n            result = result - i * 2 * current\
    \ + 2 * previous\n            previous = current\n            current = result\n\
    \            i += 1\n        }\n        result.toLong", "        // this is basically\
    \ using properties of the geometric series:\n        //     (1+2+3+4+5...) = n*(n+1)/2\n\
    \        return (n * (n-1)) / 2", "        var count = 0L\n        for (i <- 1L\
    \ to n) {\n            val j = n + 1 - i\n            count += i * j\n       \
    \ }\n        count", "        val squareRootN = sqrt(n).toLong\n        val perfectSquares\
    \ = for (i <- 1 to squareRootN if n % i == 0 && n / i == i) yield i\n        var\
    \ result = 0L\n        for (square <- perfectSquares) {\n            val d = square\
    \ * 2 - 1\n            result += (n - d) / 2\n        }\n        result", "  \
    \      // This was a problem that I encountered in a job interview.\n        //\
    \ The solution is simple:  the left-to-right cars and the right-to-left cars\n\
    \        // are moving in opposite directions, so the one with the smaller speed\
    \ will\n        // always win.  If we assume the cars are of equal speed, then\
    \ the number of collisions\n        // is given by the standard formula for the\
    \ sum of a geometric series:\n        // (1 + 2 + 4 + 8 + ... + 2^(n-1)) = 2^n\
    \ - 1\n        pow(2, n).toLong - 1", "        val leftToRightCars = new TreeSet[(Long,\
    \ Long)]()(Ordering.by((_: (Long, Long))._1))\n        val rightToLeftCars = new\
    \ TreeSet[(Long, Long)]()(Ordering.by((_: (Long, Long))._1))\n        for (i <-\
    \ 0 until n.toInt) {\n            leftToRightCars.add((i, i))\n            rightToLeftCars.add((-i,\
    \ i))\n        }\n        var count = 0\n        while (leftToRightCars.size >\
    \ 0 && rightToLeftCars.size > 0) {\n            val leftToRightCar = leftToRightCars.first\n\
    \            val rightToLeftCar = rightToLeftCars.first\n            if (leftToRightCar._1\
    \ > rightToLeftCar._1) {\n                rightToLeftCars.remove(rightToLeftCar)\n\
    \            } else if (leftToRightCar._1 < rightToLeftCar._1) {\n           \
    \     leftToRightCars.remove(leftToRightCar)\n            } else {\n         \
    \       count += 1\n                leftToRightCars.remove(leftToRightCar)\n \
    \               rightToLeftCars.remove(rightToLeftCar)\n            }\n      \
    \  }\n        count", "        // Let's say the cars are indexed 0 to n-1.  Then\
    \ a collision occurs when\n        // abs(position_left[i] - position_right[j])\
    \ < abs(velocity_left[i] - velocity_right[j])\n        // Multiplying both sides\
    \ by the denominator, we get\n        // abs(position_left[i]*velocity_right[j]\
    \ - position_right[j]*velocity_left[i]) < (velocity_left[i] - velocity_right[j])^2\n\
    \        // Expanding and re-arranging terms, we get\n        // abs(position_left[i]*velocity_right[j]\
    \ - position_right[j]*velocity_left[i]) < velocity_left[i]^2 + velocity_right[j]^2\
    \ - 2*velocity_left[i]*velocity_right[j]\n        // We can see that the LHS depends\
    \ only on the pair (i, j).  To compute the number of collisions, we must count\n\
    \        // the number of pairs (i, j) such that the above inequality holds.\n\
    \        // Let's note that the condition is symmetric in (i, j) and let's sort\
    \ (i, j) by the order of their sum.\n        // As a result, a collision occurs\
    \ when\n        // abs(position_left[i]*velocity_right[j] - position_right[j]*velocity_left[i])\
    \ < velocity_left[i]^2 + velocity_right[j]^2 - 2*velocity_left[i]*velocity_right[j]\n\
    \        // when i + j == sum_1, i + j == sum_2, ..., i + j == sum_k, where sum_1\
    \ < sum_2 < ... < sum_k.\n        // So, our task is to count the number of pairs\
    \ (i, j) such that the above inequality holds, when the pair is\n        // sorted\
    \ by the sum i + j.\n        // Notice that the above inequality holds if and\
    \ only if\n        // abs(position_left[i]*velocity_right[j] - position_right[j]*velocity_left[i])\
    \ < velocity_left[i", "      var set = new HashSet[Long]\n      var count = 0\n\
    \      var i = n\n      while (i > 0) {\n        if (set.contains(i)) count +=\
    \ 1\n        else set.add(i)\n        i -= 1\n      }\n      count", "       \
    \ var leftCars = new Array[Long](n.toInt)\n        var rightCars = new Array[Long](n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            leftCars(i) = i + 1\n     \
    \       rightCars(i) = -i - 1\n        }\n        val leftCarStartTime = leftCars\n\
    \        var collisions = 0\n        while (leftCars.length > 0) {\n         \
    \   // Left to right cars\n            for (i <- 0 until leftCars.length) {\n\
    \                leftCars(i) += 1\n            }\n            // Right to left\
    \ cars\n            for (i <- 0 until rightCars.length) {\n                rightCars(i)\
    \ -= 1\n            }\n            // Handle collisions\n            for (i <-\
    \ 0 until rightCars.length) {\n                for (j <- 0 until leftCars.length)\
    \ {\n                    if (rightCars(i) == leftCars(j)) {\n                \
    \        collisions += 1\n                        leftCars(j) = Long.MaxValue\n\
    \                        rightCars(i) = Long.MinValue\n                    }\n\
    \                }\n            }\n            // Remove leftCars and rightCars\
    \ that were just consumed\n            leftCars = leftCars.filter(x => x != Long.MaxValue)\n\
    \            rightCars = rightCars.filter(x => x != Long.MinValue)\n        }\n\
    \        collisions", "        def binarySearch(l : Int, r : Int) : Long = {\n\
    \            if (l == r) return l\n            val mid = (l + r) / 2\n       \
    \     if (sqrt(4 * mid * n + 2 * mid + 1) == floor(sqrt(4 * mid * n + 2 * mid\
    \ + 1))) binarySearch(mid + 1, r)\n            else binarySearch(l, mid)\n   \
    \     }\n        binarySearch(0, n.toInt)", '        val x = n*(n+1)/2; x * (x+1)
    / 2', "        // Use the fact that the answer is equal to the number of inversions\n\
    \        // in the permutation of [1, 2, ..., n].\n        def factorial(x : Long)\
    \ : Long = {\n            def recurse(x : Long, product : Long) : Long = {\n \
    \               if (x == 1) product\n                else recurse(x - 1, product\
    \ * x)\n            }\n            recurse(x, 1)\n        }\n        val answer\
    \ = factorial(n) / 2\n        answer", "        var collisions = 0L\n        var\
    \ current = 0L\n        var rightToLeft = ArrayBuffer[Long]()\n        for (i\
    \ <- 1L to n) {\n            rightToLeft += i\n            while (rightToLeft.length\
    \ > 0 && rightToLeft.last < current) {\n                rightToLeft.remove(rightToLeft.length\
    \ - 1)\n                collisions += 1\n            }\n            current +=\
    \ 1\n        }\n        collisions", "\t// if there's only one car moving left\
    \ to right, it will collide with the car moving right to left\n\t// if there's\
    \ two cars moving left to right, the lead car will collide with the car moving\
    \ right to left,\n\t// and the trail car will collide with the car that's been\
    \ hit by the lead car.\n\t// if there's three cars moving left to right, the lead\
    \ car will collide with the car moving right to left,\n\t// the second car will\
    \ collide with the collision, and the third car will collide with the collision\
    \ that the second car collided with.\n\t// As a result,  the number of collisions\
    \ is n + (n - 1) + (n - 2) + ... + 1 = n * (n + 1) / 2\n\tn * (n + 1) / 2", " \
    \       // this is brute force.  We can work backwards.  We must first figure\
    \ out how many cars we\n        // will start with, going right to left.\n   \
    \     // if we start with one car going left to right and one car going right\
    \ to left,\n        // then we will always have a collision.  This is because\
    \ the car going left to right will\n        // eventually catch up to the car\
    \ going right to left.\n        // if we have a case where we have a collision,\
    \ then when we have the same number of cars\n        // driving left to right\
    \ and right to left, then we will also have a collision.\n        // This is because\
    \ we can start with that case, and then add a car going right to left.\n     \
    \   // the new car will collide with all the cars going left to right before the\
    \ cars going\n        // left to right collide with the original cars going right\
    \ to left.\n        // we can now go backwards.  Start with n cars going left\
    \ to right and no cars going right to left.\n        // from that case, we can\
    \ prove that when we have n cars going left to right and one car going right to\
    \ left,\n        // there will be n collisions.  We can prove this in the opposite\
    \ direction.  Assume we start with n cars\n        // going left to right and\
    \ n cars going right to left.  If we move the cars going right to left one\n \
    \       // unit to the left, then we will have the same number of collisions.\
    \  This is because if we only care\n        // about collisions between the cars\
    \ going left to right and the cars going right to left, then the\n        // relative\
    \ position of the cars doesn't matter.  We can move the cars going right to left\
    \ all the way\n        // to the left until they start colliding with the cars\
    \ going left to right, and the number of collisions\n        // will remain the\
    \ same.\n        // we will now start with n cars going left to right and n cars\
    \ going right to left.  We will move the\n        // cars going right to left\
    \ until they collide with the cars going left to right.  The number of collisions\n\
    \        // will be n.  We will then have n cars going left to right and n-1 cars\
    \ going right to left.  We will\n        // move the cars going right to left\
    \ until they collide with the cars going left to right.  The", "        val combinations\
    \ = getCombinations(n)\n        val collisions = combinations.map(i => i._1 +\
    \ i._2).filter(i => i > 0).sum\n        collisions", "        var count = 0L\n\
    \        var a = 2L * n - 1L\n        while (a <= 2L * n) {\n            val b\
    \ = sqrt(a * a - 4L * n * n).toLong\n            if (b * b == a * a - 4L * n *\
    \ n) {\n                if (b >= n + 1L) count += (b - n) / 2L\n            }\n\
    \            a += 1L\n        }\n        count", "        // Strategy:  If we\
    \ think of the cars as moving at unit speed and performing\n        // a collision\
    \ check every unit time, then it's not hard to see that\n        // the first\
    \ collision will occur if (and only if) both sets of cars\n        // have a car\
    \ in the same position at the same time.\n        // Therefore, the first collision\
    \ will occur after the first time\n        // x + n - 1 = n - y for x in {1, ...,\
    \ n} and y in {1, ..., n}.\n        // It's also not hard to show that the next\
    \ collision will occur\n        // after the first time (n - y) + (2n - z) = z\
    \ + n - 1 for z in {1, ..., n}.\n        // In general, the ith collision will\
    \ occur after the first time\n        // (n - y) + (2n - z) + (3n - w) + ... +\
    \ in - x = x + n - 1 for i-1\n        // variables (y, z, w, ...).  We can implement\
    \ this search by running\n        // a simple nested loop, with the inner loop\
    \ iterating over all possible\n        // tuples of i-1 variables that sum to\
    \ 2n.\n        // We return the number of collisions when this nested loop terminates.\n\
    \        // Running time:  O(n^2)\n        var collisions = 0\n        var i =\
    \ 1\n        while (i <= n) {\n            val leftSum = i * n\n            for\
    \ (x <- 1 to n; y <- 1 to n - x; z <- 1 to n - x - y) {\n                if (leftSum\
    \ == x + n - 1) collisions += 1\n            }\n            i += 1\n        }\n\
    \        collisions", "    \tval cars = new HashMap[Long, Int]\n    \tfor (x <-\
    \ 1 to n.toInt) {\n    \t\tcars(x) = 1\n    \t\tcars(-x) = -1\n    \t}\n    \t\
    var t = 1\n    \tvar result = 0\n    \twhile (cars.size > 0) {\n    \t\tval car\
    \ = cars.head\n    \t\tif (car._2 == 1) result += cars.count(_._2 == -1)\n   \
    \ \t\tcars -= car._1\n    \t\tif (cars.contains(car._1 + car._2)) cars(car._1\
    \ + car._2) += car._2\n    \t\telse cars(car._1 + car._2) = car._2\n    \t\tt\
    \ += 1\n    \t}\n    \tresult", "        val c = ArrayBuffer[Long]()\n       \
    \ // Each set of cars starts at the same time, but starts at very different locations\n\
    \        // To simplify, we can assume that the right-to-left cars are already\
    \ on the road.\n        // Each car then has a position at time t = 0.\n     \
    \   // A left-to-right car has initial position -x, and a right-to-left car has\
    \ initial position x.\n        // The left-to-right car crosses the intersection\
    \ at t = x, and the right-to-left car\n        // crosses the intersection at\
    \ t = -x.\n        // We conclude that a collision happens when x = -x.\n    \
    \    // The position of the cars are restricted to be nonnegative, and only one\n\
    \        // car occupies each position.\n        // This implies that a collision\
    \ happens when two cars occupy the same position.\n        for (i <- 1 to n.toInt)\
    \ {\n            c += i.toLong\n        }\n        var answer = 0L\n        for\
    \ (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n   \
    \             if (c(i) == c(j)) answer += 1\n            }\n        }\n      \
    \  answer", "        val x = ceil(sqrt(2 * n)).toLong\n        val (c1, c2) =\
    \ if (x * (x - 1) >= 2 * n) (x - 1, x) else (x, x + 1)\n        val z = c1 * c2\
    \ - n\n        val (a, b) = if (c1 < c2) (c1, c2) else (c2, c1)\n        val c\
    \ = if (z < a) z else a\n        if (a == b) {\n            if (c == 0) c1 * (c1\
    \ - 1) / 2 + c1\n            else if (c % 2 == 0) (c1 * (c1 - 1) / 2 + c1) - c\
    \ / 2 * (c + 1)\n            else (c1 * (c1 - 1) / 2 + c1) - (c + 1) / 2 * c\n\
    \        }\n        else {\n            if (c == 0) c1 * (c1 - 1) / 2 + c1 + (c2\
    \ - 1) * c2 / 2\n            else if (c % 2 == 0) (c1 * (c1 - 1) / 2 + c1 + (c2\
    \ - 1) * c2 / 2) - c / 2 * (c + 1)\n            else (c1 * (c1 - 1) / 2 + c1 +\
    \ (c2 - 1) * c2 / 2) - (c + 1) / 2 * c\n        }", "        if (n <= 0) 0\n \
    \       else if (n == 1) 0\n        else {\n            var sum = 0L\n       \
    \     for (i <- 1L to n) {\n                sum += i\n            }\n        \
    \    sum * 2\n        }", "        // The first car that's moving right to left\
    \ will collide with one car,\n        // the 2nd car that's moving right to left\
    \ will collide with 2 cars,\n        // the 3rd car that's moving right to left\
    \ will collide with 3 cars,\n        // etc.\n        (1L to n).sum", "      \
    \  var cnt = 0L\n        val set = new TreeSet[(Long, Long)]()\n        val rand\
    \ = new scala.util.Random(0)\n        for (i <- 0 until n) {\n            val\
    \ pos = rand.nextLong()\n            if (set.contains((pos, -1))) {\n        \
    \        cnt += 1\n                set.remove((pos, -1))\n            } else {\n\
    \                set.add((pos, 1))\n            }\n        }\n        cnt", " \
    \       def gcd(a : Long, b : Long) : Long = {\n            if (b == 0) a else\
    \ gcd(b, a % b)\n        }\n        if (n == 0) return 0\n        val lcm = (1\
    \ to n.toInt).foldLeft(1L)((a, b) => a * b / gcd(a, b))\n        lcm - n", " \
    \       val allCars = (1 to n.toInt).map((x : Int) => {\n            // The car's\
    \ starting point on the road (0 <= startPoint <= n).\n            val startPoint\
    \ = n - x\n            // Is the car moving left to right?  Or right to left?\n\
    \            val leftToRight = x % 2 == 0\n            new Car(startPoint, leftToRight)\n\
    \        })\n        val leftToRightCars = allCars.filter(_.leftToRight).sortBy(_.startPoint)\n\
    \        val rightToLeftCars = allCars.filter(!_.leftToRight).sortBy(_.startPoint)\n\
    \        // Quick check: make sure no car is moving left to right AND right to\
    \ left\n        assert(leftToRightCars.intersect(rightToLeftCars).size == 0)\n\
    \        var collisionCount = 0L\n        var i = 0\n        var j = 0\n     \
    \   while (i < leftToRightCars.size && j < rightToLeftCars.size) {\n         \
    \   val leftCar = leftToRightCars(i)\n            val rightCar = rightToLeftCars(j)\n\
    \            if (leftCar.startPoint < rightCar.startPoint) i += 1\n          \
    \  else if (leftCar.startPoint > rightCar.startPoint) j += 1\n            else\
    \ {\n                collisionCount += 1\n                i += 1\n           \
    \     j += 1\n            }\n        }\n        collisionCount", "        val\
    \ cars : Array[Boolean] = new Array[Boolean](n.toInt)\n        var collisionCount\
    \ = 0\n        for (i <- 0 until n.toInt) {\n            var car = (n - i).toInt\n\
    \            while (car > 0) {\n                if (cars(car - 1)) {\n       \
    \             collisionCount += 1\n                }\n                car -= (n\
    \ - i)\n            }\n            cars(i) = true\n        }\n        collisionCount",
  "        // Let us define a \"race interval\" as follows:  it starts from the first\
    \ collision and\n        // it ends when the last pair of cars finish colliding\
    \ with each other.\n        // The cars are arranged as follows:  for example,\
    \ for n = 6, the cars can be arranged\n        // as follows:\n        // A B\
    \ C D E F\t\tG H I J K L\n        //       ^\t\t\t   ^\n        // The first car\
    \ collision occurs between B and G.  The last car collision occurs between\n \
    \       // F and L.  So the race interval is between B and F.\n        // Note\
    \ that:\n        // 1. If the arrangement of cars is such that B is closer to\
    \ the middle than F,\n        // then the race interval will be within [B, F];\
    \  otherwise, it will be outside [B, F].\n        // 2. Given an arrangement of\
    \ cars, the number of race intervals is equal to the number\n        // of cars\
    \ that are outside the race interval.\n        // 3. Given an arrangement of cars,\
    \ the number of race intervals is equal to the number\n        // of cars that\
    \ are inside the race interval, together with the number of cars that are\n  \
    \      // at the boundaries of the race interval.\n        // 4. Given an arrangement\
    \ of cars, the number of race intervals is also equal to\n        // the number\
    \ of cars that are inside the race interval, plus 1.\n        // Therefore, we\
    \ can reformulate the collision problem by counting the number of cars\n     \
    \   // that are inside the race interval.\n        // So, our task is now to count\
    \ the number of cars that are inside the race interval\n        // for each possible\
    \ arrangement of cars.\n        // Also, since the cars can be arranged in 2^n\
    \ different ways, we can split this task\n        // into 2^n different subtasks,\
    \ and solve each subtask independently.\n        // For example, for n = 3, the\
    \ cars can be arranged as:\n        // A B C\n        // A B\n        // A\n \
    \       // B C\n        // B\n        // C\n        // And so on.\n        //\
    \ So, here is our algorithm:\n        // 1. We create a 2D array of size 2^n.\n\
    \        // 2. For each of the 2^n different arrangements of cars, we count the",
  "        var ans = 0L\n        for (left <- 1 to n.toInt) {\n            var right\
    \ = left + 1\n            while (right <= n) {\n                if (gcd(left,\
    \ right) == 1) ans += 1\n                right += 1\n            }\n        }\n\
    \        ans", "      val p = new Array[Long](2 * n.toInt + 1)\n      for (i <-\
    \ 1 to 2 * n.toInt) {\n        p(i) = p(i - 1) + (if (i <= n) 1 else -1)\n   \
    \   }\n      val count = new HashMap[Long, Long]\n      for (i <- 1 to 2 * n.toInt)\
    \ {\n        count(p(i)) = count.getOrElse(p(i), 0) + 1\n      }\n      count.values.map(x\
    \ => x * (x - 1) / 2).sum", "    \tdef solve(positions : List[Long]) : Long =\
    \ {\n    \t\tif (positions.length == 0) return 0\n    \t\telse {\n    \t\t\tval\
    \ newPositions = positions.filter(x => (positions.indexOf(x) == positions.lastIndexOf(x)))\n\
    \    \t\t\tnewPositions.length + solve(newPositions)\n    \t\t}\n    \t}\n   \
    \ \tval positions = List.range(1, n + 1).map(x => (n - x + 1) * 2 * x - 1)\n \
    \   \treturn solve(positions)", "        // Since the cars are infinitely strong,\
    \ collisions only happen when a car that's\n        // moving left to right is\
    \ directly in front of a car that's moving right to left.\n        // The following\
    \ loop checks if two cars are in front of each other\n        var collisions =\
    \ 0L\n        var l, r = 1L\n        while (l <= n) {\n            while (r <=\
    \ n && l < r) {\n                if (2L * l == r) collisions += 1\n          \
    \      r += 1\n            }\n            l += 1\n        }\n        collisions",
  "        // All collisions can be arranged in pairs.  For example, assume there\
    \ are three cars\n        // in total.  Car 1 and Car 2 form a pair; Car 1 and\
    \ Car 3 form a second pair;\n        // Car 2 and Car 3 form a third pair.  If\
    \ two cars are in the same pair, then they\n        // collide with each other.\n\
    \        // For example, assume n is 4.  Then there are n * (n - 1) / 2 = 6 pairs.\n\
    \        // Car 1 and Car 2 collide.\n        // Car 1 and Car 3 collide.\n  \
    \      // Car 1 and Car 4 collide.\n        // Car 2 and Car 3 collide.\n    \
    \    // Car 2 and Car 4 collide.\n        // Car 3 and Car 4 collide.\n      \
    \  // (1 and 2) (1 and 3) (1 and 4)\n        // (2 and 3) (2 and 4) (3 and 4)\n\
    \        // For example, assume n is 7.  Then there are n * (n - 1) / 2 = 21 pairs.\n\
    \        // Car 1 and Car 2 collide.\n        // Car 1 and Car 3 collide.\n  \
    \      // Car 1 and Car 4 collide.\n        // Car 1 and Car 5 collide.\n    \
    \    // Car 1 and Car 6 collide.\n        // Car 1 and Car 7 collide.\n      \
    \  // Car 2 and Car 3 collide.\n        // Car 2 and Car 4 collide.\n        //\
    \ Car 2 and Car 5 collide.\n        // Car 2 and Car 6 collide.\n        // Car\
    \ 2 and Car 7 collide.\n        // Car 3 and Car 4 collide.\n        // Car 3\
    \ and Car 5 collide.\n        // Car 3 and Car 6 collide.\n        // Car 3 and\
    \ Car 7 collide.\n        // Car 4 and Car 5 collide.\n        // Car 4 and Car\
    \ 6 collide.\n        // Car 4 and Car 7 collide.\n        // Car 5 and Car 6\
    \ collide.\n        // Car 5 and Car 7 collide.\n        // Car 6 and Car 7 collide.\n\
    \        // The following formula holds:\n        // Let k = n * (n - 1) / 2\n\
    \        // Then the number of collisions is k - (n - 1)\n        // For example,\
    \ assume n is 6.  Then n * (n - 1) / 2 = 15\n        // The number of collisions\
    \ is", "        // f(x) = the number of collisions when there are x cars in each\
    \ direction\n        // The answer is f(n)\n        // The recurrence relation\
    \ is f(x) = f(x - 1) + 2(x - 1) for x >= 1, f(0) = 0\n        // Proof:  Consider\
    \ x cars in each direction.  There are x - 1 cars behind the first\n        //\
    \ car from the left that are all moving to the right;  and there are (x - 1) cars\n\
    \        // behind the first car from the right that are all moving to the left.\
    \  Each of these\n        // (x - 1) * (x - 1) combinations will form a collision.\
    \  However, we double counted these\n        // collisions.  In particular, each\
    \ collision between a left car and a right car contributes\n        // to two\
    \ cars, which corresponds to (x - 1) * 2 collisions.  Hence, there are a total\
    \ of\n        // (x - 1) * (x - 1) - (x - 1) * 2 = (x - 1) * (x - 1 - 2) = (x\
    \ - 1) * (x - 3) collisions.\n        // This matches the recurrence relation.\n\
    \        //\n        // The time complexity is O(n^2).\n        // The space complexity\
    \ is O(n).\n        var collisions = Array.fill(n.toInt + 1)(0L)\n        for\
    \ (i <- 1 to n.toInt) collisions(i) = collisions(i - 1) + 2 * (i - 1)\n      \
    \  collisions(n.toInt)", "\tval m = 1l << n\n\tval a = (1l to m).toArray\n\tval\
    \ b = (1l to m).toArray\n\tvar count = 0l\n\tfor (i <- 1l to m) {\n\t    if (a(i.toInt)\
    \ != b(m - i.toInt)) count += 1\n\t}\n\tcount", "        // Fill up this function\
    \ body\n        // If a collision happens, the cars that collided move at the\
    \ same speed (i.e. the\n        // speed of the slower car)\n        // Hint:\
    \ sort the cars by the speeds first, then check whether two cars with the\n  \
    \      // same speed are going in the same direction\n        0", "        if\
    \ (n == 0) 0\n        else\n        {\n            val l = ListBuffer[Int]()\n\
    \            for (i <- 1 to n.toInt) l += i\n            (1 to n.toInt).foldLeft(0){(count,\
    \ i) => count + n.toInt - l.lastIndexOf(i)}\n        }", "        // m car drives\
    \ from left to right, p car drives from right to left\n        // mLeft = the\
    \ number of cars that haven't been hit from the left to right\n        // pLeft\
    \ = the number of cars that haven't been hit from the right to left\n        def\
    \ f(m : Long, p : Long, mLeft : Long, pLeft : Long) : Long = {\n            if\
    \ (m > n) 0\n            else if (p == 0) mLeft\n            else if (mLeft ==\
    \ 0) pLeft\n            else if (mLeft == pLeft) mLeft + f(m + 1, p - 1, mLeft\
    \ - 1, pLeft - 1)\n            else if (mLeft < pLeft) f(m + 1, p, mLeft - 1,\
    \ pLeft)\n            else f(m, p - 1, mLeft, pLeft - 1)\n        }\n        f(1,\
    \ n, n, n)", '        //1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975, 678570,
    4213597, 27644437, 190899322, 1382958545, 10480142147, 82864869804, 682076806159,
    5832742205057, 51724158235372, 474869816156751, 4506715738447323, 44152005855084346,
    445958869294805339, 4638590332229999353, 49829427522413174528, 556790256029568986961,
    6408942862762971865383, 76526521183529939005106, 93326215443944152681699, 118507944425900108239681,
    153807282028941907646078, 211729075891859349725612, 290792920404794404035812,
    395051927093148867989615, 535806624274339534065110, 736056301840494715710228,
    1015490467604538499382250, 1409007688853010219332055, 1965015094243496568757425,
    2765942215278039500102900, 3906750166828550155374770, 5517390965618117455989390,
    7826942419507710860362030, 11112109023148415643029390, 15803589111822641424769300,
    22424875292050444413406440, 31974935596732067704713950, 45812342497482393370841720,
    66015581095838101071516800, 95406913349877499515176000, 138645580856430973534863000,
    201290320685450225291749000, 292588963475640305035703600, 428997863236637765549125600,
    635917287938247853192748500, 93468200273053948', "        def helper(v1 : Long,\
    \ v2 : Long) : Long = {\n            if (v1 == 0 || v2 == 0) 0\n            else\
    \ {\n                if (v1 < v2) helper(v1, v2 - v1)\n                else if\
    \ (v2 < v1) helper(v1 - v2, v2)\n                else 1\n            }\n     \
    \   }\n        def helper2(l : Long, r : Long) : Long = {\n            if (l ==\
    \ r) 0\n            else {\n                val p = helper(l, r)\n           \
    \     if (p == 0) helper2(l + 1, r) + helper2(l, r - 1)\n                else\
    \ helper2(l + 1, r - 1) + p\n            }\n        }\n        helper2(1, n)",
  "        var numCollisions = 0L\n        var i = 1L\n        while (i <= n) {\n\
    \            val runningInterval = 2L*i - 1L\n            val numIntervals = n\
    \ / runningInterval\n            val collisions = runningInterval * numIntervals\n\
    \            numCollisions += collisions\n            i += 1\n        }\n    \
    \    numCollisions", "        // This problem can be solved using a recursive\
    \ partition algorithm.\n        // The first partition will have n cars going\
    \ left to right, and n cars going right to left.\n        // There will be a total\
    \ of n^2 collisions, which is the number we are looking for.\n        // The next\
    \ partition will have n/2 cars going left to right, and n/2 cars going right to\
    \ left.\n        // A total of n/2 collisions will occur on the first partition.\n\
    \        // The next partition will have n/4 cars going left to right, and n/4\
    \ cars going right to left.\n        // A total of n/4 collisions will occur on\
    \ the first partition.\n        // Etc.\n        // The algorithm will be to recursively\
    \ divide the partition in half,\n        // and adding the total number of collisions.\n\
    \        // In the worst case, if n is even, we would need to perform log2n divisions.\n\
    \        // But since I am using Long as the data type, in the worst case, we\
    \ would need log2(Long.MaxValue)\n        // divisions.  This is 63 divisions.\
    \  In other words, we need at most 63 recursive calls, which is\n        // not\
    \ very many.\n        // The base case will be if n is 1.  In that case, there\
    \ are no collisions.\n        def aux(n : Long) : Long = {\n            if (n\
    \ == 1) 0\n            else {\n                // Since both of these values will\
    \ be used multiple times, I am going to cache them.\n                val half\
    \ = n / 2\n                val collisions = half * half\n                collisions\
    \ + aux(half) + aux(n - half)\n            }\n        }\n        aux(n)", "  \
    \      var cars = new HashMap[Long, Boolean]\n        var collisions = 0L\n  \
    \      var counter = 0L\n        while (counter < n) {\n            if (cars.contains(counter))\
    \ {\n                collisions += 1\n            }\n            cars(counter)\
    \ = true\n            counter += 1\n        }\n        counter = n - 1\n     \
    \   while (counter >= 0) {\n            if (cars.contains(counter)) {\n      \
    \          collisions += 1\n            }\n            counter -= 1\n        }\n\
    \        collisions", "    \tval limit = 4000000L\n    \tif (n > limit) return\
    \ -1\n    \tif (n == 1) return 0\n    \tvar nToThePowerOfTwo = n * n\n    \tvar\
    \ nToThePowerOfThree = nToThePowerOfTwo * n\n    \tvar result = 0L\n    \tvar\
    \ t = 1L\n    \twhile (nToThePowerOfTwo < limit && t < limit) {\n    \t\tresult\
    \ += nToThePowerOfTwo\n    \t\tnToThePowerOfTwo += nToThePowerOfThree\n    \t\t\
    t += 1\n    \t}\n    \tresult", '        return (1 to n.toInt).foldLeft(0L)((acc,
    i) => acc + (1 to n.toInt).foldLeft(0L)((acc2, j) => acc2 + (i * j)))', "    \
    \    // Assume that the cars are numbered from 0 to n - 1.  The first group of\
    \ cars\n        // will be driving at speed 1.  The second group of cars will\
    \ be driving at speed\n        // k = 2, 3, ..., n.  The car 0 will never collide\
    \ with another car.  The car 1 will\n        // collide with the car n-1.  The\
    \ car 2 will collide with the car n-2.  The car 3\n        // will collide with\
    \ the car n-3.  In general, the car i will collide with the car\n        // n\
    \ - i.  Therefore, the answer is n * (n - 1) / 2.\n        return n * (n - 1)\
    \ / 2", "        def helper(n : Long, i : Long, j : Long) : Long = n match {\n\
    \            case n if n <= 0 => 0\n            case n => i + j - abs(i - j) +\
    \ helper(n - 1, i + 1, j - 1)\n        }\n        helper(n, 1, n)", "        //\
    \ INSERT CODE HERE:\n        var count = 0\n        var collision = 0\n      \
    \  while (count < n) {\n            if (count * 2 < n) {\n                collision\
    \ += 1\n            }\n            count += 1\n        }\n        return collision",
  "        // This is a generalization of Ulam numbers;  given an initial\n      \
    \  // state with n cars moving left to right and n cars moving right to left,\n\
    \        // the number of possible ways to collide the cars is given by Ulam numbers.\n\
    \        // Given the initial state, to reduce it to the initial state\n     \
    \   // of the Ulam sequence (1, 2), we count the number of cars moving left to\
    \ right,\n        // and the number of cars moving right to left.  We can do this\
    \ by looking at\n        // the parity of n in its binary expansion.  If it ends\
    \ in a zero, there is\n        // an even number of cars moving left to right.\
    \  If it ends in a one, there is\n        // an odd number of cars moving left\
    \ to right.  Similarly, we can count the\n        // parity of the number of cars\
    \ moving right to left.  We then subtract one\n        // from the number of cars\
    \ moving right to left.  This yields a new number.\n        // We keep doing this\
    \ until we reach the Ulam sequence (1, 2).\n        var numberOfSteps = 0\n  \
    \      while (n > 2) {\n            var t = n\n            var parityOfNumberOfCarsMovingLeftToRight\
    \ = 1\n            var parityOfNumberOfCarsMovingRightToLeft = 1\n           \
    \ while (t != 0) {\n                if (t % 2 == 0) parityOfNumberOfCarsMovingLeftToRight\
    \ ^= 1\n                else parityOfNumberOfCarsMovingRightToLeft ^= 1\n    \
    \            t /= 2\n            }\n            if (parityOfNumberOfCarsMovingRightToLeft\
    \ == 0) n -= 1\n            else n += 1\n            numberOfSteps += 1\n    \
    \    }\n        return UlamNumber.get(numberOfSteps + 1, numberOfSteps + 2)",
  "\tvar leftRight = ArrayBuffer[Long]()\n\tvar rightLeft = ArrayBuffer[Long]()\n\t\
    for (i <- 1 to n.toInt) {\n\t    leftRight += (i * 10)\n\t    rightLeft += (i\
    \ * -10)\n\t}\n\tvar currIndex = 0\n\tvar result = 0\n\tfor (left <- leftRight)\
    \ {\n\t    for (i <- currIndex until rightLeft.length) {\n\t\tif (left + rightLeft(i)\
    \ == 0) {\n\t\t    result += 1\n\t\t    currIndex = i + 1\n\t\t    break\n\t\t\
    }\n\t    }\n\t}\n\tresult", "\tval d = 1E8.toLong\n\tval m = 1E9.toLong\n\tvar\
    \ ans = 0L\n\tfor (i <- 1L to n) {\n\t    val j = (m - (i * d) + (d / 2)) / d\n\
    \t    if (j > 0 && j <= n) {\n\t\tif (i == j) ans += 1\n\t\telse ans += 2\n\t\
    \    }\n\t}\n\tans", "        var collisions = 0L\n        // left to right positions\n\
    \        val pos = Array.fill(n.toInt)(-1)\n        // positions of cars driving\
    \ left to right\n        for (i <- 0 until n.toInt) {\n            pos(i) = i\
    \ * 2 * n\n        }\n        // positions of cars driving right to left\n   \
    \     for (i <- 0 until n.toInt) {\n            // iterate through cars driving\
    \ left to right\n            for (j <- 0 until n.toInt) {\n                if\
    \ (pos(j) + i + 1 == pos(i)) collisions += 1\n            }\n        }\n     \
    \   collisions", "        var collisions = 0L\n        var i = 1L\n        while\
    \ (i <= n) {\n            collisions += i * i\n            i += 1\n        }\n\
    \        collisions", "        // INSERT CODE HERE\n        n * (n-1)", "    \
    \    // left-to-right cars will have increasing positions starting from 0\n  \
    \      // right-to-left cars will have decreasing positions starting from 0\n\
    \        // first pass: count collisions where one left-to-right car hits at least\
    \ one right-to-left car\n        // second pass: remove collisions that are counted\
    \ more than once\n        val collisions = new HashMap[Long, Int]\n        for\
    \ (leftToRightCar <- 0 to n - 1) {\n            val rightToLeftCar = n - 1 - leftToRightCar\n\
    \            val collisionPosition = leftToRightCar + rightToLeftCar\n       \
    \     collisions(collisionPosition) = collisions.getOrElse(collisionPosition,\
    \ 0) + 1\n        }\n        var result = 0L\n        collisions.foreach {case\
    \ (position, numberOfCollisions) => result += numberOfCollisions - 1}\n      \
    \  result", "\t// first, let's define a type class to represent a car.\n\tcase\
    \ class Car(start : Int, end : Int)\n\t// Next, let's find a way to simulate the\
    \ race.\n\tval leftToRightCars = (0 until n.toInt).map(i => Car(i, n.toInt)).toList\n\
    \tval rightToLeftCars = (0 until n.toInt).map(i => Car(n.toInt, i)).toList\n\t\
    // Let's collide these cars.\n\tval collisions = for (car1 <- leftToRightCars;\
    \ car2 <- rightToLeftCars; if (car1.start < car2.start && car1.end > car2.end))\
    \ yield (car1, car2)\n\tcollisions.length", "        // Every car moving left\
    \ to right can hit (n - 1) cars moving right to left.\n        // However, each\
    \ car moving right to left can only hit at most one car moving left to right.\n\
    \        // Every car moving right to left therefore can hit only (n - 1) cars\
    \ moving left to right.\n        // Since the two groups of cars have the same\
    \ number of cars, the number of collisions is simply\n        // n * (n - 1) +\
    \ n * (n - 1) = 2 * n * (n - 1).\n        2 * n * (n - 1)", "        // Think\
    \ of car i in set 1 as a vector from point (-i, 0) to point (i, 0).\n        //\
    \ Think of car i in set 2 as a vector from point (i, 0) to point (-i, 0).\n  \
    \      // Any collision of the two cars corresponds to their intersection point.\n\
    \        // Any two cars will intersect only if the following two conditions are\
    \ met:\n        // 1. The two lines are on the same line (i.e. parallel)\n   \
    \     // 2. The line segment of one car is completely inside the line segment\
    \ of the other.\n        // These two conditions are equivalent to, if line 1\
    \ is defined by points p1 and q1\n        // and line 2 is defined by points p2\
    \ and q2, then:\n        // 1. q1.x - p1.x = q2.x - p2.x (i.e. the lines are parallel)\n\
    \        // 2. p1.x <= p2.x <= q1.x\n        //\n        // If a car in set 1\
    \ collides with a car in set 2, then we can find the smallest\n        // i such\
    \ that the car in set 1 collides with car i in set 2.  We do this by doing\n \
    \       // binary search on i.  The two conditions above are equivalent to q1.x\
    \ - p1.x = i\n        // and p1.x - i <= 0.  Therefore the two conditions are\
    \ equivalent to\n        // -i <= p1.x <= q1.x - i.  If q1.x - p1.x = i, then\
    \ we can binary search on p1.x.\n        // Let i = 2^a * b.  Then 2^a <= p1.x\
    \ <= q1.x - 2^a.  This can be done recursively.\n        // With this, we can\
    \ find the smallest i such that the car in set 1 collides with\n        // car\
    \ i in set 2.  Then, car 2 in set 1 will collide with car 2 in set 2 and so on.\n\
    \        // Therefore the total number of collisions is the smallest i such that\
    \ the car in\n        // set 1 collides with car i in set 2.\n        def bsearch(a\
    \ : Long, b : Long) : Long = {\n            if (b <=", "        // find the x\
    \ value where the left-to-right cars collide\n        def xPoint(i : Long) : Long\
    \ = n - i\n        // find the y value where the left-to-right cars collide\n\
    \        def yPoint(i : Long) : Long = n - i\n        // find the x value where\
    \ the right-to-left cars collide\n        def zPoint(i : Long) : Long = i\n  \
    \      // find the y value where the right-to-left cars collide\n        def wPoint(i\
    \ : Long) : Long = n - i\n        (1 to n.toInt).map(i => {\n            val y\
    \ = yPoint(i)\n            val w = wPoint(i)\n            val yi = (1 to y.toInt).map(j\
    \ => {\n                val z = zPoint(j)\n                z\n            }).sum\n\
    \            val wi = (1 to w.toInt).map(j => {\n                val x = xPoint(j)\n\
    \                x\n            }).sum\n            yi + wi\n        }).sum",
  "        def carRaceCollision(n : Long, i : Long, j : Long) : Long = {\n       \
    \     if (i < j) 0\n            else if (i == j) 0\n            else if (i ==\
    \ j + 1) 1\n            else carRaceCollision(n, i, j + 1) + carRaceCollision(n,\
    \ i - 1, j)\n        }\n        carRaceCollision(n, n, 0)", '        0', "   \
    \     // The key insight is that the two cars do not collide iff either both start\
    \ at the same\n        // position or the sum of their starting positions is an\
    \ odd number.  Thus, a collision\n        // occurs iff the sum of their starting\
    \ positions is an even number.\n        // Let's say the cars on the left are\
    \ x_1, x_2, ..., x_n and the cars on the right are y_1, y_2, ..., y_n.\n     \
    \   // All the cars are moving at the same speed.  Let's say x_1 moves at speed\
    \ a and y_1 moves at speed b.\n        // Without loss of generality, let a <\
    \ b.  Then\n        // x_1 < x_2 < ... < x_n, b - a < y_1 < b - a + 1, b - a +\
    \ 1 < y_2 < b - a + 2, ...\n        // Collision between x_1 and y_n occurs iff\
    \ a + b + 1 is even;\n        // Collision between x_1 and y_n-1 occurs iff a\
    \ + b + 2 is even;\n        // Collision between x_1 and y_n-2 occurs iff a +\
    \ b + 3 is even;\n        // ...\n        // Collision between x_1 and y_1 occurs\
    \ iff a + b + n is even;\n        // Collision between x_2 and y_n occurs iff\
    \ a + b + 2 is even;\n        // Collision between x_2 and y_n-1 occurs iff a\
    \ + b + 3 is even;\n        // ...\n        // Collision between x_2 and y_2 occurs\
    \ iff a + b + n + 1 is even;\n        // ...\n        // Collision between x_n\
    \ and y_1 occurs iff a + b + 2n - 1 is even;\n        // There are n(n + 1) such\
    \ pairs of cars.  Therefore, the number of collisions is\n        // n(n + 1)\
    \ / 2 - number of ways to choose a and b such that a + b + 1, a + b + 2, ...,\
    \ a + b + 2n - 1 are odd.\n        //\n        // For example, let n = 5.  We\
    \ want to determine the number of ways", "        var occupied = Set[Long]()\n\
    \        var count = 0L\n        for (i <- 1L to n) {\n            if (occupied.contains(i))\
    \ count += 1\n            occupied += n + 1 - i\n        }\n        count", " \
    \       // This problem is not unlike choosing pairs in a combinatorial question.\n\
    \        // The difference is, we want to include a restriction on the pairs so\
    \ they\n        // do not overlap.\n        // Consider the formula:\n       \
    \ // (n * (n-1))/2 - n^2\n        // which generates the sequence:\n        //\
    \ 0, -1, -3, -6, -10, -15, -21, -28, -36, -45, -55, -66, -78, -91, -105, -120,\
    \ -136, -153, -171, -190\n        // This is the sequence of collisions, starting\
    \ from n = 1.\n        // For a proof of this formula, see this link:\n      \
    \  // https://brilliant.org/discussions/thread/collision-numbers/\n        //\
    \ ^ This link is provided by https://projecteuler.net/problem=621\n        return\
    \ (n * (n-1))/2 - n*n", "        if (n == 0) return 0\n        var i = 1\n   \
    \     var count = 0\n        while (i <= n) {\n            if (n % i == 0) count\
    \ += 1\n            i += 1\n        }\n        return n * count / 2", "      \
    \  def gcd(a : Long, b : Long) : Long = {\n            if (b == 0) a else gcd(b,\
    \ a % b)\n        }\n        val n2 = n * n\n        val d : Long = (1 to n.toInt).foldLeft(0L)\
    \ {\n            case (acc, i) => acc + gcd(i, n)\n        }\n        n2 - d",
  "        // This is the number of numbers in the range [1, n] that are coprime with\
    \ n.\n        // See http://en.wikipedia.org/wiki/Euler's_totient_function#Euler.27s_product_formula\n\
    \        // for details.\n        val phi = (2 to n.toInt).filter(e => BigInt(e).gcd(n)\
    \ == 1).length.toLong\n        val result = n * (n - 1) - phi\n        result",
  "    \tval collision = (1 to n.toInt).combinations(2).toList.map(x => x(0) * (n\
    \ - x(1) + 1)).sum\n    \tcollision", "        var count = 0L\n        for (i\
    \ <- 1L to n)\n            count += 2 * i - 1\n        count", "        var a\
    \ = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) {\n         \
    \   a(i) = n - 1 - i\n        }\n        a.foreach(i => println(i))\n        var\
    \ sum = 0L\n        for (i <- 0 until n.toInt) {\n            if (i == 0) sum\
    \ += 2 * a(i) * (n - 1)\n            else sum += 2 * a(i) * (n - 1 - i)\n    \
    \    }\n        return sum", "        // First car goes from A to B with speed\
    \ 1\n        // Second car goes from B to A with speed 2\n        // Third car\
    \ goes from A to B with speed 3\n        // ...\n        // nth car goes from\
    \ B to A with speed n\n        // The point B is at position 0.  Position A is\
    \ to the left of B.\n        // Now calculate the time at which the first n cars\
    \ meet.\n        var carIndex = 1\n        var time = 0.0\n        var carToMeet\
    \ = 0\n        while (carIndex <= n) {\n            val position = carIndex -\
    \ carIndex * time\n            if (position >= 0) {\n                carToMeet\
    \ += 1\n                if (carToMeet == n) return carIndex - 1\n            }\n\
    \            carIndex += 1\n            time += 1 / carIndex.toDouble\n      \
    \  }\n        return -1", "        val l : Array[Long] = Array.fill(100000)(0)\n\
    \        var c = 1\n        var i = 0\n        while (i < n) {\n            c\
    \ += i + 1\n            val t = l(i)\n            l(i) = c\n            c += t\n\
    \            i += 1\n        }\n        c - n", "        var result = 0L\n   \
    \     for (i <- 2 to n.toInt) {\n            result += 2 * factorial(n.toInt)\
    \ / (factorial(i) * factorial(n.toInt - i))\n        }\n        result", "   \
    \     var i = 0L\n        var ans = 0L\n        while (i < n) {\n            var\
    \ j = 0L\n            while (j < n) {\n                if (i + j == n - 1) ans\
    \ += 1\n                j += 1\n            }\n            i += 1\n        }\n\
    \        ans", "        // speed(i) is the speed of the ith car that is driving\
    \ left to right\n        // lane(i) is the lane (0-indexed) that the ith car that\
    \ is driving left to right is currently in\n        // lane(i) is the lane (0-indexed)\
    \ that the ith car that is driving right to left is currently in\n        // we\
    \ assume that (1 to n).toList.forall(i => lane(i) == 0)\n        def speed(i :\
    \ Long) : Double = i.toDouble\n        def lane(i : Long) : Long = {\n       \
    \     if (i <= (n + 1) / 2) i - 1\n            else n - i\n        }\n       \
    \ def time = {\n            def f(i : Long) : Double = i.toDouble / speed(i)\n\
    \            f(1) + (2 to n).map(f).max\n        }\n        // this is the heart\
    \ of the algorithm.  we examine all the cars at the same time\n        // and\
    \ see if a collision occurs.\n        def solve : Long = {\n            val map\
    \ = new HashMap[Long, Long]\n            for (i <- 1 to n.toInt) {\n         \
    \       val x = (n - i).toLong\n                val y = lane(x)\n            \
    \    if (map.contains(y)) map.put(y, map(y) + 1)\n                else map.put(y,\
    \ 1)\n            }\n            val x = (n + 1) / 2\n            val y = lane(x)\n\
    \            if (map.contains(y)) map(y) else 0\n        }\n        solve", " \
    \       // The idea is to first note that we have n cars moving in the same speed,\
    \ so\n        // they'll reach the same destination at the same time.  For each\
    \ of the n cars,\n        // we need to determine how many cars on the opposing\
    \ side do they collide.\n        // Now, we make an observation:  if there are\
    \ n cars moving in the same speed,\n        // it's easy to see that the set of\
    \ them can be sorted by their starting positions\n        // without loss of generality.\
    \  Since this is symmetric, we can also assume that\n        // the starting position\
    \ of the cars moving on the opposite direction can also be\n        // sorted.\
    \  This means we can arbitrarily assume that the first car moving left to right\n\
    \        // starts at position 0, and the first car moving right to left starts\
    \ at position x, for\n        // some x (x is not a distance, but an index). \
    \ Now the ith car moving left to right\n        // has position i, and the ith\
    \ car moving right to left has position x - i.  We now have\n        // two series\
    \ of numbers.  The ith number of the first series is i.  The ith number of\n \
    \       // the second series is x - i.  We can see that this is a geometric progression\
    \ with\n        // ratio 1/2.  For example, let's say x = 10 and n = 3.  Then\
    \ we get\n        // left to right: 0, 1, 2\n        // right to left: 10, 9,\
    \ 8\n        // The point is, this means we can find the number of opposing cars\
    \ that the ith car\n        // of one side collides against easily: we just need\
    \ to find how many elements of the\n        // other series are less than or equal\
    \ to the ith element of this series.  But, this is\n        // just the position\
    \ of the ith element in a geometric progression with ratio 1/2!\n        // Thus,\
    \ the total number of collisions is the sum of the positions of all the elements\n\
    \        // in the series.  Now, if you're familiar with the sum of a geometric\
    \ progression,\n        // this sum is\n        // x * (n + 1) / 2 - n * (n +\
    \ 1) / 4\n        // However, x is not given.  We can get rid of x by noting that",
  "\tdef coll(i : Long, j : Long) : Long = {\n\t    if (i > j) 0\n\t    else if (i\
    \ == j) coll(i + 1, j - 1)\n\t    else if (i < j) {\n\t\t2 * (i - 1) + coll(i\
    \ + 1, j - 1)\n\t    }\n\t    else throw new Exception(\"never get here\")\n\t\
    }\n\tcoll(1, n)", "      var path  = (1 to n.toInt).map(x => new Car(\"r\", n-x+1)).toList\n\
    \      var path2 = (1 to n.toInt).map(x => new Car(\"l\", x)).toList\n      var\
    \ res = 0\n      while(path2.length > 0) {\n        var start = path2.head\n \
    \       path = path.filter(_.distance != start.distance)\n        path2 = path2.tail\n\
    \        if(path.length > 0) {\n          val dist = path.filter(_.distance <\
    \ start.distance).length\n          res += dist\n        }\n      }\n      return\
    \ res", "        val r = new Random\n        // randomly generate the speed of\
    \ all cars\n        val carSpeeds = Array.fill(n.toInt)(r.nextInt(2 * n.toInt))\n\
    \        println(carSpeeds.mkString(\" \"))\n        // a car is moving left to\
    \ right if it's speed is positive, right to left if it's speed is negative\n \
    \       val leftToRightCars = carSpeeds.filter(_ > 0)\n        val rightToLeftCars\
    \ = carSpeeds.filter(_ < 0)\n        // sort the arrays by speeds\n        scala.util.Sorting.quickSort(leftToRightCars)\n\
    \        scala.util.Sorting.quickSort(rightToLeftCars)\n        var collisions\
    \ = 0\n        var i = 0\n        var j = 0\n        // one pointer moves from\
    \ left to right, the other moves from right to left\n        // whenever their\
    \ speeds are the same, the cars collide\n        while (i < leftToRightCars.length\
    \ && j < rightToLeftCars.length) {\n            if (leftToRightCars(i) == -rightToLeftCars(j))\
    \ {\n                collisions += 1\n                i += 1\n               \
    \ j += 1\n            } else if (leftToRightCars(i) > -rightToLeftCars(j)) {\n\
    \                j += 1\n            } else i += 1\n        }\n        collisions",
  "        // If we number the cars from 1 to n and let R(i) be the position of the\
    \ i'th car\n        // driving right to left and L(i) be the position of the i'th\
    \ car driving left to right,\n        // then collisions happen only when R(i)\
    \ == L(j).\n        // To speed up computation, we divide by n and let R(i) be\
    \ the position of the i'th car\n        // driving right to left and L(i) be the\
    \ position of the i'th car driving left to right,\n        // where i, j range\
    \ from 0 to n-1.\n        //\n        // Define E(i) = (R(i) - L(i)).  Note that\
    \ the i'th car and the j'th car collide if and only if\n        // E(i) == E(j)\
    \ and i != j.\n        // To compute the number of collisions, note that\n   \
    \     // E(i) = R(i) - L(i) = (i+1)/n - (n-i)/n\n        // E(i) = 2*i/n + 1/n\
    \ - n/n\n        // E(i) = 2*i/n + 1/n - 1\n        // E(i) = 2*i/n + 1/n - 1\n\
    \        // E(i) = 2*i/n + (1-1)/n\n        // E(i) = 2*i/n + 0\n        // E(i)\
    \ = 2*i/n\n        // This means that E(i) = 2*i/n and E(j) = 2*j/n for i != j.\n\
    \        // Hence, there are n*(n-1)/2 collisions in this problem.\n        val\
    \ collisions = n * (n - 1) / 2\n        collisions", "        val pq = new PriorityQueue[Int]()(Ordering.Int.reverse)\n\
    \        var count = 0\n        for (i <- 1 to n.toInt) {\n            while (!pq.isEmpty\
    \ && pq.dequeue < i) count += 1\n            pq.enqueue(i + n.toInt)\n       \
    \ }\n        count", '        n * (n - 1) / 2', "        var collisions = 0L\n\
    \        val c = new Array[(Long, Long)](n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            c(i) = (i, n - i - 1)\n        }\n        for (i <- 0 until n.toInt)\
    \ {\n            for (j <- i + 1 until n.toInt) {\n                val (a, b)\
    \ = c(i)\n                val (c, d) = c(j)\n                if (a > c && b <\
    \ d) collisions += 1\n                if (c > a && d < b) collisions += 1\n  \
    \          }\n        }\n        collisions", "        def draw(height : Long,\
    \ nodes : List[(Long, Long)]) : Unit = {\n            val minX = nodes.minBy(_._1)._1\n\
    \            val maxX = nodes.maxBy(_._1)._1\n            val minY = nodes.minBy(_._2)._2\n\
    \            val maxY = nodes.maxBy(_._2)._2\n            for (y <- maxY to minY\
    \ by -1) {\n                for (x <- minX to maxX) {\n                    if\
    \ (nodes.exists(coord => coord._1 == x && coord._2 == y)) print(\"X\")\n     \
    \               else print(\".\")\n                }\n                println()\n\
    \            }\n        }\n        val minCoord = -(n - 1)\n        val maxCoord\
    \ = n - 1\n        val uniqueTuples = minCoord.to(maxCoord).flatMap(x => minCoord.to(maxCoord).map(y\
    \ => (x, y))).toList\n        val permutations = uniqueTuples.combinations(n.toInt).toList\n\
    \        permutations.foreach(permutation => {\n            val leftCarCoords\
    \ = permutation.map(coord => (coord._1, coord._2)).sortBy(_._1)\n            val\
    \ rightCarCoords = permutation.map(coord => (coord._1, -coord._2)).sortBy(_._1)\n\
    \            val collidingPairs = leftCarCoords.intersect(rightCarCoords)\n  \
    \          //println(leftCarCoords)\n            //println(rightCarCoords)\n \
    \           //println(collidingPairs)\n            //println()\n            //draw(n,\
    \ leftCarCoords ++ rightCarCoords)\n        })\n        //println(permutations.length)\n\
    \        0", "        // On each collision, a left-to-right car can collide with\
    \ a right-to-left car in [1, 2n - 1] ways,\n        // where n is the number of\
    \ cars on each side.\n        // This is because there's n cars on each side,\
    \ and the car that's on the leftmost can only collide\n        // with the car\
    \ that's on the rightmost.  Similarly, the car that's in second place from the\
    \ left can\n        // only collide with the car that's in second place from the\
    \ right.  And so on.\n        // The total number of collisions is the sum from\
    \ 1 to 2n - 1 of these numbers, which is\n        // n * 2n - n, which equals\
    \ n^2\n        n * n", "        // speed : number of cars that move at that speed\n\
    \        val leftToRight = new HashMap[Int, Long]\n        val rightToLeft = new\
    \ HashMap[Int, Long]\n        for (i <- 1 to n.toInt) {\n            if (i % 2\
    \ == 0) {\n                val x = leftToRight.getOrElse(i, 0L)\n            \
    \    leftToRight.put(i, x + 1)\n            } else {\n                val x =\
    \ rightToLeft.getOrElse(i, 0L)\n                rightToLeft.put(i, x + 1)\n  \
    \          }\n        }\n        // For each speed, there are n / speed cars.\n\
    \        var result = 0L\n        for (i <- 1 to n.toInt) {\n            val left\
    \ = leftToRight.getOrElse(i, 0L)\n            val right = rightToLeft.getOrElse(i,\
    \ 0L)\n            result += left * right\n        }\n        result", "     \
    \   // map[key,value] is a hashmap type in Scala which can be accessed by map[key]\
    \ and\n        // also has a getOrElse method which takes a default value.  The\
    \ default value will\n        // be used if map[key] is not in the map.\n    \
    \    // The format of the map is map[car velocity, number of cars with this velocity]\n\
    \        var mapLeftToRight = Map[Long, Long]()\n        var mapRightToLeft =\
    \ Map[Long, Long]()\n        // This function is used to add a car to the map.\n\
    \        def addCar(map : Map[Long, Long], v : Long) {\n            map(v) = map.getOrElse(v,\
    \ 0) + 1\n        }\n        // This function is used to add a car to the map\
    \ and return the number of collisions.\n        def addCarCollision(map : Map[Long,\
    \ Long], v : Long) : Long = {\n            // The collisions of a car depend on\
    \ the number of cars of equal or greater speed.\n            val collisions =\
    \ map.getOrElse(v, 0)\n            map(v) = map.getOrElse(v, 0) + 1\n        \
    \    collisions\n        }\n        // This function is used to remove a car from\
    \ the map.\n        def removeCar(map : Map[Long, Long], v : Long) {\n       \
    \     val n = map(v)\n            if (n == 1) map.remove(v)\n            else\
    \ map(v) = n - 1\n        }\n        // This loop adds cars to the left to right\
    \ map while removing cars from the right to left map.\n        // It computes\
    \ the number of collisions.\n        // The loop takes O(sqrt(n)) time.\n    \
    \    // We do not need to loop over the entire car velocity range because the\
    \ number of cars\n        // with the same velocity is at most sqrt(n).\n    \
    \    for (i <- 0L until sqrt(n).toLong) {\n            val v = n - i * i\n   \
    \         val collisions = addCarCollision(mapLeftToRight, v)\n            removeCar(mapRightToLeft,\
    \ v)\n            // collisions is the number of collisions of this car\n    \
    \        // Add to the total number of collisions\n            println", "   \
    \     // The answer is n*(n-1)/2\n        n*(n-1)/2", "        // Let's assume\
    \ that the cars move at the same speed of 1 meter per second.\n        // We'll\
    \ locate each car by its position, which means that it's a point on the real number\
    \ line.\n        // Let's assume that the left-to-right cars are in the set L\
    \ and the right-to-left cars are in\n        // the set R.  Suppose that the right-to-left\
    \ cars have positions r1, r2, r3, ..., rn.\n        // Let's sort these positions\
    \ in ascending order; we get r1 <= r2 <= r3 <= ... <= rn.\n        // Then we\
    \ have:\n        // n - 1 collisions among the right-to-left cars\n        //\
    \ n - 1 collisions among the left-to-right cars\n        // n choose 2 collisions\
    \ among the cars (each pair of cars contributes to one collision)\n        //\
    \ In total, we have 2n - 1 collisions, which is the same as (n choose 2) + n -\
    \ 1.\n        if (n == 0) {\n            return 0\n        }\n        return (n\
    \ * (n - 1)) / 2 + n - 1", "        var leftToRight = new Array[Long](n.toInt)\n\
    \        var rightToLeft = new Array[Long](n.toInt)\n        for (i <- 0 until\
    \ n.toInt) {\n            leftToRight(i) = i\n            rightToLeft(i) = n -\
    \ i - 1\n        }\n        leftToRight = leftToRight.sorted\n        rightToLeft\
    \ = rightToLeft.sorted\n        var collisions = 0\n        var i = 0\n      \
    \  var j = 0\n        while (i < n.toInt && j < n.toInt) {\n            if (leftToRight(i)\
    \ < rightToLeft(j)) {\n                collisions += j\n                i += 1\n\
    \            } else {\n                j += 1\n            }\n        }\n    \
    \    collisions", '        n * (n - 1) / 2', "        // This problem can be solve\
    \ by mapping the problem to a function with\n        // a special property.  Let\
    \ f(x) be the function that maps x to the number\n        // of collisions that\
    \ occur when x cars are driving left to right and x cars\n        // are driving\
    \ right to left.  Let D be the domain of f.  Note that f is \n        // symmetric\
    \ around the origin.  Thus, f(x) = f(-x).  Moreover, f(x) = f(y)\n        // when\
    \ x and y differ by n.  These two properties leads to the formula:\n        //\
    \ f(x) = min(x, -x)\n        // as x ranges from 0 to n - 1.\n        return n\
    \ * (n - 1) / 2;", "        if (n < 0) {\n            return 0\n        }\n  \
    \      val r = n * (n - 1) / 2\n        r", "        val leftRight = Array.fill(n.toInt)(0)\n\
    \        val rightLeft = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ {\n            leftRight(i) = scala.io.StdIn.readInt\n            rightLeft(i)\
    \ = scala.io.StdIn.readInt\n        }\n        var collisions = 0L\n        for\
    \ (i <- 0 until n.toInt) {\n            for (j <- 0 until n.toInt) {\n       \
    \         if (leftRight(i) < rightLeft(j)) collisions += 1\n            }\n  \
    \      }\n        collisions", "        def gcd(a : Long, b : Long) : Long = {\n\
    \            if (b == 0) a else gcd(b, a % b)\n        }\n        val pos = (0L\
    \ until n).map(x => x + 1).map(x => (x, x)).toArray\n        val neg = (0L until\
    \ n).map(x => -x - 1).map(x => (x, x)).toArray\n        // process in sweeps\n\
    \        def processSweep(sorted : Array[(Long, Long)]) : Long = {\n         \
    \   // sort by distance\n            val processed = ArrayBuffer[(Long, Long)]()\n\
    \            for (i <- 0 until sorted.length) {\n                var found = false\n\
    \                for (j <- 0 until processed.length) {\n                    val\
    \ (x, y) = processed(j)\n                    if (x <= sorted(i)._1 && sorted(i)._1\
    \ <= y) {\n                        found = true\n                        processed(j)\
    \ = (x, sorted(i)._2)\n                    }\n                }\n            \
    \    if (!found) processed += ((sorted(i)._1, sorted(i)._2))\n            }\n\
    \            // sort by start\n            val sorted2 = processed.sortBy(x =>\
    \ x._1)\n            val result = ArrayBuffer[(Long, Long)]()\n            var\
    \ current : (Long, Long) = null\n            for (i <- 0 until sorted2.length)\
    \ {\n                if (current == null) current = sorted2(i)\n             \
    \   else {\n                    if (current._2 >= sorted2(i)._1) {\n         \
    \               current = (current._1, max(current._2, sorted2(i)._2))\n     \
    \               } else {\n                        result += current\n        \
    \                current = sorted2(i)\n                    }\n               \
    \ }\n            }\n            if (current != null) result += current\n     \
    \       // sort by start\n            result.sortBy(x => x._1).map(x => x._2 -\
    \ x._1 + 1).sum\n        }\n        // sort by sign\n        val sorted = (pos\
    \ ++ neg).sortBy(x => x._1)\n        // first sweep\n        var (j, k) = (0,",
  "        // Let's say the starting point of a left to right car is p.\n        //\
    \ The starting point of the corresponding right to left car is -p.\n        //\
    \ The point of collision is when p+t=1/(p-t)\n        // Quadratic formula shows\
    \ that t is the positive square root of (1+1/p^2)\n        // So the total time\
    \ that it takes for the collision is (1+1/p^2)^(1/2)\n        // The number of\
    \ cars that can collide is the number of p's such that\n        // (1+1/p^2)^(1/2)\
    \ < p\n        // Since (1+1/p^2)^(1/2) < 1+1/(2p^2), we have\n        // (1+1/p^2)^(1/2)\
    \ < p  iff  1+1/(2p^2) < p  iff  1/p^2 < 1/(2p^2)  iff  1 < 2\n        // So the\
    \ answer is n-1.\n        n - 1", "        val max = 2 * n * n\n        val mod\
    \ = 1000000007\n        var sum = 0L\n        for (i <- 1 to max.toInt) {\n  \
    \          val first = (i - 1) / n\n            val second = i % n\n         \
    \   if (first == second) {\n                sum += 1\n            }\n        }\n\
    \        sum % mod", "\tval positions = HashMap[Long, Long]()\n\tfor (i <- 0 to\
    \ n.toInt - 1) {\n\t    val left = (i * -1) + 1\n\t    positions(left) = positions.getOrElse(left,\
    \ 0) + 1\n\t    val right = i + 1\n\t    positions(right) = positions.getOrElse(right,\
    \ 0) + 1\n\t}\n\tpositions.values.foldLeft(0)((total, current) => total + (current\
    \ - 1) * current / 2)", "        var collisions = 0\n        for (x <- 1 to n)\
    \ {\n            var collision = false\n            for (y <- 1 to n) {\n    \
    \            if (x > y) {\n                    if (x % y == 0) {\n           \
    \             collision = true\n                    }\n                }\n   \
    \         }\n            if (collision) collisions += 1\n        }\n        collisions",
  "        // Realize that two cars collide if and only if at some point in time the\n\
    \        // car on the left is at the same location as the car on the right.\n\
    \        // The cars are moving at constant speed and the road is straight, so\
    \ the\n        // location of a given car at any point in time is a linear function\
    \ of time.\n        // Here we assume that the cars are numbered 0 to n-1, where\
    \ the left-to-right\n        // cars are numbered 0 to n/2-1 and the right-to-left\
    \ cars are numbered n/2 to n-1.\n        // The number of collisions is then the\
    \ number of pairs of indices i < j\n        // such that the linear functions\
    \ describing the location of the ith car and\n        // the jth car are equal\
    \ at some point in time.\n        // We show a proof of this for the case where\
    \ n is even; the odd case is similar.\n        // One linear function is given\
    \ by f(t) = a*t+b, the other linear function is\n        // given by g(t) = c*t+d.\n\
    \        // The two cars collide if and only if there exists a value t >= 0 such\
    \ that\n        // f(t) = g(t).  Since f(t) = a*t+b and g(t) = c*t+d, there exists\
    \ a value t >= 0\n        // such that a*t+b = c*t+d, if and only if a*t - c*t\
    \ = d - b,\n        // which happens if and only if a-c != 0 and t = (d-b)/(a-c).\n\
    \        // We have shown that i and j collide if and only if a-c != 0 and\n \
    \       // t = (d-b)/(a-c) is a nonnegative real number.\n        // Now we show\
    \ that a-c != 0 if and only if i < j.\n        // Since 0 <= i < n/2, it follows\
    \ that car i is going left to right and\n        // car j is going right to left.\
    \  Therefore, a-c < 0.\n        // On the other hand, since i < j, it follows\
    \ that a-c < 0 if and only if i < j.\n        // Therefore, i and j collide",
  "        var collisions = 0L\n        // If a car at position i on the left is hit\
    \ by a car at position j on the right,\n        // then the car at position i\
    \ on the left will have a distance to the car at position j\n        // on the\
    \ right of i + j.\n        // We can treat this distance as a \"starting position\"\
    \ of the car at position i on the left,\n        // and the car at position j\
    \ on the right as a \"starting position\" of the car at position j on the right.\n\
    \        // Suppose the \"starting position\" of the car at position i on the\
    \ left is x, and the\n        // \"starting position\" of the car at position\
    \ j on the right is y.\n        // Then the times taken for them to meet would\
    \ be (x + y) / (i + j).\n        // The time taken for two cars to meet would\
    \ be the lowest amongst all the \"starting positions\" of all the cars\n     \
    \   // on the left, and all the \"starting positions\" of all the cars on the\
    \ right.\n        // If the \"starting position\" of the car at position i on\
    \ the left is x, and the\n        // \"starting position\" of the car at position\
    \ j on the right is y, then the time taken\n        // for them to meet is (x\
    \ + y) / (i + j).\n        // If the time taken is t, then the distance of the\
    \ car at position i on the left is i * t,\n        // and the distance of the\
    \ car at position j on the right is j * t.\n        // This means that the distance\
    \ of the car at position i on the left minus the distance of the car at position\
    \ j on the right\n        // is (i * t - j * t) = (i - j) * t.\n        // We\
    \ want to find two cars with the lowest collision time t.  So we can instead try\
    \ to find\n        // two cars with the smallest (i - j) * t = x + y.\n      \
    \  // We can use a standard algorithm for finding the smallest element of a set\
    \ of numbers.\n        // The numbers are the \"starting positions\" of the cars.\n\
    \        // The algorithm is like this:\n        // Start with two indices, one\
    \ for the left cars and one for the right cars.\n        // If the number indicated\
    \ by the left index", "        val cars = ArrayBuffer.fill(n.toInt)(0)\n     \
    \   for (i <- 0 until n.toInt) cars(i) = i\n        cars.toArray.groupBy(x =>\
    \ x).map(_._2.length).filter(_ > 1).map(_ - 1).sum", "        // Let's say the\
    \ speed of a car is x.  Then there is a collision\n        // at point n/x.  Therefore,\
    \ there are n(n-1)/2 such points.\n        // If we let x go from 1 to n, then\
    \ we get the desired result.\n        // The sum of 1 to n is n(n+1)/2.  Therefore,\
    \ we divide by 2.\n        return n * (n-1) / 2", "        // The \"standard\"\
    \ solution is to sort the n cars that are moving left to right\n        // by\
    \ their starting position, and then do a linear scan to count the number of\n\
    \        // collisions.  This takes O(n lg n) time and O(n) space.\n        //\n\
    \        // Instead, we can use the O(n lg n) time algorithm to merge-sort only\
    \ the\n        // cars that are moving right to left.  We can then scan the two\
    \ sorted arrays\n        // side by side in O(n) time and output the number of\
    \ collisions.\n        val n1 = n;\n        val n2 = n;\n        var a = new Array[Long](n1.toInt);\n\
    \        var b = new Array[Long](n2.toInt);\n        for (i <- 0 until n1.toInt)\
    \ {\n            a(i) = 1 + i;\n        }\n        for (i <- 0 until n2.toInt)\
    \ {\n            b(i) = n1 + n2 - i;\n        }\n        println(a.mkString(\"\
    \ \"));\n        println(b.mkString(\" \"));\n        val c = MergeSort.mergeSort(b);\n\
    \        println(c.mkString(\" \"));\n        var i = 0;\n        var j = 0;\n\
    \        var count = 0;\n        while (i < n1 && j < n2) {\n            if (a(i)\
    \ < c(j)) {\n                i += 1;\n            } else {\n                count\
    \ += 1;\n                j += 1;\n            }\n        }\n        count;", " \
    \       // Given 2n cars.  There are n collisions if every car on the left goes\
    \ at a slower\n        // speed than every car on the right; there are 0 collisions\
    \ if every car on the left\n        // goes at a faster speed than every car on\
    \ the right.  There are 0 collisions if every\n        // car on the left goes\
    \ at the same speed as every car on the right.  And there are\n        // n(n-1)/2\
    \ collisions if the n cars on the left go at n distinct speeds, and the n cars\n\
    \        // on the right go at n distinct speeds.\n        // (Note: it's possible\
    \ to have the same speed but different cars on the left and the right.\n     \
    \   // This can result in less than n(n-1)/2 collisions)\n        // For example,\
    \ there are 2 cars:\n        //   A left car with speed 2\n        //   A right\
    \ car with speed 1\n        // A left car with speed 1\n        // A right car\
    \ with speed 2\n        // There are 1 + 1 = 2 collisions.\n        // However,\
    \ if the two cars swap places, there are 0 collisions.\n        // A left car\
    \ with speed 1\n        // A right car with speed 2\n        // A left car with\
    \ speed 2\n        // A right car with speed 1\n        val nLeft = n\n      \
    \  val nRight = n\n        val nPairs = nLeft * nRight\n        val nDup = (1\
    \ to nLeft.toInt).map(a =>\n            (1 to nRight.toInt).map(b =>\n       \
    \         if (a == b) 1 else 0).sum).sum\n        val nUnique = nPairs - nDup\n\
    \        nUnique / 2", "        // Let the ith car in the left to right group\
    \ be at coordinate i - 1.\n        // Let the ith car in the right to left group\
    \ be at coordinate 2n - i.\n        // If a car at coordinate i collides with\
    \ a car at coordinate j,\n        // then we know that i - j > 0.  Letting m =\
    \ i - j, the ith car in the left to right\n        // group collides with the\
    \ mth car in the right to left group.\n        // We repeat this process for all\
    \ cars in the left to right group;\n        // the total number of collisions\
    \ is equal to the number of collisions\n        // for the ith car in the left\
    \ to right group for all i.\n        // The collision of ith car in the left to\
    \ right group with the mth car in the right to left group is\n        // equal\
    \ to the number of cars from the mth car to the (2n - i)th car in the right to\
    \ left group.\n        // There are (2n - i - m + 1) = (2n - i - (i - j) + 1)\
    \ = (2n - 2i + j + 1) cars in the right to left group\n        // from the (i\
    \ - j)th car to the (2n - i)th car.\n        // Therefore, the total number of\
    \ collisions is equal to\n        // the sum of (2n - 2i + j + 1) for all i from\
    \ 1 to n, and all j from 1 to i - 1.\n        val totalCollisions = (1 to n.toInt).map(i\
    \ => (1 to i - 1).map(j => 2 * n - 2 * i + j + 1).sum).sum\n        totalCollisions",
  "        var count = 0L\n        for (i <- 1L to n) {\n            count += (i -\
    \ 1) * 2\n        }\n        count", "        def go(i : Long, j : Long, count\
    \ : Long) : Long = {\n            if (i == n) count\n            else {\n    \
    \            val collision = if (j < n) n - j - 1 else n - j\n               \
    \ go(i + 1, j + 1, count + collision)\n            }\n        }\n        go(0,\
    \ 0, 0)", "        // The idea is to consider all the cars moving from left to\
    \ right, and\n        // all the cars moving from right to left as a single set\
    \ of cars moving\n        // both ways on a single infinitely long line.\n   \
    \     // The number of collisions can then be thought of as a question of\n  \
    \      // counting number of pairs of cars which are moving in opposite directions\n\
    \        // and have the same speed.\n        // We will solve this problem using\
    \ brute force.\n        var cnt = 0L\n        for (i <- 1L to n) {\n         \
    \   // Let i be the speed of a car that's moving left to right\n            //\
    \ At each point in time, this car will be at position x = i * t\n            //\
    \ Therefore, it will collide with a car that's moving right to left\n        \
    \    // if and only if its position x is equal to j * t, where j is the speed\n\
    \            // of that car.  It is easy to verify that the solution to this equation\n\
    \            // is t = n / (i + j).  Therefore, we will take all the values of\
    \ j from\n            // 1 to n, and compute t for each pair of i and j.  If t\
    \ is an integer,\n            // then we have a collision.\n            for (j\
    \ <- 1L to n) {\n                val t = n / (i + j)\n                if (t *\
    \ (i + j) == n) cnt += 1\n            }\n        }\n        cnt", "        //\
    \ We shall call a right-to-left car a \"negative car\", and a left-to-right car\
    \ a \"positive car\".\n        // To determine the number of collisions, it is\
    \ equivalent to count the number of \"negative cars\"\n        // between two\
    \ consecutive \"positive cars\".\n        // In other words, we can sort the n\
    \ negative cars and n positive cars by their initial positions,\n        // and\
    \ for each positive car, we can compute the number of negative cars in its left\
    \ and right;\n        // then the number of collisions is just the total of these\
    \ numbers.\n        // To do so, we can use an interval tree or segment tree;\
    \ however, a simple stack implementation is also effective.\n        // First,\
    \ we sort the cars by their initial positions:\n        val cars = ArrayBuffer.empty[Long]\n\
    \        for (i <- 0L until n) cars += i\n        val negativeCars = cars.sortWith(_\
    \ > _)\n        val positiveCars = cars.sortWith(_ < _)\n        var numCollisions\
    \ = 0L\n        val st = Stack.empty[Long]\n        for (car <- positiveCars)\
    \ {\n            while (!st.isEmpty && st.top < car) {\n                numCollisions\
    \ += 1\n                st.pop\n            }\n            st.push(car)\n    \
    \    }\n        return numCollisions", "        var ans = 0L\n        for (i <-\
    \ 1L to n) {\n            for (j <- 1L to n) {\n                if (gcd(i, j)\
    \ == 1) ans += 1\n            }\n        }\n        ans"]
stop_tokens:
- "\n    }\n"
