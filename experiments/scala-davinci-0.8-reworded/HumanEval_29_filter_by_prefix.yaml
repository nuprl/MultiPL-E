name: HumanEval_29_filter_by_prefix
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Filter an input list of strings only for ones that start with a given prefix.\n\
  \    // >>> filterByPrefix((List[String]()), (\"a\"))\n    // (List[String]())\n\
  \    // >>> filterByPrefix((List[String](\"abc\", \"bcd\", \"cde\", \"array\")),\
  \ (\"a\"))\n    // (List[String](\"abc\", \"array\"))\n    def filterByPrefix(strings\
  \ : List[String], prefix : String) : List[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(filterByPrefix((List[String]()),\
  \ (\"john\")).equals((List[String]())));\n    assert(filterByPrefix((List[String](\"\
  xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xxx\")).equals((List[String](\"\
  xxx\", \"xxxAAA\", \"xxx\"))));\n    }\n\n}\n"
completions: ['        return strings.filter(s => s.startsWith(prefix))', '        strings.filter(str
    => str.length >= prefix.length && str.substring(0, prefix.length) == prefix)',
  '        (strings.filter((s) => s.startsWith(prefix)))', '        return strings.filter(p
    => p.startsWith(prefix))', "        def filterByPrefix0(strings : List[String],\
    \ prefix : String, result : List[String]) : List[String] = {\n            if (strings.isEmpty)\
    \ result\n            else if (strings.head.startsWith(prefix)) filterByPrefix0(strings.tail,\
    \ prefix, result :+ strings.head)\n            else filterByPrefix0(strings.tail,\
    \ prefix, result)\n        }\n        filterByPrefix0(strings, prefix, List[String]())",
  '        strings.filter(s => s.startsWith(prefix))', '        return strings.filter(x
    => x.startsWith(prefix))', "        // We will use the library method filter to\
    \ process the list.\n        // https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#filter(p:A=>Boolean):List[A]\n\
    \        // We have to supply the function that determines whether an item is\
    \ filtered in or out.\n        //\n        // We will use the library method startsWith\
    \ to determine whether a string has the correct prefix.\n        // https://www.scala-lang.org/api/current/scala/collection/immutable/StringOps.html#startsWith(that:String):Boolean\n\
    \        //\n        // Note that the method filter also has an alternative syntax.\n\
    \        // https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#withFilter(p:A=>Boolean):List[A]\n\
    \        //\n        // Note that the method startsWith also has an alternative\
    \ syntax.\n        // https://www.scala-lang.org/api/current/scala/collection/immutable/StringOps.html#startsWith(that:T):Boolean\n\
    \        ???", '        ???', "        var result : List[String] = List[String]()\n\
    \        for (word <- strings) {\n            if (word.startsWith(prefix)) {\n\
    \                result = result :+ word\n            }\n        }\n        return\
    \ result", '        strings.filter(s => s.startsWith(prefix))', '        strings.filter((s)
    => (s.take(prefix.length) == prefix))', '        strings.filter(_.startsWith(prefix))',
  '        strings.filter(_.startsWith(prefix))', "        if (strings.isEmpty) strings\n\
    \        else {\n            if (strings.head.startsWith(prefix)) strings.head\
    \ :: filterByPrefix(strings.tail, prefix)\n            else filterByPrefix(strings.tail,\
    \ prefix)\n        }", '        strings.filter(((s : String) => (s.startsWith(prefix))))',
  "        var r : List[String] = List()\n        for (string <- strings) {\n    \
    \        if (string.startsWith(prefix)) r = r :+ string\n        }\n        return\
    \ r", "        val result = ListBuffer[String]()\n        for (str <- strings)\
    \ {\n            if (str.startsWith(prefix)) result += str\n        }\n      \
    \  result.toList", '        strings.filter((str) => str.startsWith(prefix))',
  "        require(prefix.length > 0)\n        strings.filter(str => str.startsWith(prefix))",
  '        strings.filter(s => s.startsWith(prefix))', '        strings.filter(e =>
    e.startsWith(prefix))', "        if (strings.length == 0) List[String]()\n   \
    \     else if (strings.head.startsWith(prefix)) strings.head :: filterByPrefix(strings.tail,\
    \ prefix)\n        else filterByPrefix(strings.tail, prefix)", '        return
    strings.filter(x => x.startsWith(prefix))', "        var result = List[String]()\n\
    \        for (string <- strings) {\n            if (string.startsWith(prefix))\
    \ result = string :: result\n        }\n        return result", '        return
    strings.filter((s : String) => s.startsWith(prefix))', "        var filteredList\
    \ = List[String]()\n        for (str <- strings) {\n            if (str.startsWith(prefix))\
    \ {\n                filteredList = str :: filteredList\n            }\n     \
    \   }\n        filteredList.reverse", "        var filtered : List[String] = (List[String]())\n\
    \        var first = true\n        for (s <- strings) {\n            if (s.startsWith(prefix))\
    \ {\n                if (first) {\n                    filtered = (s :: filtered)\n\
    \                    first = false\n                } else {\n               \
    \     filtered = filtered :+ s\n                }\n            }\n        }\n\
    \        return filtered", '        strings.filter(x => x.startsWith(prefix))',
  '        strings.filter(s => s.startsWith(prefix))', "        var result : List[String]\
    \ = List()\n        for (s <- strings) {\n            if (s.startsWith(prefix))\
    \ {\n                result = s :: result\n            }\n        }\n        return\
    \ result", '        strings.filter(s => s.startsWith(prefix))', "        var ret\
    \ : List[String] = List()\n        for (str <- strings) if (str.startsWith(prefix))\
    \ ret = str :: ret\n        return ret", '        strings.filter(s => s.startsWith(prefix))',
  '        strings.filter((s : String) => {s.startsWith(prefix)})', "        val prefixLength\
    \ = prefix.length\n        strings.filter((s) => (s.startsWith(prefix)))", " \
    \       for {\n            s <- strings\n            if s.startsWith(prefix)\n\
    \        } yield s", "        // Print the inputs to help debugging.\n       \
    \ // print(strings)\n        // print(prefix)\n        // Retrieve a list of strings\
    \ which starts with the given prefix.\n        strings.filter(str => str.startsWith(prefix))",
  '      strings.filter(_.startsWith(prefix))', '        strings.filter((word : String)
    => word.startsWith(prefix))', "        // ERROR:\n        val filter = for (string\
    \ <- strings if string.startsWith(prefix)) yield string\n        filter", "  \
    \      strings match {\n            case (List()) => List()\n            case\
    \ (x :: xs) =>\n                if (x.startsWith(prefix)) x :: filterByPrefix(xs,\
    \ prefix)\n                else filterByPrefix(xs, prefix)\n        }", '        (for
    (x <- strings; if x.startsWith(prefix)) yield x).toList', "        // @todo implement\
    \ this\n        return strings", '        strings.filter(s => s.startsWith(prefix))',
  '        strings.filter(string => string.startsWith(prefix))', '        strings.filter(x
    => x.startsWith(prefix))', '        return strings.filter(s => s.startsWith(prefix))',
  '        return strings.filter((x : String) => (x.startsWith(prefix)))', '        return
    List();', '        return strings.filter(s => s.startsWith(prefix))', '        strings.filter(x
    => x.startsWith(prefix))', "        var stringsAfterFilter = List[String]()\n\
    \        for (string <- strings) {\n            if (string.startsWith(prefix))\
    \ {\n                stringsAfterFilter = string :: stringsAfterFilter\n     \
    \       }\n        }\n        stringsAfterFilter", "        val f = (str : String)\
    \ => str.startsWith(prefix)\n        val filtered = strings.filter(f)\n      \
    \  return filtered", '        strings.filter(x => x.startsWith(prefix))', "  \
    \      val n = prefix.length\n        strings.filter(x => x.length >= n && x.substring(0,\
    \ n) == prefix)", "        // We know the prefix we want to match.\n        //\
    \ Any string in the list that does not start with that prefix should be filtered\
    \ out.\n        // There are two cases for each string\n        // 1. Starts with\
    \ the prefix\n        // 2. Doesn't start with the prefix\n        // It would\
    \ be ideal if there was a built-in function that did this\n        // Luckily\
    \ there is.\n        return strings.filter((s : String) => s.startsWith(prefix))",
  "        if (strings.isEmpty) List[String]()\n        else if (strings.head.startsWith(prefix))\
    \ strings.head :: filterByPrefix(strings.tail, prefix)\n        else filterByPrefix(strings.tail,\
    \ prefix)", "        // YOUR CODE HERE\n        strings.filter(s => s.startsWith(prefix))",
  '        strings.filter(word => word.startsWith(prefix))', '        strings.filter(_.startsWith(prefix))',
  '        return strings.filter((_ : String).startsWith(prefix))', '        return
    (strings.filter((s : String) => s.startsWith(prefix)))', "        if (strings.length\
    \ == 0) {\n            List[String]()\n        } else {\n            if (strings.head.startsWith(prefix))\
    \ {\n                strings.head :: filterByPrefix(strings.tail, prefix)\n  \
    \          } else {\n                filterByPrefix(strings.tail, prefix)\n  \
    \          }\n        }", '        (for (s <- strings if s.startsWith(prefix))
    yield s).toList', '        return strings.filter(x => x.startsWith(prefix))',
  "        val prefixedStrings = ListBuffer[String]()\n        for (string <- strings)\
    \ {\n            if (string.startsWith(prefix)) prefixedStrings += string\n  \
    \      }\n        prefixedStrings.toList", '        strings.filter((s : String)
    => s.startsWith(prefix))', '        strings.filter(x => x.indexOf(prefix) == 0)',
  '        return strings.filter(str => str.startsWith(prefix))', '        strings.filter(word
    => word.startsWith(prefix))', '        ???', '        strings.filter(s => s.startsWith(prefix))',
  '        strings.filter((s) => {s.startsWith(prefix)})', '        strings.filter(x
    => x.indexOf(prefix) == 0)', '        strings.filter(s => s.startsWith(prefix))',
  "        if (strings.isEmpty) return List[String]()\n        if (strings.head.startsWith(prefix))\
    \ return strings.head :: filterByPrefix(strings.tail, prefix)\n        return\
    \ filterByPrefix(strings.tail, prefix)", '        strings.filter(x => x.startsWith(prefix))',
  "        require(strings != null && prefix != null)\n        strings.filter(string\
    \ => string.startsWith(prefix))", "        var output = List[String]()\n     \
    \   for (s <- strings) {\n            if (s.substring(0, min(s.length, prefix.length))\
    \ == prefix) {\n                output = s :: output\n            }\n        }\n\
    \        return output", '        return strings.filter( s => s.startsWith(prefix)
    )', "        return strings.filter(\n          s => s.startsWith(prefix)\n   \
    \     )", "        var copy : List[String] = List[String]()\n        for (s <-\
    \ strings) {\n            if (s.startsWith(prefix)) copy ::= s\n        }\n  \
    \      return copy.reverse", "        strings match {\n            case Nil =>\
    \ Nil\n            case s :: ss => {\n                if (s.startsWith(prefix))\
    \ s :: filterByPrefix(ss, prefix)\n                else filterByPrefix(ss, prefix)\n\
    \            }\n        }", '        strings.filter(e => e.startsWith(prefix))',
  '        strings.filter(str => str.startsWith(prefix))', '        strings.filter(_.startsWith(prefix))',
  '        strings.filter(prefix.r.findFirstIn(_).isDefined)', "        // TODO: Fill\
    \ in.\n        strings.filter(x => x.startsWith(prefix))", "        // <<< Complete\n\
    \        return List[String]()\n        // >>> Complete", '        strings.filter(_.startsWith(prefix))',
  "        var output : List[String] = List()\n        var found : Boolean = false\n\
    \        for (s <- strings) {\n            if (s.startsWith(prefix)) {\n     \
    \           output = output :+ s\n                found = true\n            }\n\
    \        }\n        if (found) {\n            return output\n        } else {\n\
    \            return List()\n        }", "        if (strings.length == 0) return\
    \ List[String]()\n        if (strings.head.startsWith(prefix)) return List(strings.head)\
    \ ::: filterByPrefix(strings.tail, prefix)\n        return filterByPrefix(strings.tail,\
    \ prefix)", "        var buf = ListBuffer[String]()\n        for (str <- strings)\
    \ {\n            if (str.startsWith(prefix)) buf += str\n        }\n        buf.toList",
  "        var result = List[String]()\n        for (str <- strings) {\n         \
    \   if (str.startsWith(prefix)) {\n                result = str :: result\n  \
    \          }\n        }\n        return result", '        strings.filter(string
    => string.startsWith(prefix))', "        if (strings.length <= 0) {\n        \
    \    return strings\n        }\n        val h = strings.head\n        if (h.startsWith(prefix))\
    \ {\n            return List(h) ++ filterByPrefix(strings.tail, prefix)\n    \
    \    }\n        return filterByPrefix(strings.tail, prefix)", '        strings.filter(string
    => string.startsWith(prefix))', '        return strings.filter(string => string.startsWith(prefix))',
  '        strings.filter(s => s.startsWith(prefix))', "        if (strings.length\
    \ <= 0) {\n            return List[String]()\n        }\n        if (strings.head.startsWith(prefix))\
    \ {\n            return strings.head :: filterByPrefix(strings.tail, prefix)\n\
    \        }\n        return filterByPrefix(strings.tail, prefix)", '        strings.filter((s
    : String) => s.startsWith(prefix))', "        // TODO: Define the body of this\
    \ function.\n        return strings.filter(x => x.startsWith(prefix))", '        strings.filter(w
    => w.startsWith(prefix))', '        return strings.filter(x => x.startsWith(prefix))',
  '        strings.filter(x => x.startsWith(prefix))', '        strings.filter(x =>
    x.startsWith(prefix))', '        strings.filter(string => string.startsWith(prefix))',
  '        strings.filter(str => str.startsWith(prefix))', '        ???', "      \
    \  // YOUR CODE HERE\n        var list: List[String] = List()\n        for (string\
    \ <- strings) {\n            if (string.startsWith(prefix)) {\n              \
    \  list = string :: list\n            }\n        }\n        list", "        if\
    \ (strings.isEmpty) {\n            List[String]()\n        } else {\n        \
    \    val head = strings.head\n            val tail = strings.tail\n          \
    \  if (head.startsWith(prefix)) {\n                head :: filterByPrefix(tail,\
    \ prefix)\n            } else {\n                filterByPrefix(tail, prefix)\n\
    \            }\n        }", '        strings.filter((x : String) => (x.startsWith(prefix)))',
  "        val prefixSet = strings.filter(_.startsWith(prefix))\n        prefixSet",
  '        return strings.filter(s => s.startsWith(prefix))', "        def recur(strings\
    \ : List[String], prefix : String, l : List[String]) : List[String] = {\n    \
    \        if (strings.isEmpty) return l else if (strings.head.startsWith(prefix))\
    \ l :+ strings.head else l\n        }\n        recur(strings, prefix, List[String]())",
  '        strings.filter(s => s.startsWith(prefix))', "        // Create a new list\
    \ for strings that start with prefix.\n        var filtered : List[String] = Nil\n\
    \        // For each string in strings, if it starts with prefix, add it to the\n\
    \        // filtered list.\n        for (str <- strings) {\n            if (str.startsWith(prefix))\
    \ {\n                filtered = str :: filtered\n            }\n        }\n  \
    \      // Return the filtered list.\n        return filtered", '        strings.filter(name
    => name.startsWith(prefix))', '        strings.filter((s : String) => s.startsWith(prefix))',
  "        var result = List[String]()\n        for (str <- strings) {\n         \
    \   if (str.indexOf(prefix) == 0) {\n                result = str :: result\n\
    \            }\n        }\n        return result", '        return strings.filter(s
    => s.startsWith(prefix))', '        strings.filter(word => word.indexOf(prefix)
    == 0)', '        strings.filter(x => x.startsWith(prefix))', "        var result\
    \ = List[String]()\n        for (string <- strings) if (string.startsWith(prefix))\
    \ result = string :: result\n        return result", "        var matches = new\
    \ ListBuffer[String]()\n        for (string <- strings) {\n            if (string.startsWith(prefix))\
    \ {\n                matches += string\n            }\n        }\n        return\
    \ matches.toList", '        return strings.filter(_.startsWith(prefix))', '        strings.filter(x
    => x.startsWith(prefix))', '      strings.filter(x => x.startsWith(prefix))',
  '        strings.filter(x => x.startsWith(prefix))', '        strings.filter(_.startsWith(prefix))',
  '        strings.filter(s => s.startsWith(prefix))', '        strings.filter(s =>
    s.startsWith(prefix))', "        def loop(s : List[String], prefix : String, acc\
    \ : List[String]) : List[String] = {\n            if (s.length == 0) acc\n   \
    \         else if (s.head.substring(0, prefix.length) == prefix) loop(s.tail,\
    \ prefix, acc :+ s.head)\n            else loop(s.tail, prefix, acc)\n       \
    \ }\n        loop(strings, prefix, List[String]())", "        var prefixList =\
    \ new ListBuffer[String]\n        for (s <- strings) {\n            if (s.startsWith(prefix))\
    \ prefixList += s\n        }\n        return prefixList.toList", "        // write\
    \ your code here\n        // return strings\n        if (strings.isEmpty) List[String]()\n\
    \        else if (strings.head.startsWith(prefix)) List(strings.head) ::: filterByPrefix(strings.tail,\
    \ prefix)\n        else filterByPrefix(strings.tail, prefix)", "        var results\
    \ = List[String]()\n        for (s <- strings) {\n            if (s.length > 0\
    \ && s(0) == prefix(0)) {\n                results = s :: results\n          \
    \  }\n        }\n        return results", '        strings.filter(word => word.startsWith(prefix))',
  '        strings.filter(string => string.startsWith(prefix))', '        strings.filter((s)
    => (s.length >= prefix.length && (s.substring(0, prefix.length) == prefix)))',
  '        strings.filter(str => str.startsWith(prefix))', "        var filtered =\
    \ List[String]()\n        for (s <- strings) {\n            if (s.startsWith(prefix))\
    \ {\n                filtered = s :: filtered\n            }\n        }\n    \
    \    filtered", '        return strings.filter((str : String) => str.startsWith(prefix))',
  "        def recurse(currentList : List[String], resultList : List[String]) : List[String]\
    \ = {\n            currentList match {\n                case Nil => resultList\n\
    \                case x :: xs => if (x.startsWith(prefix)) recurse(xs, resultList\
    \ :+ x) else recurse(xs, resultList)\n            }\n        }\n        recurse(strings,\
    \ List[String]())", "        var result = List[String]()\n        for (string\
    \ <- strings) {\n            if (string.length() > 0 && string.substring(0, 1)\
    \ == prefix) {\n                result = string :: result\n            }\n   \
    \     }\n        return result", '        strings.filter(_.startsWith(prefix))',
  '        strings.filter(s => s.startsWith(prefix))', '        strings.filter(x =>
    x.startsWith(prefix))', "        // TODO: Return a version of strings where only\
    \ those starting with prefix are retained.\n        // Hint: Use the filter method\
    \ of Lists and the startsWith method of Strings.\n        // Hint: Returns strings.filter(string\
    \ => string.startsWith(prefix))\n        strings.filter(_.startsWith(prefix))",
  "        var output : List[String] = List[String]()\n        for (string <- strings)\
    \ {\n            if (string.startsWith(prefix)) {\n                output = output\
    \ :+ string\n            }\n        }\n        return output", '        return
    strings.filter(s => s.startsWith(prefix))', '        strings.filter((x : String)
    => x.startsWith(prefix))', '        strings.filter(s => s.startsWith(prefix))',
  "        var ret : List[String] = List[String]()\n        for (string <- strings)\
    \ {\n            if (string.startsWith(prefix)) {\n                ret = ret :+\
    \ string\n            }\n        }\n        return ret", '        return strings.filter(str
    => str.indexOf(prefix) == 0)', '        return strings.filter(s => s.startsWith(prefix))',
  '        strings.filter(x => x.startsWith(prefix))', "        val start = 0\n  \
    \      val end = prefix.length\n        return strings.filter(s => s.substring(start,\
    \ end) == prefix)", "      if (strings.isEmpty)\n        return List[String]()\n\
    \      if (strings.head.startsWith(prefix))\n        return strings.head :: filterByPrefix(strings.tail,\
    \ prefix)\n      return filterByPrefix(strings.tail, prefix)", '        return
    strings.filter(_.startsWith(prefix))', "        var result : List[String] = List()\n\
    \        for (str <- strings) {\n            if (str.startsWith(prefix)) {\n \
    \               result = result :+ str\n            }\n        }\n        return\
    \ result", '        strings.filter(str => { str.startsWith(prefix) })', "    \
    \    // YOUR CODE HERE\n        def helper(strings : List[String], prefix : String,\
    \ output : List[String]) : List[String] = {\n            strings match {\n   \
    \             case Nil => output\n                case head :: tail => {\n   \
    \                 if (head.startsWith(prefix)) {\n                        helper(tail,\
    \ prefix, output :+ head)\n                    } else {\n                    \
    \    helper(tail, prefix, output)\n                    }\n                }\n\
    \            }\n        }\n        helper(strings, prefix, List[String]())", " \
    \       if (strings.isEmpty) {\n            return strings\n        }\n      \
    \  if (strings.head.startsWith(prefix)) {\n            return strings.head ::\
    \ filterByPrefix(strings.tail, prefix)\n        }\n        return filterByPrefix(strings.tail,\
    \ prefix)", "        // TODO: Provide definition here.\n        def startWith(s:\
    \ String, prefix: String): Boolean = {\n            if (s.length < prefix.length)\
    \ false\n            else if (s.substring(0, prefix.length) == prefix) true\n\
    \            else false\n        }\n        var lst = List[String]()\n       \
    \ for (i <- strings) {\n            if (startWith(i, prefix)) lst = lst :+ i\n\
    \        }\n        lst", "      def helper(strings : List[String], prefix : String,\
    \ result : List[String]) : List[String] = {\n        if (strings.isEmpty) result\n\
    \        else {\n          val head = strings.head\n          if (head.startsWith(prefix))\
    \ helper(strings.tail, prefix, result :+ head)\n          else helper(strings.tail,\
    \ prefix, result)\n        }\n      }\n      helper(strings, prefix, List[String]())",
  "        if (strings.isEmpty) {\n            List[String]()\n        } else {\n\
    \            val head : String = strings.head\n            val rest : List[String]\
    \ = strings.tail\n            if (head.startsWith(prefix)) {\n               \
    \ (head :: filterByPrefix(rest, prefix))\n            } else {\n             \
    \   filterByPrefix(rest, prefix)\n            }\n        }", '        strings.filter(s
    => s.startsWith(prefix))', "        // TODO: implement this method\n        return\
    \ null", '        strings.filter(_.startsWith(prefix))', "        var result :\
    \ List[String] = List[String]()\n        for (str <- strings) {\n            if\
    \ (str.length >= prefix.length && str.substring(0, prefix.length) == prefix) {\n\
    \                result = result :+ str\n            }\n        }\n        return\
    \ result", "        // TODO: Change to your implementation.\n        null", '        strings.filter(s
    => s.startsWith(prefix))', '        return strings.filter(s => s.startsWith(prefix))',
  '        strings.filter(s => s.startsWith(prefix))', '        strings.filter(_.startsWith(prefix))',
  '        strings.filter(x => x.startsWith(prefix))', '        return strings.filter(_.startsWith(prefix))',
  '        ???', "        if (strings.length == 0)\n            return strings\n \
    \       val head = strings.head\n        val tail = strings.tail\n        if (head.startsWith(prefix))\n\
    \            List(head) ::: filterByPrefix(tail, prefix)\n        else\n     \
    \       filterByPrefix(tail, prefix)", '        strings.filter(x => x.startsWith(prefix))',
  '        strings.filter(e => e.startsWith(prefix))', '        strings.filter(_.startsWith(prefix))',
  '        return strings.filter(_.startsWith(prefix))', '        // Write your solution
    here.', '        strings.filter(x => x.startsWith(prefix))', '        return strings.filter((str)
    => str.startsWith(prefix))', "        var result : List[String] = List[String]()\n\
    \        for (string <- strings) {\n            if (string.startsWith(prefix))\
    \ {\n                result = result :+ string\n            }\n        }\n   \
    \     return result", '        return strings.filter(x => x.startsWith(prefix))',
  "        var res : List[String] = List[String]()\n        for (s <- strings) {\n\
    \            if (s.startsWith(prefix)) res = s :: res\n        }\n        res",
  "        def compare(s : String) : Boolean = s.startsWith(prefix)\n        strings.filter(compare)",
  '        strings.filter(str => str.startsWith(prefix))', "        var result = List[String]()\n\
    \        for (string <- strings) {\n            if (string.startsWith(prefix))\
    \ {\n                result = result :+ string\n            }\n        }\n   \
    \     return result", '        strings.filter(x => x.indexOf(prefix) == 0)', '        strings.filter(st
    => st.startsWith(prefix))', '        strings.filter(string => string.startsWith(prefix))',
  '        strings.filter(_.startsWith(prefix))', "        var newList = List[String]()\n\
    \        for (str <- strings) {\n            if (str.startsWith(prefix)) newList\
    \ ::= str\n        }\n        newList", '        for {s <- strings if s.startsWith(prefix)}
    yield s', '        strings.filter(s => s.startsWith(prefix))']
stop_tokens:
- "\n    }\n"
