name: HumanEval_30_get_positive
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return only positive numbers in the list.\n    // >>> getPositive((List[Long](-1l.toLong,\
  \ 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](2l.toLong,\
  \ 5l.toLong, 6l.toLong))\n    // >>> getPositive((List[Long](5l.toLong, 3l.toLong,\
  \ -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong,\
  \ 1l.toLong, -10l.toLong)))\n    // (List[Long](5l.toLong, 3l.toLong, 2l.toLong,\
  \ 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))\n    def getPositive(l : List[Long])\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getPositive((List[Long](-1l.toLong,\
  \ -2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](4l.toLong, 5l.toLong,\
  \ 6l.toLong))));\n    assert(getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong,\
  \ 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong,\
  \ -10l.toLong))).equals((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
  \ 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))));\n    assert(getPositive((List[Long](-1l.toLong,\
  \ -2l.toLong))).equals((List[Long]())));\n    assert(getPositive((List[Long]())).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ['        return l.filter((e : Long) => e > 0)', '        return l.filter(_
    >= 0)', '        return l.filter((x) => x > 0)', '        l.filter((l : Long)
    => l > 0)', "        val result = l.filter(x => x > 0)\n        return result",
  '        l.filter(i => i > 0)', "        var list = List[Long]()\n        for (i\
    \ <- l) {\n            if (i > 0) list = list :+ i\n        }\n        list",
  "        val buffer = new ListBuffer[Long]()\n        for (i <- l) if (i > 0) buffer\
    \ += i\n        return buffer.toList", '        l.filter((x) => x > 0)', "   \
    \     var positiveList = List[Long]()\n        for (i <- l) {\n            if\
    \ (i > 0) {\n                positiveList = positiveList :+ i\n            }\n\
    \        }\n        return positiveList", "        def loop(l : List[Long], lout\
    \ : List[Long]) : List[Long] = {\n            l match {\n                case\
    \ Nil => lout\n                case head :: tail => {\n                    if\
    \ (head < 0) loop(tail, lout)\n                    else loop(tail, head :: lout)\n\
    \                }\n            }\n        }\n        loop(l, List[Long]())",
  "        val nums = l\n        val positive = new ArrayBuffer[Long]()\n        nums.foreach(n\
    \ => if (n > 0) positive += n)\n        positive.toList", "        var result\
    \ : List[Long] = List[Long]()\n        l.foreach { n =>\n            if (n > 0)\
    \ {\n                result = result :+ n\n            }\n        }\n        return\
    \ result", '        l.filter(x => x > 0)', '        l.filter(n => n > 0)', '        return
    l.filter((n : Long) => n > 0)', "        var i = 0\n        var newList = List[Long]()\n\
    \        while (i < l.length) {\n            if (l(i) > 0) {\n               \
    \ newList = newList :+ l(i)\n            }\n            i += 1\n        }\n  \
    \      return newList", '        l.filter(x => x > 0l.toLong)', '        return
    l.filter(p => p > 0);', "        var positive = List[Long]()\n        for (x <-\
    \ l) {\n            if (x > 0) {\n                positive = positive :+ x\n \
    \           }\n        }\n        return positive", '        l.filter(x => x >
    0)', "        val l2 = ListBuffer[Long]()\n        for (x <- l) if (x > 0) l2\
    \ += x\n        l2.toList", '        l.filter(_ > 0)', '        l.filter(el =>
    el > 0l)', "        var ans = List[Long]()\n        for (i <- l) {\n         \
    \   if (i > 0) {\n                ans = ans :+ i\n            }\n        }\n \
    \       return ans", '        l.filter((x) => (x > 0))', '        return l.filter(x
    => x > 0)', "        var result : List[Long] = List()\n        for (item <- l)\
    \ {\n            if (item > 0) {\n                result = result :+ item\n  \
    \          }\n        }\n        return result", "        // Write your solution\
    \ here.\n        // Problem #1.\n        var positiveList = new ListBuffer[Long]()\n\
    \        for (i <- l) {\n            if (i > 0) {\n                positiveList\
    \ += i\n            }\n        }\n        return positiveList.toList", "     \
    \   var res : List[Long] = List.empty[Long]\n        for (i <- l) {\n        \
    \    if (i > 0) {\n                res = res :+ i\n            }\n        }\n\
    \        return res", '        l.filter(_ > 0)', "        // todo: return the\
    \ list with only positive numbers\n        return null", '        for (a <- l;
    if (a > 0)) yield a', '        return l.filter((x) => x > 0)', '        l.filter(x
    => x > 0)', '        l.filter(x => x > 0)', "        def getPositiveRec(l : List[Long],\
    \ result : List[Long]) : List[Long] = {\n            l match {\n             \
    \   case Nil => result\n                case x :: tail => if (x > 0) getPositiveRec(tail,\
    \ x :: result) else getPositiveRec(tail, result)\n            }\n        }\n \
    \       getPositiveRec(l, List[Long]()).reverse", '        l.filter(x => x > 0l.toLong)',
  "        var pList = List[Long]()\n        l.foreach(n => if (n > 0) pList = pList\
    \ :+ n)\n        pList", '        l.filter((e) => e > 0)', "        // Implement\
    \ the body.\n        l.filter(x => x > 0)", '        l.filter(x => (x > 0))',
  "        if (l.isEmpty) {\n            List[Long]()\n        } else {\n        \
    \    if (l.head >= 0) {\n                List[Long](l.head) ::: getPositive(l.tail)\n\
    \            } else {\n                getPositive(l.tail)\n            }\n  \
    \      }", "        // Fill up this function body\n        // `l` is a list of\
    \ long values.\n        // You need to return only positive numbers in the list.\n\
    \        return l.filter((x : Long) => x > 0)", '        return l.filter(x =>
    x > 0)', "        var ret = List[Long]()\n        for (n <- l) {\n           \
    \ if (n > 0) ret = ret :+ n\n        }\n        ret", "        if (l.length ==\
    \ 0) return List[Long]()\n        if (l.head > 0) return List[Long](l.head) ++\
    \ getPositive(l.tail)\n        else return getPositive(l.tail)", '        return
    l.filter((x : Long) => {return x > 0l.toLong})', "        if (l.isEmpty) {\n \
    \           l\n        } else {\n            if (l.head > 0) {\n             \
    \   l.head :: getPositive(l.tail)\n            } else {\n                getPositive(l.tail)\n\
    \            }\n        }", '        l.filter(x => x > 0)', "        var res =\
    \ new ListBuffer[Long]()\n        for (i <- l) {\n            if (i > 0) {\n \
    \               res += i\n            }\n        }\n        return res.toList",
  '        return l.filter(n => n > 0)', '        return l.filter((x : Long) => (x
    > 0))', '        l.filter(x => x > 0)', '        l.filter(x => x > 0)', "    \
    \    def getPositiveRec(inL : List[Long], outL : List[Long]) : List[Long] = {\n\
    \            if (inL.isEmpty) outL\n            else {\n                val head\
    \ = inL.head\n                if (head > 0) getPositiveRec(inL.tail, outL :+ head)\n\
    \                else getPositiveRec(inL.tail, outL)\n            }\n        }\n\
    \        getPositiveRec(l, List[Long]())", "        val list = scala.collection.mutable.ListBuffer[Long]()\n\
    \        for (i <- l) {\n            if (i > 0) {\n                list += i\n\
    \            }\n        }\n        list.toList", '        return l.filter((x :
    Long) => x > 0l)', '        return l.filter((x) => x > 0l.toLong)', '        return
    l.filter(element => (element > 0l.toLong));', '        l.filter(x => x > 0)',
  "        var ret = new ListBuffer[Long]\n        for (i <- l) {\n            if\
    \ (i > 0) ret += i\n        }\n        ret.toList", "        // var t = List[Long]()\n\
    \        // for (n <- l) {\n        //     if (n > 0) {\n        //         t\
    \ = t :+ n\n        //     }\n        // }\n        // t\n        l.filter(_ >\
    \ 0)", "        val l1 = l.filter(x => x > 0)\n        l1", '        return l.filter(l
    => l > 0)', '        return l.filter(v => v > 0)', '        l.filter(e => e >
    0)', '        l.filter(x => x > 0)', "        var answer : List[Long] = List()\n\
    \        for (i <- l) {\n            if (i > 0) answer = answer :+ i\n       \
    \ }\n        return answer", "        // Preconditions\n        assert(l != null)\n\
    \        var l2 = List[Long]()\n        for (x <- l) {\n            if (x > 0)\
    \ {\n                l2 = l2 :+ x\n            }\n        }\n        // Postconditions\n\
    \        assert(l2 != null)\n        for (x <- l2) {\n            assert(x > 0)\n\
    \        }\n        return l2", '        l.filter(num => num > 0)', "        //\
    \ code here\n        return l.filter(_ > 0)", "        var result = List[Long]()\n\
    \        for (n <- l) {\n            if (n > 0) {\n                result = result\
    \ :+ n\n            }\n        }\n        return result", '        // your code
    goes here', '        l.filter(x => x > 0)', '        return l.filter(x => x >
    0)', '        l.filter(_ > 0)', '        return l.filter(x => x > 0)', '        //
    insert your code here', '        l.filter(_ > 0)', '        return l.filter(x
    => x > 0)', '        return l.filter(e => e > 0l)', '        return l.filter(x
    => x > 0)', '        return l.filter(x => x > 0)', "        val buf = new ListBuffer[Long]\n\
    \        for (i <- l) {\n            if (i > 0) buf += i\n        }\n        buf.toList",
  "        var ls : List[Long] = List()\n        for (i <- l) {\n            if (i\
    \ > 0) {\n                ls = ls :+ i\n            }\n        }\n        return\
    \ ls", "        var res : List[Long] = List[Long]()\n        for (i <- l) {\n\
    \            if (i > 0) res = res :+ i\n        }\n        res", '        l.filter(_
    > 0)', "        var r = List[Long]()\n        for (e <- l) {\n            if (e\
    \ > 0) r = e :: r\n        }\n        r.reverse", "        val lst : List[Long]\
    \ = l.filter(x => x > 0)\n        lst", '        l.filter(p => p > 0)', "    \
    \    if (l.isEmpty) {\n            List[Long]()\n        } else {\n          \
    \  if (l.head > 0) {\n                List[Long](l.head) ::: getPositive(l.tail)\n\
    \            } else {\n                getPositive(l.tail)\n            }\n  \
    \      }", "        // Implement me\n        l.filter(x => x > 0l)", "       \
    \ //filter(l, {x : Long => x > 0})\n        l.filter(_ > 0)", '        l.filter(x
    => x > 0)', "        var posNumbers = List[Long]()\n        l.foreach((n : Long)\
    \ => if (n > 0) posNumbers = posNumbers :+ n)\n        posNumbers", '        l.filter(x
    => x > 0)', "        var ll : List[Long] = List()\n        for (i <- l) {\n  \
    \          if (i > 0) {\n                ll = ll :+ i\n            }\n       \
    \ }\n        return ll", '        l.filter(x => x > 0)', '        l.filter(x =>
    x > 0)', "        var res : List[Long] = Nil\n        for (n <- l) {\n       \
    \     if (n > 0) {\n                res = res :+ n\n            }\n        }\n\
    \        return res", '        l.filter((x : Long) => x > 0l.toLong)', '        l.filter(_
    > 0)', '        l.filter(e => e > 0)', '        for(i <- l if i > 0) yield i',
  "        def getPositiveHelper(l : List[Long], result : List[Long]) : List[Long]\
    \ = {\n            if (l.isEmpty) {\n                result\n            } else\
    \ {\n                val head = l.head\n                if (head > 0) {\n    \
    \                getPositiveHelper(l.tail, result :+ head)\n                }\
    \ else {\n                    getPositiveHelper(l.tail, result)\n            \
    \    }\n            }\n        }\n        getPositiveHelper(l, List[Long]())",
  '        l.filter(x => x > 0l.toLong)', "\t\tl.filter(x => x > 0)", '        return
    l.filter(_ > 0l.toLong)', '        return l.filter((x : Long) => x > 0)', '        l.filter(_
    > 0l)', "        var result : List[Long] = List.empty[Long]\n        for (item\
    \ <- l) if (item > 0) result = result :+ item\n        return result", '        return
    l.filter(x => x > 0)', "        var ret : List[Long] = List[Long]()\n        for\
    \ (i <- l) {\n            if (i > 0) {\n                ret = ret :+ i\n     \
    \       }\n        }\n        return ret", "        var result : List[Long] =\
    \ List()\n        for (i <- l) {\n            if (i > 0) result = result :+ i\n\
    \        }\n        return result", '        l.filter((x : Long) => x > 0)', '        l.filter(_
    > 0l)', "        var ans = List[Long]()\n        for (i <- l) if (i > 0) ans =\
    \ ans :+ i\n        ans", "\t\tval len = l.length\n\t\tvar pos = List[Long]()\n\
    \t\tfor (i <- (0 to len - 1)) {\n\t\t\tval num = l(i)\n\t\t\tif (num > 0) {\n\t\
    \t\t\tpos = num :: pos\n\t\t\t}\n\t\t}\n\t\tpos", '        l.filter(x => x > 0l.toLong)',
  "        val r = ListBuffer[Long]()\n        l.foreach(x => if (x > 0) r += x)\n\
    \        r.toList", '        l.filter(x => x > 0)', "        var b : ListBuffer[Long]\
    \ = new ListBuffer[Long]()\n        for (i <- l) {\n            if (i > 0) {\n\
    \                b += i\n            }\n        }\n        b.toList", '        l.filter((x
    : Long) => x > 0l.toLong)', '        return l.filter(_ > 0)', "\tl.filter((x :\
    \ Long) => x > 0)", '        return l.filter(x => x > 0);', "        var positives\
    \ = List[Long]()\n        for (i <- l) {\n            if (i > 0) {\n         \
    \       positives = positives :+ i\n            }\n        }\n        return positives",
  '        l.filter((x : Long) => x > 0l.toLong)', '        l.filter(i => i > 0l.toLong)',
  '        return l.filter(x => x > 0)', '        l.filter((x : Long) => x > 0)',
  '        return l.filter(i => i > 0l)', '        l.filter(i => i > 0)', '        return
    l.filter((n : Long) => n > 0)', '        return l.filter(x => x > 0)', "     \
    \   // Pre-condition\n        if (l == null) throw new IllegalArgumentException\n\
    \        // Body\n        var filteredList = List[Long]()\n        for (item <-\
    \ l) {\n            if (item > 0) {\n                filteredList = filteredList\
    \ :+ item\n            }\n        }\n        return filteredList", "        //\
    \ Write your code here.\n        return l.filter(x => x > 0)", '        l.filter(
    _ > 0l.toLong)', '        for (i <- l if i > 0) yield i', "        // TODO: Return\
    \ positive numbers in l\n        l.filter(x => x > 0)", "        var res : List[Long]\
    \ = List()\n        for (i <- l) {\n            if (i > 0) res = res :+ i\n  \
    \      }\n        res", "        val buf = new ListBuffer[Long]()\n        for\
    \ (x <- l) {\n            if (x > 0) {\n                buf += x\n           \
    \ }\n        }\n        buf.toList", '        return l.filter((x) => x > 0)',
  '        l.filter(0 < _)', '        return l.filter(x => (x >= 0))', "        var\
    \ positiveList = List[Long]()\n        positiveList = l.filter(x => x >= 0)\n\
    \        return positiveList", '        return l.filter(x => x > 0)', '        l.filter(_
    > 0)', '        l.filter(_ > 0)', "        // If a number is negative, remove\
    \ it from the list.\n        var m : List[Long] = List()\n        for (n <- l)\
    \ {\n            if (n > 0) {\n                m = m :+ n\n            }\n   \
    \     }\n        return m", "        val b = ArrayBuffer[Long]()\n        for\
    \ (i <- l if i > 0) {\n            b += i\n        }\n        b.toList", '        l.filter(x
    => (x > 0))', '        l.filter(e => e > 0)', "        var r : List[Long] = List[Long]()\n\
    \        for (i <- l) if (i > 0) r = r :+ i\n        r", '        return l.filter(_
    > 0)', "        // your code here\n        l.filter(i => i > 0)", '        l.filter(_
    > 0)', '        l.filter((n) => n > 0)', '        return l.filter( x => x > 0)',
  '        return l.filter(x => x > 0)', '        for (x <- l if x > 0) yield x',
  "        var r : List[Long] = List()\n        for (i <- l) if (i > 0) r = r :+ i\n\
    \        r", "        // l.filter(x => x > 0)\n        l.flatMap(x => if (x >\
    \ 0) Some(x) else None)", '        return l.filter(x => x > 0)', "        var\
    \ res : List[Long] = List()\n        for (i <- l) {\n            if (i > 0) {\n\
    \                res = res :+ i\n            }\n        }\n        return res",
  '        return l.filter(x => x > 0)', '        l.filter(x => x > 0)', "       \
    \ var ret : List[Long] = List()\n        for (x <- l) {\n            if (x > 0)\
    \ {\n                ret = ret :+ x\n            }\n        }\n        return\
    \ ret", '        return l.filter(_ > 0)', '        l.filter(x => x > 0)', '        l.filter(_
    >= 0)', '        l.filter(p => p > 0)', '        l.filter(e => e > 0)', '        return
    l.filter(element => element > 0)', "        // import List._\n        // l.filter(n\
    \ => n > 0)\n        l.filter(_ > 0)", "\tl.filter((x : Long) => x > 0)", '        l.filter(x
    => x > 0l.toLong)', "        val h = new HashSet[Long]\n        for (x <- l) if\
    \ (x > 0) h += x\n        h.toList", '        l.filter(x => x > 0)', '        l.filter((x
    : Long) => {x > 0l})', "        // >>> getPositive((List[Long](-1l.toLong, 2l.toLong,\
    \ -4l.toLong, 5l.toLong, 6l.toLong)))\n        // (List[Long](2l.toLong, 5l.toLong,\
    \ 6l.toLong))\n        l.filter((x : Long) => x > 0l.toLong)", '        l.filter(a
    => a > 0l.toLong)', '        l.filter(n => n > 0)', "        // Write your code\
    \ here\n        var out = List[Long]()\n        for (x <- l) {\n            if\
    \ (x > 0) out = out :+ x\n        }\n        out", '        return l.filter((x
    : Long) => x > 0l)', "        if (l.length == 0) {\n            List[Long]()\n\
    \        } else {\n            var result = getPositive(l.tail)\n            if\
    \ (l.head >= 0) {\n                l.head :: result\n            } else {\n  \
    \              result\n            }\n        }", '        l.filter((x) => x >
    0)', '        l.filter((x : Long) => x > 0l.toLong)', '        return l.filter(x
    => x > 0)', '        l.filter(x => x > 0)', '        return l.filter(_ > 0)',
  '        l.filter(x => x > 0)', '        return l.filter(x => x > 0l.toLong)', " \
    \       // Fill up this function body\n        // 'l' is a list of integers.\n\
    \        var result = List[Long]()\n        for (element <- l) {\n           \
    \ if (element > 0) {\n                result = element :: result\n           \
    \ }\n        }\n        return result", "        var ret = List[Long]()\n    \
    \    for (item <- l) {\n            if (item > 0) ret = ret :+ item\n        }\n\
    \        return ret", '        l.filter(x => x > 0)', '        return l.filter((i
    : Long) => i > 0l)', "        val positive = new ListBuffer[Long]\n        l.foreach(i\
    \ => if (i > 0) positive += i)\n        positive.toList", "        val positiveNumbers\
    \ = ListBuffer[Long]()\n        for (number <- l) {\n            if (number >\
    \ 0) {\n                positiveNumbers += number\n            }\n        }\n\
    \        positiveNumbers.toList"]
stop_tokens:
- "\n    }\n"
