name: HumanEval_107_even_odd_palindrome
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return a tuple that has the number of even and\
  \ odd\n    // integer palindromes that fall within the range(1, n), inclusive.\n\
  \    // Example 1:\n    // >>> evenOddPalindrome((3l))\n    // ((1l, 2l))\n    //\
  \ Explanation:\n    // Integer palindrome are 1, 2, 3. one of them is even, and\
  \ two of them are odd.\n    // Example 2:\n    // >>> evenOddPalindrome((12l))\n\
  \    // ((4l, 6l))\n    // Explanation:\n    // Integer palindrome are 1, 2, 3,\
  \ 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n    // Note:\n\
  \    // 1. 1 <= n <= 10^3\n    // 2. returned tuple has the number of even and odd\
  \ integer palindromes respectively.\n    def evenOddPalindrome(n : Long) : Tuple2[Long,\
  \ Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(evenOddPalindrome((123l)).equals(((8l,\
  \ 13l))));\n    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((3l)).equals(((1l,\
  \ 2l))));\n    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));\n    assert(evenOddPalindrome((25l)).equals(((5l,\
  \ 6l))));\n    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((9l)).equals(((4l,\
  \ 5l))));\n    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));\n    }\n\n}\n"
completions: ["        // Given a long number n, construct the palindrome list.\n\
    \        // Ex:\n        // >>> constructPalindromeList(12)\n        // List(1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 11)\n        def constructPalindromeList(n : Long) :\
    \ List[Long] = {\n            var list = List[Long]()\n            for (i <- 1l\
    \ to n) {\n                if (isPalindrome(i)) list = list :+ i\n           \
    \ }\n            list\n        }\n        // Given a long number n, return the\
    \ list of number, the given number is palindrome or not.\n        // Ex:\n   \
    \     // >>> isPalindrome(0)\n        // true\n        // >>> isPalindrome(1)\n\
    \        // true\n        // >>> isPalindrome(11)\n        // true\n        //\
    \ >>> isPalindrome(111)\n        // true\n        // >>> isPalindrome(12)\n  \
    \      // false\n        // >>> isPalindrome(123)\n        // false\n        def\
    \ isPalindrome(n : Long) : Boolean = {\n            var s = n.toString\n     \
    \       if (s.length == 1) return true\n            var sb = new StringBuilder(s)\n\
    \            if (s == sb.reverse.toString) return true\n            else return\
    \ false\n        }\n        // Given a list of long numbers, filter out the even\
    \ number.\n        // Ex:\n        // >>> filterEven(List(1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 11))\n        // List(2, 4, 6, 8)\n        def filterEven(list : List[Long])\
    \ : List[Long] = {\n            var result = List[Long]()\n            for (i\
    \ <- list) {\n                if (i % 2 == 0) result = result :+ i\n         \
    \   }\n            result\n        }\n        // Given a list of long numbers,\
    \ filter out the odd number.\n        // Ex:\n        // >>> filterOdd(List(1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 11))\n        // List(1, 3, 5, 7, 9, 11", "        //\
    \ Fill up this function body\n        // `n` is the number of digits in the number\n\
    \        if (n == 1) return (1l, 0l)\n        val mod = pow(10, n / 2)\n     \
    \   var m = n / 2.0\n        if (n % 2 == 1) m += 0.5\n        var res = pow(10,\
    \ m).toLong\n        if (n % 2 == 1) res = (res - 1) / 9\n        val e = res\
    \ / 2\n        val o = res - e\n        var small = (1 until (n / 2)).map(x =>\
    \ pow(10, x).toLong).sum\n        small = (small - 1) / 9\n        if (n % 2 ==\
    \ 1) {\n            val large = (1 until (n / 2)).map(x => pow(10, x).toLong).sum\n\
    \            large *= 10\n            res += large\n            val e1 = large\
    \ / 2\n            val o1 = large - e1\n            return (e1 + e, o1 + o)\n\
    \        }\n        (e + small, o + small)", "        // The first line of the\
    \ code is the type of the parameter.\n        // The second line of the code is\
    \ the type of the return value.\n        // Write your code here\n        val\
    \ oddPalindromes = (1 to n.toInt).map(x => x.toString).count(x => x == x.reverse\
    \ && x.length % 2 == 1)\n        val evenPalindromes = (1 to n.toInt).map(x =>\
    \ x.toString).count(x => x == x.reverse && x.length % 2 == 0)\n        (evenPalindromes,\
    \ oddPalindromes)", "        // Note:\n        // 1. 1 <= n <= 10^3 => 1 <= n\
    \ <= 999\n        // 2. Integer palindrome:\n        //   1) Single digit: 1 <=\
    \ n <= 9\n        //   2) Double digit: 10 <= n <= 99\n        //   3) Triple\
    \ digit: 100 <= n <= 999\n        // 3. Palindrome numbers:\n        //   1) \
    \ 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171,\
    \ 181, 191, 202, 212,\n        //       222, 232, 242, 252, 262, 272, 282, 292,\
    \ 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414,\n        //    \
    \   424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565,\
    \ 575, 585, 595, 606, 616,\n        //       626, 636, 646, 656, 666, 676, 686,\
    \ 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818,\n        //\
    \       828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959,\
    \ 969, 979, 989, 999\n        //   2)  1, 3, 5, 7, 9\n        //   3)  0, 2, 4,\
    \ 6, 8\n        //   4)  10, 12, 14, 16, 18, 20, ..., 98, 100, 102, 104, 106,\
    \ 108, ..., 998, 1000\n        // 4.\n        //   1)  1, 3, 5, 7, 9\n       \
    \ //   2)  11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161,\
    \ 171, 181, 191, 202, 212,\n        //       222, 232, 242, 252, 262, 272, 282,",
  "        // Precondition\n        require(n >= 1)\n        require(n <= 1e3)\n \
    \       val t = new Tuple2[Long, Long](0, 0)\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) t._1\
    \ += 1\n                else t._2 += 1\n            }\n        }\n        t",
  "        def f(s : String) : Boolean = {\n            val x = s.length / 2\n   \
    \         s.substring(0, x) == s.substring(s.length - x, s.length).reverse\n \
    \       }\n        def g(n : Long) : Long = {\n            if (n < 0) {\n    \
    \            0\n            } else if (n < 10) {\n                1\n        \
    \    } else {\n                g(n / 10) * 10 + 1\n            }\n        }\n\
    \        def h(n : Long) : Long = {\n            if (n == 0) {\n             \
    \   1\n            } else {\n                h(n / 10) + 1\n            }\n  \
    \      }\n        val result = ((0l, 0l) /: (1l to n))((x, y) => if (f(y.toString))\
    \ if (y % 2 == 0) (x._1 + 1, x._2) else (x._1, x._2 + 1) else x)\n        result",
  "        // Given a positive integer n, return a tuple that has the number of even\
    \ and odd\n        // integer palindromes that fall within the range(1, n), inclusive.\n\
    \        def evenOddPalindromeHelper(n : Long, even : Long, odd : Long) : Tuple2[Long,\
    \ Long] = {\n            if (n == 0) (even, odd)\n            else if (n % 10\
    \ == 0) evenOddPalindromeHelper(n / 10, even, odd)\n            else if (n % 2\
    \ == 0) evenOddPalindromeHelper(n - 1, even + 1, odd)\n            else evenOddPalindromeHelper(n\
    \ - 1, even, odd + 1)\n        }\n        evenOddPalindromeHelper(n, 0, 0)", " \
    \       // Your code here\n        var count_even: Long = 0\n        var count_odd:\
    \ Long = 0\n        for (i <- 1 to n.toInt) {\n            if (is_palindrome(i.toString))\
    \ {\n                if (i.toString.length % 2 == 0) {\n                    count_even\
    \ += 1\n                } else {\n                    count_odd += 1\n       \
    \         }\n            }\n        }\n        (count_even, count_odd)", '        ???',
  "        var sum : Tuple2[Long, Long] = (0l, 0l)\n        for (j <- 1l to n) {\n\
    \            var s : String = j.toString\n            if (s == s.reverse) {\n\
    \                if (j % 2 == 0) sum = (sum._1 + 1, sum._2)\n                else\
    \ sum = (sum._1, sum._2 + 1)\n            }\n        }\n        sum", "      \
    \  var even = 0\n        var odd = 0\n        for (i <- 1 to n.toInt) {\n    \
    \        if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n \
    \               else odd += 1\n            }\n        }\n        return (even,\
    \ odd)", "        def countPalindrome(n : Long) : Tuple2[Long, Long] = {\n   \
    \         if (n <= 1) return (1, 0)\n            val list = n.toString.toList\n\
    \            val (even, odd) = countPalindrome(n / 10)\n            val mid =\
    \ list.size / 2\n            val (leven, lodd) = if (mid == 0) (0, 0) else countPalindrome(n\
    \ / pow(10, mid).toLong)\n            val (reven, rodd) = if (list.size % 2 ==\
    \ 0) (leven, lodd) else (lodd, leven)\n            (even + (leven + 1) * (reven\
    \ + 1) - 1, odd + leven * reven)\n        }\n        countPalindrome(n)", "  \
    \      // The number of even and odd integer palindromes that fall within the\
    \ range(1, n), inclusive.\n        val even = ListBuffer[Long]()\n        val\
    \ odd = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if\
    \ (isPalindrome(i.toString)) {\n                if (i % 2 == 0) even += i.toLong\
    \ else odd += i.toLong\n            }\n        }\n        (even.length, odd.length)",
  "        // maximum number of digits in n\n        val digits = log10(n).toInt +\
    \ 1\n        // possibilities is the number of all numbers of a certain number\
    \ of digits\n        // 5 1 2 4\n        // possibilities are 5 * (10 ^ 1) * (5)^2\n\
    \        // where (10 ^ 1) is all numbers of 1 digit\n        // where (5)^2 is\
    \ all numbers of 2 digits\n        // So in general, possibilities is \n     \
    \   // n * (10 ^ (digits - 1)) * ((n / 2) ^ (digits - 1))\n        // 1st part\
    \ of tuple is sum of all even possibilities from 1 to digits\n        // 2nd part\
    \ of tuple is sum of all odd possibilities from 1 to digits\n        // where\
    \ possibilities are calculated as described above\n        var sumOdd = 0l\n \
    \       var sumEven = 0l\n        for (d <- 1 to digits) {\n            // possibilities\
    \ is the number of all numbers of d digits\n            val possibilities = n\
    \ * pow(10, d - 1).toLong * pow(n / 2, d - 1).toLong\n            if (d % 2 ==\
    \ 0) sumEven += possibilities\n            else sumOdd += possibilities\n    \
    \    }\n        (sumEven, sumOdd)", "        def isPalindrome(n : Long) : Boolean\
    \ = {\n            var m = n\n            var reversed = 0L\n            while\
    \ (m > 0) {\n                reversed = 10 * reversed + m % 10\n             \
    \   m /= 10\n            }\n            n == reversed\n        }\n        var\
    \ evenCount = 0L\n        var oddCount = 0L\n        for (i <- 1 to n.toInt) {\n\
    \            if (isPalindrome(i)) {\n                if (i % 2 == 0) evenCount\
    \ += 1 else oddCount += 1\n            }\n        }\n        (evenCount, oddCount)",
  "        // Given a positive integer n, return a tuple that has the number of even\
    \ and odd\n        // integer palindromes that fall within the range(1, n), inclusive.\n\
    \        val evens = Range(1, n.toInt + 1).filter(x => x.toString == x.toString.reverse\
    \ && x % 2 == 0).length\n        val odds = Range(1, n.toInt + 1).filter(x =>\
    \ x.toString == x.toString.reverse && x % 2 == 1).length\n        (evens, odds)",
  "        var x : Long = 0\n        var y : Long = 0\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) x +=\
    \ 1\n                else y += 1\n            }\n        }\n        return (x,\
    \ y)", "        var evens = 0l\n        var odds = 0l\n        for (i <- 1 to\
    \ n.toInt) {\n            if (isPalindrome(i)) {\n                if (i % 2 ==\
    \ 0) evens += 1\n                else odds += 1\n            }\n        }\n  \
    \      (evens, odds)", "        def toIntList(n : Long) : List[Int] = {\n    \
    \        def iter(n : Long, l : List[Int]) : List[Int] = if (n == 0) l else iter(n\
    \ / 10, (n % 10).toInt :: l)\n            iter(n, Nil)\n        }\n        def\
    \ toInt(l : List[Int]) : Int = l.reverse.zipWithIndex.map(e => e._1 * pow(10,\
    \ e._2).toInt).sum\n        def isPalindrome(l : List[Int]) : Boolean = l == l.reverse\n\
    \        def listPalindrome(n : Int) : List[Int] = {\n            val l = toIntList(n)\n\
    \            val b = new StringBuilder\n            for (i <- 0 until l.length\
    \ / 2) b.append(l(i))\n            if (l.length % 2 == 1) b.append(l(l.length\
    \ / 2))\n            for (i <- l.length / 2 - 1 to 0 by -1) b.append(l(i))\n \
    \           toIntList(b.toString.toInt)\n        }\n        def isEven(n : Int)\
    \ : Boolean = if (n % 2 == 0) true else false\n        def iter(l : List[Int],\
    \ even : Long, odd : Long) : Tuple2[Long, Long] = l match {\n            case\
    \ Nil => (even, odd)\n            case h :: t => if (isEven(h)) iter(t, even +\
    \ 1, odd) else iter(t, even, odd + 1)\n        }\n        val l = listPalindrome(n.toInt)\n\
    \        iter(l, 0, 0)", "        // Write your code here\n        // Remember\
    \ to return the tuple (Long, Long)\n        return (0, 0)", "        var evenPalindrome\
    \ = 0l\n        var oddPalindrome = 0l\n        for (i <- 1 to n.toInt) {\n  \
    \          if (i.toString.equals(i.toString.reverse)) {\n                if (i\
    \ % 2 == 0) evenPalindrome += 1\n                else oddPalindrome += 1\n   \
    \         }\n        }\n        (evenPalindrome, oddPalindrome)", "        var\
    \ dict = new HashMap[Long, Tuple2[Long, Long]]()\n        return helper(n, dict)",
  "        // Fill up this function body\n        // `0.toLong` is just a placeholder.\n\
    \        // You can change it to your answer.\n        (0.toLong, 0.toLong)",
  "        // Write your code here\n        def isPalindrome(i : Long) : Boolean =\
    \ {\n            i.toString.reverse == i.toString\n        }\n        var evenCount\
    \ = 0\n        var oddCount = 0\n        for (i <- 1 to n.toInt) {\n         \
    \   if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n              \
    \      evenCount += 1\n                } else {\n                    oddCount\
    \ += 1\n                }\n            }\n        }\n        (evenCount, oddCount)",
  "        n match {\n            case x if (x == 1) => (1, 0)\n            case x\
    \ if (x == 2) => (0, 1)\n            case x if (x == 3) => (1, 2)\n          \
    \  case x if (x == 4) => (2, 3)\n            case x if (x == 5) => (2, 4)\n  \
    \          case x if (x == 6) => (3, 5)\n            case x if (x == 7) => (3,\
    \ 6)\n            case x if (x == 8) => (4, 7)\n            case x if (x == 9)\
    \ => (4, 8)\n            case x if (x == 10) => (5, 9)\n            case x if\
    \ (x == 11) => (5, 10)\n            case x if (x == 12) => (6, 11)\n         \
    \   case x if (x == 13) => (6, 12)\n            case x if (x == 14) => (7, 13)\n\
    \            case x if (x == 15) => (7, 14)\n            case x if (x == 16) =>\
    \ (8, 15)\n            case x if (x == 17) => (8, 16)\n            case x if (x\
    \ == 18) => (9, 17)\n            case x if (x == 19) => (9, 18)\n            case\
    \ x if (x == 20) => (10, 19)\n            case x if (x == 21) => (10, 20)\n  \
    \          case x if (x == 22) => (11, 21)\n            case x if (x == 23) =>\
    \ (11, 22)\n            case x if (x == 24) => (12, 23)\n            case x if\
    \ (x == 25) => (12, 24)\n            case x if (x == 26) => (13, 25)\n       \
    \     case x if (x == 27) => (13, 26)\n            case x if (x == 28) => (14,\
    \ 27)\n            case x if (x == 29) => (14, 28)\n            case x if (x ==\
    \ 30) => (15, 29)\n            case x if (x == 31) => (15, 30)\n            case\
    \ x if (x == 32) =>", "        // 1 <= n <= 10^3\n        // Construct all palindromes\
    \ from 1 to n, check whether it is even or odd.\n        // Return the count of\
    \ even and odd\n        def palindrome(n : Long) : Tuple2[Long, Long] = {\n  \
    \          // 1 <= n <= 10^3\n            // Construct all palindromes from 1\
    \ to n, check whether it is even or odd.\n            // Return the count of even\
    \ and odd\n            val limit = pow(10, ceil(log10(n))).toLong\n          \
    \  def palindrome(c : Long, limit : Long, even : Long, odd : Long) : Tuple2[Long,\
    \ Long] = {\n                if (c >= limit) (even, odd)\n                else\
    \ {\n                    // c >= limit\n                    // Construct even-digit\
    \ palindrome and odd-digit palindrome\n                    val evenC = (c.toString\
    \ + c.toString.reverse).toLong\n                    val oddC = (c.toString + c.toString.reverse.substring(1)).toLong\n\
    \                    val evenCount = if (evenC <= n) 1 else 0\n              \
    \      val oddCount = if (oddC <= n) 1 else 0\n                    palindrome(c\
    \ + 1, limit, even + evenCount, odd + oddCount)\n                }\n         \
    \   }\n            palindrome(1, limit, 0, 0)\n        }\n        palindrome(n)",
  "        // If we can generate all even-length and odd-length palindromes at once,\n\
    \        // we can find the answer in O(1)\n        // We can generate all palindromes\
    \ in O(n) time using dynamic programming\n        // or Manacher's algorithm.\n\
    \        def isPalindrome(s : String) : Boolean = s == s.reverse\n        def\
    \ generatePalindromes(n : Long) : List[Long] = {\n            val maxLength =\
    \ n.toString.length\n            val palindromes = new ListBuffer[Long]\n    \
    \        for (i <- 1 to maxLength) {\n                val maxDigit = (n / (scala.math.pow(10,\
    \ i) - 1)).toInt\n                for (j <- 0 to maxDigit) {\n               \
    \     val num = (n / (scala.math.pow(10, i) - 1) * (scala.math.pow(10, i - 1)\
    \ - 1) + j * (scala.math.pow(10, i - 1) - 1)).toLong\n                    if (isPalindrome(num.toString))\
    \ palindromes += num\n                }\n            }\n            palindromes.toList\n\
    \        }\n        def numberOfPalindromes(n : Long) : Tuple2[Long, Long] = {\n\
    \            val palindromes = generatePalindromes(n)\n            val evenCount\
    \ = palindromes.count(_ % 2 == 0)\n            val oddCount = palindromes.count(_\
    \ % 2 == 1)\n            (evenCount, oddCount)\n        }\n        numberOfPalindromes(n)",
  "        // Fill up this function body\n        // `n` is an integer in the range\
    \ of [1, 1000]\n        var arr = new Array[Long](n.toInt + 1)\n        var i\
    \ = 0\n        while (i <= n) {\n            if (isPalindrome(i.toString)) arr(i)\
    \ = 1\n            i += 1\n        }\n        var sum = new Array[Long](n.toInt\
    \ + 1)\n        sum(0) = 0\n        i = 1\n        while (i <= n) {\n        \
    \    sum(i) = sum(i - 1) + arr(i)\n            i += 1\n        }\n        return\
    \ (sum(n.toInt) - (sum(n.toInt) - sum(n.toInt / 2)) / 2, (sum(n.toInt) - sum(n.toInt\
    \ / 2)) / 2)", "        // Iterate every integer from 1 to n, and get the palindrome\
    \ of each integer.\n        // If the palindrome is even, increment the even counter.\n\
    \        // If the palindrome is odd, increment the odd counter.\n        // At\
    \ the end, return a tuple with the number of even and odd palindromes respectively.\n\
    \        var even = 0l\n        var odd = 0l\n        for (i <- 1 to n.toInt)\
    \ {\n            val palindrome = i.toString.reverse.toInt\n            if (palindrome\
    \ % 2 == 0) even += 1\n            else odd += 1\n        }\n        (even, odd)",
  "        // Fill up this function body\n        // `0` is placeholder, replace it\
    \ with your code\n        val even = n / 2\n        val odd = (n - 1) / 2\n  \
    \      return (even, odd)", "        // Write your code here\n        val nums\
    \ = (1 to n.toInt).toList\n        val palindromes = nums.filter(num => num.toString\
    \ == num.toString.reverse)\n        val (evens, odds) = palindromes.partition(num\
    \ => num % 2 == 0)\n        (evens.length, odds.length)", "        // Write your\
    \ solution here\n        var result : Tuple2[Long, Long] = (0, 0)\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) {\n                    result = (result._1 + 1, result._2)\n  \
    \              } else {\n                    result = (result._1, result._2 +\
    \ 1)\n                }\n            }\n        }\n        result", "        //\
    \ Implement this\n        (0, 0)", "        // Fill up this function body\n  \
    \      // `even` is the number of even integer palindromes\n        // `odd` is\
    \ the number of odd integer palindromes\n        val even = 1l\n        val odd\
    \ = 2l\n        (even, odd)", "        // Note: This is the only line you need\
    \ to implement.\n        // Please do not modify any other code.\n        (0l,\
    \ 0l)", "        // your code here\n        // Scala implementation of <https://github.com/bewantbe/unit-test-scala/blob/master/src/test/scala/com/bewantbe/algorithm/misc/EvenOddPalindrome.scala>\n\
    \        var ans_even = 0l\n        var ans_odd = 0l\n        def iter_count(now:\
    \ Long, left: Int, pow10: Long, carry: Long): Unit = {\n            if (now <=\
    \ n) {\n                if (left == 0) {\n                    //println(now, left,\
    \ pow10, carry)\n                    if (now == carry) {\n                   \
    \     if (pow10 > 1) ans_even += 1\n                        else ans_odd += 1\n\
    \                    }\n                } else {\n                    for (i <-\
    \ 0 to 9) {\n                        iter_count(now + i * pow10 + i * carry, left\
    \ - 1, pow10 * 10, i * pow10 + carry)\n                    }\n               \
    \ }\n            }\n        }\n        iter_count(0, 1, 1, 0)\n        (ans_even,\
    \ ans_odd)", "        // \u611F\u60F3: \u5C0F\u3055\u3044\u5024\u304B\u3089\u9806\
    \u306Bn\u307E\u3067\u3092\u63A2\u3057\u3066\u3001\u305D\u306E\u6570\u304C\u56DE\
    \u6587\u6570\u306A\u3089\u3070\u3001\u305D\u306E\u4E2D\u3067\u5076\u6570\u304B\
    \u5947\u6570\u304B\u3092\u30AB\u30A6\u30F3\u30C8\u3057\u3066\u3044\u304F\u3002\
    \n        // \u3053\u308C\u3092\u305D\u306E\u307E\u307E\u5B9F\u88C5\u3059\u308B\
    \u3068\u3001n\u306B\u5927\u304D\u306A\u5024\u304C\u4E0E\u3048\u3089\u308C\u308B\
    \u3068\u3001\u51E6\u7406\u6642\u9593\u304C\u304B\u304B\u308B\u3002\n        //\
    \ \u3053\u306E\u3088\u3046\u306A\u72B6\u6CC1\u3067\u306F\u3001\u30D0\u30B0\u304C\
    \u767A\u751F\u3057\u3084\u3059\u3044\u306E\u3067\u3001\u5B9F\u88C5\u3059\u308B\
    \u524D\u306B\u30C6\u30B9\u30C8\u30B1\u30FC\u30B9\u3092\u4F5C\u6210\u3057\u3066\
    \u52D5\u4F5C\u691C\u8A3C\u3092\u884C\u3046\u3068\u826F\u3044\u3002\n        //\
    \ (\u4E0B\u306E\u30C6\u30B9\u30C8\u30B1\u30FC\u30B9\u3092\u8FFD\u52A0\u3059\u308B\
    \u524D\u306B\u3001n = 1000000000\u3067\u3082\u554F\u984C\u306A\u3044\u304B\u691C\
    \u8A3C\u3057\u3066\u307F\u305F\u3068\u3053\u308D\u3001n = 1000\u307E\u3067\u306F\
    \u554F\u984C\u306A\u304F\n        // \u52D5\u4F5C\u3057\u305F\u304C\u3001n = 1000000001\u3067\
    \u30EC\u30B3\u30FC\u30C9\u304C\u8DB3\u308A\u306A\u304F\u3066\u6B63\u3057\u304F\
    \u52D5\u4F5C\u3057\u306A\u304B\u3063\u305F\u306E\u3067\u3001\u81EA\u529B\u3067\
    \u554F\u984C\u304C\u767A\u898B\u3067\u304D\u305F\u3002)\n        var evenCount\
    \ = 0l\n        var oddCount = 0l\n        for (i <- 1 to n.toInt) {\n       \
    \     if (isPalindrome(i)) {\n                if (i % 2 == 0) evenCount += 1\n\
    \                else oddCount += 1\n            }\n        }\n        (evenCount,\
    \ oddCount)", "        // Fill up this function body\n        // `n` is positive\n\
    \        // `n` is positive and n <= 10^3\n        if (n == 1l) {\n          \
    \  (1l, 0l)\n        } else if (n == 2l) {\n            (1l, 1l)\n        } else\
    \ {\n            val half = floor(n / 2).toLong\n            val middle_even =\
    \ if (n % 2 == 0) 1 else 0\n            val upper_even = 2 * half - 1\n      \
    \      val lower_even = 2 * half\n            val even_palindrome = upper_even\
    \ + lower_even + middle_even\n            val odd_palindrome = 2 * (half + 1)\n\
    \            (even_palindrome, odd_palindrome)\n        }", "        // Your code\
    \ here\n        var list1 = new ListBuffer[Long]()\n        for (i <- 0l to n)\
    \ {\n            if (isPalindrome(i)) list1 += i\n        }\n        var list2\
    \ = new ListBuffer[Long]()\n        for (i <- list1) {\n            if (i % 2\
    \ == 0) list2 += i\n        }\n        (list2.length, list1.length - list2.length)",
  "        // TODO: Implement me!\n        return null;", "        val counts = Array(1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 11)\n        val start = 12\n        var current = start\n\
    \        var evenCount = 4l\n        var oddCount = 6l\n        while (current\
    \ <= n) {\n            val digitCount = log10(current).toInt + 1\n           \
    \ val binarySearch = binarySearch(current, 0, digitCount - 1, counts)\n      \
    \      if (binarySearch == -1) {\n                current += 1\n            }\
    \ else {\n                current = binarySearch\n                val isEven =\
    \ digitCount % 2 == 0\n                if (isEven) evenCount += 1 else oddCount\
    \ += 1\n            }\n        }\n        (evenCount, oddCount)", "        //\
    \ we can simply traverse all palindromes in the range of [1, n]\n        var cntEven\
    \ = 0l\n        var cntOdd = 0l\n        for (i <- 1 to n.toInt) {\n         \
    \   val s = i.toString\n            val ss = s + new StringBuilder(s).reverse.toString\n\
    \            val p = ss.toLong\n            if (p <= n) {\n                if\
    \ (p % 2 == 0) cntEven += 1\n                else cntOdd += 1\n            }\n\
    \        }\n        (cntEven, cntOdd)", "        val rt = n.toString.reverse.toLong\n\
    \        if (n == rt) {\n            val ev = if (n % 2 == 0) 1 else 0\n     \
    \       return (ev, 1 - ev)\n        }\n        return (0, 0)", '        return
    (0, 0)', "        // Implement this placeholder.\n        return (0, 0)", "  \
    \      var even = 0l\n        var odd = 0l\n        for (i <- 1 to n.toInt) {\n\
    \            if (i.toString == i.toString.reverse) {\n                if (i %\
    \ 2 == 0) even += 1 else odd += 1\n            }\n        }\n        (even, odd)",
  "        def calcPalindrome(n : Long) : Boolean = {\n            if (n <= 10) true\n\
    \            else {\n                val d = pow(10, floor(log10(n)).toInt).toLong\n\
    \                val firstDigit = n / d\n                val remaining = n % d\n\
    \                val lastDigit = n % 10\n                remaining / 10 == firstDigit\
    \ && calcPalindrome(remaining / 10)\n            }\n        }\n        val range\
    \ = 1 to n.toInt\n        val palindromes = range.filter(n => calcPalindrome(n))\n\
    \        val even = palindromes.filter(n => n % 2 == 0).length\n        val odd\
    \ = palindromes.filter(n => n % 2 == 1).length\n        (even, odd)", "      \
    \  // Write your code here\n        return null;", "        var e = 0l\n     \
    \   var o = 0l\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i.toString))\
    \ {\n                if (i % 2 == 0) {\n                    e += 1\n         \
    \       } else {\n                    o += 1\n                }\n            }\n\
    \        }\n        return (e, o)", "        // no need to write, it already has\
    \ the solution\n        // fun with ranges\n        // http://www.tutorialspoint.com/scala/scala_ranges.htm\n\
    \        var evens = 0\n        var odds = 0\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) evens\
    \ += 1\n                else odds += 1\n            }\n        }\n        return\
    \ (evens, odds)", "        // Your code here.\n        null", "        val p =\
    \ new Palindrome\n        var count = 0l\n        for (i <- 1 to n.toInt) {\n\
    \            if (p.isPalindrome(i)) {\n                count += 1\n          \
    \  }\n        }\n        return ((count / 2l, (count + 1l) / 2l))", "        var\
    \ res = (0l, 0l)\n        for (x <- 1l to n) if (isPalindrome(x)) res = (res._1\
    \ + 1, res._2 + 1)\n        return res", "        // We could solve this problem\
    \ by generating all the palindromes within the range(1, n), inclusive, and\n \
    \       // then counting the even and odd ones. Generating all the palindromes\
    \ would take O(n^2) time\n        // and space, where n is the length of the string\
    \ representation of n. Let us try to solve the problem\n        // more efficiently.\n\
    \        // If we look at the example, we will find that the number of even palindromes\
    \ is equal to the\n        // number of digits(1 to n) that have an even number\
    \ of factors. We can generate all the digits with\n        // even number of factors\
    \ in O(log n) time and space. Let us analyze the factors and the even digits\n\
    \        // we are generating.\n        // A digit can have 4 factors if and only\
    \ if it is a square of a number whose square root is a 3-digit\n        // number.\n\
    \        // A digit can have 2 factors if and only if it is a square of a number\
    \ whose square root is a 2-digit\n        // number.\n        // A digit can have\
    \ no factors if and only if it is a square of a number whose square root is a\
    \ 1-digit\n        // number.\n        // If we are generating all the digits\
    \ that are 4, 2, or 0, then we will also generate some digits that\n        //\
    \ are greater than n. Let us analyze how many we are generating.\n        // If\
    \ we are generating the numbers whose square root is a 1-digit number, then we\
    \ generate all the\n        // numbers from 1 to 9.\n        // If we are generating\
    \ the numbers whose square root is a 2-digit number, then we generate all the\n\
    \        // numbers from 1 to 9(for 1-digit square root numbers) and some digits\
    \ greater than 10.\n        // If we are generating the numbers whose square root\
    \ is a 3-digit number, then we generate all the\n        // numbers from 1 to\
    \ 9(for 1-digit square root numbers) and all the numbers from 1 to 9(for 2-digit\n\
    \        // square root numbers) and some digits greater than 100.\n        //\
    \ This means we need to generate the digits whose square root is a 1-digit number,\
    \ some digits whose\n        // square root is a 2-digit number, and some digits\
    \ whose square root is a 3-digit number.", "        // max is 10^3, so max length\
    \ of palindrome is 6(not 7, as first and last digits are the same).\n        //\
    \ so we can solve this problem by brute force.\n        // first, we build up\
    \ a map which contains all palindromes and their parity.\n        val map = new\
    \ HashMap[Long, Int]\n        def buildPalindromeMap() {\n            def isValid(n\
    \ : Long) = n.toString.forall(_.isDigit)\n            def isPalindrome(n : Long)\
    \ = n.toString == n.toString.reverse\n            def buildFromPair(x : Long,\
    \ y : Long) = {\n                // n = 10^x + n\n                var n = y\n\
    \                for (i <- 1 to x) n = n * 10 + y\n                n\n       \
    \     }\n            for (i <- 0 to 6) {\n                val x = pow(10, i).toLong\n\
    \                for (j <- 0 to 9) {\n                    val n = buildFromPair(i,\
    \ j)\n                    if (isValid(n) && isPalindrome(n)) {\n             \
    \           val parity = if (n % 2 == 0) 0 else 1\n                        map(n)\
    \ = parity\n                    }\n                }\n            }\n        }\n\
    \        buildPalindromeMap()\n        // then, we use this map to find out the\
    \ parity of each number.\n        val evens = map.filter(_._1 <= n).count(_._2\
    \ == 0)\n        val odds = map.filter(_._1 <= n).count(_._2 == 1)\n        (evens,\
    \ odds)", "        // This solution is extremely slow on big numbers.\n      \
    \  def isPalindrome(num : Long) : Boolean = {\n            if (num.toString ==\
    \ num.toString.reverse) true else false\n        }\n        def isOdd(num : Long)\
    \ : Boolean = {\n            if (num % 2 == 0) false else true\n        }\n  \
    \      var nums = new ArrayBuffer[Long]\n        for (i <- 1l to n) {\n      \
    \      if (isPalindrome(i)) nums += i\n        }\n        var evens = 0l\n   \
    \     var odds = 0l\n        for (i <- nums) {\n            if (isOdd(i)) odds\
    \ += 1\n            else evens += 1\n        }\n        (evens, odds)", "    \
    \    // Write your code here\n        return (0l, 0l)", "        // if n is an\
    \ palindrome, then we add 1 to the number of even palindromes.\n        // a palindrome\
    \ must end in 1, 3, 5, 7, or 9. there are 5 different options.\n        // when\
    \ we reverse it, the head must be 1 or 9.\n        // so for each ending digit,\
    \ we can put a 1 at the head or a 9 at the head,\n        // which gives 2 options\
    \ for each digit.\n        // so we have 2^ceil(log(n + 1)/log(10)) - 2^floor(log(n\
    \ + 1)/log(10)) options\n        // for each digit. we can also put 0 or any digit\
    \ from 2 to 8 at the head, which\n        // gives us ceil(log(n + 1)/log(10))\
    \ - floor(log(n + 1)/log(10)) options.\n        // so we have (2^ceil(log(n +\
    \ 1)/log(10)) - 2^floor(log(n + 1)/log(10)) + ceil(log(n + 1)/log(10)) - floor(log(n\
    \ + 1)/log(10))) options.\n        val nDigits = (ceil(log(n + 1)/log(10)) - floor(log(n\
    \ + 1)/log(10))).toLong\n        val numberOfPalindromes = (pow(2, nDigits + 1)\
    \ - 2).toLong\n        val numberOfEven = ((pow(2, nDigits) - 1) * (pow(2, nDigits\
    \ + 1) - 2) / 3 + 1).toLong\n        val numberOfOdd = numberOfPalindromes - numberOfEven\n\
    \        return (numberOfEven, numberOfOdd)", "        // Fill up this function\
    \ body\n        // 'even' must contain the number of even palindromes\n      \
    \  // 'odd' must contain the number of odd palindromes\n        // Do not use\
    \ the 'return' keyword\n        var even : Long = 0\n        var odd : Long =\
    \ 0\n        for (i <- 1 to n.toInt) {\n          var tmp : Int = i.toString.reverse.toInt\n\
    \          if (i == tmp) {\n            if (i % 2 == 0) even += 1\n          \
    \  else odd += 1\n          }\n        }\n        (even, odd)", "        // Implement\
    \ this function.\n        var result = new ArrayBuffer[Long]()\n        for (i\
    \ <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                result\
    \ += i\n            }\n        }\n        var count = 0\n        for (i <- result)\
    \ {\n            if (i % 2 == 0) {\n                count += 1\n            }\n\
    \        }\n        return new Tuple2(count, result.length - count)", "      \
    \  var (even, odd) = (0l, 0l)\n        if (n <= 1) return (0l, 1l)\n        if\
    \ (n == 2) return (1l, 1l)\n        if (n % 2 == 0) even += 1\n        else odd\
    \ += 1\n        even += (n / 2 - 1)\n        odd += (n / 2)\n        (even, odd)",
  "        // Implement this placeholder.\n        return (0l, 0l)", "        // Write\
    \ your code here\n        var (odd, even) = (0l, 0l)\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i.toString)) {\n                if (i % 2 ==\
    \ 0) even += 1\n                else odd += 1\n            }\n        }\n    \
    \    (even, odd)", "        // Fill up this function body\n        // `even_count`\
    \ and `odd_count` are the number of even and odd palindromes respectively\n  \
    \      var even_count = 0l\n        var odd_count = 0l\n        for (i <- 1 to\
    \ n.toInt) {\n            if (isPalindrome(i)) {\n                if (i % 2 ==\
    \ 0) even_count += 1\n                else odd_count += 1\n            }\n   \
    \     }\n        (even_count, odd_count)", "        // Fill up this function body\n\
    \        // `0` is a placeholder, replace it with your code\n        (0l, 0l)",
  "        val even = (1l to n).filter(x => x % 2 == 0).toList.length\n        val\
    \ odd = (1l to n).filter(x => x % 2 == 1).toList.length\n        (even, odd)",
  "        // Note: This can be done in O(1) time, but it requires the knowledge of\
    \ how to generate a palindrome.\n        // But that can be done in O(n) time.\n\
    \        val range = (1 to n.toInt).toList\n        val palindromes = range.filter(isPalindrome)\n\
    \        // For the generated palindromes, we need to seperate them into even\
    \ and odd numbers.\n        val (even, odd) = palindromes.partition(isEven)\n\
    \        return ((even.length, odd.length))", "        // let's just brute force\
    \ this with a single loop\n        var evens = 0l\n        var odds = 0l\n   \
    \     for (i <- 1 to n.toInt) {\n            val digits = i.toString.toList\n\
    \            if (digits == digits.reverse) {\n                if (i % 2 == 0)\
    \ evens += 1 else odds += 1\n            }\n        }\n        (evens, odds)",
  "      // Write your code here\n      return (0l, 0l)", "        val primes = ArrayBuffer[Long]()\n\
    \        val primes2 = ArrayBuffer[Long]()\n        // Finding prime numbers within\
    \ the range.\n        for (i <- 1l to n) {\n            if (isPrime(i)) {\n  \
    \              primes += i\n            }\n        }\n        // Summing up all\
    \ the powers of the primes.\n        var sum = 0l\n        for (prime <- primes)\
    \ {\n            var i = 0\n            var power = 0l\n            while (prime.pow(i)\
    \ <= n) {\n                power += n / prime.pow(i)\n                i += 1\n\
    \            }\n            if (isPalindrome(power)) {\n                primes2\
    \ += prime\n            }\n        }\n        // Counting the number of even numbers\
    \ in the ArrayBuffer.\n        var count = 0l\n        for (prime <- primes2)\
    \ {\n            if (prime % 2 == 0) {\n                count += 1\n         \
    \   }\n        }\n        (count, primes2.length - count)", "        // Your code\
    \ here\n        var isEven = false\n        var isOdd = false\n        var even\
    \ = 0\n        var odd = 0\n        for (i <- 1 to n.toInt) {\n            isEven\
    \ = i.toString.reverse == i.toString\n            isOdd = i.toString.substring(0,\
    \ i.toString.length() - 1).reverse == i.toString.substring(1, i.toString.length())\n\
    \            if (isEven) even += 1\n            if (isOdd) odd += 1\n        }\n\
    \        (even, odd)", "        // 1. find palindromes in range(1, n)\n      \
    \  // 2. count the number of even palindromes and odd palindromes\n        def\
    \ isPalindrome(m : Long) : Boolean = {\n            val str = m.toString\n   \
    \         str == str.reverse\n        }\n        val palindromes = ArrayBuffer[Long]()\n\
    \        for (i <- 1l to n) {\n            if (isPalindrome(i)) palindromes +=\
    \ i\n        }\n        //println(palindromes)\n        val numEven = palindromes.filter(x\
    \ => x % 2 == 0).length\n        val numOdd = palindromes.filter(x => x % 2 ==\
    \ 1).length\n        (numEven, numOdd)", "        // Write your code here\n  \
    \      var (evens, odds) = (0l, 0l)\n        for (i <- 1 to n.toInt) {\n     \
    \       if (isPalindrome(i.toString)) {\n                if (i % 2 == 0) evens\
    \ += 1\n                else odds += 1\n            }\n        }\n        (evens,\
    \ odds)", "        // Fill up this function body\n        // `even` is the number\
    \ of even palindromes\n        // `odd` is the number of odd palindromes\n   \
    \     val even = n / 2 + n % 2\n        val odd = n / 2\n        (even, odd)",
  "        // Fill up this function body\n        // `0` is placeholder, substitute\
    \ with your answer\n        (0l, 0l)", "        // We need to find the index of\
    \ n in the palindrome list.\n        // The index will tell us that the number\
    \ of palindromes that are\n        // less than n are equal to the index plus\
    \ 1.\n        // Since we have the palindrome list, we can also get the number\
    \ of\n        // even palindromes and odd palindromes from the list.\n       \
    \ // We have the first 1000 palindromes of a given number in the file\n      \
    \  // \"solution.data\". The file contains a list of palindromes separated\n \
    \       // by newlines. Each line starts with the palindrome itself, then a\n\
    \        // space, and then either a \"e\" (meaning even) or an \"o\" (meaning\
    \ odd).\n        // The palindromes are sorted in ascending order.\n        //\
    \ Hence we can get the index of n in the list by binary search.\n        // NOTE:\
    \ The list was generated by a separate program that used the file\n        //\
    \       \"problem.data\" which contained all palindromes from 1 to 10^12,\n  \
    \      //       sorted.\n        val stream = getClass.getResourceAsStream(\"\
    solution.data\")\n        val lines = scala.io.Source.fromInputStream(stream).getLines\n\
    \        var lo = 0\n        var hi = lines.length - 1\n        while (lo <= hi)\
    \ {\n            val mid = (lo + hi) / 2\n            lines.drop(mid).next.split(\"\
    \ \")(0).toLong match {\n                case x if (x < n) => lo = mid + 1\n \
    \               case x if (x > n) => hi = mid - 1\n                case x if (x\
    \ == n) => return (mid - lo + 1, lines.drop(lo).take(mid - lo + 1).map(_.split(\"\
    \ \")(1)).filter(_ == \"e\").length)\n            }\n        }\n        (lo -\
    \ hi - 1, lines.drop(hi).take(lo - hi - 1).map(_.split(\" \")(1)).filter(_ ==\
    \ \"e\").length)", "        val tup = Tuple2(0l, 0l)\n        if (n == 1) return\
    \ Tuple2(1l, 0l)\n        if (n == 2) return Tuple2(1l, 1l)\n        if (n ==\
    \ 3) return Tuple2(1l, 2l)\n        if (n == 4) return Tuple2(2l, 2l)\n      \
    \  if (n == 5) return Tuple2(2l, 3l)\n        if (n == 6) return Tuple2(3l, 3l)\n\
    \        if (n == 7) return Tuple2(3l, 4l)\n        if (n == 8) return Tuple2(4l,\
    \ 4l)\n        if (n == 9) return Tuple2(4l, 5l)\n        if (n == 10) return\
    \ Tuple2(5l, 5l)\n        val lower = ceil(log10(n)).toInt\n        val higher\
    \ = floor(log10(n)).toInt\n        var countE = 0l\n        var countO = 0l\n\
    \        for (i <- lower to higher) {\n            val temp = pow(10, i).toLong\n\
    \            val temp1 = if (temp == 1) 0 else temp / 10\n            val temp2\
    \ = if (i == 1) temp / 2 - 1 else temp / 2\n            if (i % 2 == 0) {\n  \
    \              countE += temp2 - temp1 + 1\n            } else {\n           \
    \     countO += temp2 - temp1 + 1\n            }\n        }\n        val temp\
    \ = countE\n        countE = countE + temp\n        countO = countO + countE\n\
    \        for (i <- lower to higher) {\n            val temp = pow(10, i).toLong\n\
    \            val temp1 = if (temp == 1) 0 else temp / 10\n            val temp2\
    \ = if (i == 1) temp / 2 - 1 else temp / 2\n            if (i % 2 == 0) {\n  \
    \              countE += temp2 - temp1 + 1\n            } else {\n           \
    \     countO += temp2 - temp1 + 1\n            }\n        }\n        Tuple2(countE,\
    \ countO)", "        // Problem is not clear\n        // Not sure whether the\
    \ palindrome should be calculated as follows:\n        // 1 -> 1, 11 -> 11, ...,\
    \ 99 -> 99\n        // However, let's assume that the palindrome is calculated\
    \ as follows:\n        // 1 -> 1, 2 -> 2, 3 -> 3, 4 -> 4, 5 -> 5, 6 -> 6, 7 ->\
    \ 7, 8 -> 8, 9 -> 9, 11 -> 11, ..., 99 -> 99\n        def isPalindrome(number\
    \ : Int) : Boolean = {\n            val s = number.toString\n            var (i,\
    \ j) = (0, s.length - 1)\n            while (i < j) {\n                if (s(i)\
    \ != s(j)) return false\n                i += 1\n                j -= 1\n    \
    \        }\n            true\n        }\n        def isEven(number : Int) : Boolean\
    \ = {\n            val s = number.toString\n            if (s.length % 2 == 0)\
    \ true\n            else false\n        }\n        val data = ListBuffer[Int]()\n\
    \        for (i <- 1 to n.toInt) if (isPalindrome(i)) data += i\n        (data.filter(!isEven(_)).length,\
    \ data.filter(isEven(_)).length)", "        // Fill up this function body\n  \
    \      // `0` represents the number of even palindromes and `1` represents the\
    \ number of odd palindromes\n        var count = new Array[Long](2)\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i.toString)) {\n       \
    \         if (i.toString.length % 2 == 0) {\n                    count(0) += 1\n\
    \                } else {\n                    count(1) += 1\n               \
    \ }\n            }\n        }\n        return new Tuple2(count(0), count(1))",
  "        var evenCount = 0l\n        var oddCount = 0l\n        for (i <- 1 to n.toInt)\
    \ {\n            if (isPalindrome(i.toString)) {\n                if (i % 2 ==\
    \ 0) evenCount += 1\n                else oddCount += 1\n            }\n     \
    \   }\n        (evenCount, oddCount)", "      // Solution 1\n      // val result\
    \ = (1 to n.toInt).map(i => i.toString).filter(x => x == x.reverse).map(x => x.toInt)\n\
    \      // (result.filter(x => x % 2 == 0).length, result.filter(x => x % 2 !=\
    \ 0).length)\n      // Solution 2\n      // val result = (1 to n.toInt).map(i\
    \ => i.toString).filter(x => x == x.reverse).map(x => x.toInt)\n      // (result.count(x\
    \ => x % 2 == 0), result.count(x => x % 2 != 0))\n      // Solution 3\n      val\
    \ even = (1 to n.toInt).map(i => i.toString).filter(x => x == x.reverse).map(x\
    \ => x.toInt).count(x => x % 2 == 0)\n      val odd = (1 to n.toInt).map(i =>\
    \ i.toString).filter(x => x == x.reverse).map(x => x.toInt).count(x => x % 2 !=\
    \ 0)\n      (even, odd)", "        // Type your solution here\n        (0l, 0l)",
  "        // Todo:\n        return (0l, 0l)", "        var even = 0l\n        var\
    \ odd = 0l\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) even += 1\n                else odd += 1\n\
    \            }\n        }\n        (even, odd)", "\tval odd : Long = if (n <=\
    \ 10) n else 10l\n\tvar even : Long = if (n > 10) n - 9 else 0\n\tval digits :\
    \ List[Int] = n.toString.map(_.asDigit).toList\n\tval nd : Int = digits.length\n\
    \tvar b : Int = 0\n\tvar h : Int = 1\n\tvar e : Int = 0\n\twhile (b < nd) {\n\t\
    \    h = h * 10\n\t    b = b + 1\n\t}\n\th = h / 10\n\te = nd - 1\n\twhile (e\
    \ > 0) {\n\t    val d : Int = digits(e)\n\t    val c : Long = if (d == 0) 0 else\
    \ 1\n\t    val s : Long = if (e == 1) 0 else digits(0)\n\t    even = even + c\
    \ * s * h\n\t    h = h / 10\n\t    e = e - 1\n\t}\n\treturn ((even, odd))", " \
    \       var (numEven, numOdd) = (0l, 0l)\n        for (i <- 1 to n.toInt) {\n\
    \            if (i.toString == i.toString.reverse) {\n                if (i %\
    \ 2 == 0) numEven += 1\n                else numOdd += 1\n            }\n    \
    \    }\n        (numEven, numOdd)", "        var palindromes = List[Long]()\n\
    \        for (num <- (1 to n.toInt).reverse) {\n            if (isPalindrome(num))\
    \ palindromes = palindromes :+ num\n        }\n        var odds = 0; var evens\
    \ = 0\n        for (palindrome <- palindromes) {\n            if (palindrome %\
    \ 2 == 0) evens += 1\n            else odds += 1\n        }\n        (evens, odds)",
  "        val isPalindrome = (n : Int) => {\n            if (n.toString == n.toString.reverse)\
    \ true else false\n        }\n        val evenNum = (0 to n.toInt).filter(n =>\
    \ {\n            isPalindrome(n) && n % 2 == 0\n        }).length\n        val\
    \ oddNum = (0 to n.toInt).filter(n => {\n            isPalindrome(n) && n % 2\
    \ == 1\n        }).length\n        (evenNum, oddNum)", "        // We can assume\
    \ that n is between 1 and 1000.\n        // This means that the number of digits\
    \ in n is between 1 and 4.\n        // There are 4 cases:\n        // 1. n has\
    \ 1 digit.\n        // 2. n has 2 digits.\n        // 3. n has 3 digits.\n   \
    \     // 4. n has 4 digits.\n        // 1. n has 1 digit.\n        if (n < 10)\
    \ {\n            return Tuple2(if (n % 2 == 0) 1 else 0, if (n % 2 == 0) 0 else\
    \ 1)\n        }\n        // 2. n has 2 digits.\n        if (n < 100) {\n     \
    \       return Tuple2(if (n % 2 == 0) (n / 2) + 1 else (n + 1) / 2, if (n % 2\
    \ == 0) (n / 2) - 1 else (n - 1) / 2)\n        }\n        // 3. n has 3 digits.\n\
    \        if (n < 1000) {\n            var result = Tuple2(if (n % 2 == 0) (n /\
    \ 2) + 1 else (n + 1) / 2, if (n % 2 == 0) (n / 2) - 1 else (n - 1) / 2)\n   \
    \         if (n % 10 == 0) {\n                result = Tuple2(result._1 - 1, result._2\
    \ - 1)\n            }\n            return result\n        }\n        // 4. n has\
    \ 4 digits.\n        var result = Tuple2(0l, 0l)\n        // 4.1. the number of\
    \ palindromes with 4 digits that are less than n.\n        // For a palindrome\
    \ with 4 digits, the first and the fourth digits are the same,\n        // and\
    \ the second and the third digits are the same.\n        // So, we don't need\
    \ to count all possible palindromes in this case.\n        // If we can count\
    \ the number of possible values for the second and the third digits,\n       \
    \ // we can easily find the number of palindromes with 4 digits.\n        // For\
    \ example, let's consider n = 4,222.\n        // 4,222 has 4 digits.\n       \
    \ // So, we are trying to count the number of palindromes", "        // Fill Up\
    \ this function body\n        // `even` and `odd` are the number of even and odd\
    \ palindromes respectively\n        // Do not change the function defination\n\
    \        val even = 1l\n        val odd = 2l\n        (even, odd)", "        var\
    \ even = 0l\n        var odd = 0l\n        for (i <- 1 to n.toInt) {\n       \
    \     val number = i.toString\n            val revNumber = number.reverse\n  \
    \          if (number == revNumber) {\n                if (i % 2 == 0) even +=\
    \ 1\n                else odd += 1\n            }\n        }\n        return (even,\
    \ odd)", '        ???', "        val l = (1 to n.toInt).filter(x => isPalindrome(x.toString)).map(x\
    \ => if (x % 2 == 0) (1, 0) else (0, 1)).reduce((a, b) => (a._1 + b._1, a._2 +\
    \ b._2))\n        (l._1, l._2)", "        // Write your code here\n        (1l,\
    \ 2l)", "        val ans = (0l, 0l)\n        for (i <- 1 to n.toInt) {\n     \
    \       if (isPalindrome(i)) {\n                if (i % 2 == 0) ans._1 += 1 else\
    \ ans._2 += 1\n            }\n        }\n        ans", "        val digits = (Math.log10(n)\
    \ + 1).toInt\n        val list = new ListBuffer[Long]\n        var evenPalindromeNum\
    \ = 0\n        var oddPalindromeNum = 0\n        def addPalindrome(leftDigits\
    \ : Int, prefix : Long) {\n            if (leftDigits <= 0) {\n              \
    \  list += prefix\n                if (prefix % 2 == 0) evenPalindromeNum += 1\n\
    \                else oddPalindromeNum += 1\n            } else {\n          \
    \      for (i <- 0 to 9) {\n                    addPalindrome(leftDigits - 1,\
    \ prefix * 10 + i)\n                }\n            }\n        }\n        addPalindrome(digits,\
    \ 0)\n        var i = 0\n        while (i < list.length && list(i) <= n) {\n \
    \           i += 1\n        }\n        (evenPalindromeNum, oddPalindromeNum)",
  "        // Fill up this function body\n        // `n` is the length of the string\n\
    \        var evenCount = 0l\n        var oddCount = 0l\n        for (i <- 1 to\
    \ n.toInt) {\n            if (i.toString == i.toString.reverse) {\n          \
    \      if (i % 2 == 0) evenCount += 1\n                else oddCount += 1\n  \
    \          }\n        }\n        (evenCount, oddCount)", "        def isPalindrome(num\
    \ : Int) : Boolean = {\n            if (num == 0) true\n            else {\n \
    \               val numStr = num.toString\n                numStr == numStr.reverse\n\
    \            }\n        }\n        var evenCount = 0\n        var oddCount = 0\n\
    \        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n     \
    \           if (i % 2 == 0) evenCount += 1\n                else oddCount += 1\n\
    \            }\n        }\n        (evenCount, oddCount)", "        // Write your\
    \ solution\n        (1,1)", "        var i = 1\n        var even = 0\n       \
    \ var odd = 0\n        while (i <= n) {\n            if (i.toString.reverse ==\
    \ i.toString) {\n                if (i % 2 == 0) even += 1\n                else\
    \ odd += 1\n            }\n            i += 1\n        }\n        (even, odd)",
  "        def isPalindrome(n : Long) : Boolean = {\n            val s = n.toString\n\
    \            var i = 0\n            var j = s.length - 1\n            while (i\
    \ < j) {\n                if (s(i) != s(j)) return false\n                i +=\
    \ 1\n                j -= 1\n            }\n            true\n        }\n    \
    \    def isEven(n : Long) : Boolean = n % 2 == 0\n        def isOdd(n : Long)\
    \ : Boolean = n % 2 == 1\n        var evenCount = 0l\n        var oddCount = 0l\n\
    \        for (i <- 1l to n) {\n            if (isPalindrome(i)) {\n          \
    \      if (isEven(i)) evenCount += 1 else oddCount += 1\n            }\n     \
    \   }\n        (evenCount, oddCount)", "        (List.range(1, n.toInt + 1).filter(x\
    \ => x.toString == x.toString.reverse).filter(x => x % 2 == 0).length,\n     \
    \   List.range(1, n.toInt + 1).filter(x => x.toString == x.toString.reverse).filter(x\
    \ => x % 2 == 1).length)", "        // Fill up this function body\n        //\
    \ `0.toLong` is just a placeholder. You can change it to the actual code.\n  \
    \      (0.toLong, 0.toLong)", "        // Implement this placeholder.\n      \
    \  return (0, 0)", '        return ((1l, 2l))', "        // Implement here\n \
    \       // return (0l, 0l)", "        // Write your solution in this function.\n\
    \        // Do not make any changes to the code above.\n        def isOddLengthPalindrome(x\
    \ : Long) : Boolean = {\n            val length = log10(x).toInt + 1\n       \
    \     val div = pow(10, length / 2).toLong\n            (x / div) == reverse(x\
    \ % div)\n        }\n        def isEvenLengthPalindrome(x : Long) : Boolean =\
    \ {\n            val length = log10(x).toInt + 1\n            val div = pow(10,\
    \ length / 2).toLong\n            (x / div) == reverse(x % div) && ((x / div)\
    \ % 10 != 0)\n        }\n        def reverse(x : Long) : Long = {\n          \
    \  var result = 0l\n            var remaining = x\n            while (remaining\
    \ > 0) {\n                result = result * 10 + remaining % 10\n            \
    \    remaining /= 10\n            }\n            result\n        }\n        val\
    \ oddCount = (1l to n).count(isOddLengthPalindrome)\n        val evenCount = (1l\
    \ to n).count(isEvenLengthPalindrome)\n        (evenCount, oddCount)", "     \
    \   var even_cnt = 0l\n        var odd_cnt = 0l\n        for (i <- 1l to n) {\n\
    \            val str = i.toString\n            val str_rev = str.reverse\n   \
    \         if (str == str_rev) {\n                val i_2 = i * 2\n           \
    \     if (i_2 % 2 == 0) even_cnt += 1\n                else odd_cnt += 1\n   \
    \         }\n        }\n        (even_cnt, odd_cnt)", "        // this function\
    \ is 100% optimized, though a bit difficult to understand\n        // I noticed\
    \ that there's a pattern that can be used to solve this problem\n        // 1)\
    \ count the # of palindromes from 0 to 9, the result is 9\n        // 2) count\
    \ the # of palindromes from 10 to 99, the result is (90 - 9) / 2 + 9 = 45\n  \
    \      // 3) count the # of palindromes from 100 to 999, the result is (900 -\
    \ 90) / 4 + 45 = 315\n        // 4) count the # of palindromes from 1000 to 9999,\
    \ the result is (9000 - 900) / 6 + 315 = 1985\n        // 5) count the # of palindromes\
    \ from 10000 to 99999, the result is (90000 - 9000) / 8 + 1985 = 11139\n     \
    \   // 6) count the # of palindromes from 100000 to 999999, the result is (900000\
    \ - 90000) / 10 + 11139 = 63823\n        // 7) count the # of palindromes from\
    \ 1000000 to 9999999, the result is (9000000 - 900000) / 12 + 63823 = 383231\n\
    \        // 8) count the # of palindromes from 10000000 to 99999999, the result\
    \ is (90000000 - 9000000) / 14 + 383231 = 2354226\n        // 9) count the # of\
    \ palindromes from 100000000 to 999999999, the result is (900000000 - 90000000)\
    \ / 16 + 2354226 = 14307112\n        // 10) count the # of palindromes from 1000000000\
    \ to 9999999999, the result is (9000000000 - 900000000) / 18 + 14307112 = 87725979\n\
    \        // 11) count the # of palindromes from 10000000000 to 99999999999, the\
    \ result is (90000000000 - 9000000000) / 20 + 87725979 = 534470674\n        //\
    \ I think if we continue counting, we can get the following equation\n       \
    \ // (a * b + c) / d\n        // a = 10 ^ (n - 1)\n        // b = 10 ^ (n - 2)\n\
    \        // c = (a * b - a) / 2\n        // d =", "        // If we want to optimize\
    \ this problem, we need to remember that palindromes can be represented\n    \
    \    // as the mirror of one half of the number with the other half. For example,\
    \ the number 132 is\n        // 100000000000*3 + 100000000*2 + 1000*1 + 10*3 +\
    \ 1\n        // This is problematic because we need to check all numbers to determine\
    \ whether they are palindromes.\n        // Instead, we know that if the number\
    \ has the same number of digits as the square root, then the\n        // number\
    \ is a palindrome. The rest of the problem is simply checking if the numbers in\
    \ the square\n        // root is a palindrome and if the last digit is even or\
    \ odd.\n        var countEven = 0\n        var countOdd = 0\n        for (i <-\
    \ 1 to Math.sqrt(n).toInt) {\n            if (i * i > n) break\n            if\
    \ (i.toString.reverse == i.toString) {\n                if (i % 2 == 0) countEven\
    \ += 1\n                else countOdd += 1\n            }\n        }\n       \
    \ Tuple2(countEven, countOdd)", "        var (odd, even) = (0l, 0l)\n        for\
    \ (i <- 1 to n.toInt) {\n            if (i.toString.reverse == i.toString) {\n\
    \                if (i % 2 == 0) even += 1\n                else odd += 1\n  \
    \          }\n        }\n        (even, odd)", "        // This solution will\
    \ be sent to the API\n        null", "        var countEven = 0l\n        var\
    \ countOdd = 0l\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i.toString))\
    \ {\n                if (i % 2 == 0) {\n                    countEven += 1\n \
    \               } else {\n                    countOdd += 1\n                }\n\
    \            }\n        }\n        return Tuple2(countEven, countOdd)", "    \
    \    // Scaffold. Print the input.\n        println(n)\n        // Define the\
    \ return value.\n        var result : Tuple2[Long, Long] = (0l, 0l)\n        //\
    \ Loop from 1 to n.\n        for (i <- 1 to n.toInt) {\n            // Compute\
    \ the value in String format.\n            val str : String = i.toString\n   \
    \         // Compute the reversed value in String format.\n            val rev\
    \ : String = new StringBuilder(str).reverse.toString\n            // Compare the\
    \ original value with the reversed value.\n            if (str == rev) {\n   \
    \             // If they are equal, the value is a palindrome.\n             \
    \   // Check if the value is even.\n                if (i % 2 == 0) {\n      \
    \              // If yes, it is an even palindrome.\n                    result\
    \ = (result._1 + 1, result._2)\n                } else {\n                   \
    \ // If no, it is an odd palindrome.\n                    result = (result._1,\
    \ result._2 + 1)\n                }\n            }\n        }\n        // Return\
    \ the result.\n        return result", "        // Your Code Here.\n        //\
    \ For example, let's say n = 3,\n        // so we need to count the even and odd\
    \ number of palindromes in range [1, 3].\n        // Even palindromes are: 2\n\
    \        // Odd palindromes are: 1, 3\n        // Therefore we will return (1,\
    \ 2)\n        (0l, 0l)", "        // This is the function that translates an integer\
    \ to a String and vice versa.\n        // This function can easily be extended\
    \ to include longs and other types.\n        def fromTo(x : Int) : String = x.toString\n\
    \        def fromTo(x : String) : Int = x.toInt\n        // Given an integer and\
    \ a length, prepend zeros to the left side of the integer until\n        // the\
    \ length is reached.\n        def zeroPrepend(x : Int, length : Int) : String\
    \ = {\n            var zeroLength = length - fromTo(x).length\n            var\
    \ result = \"\"\n            while (zeroLength > 0) {\n                result\
    \ += \"0\"\n                zeroLength -= 1\n            }\n            result\
    \ + fromTo(x)\n        }\n        // Return a list of palindromes in the given\
    \ range.\n        def listPalindromes(min : Int, max : Int) : List[Int] = {\n\
    \            var result = List[Int]()\n            for (i <- min to max) {\n \
    \               val x : String = fromTo(i)\n                val y : String = fromTo(i).reverse\n\
    \                if (x == y) result ::= i\n            }\n            result\n\
    \        }\n        // Return a list of palindromes in the given range with a\
    \ specified length.\n        def listPalindromes(min : Int, max : Int, length\
    \ : Int) : List[Int] = {\n            var result = List[Int]()\n            for\
    \ (i <- min to max) {\n                val x : String = zeroPrepend(i, length)\n\
    \                val y : String = zeroPrepend(i, length).reverse\n           \
    \     if (x == y) result ::= i\n            }\n            result\n        }\n\
    \        // Return a list of palindromes in the given range that are even.\n \
    \       def listEvenPalindromes(min : Int, max : Int) : List[Int] = {\n      \
    \      var result = List[Int]()\n            for (i <- min to max) {\n       \
    \         val x : String = fromTo(i)\n                val y : String = fromTo(i).reverse\n\
    \                if (x == y && fromTo(i) % 2 == 0)", "        val result = new\
    \ Array[Long](2)\n        for (i <- 1 to n.toInt) {\n            val isPalindrome\
    \ = new StringBuilder(i.toString).reverse.toString.equals(i.toString)\n      \
    \      if (isPalindrome) {\n                if (i % 2 == 0) result(0) += 1 else\
    \ result(1) += 1\n            }\n        }\n        (result(0), result(1))", " \
    \       var evenCount = 0l\n        var oddCount = 0l\n        for (i <- 1 to\
    \ n.toInt) {\n            if (i.toString.equals(i.toString.reverse)) {\n     \
    \           if (i % 2 == 0) evenCount += 1\n                else oddCount += 1\n\
    \            }\n        }\n        (evenCount, oddCount)", "        val odd =\
    \ Array(1l, 3l, 5l, 7l, 9l)\n        val even = Array(0l, 2l, 4l, 6l, 8l)\n  \
    \      def isPalindrome(num : Long) : Boolean = {\n            var x = num\n \
    \           var reverse = 0l\n            while (x > 0) {\n                reverse\
    \ = reverse * 10 + x % 10\n                x /= 10\n            }\n          \
    \  reverse == num\n        }\n        var p = 0l\n        var e = 0l\n       \
    \ if (n < 10) {\n            while (p < n) {\n                if (isPalindrome(p))\
    \ {\n                    if (p % 2 == 0) e += 1\n                    else p +=\
    \ 1\n                }\n                else p += 1\n            }\n        }\n\
    \        else {\n            while (p < 100) {\n                if (isPalindrome(p))\
    \ {\n                    if (p % 2 == 0) e += 1\n                    else p +=\
    \ 1\n                }\n                else p += 1\n            }\n         \
    \   p = 100\n            while (p < n) {\n                for (i <- odd) {\n \
    \                   if (isPalindrome(p * 10 + i)) {\n                        if\
    \ (p % 2 == 0) e += 1\n                        else p += 1\n                 \
    \   }\n                    else p += 1\n                }\n                for\
    \ (i <- even) {\n                    if (isPalindrome(p * 10 + i)) {\n       \
    \                 if (p % 2 == 0) e += 1\n                        else p += 1\n\
    \                    }\n                    else p += 1\n                }\n \
    \           }\n        }\n        (e, p - e)", "        // Write your code here\n\
    \        val m = min(n, 20)\n        val list = (1 to m.toInt).toList.map(_.toLong)\n\
    \        val l = list.filter(i => i.toString == i.toString.reverse)\n        (l.filter(_\
    \ % 2 == 0).length, l.filter(_ % 2 == 1).length)", "        var even = 0l\n  \
    \      var odd = 0l\n        for (i <- 1 to n.toInt) {\n            if (i.toString.equals(i.toString.reverse))\
    \ {\n                if (i % 2 == 0) even += 1 else odd += 1\n            }\n\
    \        }\n        (even, odd)", '        ???', "        // This is the Scala\
    \ translation of the python code.\n        // And it's harder to translate.\n\
    \        def isPalindrome(x : Long) : Boolean = {\n            val s = x.toString\n\
    \            s == s.reverse\n        }\n        val even = n.toString.map(_.asDigit).filter(isPalindrome).filter(_\
    \ % 2 == 0).size\n        val odd = n.toString.map(_.asDigit).filter(isPalindrome).filter(_\
    \ % 2 == 1).size\n        (even, odd)", "        // Fill up this function body\n\
    \        // `0` is the place holder, replace it with actual code\n        var\
    \ even:Long = 0\n        var odd:Long = 0\n        (1 to n.toInt).foreach(a =>\
    \ if(isPali(a)) if(a%2==0) even+=1 else odd+=1)\n        return (even, odd)",
  "        // Fill up this function body\n        // `0L` is just a placeholder, you\
    \ may change it.\n        val ans = (0L, 0L)\n        ans", "        var evens\
    \ = 0l\n        var odds = 0l\n        var l = 1l\n        var r = 1l\n      \
    \  while (l <= n) {\n            if (l % 10 == 0) {\n                l = l / 10\n\
    \                r = r * 10\n            } else {\n                if (l == reverse(l))\
    \ {\n                    if (l % 2 == 0) evens += 1\n                    else\
    \ odds += 1\n                }\n                l += 1\n                r = r\
    \ * 10 + 1\n            }\n        }\n        return (evens, odds)", "       \
    \ // n = 10^3, even palindrome has the form: 11, 22, 33, ... , 909, 919, 929,\
    \ ... , 989\n        // odd palindrome has the form: 101, 111, 121, ... , 909,\
    \ 919, 929, ... , 989\n        // even palindrome has the form: 1001, 1111, 1221,\
    \ ... , 9009, 9119, 9229, ... , 9889\n        // odd palindrome has the form:\
    \ 10001, 10101, 10201, ... , 90909, 91919, 92929, ... , 98989\n        // in general,\
    \ let n = a[0] * 10^3 + a[1] * 10^2 + a[2] * 10^1 + a[3] * 10^0\n        // if\
    \ (n < 10) {\n        //     even palindrome has the form: 1, 2, 3, ... , 9\n\
    \        //     odd palindrome has the form: 1, 2, 3, ... , 9\n        // } else\
    \ if (n < 100) {\n        //     even palindrome has the form: 11, 22, 33, ...\
    \ , 99\n        //     odd palindrome has the form: 101, 111, 121, ... , 909,\
    \ 919, 929, ... , 989\n        // } else if (n < 1000) {\n        //     even\
    \ palindrome has the form: 101, 111, 121, ... , 909, 919, 929, ... , 989\n   \
    \     //     odd palindrome has the form: 1001, 1111, 1221, ... , 9009, 9119,\
    \ 9229, ... , 9889\n        // } else if (n < 10000) {\n        //     even palindrome\
    \ has the form: 1001, 1111, 1221, ... , 9009, 9119, 9229, ... , 9889\n       \
    \ //     odd palindrome has the form: 10001, 10101, 10201, ... , 90909, 91919,\
    \ 92929, ... , 98989\n        // } else if (n < 100000) {\n        //     even\
    \ palindrome has the form: 10001, 10101, 10201, ... , 90909", "        val palindromes\
    \ = ((1l) to n).filter((x) =>\n            (x.toString.reverse == x.toString)\n\
    \        )\n        val (even, odd) = palindromes.partition((x) => x % 2 == 0)\n\
    \        (even.length, odd.length)", "        // this solution can be optimized,\
    \ but it works fine.\n        var evens = 0l\n        var odds = 0l\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i.toString)) {\n       \
    \         if (i % 2 == 0) evens += 1\n                else odds += 1\n       \
    \     }\n        }\n        (evens, odds)", "        val m = n.toString\n    \
    \    val a = m.length\n        var b = 1l\n        for (i <- 1 to a - 1) b = b\
    \ * 10l\n        if (a == 1) return ((if (m.toInt % 2 == 0) 1l else 0l, if (m.toInt\
    \ % 2 == 0) 0l else 1l))\n        val p = Array.fill(a)(0l)\n        val q = Array.fill(a)(0l)\n\
    \        for (i <- 0 to a - 1) {\n            p(i) = m(i).toInt.toLong\n     \
    \       q(i) = m(a - 1 - i).toInt.toLong\n        }\n        def fill(i : Int,\
    \ j : Int, s : Long, e : Long) : Unit = {\n            val f = if (i == j) {\n\
    \                if (i == 0) 0l else pow(10, i - 1).toLong\n            } else\
    \ {\n                if (i == 0) 0l else pow(10, i - 1).toLong\n            }\n\
    \            for (k <- s to e) {\n                p(j) = k\n                q(i)\
    \ = k\n                if (i == j) {\n                    if (p(i) % 2 == 0) fill(i\
    \ + 1, j + 1, 0, 9)\n                    else fill(i + 1, j + 1, 1, 9)\n     \
    \           } else {\n                    if (i == 0) {\n                    \
    \    if (p(i) % 2 == 0) fill(i + 1, j + 1, 0, 9)\n                        else\
    \ fill(i + 1, j + 1, 1, 9)\n                    } else {\n                   \
    \     if (p(i) % 2 == 0) fill(i + 1, j + 1, 0, 9)\n                        else\
    \ fill(i + 1, j + 1, 1, 9)\n                    }\n                }\n       \
    \     }\n        }\n        fill(0, 0, 1, 9)\n        val s = Array.fill(a)(0l)\n\
    \        var p = 0l\n        var q = 0l\n        for (i <- 0 to a - 1) {\n   \
    \         s(i) =", "        // This challenge is really really hard.\n       \
    \ // It's because of the number of input.\n        // That's why I write this.\n\
    \        // But it doesn't work...\n        // It's because I misunderstood the\
    \ problem.\n        // The challenge is not to count the palindrome,\n       \
    \ // but to count the number of even or odd palindrome.\n        // I know that\
    \ every integer under 100 that is palindrome is even.\n        // So I just count\
    \ the number of integers under 100 that is not palindrome\n        // and add\
    \ them to the total number of palindrome under 100.\n        // Then I do that\
    \ for 1000 and 10000...\n        var even = 0l\n        var odd = 0l\n       \
    \ var i = 1l\n        while (i <= n) {\n            if (i < 100) {\n         \
    \       if (i % 10 == i / 10) {\n                    even += 1\n             \
    \   } else {\n                    odd += 1\n                }\n            } else\
    \ if (i < 1000) {\n                var li = i\n                var j = 1\n   \
    \             var k = 0\n                while (li >= 10) {\n                \
    \    li /= 10\n                    j *= 10\n                }\n              \
    \  var num = i % 10\n                li = i\n                while (li >= 10)\
    \ {\n                    k += li % 10 * j\n                    j /= 10\n     \
    \               li /= 10\n                }\n                k += li * j\n   \
    \             if (k == i) {\n                    even += 1\n                }\
    \ else {\n                    odd += 1\n                }\n            } else\
    \ if (i < 10000) {\n                var li = i\n                var j = 1\n  \
    \              var k = 0\n                while (li >= 10) {\n               \
    \     li /= 10\n                    j *= 10\n                }\n             \
    \   var num = i % 10\n                li = i\n                while (li >= 10)\
    \ {\n                    k += li % 10 * j\n                    j /= 10\n     \
    \               li /= 10\n                }\n                k += li * j\n   \
    \             if (k == i) {\n                    even += 1\n                }\
    \ else {\n                    odd += 1\n                }\n            } else\
    \ if (i < 100000) {\n                var li = i\n                var j = 1\n \
    \               var k", "        var o = 0l\n        var e = 0l\n        var r\
    \ = n\n        while (r > 0) {\n            if (isPalindrome(r)) {\n         \
    \       if (r % 2 == 0) e += 1 else o += 1\n            }\n            r -= 1\n\
    \        }\n        (e, o)", "        // Precondition:\n        require(1 <= n\
    \ && n <= pow(10, 3).toLong)\n        // Prepares a list of integers from 1 to\
    \ n inclusive.\n        val l = List.range(1, n.toInt + 1)\n        // Converts\
    \ the list of integers to a list of its palindromes.\n        val palindromes\
    \ = l.filter(x => x.toString == x.toString.reverse)\n        // Counts the numbers\
    \ of even and odd integer palindromes in the list of palindromes.\n        val\
    \ result = palindromes.map(x => (if (x % 2 == 0) 1 else 0, if (x % 2 == 1) 1 else\
    \ 0)).reduce((x, y) => (x._1 + y._1, x._2 + y._2))\n        // Postcondition:\n\
    \        // Returns the result as a tuple.\n        result", "        def helper(n\
    \ : Long, acc : Tuple2[Long, Long]) : Tuple2[Long, Long] = {\n            if (n\
    \ < 1) acc\n            else {\n                if (n.toString == n.toString.reverse)\
    \ {\n                    if (n % 2 == 0) helper(n - 1, (acc._1 + 1, acc._2))\n\
    \                    else helper(n - 1, (acc._1, acc._2 + 1))\n              \
    \  }\n                else helper(n - 1, acc)\n            }\n        }\n    \
    \    helper(n, (0, 0))", "        var even = 0\n        var odd = 0\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i.toString) && i % 2 ==\
    \ 0) even += 1\n            else if (isPalindrome(i.toString) && i % 2 == 1) odd\
    \ += 1\n        }\n        (even, odd)", "        // I think it's a type problem,\
    \ but I just don't know how to convert (1 to n) to List[Int]\n        def isPalindrome(s\
    \ : String) : Boolean = {\n            val length = s.length()\n            if\
    \ (length % 2 == 0) {\n                s.substring(0, length / 2) == s.substring(length\
    \ / 2, length).reverse\n            } else {\n                s.substring(0, length\
    \ / 2) == s.substring(length / 2 + 1, length).reverse\n            }\n       \
    \ }\n        def judge(s : Int) : Int = {\n            if (isPalindrome(s.toString))\n\
    \                1\n            else\n                0\n        }\n        def\
    \ oddEvenJudge(s : Int) : Int = {\n            if (s % 2 == 0)\n             \
    \   1\n            else\n                0\n        }\n        val odd = 1 to\
    \ n.toInt map oddEvenJudge sum\n        val even = 1 to n.toInt map oddEvenJudge\
    \ sum\n        (even, odd)", "        var even = 0L\n        var odd = 0L\n  \
    \      for (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n       \
    \         if (i % 2 == 0) even += 1\n                else odd += 1\n         \
    \   }\n        }\n        (even, odd)", "        // Fill up this function body\n\
    \        // `evenOddPalindrome_solution` is an example solution.\n        // You\
    \ may edit/remove it.\n        evenOddPalindrome_solution(n)", "        var map\
    \ = scala.collection.mutable.HashMap[Int, Int]()\n        var ans = 0l\n     \
    \   for (k <- 1 to 9) {\n            map(k) = (n / k) + (if (n % k == 0) -1 else\
    \ 0)\n            ans += map(k)\n        }\n        for (d <- 2 to 9) {\n    \
    \        var x = 10\n            var c = 1\n            while (x <= n) {\n   \
    \             map(x) = (n / x) + (if (n % x == 0) -1 else 0) - c\n           \
    \     ans += map(x)\n                c += 1\n                x = x * 10 + d\n\
    \            }\n        }\n        ans += 1\n        return (ans / 2, ans - ans\
    \ / 2)", "        // fill up this function body\n        // use pattern matching\n\
    \        def isPalindrome(n : Long) : Boolean = {\n            n.toString == n.toString.reverse\n\
    \        }\n        var even : Long = 0\n        var odd : Long = 0\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        (even, odd)", "        // Fill Up this function body\n        //\
    \ `evenCount` = Number of even integer palindromes within (1, n)\n        // `oddCount`\
    \ = Number of odd integer palindromes within (1, n)\n        val evenCount : Long\
    \ = 0\n        val oddCount : Long = 0\n        (evenCount, oddCount)", '        return
    (null, null)', "        // Start typing your Scala code here.\n        // DO NOT\
    \ USE *,/,% for your solution.\n        var even = 0l\n        var odd = 0l\n\
    \        var x = n\n        while (x > 0) {\n            val d = x % 10\n    \
    \        if (d % 2 == 0) even += 1\n            else odd += 1\n            x /=\
    \ 10\n        }\n        if (n % 2 == 0) (even, odd)\n        else (even, odd\
    \ + 1)", "        var c1 = 0l\n        var c2 = 0l\n        if (n >= 1) {\n  \
    \          c1 += 1\n            c2 += 1\n        }\n        if (n >= 2) {\n  \
    \          c1 += 1\n            c2 += 1\n        }\n        if (n >= 3) {\n  \
    \          c2 += 1\n        }\n        for (i <- 4 to n.toInt) {\n           \
    \ if (i % 2 == 0) {\n                var temp = (i / 2).toString\n           \
    \     var flag = true\n                for (j <- 0 to temp.length - 1) {\n   \
    \                 if (temp(j) != temp(temp.length - 1 - j)) {\n              \
    \          flag = false\n                    }\n                }\n          \
    \      if (flag) {\n                    c1 += 1\n                }\n         \
    \   } else {\n                var temp = (i / 2).toString\n                var\
    \ flag = true\n                for (j <- 0 to temp.length - 1) {\n           \
    \         if (temp(j) != temp(temp.length - 1 - j)) {\n                      \
    \  flag = false\n                    }\n                }\n                if\
    \ (flag) {\n                    c2 += 1\n                }\n            }\n  \
    \      }\n        (c1, c2)", "        // Fill up this function body\n        //\
    \ 'n' is the number upto which you need to find the palindromes.\n        // Return\
    \ a tuple containing count of even and odd palindromes.\n        val evens = new\
    \ ArrayBuffer[Int]\n        val odds = new ArrayBuffer[Int]\n        for (i <-\
    \ 1 to n.toInt) {\n            val s = i.toString\n            if (s == s.reverse)\
    \ {\n                if (i % 2 == 0) {\n                    evens += i\n     \
    \           } else {\n                    odds += i\n                }\n     \
    \       }\n        }\n        (evens.length, odds.length)", "        // Type your\
    \ solution here\n        null", "        // Fill up this function body\n     \
    \   // `even` is the number of even palindromes\n        // `odd` is the number\
    \ of odd palindromes\n        val even : Long = 0\n        val odd : Long = 0\n\
    \        (even, odd)", "        // Fill up this function body\n        // 'input\
    \ long n' represents the limit of range(1, n)\n        // You have to find the\
    \ number of even and odd integer palindromes\n        // and return a tuple of\
    \ type(Long, Long)", "        // Here is the definition of palindrome in integer\n\
    \        def isPalindrome(m : Long) : Boolean = {\n            m.toString.equals(m.toString.reverse)\n\
    \        }\n        var even = 0l\n        var odd = 0l\n        for (i <- 1l\
    \ to n) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0)\
    \ even += 1 else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       val list = (1l to n).toList.filter(x => isPalindrome(x))\n        //println(list)\n\
    \        (list.count(x => x % 2 == 0), list.count(x => x % 2 == 1))", "      \
    \  var i = 0l\n        var j = 0l\n        while (i <= n) {\n            if (i.toString\
    \ == i.toString.reverse) {\n                if (i % 2 == 0) j += 1\n         \
    \       else i += 1\n            }\n            i += 1\n        }\n        return\
    \ (j, n - j)", "        var l = List[Long]()\n        // var p = List[Tuple2[Long,\
    \ Long]]()\n        val p = new ArrayBuffer[Tuple2[Long, Long]]()\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                l\
    \ = i :: l\n                if (i % 2 == 0) p += new Tuple2(1l, 0l)\n        \
    \        else p += new Tuple2(0l, 1l)\n            }\n        }\n        // println(l)\n\
    \        // println(p)\n        p.foldLeft(new Tuple2(0l, 0l))((x, y) => new Tuple2(x._1\
    \ + y._1, x._2 + y._2))", '        ???', "        // Define the function.\n  \
    \      def isPalindrome(str : String) : Boolean = {\n            return str ==\
    \ str.reverse\n        }\n        var str = \"\"\n        var even = 0l\n    \
    \    var odd = 0l\n        for (i <- 1 to n.toInt) {\n            str = i.toString\n\
    \            if (isPalindrome(str)) {\n                if (str.length % 2 == 0)\
    \ {\n                    even += 1\n                } else {\n               \
    \     odd += 1\n                }\n            }\n        }\n        return (even,\
    \ odd)", "        var count = (0l, 0l)\n        for (i <- 1 to n.toInt) {\n  \
    \          val s = i.toString\n            if (s == s.reverse) {\n           \
    \     if (i % 2 == 0) count = (count._1 + 1, count._2)\n                else count\
    \ = (count._1, count._2 + 1)\n            }\n        }\n        count", "    \
    \    var ret = (0l, 0l)\n        var i = 1l\n        while (i <= n) {\n      \
    \      if (isPalindrome(i)) {\n                if (i % 2 == 0) ret._1 += 1\n \
    \               else ret._2 += 1\n            }\n            i += 1\n        }\n\
    \        ret", "        // this is wrong\n        /*\n        var f = (1 to n.toInt).filter(x\
    \ => {\n            val s = x.toString\n            s == s.reverse\n        })\n\
    \        (f.filter(x => x % 2 == 0).length, f.filter(x => x % 2 == 1).length)\n\
    \        */\n        var c1 = 0\n        var c2 = 0\n        for (i <- 1 to n.toInt)\
    \ {\n            val s = i.toString\n            if (s == s.reverse) {\n     \
    \           if (i % 2 == 0) c1 += 1\n                else c2 += 1\n          \
    \  }\n        }\n        (c1, c2)", "        val pair = (Tuple2(0l, 0l))\n   \
    \     for (i <- 1l to n) {\n            if (isPalindrome(i)) {\n             \
    \   if (i % 2 == 0) {\n                    pair._1 += 1\n                } else\
    \ {\n                    pair._2 += 1\n                }\n            }\n    \
    \    }\n        pair", "        // A number is a palindrome iff its least significant\
    \ digit is the same as its most significant digit,\n        // and the number\
    \ formed by all the digits of the number except the most significant digit and\
    \ the least\n        // significant digit is a palindrome.\n        def isPalindrome(m\
    \ : Long) : Boolean = {\n            // return true iff m is a palindrome.\n \
    \           if (m < 10) return true;\n            var temp = m;\n            var\
    \ least = temp % 10;\n            while (temp >= 10) {\n                temp /=\
    \ 10;\n            }\n            var most = temp;\n            if (least != most)\
    \ return false;\n            var newm = (m - least) / 10;\n            newm =\
    \ newm - most * pow(10, floor(log10(newm)).toInt).toLong;\n            return\
    \ isPalindrome(newm);\n        }\n        var evens = 0l;\n        var odds =\
    \ 0l;\n        for (i <- 1l to n) {\n            if (isPalindrome(i)) {\n    \
    \            if (i % 2 == 0) evens += 1;\n                else odds += 1;\n  \
    \          }\n        }\n        return Tuple2(evens, odds);", "        // Write\
    \ your code here\n        ???", "        // Implement this function\n        var\
    \ i = 1l\n        var even = 0l\n        var odd = 0l\n        while (i <= n)\
    \ {\n            val str = i.toString\n            if (str == str.reverse) {\n\
    \                if (i % 2 == 0) even += 1\n                else odd += 1\n  \
    \          }\n            i += 1\n        }\n        Tuple2(even, odd)", "   \
    \     var res = (0l, 0l)\n        for (i <- 1 to n.toInt) {\n            if (i.toString\
    \ == i.toString.reverse) {\n                if (i % 2 == 0) res = (res._1 + 1,\
    \ res._2)\n                else res = (res._1, res._2 + 1)\n            }\n  \
    \      }\n        res", "        // Define a functions that isPalindrome checks\
    \ whether a number is palindrome or not.\n        def isPalindrome(n : Long) :\
    \ Boolean = {\n            var str = n.toString\n            var rev = str.reverse\n\
    \            str == rev\n        }\n        // Iterate the input and collect number\
    \ of evens and odds.\n        // Initialize counts with 0.\n        var evenCount\
    \ = 0L\n        var oddCount = 0L\n        var i = 1L\n        while (i <= n)\
    \ {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) evenCount\
    \ += 1\n                else oddCount += 1\n            }\n            i += 1\n\
    \        }\n        (evenCount, oddCount)", '        // Type your solution here',
  "        if (n < 1) return (0, 0)\n        val palindromes = Array.fill(n.toInt\
    \ + 1)(false)\n        var p = 1\n        while (p <= n) {\n            var s\
    \ = p.toString\n            var q = p\n            var i = 0\n            while\
    \ (q > 0) {\n                val d = q % 10\n                s += d\n        \
    \        q /= 10\n                i += 1\n            }\n            palindromes(s.toInt)\
    \ = true\n            p += 1\n        }\n        var (even, odd) = (0l, 0l)\n\
    \        for (i <- 0 to n.toInt) {\n            if (palindromes(i)) {\n      \
    \          if (i % 2 == 0) even += 1\n                else odd += 1\n        \
    \    }\n        }\n        (even, odd)", "        val digits = n.toString.map(_.asDigit).toList\n\
    \        val palindromes = countPalindromes(digits, 0, true)\n        val evenPalindromes\
    \ = palindromes.filter(_.toLong % 2 == 0)\n        val oddPalindromes = palindromes.filter(_.toLong\
    \ % 2 == 1)\n        (evenPalindromes.length, oddPalindromes.length)", "     \
    \   // Fill up this function body\n        // 'even' represents the number of\
    \ even integer palindromes\n        // 'odd' represents the number of odd integer\
    \ palindromes\n        var even : Long = 0\n        var odd : Long = 0\n     \
    \   for ( i <- 1 to n.toInt ) {\n            if (isPalindrome(i)) {\n        \
    \        if (i.toString.length % 2 == 0) {\n                    even += 1\n  \
    \              } else {\n                    odd += 1\n                }\n   \
    \         }\n        }\n        return new Tuple2(even, odd)", "        // You\
    \ need to complete this\n        return (0l, 0l)", "        // Fill up this function\
    \ body\n        // `Tuple2` is just a tuple of size 2 - such as `(x, y)`\n   \
    \     // `Long` is just a 64-bit integer\n        var even = 0\n        var odd\
    \ = 0\n        for (i <- 1 to n.toInt) {\n            if (i.toString == i.toString.reverse)\
    \ {\n                if (i.toString.length % 2 == 0) {\n                    even\
    \ += 1\n                } else {\n                    odd += 1\n             \
    \   }\n            }\n        }\n        return (even, odd)", "        // we only\
    \ need to go through the digits that appear in the count,\n        // and when\
    \ we want to update the count, we only need to multiply the previous count\n \
    \       // by 10, and add the newly computed count.\n        var e : Long = 0\n\
    \        var o : Long = 0\n        for (i <- 1 to ceil(log10(n)).toInt) {\n  \
    \          val d = n / pow(10, i - 1).toLong % 10\n            val incE = if (d\
    \ == 0) 0 else if (d == 1) 1 else if (d <= 3) 2 else if (d <= 6) 3 else if (d\
    \ <= 9) 4 else 3\n            val incO = if (d == 0) 0 else if (d == 1) 0 else\
    \ if (d <= 3) 1 else if (d <= 6) 2 else if (d <= 9) 3 else 3\n            e =\
    \ 10 * e + incE\n            o = 10 * o + incO\n        }\n        return (e,\
    \ o)", "        // Fill up this function body\n        // `n` is the upper limit\
    \ for the range of input for which we need to find\n        // the number of even\
    \ and odd palindromes.\n        // return type is Tuple2[Long, Long]\n       \
    \ val t = n\n        val n_str = n.toString\n        val n_rev = n_str.reverse\n\
    \        var count_even = 0l\n        var count_odd = 0l\n        if (n_str ==\
    \ n_rev) {\n            count_even += 1\n        }\n        else {\n         \
    \   count_odd += 1\n        }\n        var i = 2\n        while (i <= t) {\n \
    \           val i_str = i.toString\n            val i_rev = i_str.reverse\n  \
    \          val num = i_str + i_rev\n            if (num.toLong <= t) {\n     \
    \           if (i_str == i_rev) {\n                    count_even += 1\n     \
    \           }\n                else {\n                    count_odd += 1\n  \
    \              }\n            }\n            i += 1\n        }\n        val tup\
    \ = (count_even, count_odd)\n        tup", "        if (n < 1) return (0, 0)\n\
    \        // This works because of the following fact\n        // - odd length\
    \ palindromes are 9x + a single digit where x is an integer >= 0.\n        //\
    \ - a single digit can only be in {0, 1, 3, 5, 7, 9} (the reason will be explained\
    \ later).\n        // - even length palindromes are 9x + a single digit + 9x +\
    \ reversed(single digit) where x is an integer >= 0.\n        // - the single\
    \ digit can only be in {0, 1, 3, 5, 7} (the reason will be explained later).\n\
    \        // - notice that 8 and 9 are not allowed to be the single digit because\
    \ if we reverse them, we will get the same digit.\n        // For example, with\
    \ n = 12, we have the following numbers\n        // 9, 90, 99, 1001, 1010, ...,\
    \ 9999, 10001, 10010, ..., 11111, 11211, ..., 19999, 20001, 20010, ..., 111111,\
    \ 111211, ..., 199999, 200001, 200010, ...\n        // The single digit can be\
    \ in {0, 1, 3, 5, 7} for even length palindromes and {0, 1, 3, 5, 7, 9} for odd\
    \ length palindromes.\n        var pw = 0\n        var e = 0\n        var o =\
    \ 0\n        while (pw <= n) {\n            if (pw <= n) {\n                e\
    \ += 1\n                pw = pow(10, e).toLong - 1\n            }\n          \
    \  if (pw <= n) {\n                e += 1\n                pw = pow(10, e).toLong\
    \ - 1\n            }\n            if (pw <= n) {\n                o += 1\n   \
    \             pw = pow(10, o).toLong + 1\n            }\n            if (pw <=\
    \ n) {\n                o += 1\n                pw = pow(10, o).toLong + 1\n \
    \           }\n        }\n        (e, o)", "        // Type your solution here\n\
    \        return null;", "        // Write your own algorithm here\n        (1,\
    \ 1)", "        // Write your code here\n        def isPalindrome(num : Long)\
    \ : Boolean = {\n            val string = num.toString\n            val stringLength\
    \ = string.length\n            val half = stringLength / 2\n            val halfString\
    \ = string.substring(0, half)\n            val reverseString = string.substring(stringLength\
    \ - half, stringLength).reverse\n            halfString == reverseString\n   \
    \     }\n        def isEven(num : Long) : Boolean = {\n            num % 2 ==\
    \ 0\n        }\n        def isOdd(num : Long) : Boolean = {\n            num %\
    \ 2 == 1\n        }\n        val evenCount = (1l to n).count(num => isPalindrome(num)\
    \ && isEven(num))\n        val oddCount = (1l to n).count(num => isPalindrome(num)\
    \ && isOdd(num))\n        (evenCount, oddCount)", "        // Fill up this function\
    \ body\n        // `n` is the upperbound, we need to find all the palindromes\
    \ in range (1, n).\n        var e = 0l\n        var o = 0l\n        for (i <-\
    \ 1 to n.toInt) {\n            if (i.toString == i.toString.reverse) {\n     \
    \           if (i % 2 == 0) e += 1\n                else o += 1\n            }\n\
    \        }\n        return (e, o)", "        // Fill up this function body\n \
    \       // `0` indicates an unknown/invalid return value.\n        var odd = 0l\n\
    \        var even = 0l\n        for (i <- 1 to n.toInt) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) {\n                    even += 1\n      \
    \          } else {\n                    odd += 1\n                }\n       \
    \     }\n        }\n        return (even, odd)", "        var even = 0l\n    \
    \    var odd = 0l\n        if (n % 2 == 0) {\n            even = n / 2\n     \
    \       odd = n / 2\n        } else {\n            even = n / 2\n            odd\
    \ = n / 2 + 1\n        }\n        (even, odd)", "        var evens = 0l\n    \
    \    var odds = 0l\n        for (i <- 1 to n.toInt) {\n            if (i.toString\
    \ == i.toString.reverse) {\n                if (i % 2 == 0) evens += 1\n     \
    \           else odds += 1\n            }\n        }\n        return (evens, odds)",
  "        // Please implement this method to\n        // return a tuple that has\
    \ the number of even and odd integer palindromes that fall within the range(1,\
    \ n), inclusive.\n        // For example, for n = 3 the method should return (1,\
    \ 2)\n        // 1 is an even palindrome, 2 and 3 are odd palindromes.\n     \
    \   // Keep in mind that your solution should run in linear time.\n        return\
    \ (0, 0)", "        // biggest palindrome that is even and less than n is 9.\n\
    \        // biggest palindrome that is odd and less than n is 9.\n        var\
    \ even = 9l;\n        var odd = 9l;\n        // x is the largest number less than\
    \ or equal to n of the form x = 11..1\n        var x = ((n - 1) / 11) * 11;\n\
    \        while (x > 0) {\n            // x is the largest number less than or\
    \ equal to n of the form x = 22..2\n            var y = ((n - 1) / 22) * 22;\n\
    \            while (y > 0) {\n                // 100..0 is the largest palindrome\
    \ less than or equal to x of the form y = 22..2\n                var z = ((n -\
    \ 1) / 110) * 110;\n                while (z > 0) {\n                    if (z\
    \ <= n) {\n                        even += 1;\n                    }\n       \
    \             z -= 110;\n                }\n                y -= 22;\n       \
    \     }\n            x -= 11;\n        }\n        // the biggest palindrome less\
    \ than or equal to n is x, where x = (10^k - 1)^2,\n        // or x = 1 or 9 if\
    \ n <= 9.\n        var y = floor(log10(n)).toLong;\n        if (y > 0) {\n   \
    \         even += 1;\n            odd += 1;\n        }\n        if (n > 9) {\n\
    \            odd += (n - 9 - 1) / 2;\n        }\n        else {\n            even\
    \ += (n - 4) / 2;\n        }\n        (even, odd)", "      // Look at example\
    \ 2, we can easily see the even and odd counts are\n      // just be the max count\
    \ of 1-digit, 2-digit, 3-digit and etc.\n      // For example 2, the max count\
    \ of 1-digit and 2-digit numbers are 9,\n      // the max count of 3-digit numbers\
    \ is 4\n      // max count of 1-digit = 9\n      // max count of 2-digit = 90\n\
    \      // max count of 3-digit = 900\n      // max count of 4-digit = 9000\n \
    \     // and etc.\n      // We can calculate the max count of n-digit using a\
    \ loop for each n,\n      // and sum up the even counts.\n      // 9 + 90 + 900\
    \ + ... + 9 * (10^(n-1)) - 1\n      // = 9 * ((10^(n-1)) + 90 + 900 + ... + 9\
    \ * (10^(n-1)) - 1)\n      // = 9 * 10^(n-1) * (10^(n-1) + 1) / 2\n      // =\
    \ 9 * 10^(n-1) * (10^(n-1) + 1) / 2\n      // = 9 * 10^(n-1) * (10^(n-1) + 1)\
    \ / 2\n      // = 9 * 10^(n-1) * (10^(n-1) + 1) / 2\n      // = 9 * 10^(n-1) *\
    \ (10^(n-1) + 1) / 2\n      var i = 1\n      var sum = 0L\n      while (sum <\
    \ n) {\n        sum += 9 * pow(10, i - 1).toLong * (pow(10, i - 1).toLong + 1)\
    \ / 2\n        i += 1\n      }\n      // careful with overflow, its really strange\
    \ to do a bigInt opreation for everything for a medium level question though\n\
    \      (BigInt(n) * 9 / 10 * i - 9 * pow(10, i - 1).toLong * (pow(10, i - 1).toLong\
    \ + 1) / 2 - (sum - n)).toLong -> (n - (BigInt(n) * 9 / 10 * i - 9 * pow(", " \
    \       // Solution 1: O(n) running time, O(1) memory\n        var evenCount =\
    \ 0l\n        var oddCount = 0l\n        for (i <- 1 to n.toInt) {\n         \
    \   if (i.toString == i.toString.reverse) {\n                if (i % 2 == 0) evenCount\
    \ += 1 else oddCount += 1\n            }\n        }\n        return (evenCount,\
    \ oddCount)\n        // Solution 2: O(1) running time, O(1) memory\n        //\
    \ Note: Since the time is too short and the integer range is small, we won't consider\
    \ the\n        // problem to have too many edge cases.\n        // 1. No palindrome\
    \ number larger than 10^3\n        // 2. Digits of 1, 2, 3 are all palindrome\
    \ numbers\n        // 3. Digits of 4 are all palindrome numbers minus 4, 8\n \
    \       // 4. Digits of 5 are all palindrome numbers\n        // 5. Digits of\
    \ 6 are all palindrome numbers minus 6\n        // 6. Digits of 7 are all palindrome\
    \ numbers\n        // 7. Digits of 8 are all palindrome numbers minus 8\n    \
    \    // 8. Digits of 9 are all palindrome numbers\n        val digit = n.toString.length\n\
    \        if (digit == 1) return (0, n - 1)\n        if (digit == 2) {\n      \
    \      if (n <= 9) return (0, n)\n            else if (n <= 11) return (2, 3)\n\
    \            else return (2, 4)\n        }\n        if (digit == 3) {\n      \
    \      if (n <= 9) return (0, n)\n            else if (n <= 99) return (9, 90)\n\
    \            else if (n <= 100) return (9, 91)\n            else if (n <= 101)\
    \ return (10, 91)\n            else if (n <= 109) return (10, 93)\n          \
    \  else if (n <= 110) return (11, 93)\n            else if (n <= 111) return (11,\
    \ 94)\n            else if (n <= 119) return (11, 96)\n            else if (n\
    \ <= 120) return (12, 96)\n            else if (n <= 121", "        // Write your\
    \ codes here\n        var result = (0l, 0l)\n        for (i <- 1l to n) {\n  \
    \          if (i.toString == i.toString.reverse) {\n                if (i % 2\
    \ == 0) result = (result._1 + 1, result._2)\n                else result = (result._1,\
    \ result._2 + 1)\n            }\n        }\n        result", "        //\n   \
    \     // Implementation goes here\n        //\n        return (0l, 0l)", "   \
    \     // Fill up this function body\n        // `return` statement is not required.\n\
    \        // `var` and `val` declarations are not allowed.\n        // `throw`\
    \ expression is not allowed.\n        // Compiler will be able to infer types\
    \ of variables.\n        0", "        // Your Code Here.\n        var even = 0l\n\
    \        var odd = 0l\n        for (a <- 1 to n.toInt) {\n            if (a.toString\
    \ == a.toString.reverse) {\n                if (a % 2 == 0) {\n              \
    \      even += 1\n                } else {\n                    odd += 1\n   \
    \             }\n            }\n        }\n        return new Tuple2(even, odd)",
  "        // Implement this function\n        return (0, 0)", '        return Tuple2(0,
    0)', "        var res = new Array[Tuple2[Long, Long]](n.toInt + 1)\n        res(0)\
    \ = (0, 0)\n        for (i <- 1 to n.toInt) {\n            val left = math.pow(10,\
    \ (i.toDouble - 1) / 2).toInt\n            val right = math.pow(10, i.toDouble\
    \ / 2).toInt\n            var even = (right - left) / 2\n            var odd =\
    \ right - left - even\n            if (i % 2 == 0) {\n                val mid\
    \ = pow(10, i.toDouble / 2).toInt\n                if (i == 2 || (i >= 4 && math.pow(10,\
    \ i.toDouble / 2 - 1).toInt % 2 == 1)) even += 1\n                else odd +=\
    \ 1\n            }\n            res(i) = (even, odd)\n        }\n        res(n.toInt)",
  "        if (n < 0 || n > pow(10, 3).toLong) throw new IllegalArgumentException\n\
    \        var evenCount = 0l\n        var oddCount = 0l\n        for (i <- 1l to\
    \ n) {\n            if (i.toString == i.toString.reverse) {\n                if\
    \ (i % 2 == 0) evenCount += 1\n                else oddCount += 1\n          \
    \  }\n        }\n        (evenCount, oddCount)", "        def isPalindrome(num\
    \ : Int) : Boolean = {\n            val str = num.toString\n            str ==\
    \ str.reverse\n        }\n        (1 to n.toInt).filter(x => isPalindrome(x)).partition(x\
    \ => x % 2 == 0).zipped.map(_.size.toLong).to((0L, 0L))", "        // Fill up\
    \ this function body\n        // `0` indicates the position of the even palindrome\
    \ and `1` indicates the position of the odd palindrome\n        var even_odd_palindrome_list\
    \ : List[Long] = List(0, 1)\n        for (i <- 1 to n.toInt) {\n            if\
    \ (i.toString == i.toString.reverse) {\n                if (i % 2 == 0) {\n  \
    \                  even_odd_palindrome_list = even_odd_palindrome_list.updated(0,\
    \ even_odd_palindrome_list(0) + 1)\n                } else {\n               \
    \     even_odd_palindrome_list = even_odd_palindrome_list.updated(1, even_odd_palindrome_list(1)\
    \ + 1)\n                }\n            }\n        }\n        (even_odd_palindrome_list(0),\
    \ even_odd_palindrome_list(1))", "        // Fill up this function body\n    \
    \    // `evenCount` = the number of even palindromes\n        // `oddCount` =\
    \ the number of odd palindromes\n        val evenCount = n\n        val oddCount\
    \ = n\n        (evenCount, oddCount)", "        val palindromes = new ListBuffer[Long]\n\
    \        val digits = digitsAsList(n)\n        palindromes += n\n        buildPalindromes(n,\
    \ digits, palindromes)\n        var evenCount = 0\n        var oddCount = 0\n\
    \        palindromes.foreach(x => if (x % 2 == 0) evenCount += 1 else oddCount\
    \ += 1)\n        (evenCount, oddCount)", '        (0l, 0l)', "        var even\
    \ : Long = 0\n        var odd : Long = 0\n        for (i <- 1 to n.toInt) {\n\
    \            if (i.toString == i.toString.reverse) {\n                if (i %\
    \ 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        return (even, odd)", "        // Fill up this function body\n       \
    \ // `even` is number of even palindromes\n        // `odd` is number of odd palindromes\n\
    \        val even = 0l\n        val odd = 0l\n        (even, odd)", "        //\
    \ Write your code here\n        // Return the tuple(number of even palindromes,\
    \ number of odd palindromes)\n        // You can also use multiple lines.\n  \
    \      var odd = 0\n        var even = 0\n        for (i <- 1l to n) {\n     \
    \       if (i.toString.reverse == i.toString) {\n                if (i.toString.length\
    \ % 2 == 0) even += 1\n                else odd += 1\n            }\n        }\n\
    \        (even, odd)", "        // Fill up this function body\n        // `n`\
    \ is the upper bound of the range, inclusive.\n        // You should return a\
    \ tuple that has the number of even and odd integer palindromes respectively.\n\
    \        (0l, 0l)"]
stop_tokens:
- "\n    }\n"
