name: HumanEval_49_modp
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n\
  \    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l),\
  \ (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l),\
  \ (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
  \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
  \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
  \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
  \ == (3l));\n    }\n\n}\n"
completions: ["        if (n == 0) return 1\n        var pn = n\n        var power\
    \ = 1l\n        while (pn > 1) {\n            var factor = n / pn\n          \
    \  var rem = n - pn * factor\n            power = (power * factor) % p\n     \
    \       if (power == 0) return 1\n            n = pn\n            pn = rem\n \
    \       }\n        return power", "        var res = 1l\n        for (i <- 0 until\
    \ n.toInt) res = (res * 2l) % p\n        return res", "        def modp(n : Long,\
    \ b : Long, p : Long) : Long = if (n == 0) 1 else if (n % 2 == 0) modp(n / 2,\
    \ (b * b) % p, p) else (b * modp(n - 1, b, p)) % p\n        modp(n, n, p)", " \
    \       if (n == 0) return 1\n        var r = modp(n / 2, p)\n        r = (r *\
    \ r) % p\n        if (n % 2 == 1) r = (r * 2) % p\n        return r", "      \
    \  // Precondition: n >= 0\n        if (n == 0) {\n            return 1\n    \
    \    }\n        var x = modp(n / 2, p)\n        var x_times_x = (x * x) % p\n\
    \        if (n % 2 == 1) {\n            x_times_x *= 2\n        }\n        return\
    \ x_times_x % p", "        if (n == 0) return 1l\n        var r = modp(n / 2,\
    \ p)\n        var t = r * r % p\n        if (n % 2 == 1) t = t * 2 % p\n     \
    \   return t", "        var r = n % p\n        if (r < 0) r += p\n        r",
  "        var r = 1l\n        var b = 2l\n        var e = n\n        while (e > 0)\
    \ {\n            if (e % 2 == 1) {\n                r = (r * b) % p\n        \
    \    }\n            e = e / 2\n            b = (b * b) % p\n        }\n      \
    \  return r", "        if (n == 0) {\n            1\n        } else {\n      \
    \      val modp_rec = modp(n / 2, p)\n            if (n % 2 == 0) {\n        \
    \        (modp_rec * modp_rec) % p\n            } else {\n                (modp_rec\
    \ * modp_rec * 2) % p\n            }\n        }", "        def pow(x : Long, n\
    \ : Long) : Long = {\n            if (n == 0) 1 else\n            if (n % 2 ==\
    \ 0) pow(x * x % p, n / 2)\n            else pow(x * x % p, n / 2) * x % p\n \
    \       }\n        pow(2, n) % p", "        var res = 1l\n        var nn = n\n\
    \        while (nn > 0) {\n            if ((nn & 1) == 1) res = (res * n) % p\n\
    \            nn = nn >> 1\n            n = (n * n) % p\n        }\n        res",
  "        var sum = 1l\n        for (i <- 1 to n.toInt) {\n            sum = (sum\
    \ * 2l) % p\n        }\n        return sum", "        if (n == 0) {\n        \
    \    return 1\n        }\n        var c = 1l\n        var a = 2l\n        var\
    \ b = n\n        while (b > 0) {\n            if ((b & 1) != 0) {\n          \
    \      c = (c * a) % p\n            }\n            a = (a * a) % p\n         \
    \   b >>= 1\n        }\n        return c", "        def calc(x : Long, n : Long,\
    \ p : Long) : Long = {\n            n match {\n                case 0 => 1\n \
    \               case _ => {\n                    val y = calc(x, n / 2, p)\n \
    \                   val yy = (y * y) % p\n                    if (n % 2 == 0)\
    \ yy else (x * yy) % p\n                }\n            }\n        }\n        calc(n,\
    \ p - 2, p)", "        var result : Long = 1\n        var i : Long = 0\n     \
    \   for(i <- 0l to n) {\n            result = (result * 2) % p\n        }\n  \
    \      return result", "        if (n < 0) modp(p - (abs(n) % p), p)\n       \
    \ else if (n == 0) 1\n        else if (n == 1) n\n        else {\n           \
    \ var a = 2l\n            var b = 1l\n            var c = 1l\n            var\
    \ d = 0l\n            while (a != 1) {\n                val quotient = n / a\n\
    \                d += quotient * c\n                d %= p\n                b\
    \ = n % a\n                n = a\n                a = b\n                c = d\n\
    \                d = b\n            }\n            n % p\n        }", "      \
    \  var a = 1l\n        var b = n\n        while (b > 0) {\n            if ((b\
    \ & 1) == 1) a = (a * n) % p\n            b >>= 1\n            n = (n * n) % p\n\
    \        }\n        return a", "        var s = 1l\n        var x = n\n      \
    \  while (x > 0) {\n            if ((x & 1) == 1) {\n                s = (s *\
    \ n) % p\n            }\n            x >>= 1\n            n = (n * n) % p\n  \
    \      }\n        return s", "        var r = 1l\n        var d = 2l\n       \
    \ var e = n\n        while (e > 0) {\n            if ((e & 1) != 0) {\n      \
    \          r = (r * d) % p\n            }\n            d = (d * d) % p\n     \
    \       e >>= 1\n        }\n        return r", "        var result : Long = 1\n\
    \        var a : Long = 2\n        var b : Long = n\n        while (b > 0) {\n\
    \            if ((b & 1) > 0) {\n                result = (result * a) % p\n \
    \           }\n            a = (a * a) % p\n            b >>= 1\n        }\n \
    \       return result", "        if (n == 0) {\n            1\n        } else\
    \ {\n            var ans = modp(n / 2, p)\n            ans = (ans * ans) % p\n\
    \            if (n % 2 == 1) ans = (ans * 2) % p\n            ans\n        }",
  "        if (n == 0) return 1\n        val res = modp(n / 2, p)\n        val res2\
    \ = (res * res) % p\n        if (n % 2 == 0) {\n            res2\n        } else\
    \ {\n            (res2 * 2) % p\n        }", "        var res = 1l\n        var\
    \ u = n % p\n        var v = p\n        while (u > 0) {\n            if ((u &\
    \ 1) == 1) res = (res * u) % p\n            u = u >> 1\n            v = (v * v)\
    \ % p\n        }\n        res", "        var a = 1l\n        var b = n\n     \
    \   while (b > 0) {\n            if ((b & 1) == 1) a = (a * n) % p\n         \
    \   b >>= 1\n            n = (n * n) % p\n        }\n        return a", "    \
    \    if (n == 0) return 1\n        if (n % 2 == 0) {\n            val m = modp(n\
    \ / 2, p)\n            return (m * m) % p\n        }\n        else return (modp(n\
    \ - 1, p) * n) % p", "        var pow = n\n        var result = 1l\n        while\
    \ (pow > 0) {\n            if ((pow & 1) == 1) {\n                result = (result\
    \ * n) % p\n            }\n            pow >>= 1\n            n = (n * n) % p\n\
    \        }\n        return result", "        if (n == 0) return 1\n        var\
    \ accum = 1l\n        for (x <- 1 to abs(n).toInt) {\n            accum = (accum\
    \ * 2) % p\n        }\n        if (n > 0) accum else (p - accum)", "        var\
    \ n_ = BigInt(n)\n        val p_ = BigInt(p)\n        var prod = BigInt(1)\n \
    \       for (i <- 0 until 32) {\n            if ((n_ & (1 << i)) != 0) prod =\
    \ (prod * pow(2, i)).mod(p_)\n        }\n        prod.toLong", "        var c\
    \ = 1l\n        for (i <- 0l until n) {\n            c = c * 2l\n            c\
    \ = c % p\n        }\n        return c", "        // Implement this function yourself\n\
    \        var res = 1L\n        var pw = n\n        var mod = p\n        while\
    \ (pw > 0) {\n            if ((pw & 1) == 1) {\n                res = (res * mod)\
    \ % p\n            }\n            pw = pw >> 1\n            mod = (mod * mod)\
    \ % p\n        }\n        return res", "        var result : Long = 1\n      \
    \  var value : Long = 2\n        while (n > 0) {\n            if ((n & 1) != 0)\
    \ result = (result * value) % p\n            value = (value * value) % p\n   \
    \         n >>= 1\n        }\n        return result", "        var x = 1l\n  \
    \      var power = n\n        var i = 1l\n        while (i <= p) {\n         \
    \   if ((i & p) != 0) {\n                x = (x * power) % p\n            }\n\
    \            power = (power * power) % p\n            i = i << 1\n        }\n\
    \        return x", "        if (n == 0) {\n            1\n        } else {\n\
    \            if (n % 2 == 0) {\n                val l = modp(n / 2, p)\n     \
    \           (l * l) % p\n            } else {\n                (2 * modp(n - 1,\
    \ p)) % p\n            }\n        }", "        var result : Long = 1\n       \
    \ var base : Long = 2\n        var exp : Long = n\n        while (exp > 0) {\n\
    \            if ((exp & 1) == 1) {\n                result = (result * base) %\
    \ p\n            }\n            exp >>= 1\n            base = (base * base) %\
    \ p\n        }\n        return result", "      if (n == 0) {\n        return 1\n\
    \      }\n      if (n % 2 == 0) {\n        val m = modp(n / 2, p)\n        return\
    \ ((m * m) % p)\n      }\n      else {\n        return ((modp(n - 1, p) * 2) %\
    \ p)\n      }", "        var result : Long = 1\n        var base : Long = 2\n\
    \        var exp : Long = n\n        while (exp > 0) {\n            if ((exp &\
    \ 1) == 1) result = (result * base) % p\n            exp >>= 1\n            base\
    \ = (base * base) % p\n        }\n        return result", "        var a = Array.fill[Long](100)(0)\n\
    \        var x = n\n        var i = 0\n        while (x > 0) {\n            a(i)\
    \ = x % 2\n            x /= 2\n            i += 1\n        }\n        var t =\
    \ a.length - 1\n        var k = 1l\n        while (t >= 0) {\n            k =\
    \ (k * k) % p\n            if (a(t) == 1) {\n                k = (k * n) % p\n\
    \            }\n            t -= 1\n        }\n        k", "        if (n < 0)\
    \ modp(n + p, p)\n        else if (n < p) n\n        else {\n            val q\
    \ = n / p\n            val r = n - q * p\n            if (2 * r >= p) r - p\n\
    \            else r\n        }", "        def mp(n : Long, p : Long, r : Long)\
    \ : Long = {\n            if (n == 0) return r\n            if (n % 2 == 0) mp(n\
    \ / 2, p * p % p, r)\n            else mp(n - 1, p * p % p, (r * p) % p)\n   \
    \     }\n        mp(n, p, 1)", "        var m = p\n        var a = n\n       \
    \ var b = p\n        var x = 0l\n        var y = 1l\n        while (a > 1) {\n\
    \            val q = a / b\n            val t = b\n            b = a % b\n   \
    \         a = t\n            val t2 = x\n            x = y - q * x\n         \
    \   y = t2\n        }\n        if (y < 0) y += m\n        y", "        var x =\
    \ n\n        var y = 1l\n        var b = 2l\n        while (x > 0) {\n       \
    \     if ((x & 1) == 1) {\n                y = (y * b) % p\n            }\n  \
    \          x >>= 1\n            b = (b * b) % p\n        }\n        y", "    \
    \    if (n == 0) return 1l\n        if (n % 2 == 0) {\n            val m = modp(n\
    \ / 2, p)\n            return (m * m) % p\n        }\n        else {\n       \
    \     val m = modp(n - 1, p)\n            return (2 * m) % p\n        }", "  \
    \      var result : Long = 1l\n        var i : Long = 0l\n        while (i < n)\
    \ {\n            result = (result * 2l) % p\n            i += 1l\n        }\n\
    \        return result", "        def f(n : Long, p : Long, result : Long) : Long\
    \ = {\n            if (n == 0) result\n            else if (n % 2 == 0) f(n /\
    \ 2, p * p % 1000000007, result)\n            else f(n - 1, p, result * p % 1000000007)\n\
    \        }\n        f(n, 1, 1)", "        def helper(n : Long, x : Long, p : Long)\
    \ : Long = {\n            if (n == 0) 1 else if (n % 2 == 0) (helper(n / 2, x\
    \ * x % p, p) % p) else (x * helper(n - 1, x, p) % p)\n        }\n        helper(n,\
    \ 2, p)", "        var v = 0l\n        var a = 1l\n        var b = n\n       \
    \ while (b > 0) {\n            if ((b & 1) == 1) {\n                v = (v + a)\
    \ % p\n            }\n            a = (a * 2) % p\n            b >>= 1\n     \
    \   }\n        v", "      var nd = n\n      var prod = 1l\n      while (nd > 0)\
    \ {\n        if ((nd & 1) == 1) prod = (prod * 2) % p\n        nd >>= 1\n    \
    \  }\n      prod", "      var ans = 1l\n      var curr = 2l\n      var pow = n\n\
    \      while (pow > 0) {\n        if (pow % 2 == 1) ans = (ans * curr) % p\n \
    \       curr = (curr * curr) % p\n        pow /= 2\n      }\n      ans", "   \
    \     if (n < 0) {\n            modp(n + p, p)\n        } else if (n < p) {\n\
    \            n\n        } else {\n            n % p\n        }", "        // Return\
    \ 2^n modulo p (be aware of numerics).\n        // >>> modp((3l), (5l))\n    \
    \    // (3l)\n        // >>> modp((1101l), (101l))\n        // (2l)\n        //\
    \ >>> modp((0l), (101l))\n        // (1l)\n        // >>> modp((3l), (11l))\n\
    \        // (8l)\n        // >>> modp((100l), (101l))\n        // (1l)\n     \
    \   var b = 2l\n        var c = 1l\n        var i = 0l\n        while (i < n)\
    \ {\n            {\n                if ((i % 100l) == 0l) c = (c * b) % p\n  \
    \              i += 1l\n            }\n        }\n        c", "        var m =\
    \ n\n        var ans = BigInt(1)\n        while (m > 0) {\n            if ((m\
    \ & 1) == 1) {\n                ans = (ans * 2) % p\n            }\n         \
    \   m = m >> 1\n        }\n        ans.toLong", "        val b = ArrayBuffer[Int]()\n\
    \        var n1 = n\n        while (n1 > 0) {\n            b += ((n1 % 2).toInt)\n\
    \            n1 /= 2\n        }\n        b.reverse\n        var power = BigInt(1)\n\
    \        var base = BigInt(2)\n        var num = BigInt(1)\n        for (d <-\
    \ b) {\n            if (d == 1) {\n                num = (num * base) % p\n  \
    \          }\n            base = (base * base) % p\n        }\n        num.toLong",
  "        var res = 1l\n        var k = n\n        var i = p - 2l\n        while\
    \ (i > 0) {\n            if (i % 2l == 1l) {\n                res = (res * k)\
    \ % p\n            }\n            k = (k * k) % p\n            i /= 2l\n     \
    \   }\n        res", "        var nn = n\n        var pp = p\n        var r =\
    \ 1l\n        while (nn > 0) {\n            if ((nn & 1) != 0) {\n           \
    \     r = (r * n) % p\n            }\n            nn >>= 1\n            n = (n\
    \ * n) % p\n        }\n        return r", "        var r : Long = 1\n        var\
    \ b : Long = 2\n        var e : Long = n\n        while (e > 0) {\n          \
    \  if ((e & 1) != 0) {\n                r = (r * b) % p\n            }\n     \
    \       e >>= 1\n            b = (b * b) % p\n        }\n        return r", " \
    \     var nn = n\n      var pp = p\n      if (nn == 0) return 1\n      var r =\
    \ 0l\n      if (nn % 2 == 1) {\n        r = modp(nn - 1, pp) * 2 % pp\n      }\
    \ else {\n        r = modp(nn / 2, pp)\n        r = r * r % pp\n      }\n    \
    \  return r", '        if (n == 0) 1 else (modp(n / 2, p) * (if (n % 2 == 0) 1
    else 2)) % p', "        var result : Long = 1\n        var bitval : Long = 2\n\
    \        var exp : Long = n\n        while (exp > 0) {\n            if ((exp &\
    \ 1) == 1) {\n                result = (result * bitval) % p\n            }\n\
    \            bitval = (bitval * bitval) % p\n            exp >>= 1\n        }\n\
    \        return result", "        var result : Long = 1l\n        var power :\
    \ Long = n\n        var base : Long = 2l\n        while (power > 0) {\n      \
    \      if ((power & 1) == 1) {\n                result = (result * base) % p\n\
    \            }\n            base = (base * base) % p\n            power >>= 1\n\
    \        }\n        return result", "        if (n == 0) {\n            return\
    \ 1\n        }\n        var k = n / 2\n        var ret = modp(k, p)\n        if\
    \ (n % 2 == 0) {\n            return ret * ret % p\n        } else {\n       \
    \     return ret * ret * 2 % p\n        }", "        var result : Long = 1\n \
    \       var power : Long = n\n        var index : Long = 1\n        while (index\
    \ <= p) {\n            if ((index & p) != 0) {\n                result = (result\
    \ * power) % p\n            }\n            power = (power * power) % p\n     \
    \       index = index << 1\n        }\n        return result", "        // assert(n\
    \ >= 0)\n        if (n == 0) return 1\n        else if (n % 2 == 0) {\n      \
    \      val x = modp(n / 2, p)\n            (x * x) % p\n        } else {\n   \
    \         (2 * modp(n - 1, p)) % p\n        }", "        def binaryExp(n : Long,\
    \ p : Long) : Long = {\n            if (n == 0) 1\n            else if (n % 2\
    \ == 0) {\n                val res = binaryExp(n / 2, p)\n                (res\
    \ * res) % p\n            } else {\n                (2 * binaryExp(n - 1, p))\
    \ % p\n            }\n        }\n        binaryExp(n, p)", "        if (n == 0)\
    \ return 1\n        var r = (n / 2) % p\n        r = r * modp(n - r * 2, p) %\
    \ p\n        if (n % 2 == 0) return r else return (p - r) % p", "        if (n\
    \ == 0) {\n            1\n        } else {\n            val x = modp(n / 2, p)\n\
    \            if (n % 2 == 0) {\n                (x * x) % p\n            } else\
    \ {\n                (((x * x) % p) * 2) % p\n            }\n        }", "   \
    \   if (n == 0) return 1\n      if (n % 2 == 0) {\n        var res = modp(n /\
    \ 2, p)\n        res = (res * res) % p\n        return res\n      }\n      else\
    \ {\n        var res = (modp(n - 1, p) * n) % p\n        return res\n      }",
  "        var res = 1l\n        var n_ = n\n        var p_ = p\n        while (n_\
    \ > 0) {\n            if ((n_ & 1) != 0) {\n                res = (res * n_) %\
    \ p_\n            }\n            n_ = n_ >> 1\n            n_ = (n_ * n_) % p_\n\
    \        }\n        return res", "        var a = 1l\n        var e = n\n    \
    \    var b = 2l\n        while (e > 0) {\n            if (e % 2 == 1) a = (a *\
    \ b) % p\n            e /= 2\n            b = (b * b) % p\n        }\n       \
    \ a", "        var result : Long = 1l\n        var base : Long = 2l\n        var\
    \ exponent : Long = n\n        while (exponent > 0) {\n            if ((exponent\
    \ & 1) == 1) {\n                result = (result * base) % p\n            }\n\
    \            exponent >>= 1\n            base = (base * base) % p\n        }\n\
    \        return result", "        var q = n\n        var res = 1l\n        while\
    \ (q > 0) {\n            if ((q & 1) != 0) res = (res * 2) % p\n            q\
    \ >>= 1\n        }\n        res", "        // >>> p = 101l\n        // >>> a =\
    \ 3l\n        // >>> a\n        // (3l)\n        // >>> b = a\n        // >>>\
    \ b\n        // (3l)\n        // >>> a = a*b\n        // >>> a\n        // (9l)\n\
    \        // >>> b = a\n        // >>> b\n        // (9l)\n        // >>> a = a*b\n\
    \        // >>> a\n        // (81l)\n        // >>> b = a\n        // >>> b\n\
    \        // (81l)\n        // >>> a = a*b\n        // >>> a\n        // (6561l)\n\
    \        // >>> b = a\n        // >>> b\n        // (6561l)\n        // >>> a\
    \ = a*b\n        // >>> a\n        // (43046721l)\n        // >>> b = a\n    \
    \    // >>> b\n        // (43046721l)\n        // >>> a = a*b\n        // >>>\
    \ a\n        // (1853020188851841l)\n        // >>> b = a\n        // >>> b\n\
    \        // (1853020188851841l)\n        // >>> a = a*b\n        // >>> a\n  \
    \      // (3433683820292512484657849089281l)\n        // >>> b = a\n        //\
    \ >>> b\n        // (3433683820292512484657849089281l)\n        // >>> a = a*b\n\
    \        // >>> a\n        // (11751797696928776958918342240575993783888509146890965449l)\n\
    \        // >>> b = a\n        // >>> b\n        // (11751797696928776958918342240575993783888509146890965449l)\n\
    \        // >>> a = a*b\n        // >>> a\n        // (59806422392206446239364652927368907056553355687628370764809l)\n\
    \        // >>> b = a\n        // >>> b\n        // (59806422392206446239364652927368907056553355687628370764",
  "        if (n == 0) return 1\n        var acc = 1l\n        for (i <- 1 to n.toInt)\
    \ {\n            acc = acc * 2\n            if (acc > p) acc = acc % p\n     \
    \   }\n        return acc", "        def f(n : Long, p : Long, acc : Long) : Long\
    \ = {\n            if (n == 0) return acc\n            else {\n              \
    \  var r = acc\n                var x = 1l\n                var t = n\n      \
    \          while (t != 0) {\n                    if ((t & 1) == 1) r = (r * x)\
    \ % p\n                    x = (x * x) % p\n                    t = t >> 1\n \
    \               }\n                r\n            }\n        }\n        if (n\
    \ == 0) return 1\n        else return f(n, p, 1)", "        var a = 1l\n     \
    \   for (i <- 0 until n.toInt) {\n            a = (a * 2l) % p\n        }\n  \
    \      return a", "        var power = 1l\n        var result = 1l\n        var\
    \ base = 2l\n        while (power <= n) {\n            if ((power & n) != 0) result\
    \ = (result * base) % p\n            base = (base * base) % p\n            power\
    \ *= 2\n        }\n        return result", "        var result : Long = 1l\n \
    \       var base : Long = 2l\n        var exponent : Long = n\n        while (exponent\
    \ > 0) {\n            if ((exponent & 1) > 0) {\n                result = (result\
    \ * base) % p\n            }\n            exponent >>= 1\n            base = (base\
    \ * base) % p\n        }\n        return result", "        if (n == 0) {\n   \
    \         return 1\n        }\n        if (n % 2 == 0) {\n            val x =\
    \ modp(n / 2, p)\n            val res = (x * x) % p\n            return res\n\
    \        }\n        val x = modp(n - 1, p)\n        val res = (x * 2) % p\n  \
    \      return res", "        var result : Long = 1\n        for (i <- 0 until\
    \ n.toInt) {\n            result = (result * 2) % p\n        }\n        return\
    \ result", "        if (n == 0) 1\n        else if (n % 2 == 0) {\n          \
    \  val t = modp(n / 2, p)\n            (t * t) % p\n        } else {\n       \
    \     (modp(n - 1, p) * 2) % p\n        }", "        var r = 1l\n        var b\
    \ = n\n        var e = p - 2l\n        while (e > 0) {\n            if (e % 2\
    \ == 1) r = (r * b) % p\n            b = (b * b) % p\n            e /= 2\n   \
    \     }\n        r", "        if (n == 0) return 1\n        var res = 1l\n   \
    \     var base = 2l\n        while (n > 0) {\n            if ((n & 1) != 0) res\
    \ = res * base % p\n            base = base * base % p\n            n >>= 1\n\
    \        }\n        return res", "        def t(n : Long, p : Long, power : Long,\
    \ m : Long) : Long = {\n            if (n == 0) m\n            else if (n % 2\
    \ == 0) t(n / 2, p, power * power % p, m)\n            else t(n - 1, p, power\
    \ * power % p, (m * power) % p)\n        }\n        t(n, p, 2, 1)", "        val\
    \ r = (1l << n) % p\n        r", "      var sum = 1l\n      var power = n\n  \
    \    var ite = 0\n      while (ite < 64) {\n        if ((p & (1l << ite)) != 0)\
    \ {\n          sum = (sum * power) % p\n        }\n        power = (power * power)\
    \ % p\n        ite += 1\n      }\n      sum", "        assert(n >= 0)\n      \
    \  var mod : Long = n\n        for (i <- 2l to n) {\n            mod = (mod *\
    \ n) % p\n        }\n        return mod", "        var ans = BigInt(2).modPow(n,\
    \ p)\n        ans.longValue", "        if (n == 0) 1\n        else if (n % 2 ==\
    \ 0)\n            (((modp(n/2, p)) % p) * ((modp(n/2, p)) % p)) % p\n        else\n\
    \            ((((modp(n/2, p)) % p) * ((modp(n/2, p)) % p)) % p) * (2 % p) % p",
  "        if (n == 0) return 1\n        val half = modp(n / 2, p)\n        val remainder\
    \ = n % 2\n        val first = (half * half) % p\n        val second = if (remainder\
    \ == 0) 1 else half\n        (first * second) % p", "        if (n < 100) return\
    \ pow(2, n).toLong % p\n        val r = modp(n / 2, p)\n        val rr = (r *\
    \ r) % p\n        if (n % 2 == 0) return rr\n        else return (2 * rr) % p",
  "        var result : Long = 1l\n        var mult : Long = 2l\n        var exp :\
    \ Long = n\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n   \
    \             result = (result * mult) % p\n            }\n            mult =\
    \ (mult * mult) % p\n            exp >>= 1\n        }\n        return result",
  "        var res = 1l\n        var b = n\n        var a = p\n        while (b >\
    \ 0) {\n            if ((b & 1) > 0) res = (res * a) % p\n            b >>= 1\n\
    \            a = (a * a) % p\n        }\n        res", "        var a = n\n  \
    \      var i = p\n        while (i > 0) {\n            if ((i & 1) == 1) {\n \
    \               a = a * n % p\n            }\n            n = n * n % p\n    \
    \        i >>= 1\n        }\n        return a", "        var res = (1l)\n    \
    \    var b = (n)\n        var e = (p - (2l))\n        while (e > (0l)) {\n   \
    \         if ((e & (1l)) > (0l)) {\n                res = (res * b) % p\n    \
    \        }\n            e >>= (1l)\n            b = (b * b) % p\n        }\n \
    \       return res", "        if (n == 0) return 1\n        var res = 1l\n   \
    \     var b = 2l\n        var e = n\n        while (e > 0) {\n            if (e\
    \ % 2 == 1) res = (res * b) % p\n            b = (b * b) % p\n            e /=\
    \ 2\n        }\n        return res", "        var pow = 1l\n        var x = n\n\
    \        while (x > 0) {\n            if ((x & 1) != 0) pow = (pow * n) % p\n\
    \            n = (n * n) % p\n            x = x >> 1\n        }\n        pow",
  "        var sum = 1l\n        var mul = 2l\n        var m = n\n        while (m\
    \ > 0) {\n            if ((m & 1) == 1) {\n                sum = (sum * mul) %\
    \ p\n            }\n            mul = (mul * mul) % p\n            m = m >> 1\n\
    \        }\n        sum", "        if (n == 0) 1\n        else {\n           \
    \ val d = modp(n / 2, p)\n            val t = (d * d) % p\n            if (n %\
    \ 2 == 0) t\n            else (t * 2) % p\n        }", "        val b = 2l\n \
    \       val m = BigInt(b).modPow(n, p)\n        val r = m.toLong\n        r",
  "        // Complete this function\n        var result = BigInt(1)\n        for\
    \ (i <- 0 until n.toInt) {\n            result = result * 2 % p\n        }\n \
    \       result.toLong", "        if (n == 0) 1\n        else if (n % 2 == 0) {\n\
    \            val x = modp(n / 2, p)\n            ((x * x) % p)\n        } else\
    \ {\n            ((2 * modp(n - 1, p)) % p)\n        }", "        if (n == 0)\
    \ return 1\n        var halfp = modp(n / 2, p)\n        var mod = (halfp * halfp)\
    \ % p\n        if (n % 2 == 1) mod = (mod * 2) % p\n        return mod", "   \
    \     var res = 1l\n        var i = 0l\n        var a = n\n        while (i <\
    \ 60) {\n            if ((a & 1) == 1) res = (res * 2) % p\n            a = a\
    \ >> 1\n            i += 1\n        }\n        res", "        def iter(n : Long,\
    \ p : Long, power : Long, result : Long) : Long = {\n            if (n == 0) result\n\
    \            else {\n                if ((n & 1) == 1) iter(n >> 1, p, power *\
    \ 2 % p, (result + power) % p)\n                else iter(n >> 1, p, power * 2\
    \ % p, result)\n            }\n        }\n        iter(n, p, 1, 0)", "       \
    \ //log.debug(\"modp(%d, %d)\".format(n, p))\n        if (n < 0) return modp(n\
    \ + p, p)\n        if (n < p) return n\n        if (n % 2 == 0) return modp(n\
    \ / 2, p) * 2 % p\n        if (n % 2 == 1) return modp(n / 2, p) * 2 % p + 1\n\
    \        throw new IllegalStateException(\"modp invariant violated\")", "    \
    \    var r = 1l\n        var m = n\n        var k = 1l\n        while (k <= m)\
    \ {\n            if ((k & m) != 0) {\n                r = (r * n) % p\n      \
    \      }\n            k <<= 1\n            n = (n * n) % p\n        }\n      \
    \  return r", "        if (n == 0) return 1l\n        if (n % 2 == 0) {\n    \
    \        val a = modp(n / 2, p)\n            a * a % p\n        } else {\n   \
    \         (2 * modp(n - 1, p)) % p\n        }", "        var modp = n\n      \
    \  while (modp >= p) {\n            modp -= p\n        }\n        modp", "   \
    \     if (n == 0) return 1l\n        if (n == 1) return 2l\n        if (n % 2\
    \ == 0) return modp(n / 2, p) * modp(n / 2, p) % p\n        return modp(n / 2,\
    \ p) * modp(n / 2, p) * 2 % p", "      def modpHelper(n : Long, p : Long, m :\
    \ Long) : Long = {\n        if (n == 0) m\n        else if (n % 2 == 0) modpHelper(n\
    \ / 2, p, (m * m) % p)\n        else modpHelper(n - 1, p, (m * m) % p)\n     \
    \ }\n      modpHelper(n, p, 1)", "        var result : Long = 1\n        var i\
    \ : Long = n\n        var j : Long = p\n        while (i > 0) {\n            if\
    \ ((i & 1) == 1) {\n                result = (result * 2) % j\n            }\n\
    \            i = i >> 1\n        }\n        return result", "        if (n ==\
    \ 0) return 1\n        var m = n\n        var e = 2\n        var result = m\n\
    \        while (e <= n) {\n            m = (m * m) % p\n            if ((e & n)\
    \ != 0) {\n                result = (result * m) % p\n            }\n        \
    \    e = e << 1\n        }\n        return result", "        if (n == 0) {\n \
    \           1l\n        } else {\n            if (n % 2 == 0) {\n            \
    \    var t = modp(n / 2, p)\n                t * t % p\n            } else {\n\
    \                2 * modp(n - 1, p) % p\n            }\n        }", "        var\
    \ ans = 1l\n        var base = 2l\n        var bpow = n\n        while (bpow >\
    \ 0) {\n            if ((bpow & 1) == 1) {\n                ans = (ans * base)\
    \ % p\n            }\n            base = (base * base) % p\n            bpow >>=\
    \ 1\n        }\n        return ans", "        if (n == 0) return 1\n        if\
    \ (n == 1) return 2\n        val temp = modp(n >> 1, p)\n        val result =\
    \ (temp * temp) % p\n        if ((n & 1) == 1) {\n            return (result *\
    \ 2) % p\n        } else {\n            return result\n        }", "        //\
    \ computes (a * b) % c\n        def mulmod(a : Long, b : Long, c : Long) : Long\
    \ = {\n            if (a > c || b > c)\n                mulmod(a % c, b % c, c)\n\
    \            else {\n                val res = (a * b) % c\n                if\
    \ (res < 0) res + c else res\n            }\n        }\n        // computes a^e\
    \ % p\n        def modpow(a : Long, e : Long, p : Long) : Long = {\n         \
    \   if (e == 0)\n                1\n            else if (e % 2 == 0)\n       \
    \         mulmod(modpow(a, e / 2, p), modpow(a, e / 2, p), p)\n            else\n\
    \                mulmod(a, modpow(a, e - 1, p), p)\n        }\n        modpow(2,\
    \ n, p)", "        var res = 1l\n        for (i <- 1 to n.toInt) res = (res *\
    \ 2l) % p\n        return res", "        var r : Long = 1l\n        for (e <-\
    \ 0 until n.toInt) {\n            r = (r * 2l) % p\n        }\n        return\
    \ r", "        val b = scala.collection.mutable.ListBuffer[Int]()\n        var\
    \ t = n\n        while (t > 0) {\n            b += ((t % 2).toInt)\n         \
    \   t /= 2\n        }\n        var r = 1l\n        for (i <- 0 until b.length)\
    \ {\n            r = (r * r) % p\n            if (b(i) == 1) r = (r * n) % p\n\
    \        }\n        return r", "        if (n < p - 1) n else {\n            if\
    \ (n < 2 * (p - 1)) n - p else {\n                var m = n\n                var\
    \ a = 1l\n                var b = p\n                while (m >= 2 * b) {\n  \
    \                  if (m % 2 == 1) a = (a * 2) % p\n                    b = (b\
    \ * 2) % p\n                    m /= 2\n                }\n                (a\
    \ + b) % p\n            }\n        }", "        def modpacc(b : Long, a : Long,\
    \ n : Long, p : Long) : Long = {\n            if (n == 0) a\n            else\
    \ {\n                if ((n & 1) == 1) modpacc(b * b % p, a * b % p, n >> 1, p)\n\
    \                else modpacc(b * b % p, a, n >> 1, p)\n            }\n      \
    \  }\n        modpacc(2, 1, n, p)", "        var ans = BigInt(1)\n        var\
    \ base = BigInt(2)\n        var i = BigInt(n)\n        while (i > 0) {\n     \
    \       if (i % 2 == 1) {\n                ans = ans * base % p\n            }\n\
    \            base = base * base % p\n            i /= 2\n        }\n        ans.toLong",
  "        val res = modp(n, 1, p, p)\n        res._1", "        def modpR(n : Long,\
    \ p : Long, a : Long) : Long = {\n            if (n == 0) a\n            else\
    \ if (n % 2 == 0) modpR(n / 2, p, a * a % p)\n            else modpR(n - 1, p,\
    \ a * a % p * a % p)\n        }\n        modpR(n, p, 1)", "        var (result,\
    \ n) = (1l, n % p)\n        for (bit <- 0 until 64) {\n            if ((n & (1l\
    \ << bit)) != 0) {\n                result = (result * (2l)) % p\n           \
    \ }\n        }\n        return result", "        val nf = new BigInt(n.toString)\n\
    \        val pf = new BigInt(p.toString)\n        val b = new BigInt(2.toString)\n\
    \        val a = b.modPow(nf, pf)\n        a.longValue", "        var res = 1l\n\
    \        var x = n\n        var y = p\n        while (x > 0) {\n            if\
    \ ((x & 1) == 1) res = (res * n) % p\n            x >>= 1\n            n = (n\
    \ * n) % p\n        }\n        res", "        var res = 1l\n        var nn = n\n\
    \        while (nn > 0) {\n            if ((nn & 1) == 1) res = (res * n) % p\n\
    \            nn >>= 1\n            n = (n * n) % p\n        }\n        res", " \
    \       var (n1, p1) = (n, p)\n        var result = 1l\n        while (n1 > 0)\
    \ {\n            if ((n1 & 1) == 1) {\n                result = (result * n) %\
    \ p\n            }\n            n1 >>= 1\n            n = (n * n) % p\n      \
    \  }\n        return result", "        var y = 1l\n        var x = n\n       \
    \ var b = 2l\n        while (b <= n) {\n            if ((x & b) != 0) {\n    \
    \            y = (y * n) % p\n            }\n            x = (x * x) % p\n   \
    \         b = b * 2\n        }\n        return y", "        val r = BigInt(2).modPow(n,\
    \ p).longValue\n        if (r >= p) r - p else r", "        if (n < p) {\n   \
    \         return n;\n        }\n        else {\n            return (modp((2 *\
    \ n) / p, p) * 2) % p;\n        }", "        if (n == 0) {\n            1\n  \
    \      } else {\n            val res = modp(n / 2, p)\n            if (n % 2 ==\
    \ 0) {\n                (res * res) % p\n            } else {\n              \
    \  (res * res * 2) % p\n            }\n        }", "        var n1 = n\n     \
    \   var m = 1l\n        while (n1 > 0) {\n            if ((n1 & 1) != 0) m = (m\
    \ * 2) % p\n            n1 >>= 1\n        }\n        m", "        if (n == 0)\
    \ return 1\n        val sqrt = modp(n / 2, p)\n        val sqrt2 = (sqrt * sqrt)\
    \ % p\n        if (n % 2 == 0) sqrt2 else (sqrt2 * (2l)) % p", "        // assert(n\
    \ >= 0)\n        // assert(p >= 0)\n        if (n == 0) return 1\n        if (n\
    \ % 2 == 0) {\n            val x = modp(n / 2, p)\n            return (x * x)\
    \ % p\n        }\n        else {\n            return ((2 % p) * modp(n - 1, p))\
    \ % p\n        }", "        def mod(a : Long, b : Long) : Long = {\n         \
    \   val r = a % b\n            if (r < 0) r + b else r\n        }\n        var\
    \ k = 1l\n        var b = 2l\n        var res = 1l\n        while (k <= n) {\n\
    \            if ((k & n) != 0) {\n                res = mod(res * b, p)\n    \
    \        }\n            k <<= 1\n            b = mod(b * b, p)\n        }\n  \
    \      res", "        val inv2 = modinv(2l, p)\n        modp(n, p, inv2)", " \
    \       val t = 2l\n        var r = 1l\n        var x = t % p\n        var nn\
    \ = n\n        while (nn > 0) {\n            if ((nn & 1) != 0) {\n          \
    \      r = (r * x) % p\n            }\n            x = (x * x) % p\n         \
    \   nn >>= 1\n        }\n        r", "        def modp_rec(n : Long, p : Long,\
    \ r : Long) : Long = n match {\n            case 0 => r\n            case _ =>\
    \ modp_rec(n / 2, p, if (n % 2 == 0) (r * r) % p else (r * r * 2) % p)\n     \
    \   }\n        modp_rec(n, p, 1)", "        if (n == 0) 1 else {\n           \
    \ val a = modp(n >> 1, p)\n            val b = a * a % p\n            if ((n &\
    \ 1) == 0) b else b * 2 % p\n        }", "        var sum = 1L\n        var current\
    \ = 2L\n        var j = n\n        while (j > 0) {\n            if (j % 2 == 1)\
    \ {\n                sum = sum * current % p\n            }\n            current\
    \ = current * current % p\n            j /= 2\n        }\n        sum", "    \
    \    var m = 1l\n        var e = n\n        var mod = p\n        while (e > 0)\
    \ {\n            if ((e & 1) != 0) {\n                m = (m * n) % mod\n    \
    \        }\n            n = (n * n) % mod\n            e = e >> 1\n        }\n\
    \        return m", "        var res = 1l\n        var x = n\n        var m =\
    \ p\n        while (x > 0) {\n            if ((x & 1) != 0) {\n              \
    \  res = (res * n) % p\n            }\n            x = x >> 1\n            n =\
    \ (n * n) % p\n        }\n        return res", "        var total = 1l\n     \
    \   var i = n\n        var x = 2l\n        while (i > 0) {\n            if (i\
    \ % 2 == 1) {\n                total = (total * x) % p\n            }\n      \
    \      x = (x * x) % p\n            i /= 2\n        }\n        return total",
  "        var r = 1l\n        var s = 2l\n        var t = n\n        while (t > 0)\
    \ {\n            if (t % 2 == 1) r = (r * s) % p\n            s = (s * s) % p\n\
    \            t /= 2\n        }\n        r", "        var result : Long = 1l\n\
    \        var base : Long = 2l\n        var exponent : Long = n\n        while\
    \ (exponent > 0) {\n            if ((exponent & 1) == 1) {\n                result\
    \ = (result * base) % p\n            }\n            exponent >>= 1\n         \
    \   base = (base * base) % p\n        }\n        return result", "        var\
    \ nn = n\n        var pp = p\n        var result = 1l\n        while (nn > 0)\
    \ {\n            if ((nn & 1) == 1) result = (result * n) % p\n            nn\
    \ >>= 1\n            n = (n * n) % p\n        }\n        return result", "   \
    \     var r : Long = 1\n        var m : Long = 2\n        var x : Long = n\n \
    \       while (x > 0) {\n            if ((x & 1) == 1) {\n                r =\
    \ (r * m) % p\n            }\n            m = (m * m) % p\n            x >>= 1\n\
    \        }\n        return r", "        var result : Long = 1\n        var b :\
    \ Long = 2\n        var bp : Long = b % p\n        var r : Long = n\n        while\
    \ (r > 0) {\n            if ((r & 1) > 0) result = (result * bp) % p\n       \
    \     r >>= 1\n            bp = (bp * bp) % p\n        }\n        return result",
  "        var a = 1l\n        var b = n\n        while (b > 0) {\n            if\
    \ ((b & 1) != 0) {\n                a = (a * n) % p\n            }\n         \
    \   b >>= 1\n            n = (n * n) % p\n        }\n        return a", "    \
    \    val nmodp = n % p\n        if (nmodp < 0) {\n            nmodp + p\n    \
    \    } else {\n            nmodp\n        }", "        var x = 1l\n        var\
    \ y = n\n        while (y > 0) {\n            if ((y & 1) > 0) x = (x * n) % p\n\
    \            y >>= 1\n            n = (n * n) % p\n        }\n        return x",
  "        val result = ((BigInt(2).modPow(n, p)).toLong)\n        result", "    \
    \    var a = 1l\n        for (i <- 1 to n.toInt) {\n            a = (a * 2l) %\
    \ p\n        }\n        return a", "        var res = 1l\n        var k = n\n\
    \        var y = 2l\n        while (k > 0) {\n            if (k % 2 == 1) {\n\
    \                res = (res * y) % p\n            }\n            y = (y * y) %\
    \ p\n            k /= 2\n        }\n        return res", "        val (d, r) =\
    \ n /% p\n        (r + p) % p", "        var n2 = n\n        var p2 = p\n    \
    \    var r = (1l)\n        while (n2 > (0l)) {\n            if ((n2 & (1l)) >\
    \ (0l)) {\n                r = (((r * (2l)) % p2) + p2) % p2\n            }\n\
    \            n2 = n2 >> (1)\n            r = (((r * r) % p2) + p2) % p2\n    \
    \    }\n        return r", "        if (n < 0) modp(n + p, p)\n        else if\
    \ (n < p) n\n        else {\n            var x = 1L\n            var k = 0L\n\
    \            while (k < n) {\n                x = (x * 2) % p\n              \
    \  k += 1\n            }\n            x\n        }", "        def modp(n : Long,\
    \ m : Long, p : Long) : Long = {\n            if (m == 0) 1\n            else\
    \ if (m % 2 == 0) modp(n * n % p, m / 2, p)\n            else n * modp(n, m -\
    \ 1, p) % p\n        }\n        modp(n, n, p)", "        var result : Long = 1l\n\
    \        var power : Long = n\n        var exponent : Long = p\n        while\
    \ (exponent > 0) {\n            if ((exponent & 1) == 1) {\n                result\
    \ = (result * power) % p\n            }\n            power = (power * power) %\
    \ p\n            exponent = exponent >> 1\n        }\n        return result",
  "        var x = 1l\n        var pow = n\n        var res = 0l\n        for (i <-\
    \ 0 to 63) {\n            val d = pow % 2\n            pow /= 2\n            res\
    \ = (res + x * d) % p\n            x = (x * 2) % p\n        }\n        res", " \
    \       var res = 1l\n        var cn = n\n        while (cn > 0) {\n         \
    \   if ((cn & 1) == 1) res = (res * 2) % p\n            cn >>= 1\n        }\n\
    \        res", "      var pow = 1l\n      var pow2 = 2l\n      var pow2n = pow2\n\
    \      for (i <- 1 to n.toInt) {\n        pow = (pow * pow2n) % p\n        pow2n\
    \ = (pow2n * pow2) % p\n      }\n      return pow", "        if (n < 0 || p <\
    \ 0) throw new Exception(\"modulo: negative arguments\")\n        if (n == 0)\
    \ return 1\n        var ans = 1l\n        for (i <- (0 until n.toInt)) {\n   \
    \         ans = (ans * 2) % p\n        }\n        return ans", "        if (n\
    \ == 0) return 1\n        if (n % 2 == 0) {\n            val res = modp(n / 2,\
    \ p)\n            (res * res) % p\n        } else {\n            val res = modp(n\
    \ - 1, p)\n            ((2 * res) % p)\n        }", "        var i = 0l\n    \
    \    var val2 = 1l\n        while (i < n) {\n            val2 = (val2 * 2l) %\
    \ p\n            i += 1l\n        }\n        return val2", "        if (n == 0)\
    \ 1 else {\n            var res = 1l\n            var b = n\n            var a\
    \ = 2l\n            while (b > 0) {\n                if ((b & 1) == 1) res = (res\
    \ * a) % p\n                a = (a * a) % p\n                b = b >> 1\n    \
    \        }\n            res\n        }", "        def modp0(m : Long, a : Long,\
    \ b : Long) : Long = {\n            if (a == 0) return b\n            if (a %\
    \ 2 == 0) modp0(m, a / 2, b * 2 % m)\n            else modp0(m, a - 1, b * m %\
    \ a)\n        }\n        modp0(n, p, 1)", "        if (n == 0) 1\n        else\
    \ {\n            val mod = n % p\n            if (mod >= ((p / 2) + 1))\n    \
    \            ((mod - p) + 2)\n            else mod\n        }", "        val base\
    \ = Vector(1l, 2l)\n        var res = 0l\n        for (i <- (0 to 62).reverse)\
    \ {\n            res = (res * base(Math.abs(res * res * 2 - 1).toInt)).toLong\
    \ % p\n            if ((n & (1l << i)) != 0) {\n                res = (res * 2)\
    \ % p\n            }\n        }\n        res", "        if (n == 0) return 1\n\
    \        if (n == 1) return 2\n        val r = if (n % 2 == 0) modp(n / 2, p)\
    \ else 2 * modp(n - 1, p)\n        return if (r >= p) r % p else r", "       \
    \ if (n == 0) return 1\n        if (n == 1) return 2\n        if (n % 2 == 0)\
    \ {\n            val x = modp(n / 2, p)\n            return (x * x) % p\n    \
    \    }\n        (2 * modp(n - 1, p)) % p", "        var n1 = n\n        var p1\
    \ = p\n        if (n1 == 0) return 1\n        var res = 1l\n        var exp =\
    \ n1 % (p1 - 1)\n        var base = n1 % p1\n        while (exp > 0) {\n     \
    \       if (exp % 2 == 1) {\n                res = (res * base) % p1\n       \
    \     }\n            base = (base * base) % p1\n            exp = exp / 2\n  \
    \      }\n        return res", "        var s = BigInt(1)\n        var i = BigInt(0)\n\
    \        var p1 = BigInt(p)\n        var n1 = BigInt(n)\n        while(i < n1)\
    \ {\n            s = (s * 2) % p1\n            i += 1\n        }\n        s.toLong",
  "        val b = new StringBuilder()\n        b.append(n)\n        val digits =\
    \ b.reverse.toString\n        var out = 1l\n        for (i <- 0 until digits.length)\
    \ {\n            out = (out * out) % p\n            if (digits(i) == '1') out\
    \ = (out * 2) % p\n        }\n        out", "        val res = ((BigInt(2).modPow(n,\
    \ BigInt(p)) % p)).toLong\n        res", "        if (n == 0) return 1l\n    \
    \    if (n % 2 == 0) {\n            val t = modp(n / 2, p)\n            (t * t)\
    \ % p\n        } else {\n            (2 * modp(n - 1, p)) % p\n        }", " \
    \       if (n < 0) throw new Exception(\"n is negative\")\n        if (p < 0)\
    \ throw new Exception(\"p is negative\")\n        if (n == 0) return 1\n     \
    \   if (n == 1) return 2\n        if (n % 2 == 0) {\n            val m = modp(n\
    \ / 2, p)\n            return (m * m) % p\n        }\n        else {\n       \
    \     val m = modp(n - 1, p)\n            return (2 * m) % p\n        }", "  \
    \      if (n == 0) {\n            return 1\n        }\n        var result : Long\
    \ = modp(n / 2, p)\n        result = (result * result) % p\n        if (n % 2\
    \ == 1) {\n            result = (result * 2) % p\n        }\n        return result",
  "        var res = 1l\n        var temp = n\n        while (temp > 0) {\n      \
    \      if ((temp & 1) == 1) res = res * n % p\n            temp >>= 1\n      \
    \      n = n * n % p\n        }\n        res", "        if (n == 0) return 1\n\
    \        var result = 1l\n        var factor = 2l\n        var nn = n\n      \
    \  while (nn > 0) {\n            if (nn % 2 == 1) {\n                result =\
    \ (result * factor) % p\n            }\n            factor = (factor * factor)\
    \ % p\n            nn /= 2\n        }\n        return result", "        // 2^(k-1)\
    \ * 2^n_k * 2^(k-1) = 2^k * 2^(k-2) = 2^(2k-2)\n        // 2^(2k-2) = (2^k)^2\
    \ = (2^(k-1) * 2)^2\n        // 2^(2k-2) % p = ((2^(k-1) * 2)^2) % p\n       \
    \ // 2^(2k-2) % p = ((2^(k-1) % p) * (2 % p))^2 % p\n        // 2^(2k-2) % p =\
    \ ((2^(k-1) % p)^2 * (2 % p)^2) % p\n        // (since 2 % p = 2)\n        //\
    \ 2^(2k-2) % p = ((2^(k-1) % p)^2 * 4) % p\n        // 2^(2k-2) % p = ((2^(k-1)\
    \ % p)^2 * 2 * 2) % p\n        // 2^(2k-2) % p = ((2^(k-1) % p)^2 * 2) % p\n \
    \       // (mod is associative)\n        // 2^(2k-2) % p = ((2^(k-1) % p) * 2)\
    \ % p\n        // (mod is distributive)\n        // 2^(2k-2) % p = ((2^(k-1) %\
    \ p) * (2^1 % p)) % p\n        // 2^n % p = ((2^(k-1) % p) * (2^(n_k) % p)) %\
    \ p\n        // (where n = k + n_k)\n        // We can start with the k = 1 case.\n\
    \        // 2^1 % p = ((2^0 % p) * (2^1 % p)) % p\n        // 2^1 % p = ((1 %\
    \ p) * (2^1 % p)) % p\n        // 2^1 % p = ((1 % p) * (2 % p)) % p\n        //\
    \ 2^1 %", '        if (n == 0) 1l else ((2l * modp(n - 1, p)) % p)', "       \
    \ if (n < 0) return modp(n + p, p)\n        if (n < p) return n\n        if (n\
    \ == 0) return 1\n        if (n == p) return 0\n        if (n % 2 == 0) return\
    \ modp(n / 2, p) * modp(2, p) % p\n        else return modp(n / 2, p) * modp(2,\
    \ p) * modp(1, p) % p", "        //assert(p > 1)\n        if (n == 0) 1 else (1l\
    \ to n).foldLeft(1l)((x, y) => x * 2 % p)", "        var pmod = 1L\n        var\
    \ i = 0L\n        while (i < n) {\n            pmod = (pmod * 2L) % p\n      \
    \      i += 1L\n        }\n        return pmod", "        // For example, 5**3\
    \ mod 7 = 1 + 5 * (1 + 5 * (1 + 5 * 1)) mod 7 = 6\n        var result = 1l\n \
    \       var b = n\n        var e = p\n        while (e != 0) {\n            if\
    \ ((e & 1) != 0) result = (result * b) % p\n            e >>= 1\n            b\
    \ = (b * b) % p\n        }\n        return result", "        if (n < p) n\n  \
    \      else if (n % 2 == 0) modp(n/2, p) * 2 % p\n        else (modp(n/2, p) *\
    \ 2 + p - 1) % p", "        var res = 1l\n        var k = n\n        var b = 2l\n\
    \        while (k > 0) {\n            if (k % 2 == 1) {\n                res =\
    \ (res * b) % p\n            }\n            k = k / 2\n            b = (b * b)\
    \ % p\n        }\n        return res", "        if (n == 0) return 1\n       \
    \ if (n % 2 == 0) {\n            var tmp = modp(n / 2, p)\n            return\
    \ (tmp * tmp) % p\n        }\n        return (modp(n - 1, p) * 2) % p", "    \
    \    var r = 1l\n        var b = 2l\n        var e = n\n        while (e > 0)\
    \ {\n            if (e % 2 == 1) {\n                r = (r * b) % p\n        \
    \    }\n            e = e / 2\n            b = (b * b) % p\n        }\n      \
    \  return r", "        var pow = n\n        var ans = 1l\n        for (i <- 0\
    \ to 63) {\n            if ((pow & (1l << i)) != 0) {\n                ans = (ans\
    \ * 2l) % p\n            }\n        }\n        return ans", "        n match {\n\
    \            case 0 => 1\n            case 1 => 2\n            case _ => modp(n\
    \ - 1, p) * 2 % p\n        }", "        var ans = 1l\n        var pow = n\n  \
    \      while (p > 0) {\n            if ((p & 1) > 0) {\n                ans =\
    \ (ans * pow) % p\n            }\n            pow = (pow * pow) % p\n        \
    \    p >>= 1\n        }\n        return ans", "        var a = n\n        var\
    \ b = p\n        var pow = 1l\n        while (a != 0) {\n            if ((a &\
    \ 1) == 1) pow = (pow * b) % p\n            a = a >> 1\n            b = (b * b)\
    \ % p\n        }\n        pow", "        if (n == 0) {\n            1\n      \
    \  } else {\n            if (n % 2 == 0) {\n                val b = modp(n / 2,\
    \ p)\n                (b * b) % p\n            } else {\n                ((2 *\
    \ modp(n - 1, p)) % p)\n            }\n        }", "        var b = 1l\n     \
    \   var c = n\n        while (c > 0) {\n            if ((c & 1) == 1) {\n    \
    \            b = (b * n) % p\n            }\n            c >>= 1\n           \
    \ n = (n * n) % p\n        }\n        return b", "        var ret = 1l\n     \
    \   var pow = n\n        var mod = p\n        while (pow > 0) {\n            if\
    \ ((pow & 1) == 1) ret = (ret * n) % p\n            pow >>= 1\n            n =\
    \ (n * n) % p\n        }\n        return ret", "        if (n == 0) 1 else {\n\
    \            val x = modp(n / 2, p)\n            if (n % 2 == 0) (x * x) % p else\
    \ (x * x * 2) % p\n        }", "        n match {\n            case 0 => 1\n \
    \           case n if n % 2 == 0 => modp(n / 2, p) * modp(n / 2, p) % p\n    \
    \        case n => n * modp(n - 1, p) % p\n        }"]
stop_tokens:
- "\n    }\n"
