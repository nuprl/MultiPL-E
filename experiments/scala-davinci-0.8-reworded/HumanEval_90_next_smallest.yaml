name: HumanEval_90_next_smallest
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of integers.\n    // Write a function next_smallest()\
  \ that returns the 2nd smallest element of the list.\n    // Return None if there\
  \ is no such element.\n    // >>> nextSmallest((List[Long](1l.toLong, 2l.toLong,\
  \ 3l.toLong, 4l.toLong, 5l.toLong)))\n    // 2l\n    // >>> nextSmallest((List[Long](5l.toLong,\
  \ 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong)))\n    // 2l\n    // >>> nextSmallest((List[Long]()))\n\
  \    // None\n    // >>> nextSmallest((List[Long](1l.toLong, 1l.toLong)))\n    //\
  \ None\n    def nextSmallest(lst : List[Long]) : Option[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(nextSmallest((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))).equals(2l));\n    assert(nextSmallest((List[Long](5l.toLong,\
  \ 1l.toLong, 4l.toLong, 3l.toLong, 2l.toLong))).equals(2l));\n    assert(nextSmallest((List[Long]())).equals(None));\n\
  \    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));\n  \
  \  assert(nextSmallest((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(1l));\n\
  \    assert(nextSmallest((List[Long](1l.toLong, 1l.toLong))).equals(None));\n  \
  \  assert(nextSmallest((List[Long](-35l.toLong, 34l.toLong, 12l.toLong, -45l.toLong))).equals(-35l));\n\
  \    }\n\n}\n"
completions: ["        if (lst.length < 2) return None\n        var result = Long.MaxValue\n\
    \        var first = Long.MaxValue\n        var second = Long.MaxValue\n     \
    \   for (x <- lst) {\n            if (x <= first) {\n                second =\
    \ first\n                first = x\n            } else if (x < second) {\n   \
    \             second = x\n            }\n        }\n        if (second == Long.MaxValue)\
    \ return None\n        else return Some(second)", '        return lst.distinct.sorted.drop(1).headOption',
  "        if (lst.length < 2) return None\n        var smallest = Long.MaxValue\n\
    \        var secondSmallest = Long.MaxValue\n        for (v <- lst) {\n      \
    \      if (v < smallest) {\n                secondSmallest = smallest\n      \
    \          smallest = v\n            } else if (v < secondSmallest) {\n      \
    \          secondSmallest = v\n            }\n        }\n        if (secondSmallest\
    \ == Long.MaxValue) return None\n        return Some(secondSmallest)", "     \
    \   if (lst.length == 0) return None\n        if (lst.length == 1) return None\n\
    \        val lst2 = lst.sortWith(_ < _)\n        return Some(lst2(1))", "    \
    \    if (lst.length == 0) {\n            None\n        } else if (lst.length ==\
    \ 1) {\n            None\n        } else {\n            val m = scala.util.Sorting.stableSort(lst).tail\n\
    \            val a = m.head\n            val b = m.tail.head\n            val\
    \ s = if (a == b) None else Some(b)\n            s\n        }", "    \tif (lst.size\
    \ < 2) None\n    \telse {\n    \t\tval sl = lst.sortWith(_ < _)\n    \t\tvar min\
    \ = Long.MaxValue\n    \t\tfor (i <- 1 until sl.size) {\n    \t\t\tif (sl(i) -\
    \ sl(i - 1) < min) min = sl(i) - sl(i - 1)\n    \t\t}\n    \t\tif (min == Long.MaxValue)\
    \ None\n    \t\telse {\n    \t\t\tfor (i <- 1 until sl.size) {\n    \t\t\t\tif\
    \ (sl(i) - sl(i - 1) == min) return Some(sl(i))\n    \t\t\t}\n    \t\t\tNone\n\
    \    \t\t}\n    \t}", "        if (lst.length < 2) None\n        else {\n    \
    \        val sorted = lst.sorted\n            Some(sorted(1))\n        }", " \
    \       if (lst.length < 2) return None\n        var min1 = 1l.toLong; var min2\
    \ = 1l.toLong\n        lst.foreach(x => {\n            if (x < min1) {\n     \
    \           min2 = min1\n                min1 = x\n            }\n           \
    \ else if (x < min2) min2 = x\n        })\n        if (min1 == min2) return None\n\
    \        Some(min2)", "        if (lst.length < 2) return None\n        var m\
    \ = lst(0)\n        var m2 = lst(1)\n        for (i <- 2 until lst.length) {\n\
    \            if (lst(i) < m) {\n                m2 = m\n                m = lst(i)\n\
    \            } else if (lst(i) < m2) {\n                m2 = lst(i)\n        \
    \    }\n        }\n        return Some(m2)", "        if (lst.length < 2) {\n\
    \            None\n        } else {\n            var min = lst(0)\n          \
    \  var min2 = lst(1)\n            for (i <- 2 until lst.length) {\n          \
    \      if (lst(i) < min) {\n                    min2 = min\n                 \
    \   min = lst(i)\n                } else if (lst(i) < min2) {\n              \
    \      min2 = lst(i)\n                }\n            }\n            if (min ==\
    \ min2) {\n                None\n            } else {\n                Some(min2)\n\
    \            }\n        }", "        if (lst.size <= 1) return None\n        else\
    \ {\n            val sortedLst = lst.sorted\n            for (i <- 1 until sortedLst.size)\
    \ if (sortedLst(i) != sortedLst(i - 1)) return Some(sortedLst(i))\n          \
    \  return None\n        }", "        if (lst.length < 2) None\n        else {\n\
    \            var min = lst(0)\n            var min2 = min\n            for (i\
    \ <- 0 until lst.length) {\n                if (lst(i) < min) {\n            \
    \        min2 = min\n                    min = lst(i)\n                }\n   \
    \             else if (lst(i) < min2 && lst(i) != min) min2 = lst(i)\n       \
    \     }\n            if (min2 == min) None\n            else Some(min2)\n    \
    \    }", "      if (lst.size < 2) None\n      else {\n        var min = lst(0)\n\
    \        var min2 = lst(1)\n        for (e <- lst) {\n          if (e < min) {\n\
    \            min2 = min\n            min = e\n          }\n          else if (e\
    \ < min2) min2 = e\n        }\n        if (min2 == min) None\n        else Some(min2)\n\
    \      }", "        if (lst.length <= 1) None\n        else if (lst.length ==\
    \ 2) if (lst(0) == lst(1)) None else Some(lst(1))\n        else {\n          \
    \  val sorted = lst.sorted\n            val result = sorted.zipWithIndex.filter(item\
    \ => item._2 != 0 && item._1 != sorted(item._2 - 1)).map(item => item._1).distinct\n\
    \            if (result.length == 0) None else Some(result(0))\n        }", " \
    \       if (lst.length < 2) None\n        else {\n            var smallest = Long.MaxValue\n\
    \            var secondSmallest = Long.MaxValue\n            for (n <- lst) {\n\
    \                if (n < smallest) {\n                    secondSmallest = smallest\n\
    \                    smallest = n\n                }\n                else if\
    \ (n < secondSmallest) {\n                    secondSmallest = n\n           \
    \     }\n            }\n            if (secondSmallest == Long.MaxValue) None\n\
    \            else Some(secondSmallest)\n        }", "        val s = lst.sorted\n\
    \        s.size match {\n            case 0 => None\n            case 1 => None\n\
    \            case _ => {\n                var prev = s(0)\n                for\
    \ (i <- 1 until s.size) {\n                    if (s(i) != prev) return Some(s(i))\n\
    \                    prev = s(i)\n                }\n                None\n  \
    \          }\n        }", "        var sortedLst = lst.sorted\n        if (sortedLst.length\
    \ < 2) None\n        else Some(sortedLst(1))", "        val set = lst.toSet\n\
    \        if (set.size == 0) None\n        else if (set.size == 1) None\n     \
    \   else {\n            val min = set.min\n            val set2 = set - min\n\
    \            Some(set2.min)\n        }", "        if (lst.length == 0) None\n\
    \        else if (lst.length == 1) None\n        else {\n            var result\
    \ = lst(0)\n            for (i <- 1 until lst.length) {\n                if (lst(i)\
    \ < result) result = lst(i)\n            }\n            result = lst(0)\n    \
    \        for (i <- 1 until lst.length) {\n                if (lst(i) < result\
    \ && lst(i) != result) result = lst(i)\n            }\n            Some(result)\n\
    \        }", "        var min = lst.head\n        var secondMin = Long.MaxValue\n\
    \        for (i <- lst) {\n            if (i < min) {\n                secondMin\
    \ = min\n                min = i\n            } else if (i > min && i < secondMin)\
    \ {\n                secondMin = i\n            }\n        }\n        if (secondMin\
    \ == Long.MaxValue) {\n            None\n        } else {\n            Some(secondMin)\n\
    \        }", "      var small = Long.MaxValue\n      var ssmall = Long.MaxValue\n\
    \      for (x <- lst) {\n        if (x <= small) {\n          ssmall = small\n\
    \          small = x\n        } else if (x < ssmall) {\n          ssmall = x\n\
    \        }\n      }\n      if (ssmall == Long.MaxValue) None else Some(ssmall)",
  "        if (lst.size == 0) return None\n        var min = lst(0)\n        var min2\
    \ = min\n        for (i <- 0 until lst.size) {\n            if (lst(i) < min)\
    \ {\n                min2 = min\n                min = lst(i)\n            } else\
    \ if (lst(i) < min2) {\n                min2 = lst(i)\n            }\n       \
    \ }\n        if (min2 == min) None else Some(min2)", "        val sorted = lst.sorted\n\
    \        if (sorted.length < 2) None\n        else Option(sorted(1))", "     \
    \   lst.sorted.distinct match {\n            case Nil => None\n            case\
    \ a :: Nil => None\n            case a :: rest => Some(rest.head)\n        }",
  "        if (lst.length == 0) return None\n        val sorted = lst.sorted\n   \
    \     if (sorted(0) == sorted(1)) return None\n        return Some(sorted(1))",
  "        val sorted = lst.sorted\n        if (sorted.length > 1) Some(sorted(1))\
    \ else None", "        if (lst.length <= 1) return None\n        val n = lst.length\n\
    \        val mm = new MinMaxStack()\n        val mn = new MinMaxStack()\n    \
    \    for (i <- 0 until n) {\n            mm.push(lst(i))\n            mn.push(lst(n\
    \ - 1 - i))\n        }\n        var i = 0\n        var last = mm.pop()\n     \
    \   var result = -1l\n        while (i < n) {\n            val cur = mm.pop()\n\
    \            if (cur != last) {\n                if (result != -1l) return Some(result)\n\
    \                result = cur\n            }\n            last = cur\n       \
    \     i += 1\n        }\n        if (result == -1l) return None\n        i = 0\n\
    \        last = mn.pop()\n        while (i < n) {\n            val cur = mn.pop()\n\
    \            if (cur != last) {\n                if (cur == result) return Some(result)\n\
    \                if (cur < result) return None\n            }\n            last\
    \ = cur\n            i += 1\n        }\n        None", "        def loop(lst :\
    \ List[Long], mn : Long, mn2 : Long) : Option[Long] = {\n            if (lst.length\
    \ == 0) Some(mn2)\n            else {\n                val n = lst.head\n    \
    \            if (n < mn) loop(lst.tail, n, mn)\n                else if (n > mn\
    \ && n < mn2) loop(lst.tail, mn, n)\n                else loop(lst.tail, mn, mn2)\n\
    \            }\n        }\n        if (lst.length <= 1) None\n        else loop(lst.tail,\
    \ lst.head, lst.head)", "        if (lst.size < 2) return None\n        var min\
    \ = lst(0)\n        var min2 = lst(1)\n        if (min > min2) {\n           \
    \ min = lst(1)\n            min2 = lst(0)\n        }\n        for (i <- 2 until\
    \ lst.size) {\n            if (lst(i) < min) {\n                min2 = min\n \
    \               min = lst(i)\n            } else if (lst(i) < min2) {\n      \
    \          min2 = lst(i)\n            }\n        }\n        return Some(min2)",
  "        def nextSmallest(smallest : Long, lst : List[Long]) : Option[Long] = {\n\
    \            lst match {\n                case Nil => None\n                case\
    \ x :: xs => {\n                    if (xs == Nil) None\n                    else\
    \ if (xs.head != smallest) Some(xs.head)\n                    else {\n       \
    \                 val nextSmallest = (xs.head min xs.tail.head)\n            \
    \            nextSmallest(nextSmallest, xs)\n                    }\n         \
    \       }\n            }\n        }\n        lst match {\n            case Nil\
    \ => None\n            case x :: xs => {\n                val smallest = (x min\
    \ xs.head)\n                nextSmallest(smallest, xs)\n            }\n      \
    \  }", '        return next_smallest_2(lst, None)', "        if (lst.size < 2)\
    \ return None\n        val sorted = lst.sorted\n        for (i <- 0 until sorted.size\
    \ - 1) {\n            if (sorted(i) != sorted(i + 1)) return Some(sorted(i + 1))\n\
    \        }\n        None", "        lst.sortWith(_ < _) match {\n            case\
    \ List() => None\n            case h :: t => if (h == t.head) None else Some(t.head)\n\
    \        }", "        var secondSmallest : Option[Long] = None\n        for (elm\
    \ <- lst) {\n            if (secondSmallest == None) {\n                secondSmallest\
    \ = Some(elm)\n            } else if (elm < secondSmallest.get) {\n          \
    \      secondSmallest = Some(elm)\n            }\n        }\n        secondSmallest",
  "        val max = lst.max\n        val min = lst.min\n        val minlst = lst.filter(x\
    \ => x != min)\n        if (minlst.isEmpty) None\n        else Some(minlst.min)",
  "        if (lst.length == 0) return None\n        var min = Long.MaxValue\n   \
    \     var min2 = Long.MaxValue\n        for (x <- lst) {\n            if (x <\
    \ min) {\n                min2 = min\n                min = x\n            } else\
    \ if (x < min2) {\n                min2 = x\n            }\n        }\n      \
    \  if (min2 == Long.MaxValue) return None\n        return Some(min2)", "     \
    \   var min = Long.MaxValue\n        var min2 = Long.MaxValue\n        for (v\
    \ <- lst) {\n            if (v < min) {\n                min2 = min\n        \
    \        min = v\n            } else if (v < min2) {\n                min2 = v\n\
    \            }\n        }\n        if (min2 != Long.MaxValue) Some(min2) else\
    \ None", "        val sorted = lst.sorted\n        val nextSmallest = sorted.drop(1).dropWhile(_\
    \ == sorted.head)\n        if (nextSmallest.isEmpty) None else Some(nextSmallest.head)",
  "        var x : List[Long] = lst.sortWith(_ < _)\n        if (x.length == 0) return\
    \ None\n        if (x.length == 1) return None\n        var m = x(0)\n       \
    \ for (i <- 1 until x.length) {\n            if (x(i) > m) return Some(x(i))\n\
    \        }\n        return None", '        lst.sorted.toSet.toList.lift(1)', '        return
    None', "        // if there are only 1 or 0 elements, return None.\n        if\
    \ (lst.length <= 1) None\n        // init min to the first element of lst.\n \
    \       else {\n            var min = lst(0)\n            // init second min to\
    \ the first element of lst.\n            var secondMin = lst(0)\n            //\
    \ go through each element in lst and update min and second min.\n            for\
    \ (i <- 0 until lst.length) {\n                // update min if it's smaller than\
    \ the current element.\n                if (lst(i) < min) {\n                \
    \    secondMin = min\n                    min = lst(i)\n                }\n  \
    \              // update second min if it's smaller than the current element but\
    \ bigger than min.\n                else if (lst(i) < secondMin && lst(i) > min)\
    \ {\n                    secondMin = lst(i)\n                }\n            }\n\
    \            // return the second min if it's not the same as min.\n         \
    \   if (secondMin != min) Some(secondMin)\n            // otherwise return None.\n\
    \            else None\n        }", "        var min = Long.MaxValue\n       \
    \ var secondMin = Long.MaxValue\n        for (i <- lst) {\n            if (i <\
    \ min) {\n                secondMin = min\n                min = i\n         \
    \   } else if (i < secondMin) {\n                secondMin = i\n            }\n\
    \        }\n        if (secondMin == Long.MaxValue) None else Some(secondMin)",
  "        val set = new TreeSet[Long]()\n        for (x <- lst) {\n            set.add(x)\n\
    \        }\n        if (set.size < 2) None else Some(set.iterator.drop(1).next)",
  "        if (lst.length < 2) return None\n        val sorted = lst.sorted\n    \
    \    return Some(sorted(1))", "        if (lst.size == 0) None\n        else if\
    \ (lst.size == 1) None\n        else {\n            var firstMin = Long.MaxValue\n\
    \            var secondMin = Long.MaxValue\n            for (i <- 0 until lst.size)\
    \ {\n                val e = lst(i)\n                if (e < firstMin) {\n   \
    \                 secondMin = firstMin\n                    firstMin = e\n   \
    \             }\n                else if (e < secondMin) {\n                 \
    \   secondMin = e\n                }\n            }\n            if (secondMin\
    \ == Long.MaxValue) None\n            else Some(secondMin)\n        }", "    \
    \    if (lst.size < 2) None\n        else {\n            var second = Long.MaxValue\n\
    \            var smallest = Long.MaxValue\n            for (i <- 0 until lst.size)\
    \ {\n                if (lst(i) < smallest) {\n                    second = smallest\n\
    \                    smallest = lst(i)\n                }\n                else\
    \ if (lst(i) < second) {\n                    second = lst(i)\n              \
    \  }\n            }\n            if (second == Long.MaxValue) None\n         \
    \   else Some(second)\n        }", "        if (lst.size < 2) None\n        else\
    \ {\n            val distinctSorted = lst.distinct.sorted\n            val min\
    \ = distinctSorted.head\n            val lstSorted = distinctSorted.tail\n   \
    \         lstSorted.find {x => x > min}\n        }", "        // Create a dictionary\
    \ of the occurences of each element\n        val counter = lst.foldLeft(Map[Long,\
    \ Int]()){\n            (map, e) => map + (e -> (map.getOrElse(e, 0) + 1))\n \
    \       }\n        // Find the 2nd smallest element\n        val m2 = lst.foldLeft(Option[Long](Long.MaxValue)){\n\
    \            (m, e) => {\n                val m2 = if (e < m.get) e else m.get\n\
    \                if (counter(m2) == 1) {\n                    Some(m2)\n     \
    \           } else {\n                    m\n                }\n            }\n\
    \        }\n        if (m2.get != Long.MaxValue) {\n            m2\n        }\
    \ else {\n            None\n        }", "        val sorted = lst.sorted\n   \
    \     for (i <- 1 until sorted.length) {\n            if (sorted(i) != sorted(i\
    \ - 1)) return Some(sorted(i))\n        }\n        None", "      val n = lst.size\n\
    \      if (n < 2) None\n      else if (n == 2) if (lst(0) == lst(1)) None else\
    \ Some(lst(1))\n      else {\n        val indexs = for (i <- 0 until n) yield\
    \ (i, lst(i))\n        val indexsSorted = indexs.sortBy(p => p._2)\n        var\
    \ ns = None : Option[Long]\n        var prev = -1l\n        for (i <- 0 until\
    \ n) {\n          if (indexsSorted(i)._2 != prev) {\n            ns = Some(indexsSorted(i)._2)\n\
    \            prev = indexsSorted(i)._2\n          }\n          else {\n      \
    \      if (ns != None) {\n              return ns\n            }\n          }\n\
    \        }\n        None\n      }", "        if (lst.length < 2) return None\n\
    \        var currentMin = Long.MaxValue\n        var secondMin = Long.MaxValue\n\
    \        for (i <- 0 until lst.length) {\n            if (lst(i) < currentMin)\
    \ {\n                secondMin = currentMin\n                currentMin = lst(i)\n\
    \            } else if (lst(i) < secondMin) {\n                secondMin = lst(i)\n\
    \            }\n        }\n        if (secondMin == Long.MaxValue) return None\n\
    \        return Some(secondMin)", "        val min = lst.foldLeft(Long.MaxValue)((min,\
    \ x) => min min x)\n        val n = lst.filter(_ != min).length\n        if (n\
    \ == 0) None\n        else Some(lst.filter(_ != min).foldLeft(Long.MaxValue)((min,\
    \ x) => min min x))", '        None', "        val sorted = lst.sorted\n     \
    \   var smallest : Option[Long] = None\n        var seen = false\n        for\
    \ (e <- sorted) {\n            if (seen) {\n                return Some(e)\n \
    \           }\n            if (smallest == None) {\n                smallest =\
    \ Some(e)\n            } else if (smallest.get != e) {\n                seen =\
    \ true\n            }\n        }\n        None", "    \tval s = lst.toSet\n  \
    \  \tif (s.size == 0) None\n    \telse if (s.size == 1) None\n    \telse if (s.size\
    \ == 2) if (s.head == s.last) None else Some(s.head)\n    \telse Some(s.toList.sorted.apply(1))",
  "        if (lst.length <= 1) None\n        else {\n            val min = lst.min\n\
    \            val minList = lst.filter(_ == min)\n            val leftList = lst.filter(_\
    \ > min)\n            if (leftList.length > 0) Some(leftList.min)\n          \
    \  else if (minList.length >= 2) Some(minList(1))\n            else None\n   \
    \     }", "        // We use a heap, but we must use a min-heap and not a max-heap\n\
    \        // Then, we pop 2 elements from the heap and return the 2nd element\n\
    \        val heap = new scala.collection.mutable.PriorityQueue[Long]()\n     \
    \   for (element <- lst) heap.enqueue(element)\n        if (heap.size < 2) return\
    \ None\n        heap.dequeue\n        Some(heap.dequeue)", "        var current\
    \ : Option[Long] = None\n        for (x <- lst) {\n            if (current ==\
    \ None) current = Some(x)\n            else if (x > current.get) {\n         \
    \       val t = current.get\n                current = Some(x)\n             \
    \   return Some(t)\n            }\n        }\n        None", "        if (lst.length\
    \ == 0) None\n        else {\n            val x = lst.toArray\n            util.Sorting.quickSort(x)\n\
    \            val y = x.toList\n            if (y.length == 1) None\n         \
    \   else {\n                val min = y.min\n                val y2 = y.filter(_\
    \ != min)\n                if (y2.length == 0) None\n                else Some(y2.min)\n\
    \            }\n        }", "        var min1 = Long.MaxValue\n        var min2\
    \ = Long.MaxValue\n        for (el <- lst) {\n            if (el < min1) {\n \
    \               min2 = min1\n                min1 = el\n            } else if\
    \ (el < min2) {\n                min2 = el\n            }\n        }\n       \
    \ if (min2 == Long.MaxValue) None else Some(min2)", "      val set = new TreeSet[Long]\n\
    \      for (i <- lst) set += i\n      if (set.size == 0) None\n      else {\n\
    \        var result : Option[Long] = None\n        var iter = set.iterator\n \
    \       while (iter.hasNext) {\n          val v = iter.next\n          if (result\
    \ == None) result = Some(v)\n          else return Some(v)\n        }\n      \
    \  None\n      }", "        val list = lst.toArray.sorted\n        if (list.length\
    \ > 1) {\n            val result = list(1)\n            Some(result)\n       \
    \ } else None", "        if (lst.size <= 1) return None\n        var lst2 = lst.sorted\n\
    \        if (lst2(0) == lst2(1)) {\n            lst2 = lst2.drop(1)\n        }\n\
    \        Some(lst2(1))", '        return lst.sortWith(_ < _).distinct.lift(1)',
  "        if (lst.size < 2) return None\n        var secondMin = Long.MaxValue\n\
    \        var min = Long.MaxValue\n        for (i <- 0 until lst.size) {\n    \
    \        if (lst(i) < min) {\n                secondMin = min\n              \
    \  min = lst(i)\n            } else if (lst(i) < secondMin) {\n              \
    \  secondMin = lst(i)\n            }\n        }\n        if (secondMin == Long.MaxValue)\
    \ return None\n        return Some(secondMin)", "        var min = Long.MaxValue\n\
    \        var min2 = Long.MaxValue\n        for (n <- lst) {\n            if (n\
    \ < min) {\n                min2 = min\n                min = n\n            }\
    \ else if (n < min2) {\n                min2 = n\n            }\n        }\n \
    \       if (min2 == Long.MaxValue) None else Some(min2)", "        if (lst.size\
    \ < 2) return None\n        var h = new HashMap[Long, Long]()\n        for (x\
    \ <- lst) {\n            if (h.contains(x)) h(x) += 1 else h(x) = 1\n        }\n\
    \        val s = h.toList.sortWith((x, y) => x._1 < y._1)\n        var c = s(0)._2\n\
    \        var d = false\n        for (x <- s) {\n            if (x._2 > c) {\n\
    \                c = x._2\n                d = true\n            }\n         \
    \   else if (x._2 == c && d) return Some(x._1)\n        }\n        return None",
  "        if (lst.length < 2) return None\n        if (lst.length == 2) return if\
    \ (lst(0) == lst(1)) None else Some(lst(1))\n        val min = lst.min\n     \
    \   val secondSmallest = (ListBuffer[Long]() ++ lst).remove(lst.indexOf(min)).min\n\
    \        Some(secondSmallest)", "        if (lst.length == 0) return None\n  \
    \      var min = Long.MaxValue\n        var min2 = Long.MaxValue\n        for\
    \ (i <- 0 until lst.length) {\n            val e = lst(i)\n            if (e <\
    \ min) {\n                min2 = min\n                min = e\n            } else\
    \ if (e < min2) {\n                min2 = e\n            }\n        }\n      \
    \  if (min2 == Long.MaxValue) None else Some(min2)", "        if (lst.length <\
    \ 2) return None\n        val sorted = lst.sorted\n        if (sorted(0) == sorted(1))\
    \ return None\n        Some(sorted(1))", "        if (lst.size < 2) return None\n\
    \        var min1 = Long.MaxValue\n        var min2 = Long.MaxValue\n        for\
    \ (v <- lst) {\n            if (v < min1) {\n                min2 = min1\n   \
    \             min1 = v\n            } else if (v < min2) {\n                min2\
    \ = v\n            }\n        }\n        if (min2 == Long.MaxValue) return None\n\
    \        return Some(min2)", "        val lstSorted = lst.sorted\n        if (lstSorted.length\
    \ < 2) None\n        else if (lstSorted(0) == lstSorted(1)) None\n        else\
    \ Some(lstSorted(1))", "        var smallest : Long = Long.MaxValue\n        var\
    \ secondSmallest : Long = Long.MaxValue\n        for (elem <- lst) {\n       \
    \     if (elem < smallest) {\n                secondSmallest = smallest\n    \
    \            smallest = elem\n            } else if (elem < secondSmallest) {\n\
    \                secondSmallest = elem\n            }\n        }\n        if (secondSmallest\
    \ == Long.MaxValue) None else Some(secondSmallest)", "        var s = new Stack[Long]\n\
    \        for (i <- lst) {\n            while (!s.isEmpty && s.top >= i) s.pop\n\
    \            if (!s.isEmpty) return Some(i)\n            s.push(i)\n        }\n\
    \        None", "        val set = lst.toSet\n        if (set.size < 2) None\n\
    \        else {\n            Some(set.toList.sorted.drop(1).head)\n        }",
  "        var index = 0\n        var prev = None : Option[Long]\n        var min\
    \ = Long.MaxValue\n        var secondMin = Long.MaxValue\n        while (index\
    \ < lst.length) {\n            val n = lst(index)\n            if (n < min) {\n\
    \                secondMin = min\n                min = n\n            } else\
    \ if (n < secondMin) {\n                secondMin = n\n            }\n       \
    \     index += 1\n        }\n        if (secondMin == Long.MaxValue) {\n     \
    \       None\n        } else {\n            Some(secondMin)\n        }", "   \
    \     if (lst.length <= 1) {\n            None\n        } else {\n           \
    \ var nextSmallest : Option[Long] = None\n            var smallest : Long = lst(0)\n\
    \            for (n <- lst) {\n                if (n < smallest) {\n         \
    \           nextSmallest = Some(smallest)\n                    smallest = n\n\
    \                } else if (n > smallest && (nextSmallest == None || n < nextSmallest.get))\
    \ {\n                    nextSmallest = Some(n)\n                }\n         \
    \   }\n            nextSmallest\n        }", "        var min = Long.MaxValue\n\
    \        var min2 = Long.MaxValue\n        for (i <- lst) {\n            if (i\
    \ < min) {\n                min2 = min\n                min = i\n            }\
    \ else if (i < min2) {\n                min2 = i\n            }\n        }\n \
    \       if (min2 == Long.MaxValue) None else Some(min2)", "        val sortedLst\
    \ = lst.sorted\n        val result = sortedLst match {\n            case a ::\
    \ b :: tail => {\n                if (a != b) {\n                    Some(b)\n\
    \                } else {\n                    None\n                }\n     \
    \       }\n            case _ => None\n        }\n        result", "    \tval\
    \ list = lst.sorted\n    \tif (list.length == 0) None\n    \telse if (list.length\
    \ == 1) None\n    \telse Some(list(1))", "        if (lst.size < 2) None\n   \
    \     else {\n            var min = lst(0)\n            var min2 = lst(1)\n  \
    \          if (min > min2) {\n                min = lst(1)\n                min2\
    \ = lst(0)\n            }\n            for (num <- lst) {\n                if\
    \ (num < min) {\n                    min2 = min\n                    min = num\n\
    \                }\n                else if (num < min2) {\n                 \
    \   min2 = num\n                }\n            }\n            if (min2 == min)\
    \ None\n            else Some(min2)\n        }", "        val sorted = lst.sorted\n\
    \        if (sorted.length == 0) None\n        else if (sorted.length == 1) None\n\
    \        else Some(sorted(1))", "        if (lst.length < 2) return None\n   \
    \     return Some(lst.distinct.sorted.tail.head)", "      var count = 0\n    \
    \  var min = Long.MaxValue\n      var secondMin = Long.MaxValue\n      for (i\
    \ <- lst) {\n        if (i < min) {\n          secondMin = min\n          min\
    \ = i\n        } else if (i < secondMin) {\n          secondMin = i\n        }\n\
    \      }\n      if (secondMin == Long.MaxValue) {\n        None\n      } else\
    \ {\n        Some(secondMin)\n      }", "        if (lst.length < 2) return None\n\
    \        var smallest = lst(0)\n        var secondSmallest = lst(1)\n        var\
    \ thirdSmallest = lst(0)\n        for (i <- 2 until lst.length) {\n          \
    \  if (lst(i) < thirdSmallest) {\n                if (lst(i) < secondSmallest)\
    \ {\n                    if (lst(i) < smallest) {\n                        thirdSmallest\
    \ = secondSmallest\n                        secondSmallest = smallest\n      \
    \                  smallest = lst(i)\n                    } else {\n         \
    \               thirdSmallest = secondSmallest\n                        secondSmallest\
    \ = lst(i)\n                    }\n                } else {\n                \
    \    thirdSmallest = lst(i)\n                }\n            }\n        }\n   \
    \     if (secondSmallest != smallest) return Some(secondSmallest)\n        else\
    \ return None", "        val ns = new HashSet[Long]\n        for (x <- lst) {\n\
    \            if (ns.size == 2) return Some(ns.last)\n            ns += x\n   \
    \     }\n        None", "        if (lst.length == 0) return None\n        var\
    \ min : Long = lst(0)\n        var min2 : Long = lst(0)\n        for (x <- lst)\
    \ {\n            if (x < min) {\n                min2 = min\n                min\
    \ = x\n            } else if (x < min2) {\n                min2 = x\n        \
    \    }\n        }\n        if (min2 == min) return None\n        Some(min2)",
  "        if (lst.length < 2) return None\n        var min1 = Long.MaxValue\n   \
    \     var min2 = Long.MaxValue\n        for (n <- lst) {\n            if (n <\
    \ min1) {\n                min2 = min1\n                min1 = n\n           \
    \ } else if (n < min2) {\n                min2 = n\n            }\n        }\n\
    \        if (min2 == Long.MaxValue) return None\n        return Some(min2)", " \
    \       if (lst.length < 2) {\n            None\n        } else {\n          \
    \  var lst2 = lst.sorted\n            var lst3 = lst2.distinct\n            if\
    \ (lst3.length < 2) {\n                None\n            } else {\n          \
    \      Some(lst3(1))\n            }\n        }", "        if (lst.size <= 1) return\
    \ None\n        var min = lst(0)\n        var next = Long.MaxValue\n        for\
    \ (i <- 1 until lst.size) {\n            if (lst(i) < min) {\n               \
    \ next = min\n                min = lst(i)\n            } else if (lst(i) < next)\
    \ {\n                next = lst(i)\n            }\n        }\n        if (next\
    \ == Long.MaxValue) return None\n        return Some(next)", "        if (lst.length\
    \ == 0) None\n        else {\n            var min = lst(0)\n            var min2\
    \ = min\n            for (i <- 1 until lst.length) {\n                if (lst(i)\
    \ < min) {\n                    min2 = min\n                    min = lst(i)\n\
    \                }\n                else if (lst(i) < min2) min2 = lst(i)\n  \
    \          }\n            if (min2 == min) None\n            else Some(min2)\n\
    \        }", "        if (lst.length == 0) return None\n        if (lst.length\
    \ == 1) return None\n        var lst1 = lst.distinct\n        if (lst1.length\
    \ == 1) return None\n        lst1 = lst1.sorted\n        return Some(lst1(1))",
  "        lst.sortWith(_ < _).distinct match {\n            case a :: b :: _ => Some(b)\n\
    \            case _ => None\n        }", "        if (lst.length < 2) return None\n\
    \        var min = lst(0)\n        var min2 = min\n        for (i <- 1 until lst.length)\
    \ {\n            if (lst(i) < min) {\n                min2 = min\n           \
    \     min = lst(i)\n            } else if (lst(i) < min2) {\n                min2\
    \ = lst(i)\n            }\n        }\n        if (min == min2) None else Some(min2)",
  "      val set = new TreeSet[Long]\n      for (x <- lst) set += x\n      val it\
    \ = set.iterator\n      val result = if (it.hasNext) it.next else return None\n\
    \      if (it.hasNext) Some(it.next) else None", "        if (lst.length < 2)\
    \ None\n        else {\n            var min = lst(0)\n            var nextMin\
    \ = Long.MaxValue\n            for (i <- 1 until lst.length) {\n             \
    \   if (lst(i) < min) {\n                    nextMin = min\n                 \
    \   min = lst(i)\n                }\n                else if (lst(i) < nextMin)\
    \ nextMin = lst(i)\n            }\n            if (nextMin == Long.MaxValue) None\n\
    \            else Some(nextMin)\n        }", "      if (lst.size < 2) {\n    \
    \    None\n      } else {\n        val min = lst.min\n        var min2 = Long.MaxValue\n\
    \        for (num <- lst) {\n          if (num > min && num < min2) {\n      \
    \      min2 = num\n          }\n        }\n        if (min2 == Long.MaxValue)\
    \ {\n          None\n        } else {\n          Some(min2)\n        }\n     \
    \ }", "    \tval set = scala.collection.mutable.Set[Long]()\n    \tvar res : Option[Long]\
    \ = None\n    \tfor (x <- lst) {\n    \t\tif (set.size == 2) {\n    \t\t\tval\
    \ y = set.min\n    \t\t\tif (x > y) {\n    \t\t\t\tres = Some(x)\n    \t\t\t\t\
    return res\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\tset.remove(y)\n    \t\t\
    \t\tset.add(x)\n    \t\t\t}\n    \t\t}\n    \t\telse {\n    \t\t\tset.add(x)\n\
    \    \t\t}\n    \t}\n    \treturn res", "        var smallest = None : Option[Long]\n\
    \        var secondSmallest = None : Option[Long]\n        for (element <- lst)\
    \ {\n            if (smallest == None) {\n                smallest = Some(element)\n\
    \            } else if (element < smallest.get) {\n                secondSmallest\
    \ = smallest\n                smallest = Some(element)\n            } else if\
    \ (secondSmallest == None || element < secondSmallest.get) {\n               \
    \ secondSmallest = Some(element)\n            }\n        }\n        return secondSmallest",
  "        val sorted = lst.sorted\n        if (sorted.size < 2) return None\n   \
    \     for (i <- 1 until sorted.size) {\n            if (sorted(i) != sorted(i\
    \ - 1)) return Some(sorted(i))\n        }\n        None", "        if (lst.length\
    \ <= 1) {\n            None\n        } else {\n            var n = lst.length\n\
    \            val sortedlst = lst.sorted\n            var m = Long.MaxValue\n \
    \           var m2 = Long.MaxValue\n            for (i <- 0 until n - 1) {\n \
    \               if (sortedlst(i) != sortedlst(i + 1)) {\n                    m\
    \ = min(m, sortedlst(i + 1))\n                }\n            }\n            for\
    \ (i <- 0 until n - 1) {\n                if (sortedlst(i) != sortedlst(i + 1)\
    \ && sortedlst(i + 1) != m) {\n                    m2 = min(m2, sortedlst(i +\
    \ 1))\n                }\n            }\n            if (m2 == Long.MaxValue)\
    \ {\n                None\n            } else {\n                Some(m2)\n  \
    \          }\n        }", "        if (lst.length < 2) {\n            None\n \
    \       } else {\n            val lst2 = lst.sortWith((a, b) => a < b)\n     \
    \       var prev = lst2(0)\n            var i = 1\n            while (i < lst2.length)\
    \ {\n                if (lst2(i) > prev) {\n                    return Some(lst2(i))\n\
    \                }\n                prev = lst2(i)\n                i += 1\n \
    \           }\n            None\n        }", "        if (lst.length < 2) None\n\
    \        else {\n            var sorted = lst.sorted\n            var current\
    \ = sorted(0)\n            for (i <- 1 until sorted.length) {\n              \
    \  if (sorted(i) > current) return Some(sorted(i))\n                current =\
    \ sorted(i)\n            }\n            None\n        }", "        val m = new\
    \ MinHeap[Long]\n        for (e <- lst) m.insert(e)\n        if (m.isEmpty) return\
    \ None\n        m.deleteMin\n        if (m.isEmpty) return None\n        Some(m.deleteMin)",
  "        if (lst.length < 2) return None\n        var maximum = lst(0)\n       \
    \ var second = lst(1)\n        if (second > maximum) {\n            var temp =\
    \ maximum\n            maximum = second\n            second = temp\n        }\n\
    \        for (i <- 1 until lst.length) {\n            if (lst(i) > maximum) {\n\
    \                second = maximum\n                maximum = lst(i)\n        \
    \    } else if (lst(i) < maximum && lst(i) > second) {\n                second\
    \ = lst(i)\n            }\n        }\n        if (second == maximum) None else\
    \ Some(second)", "        var sorted = lst.sorted\n        sorted = sorted.filter(e\
    \ => e > 0)\n        if (sorted.size < 2) None\n        else Some(sorted(1))",
  '        return lst.distinct.sortWith(_ < _).drop(1).headOption', "        if (lst.length\
    \ <= 1) None\n        else {\n            var mx = lst(0)\n            var mn\
    \ = lst(0)\n            var mn2 = lst(0)\n            for (i <- 0 until lst.length)\
    \ {\n                val x = lst(i)\n                if (x > mx) mx = x\n    \
    \            if (x < mn) {\n                    mn2 = mn\n                   \
    \ mn = x\n                }\n                else if (x < mn2) mn2 = x\n     \
    \       }\n            if (mn2 == mn) None\n            else Some(mn2)\n     \
    \   }", "        val sorted = lst.sorted\n        if (sorted.size == 0) None\n\
    \        else if (sorted.size == 1) None\n        else Some(sorted(1))", "   \
    \     if (lst.length <= 1) None\n        else {\n            var unique = lst.toSet\n\
    \            unique.remove(unique.min)\n            if (unique.size > 0) Some(unique.min)\n\
    \            else None\n        }", "        if (lst.size == 0) None\n       \
    \ else if (lst.size == 1) None\n        else {\n            var result = lst(0)\n\
    \            for (i <- 1 until lst.size) {\n                if (lst(i) < result)\
    \ result = lst(i)\n            }\n            var count = 0\n            for (i\
    \ <- 0 until lst.size) {\n                if (lst(i) == result) count += 1\n \
    \           }\n            if (count == lst.size) None\n            else {\n \
    \               var result2 = lst(0)\n                for (i <- 1 until lst.size)\
    \ {\n                    if (lst(i) < result2 && lst(i) > result) result2 = lst(i)\n\
    \                }\n                Some(result2)\n            }\n        }",
  "        if (lst.length == 0) {\n            None\n        } else if (lst.length\
    \ == 1) {\n            None\n        } else {\n            val firstSmallest =\
    \ lst.min\n            val lst2 = lst.filter(x => x != firstSmallest)\n      \
    \      val secondSmallest = lst2.min\n            Some(secondSmallest)\n     \
    \   }", "        val s = new HashSet[Long]\n        for (i <- lst) {\n       \
    \     if (s.contains(i)) {\n                return None\n            }\n     \
    \       s.add(i)\n        }\n        val sortedLst = lst.sorted\n        if (sortedLst.length\
    \ >= 2) {\n            return Some(sortedLst(1))\n        }\n        return None",
  "        val smallests = new ListBuffer[Long]\n        var smallest = Long.MaxValue\n\
    \        var secondSmallest = Long.MaxValue\n        var allTheSame = true\n \
    \       for (n <- lst) {\n            if (n < smallest) {\n                secondSmallest\
    \ = smallest\n                smallest = n\n                allTheSame = false\n\
    \            } else if (n == smallest) {\n                allTheSame = true\n\
    \            } else if (n < secondSmallest) {\n                secondSmallest\
    \ = n\n                allTheSame = false\n            }\n        }\n        if\
    \ (allTheSame) {\n            None\n        } else {\n            Some(secondSmallest)\n\
    \        }", "        if (lst.length <= 1) return None\n        val m = TreeMap[Long,\
    \ Int]()\n        for (v <- lst) {\n            if (m.contains(v)) m(v) += 1\n\
    \            else m(v) = 1\n        }\n        var c = 0\n        for (v <- m.keysIterator)\
    \ {\n            c += m(v)\n            if (c == 2) return Some(v)\n        }\n\
    \        None", "      if (lst.length == 0) None\n      else {\n        val (left,\
    \ right) = lst.splitAt(lst.length / 2)\n        val leftMin = left.reduceLeft((x,\
    \ y) => if (x < y) x else y)\n        val rightMin = right.reduceLeft((x, y) =>\
    \ if (x < y) x else y)\n        val leftMinIndex = lst.indexOf(leftMin)\n    \
    \    val rightMinIndex = lst.indexOf(rightMin)\n        val rightMinIndexInLeft\
    \ = left.indexOf(rightMin)\n        val leftMinIndexInRight = right.indexOf(leftMin)\n\
    \        if (rightMinIndex == -1) {\n          if (leftMinIndexInRight == -1)\
    \ {\n            if (leftMin == lst.last) None\n            else Some(leftMin)\n\
    \          }\n          else {\n            val leftMinInRight = right(leftMinIndexInRight)\n\
    \            if (leftMinInRight == lst.last) None\n            else Some(leftMinInRight)\n\
    \          }\n        }\n        else if (leftMinIndex == -1) {\n          if\
    \ (rightMinIndexInLeft == -1) {\n            if (rightMin == lst.last) None\n\
    \            else Some(rightMin)\n          }\n          else {\n            val\
    \ rightMinInLeft = left(rightMinIndexInLeft)\n            if (rightMinInLeft ==\
    \ lst.last) None\n            else Some(rightMinInLeft)\n          }\n       \
    \ }\n        else {\n          if (leftMinIndexInRight == -1) {\n            if\
    \ (rightMinIndexInLeft == -1) {\n              if (leftMin == lst.last) None\n\
    \              else Some(leftMin)\n            }\n            else {\n       \
    \       val rightMinInLeft = left(rightMinIndexInLeft)\n              if (rightMinInLeft\
    \ == lst.last) None\n              else Some(rightMinInLeft)\n            }\n\
    \          }\n          else {\n            val leftMinInRight = right(leftMinIndexInRight)\n\
    \            if (rightMinIndexInLeft == -1) {\n              if (leftMinInRight\
    \ == l", "    \tif (lst.length <= 1) None\n    \telse {\n    \t\tval min = lst.min\n\
    \    \t\tval newlst = lst.filter(_ != min)\n    \t\tif (newlst.length == 0) None\n\
    \    \t\telse Some(newlst.min)\n    \t}", "        if (lst.size < 2) None\n  \
    \      else {\n            val sorted = lst.sorted\n            if (sorted(0)\
    \ == sorted(1)) None\n            else Some(sorted(1))\n        }", "        if\
    \ (lst.size < 2) return None\n        var min = lst(0)\n        var nextMin =\
    \ lst(1)\n        for (i <- 1 until lst.size) {\n            if (lst(i) < min)\
    \ {\n                nextMin = min\n                min = lst(i)\n           \
    \ }\n            else if (lst(i) < nextMin) {\n                nextMin = lst(i)\n\
    \            }\n        }\n        if (min == nextMin) return None\n        Some(nextMin)",
  "        if (lst.length <= 1) None\n        else {\n            val min = lst.reduceLeft((a,\
    \ b) => if (a < b) a else b)\n            val filtered = lst.filter(_ != min)\n\
    \            if (filtered.length == 0) None\n            else Some(filtered.reduceLeft((a,\
    \ b) => if (a < b) a else b))\n        }", "        var foundFirst = false\n \
    \       var foundSecond = false\n        var first : Long = 0\n        var second\
    \ : Long = 0\n        for (x <- lst) {\n            if (!foundFirst) {\n     \
    \           first = x\n                foundFirst = true\n            } else if\
    \ (!foundSecond) {\n                if (x < first) {\n                    second\
    \ = first\n                    first = x\n                } else if (x != first)\
    \ {\n                    second = x\n                    foundSecond = true\n\
    \                }\n            } else {\n                if (x < first) {\n \
    \                   second = first\n                    first = x\n          \
    \      } else if (x < second) {\n                    second = x\n            \
    \    }\n            }\n        }\n        if (foundSecond) Some(second) else None",
  "        lst.sorted.distinct match {\n            case List() => None\n        \
    \    case List(x) => None\n            case x :: xs => Some(xs.head)\n       \
    \ }", "        if (lst.length < 2) None\n        else {\n            var min1\
    \ = Long.MaxValue\n            var min2 = Long.MaxValue\n            for (i <-\
    \ 0 until lst.length) {\n                val elem = lst(i)\n                if\
    \ (elem < min1) {\n                    min2 = min1\n                    min1 =\
    \ elem\n                }\n                else if (elem < min2) {\n         \
    \           min2 = elem\n                }\n            }\n            if (min2\
    \ == Long.MaxValue) None\n            else Some(min2)\n        }", "        def\
    \ mergeSort(x : List[Long]) : List[Long] = {\n            if (x.length <= 1) x\n\
    \            else {\n                val (left, right) = x.splitAt(x.length /\
    \ 2)\n                merge(mergeSort(left), mergeSort(right))\n            }\n\
    \        }\n        def merge(left : List[Long], right : List[Long]) : List[Long]\
    \ = {\n            (left, right) match {\n                case (Nil, y) => y\n\
    \                case (x, Nil) => x\n                case (leftHead :: leftTail,\
    \ rightHead :: rightTail) => if (leftHead < rightHead) leftHead :: merge(leftTail,\
    \ right) else rightHead :: merge(left, rightTail)\n            }\n        }\n\
    \        lst match {\n            case List() => None\n            case List(a)\
    \ => None\n            case List(a, b) => if (a != b) Some(a) else None\n    \
    \        case _ => Some(mergeSort(lst).apply(1))\n        }", "        if (lst.size\
    \ < 2) return None\n        var min = Long.MaxValue\n        var min2 = Long.MaxValue\n\
    \        for (n <- lst) {\n            if (n < min) {\n                min2 =\
    \ min\n                min = n\n            } else if (n < min2) {\n         \
    \       min2 = n\n            }\n        }\n        if (min2 == Long.MaxValue)\
    \ return None\n        return Some(min2)", "        val sorted = lst.sorted\n\
    \        if (sorted.size < 2) return None\n        return Some(sorted(1))", " \
    \       val n = lst.length\n        if (n < 2) return None\n        val m = lst.min\n\
    \        val result = (m +: lst).sorted.distinct.drop(1).head\n        Some(result)",
  "        if (lst.length <= 1) None\n        else Some(lst.toSet.toList.sorted.drop(1).head)",
  "        val xs = new ListBuffer[Long]()\n        xs ++= lst\n        xs = xs.sortWith(_\
    \ < _)\n        var last = 0l\n        var minimum = Long.MaxValue\n        xs.foreach(x\
    \ => {\n            if (x != last) {\n                if (minimum == Long.MaxValue)\
    \ minimum = x\n                else {\n                    val tmp = minimum\n\
    \                    minimum = x\n                    return Some(tmp)\n     \
    \           }\n            }\n            last = x\n        })\n        None",
  "        if (lst.length < 2) None\n        else {\n            val sorted = lst.sorted\n\
    \            val min = sorted(0)\n            val next = sorted(1)\n         \
    \   if (min == next) None\n            else Some(next)\n        }", "        var\
    \ min = Long.MaxValue\n        var min2 = Long.MaxValue\n        for (i <- lst)\
    \ {\n            if (i <= min) {\n                min2 = min\n               \
    \ min = i\n            }\n            else if (i < min2) min2 = i\n        }\n\
    \        if (min2 == Long.MaxValue) None else Some(min2)", "        if (lst.size\
    \ <= 1) return None\n        val min = lst.min\n        if (lst.count(_ == min)\
    \ == lst.size) return None\n        val max = lst.max\n        val sorted = lst.sorted\n\
    \        return Some(sorted(sorted.indexOf(min) + 1))", "      if (lst.length\
    \ <= 1) None\n      else {\n        val m = lst.foldLeft(lst(0))((x, y) => min(x,\
    \ y))\n        val m2 = lst.foldLeft(m)((x, y) => if (y == m) x else min(x, y))\n\
    \        if (m2 == m) None else Some(m2)\n      }", "        val it = lst.toIterator\n\
    \        var first : Option[Long] = None\n        var second : Option[Long] =\
    \ None\n        var min : Option[Long] = None\n        while (it.hasNext) {\n\
    \            val current = it.next\n            if (min == None || current < min.get)\
    \ {\n                min = Some(current)\n            }\n            if (first\
    \ == None || current > first.get) {\n                if (second == None || current\
    \ < second.get) {\n                    second = Some(current)\n              \
    \  }\n                first = Some(current)\n            }\n        }\n      \
    \  if (min == first) None else second", "        if (lst.length <= 1) return None\n\
    \        var smaller = Long.MaxValue\n        var smaller2 = Long.MaxValue\n \
    \       for (x <- lst) {\n            if (x <= smaller) {\n                smaller2\
    \ = smaller\n                smaller = x\n            } else if (x < smaller2)\
    \ {\n                smaller2 = x\n            }\n        }\n        if (smaller2\
    \ != Long.MaxValue) return Some(smaller2)\n        return None", "        if (lst.length\
    \ < 2) return None\n        var min = lst(0)\n        var secondMin = lst(1)\n\
    \        if (min > secondMin) {val temp = min; min = secondMin; secondMin = temp}\n\
    \        for (i <- lst.drop(2)) {\n            if (i < min) {\n              \
    \  secondMin = min\n                min = i\n            }\n            else if\
    \ (i < secondMin) secondMin = i\n        }\n        return Some(secondMin)", " \
    \       lst.sorted.distinct match {\n            case Nil => None\n          \
    \  case h :: Nil => None\n            case h :: t => Some(t.head)\n        }",
  "      val sorted = lst.sorted\n      var res : Option[Long] = None\n      if (sorted.length\
    \ >= 2) {\n        if (sorted(0) == sorted(1)) {\n          res = None\n     \
    \   } else {\n          res = Some(sorted(1))\n        }\n      }\n      res",
  "        var result : Option[Long] = None\n        var currentMin = Long.MaxValue\n\
    \        for (i <- lst) {\n            if (i < currentMin) {\n               \
    \ result = Some(currentMin)\n                currentMin = i\n            } else\
    \ if (i != currentMin && i < result.getOrElse(i)) {\n                result =\
    \ Some(i)\n            }\n        }\n        result", '        lst.sortWith(_
    < _).slice(1, 2).headOption', "        if (lst.size < 2) None\n        else {\n\
    \            val sorted = lst.sorted\n            if (sorted(0) == sorted(1))\
    \ None\n            else Some(sorted(1))\n        }", "        if (lst.size <\
    \ 2) return None\n        var counter = new scala.collection.mutable.HashMap[Long,\
    \ Int]\n        lst.foreach(x => counter(x) = counter.getOrElse(x, 0) + 1)\n \
    \       val set = new scala.collection.mutable.HashSet[Long]\n        counter.foreach(x\
    \ => set += x._1)\n        val sortedList = set.toList.sorted\n        if (sortedList.size\
    \ == 1) return None\n        return Some(sortedList(1))", "        def nextSmallesthelper(lst\
    \ : List[Long], min : Long, secondMin : Long) : Option[Long] = {\n           \
    \ if (lst.isEmpty) {\n                if (secondMin == Long.MaxValue) None else\
    \ Some(secondMin)\n            } else {\n                if (lst.head < min) nextSmallesthelper(lst.tail,\
    \ lst.head, min)\n                else if (lst.head > min && lst.head < secondMin)\
    \ nextSmallesthelper(lst.tail, min, lst.head)\n                else nextSmallesthelper(lst.tail,\
    \ min, secondMin)\n            }\n        }\n        nextSmallesthelper(lst, Long.MaxValue,\
    \ Long.MaxValue)", '        lst.sorted.drop(1).headOption', "        // Builds\
    \ a map where key = element of list, value = count of elements in the list that\
    \ are less than or equal to element.\n        // Returns None if count of elements\
    \ in the list that are less than or equal to element is 0.\n        def buildMap(lst\
    \ : List[Long], map : HashMap[Long, Int]) : HashMap[Long, Int] = {\n         \
    \   if (lst.isEmpty) map\n            else {\n                val (key, value)\
    \ = (lst.head, lst.filter(_ <= lst.head).length)\n                map.put(key,\
    \ value)\n                buildMap(lst.tail, map)\n            }\n        }\n\
    \        val map = buildMap(lst, new HashMap[Long, Int])\n        // Gets the\
    \ element with the second smallest value.\n        // Returns None if there is\
    \ no such element.\n        def getElement(map : HashMap[Long, Int]) : Option[Long]\
    \ = {\n            // Finds the next smallest value in the map.\n            //\
    \ Returns None if there is no such value.\n            def findNextSmallest(map\
    \ : HashMap[Long, Int], valu : Int) : Option[Int] = {\n                val values\
    \ = map.values.toList.sortWith(_ < _)\n                val index = values.indexOf(valu)\n\
    \                if (index + 1 == values.length) None\n                else Some(values(index\
    \ + 1))\n            }\n            valuOption = findNextSmallest(map, 1)\n  \
    \          valuOption match {\n                case None => None\n           \
    \     case Some(valu) => {\n                    val keys = map.keys.toList.sortWith(_\
    \ < _)\n                    val index = map.values.toList.indexOf(valu)\n    \
    \                Some(keys(index))\n                }\n            }\n       \
    \ }\n        getElement(map)", "        if (lst.size < 2) return None\n      \
    \  val list = lst.sorted\n        if (list(0) == list(1)) return None\n      \
    \  Some(list(1))", "        // val sorted = lst.sorted\n        // for (i <- 0\
    \ until sorted.length - 1) {\n        //     if (sorted(i) != sorted(i + 1)) {\n\
    \        //         return Some(sorted(i + 1))\n        //     }\n        // }\n\
    \        // None\n        val sorted = lst.sorted\n        val sortedDistinct\
    \ = sorted.distinct\n        if (sortedDistinct.length > 1) {\n            Some(sortedDistinct(1))\n\
    \        } else {\n            None\n        }", "      if (lst.length < 2) {\n\
    \        None\n      } else {\n        val sorted = lst.sorted\n        var found\
    \ = false\n        var i = 0\n        while (i < sorted.length - 1 && !found)\
    \ {\n          if (sorted(i) != sorted(i + 1)) {\n            found = true\n \
    \         } else {\n            i += 1\n          }\n        }\n        if (found)\
    \ {\n          Some(sorted(i + 1))\n        } else {\n          None\n       \
    \ }\n      }", "      if (lst.size < 2) return None\n      return Some(lst.sorted.tail.head)",
  "        var min1 = Long.MaxValue\n        var min2 = Long.MaxValue\n        for\
    \ (e <- lst) {\n            if (e < min1) {\n                min2 = min1\n   \
    \             min1 = e\n            } else if (e < min2) {\n                min2\
    \ = e\n            }\n        }\n        if (min2 == Long.MaxValue) None else\
    \ Some(min2)", "        val a = lst.sorted\n        val b = a.distinct\n     \
    \   if (b.length == 0) return None\n        else if (b.length == 1) return None\n\
    \        else if (b.length == 2) return None\n        else return Some(b(1))",
  "      lst.sortWith(_ < _).distinct match {\n        case head :: second :: _ =>\
    \ Some(second)\n        case _ => None\n      }", "        if (lst.length < 2)\
    \ None\n        else {\n            var (p1, p2) = (lst(0), lst(1))\n        \
    \    if (p1 < p2) (p1, p2) = (p2, p1)\n            lst.tail.tail.foreach(x =>\
    \ {\n                if (x < p1) {\n                    p2 = p1\n            \
    \        p1 = x\n                }\n                else if (x < p2) p2 = x\n\
    \            })\n            if (p1 == p2) None\n            else Some(p2)\n \
    \       }", "        val lst1 = lst.sorted\n        if (lst1.size < 2) {\n   \
    \         None\n        } else {\n            Option(lst1(1))\n        }", " \
    \       lst.sorted.distinct match {\n            case head :: second :: tail =>\
    \ Option(second)\n            case _ => None\n        }", "        val set = HashSet[Long]()\n\
    \        for (i <- lst) set += i\n        var ans = Long.MaxValue\n        var\
    \ found = false\n        for (i <- set) {\n            if (i < ans) {\n      \
    \          ans = i\n                found = true\n            }\n        }\n \
    \       if (found) {\n            return Some(ans)\n        } else {\n       \
    \     return None\n        }", "        val sorted = lst.sorted\n        if (sorted.length\
    \ == 0) return None\n        var min = sorted(0)\n        var second = None :\
    \ Option[Long]\n        for (e <- sorted) {\n            if (e > min) {\n    \
    \            second = Some(e)\n                break\n            }\n        \
    \    min = e\n        }\n        second", "        if (lst.size < 2) None\n  \
    \      else {\n            val sorted = lst.sorted\n            if (sorted(0)\
    \ == sorted(1)) None\n            else Some(sorted(1))\n        }", "        //\
    \ >>> nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\n\
    \        // 2l\n        // >>> nextSmallest((List[Long](5l.toLong, 1l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong)))\n        // 2l\n        // >>> nextSmallest((List[Long]()))\n\
    \        // None\n        // >>> nextSmallest((List[Long](1l.toLong, 1l.toLong)))\n\
    \        // None\n        // >>> nextSmallest((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong)))\n        // None\n        // >>> nextSmallest((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)))\n        // 2l\n  \
    \      // >>> nextSmallest((List[Long](6l.toLong, 1l.toLong, 4l.toLong, 3l.toLong,\
    \ 2l.toLong, 5l.toLong)))\n        // 2l\n        // >>> nextSmallest((List[Long](6l.toLong,\
    \ 5l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong)))\n        // 2l\n  \
    \      // >>> nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong)))\n        // 3l\n        // >>> nextSmallest((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 5l.toLong)))\n        // 4l\n  \
    \      // >>> nextSmallest((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 5l.toLong)))\n        // 4l\n        if (lst.length == 0) return\
    \ None\n        if (lst.", '      lst.toSet.toList.sortWith(_<_).lift(1)', " \
    \       if (lst.length < 2) return None\n        lst.sortWith(_ < _)\n       \
    \ return Some(lst(1))", "        if (lst.length < 2) None\n        else {\n  \
    \          val sorted = lst.sorted\n            val unique = sorted.groupBy(x\
    \ => x).toList.map(p => p._1)\n            if (unique.length < 2) None\n     \
    \       else Some(unique(1))\n        }", "        var m1 = Long.MaxValue\n  \
    \      var m2 = Long.MaxValue\n        for (x <- lst) {\n            if (x < m1)\
    \ {\n                m2 = m1\n                m1 = x\n            } else if (x\
    \ < m2) {\n                m2 = x\n            }\n        }\n        if (m2 ==\
    \ Long.MaxValue) None else Some(m2)", "        var found = false\n        var\
    \ previous = None:Option[Long]\n        for (i <- lst.sorted) {\n            if\
    \ (previous.isDefined && i > previous.get) {\n                return Some(i)\n\
    \            }\n            previous = Some(i)\n        }\n        return None",
  "        val buf = lst.sorted\n        if (buf.size == 0) None\n        else {\n\
    \            val buf2 = buf.distinct\n            if (buf2.size == 1) None\n \
    \           else Some(buf2(1))\n        }", "        var min = None : Option[Long]\n\
    \        var min2 = None : Option[Long]\n        for (x <- lst) {\n          \
    \  if (min == None || x < min.get) {\n                min2 = min\n           \
    \     min = Some(x)\n            } else if (min2 == None || x < min2.get) {\n\
    \                min2 = Some(x)\n            }\n        }\n        return min2",
  "        val lst2 = lst.sorted\n        if (lst2.size < 2) None\n        else Some(lst2(1))",
  "        val list = lst.distinct.sorted\n        if (list.size < 2) None\n     \
    \   else Some(list(1))", "      if (lst.size == 0) return None\n      var smallest\
    \ = lst(0)\n      var secondSmallest = None : Option[Long]\n      for (i <- 0\
    \ until lst.size) {\n        if (lst(i) <= smallest) {\n          smallest = lst(i)\n\
    \        } else if (secondSmallest == None || lst(i) <= secondSmallest.get) {\n\
    \          secondSmallest = Some(lst(i))\n        }\n      }\n      return secondSmallest",
  "        if (lst.length < 2) None\n        else Some(lst.toSet.toList.sorted.tail.head)",
  '        return None', "      if (lst.length == 0) return None\n      var m = Long.MaxValue\n\
    \      var m2 = Long.MaxValue\n      for (i <- lst) {\n        if (i < m) {\n\
    \          m2 = m\n          m = i\n        } else if (i < m2) {\n          m2\
    \ = i\n        }\n      }\n      if (m2 == Long.MaxValue) return None\n      return\
    \ Some(m2)", "        if (lst.length == 0) return None\n        if (lst.length\
    \ == 1) return None\n        var currentMin = lst(0)\n        var currentMinIndex\
    \ = 0\n        var secondMin = Long.MaxValue\n        var secondMinIndex = -1\n\
    \        for (i <- 1 until lst.length) {\n            if (lst(i) < currentMin)\
    \ {\n                secondMin = currentMin\n                secondMinIndex =\
    \ currentMinIndex\n                currentMin = lst(i)\n                currentMinIndex\
    \ = i\n            }\n            else if (lst(i) > currentMin && lst(i) < secondMin)\
    \ {\n                secondMin = lst(i)\n                secondMinIndex = i\n\
    \            }\n        }\n        if (secondMinIndex == -1) return None\n   \
    \     return Some(secondMin)", "        if (lst.size == 0) return None\n     \
    \   if (lst.size == 1) return None\n        if (lst.size == 2) {\n           \
    \ if (lst(0) == lst(1)) return None\n            else return Some(min(lst(0),\
    \ lst(1)))\n        }\n        val sorted = lst.sorted\n        var min = sorted(0)\n\
    \        var min2 = Long.MaxValue\n        for (i <- 1 until sorted.size) {\n\
    \            if (sorted(i) > min) {\n                min2 = sorted(i)\n      \
    \          break\n            }\n        }\n        if (min2 == Long.MaxValue)\
    \ return None\n        else return Some(min2)", '      lst.distinct.sorted.tail.headOption',
  "        if (lst.size <= 1) None\n        else {\n            var min = Long.MaxValue\n\
    \            var secondMin = Long.MaxValue\n            for (i <- 0 until lst.size)\
    \ {\n                if (lst(i) < min) {\n                    secondMin = min\n\
    \                    min = lst(i)\n                }\n                else if\
    \ (lst(i) > min && lst(i) < secondMin) {\n                    secondMin = lst(i)\n\
    \                }\n            }\n            if (secondMin == Long.MaxValue)\
    \ None\n            else Some(secondMin)\n        }", "    \tval sorted = lst.sorted\n\
    \    \tif (sorted.size < 2) None\n    \telse {\n    \t\tval (first, rest) = (sorted.head,\
    \ sorted.tail)\n    \t\tval diff = (rest :\\ Map[Long, List[Long]]())((x, m) =>\
    \ {m + (x - first -> (x :: m.getOrElse(x - first, List[Long]())))})\n    \t\t\
    val secondSmallest = diff.minBy(_._1)._2.head\n    \t\tSome(secondSmallest)\n\
    \    \t}", "        if (lst.length < 2) return None\n        var sorted = lst.sorted\n\
    \        if (sorted(0) == sorted(1)) return None\n        return Some(sorted(1))",
  "    \tval ls = lst.sorted\n    \tif (ls.length == 0) None\n    \telse if (ls.length\
    \ == 1) None\n    \telse Some(ls(1))", "        if (lst.length < 2) None\n   \
    \     else {\n            var sndSmallest : Long = Long.MaxValue\n           \
    \ var smallest : Long = Long.MaxValue\n            lst.foreach(x => {\n      \
    \          if (x < smallest) {\n                    sndSmallest = smallest\n \
    \                   smallest = x\n                }\n                else if (x\
    \ < sndSmallest) sndSmallest = x\n            })\n            if (sndSmallest\
    \ == Long.MaxValue) None\n            else Some(sndSmallest)\n        }", "  \
    \      if (lst.size == 0) {\n            None\n        } else if (lst.size ==\
    \ 1) {\n            None\n        } else {\n            Some(lst.sortWith(_ <\
    \ _)(1))\n        }", '        lst.sorted.tail.headOption', "    \tif (lst.length\
    \ < 2) None\n    \telse {\n    \t\tval s = SortedSet[Long]() ++ lst\n    \t\t\
    val it = s.iterator\n    \t\tit.next\n    \t\tSome(it.next)\n    \t}", "     \
    \   if (lst.length <= 1) return None\n        if (lst.length == 2) {\n       \
    \     if (lst(0) == lst(1)) return None\n            else return Some(max(lst(0),\
    \ lst(1)))\n        }\n        else {\n            val mx = lst.max\n        \
    \    var lst2 = lst :+ mx\n            lst2 = lst2.sortWith(_ < _)\n         \
    \   return Some(lst2(1))\n        }", "        val sorted = lst.sorted\n     \
    \   if (sorted.length < 2) None\n        else {\n            val slst = sorted.distinct\n\
    \            if (slst.length < 2) None\n            else Some(slst(1))\n     \
    \   }", "        lst.size match {\n            case 0 => None\n            case\
    \ 1 => None\n            case _ => {\n                val ls = lst.sorted\n  \
    \              if (ls(0) == ls(1)) {\n                    None\n             \
    \   } else {\n                    Some(ls(1))\n                }\n           \
    \ }\n        }", "        val sorted = lst.sorted\n        if (sorted.size <=\
    \ 1) None\n        else {\n            val smallest = sorted(0)\n            var\
    \ result = None:Option[Long]\n            for (i <- 1 until sorted.size) {\n \
    \               if (sorted(i) != smallest) {\n                    result = Some(sorted(i))\n\
    \                    break\n                }\n            }\n            result\n\
    \        }", "        var min = lst.min\n        var min2 = min\n        for (i\
    \ <- lst) {\n            if (i < min2 && i > min) min2 = i\n        }\n      \
    \  if (min2 == min) None else Some(min2)", "        if (lst.length < 2) return\
    \ None\n        if (lst.length == 2) {\n            if (lst(0) == lst(1)) return\
    \ None\n            else return Some(min(lst(0), lst(1)))\n        }\n       \
    \ var min1 = lst(0)\n        var min2 = lst(1)\n        if (min1 > min2) {\n \
    \           val tmp = min1\n            min1 = min2\n            min2 = tmp\n\
    \        }\n        for (i <- 2 until lst.length) {\n            if (lst(i) <\
    \ min1) {\n                min2 = min1\n                min1 = lst(i)\n      \
    \      }\n            else if (lst(i) < min2) {\n                min2 = lst(i)\n\
    \            }\n        }\n        return Some(min2)", "    \tif (lst.size <=\
    \ 1) None\n    \telse {\n    \t\tval firstMin = min(lst(0), lst(1))\n    \t\t\
    val secondMin = max(lst(0), lst(1))\n    \t\tlst.foldLeft((firstMin, secondMin))((a,\
    \ b) => if (b < a._1) (b, a._1) else if (b < a._2) (a._1, b) else a)._2\n    \t\
    }", "        if (lst.size < 2) return None\n        val lst2 = lst.sorted\n  \
    \      var set = new HashSet[Long]\n        var i = 0\n        while (i < lst2.size)\
    \ {\n            if (i == 0) {\n                if (lst2(i) != lst2(i + 1)) set\
    \ += lst2(i + 1)\n            } else if (i == lst2.size - 1) {\n             \
    \   if (lst2(i) != lst2(i - 1)) set += lst2(i - 1)\n            } else {\n   \
    \             if (lst2(i) != lst2(i - 1) && lst2(i) != lst2(i + 1)) set += lst2(i\
    \ - 1)\n            }\n            i += 1\n        }\n        if (set.size ==\
    \ 0) return None\n        return Some(set.min)", "      if (lst.size == 0) None\n\
    \      else {\n        val sorted = lst.sorted\n        if (sorted(0) == sorted(1))\
    \ None\n        else Some(sorted(1))\n      }", "        if (lst.size < 2) {\n\
    \            None\n        } else {\n            val (smallest, nextSmallest)\
    \ = lst.drop(1).foldLeft((lst(0), Long.MaxValue))((current, e) => if (e < current._1)\
    \ (e, current._1) else if (e < current._2) (current._1, e) else current)\n   \
    \         if (nextSmallest == Long.MaxValue) None else Some(nextSmallest)\n  \
    \      }", "        if (lst.length == 0) return None\n        if (lst.length ==\
    \ 1) return None\n        lst.sorted.toArray.toList.distinct.drop(1).headOption",
  '        lst.distinct.sortWith(_ < _).drop(1).headOption', "        if (lst.length\
    \ < 2) return None\n        var min1 = lst(0)\n        var min2 = lst(1)\n   \
    \     if (min1 > min2) {\n            val tmp = min1\n            min1 = min2\n\
    \            min2 = tmp\n        }\n        for (i <- 2 until lst.length) {\n\
    \            if (lst(i) < min1) {\n                min2 = min1\n             \
    \   min1 = lst(i)\n            } else if (lst(i) > min1 && lst(i) < min2) {\n\
    \                min2 = lst(i)\n            }\n        }\n        if (min1 ==\
    \ min2) None else Some(min2)", "        val v = lst.sorted\n        if (v.size\
    \ <= 1) None\n        else Some(v(1))", "        if (lst.length <= 1) return None\n\
    \        val sortedList = lst.sorted\n        if (sortedList(0) == sortedList(1))\
    \ return None\n        Some(sortedList(1))", "        if (lst.length < 2) None\n\
    \        else {\n            def recur(lst2 : List[Long], currentMin : Long, secondMin\
    \ : Long) : Long = {\n                if (lst2.isEmpty) secondMin\n          \
    \      else {\n                    val newMin = if (lst2.head < currentMin) lst2.head\
    \ else currentMin\n                    val newSecondMin = if (lst2.head > currentMin\
    \ && lst2.head < secondMin) lst2.head else secondMin\n                    recur(lst2.tail,\
    \ newMin, newSecondMin)\n                }\n            }\n            val ret\
    \ = recur(lst.tail, lst.head, lst.head)\n            if (ret == lst.head) None\
    \ else Some(ret)\n        }"]
stop_tokens:
- "\n    }\n"
