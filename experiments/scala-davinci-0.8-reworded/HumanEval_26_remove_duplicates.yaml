name: HumanEval_26_remove_duplicates
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a list of integers, remove all elements that occur more than once.\n\
  \    // Keep order of elements left the same as in the input.\n    // >>> removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong,\
  \ 4l.toLong))\n    def removeDuplicates(numbers : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(removeDuplicates((List[Long]())).equals((List[Long]())));\n\
  \    assert(removeDuplicates((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(removeDuplicates((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))).equals((List[Long](1l.toLong,\
  \ 4l.toLong, 5l.toLong))));\n    }\n\n}\n"
completions: ["        val map = Map[Long, Int]()\n        for (number <- numbers)\
    \ {\n            map(number) = map.getOrElse(number, 0) + 1\n        }\n     \
    \   return numbers.filter(number => map(number) == 1)", "        var hash : Map[Long,\
    \ Int] = Map()\n        numbers.foreach(x => hash += (x -> (hash.getOrElse(x,\
    \ 0) + 1)))\n        var result : List[Long] = List()\n        numbers.foreach(x\
    \ => if (hash(x) == 1) result = result :+ x)\n        result", "        numbers.foldLeft(Map[Long,\
    \ Long]())((map, number) => {\n            map + (number -> (map.getOrElse(number,\
    \ 0l.toLong) + 1l.toLong))\n        }).foldLeft(List[Long]())((list, pair) =>\
    \ {\n            if (pair._2 == 1l.toLong) list ++ List(pair._1) else list\n \
    \       })", "        var set = new HashSet[Long]()\n        var result = new\
    \ ArrayBuffer[Long]()\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        numbers.foldLeft(List[Long]())((acc,\
    \ x) => {\n            if (acc.contains(x)) acc else acc :+ x\n        })", " \
    \     var duplicates = Set[Long]()\n      var result = List[Long]()\n      for\
    \ (number <- numbers) {\n        if (!duplicates.contains(number)) {\n       \
    \   duplicates.add(number)\n          result = result :+ number\n        }\n \
    \     }\n      result", "        val removed = new HashSet[Long]\n        val\
    \ returned = new ListBuffer[Long]\n        for (i <- numbers) {\n            if\
    \ (!removed.contains(i)) {\n                removed += i\n                returned\
    \ += i\n            }\n        }\n        returned.toList", "        var n : List[Long]\
    \ = numbers\n        var i : Int = 1\n        while (i < n.length) {\n       \
    \     var j : Int = 0\n            while (j < i) {\n                if (n(i) ==\
    \ n(j)) {\n                    n = n.slice(0, i) ++ n.slice(i + 1, n.length)\n\
    \                    j = i\n                }\n                j += 1\n      \
    \      }\n            i += 1\n        }\n        n", '      List()', "       \
    \ val occurences : HashMap[Long, Int] = new HashMap[Long, Int]()\n        numbers.foreach(num\
    \ => {\n            occurences.put(num, occurences.getOrElse(num, 0) + 1)\n  \
    \      })\n        numbers.filter(num => {\n            occurences.get(num).get\
    \ == 1\n        })", '        numbers.reverse.distinct.reverse', "        val\
    \ distinctNumbers = numbers.distinct\n        var result = List[Long]()\n    \
    \    for (number <- distinctNumbers) {\n            if (numbers.indexOf(number)\
    \ == numbers.lastIndexOf(number)) result = result :+ number\n        }\n     \
    \   result", "        var d = new HashMap[Long, Int]()\n        for (n <- numbers)\
    \ {\n            val count = d.getOrElse(n, 0)\n            d += (n -> (count\
    \ + 1))\n        }\n        numbers.filter(n => d(n) == 1)", '        List[Long]()',
  '        numbers.distinct', "        var l1 = ArrayBuffer[Long]()\n        numbers.foreach(x\
    \ => if (!l1.contains(x)) l1 += x)\n        l1.toList", '        numbers.filter((x)
    => numbers.count((y) => y == x) == 1)', "        var uniqueNumbers = Set[Long]()\n\
    \        var uniqueNumb", "        var dict = new HashMap[Long, Int]\n       \
    \ for (i <- numbers) {\n            if (dict.contains(i)) dict(i) += 1\n     \
    \       else dict(i) = 1\n        }\n        dict.filter(x => x._2 == 1).map(x\
    \ => x._1).toList", '        numbers.distinct', "        var uniqueNumbers = List[Long]()\n\
    \        var alreadySeen = Set[Long]()\n        for (number <- numbers) {\n  \
    \          if (!alreadySeen.contains(number)) {\n                uniqueNumbers\
    \ = uniqueNumbers :+ number\n                alreadySeen.add(number)\n       \
    \     }\n        }\n        uniqueNumbers", "        var result : List[Long] =\
    \ List()\n        var hashTable : HashMap[Long, Int] = HashMap()\n        for\
    \ (i <- numbers) {\n            if (hashTable.contains(i)) {\n               \
    \ hashTable(i) += 1\n            } else {\n                hashTable(i) = 1\n\
    \            }\n        }\n        for (i <- numbers) {\n            if (hashTable(i)\
    \ == 1) {\n                result ::= i\n            }\n        }\n        result",
  "        var all = List[Long]()\n        var unique = List[Long]()\n        for\
    \ (n <- numbers) {\n            if (!all.contains(n)) {\n                all =\
    \ n :: all\n                unique = n :: unique\n            }\n        }\n \
    \       return unique.reverse", "      def helper(numbers : List[Long], distinct\
    \ : List[Long]) : List[Long] = numbers match {\n        case Nil => distinct\n\
    \        case x :: xs => if (distinct.contains(x)) helper(xs, distinct) else helper(xs,\
    \ x :: distinct)\n      }\n      return helper(numbers, Nil)", "        var list\
    \ = List[Long]()\n        for (i <- numbers) {\n            if (!list.contains(i))\
    \ list = list :+ i\n        }\n        list", '        numbers.filter(number =>
    numbers.count(_ == number) == 1)', "        val hash = new HashMap[Long, Boolean]\n\
    \        for (number <- numbers) {\n            if (hash.contains(number)) {\n\
    \                hash(number) = true\n            } else {\n                hash(number)\
    \ = false\n            }\n        }\n        return numbers.filter(number => !hash(number))",
  "    \tnumbers.foldLeft(List[Long]())((list, num) => {\n    \t\tif (list.contains(num))\
    \ {\n    \t\t\tlist\n    \t\t} else {\n    \t\t\tlist :+ num\n    \t\t}\n    \t\
    })", "        val uniqueNumbers = new ListBuffer[Long]\n        numbers.foreach(num\
    \ => {\n            if (!uniqueNumbers.contains(num)) uniqueNumbers += num\n \
    \       })\n        uniqueNumbers.toList", "        val duplicates = numbers.filter(x\
    \ => numbers.count(_ == x) > 1)\n        numbers.diff(duplicates)", '        numbers.filter(num
    => numbers.count(_ == num) == 1)', "        var m = Map[Long,Int]()\n        for\
    \ (n <- numbers) {\n            val count = m.getOrElse(n, 0)\n            m.put(n,\
    \ count + 1)\n        }\n        return numbers.filter(n => m.getOrElse(n, 0)\
    \ == 1)", "        if (numbers.isEmpty) {\n            return List[Long]()\n \
    \       }\n        return numbers.tail.foldLeft(List(numbers.head))((result, current)\
    \ => {\n            if (result.contains(current)) result else result :+ current\n\
    \        })", "        var result = List[Long]()\n        val numbersOccurrences\
    \ = new HashMap[Long, Int]()\n        for (number <- numbers) {\n            if\
    \ (numbersOccurrences.contains(number)) {\n                numbersOccurrences(number)\
    \ += 1\n            } else {\n                numbersOccurrences(number) = 1\n\
    \            }\n        }\n        for (number <- numbers) {\n            if (numbersOccurrences(number)\
    \ == 1) {\n                result = result :+ number\n            }\n        }\n\
    \        result", "        var h = new HashMap[Long, Int]()\n        var n = new\
    \ ArrayBuffer[Long]()\n        for (number <- numbers) {\n            if (h.contains(number))\
    \ h(number) += 1\n            else h(number) = 1\n        }\n        for (number\
    \ <- numbers) {\n            if (h(number) == 1) n += number\n        }\n    \
    \    n.toList", "      val set = new ListBuffer[Long]\n      for (i <- numbers)\
    \ {\n        if (!set.contains(i)) set += i\n      }\n      set.toList", "   \
    \     var c = new HashMap[Long, Boolean]\n        var r = new ListBuffer[Long]\n\
    \        for (i <- numbers) {\n            if (!c.contains(i)) {\n           \
    \     c += i -> true\n                r += i\n            }\n        }\n     \
    \   r.toList", "        val c = new HashMap[Long, Int]\n        numbers.foreach(i\
    \ => c(i) = c.getOrElse(i, 0) + 1)\n        numbers.filter(i => c(i) == 1)", " \
    \       var result = List[Long]()\n        var appearances = HashMap[Long, Int]()\n\
    \        for (num <- numbers) {\n            if (appearances.contains(num)) {\n\
    \                appearances(num) += 1\n            } else {\n               \
    \ appearances(num) = 1\n            }\n        }\n        for (num <- numbers)\
    \ {\n            if (appearances(num) == 1) {\n                result = result\
    \ :+ num\n            }\n        }\n        result", "        var uniques = new\
    \ ListBuffer[Long]\n        for (n <- numbers) {\n            if (!uniques.contains(n))\
    \ {\n                uniques += n\n            }\n        }\n        uniques.toList",
  "        val m : HashMap[Long,Long] = new HashMap[Long,Long]()\n        numbers.foreach(n\
    \ => {\n            if (m.contains(n)) {\n                m.put(n, 1)\n      \
    \      } else {\n                m.put(n, 0)\n            }\n        })\n    \
    \    numbers.filter(n => m.get(n).get == 0)", "        var result = List[Long]()\n\
    \        for (i <- numbers) {\n            if (!result.contains(i)) result = i\
    \ :: result\n        }\n        result.reverse", "        numbers.foldLeft(List[Long]())((l,\
    \ n) => {\n            if (l.contains(n)) l else l :+ n\n        })", "      \
    \  val result : ListBuffer[Long] = new ListBuffer[Long]()\n        val occurrences\
    \ : scala.collection.mutable.Map[Long, Int] = scala.collection.mutable.Map[Long,\
    \ Int]()\n        for (number <- numbers) {\n            if (occurrences.contains(number))\
    \ {\n                occurrences(number) += 1\n            } else {\n        \
    \        occurrences(number) = 1\n            }\n        }\n        for (number\
    \ <- numbers) {\n            if (occurrences(number) == 1) {\n               \
    \ result += number\n            }\n        }\n        result.toList", "      \
    \  val set = numbers.toSet\n        numbers.filter(n => set.contains(n))", " \
    \       var hs = new HashSet[Long]\n        var ret = new ListBuffer[Long]\n \
    \       for (i <- numbers) {\n            if (!hs.contains(i)) {\n           \
    \     hs += i\n                ret += i\n            }\n        }\n        ret.toList",
  '        ???', "        // numbers.reverse.distinct.reverse\n        numbers.distinct",
  "        val uniqueNumbers = new HashSet[Long]\n        val uniqueNumbersList =\
    \ new ListBuffer[Long]\n        for (n <- numbers) {\n            if (!uniqueNumbers.contains(n))\
    \ {\n                uniqueNumbers.add(n)\n                uniqueNumbersList.append(n)\n\
    \            }\n        }\n        uniqueNumbersList.toList", '        numbers.foldLeft(List[Long]())((accum,
    num) => if (accum.contains(num)) accum else num :: accum).reverse', "        val\
    \ result = new ListBuffer[Long]\n        val set = new HashSet[Long]\n       \
    \ val duplicates = new HashSet[Long]\n        for (x <- numbers) {\n         \
    \   if (set.contains(x)) {\n                duplicates.add(x)\n            } else\
    \ {\n                set.add(x)\n            }\n        }\n        for (x <- numbers)\
    \ {\n            if (!duplicates.contains(x)) {\n                result.append(x)\n\
    \            }\n        }\n        result.toList", '        numbers.distinct',
  "        // Double-loop and check\n        // O(n^2) but O(1) memory\n        val\
    \ ret = new ArrayBuffer[Long]\n        for (i <- 0 until numbers.length) {\n \
    \           var isDuplicate = false\n            for (j <- 0 until ret.length)\
    \ if (numbers(i) == ret(j)) isDuplicate = true\n            if (!isDuplicate)\
    \ ret += numbers(i)\n        }\n        ret.toList", "        val buf = Buffer[Long]()\n\
    \        for (n <- numbers) {\n            if (!buf.contains(n)) buf += n\n  \
    \      }\n        buf.toList", "        var ret = List[Long]()\n        var dic\
    \ = Map[Long, Long]()\n        for (i <- numbers) {\n            if (dic.contains(i))\
    \ {\n                dic(i) += 1\n            } else {\n                dic(i)\
    \ = 1\n            }\n        }\n        for (i <- numbers) {\n            if\
    \ (dic(i) == 1) {\n                ret = ret :+ i\n            }\n        }\n\
    \        return ret", "        val buffer = new ListBuffer[Long]\n        val\
    \ map = new HashMap[Long, Boolean]\n        for (i <- numbers) {\n           \
    \ if (!map.contains(i)) {\n                map.put(i, true)\n                buffer\
    \ += i\n            }\n        }\n        buffer.toList", "        var distinct\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!distinct.contains(number))\
    \ {\n                distinct += number\n            }\n        }\n        distinct.toList",
  "        // Enter your code here. Read input from STDIN. Print output to STDOUT.\
    \ Your class should be named Solution\n    var d = new HashMap[Long, Int]\n  \
    \  for (i <- numbers) {\n        if (d.contains(i)) {\n            var v = d(i)\n\
    \            d.put(i, v + 1)\n        } else {\n            d.put(i, 1)\n    \
    \    }", '        numbers.distinct', "        val set = HashSet[Long]()\n    \
    \    val result = ArrayBuffer[Long]()\n        for (number <- numbers) {\n   \
    \         if (!set.contains(number)) {\n                set += number\n      \
    \          result += number\n            }\n        }\n        result.toList",
  "        var numberCounts = Map[Long, Int]()\n        numbers.foreach(num => numberCounts(num)\
    \ = numberCounts.getOrElse(num, 0) + 1)\n        numbers.filter(num => numberCounts(num)\
    \ == 1)", "        val counts = new HashMap[Long, Int]()\n        for (number\
    \ <- numbers) {\n            counts.put(number, counts.getOrElse(number, 0) +\
    \ 1)\n        }\n        val unique = new ListBuffer[Long]()\n        for (number\
    \ <- numbers) {\n            if (counts(number) == 1) {\n                unique\
    \ += number\n            }\n        }\n        unique.toList", "        var result\
    \ : List[Long] = Nil\n        for (number <- numbers) {\n            if (!result.contains(number))\
    \ {\n                result = number :: result\n            }\n        }\n   \
    \     result.reverse", "        val set = new HashSet[Long]\n        val list\
    \ = new ListBuffer[Long]\n        for (number <- numbers) {\n            if (!set.contains(number))\
    \ {\n                set += number\n                list += number\n         \
    \   }\n        }\n        list.toList", "        var uniqueElements = Map[Long,\
    \ Int]()\n        for (number <- numbers) {\n            if (uniqueElements.contains(number))\
    \ {\n                uniqueElements += (number -> (uniqueElements(number) + 1))\n\
    \            } else {\n                uniqueElements += (number -> 1)\n     \
    \       }\n        }\n        numbers.filter(uniqueElements(_) == 1)", "     \
    \   val map = HashMap[Long, Int]()\n        numbers.foreach(x => map.put(x, map.getOrElse(x,\
    \ 0) + 1))\n        numbers.filter(x => map(x) == 1)", "        var numbersSet\
    \ = HashSet[Long]()\n        var result = List[Long]()\n        for (number <-\
    \ numbers) {\n            if (!numbersSet.contains(number)) {\n              \
    \  numbersSet += number\n                result = number :: result\n         \
    \   }\n        }\n        result.reverse", '        return numbers.foldLeft(List[Long]())((list,
    number) => if (!list.contains(number)) number :: list else list).reverse', " \
    \       var dict = new HashMap[Long, Boolean]()\n        var list = new ListBuffer[Long]()\n\
    \        for (i <- numbers) {\n            if (!dict.contains(i)) {\n        \
    \        dict(i) = true\n                list += i\n            }\n        }\n\
    \        list.toList", '        return numbers.distinct', "        //val numbersSet\
    \ = HashSet[Long]()\n        val numbersSet = scala.collection.mutable.Set[Long]()\n\
    \        val result = scala.collection.mutable.ArrayBuffer[Long]()\n        for\
    \ (number <- numbers) {\n            if (!numbersSet.contains(number)) {\n   \
    \             numbersSet += number\n                result += number\n       \
    \     }\n        }\n        result.toList", "        var uniqueList = List[Long]()\n\
    \        var unique = Set[Long]()\n        for (number <- numbers) {\n       \
    \     if (!unique.contains(number)) {\n                uniqueList = uniqueList\
    \ :+ number\n                unique = unique + number\n            }\n       \
    \ }\n        uniqueList", "        var temp = new ListBuffer[Long]()\n       \
    \ var set = new HashSet[Long]()\n        for (number <- numbers) {\n         \
    \   if (!set.contains(number)) {\n                temp += number\n           \
    \     set += number\n            }\n        }\n        temp.toList", "       \
    \ val freq = numbers.groupBy(identity).mapValues(_.size)\n        val numbers_filtered\
    \ = numbers.filter(x => freq(x) == 1)\n        return numbers_filtered", "   \
    \     var result : List[Long] = List();\n        var hashSet : HashSet[Long] =\
    \ HashSet();\n        for (n <- numbers) {\n            if (!hashSet.contains(n))\
    \ {\n                hashSet.add(n);\n                result = result :+ n;\n\
    \            }\n        }\n        return result;", "        var result = new\
    \ ListBuffer[Long]()\n        var occurance = new HashMap[Long, Long]()\n    \
    \    for (number <- numbers) {\n            if (occurance.contains(number)) {\n\
    \                occurance(number) += 1\n            } else {\n              \
    \  occurance(number) = 1\n            }\n        }\n        for (number <- numbers)\
    \ {\n            if (occurance(number) == 1) {\n                result += number\n\
    \            }\n        }\n        result.toList", "        val counts = new HashMap[Long,\
    \ Long]()\n        for (number <- numbers) {\n            counts(number) = counts.getOrElse(number,\
    \ 0l.toLong) + 1l.toLong\n        }\n        return numbers.filter(number => counts(number)\
    \ == 1l.toLong)", "        val result = numbers.foldLeft(List[Long]())((acc, x)\
    \ => acc match {\n            case Nil => x :: acc\n            case head :: tail\
    \ => if (head == x) acc else x :: acc\n        })\n        result.reverse", " \
    \       val counts = new HashMap[Long, Int]\n        for (i <- numbers) {\n  \
    \          if (counts.contains(i)) {\n                counts.put(i, counts(i)\
    \ + 1)\n            } else {\n                counts.put(i, 1)\n            }\n\
    \        }\n        var result = new ArrayBuffer[Long]\n        for (i <- numbers)\
    \ {\n            if (counts(i) == 1) {\n                result += i\n        \
    \    }\n        }\n        result.toList", "        val s: HashSet[Long] = new\
    \ HashSet[Long]()\n        val result = ListBuffer[Long]()\n        for (n <-\
    \ numbers) {\n            if (!s.contains(n)) {\n                s.add(n)\n  \
    \              result.append(n)\n            }\n        }\n        result.toList",
  "        if (numbers.length == 0) return numbers\n        var list = new ListBuffer[Long]\n\
    \        val numberSet = new HashSet[Long]\n        for (number <- numbers) {\n\
    \            if (!numberSet.contains(number)) {\n                list += number\n\
    \                numberSet += number\n            }\n        }\n        list.toList",
  "        val m = numbers.toSet\n        val newList = new ListBuffer[Long]\n   \
    \     numbers.foreach(i => if (!m.contains(i)) newList += i)\n        newList.toList",
  "        val counter = new HashMap[Long, Int]\n        val filtered = new ListBuffer[Long]\n\
    \        for (number <- numbers) {\n            counter(number) = counter.getOrElse(number,\
    \ 0) + 1\n            if (counter(number) == 1) filtered += number\n        }\n\
    \        filtered.toList", '        ???', "        def remove(result : List[Long],\
    \ numbers : List[Long]) : List[Long] = {\n            if (numbers.length == 0)\
    \ result\n            else if (result.contains(numbers.head)) remove(result, numbers.tail)\n\
    \            else remove(result :+ numbers.head, numbers.tail)\n        }\n  \
    \      remove(List[Long](), numbers)", "        val m = new HashMap[Long, Long]\n\
    \        for (number <- numbers) {\n            m(number) = m.getOrElse(number,\
    \ 0l.toLong) + 1l.toLong\n        }\n        var result = List[Long]()\n     \
    \   for (number <- numbers) {\n            if (m(number) == 1l.toLong) {\n   \
    \             result = number :: result\n            }\n        }\n        result.reverse",
  "        // return numbers.toSet.toList\n        val set = new HashSet[Long]\n \
    \       val list = new ArrayBuffer[Long]\n        for (n <- numbers) {\n     \
    \       if (!set.contains(n)) {\n                set += n\n                list\
    \ += n\n            }\n        }\n        list.toList", "        def removeDuplicatesHelper(numbers\
    \ : List[Long], removeDuplicates : List[Long]) : List[Long] = {\n            if\
    \ (numbers.isEmpty) removeDuplicates\n            else {\n                if (removeDuplicates.contains(numbers.head))\
    \ removeDuplicatesHelper(numbers.tail, removeDuplicates)\n                else\
    \ removeDuplicatesHelper(numbers.tail, removeDuplicates :+ numbers.head)\n   \
    \         }\n        }\n        removeDuplicatesHelper(numbers, List[Long]())",
  "        val hash = new HashMap[Long, Int]()\n        numbers.foreach(n => hash.put(n,\
    \ hash.getOrElse(n, 0) + 1))\n        numbers.filter(n => hash(n) == 1)", "  \
    \      var temp : List[Long] = numbers\n        var result : List[Long] = Nil\n\
    \        while (!temp.isEmpty) {\n            val num = temp.head\n          \
    \  if (temp.count(_ == num) == 1) result = result :+ num\n            temp = temp.filter(_\
    \ != num)\n        }\n        result", "        val counts = HashMap[Long, Long]()\n\
    \        numbers.foreach(n => {\n            if (!counts.contains(n)) counts(n)\
    \ = 0\n            counts(n) += 1\n        })\n        numbers.filter(n => counts(n)\
    \ == 1)", "        val counter = HashMap[Long, Int]()\n        val unique = ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            counter(number) = counter.getOrElse(number,\
    \ 0) + 1\n            if (counter(number) == 1) unique += number\n        }\n\
    \        unique.toList", '        return numbers.toSet.toList', "        var map\
    \ = HashMap[Long, Boolean]()\n        var solution = List[Long]()\n        for\
    \ (n <- numbers) {\n            if (!map.contains(n)) {\n                map +=\
    \ (n -> true)\n                solution = n :: solution\n            }\n     \
    \   }\n        solution.reverse", "        // List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 2l.toLong, 4l.toLong)\n        // 1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong\n        // Map[Long, Int](1 -> 1, 2 -> 2, 3 -> 1, 4 ->\
    \ 1)\n        val counts = numbers.foldLeft(Map[Long, Int]()) {(counts, i) =>\n\
    \            counts + (i -> (counts.getOrElse(i, 0) + 1))\n        }\n       \
    \ // List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)\n     \
    \   // 1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong\n        // Map[Long,\
    \ Int](1 -> 1, 2 -> 2, 3 -> 1, 4 -> 1)\n        // Map[Long, Int](2 -> 2)\n  \
    \      val keep = numbers.foldLeft(Map[Long, Int]()) {(keep, i) =>\n         \
    \   if (counts(i) == 1) keep + (i -> 1) else keep\n        }\n        // List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 4l.toLong)\n        // 1l.toLong, 2l.toLong,\
    \ 3l.toLong, 2l.toLong, 4l.toLong\n        // Map[Long, Int](1 -> 1, 2 -> 2, 3\
    \ -> 1, 4 -> 1)\n        // Map[Long, Int](2 -> 2)\n        // 1l.toLong, 2l.toLong,\
    \ 3l.toLong, 2l.toLong, 4l.toLong\n        // List[Long](1l.toLong, 3l.toLong,\
    \ 4l.toLong)\n        numbers.filter(i => keep.contains(i))", "        val found\
    \ = HashSet[Long]()\n        val remaining = Buffer[Long]()\n        for (i <-\
    \ numbers) {\n            if (!found.contains(i)) {\n                found +=\
    \ i\n                remaining += i\n            }\n        }\n        remaining.toList",
  "        var dict = new HashMap[Long, Int]\n        for (n <- numbers) {\n     \
    \       if (dict.contains(n)) dict(n) += 1\n            else dict(n) = 1\n   \
    \     }\n        var result = new ListBuffer[Long]\n        for (n <- numbers)\
    \ {\n            if (dict(n) == 1) result += n\n        }\n        result.toList",
  "        // This solution is the most concise I could think of\n        // It uses\
    \ the foldLeft method to simply build a list that only has a single\n        //\
    \ occurrence of every element in it\n        numbers.foldLeft(List[Long]())((a,b)\
    \ => if (a.contains(b)) a else a :+ b)", "        // Map of key->count of keys\n\
    \        var map = new HashMap[Long, Int]\n        // List of the new list's numbers\n\
    \        var newNumbers = new ListBuffer[Long]\n        for (number <- numbers)\
    \ {\n            // If we've seen this number before, we add it to the list and\
    \ increment its count\n            if (map.contains(number)) {\n             \
    \   newNumbers += number\n                map += (number -> (map(number) + 1))\n\
    \            }\n            // Otherwise, we add it to the map and add it to the\
    \ list\n            else {\n                map += (number -> 1)\n           \
    \     newNumbers += number\n            }\n        }\n        // Now, we remove\
    \ all the duplicates\n        var set = new HashSet[Long]\n        for (i <- 0\
    \ until newNumbers.length) {\n            val number = newNumbers(i)\n       \
    \     if (map(number) > 1) set += number\n        }\n        var result = new\
    \ ListBuffer[Long]\n        for (i <- 0 until newNumbers.length) {\n         \
    \   val number = newNumbers(i)\n            if (!set.contains(number)) result\
    \ += number\n        }\n        result.toList", "        if (numbers.isEmpty)\
    \ List()\n        else {\n            var numbersLeft = removeDuplicates(numbers.tail)\n\
    \            if (numbersLeft.contains(numbers.head)) numbersLeft\n           \
    \ else numbers.head :: numbersLeft\n        }", "        val duplicateNumbers\
    \ = numbers.groupBy(identity).filter(_._2.size > 1).keySet\n        numbers.filter(n\
    \ => !duplicateNumbers.contains(n))", "        val distinctNumbers = ListBuffer[Long]()\n\
    \        val numbersHash = HashMap[Long, Boolean]()\n        for (n <- numbers)\
    \ {\n            if (!numbersHash.contains(n)) {\n                numbersHash\
    \ += n -> true\n                distinctNumbers += n\n            }\n        }\n\
    \        distinctNumbers.toList", '      return numbers.distinct', "    \tvar\
    \ pos = 0\n    \tvar buffer = numbers\n    \tvar seen = new HashSet[Long]\n  \
    \  \twhile (pos < buffer.length) {\n    \t\tif (seen.contains(buffer(pos))) {\n\
    \    \t\t\tbuffer = buffer.take(pos) ++ buffer.drop(pos + 1)\n    \t\t} else {\n\
    \    \t\t\tseen += buffer(pos)\n    \t\t\tpos += 1\n    \t\t}\n    \t}\n    \t\
    buffer", "        val set = new HashSet[Long]\n        val list = new LinkedList[Long]\n\
    \        for (number <- numbers) {\n            if (!set.contains(number)) {\n\
    \                set += number\n                list += number\n            }\n\
    \        }\n        list.toList", "        var result = List[Long]()\n       \
    \ for (number <- numbers) {\n            if (!result.contains(number)) {\n   \
    \             result = result :+ number\n            }\n        }\n        result",
  "        var map = Map[Long, Int]()\n        numbers.foreach { x => if (map.contains(x))\
    \ map(x) += 1 else map(x) = 1 }\n        return numbers.filter { x => map(x) ==\
    \ 1 }", "        val map = new HashMap[Long, Int]()\n        numbers.foreach(n\
    \ => map(n) = map.getOrElse(n, 0) + 1)\n        numbers.filter(n => map(n) ==\
    \ 1)", "        var unique = HashSet[Long]()\n        val result = ListBuffer[Long]()\n\
    \        for (n <- numbers) {\n            if (!unique.contains(n)) {\n      \
    \          unique += n\n                result += n\n            }\n        }\n\
    \        result.toList", "        def removeDuplicatesRecur(numbers : List[Long],\
    \ seen : List[Long]) : List[Long] = {\n            numbers match {\n         \
    \       case Nil => seen\n                case x :: xs => {\n                \
    \    if (seen.contains(x)) removeDuplicatesRecur(xs, seen)\n                 \
    \   else removeDuplicatesRecur(xs, x :: seen)\n                }\n           \
    \ }\n        }\n        removeDuplicatesRecur(numbers, Nil)", "      var memo\
    \ : HashMap[Long, Long] = new HashMap[Long, Long]()\n      var result : List[Long]\
    \ = Nil\n      for (x <- numbers) {\n        if (memo.contains(x)) {\n       \
    \   memo.update(x, memo(x) + 1)\n        } else {\n          memo.update(x, 1)\n\
    \        }\n      }\n      for (x <- numbers) {\n        if (memo(x) == 1) {\n\
    \          result = x :: result\n        }\n      }\n      result.reverse", '        ???',
  "        var map = new HashMap[Long, Long]\n        for (number <- numbers) {\n\
    \            if (map.contains(number)) map += (number -> (map(number) + 1))\n\
    \            else map += (number -> 1)\n        }\n        return numbers.filter(number\
    \ => map(number) == 1)", "        // Clone the list.\n        var numbers_buf\
    \ = numbers.toBuffer\n        var removals : List[Long] = List[Long]()\n     \
    \   // Iterate over the numbers.\n        while (numbers_buf.length > 0) {\n \
    \           var count = 0\n            val num = numbers_buf(0)\n            for\
    \ (i <- 0 until numbers_buf.length) {\n                if (numbers_buf(i) == num)\
    \ count += 1\n            }\n            if (count > 1) removals = removals :+\
    \ num\n            for (i <- 0 until numbers_buf.length) {\n                if\
    \ (numbers_buf(i) == num) numbers_buf.remove(i)\n            }\n        }\n  \
    \      return numbers_buf.toList", '      return (List[Long]())', "        var\
    \ i = 0\n        val counts = new HashMap[Long, Int]()\n        for (i <- 0 until\
    \ numbers.length) {\n            counts(numbers(i)) = 1 + counts.getOrElse(numbers(i),\
    \ 0)\n        }\n        return numbers.filter(n => counts(n) == 1)", "      \
    \  var r = List[Long]()\n        for (x <- numbers) {\n            if (!r.contains(x))\
    \ {\n                r = x :: r\n            }\n        }\n        r.reverse",
  "        var deduplicatedList = List[Long]()\n        numbers.foreach(number =>\
    \ {\n            if (!deduplicatedList.contains(number)) {\n                deduplicatedList\
    \ = deduplicatedList :+ number\n            }\n        })\n        deduplicatedList",
  '        return numbers.foldLeft(List[Long]())((list, e) => if (list.contains(e))
    list else list :+ e)', "        val l = new ListBuffer[Long]()\n        for (i\
    \ <- numbers) {\n            if (!l.contains(i)) l += i\n        }\n        l.toList",
  '        numbers.toSet.toList', "        var map = Map[Long, Int]()\n        for\
    \ (i <- numbers) {\n            if (map.contains(i)) {\n                map(i)\
    \ += 1\n            } else {\n                map(i) = 1\n            }\n    \
    \    }\n        var result = List[Long]()\n        for (i <- numbers) {\n    \
    \        if (map(i) == 1) {\n                result = i :: result\n          \
    \  }\n        }\n        result.reverse", "        // Initialize a map which will\
    \ contain the count of each number\n        val occurCount = new HashMap[Long,\
    \ Int]\n        numbers.foreach {\n            // Accumulate the count of each\
    \ number\n            occurCount += _ -> (occurCount.getOrElse(_, 0) + 1)\n  \
    \      }\n        // Iterate through the original list and return the numbers\
    \ that\n        // occur less than 2 times.\n        numbers.filter { occurCount(_)\
    \ < 2 }", '        numbers.groupBy(identity).filter(_._2.size == 1).keys.toList',
  "        //      // I think this method is slightly harder to understand\n     \
    \   //      def getOnlyUnique(acc : List[Long], numbers : List[Long]) : List[Long]\
    \ = {\n        //          if (numbers.isEmpty)\n        //              acc\n\
    \        //          else if (acc.contains(numbers.head))\n        //        \
    \      getOnlyUnique(acc, numbers.tail)\n        //          else\n        //\
    \              getOnlyUnique(acc :+ numbers.head, numbers.tail)\n        //  \
    \    }\n        //      getOnlyUnique(List(), numbers)\n        numbers.filter((value\
    \ : Long) => numbers.count((otherValue : Long) => value == otherValue) == 1)",
  '        numbers.groupBy(identity).filter(_._2.size == 1).keys.toList', "      \
    \  var dict = new ListBuffer[Long]()\n        var ret = new ListBuffer[Long]()\n\
    \        for (i <- numbers) {\n            if (!dict.contains(i)) {\n        \
    \        dict += i\n                ret += i\n            }\n        }\n     \
    \   ret.toList", "        val count = numbers.groupBy(identity).mapValues(_.size)\n\
    \        numbers.filter(n => count(n) == 1)", "        numbers.foldLeft(new ListBuffer[Long])((acc,\
    \ x) => {\n            if (!acc.contains(x)) acc += x\n            acc\n     \
    \   }).toList", '        ???', "        // TODO\n        List[Long]()", '        return
    numbers.distinct', "        val result = new ListBuffer[Long]\n        val occurences\
    \ = new HashMap[Long, Boolean]\n        for (number <- numbers) {\n          \
    \  if (!occurences.contains(number)) {\n                occurences += (number\
    \ -> true)\n                result += number\n            }\n        }\n     \
    \   result.toList", '        numbers.toSet.toList', "        require(numbers !=\
    \ null)\n        numbers.distinct", "        //println(numbers)\n        var count\
    \ = new HashMap[Long, Int]()\n        numbers.foreach(e => {\n            if (count.contains(e))\
    \ count(e) += 1\n            else count(e) = 1\n        })\n        var result\
    \ = new ListBuffer[Long]()\n        numbers.foreach(e => {\n            if (count(e)\
    \ == 1) result += e\n        })\n        result.toList", "        numbers.foldLeft(List[Long]())((result,\
    \ n) => {\n            if (result.contains(n)) result else n :: result\n     \
    \   }).reverse", "        val numberSet = HashSet[Long]()\n        val uniqueList\
    \ = ListBuffer[Long]()\n        for (number <- numbers) {\n            if (!numberSet.contains(number))\
    \ {\n                numberSet += number\n                uniqueList += number\n\
    \            }\n        }\n        uniqueList.toList", '        numbers.distinct',
  "        var map = Map[Long, Int]()\n        for (n <- numbers) {\n            if\
    \ (map.contains(n)) map += (n -> (map(n) + 1))\n            else map += (n ->\
    \ 1)\n        }\n        numbers.filter(n => map(n) == 1)", "        // Create\
    \ a HashMap to hold the number of times a number appears in the list.\n      \
    \  val duplicates = HashMap[Long, Int]()\n        // Populate the HashMap.\n \
    \       for (number <- numbers) {\n            if (duplicates.contains(number))\
    \ duplicates(number) += 1\n            else duplicates(number) = 1\n        }\n\
    \        // Filter out the duplicates.\n        val result = numbers.filter(x\
    \ => duplicates(x) == 1)\n        // Return the result.\n        result", "  \
    \      var numberSet = Set[Long]()\n        var result = List[Long]()\n      \
    \  numbers.foreach(number => {\n            if (!numberSet.contains(number)) {\n\
    \                numberSet += number\n                result = result :+ number\n\
    \            }\n        })\n        result", "        var result = List[Long]()\n\
    \        for (n <- numbers) {\n            if (!result.contains(n)) {\n      \
    \          result = n :: result\n            }\n        }\n        result.reverse",
  "        val size = numbers.size\n        val result = ListBuffer[Long]()\n    \
    \    for (i <- 0 until size) {\n            if (result.lastIndexOf(numbers(i))\
    \ == -1) {\n                result += numbers(i)\n            }\n        }\n \
    \       result.toList", '        numbers.groupBy(identity).filter(x => x._2.length
    == 1).map(x => x._1).toList', "        var hash = new HashMap[Long, Int]()\n \
    \       for (x <- numbers) {\n            if (hash.contains(x)) hash(x) += 1\n\
    \            else hash(x) = 1\n        }\n        var list = new ListBuffer[Long]()\n\
    \        for (x <- numbers) {\n            if (hash(x) == 1) list += x\n     \
    \   }\n        list.toList", "        val table = new HashMap[Long, Long]\n  \
    \      for (number <- numbers) {\n            table(number) = table.getOrElse(number,\
    \ 0l.toLong) + 1l.toLong\n        }\n        for (number <- numbers) {\n     \
    \       if (table(number) > 1l.toLong) {\n                table -= number\n  \
    \          }\n        }\n        val result = new ListBuffer[Long]\n        for\
    \ (number <- numbers) {\n            if (table.contains(number)) {\n         \
    \       result += number\n            }\n        }\n        result.toList", " \
    \       val uniqueSet = numbers.toSet\n        uniqueSet.toList", "      numbers.foldLeft(Tuple2(new\
    \ ListBuffer[Long], new HashSet[Long]))((buf, num) => {\n        if (!buf._2.contains(num))\
    \ {\n          buf._1 += num\n          buf._2 += num\n        }\n        buf\n\
    \      })._1.toList", "        val used = Set[Long]()\n        var result = List[Long]()\n\
    \        numbers.foreach(n => {\n            if (!used.contains(n)) {\n      \
    \          used += n\n                result = n :: result\n            }\n  \
    \      })\n        result.reverse", '        numbers.distinct', "        var hash\
    \ = HashMap[Long, Int]()\n        for (i <- numbers) {\n            if (hash.contains(i))\
    \ hash(i) += 1\n            else hash += (i -> 1)\n        }\n        var result\
    \ = List[Long]()\n        for (i <- numbers) {\n            if (hash(i) == 1)\
    \ result = i :: result\n        }\n        result.reverse", "        var set =\
    \ Set[Long]()\n        var answer = List[Long]()\n        for (number <- numbers)\
    \ {\n            if (!set.contains(number)) {\n                answer = answer\
    \ :+ number\n                set = set + number\n            }\n        }\n  \
    \      return answer", "      var result = List[Long]()\n      var table = HashMap[Long,\
    \ Int]()\n      for (number <- numbers) {\n        if (table.contains(number))\
    \ table(number) += 1\n        else table += (number -> 1)\n      }\n      for\
    \ (number <- numbers) if (table(number) == 1) result = result :+ number\n    \
    \  result", "        var map = Map[Long, Long]()\n        for (n <- numbers) {\n\
    \            map(n) = map.getOrElse(n, 0l.toLong) + 1l.toLong\n        }\n   \
    \     var result = List[Long]()\n        for (n <- numbers) {\n            if\
    \ (map(n) == 1l.toLong) result = result :+ n\n        }\n        return result",
  "        var result = List[Long]()\n        var counted = HashMap[Long, Int]()\n\
    \        for (number <- numbers) {\n            if (counted.contains(number))\
    \ counted(number) += 1\n            else counted(number) = 1\n        }\n    \
    \    for (number <- numbers) {\n            if (counted(number) == 1) result =\
    \ result :+ number\n        }\n        result", "        var numMap = Map[Long,\
    \ Int]()\n        for (num <- numbers) {\n            if (numMap.contains(num))\
    \ numMap(num) += 1\n            else numMap(num) = 1\n        }\n        var result\
    \ = List[Long]()\n        for (num <- numbers) {\n            if (numMap(num)\
    \ == 1) result = num :: result\n        }\n        result.reverse", "        numbers.foldLeft((Map[Long,\
    \ Long](), List[Long]()))((b, a) => {\n            if (b._1.contains(a)) (b._1,\
    \ b._2)\n            else (b._1 + (a -> 1l.toLong), b._2 :+ a)\n        })._2",
  "    \tval hs = HashSet[Long]()\n    \tval l = ListBuffer[Long]()\n    \tfor (n\
    \ <- numbers) {\n    \t\tif (!hs.contains(n)) {\n    \t\t\ths += n\n    \t\t\t\
    l += n\n    \t\t}\n    \t}\n    \tl.toList", "        val b = Buffer[Long]()\n\
    \        val s = Set[Long]()\n        for (n <- numbers) {\n            if (!s.contains(n))\
    \ {\n                b += n\n                s += n\n            }\n        }\n\
    \        b.toList", "    \tval numbers2 = numbers.sorted\n    \tvar numbers3 =\
    \ List[Long]()\n    \tvar old = 0l\n    \tfor (n <- numbers2) {\n    \t\tif (n\
    \ != old) {\n    \t\t\tnumbers3 = numbers3 :+ n\n    \t\t\told = n\n    \t\t}\n\
    \    \t}\n    \tnumbers3", "      var numSet = HashSet[Long]()\n      var result\
    \ = List[Long]()\n      for (number <- numbers) {\n        if (!numSet.contains(number))\
    \ {\n          numSet += number\n          result = number :: result\n       \
    \ }\n      }\n      result.reverse", '        numbers.toSet.toList', "       \
    \ if (numbers.length == 0) return numbers\n        var set = Set[Long]()\n   \
    \     var list = List[Long]()\n        for (i <- 0 until numbers.length) {\n \
    \           if (!set.contains(numbers(i))) {\n                set += numbers(i)\n\
    \                list = list :+ numbers(i)\n            }\n        }\n       \
    \ return list", '      numbers.toSet.toList', "      // var result = List[Long]()\n\
    \      // for (i <- numbers) {\n      //   if (!result.contains(i)) {\n      //\
    \     result = i :: result\n      //   }\n      // }\n      // result\n      numbers.toSet.toList",
  "        val indexSet = HashSet[Long]()\n        val outputList = Buffer[Long]()\n\
    \        for (num <- numbers) {\n            if (!indexSet.contains(num)) {\n\
    \                indexSet += num\n                outputList += num\n        \
    \    }\n        }\n        outputList.toList", '        numbers.foldLeft(List[Long]())((acc,
    x) => if (!acc.contains(x)) x :: acc else acc).reverse', "        val map = numbers.groupBy(identity).mapValues(_.size)\n\
    \        var result = List[Long]()\n        for (number <- numbers) {\n      \
    \      if (map(number) == 1) result = result :+ number\n        }\n        result",
  '        numbers.filter(n => numbers.count(_ == n) == 1)', "      numbers.map {\n\
    \        x =>\n          if (numbers.indexOf(x) == numbers.lastIndexOf(x)) {\n\
    \            x\n          } else {\n            -1\n          }\n      }.filter(_\
    \ != -1)", "        numbers.foldLeft((List[Long](), HashSet[Long]()))((result,\
    \ number) => {\n            if (result._2.contains(number)) {\n              \
    \  result\n            } else {\n                (result._1 ++ List(number), result._2.+(number))\n\
    \            }\n        })._1", "        var map = new HashMap[Long, Int]()\n\
    \        numbers.foreach(x => map(x) = map.getOrElse(x, 0) + 1)\n        var list\
    \ = new ListBuffer[Long]()\n        map.keys.foreach(x => if (map(x) == 1) list\
    \ += x)\n        list.toList", "        numbers.foldLeft((List[Long](), Set[Long]()))((a,\
    \ e) => {\n            if (!a._2.contains(e)) (e :: a._1, a._2 + e)\n        \
    \    else a\n        })._1.reverse", "        require(numbers != null)\n     \
    \   numbers.distinct", "        val uniqueNumbers = numbers.toSet\n        val\
    \ result = ListBuffer[Long]()\n        for (n <- numbers) if (uniqueNumbers.contains(n))\
    \ {\n            result += n\n            uniqueNumbers -= n\n        }\n    \
    \    result.toList", "        if (numbers.isEmpty) {\n            numbers\n  \
    \      } else {\n            val (start : List[Long], end : List[Long]) = numbers.splitAt(1)\n\
    \            start.head :: removeDuplicates(end.filter(p => p != start.head))\n\
    \        }", "        var m = Map[Long, Boolean]()\n        for (n <- numbers)\
    \ {\n            if (m.contains(n)) {\n                m -= n\n            } else\
    \ {\n                m += n -> true\n            }\n        }\n        var res\
    \ = List[Long]()\n        for (n <- numbers) {\n            if (m.contains(n))\
    \ {\n                res = n :: res\n                m -= n\n            }\n \
    \       }\n        res.reverse", "        var ret = new ListBuffer[Long]\n   \
    \     var set = new HashSet[Long]\n        for (n <- numbers) {\n            if\
    \ (!set.contains(n)) {\n                ret += n\n                set += n\n \
    \           }\n        }\n        ret.toList", "        val uniqueNumbers = new\
    \ HashSet[Long]()\n        val uniqueNumbersList = new ListBuffer[Long]()\n  \
    \      for (number <- numbers) {\n            if (!uniqueNumbers.contains(number))\
    \ {\n                uniqueNumbers += number\n                uniqueNumbersList\
    \ += number\n            }\n        }\n        uniqueNumbersList.toList", "  \
    \      val duplicates = numbers.groupBy(x => x).filter(x => x._2.length > 1).map(x\
    \ => x._1)\n        numbers.filter(x => !duplicates.contains(x))", "        //throw\
    \ new Exception(\"not implemented\")\n        val list = ArrayBuffer[Long]()\n\
    \        for (i <- numbers) {\n            if (!list.contains(i)) list += i\n\
    \        }\n        list.toList", "        var uniqueNumbers = new ListBuffer[Long]()\n\
    \        for (number <- numbers) {\n            if (!uniqueNumbers.contains(number))\
    \ {\n                uniqueNumbers += number\n            }\n        }\n     \
    \   uniqueNumbers.toList", "        val unique : HashSet[Long] = new HashSet\n\
    \        val result : ListBuffer[Long] = new ListBuffer\n        for (number <-\
    \ numbers) {\n            if (!unique.contains(number)) {\n                unique\
    \ += number\n                result += number\n            }\n        }\n    \
    \    result.toList", '        return numbers.distinct', "        var set = new\
    \ HashSet[Long]\n        numbers.filter(!set.add(_))", '        numbers.groupBy(identity).map(_._2.head).toList',
  "        val occurences = HashMap[Long, Int]()\n        numbers.foreach(number =>\
    \ {\n            if (occurences.contains(number)) {\n                occurences.put(number,\
    \ occurences(number) + 1)\n            } else {\n                occurences.put(number,\
    \ 1)\n            }\n        })\n        numbers.filter(number => occurences(number)\
    \ == 1)", "        var a = List[Long]()\n        for (i <- numbers) {\n      \
    \      if (!a.contains(i)) {\n                a = i :: a\n            }\n    \
    \    }\n        a.reverse", "        val sorted = numbers.sorted\n        var\
    \ result = List[Long]()\n        for (i <- 0 until sorted.length) {\n        \
    \    if (i == 0 || sorted(i) != sorted(i - 1)) {\n                result = result\
    \ :+ sorted(i)\n            }\n        }\n        result", "        val uniqueSet\
    \ = new HashSet[Long]()\n        val uniqueBuffer = new ListBuffer[Long]()\n \
    \       for (number <- numbers) {\n            if (!uniqueSet.contains(number))\
    \ {\n                uniqueSet += number\n                uniqueBuffer += number\n\
    \            }\n        }\n        uniqueBuffer.toList", "        val set = new\
    \ HashSet[Long]()\n        var result = new ListBuffer[Long]()\n        for (n\
    \ <- numbers) {\n            if (!set.contains(n)) {\n                set += n\n\
    \                result += n\n            }\n        }\n        result.toList",
  '        numbers.groupBy(identity).map(_._2.head).toList', "        var s : Set[Long]\
    \ = Set.empty[Long]\n        numbers.filter(x => if (s contains x) false else\
    \ {s += x; true})", "        var uniques = Set[Long]()\n        var result = List[Long]()\n\
    \        for (n <- numbers) {\n            if (!uniques.contains(n)) {\n     \
    \           uniques += n\n                result = n :: result\n            }\n\
    \        }\n        result.reverse", "      if (numbers.isEmpty) List[Long]()\n\
    \      else {\n        // Convert to an array\n        val a = numbers.toArray\n\
    \        val result = new ListBuffer[Long]\n        // Iterate over the array\n\
    \        for (x <- a) {\n          // Count occurrences of x\n          val count\
    \ = a.count(_ == x)\n          // Only add elements that occur once.\n       \
    \   if (count == 1) result += x\n        }\n        result.toList\n      }", " \
    \       val dic = new HashMap[Long, Int]\n        for (x <- numbers) dic(x) =\
    \ dic.getOrElse(x, 0) + 1\n        var result = List[Long]()\n        for (x <-\
    \ numbers) if (dic(x) == 1) result = x :: result\n        result.reverse", " \
    \       var seen = Set[Long]()\n        var uniques = List[Long]()\n        for\
    \ (n <- numbers) {\n            if (!seen.contains(n)) {\n                uniques\
    \ = n :: uniques\n                seen += n\n            }\n        }\n      \
    \  uniques.reverse", '        return List[Long]()', "        var r = new ListBuffer[Long]()\n\
    \        var q = numbers.sorted\n        for (n <- q) {\n            var s = q.filter(e\
    \ => e == n)\n            if (s.length == 1) {\n                r += n\n     \
    \       }\n        }\n        r.toList"]
stop_tokens:
- "\n    }\n"
