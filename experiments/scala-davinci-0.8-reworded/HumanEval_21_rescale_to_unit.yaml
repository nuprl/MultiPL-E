name: HumanEval_21_rescale_to_unit
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n    // such that the smallest number will become 0 and the largest\
  \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
  \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
  \ : List[Float]) : List[Float] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
  \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
  \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
  \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
  \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
  \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
  \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
  \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
completions: ["    \tval min = numbers.min\n    \tval max = numbers.max\n    \tval\
    \ total = max - min\n    \tnumbers.map(x => (x - min) / total)", "        var\
    \ min : Float = numbers.reduce(min(_, _))\n        var max : Float = numbers.reduce(max(_,\
    \ _))\n        numbers.map(n => (n - min) / (max - min))", "    \tval max = numbers.max\n\
    \    \tval min = numbers.min\n    \tval interval = max - min\n    \tnumbers.map(x\
    \ => (x - min) / interval)", "        val min = numbers.min\n        val max =\
    \ numbers.max\n        numbers.map(n => (n - min) / (max - min))", "        val\
    \ min = numbers.reduceLeft(_ min _)\n        val max = numbers.reduceLeft(_ max\
    \ _)\n        val diff = max - min\n        return numbers.map(x => (x - min)\
    \ / diff)", "        var min = numbers.reduceLeft(min(_, _))\n        var max\
    \ = numbers.reduceLeft(max(_, _))\n        numbers.map((x : Float) => (x - min)\
    \ / (max - min))", "        val min = numbers.min\n        val max = numbers.max\n\
    \        return numbers.map((a : Float) => (a - min) / (max - min))", "      \
    \  val numbersSorted = numbers.sorted\n        val max = numbersSorted.last\n\
    \        val min = numbersSorted.head\n        val numRange = max - min\n    \
    \    val rescaled = numbers.map(x => (x - min) / numRange)\n        // println(numbers)\n\
    \        // println(numbersSorted)\n        // println(max)\n        // println(min)\n\
    \        // println(numRange)\n        // println(rescaled)\n        rescaled",
  "        if (numbers.length <= 1) throw new Exception(\"Need at least two numbers\"\
    )\n        val min = numbers.min\n        val max = numbers.max\n        numbers.map(x\
    \ => (x - min) / (max - min))", "      val min = numbers.min\n      val max =\
    \ numbers.max\n      numbers.map(x => (x - min) / (max - min))", "        // >>>\
    \ rescaleToUnit((List[Float](5.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat,\
    \ 1.0f.toFloat)))\n        // (List[Float](1.0f.toFloat, 0.25f.toFloat, 0.5f.toFloat,\
    \ 0.75f.toFloat, 0.0f.toFloat))\n        val sortedNumbers = numbers.sorted\n\
    \        val max = sortedNumbers.last\n        val min = sortedNumbers.head\n\
    \        val diff = max - min\n        numbers.map { num => (num - min) / diff\
    \ }", "      var min = numbers.min\n      var max = numbers.max\n      var n =\
    \ numbers.length\n      var multiplier = 1.0f / (max - min)\n      numbers.map(x\
    \ => (x - min) * multiplier)", "        val max = numbers.max\n        val min\
    \ = numbers.min\n        val range = max - min\n        numbers.map(x => (x -\
    \ min) / range)", "        if (numbers.size <= 1) {\n            numbers\n   \
    \     } else {\n            val min = numbers.min\n            val max = numbers.max\n\
    \            val x = numbers.map(x => (x - min) / (max - min))\n            x\n\
    \        }", "        val minNumber = numbers.min\n        val maxNumber = numbers.max\n\
    \        numbers.map(n => {\n            if (maxNumber == minNumber) 1.0f\n  \
    \          else (n - minNumber) / (maxNumber - minNumber)\n        })", "    \
    \    var max = numbers.reduce((a, b) => max(a, b))\n        var min = numbers.reduce((a,\
    \ b) => min(a, b))\n        if (max == min) {\n            return numbers\n  \
    \      }\n        var unitized = numbers.map(x => (x - min) / (max - min))\n \
    \       return unitized", "        def rescaleToUnitHelper(currentMin : Float,\
    \ currentMax : Float, numbers : List[Float]) : List[Float] = {\n            if\
    \ (numbers.isEmpty)\n                Nil\n            else {\n               \
    \ val transformedNumber = (numbers.head - currentMin) / (currentMax - currentMin)\n\
    \                transformedNumber :: rescaleToUnitHelper(currentMin, currentMax,\
    \ numbers.tail)\n            }\n        }\n        rescaleToUnitHelper(numbers.min,\
    \ numbers.max, numbers)", "        if (numbers.length < 2) throw new IllegalArgumentException(\"\
    numbers must have at least two elements\")\n        val maxElement = numbers.max\n\
    \        val minElement = numbers.min\n        val scale = maxElement - minElement\n\
    \        numbers.map(n => (n - minElement) / scale)", "        val max = numbers.max\n\
    \        val min = numbers.min\n        val diff = max - min\n        if (diff\
    \ == 0) numbers\n        else numbers.map((number : Float) => (number - min) /\
    \ diff)", "        val max = numbers.max\n        val min = numbers.min\n    \
    \    val denom = max - min\n        for (number <- numbers) yield (number - min)\
    \ / denom", "    \tval min = numbers.reduceLeft((x, y) => min(x, y))\n    \tval\
    \ max = numbers.reduceLeft((x, y) => max(x, y))\n    \tnumbers.map(x => (x - min)\
    \ / (max - min))", "        val largest = numbers.max\n        val smallest =\
    \ numbers.min\n        numbers.map(i => (i - smallest) / (largest - smallest))",
  "        var minNumber = Float.MaxValue\n        var maxNumber = Float.MinValue\n\
    \        for (number <- numbers) {\n            if (number < minNumber) {\n  \
    \              minNumber = number\n            }\n            if (number > maxNumber)\
    \ {\n                maxNumber = number\n            }\n        }\n        var\
    \ result = new ListBuffer[Float]\n        for (number <- numbers) {\n        \
    \    result += (number - minNumber) / (maxNumber - minNumber)\n        }\n   \
    \     result.toList", "        val min = numbers.min\n        val max = numbers.max\n\
    \        numbers.map((x : Float) => (x - min) / (max - min))", "        if (numbers.length\
    \ == 0) List()\n        else {\n            val min : Float = numbers.min\n  \
    \          val max : Float = numbers.max\n            numbers.map(n => (n - min)\
    \ / (max - min))\n        }", "        val min = numbers.min\n        val max\
    \ = numbers.max\n        numbers.map(x => (x - min) / (max - min))", "       \
    \ val minimum = numbers.min\n        val maximum = numbers.max\n        numbers.map(number\
    \ => (number - minimum) / (maximum - minimum))", "        val (min, max) = numbers.foldLeft((numbers.head,\
    \ numbers.head))((acc, n) => (min(acc._1, n), max(acc._2, n)))\n        numbers.map(n\
    \ => (n - min) / (max - min))", "        val min = numbers.min\n        val max\
    \ = numbers.max\n        val scale = max - min\n        numbers.map(x => (x -\
    \ min) / scale)", "        val minNumber = numbers.min\n        val maxNumber\
    \ = numbers.max\n        val diff = maxNumber - minNumber\n        numbers.map(x\
    \ => (x - minNumber) / diff)", "        var maximum = Float.MinValue\n       \
    \ var minimum = Float.MaxValue\n        for (i <- numbers) {\n            if (i\
    \ > maximum) {\n                maximum = i\n            }\n            if (i\
    \ < minimum) {\n                minimum = i\n            }\n        }\n      \
    \  numbers.map(x => (x - minimum) / (maximum - minimum))", "        val min =\
    \ numbers.min\n        val max = numbers.max\n        numbers.map(x => (x - min)\
    \ / (max - min))", "        val minValue = numbers.reduceLeft(_ min _)\n     \
    \   val maxValue = numbers.reduceLeft(_ max _)\n        val interval = maxValue\
    \ - minValue\n        numbers.map(x => (x - minValue) / interval)", "        val\
    \ min = numbers.min\n        val max = numbers.max\n        val numbersInRange\
    \ = numbers.map(n => n - min)\n        val scale = max - min\n        numbersInRange.map(n\
    \ => n / scale)", "        val minValue = numbers.min\n        val maxValue =\
    \ numbers.max\n        val length = maxValue - minValue\n        if (length ==\
    \ 0) numbers else numbers.map(n => (n - minValue) / length)", "        val newNumbers\
    \ = numbers.sorted\n        val a = (1 - 0).toFloat / (newNumbers.last - newNumbers.head)\n\
    \        val b = 0 - a * newNumbers.head\n        return newNumbers.map(n => a\
    \ * n + b)", "    \tval minimum = numbers.reduceLeft((x, y) => min(x, y))\n  \
    \  \tval maximum = numbers.reduceLeft((x, y) => max(x, y))\n    \tnumbers.map(x\
    \ => (x - minimum) / (maximum - minimum))", "        numbers.zipWithIndex.map{case\
    \ (number, index) =>\n            val min = numbers.min\n            val max =\
    \ numbers.max\n            if (max == min) number\n            else (number -\
    \ min) / (max - min)\n        }", "    \tval min = numbers.reduceLeft(_ min _)\n\
    \    \tval max = numbers.reduceLeft(_ max _)\n    \tnumbers.map(a => (a - min)\
    \ / (max - min))", "        val minN = numbers.min\n        val maxN = numbers.max\n\
    \        numbers.map(x => (x - minN) / (maxN - minN))", "        val min = numbers.min\n\
    \        val max = numbers.max\n        numbers.map(i => (i - min) / (max - min))",
  "        val min = numbers.reduceLeft(_ min _)\n        val max = numbers.reduceLeft(_\
    \ max _)\n        if (min == max) numbers\n        else numbers.map((n : Float)\
    \ => (n - min) / (max - min))", "        val minValue = numbers.min\n        val\
    \ maxValue = numbers.max\n        val range = maxValue - minValue\n        numbers.map(number\
    \ => (number - minValue) / range)", "        val maximum = numbers.max\n     \
    \   val minimum = numbers.min\n        val normalized = numbers.map(e => if (maximum\
    \ == minimum) (1) else ((e - minimum) / (maximum - minimum)))\n        normalized",
  "        var scaled : List[Float] = List()\n        val max = numbers.max\n    \
    \    val min = numbers.min\n        val diff = max - min\n        numbers.foreach(number\
    \ => scaled ::= (number - min) / diff)\n        scaled.reverse", "        val\
    \ min = numbers.min\n        val max = numbers.max\n        val range = max -\
    \ min\n        numbers.map(x => (x - min) / range)", "        //println(numbers)\n\
    \        var min = Float.MaxValue\n        var max = Float.MinValue\n        for\
    \ (number <- numbers) {\n            min = min min number\n            max = max\
    \ max number\n        }\n        var rescaled = new ListBuffer[Float]\n      \
    \  for (number <- numbers) {\n            rescaled += ((number - min) / (max -\
    \ min))\n        }\n        rescaled.toList", "        var x = numbers.min\n \
    \       var y = numbers.max\n        numbers.map(z => (z - x) / (y - x))", " \
    \       val min : Float = numbers.min\n        val max : Float = numbers.max\n\
    \        numbers.map(x => (x - min) / (max - min))", "        val max = numbers.max\n\
    \        val min = numbers.min\n        numbers.map(x => (x - min) / (max - min))",
  "      val nums = numbers.sorted\n      val min = nums.head\n      val max = nums.last\n\
    \      val delta = max - min\n      numbers.map(x => (x - min) / delta)", "  \
    \      require(numbers.length >= 2)\n        val min = numbers.min\n        val\
    \ max = numbers.max\n        numbers.map(n => (n - min)/(max - min))", "     \
    \   val maxVal = numbers.max\n        val minVal = numbers.min\n        numbers.map(x\
    \ => (x - minVal) / (maxVal - minVal))", "    \tval min = numbers.min\n    \t\
    val max = numbers.max\n    \tval scale = max - min\n    \tnumbers.map(x => (x\
    \ - min) / scale)", "        var minimum = numbers.min\n        var maximum =\
    \ numbers.max\n        numbers.map(n => (n - minimum) / (maximum - minimum))",
  "        val sum = numbers.foldLeft(0f)(_ + _)\n        val average = sum / numbers.length\n\
    \        val max = numbers.foldLeft(Float.MinValue)((b, a) => max(b, a))\n   \
    \     val min = numbers.foldLeft(Float.MaxValue)((b, a) => min(b, a))\n      \
    \  val stddev = sqrt(numbers.foldLeft(0f)((b, a) => b + pow(a - average, 2).toFloat)\
    \ / numbers.length)\n        numbers.map(n => ((n - min) / (max - min)) * (1 -\
    \ 0) + 0)", "        if (numbers.length < 2) throw new Exception(\"Not enough\
    \ numbers\")\n        var minimum : Float = numbers(0)\n        var maximum :\
    \ Float = numbers(0)\n        for (number <- numbers) {\n            if (number\
    \ < minimum) minimum = number\n            if (number > maximum) maximum = number\n\
    \        }\n        val size = maximum - minimum\n        return numbers.map(number\
    \ => (number - minimum) / size)", "        val min = numbers.min\n        val\
    \ max = numbers.max\n        numbers.map(n => (n - min) / (max - min))", "   \
    \     var smallest = numbers.min\n        var largest = numbers.max\n        var\
    \ scale = largest - smallest\n        numbers.map((x) => (x - smallest) / scale)",
  "    \tval minV = numbers.min\n    \tval maxV = numbers.max\n    \tnumbers.map(x\
    \ => (x - minV) / (maxV - minV))", "        val max = numbers.max\n        val\
    \ min = numbers.min\n        numbers.map(x => (x - min) / (max - min))", "   \
    \   if (numbers.length < 2) {\n        return numbers\n      }\n      val min\
    \ = numbers.min\n      val max = numbers.max\n      for (num <- numbers) yield\
    \ {\n        (num - min) / (max - min)\n      }", "        val (min, max) = (numbers.min,\
    \ numbers.max)\n        numbers.map(n => (n - min) / (max - min))", "        if\
    \ (numbers.size < 2) throw new Exception(\"The list should have at least two elements\"\
    )\n        val min = numbers.min\n        val max = numbers.max\n        numbers.map(x\
    \ => (x - min) / (max - min))", "        var out = List[Float]()\n        var\
    \ min = numbers.min\n        var max = numbers.max\n        var range = max -\
    \ min\n        numbers.foreach(x => out = out :+ ((x - min) / range))\n      \
    \  out", "        val min = numbers.reduceLeft(min(_, _))\n        val max = numbers.reduceLeft(max(_,\
    \ _))\n        val range = max - min\n        numbers.map(n => (n - min) / range)",
  "        val min = numbers.min\n        val max = numbers.max\n        if (max -\
    \ min > 0) {\n            numbers.map(x => (x - min) / (max - min))\n        }\
    \ else {\n            numbers\n        }", "        // We do not want to modify\
    \ the given list, so we are going to create a copy of it\n        val copy = numbers.toList\n\
    \        val minValue = copy.min\n        val maxValue = copy.max\n        for\
    \ (i <- 0 until copy.length) {\n            val normalizedValue = (copy(i) - minValue)\
    \ / (maxValue - minValue)\n            copy(i) = normalizedValue\n        }\n\
    \        copy", "        var min = numbers.min\n        var max = numbers.max\n\
    \        val results = numbers.map(n => (n - min) / (max - min))\n        return\
    \ results", "        // Get the maximum and minimum values in a list of numbers,\
    \ along with their indices\n        def getMaxMinIndices(numbers : List[Float])\
    \ : (Float, Float, Int, Int) = {\n            var max = Float.MinValue\n     \
    \       var min = Float.MaxValue\n            var maxIndex = -1\n            var\
    \ minIndex = -1\n            for (i <- 0 until numbers.length) {\n           \
    \     if (numbers(i) > max) {\n                    max = numbers(i)\n        \
    \            maxIndex = i\n                }\n                if (numbers(i) <\
    \ min) {\n                    min = numbers(i)\n                    minIndex =\
    \ i\n                }\n            }\n            (max, min, maxIndex, minIndex)\n\
    \        }\n        val (max, min, maxIndex, minIndex) = getMaxMinIndices(numbers)\n\
    \        val a = 1.0f / (max - min)\n        val b = -a * min\n        val result\
    \ = new Array[Float](numbers.length)\n        for (i <- 0 until numbers.length)\
    \ result(i) = a * numbers(i) + b\n        result.toList", "        val min = numbers.min\n\
    \        val max = numbers.max\n        numbers.map(x => (x - min) / (max - min))",
  "        if (numbers.size <= 1) {\n            throw new Exception(\"Number list\
    \ should be of at least 2 elements\")\n        }\n        val minValue = numbers.min\n\
    \        val maxValue = numbers.max\n        if (minValue == maxValue) {\n   \
    \         numbers.map((_) => 0.5f)\n        } else {\n            numbers.map((number)\
    \ => (number - minValue) / (maxValue - minValue))\n        }", "        val max:\
    \ Float = numbers.max\n        val min: Float = numbers.min\n        val b = max\
    \ - min\n        numbers.map(x => (x - min) / b)", "        val min = numbers.min\n\
    \        val max = numbers.max\n        val diff = max - min\n        numbers.map(x\
    \ => (x - min) / diff)", "        val (min, max) = numbers.foldLeft((Float.MaxValue,\
    \ Float.MinValue))((a, b) => (min(a._1, b), max(a._2, b)))\n        val scale\
    \ = 1 / (max - min)\n        numbers.map(x => scale * (x - min))", "        val\
    \ min = numbers.min\n        val max = numbers.max\n        val m = if (max ==\
    \ min) 1.0f else 1.0f / (max - min)\n        val b = if (max == min) 0.0f else\
    \ -min * m\n        numbers.map(k => m * k + b)", "        def rescale(number\
    \ : Float, min : Float, max : Float) : Float = (number - min) / (max - min)\n\
    \        val min = numbers.min\n        val max = numbers.max\n        numbers.map(rescale(_,\
    \ min, max))", "        val min = numbers.min\n        val max = numbers.max\n\
    \        numbers.map(n => (n - min) / (max - min))", '        numbers.map(n =>
    (n - numbers.min) / (numbers.max - numbers.min))', "        val min = numbers.min\n\
    \        val max = numbers.max\n        numbers.map(x => (x - min) / (max - min))",
  "        val max = numbers.max\n        val min = numbers.min\n        return numbers.map(n\
    \ => (n - min) / (max - min))", "        val min = numbers.min\n        val max\
    \ = numbers.max\n        numbers.map(n => (n - min) / (max - min))", "       \
    \ val minimum = numbers.reduceLeft((a, b) => min(a, b))\n        val maximum =\
    \ numbers.reduceLeft((a, b) => max(a, b))\n        numbers.map(x => (x - minimum)\
    \ / (maximum - minimum))", "        val min_max = numbers.foldLeft((numbers.head,\
    \ numbers.head))((a, b) => (min(a._1, b), max(a._2, b)))\n        val range =\
    \ min_max._2 - min_max._1\n        numbers.map(x => (x - min_max._1) / range)",
  "        var min = Float.MaxValue\n        var max = Float.MinValue\n        numbers.foreach(n\
    \ => {\n            if (n < min) min = n\n            if (n > max) max = n\n \
    \       })\n        return numbers.map(n => (n - min) / (max - min))", "     \
    \   val max = numbers.max\n        val min = numbers.min\n        val diff = max\
    \ - min\n        val oneOverDiff = if (diff != 0.0f) 1.0f / diff else 1.0f\n \
    \       numbers.map(n => (n - min) * oneOverDiff)", "        val (min, max) =\
    \ (numbers.min, numbers.max)\n        for(n <- numbers) yield (n - min) / (max\
    \ - min)", "        val min = numbers.min\n        val max = numbers.max\n   \
    \     val range = max - min\n        numbers.map(x => (x - min) / range)", " \
    \       var min = numbers.min\n        var max = numbers.max\n        numbers.map(x\
    \ => (x - min) / (max - min))", "        val max = numbers.max\n        val min\
    \ = numbers.min\n        val difference = max - min\n        numbers.map(x =>\
    \ (x - min) / difference)", "    \tvar minimum : Float = numbers.head\n    \t\
    var maximum : Float = numbers.head\n    \tfor (number <- numbers) {\n    \t\t\
    if (number < minimum) minimum = number\n    \t\tif (number > maximum) maximum\
    \ = number\n    \t}\n    \tif (maximum == minimum) return numbers\n    \tvar rescaled\
    \ : List[Float] = List()\n    \tfor (number <- numbers) {\n    \t\trescaled =\
    \ rescaled :+ (number - minimum) / (maximum - minimum)\n    \t}\n    \treturn\
    \ rescaled", "        val m = numbers.max\n        val n = numbers.min\n     \
    \   numbers.map(x => if (m == n) 0.0f else ((x - n) / (m - n)))", "        if\
    \ (numbers.length == 0) List[Float]()\n        else {\n            val min = numbers.min\n\
    \            val max = numbers.max\n            numbers.map((x : Float) => (x\
    \ - min) / (max - min))\n        }", "        var maximum = numbers.max\n    \
    \    var minimum = numbers.min\n        for (number <- numbers) yield (number\
    \ - minimum) / (maximum - minimum)", "    \tval min = numbers.min\n    \tval max\
    \ = numbers.max\n    \tval diff = max - min\n    \tnumbers.map(x => (x - min)\
    \ / diff)", "        val minmax = numbers.foldLeft((numbers.head, numbers.head))((b,\
    \ a) => (min(b._1, a), max(b._2, a)))\n        def normalize(x : Float) = (x -\
    \ minmax._1) / (minmax._2 - minmax._1)\n        numbers.map(normalize)", "   \
    \     // >>> (List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat,\
    \ 5.0f.toFloat)).min\n        // 1.0f.toFloat\n        // >>> (List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)).max\n        // 5.0f.toFloat\n\
    \        val minValue = numbers.min\n        val maxValue = numbers.max\n    \
    \    val range = maxValue - minValue\n        numbers.map(num => (num - minValue)\
    \ / range)", "        val minValue = numbers.min\n        val maxValue = numbers.max\n\
    \        val delta = maxValue - minValue\n        numbers.map(x => (x - minValue)\
    \ / delta)", "        val minVal = numbers.min\n        val maxVal = numbers.max\n\
    \        numbers.map(x => (x - minVal) / (maxVal - minVal))", "        val sortedNumbers\
    \ = numbers.sorted\n        val max = sortedNumbers.last\n        val min = sortedNumbers.head\n\
    \        sortedNumbers.map(x => (x - min) / (max - min))", "        val minimum\
    \ = numbers.min\n        val maximum = numbers.max\n        val scale = maximum\
    \ - minimum\n        numbers.map(n => (n - minimum) / scale)", "        var max\
    \ = 0.0f\n        var min = 0.0f\n        for (number <- numbers) {\n        \
    \    if (number > max) max = number\n            if (number < min) min = number\n\
    \        }\n        val scale = 1.0f / (max - min)\n        var scaledNumbers\
    \ = List[Float]()\n        for (number <- numbers) {\n            scaledNumbers\
    \ = scaledNumbers :+ (number - min) * scale\n        }\n        scaledNumbers",
  "        val min = numbers.min\n        val max = numbers.max\n        val length\
    \ = max - min\n        numbers.map(item => (item - min) / length)", "        val\
    \ scale = 1.0f / (numbers.max - numbers.min)\n        numbers.map(x => (x - numbers.min)\
    \ * scale)", "        val min = numbers.min\n        val max = numbers.max\n \
    \       val range = max - min\n        numbers.map(x => (x - min) / range)", " \
    \       numbers.length match {\n            case 0 => List()\n            case\
    \ 1 => List(1.0f)\n            case _ => {\n                val max = numbers.max\n\
    \                val min = numbers.min\n                val length = max - min\n\
    \                numbers.map(x => ((x - min) / length))\n            }\n     \
    \   }", "        val min = numbers.min\n        val max = numbers.max\n      \
    \  return numbers.map(x => (x - min) / (max - min))", "        if (numbers.size\
    \ < 2) {\n            throw new IllegalArgumentException(\"Minimum size of the\
    \ list is 2\")\n        }\n        else {\n            var max : Float = numbers.max\n\
    \            var min : Float = numbers.min\n            var result : List[Float]\
    \ = List()\n            for (number <- numbers) {\n                result = result\
    \ :+ ((number - min) / (max - min))\n            }\n            return result\n\
    \        }", "      require(numbers.length >= 2)\n      val min = numbers.min\n\
    \      val max = numbers.max\n      val delta = max - min\n      numbers.map(e\
    \ => (e - min) / delta)", "      if (numbers.length > 1) {\n        val min =\
    \ numbers.min\n        val max = numbers.max\n        val step = (max - min) /\
    \ (numbers.length - 1)\n        //println(\"min: \" + min + \" max: \" + max +\
    \ \" step: \" + step)\n        var scaled = new ListBuffer[Float]\n        for\
    \ (i <- 0 until numbers.length) {\n          //println(\"i: \" + i + \" i * step:\
    \ \" + i * step + \" min: \" + min)\n          scaled += i * step + min\n    \
    \    }\n        return scaled.toList\n      }\n      return numbers", "    \t\
    val diff = numbers.max - numbers.min\n    \tif (diff == 0) numbers else numbers.map(n\
    \ => (n - numbers.min) / diff)", "        def loop(numbers : List[Float], minimum\
    \ : Float, maximum : Float) : List[Float] = {\n            numbers match {\n \
    \               case Nil => Nil\n                case x :: xs => (x - minimum)\
    \ / (maximum - minimum) :: loop(xs, minimum, maximum)\n            }\n       \
    \ }\n        numbers match {\n            case Nil => Nil\n            case x\
    \ :: xs => loop(numbers, x, xs.max)\n        }", "        val numbersSorted =\
    \ numbers.sorted\n        val _min = numbersSorted.head\n        val _max = numbersSorted.last\n\
    \        if (_min == _max) return numbersSorted.map(number => 0f)\n        val\
    \ _range = _max - _min\n        numbersSorted.map(number => (number - _min) /\
    \ _range)", "        def unitize(value : Float, min : Float, max : Float) : Float\
    \ = {\n            assert(max > min)\n            (value - min) / (max - min)\n\
    \        }\n        val min = numbers.min\n        val max = numbers.max\n   \
    \     numbers.map(unitize(_, min, max))", "        val max = numbers.max\n   \
    \     val min = numbers.min\n        numbers.map(x => (x - min) / (max - min))",
  "        val maxValue = numbers.max\n        val minValue = numbers.min\n      \
    \  val unit = 1f\n        val range = maxValue - minValue\n        numbers.map(n\
    \ => unit * (n - minValue) / range)", "        val (min, max) = (numbers.min,\
    \ numbers.max)\n        val delta = max - min\n        numbers.map {number =>\
    \ (number - min) / delta}", "        var max = Float.MinValue\n        var min\
    \ = Float.MaxValue\n        for (number <- numbers) {\n            if (number\
    \ > max) max = number\n            if (number < min) min = number\n        }\n\
    \        val range = max - min\n        return numbers.map(number => ((number\
    \ - min) / range))", "        if (numbers.size < 2) {\n            numbers\n \
    \       } else {\n            val min = numbers.min\n            val max = numbers.max\n\
    \            val length = max - min\n            numbers.map(x => (x - min) /\
    \ length)\n        }", "    \tif (numbers.size < 2) throw new Exception(\"Rescale\
    \ list must have at least two elements\")\n    \tval min = numbers.reduceLeft(min(_,\
    \ _))\n    \tval max = numbers.reduceLeft(max(_, _))\n    \tval factor = 1 / (max\
    \ - min)\n    \tnumbers.map(x => (x - min) * factor)", "        val minimum =\
    \ numbers.min\n        val maximum = numbers.max\n        val n = numbers.length\n\
    \        numbers.map(x => (x - minimum) / (maximum - minimum))", "        val\
    \ min = numbers.reduceLeft(_ min _)\n        val max = numbers.reduceLeft(_ max\
    \ _)\n        val range = max - min\n        numbers.map(x => (x - min) / range)",
  "        if (numbers.size < 2) throw new IllegalArgumentException\n        val minmax\
    \ = numbers.foldLeft((Float.MaxValue, Float.MinValue))((minmax, x) => (min(minmax._1,\
    \ x), max(minmax._2, x)))\n        val zeroOne = numbers.map(x => (x - minmax._1)\
    \ / (minmax._2 - minmax._1))\n        zeroOne", "        // Assume that we have\
    \ the list to rescale\n        if (numbers.size < 2) return numbers\n        val\
    \ max = numbers.max\n        val min = numbers.min\n        val range = max -\
    \ min\n        val rescaledNumbers = numbers.map(x => (x - min) / range)\n   \
    \     rescaledNumbers", "        val size = numbers.size\n        val maxVal =\
    \ numbers.max\n        val minVal = numbers.min\n        for (val i <- 0 until\
    \ size) yield {\n            val cur = numbers(i)\n            val rescaled =\
    \ (cur - minVal) / (maxVal - minVal)\n            rescaled\n        }", "\t\t\
    if (numbers.length < 2) {\n\t\t\tprintln(\"list needs to have at least two elements\"\
    )\n\t\t\tList()\n\t\t}\n\t\telse {\n\t\t\tval max = numbers.max\n\t\t\tval min\
    \ = numbers.min\n\t\t\tnumbers.map((x) => {\n\t\t\t\tval minMaxDiff = max - min\n\
    \t\t\t\tval numMinDiff = x - min\n\t\t\t\tnumMinDiff / minMaxDiff\n\t\t\t})\n\t\
    \t}\n\t}\n\tdef main(args: Array[String]) {\n\t\tval list = List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)\n\t\tprintln(rescaleToUnit(list))\n\
    \t}\n}", "        val (min, max) = numbers.foldLeft((Float.MaxValue, Float.MinValue))((b,\
    \ a) => (min(b._1, a), max(b._2, a)))\n        numbers.map(x => (x - min) / (max\
    \ - min))", "        val max = numbers.max\n        val min = numbers.min\n  \
    \      var map = new HashMap[Float, Float]\n        for (i <- numbers) map(i)\
    \ = (i - min) / (max - min)\n        var result = new ListBuffer[Float]\n    \
    \    for (i <- numbers) result += map(i)\n        result.toList", "        val\
    \ max = numbers.max\n        val min = numbers.min\n        numbers.map(n => (n\
    \ - min) / (max - min))", "\tval max = numbers.max\n\tval min = numbers.min\n\t\
    val range = max - min\n\tnumbers.map(number => (number - min) / range)", "   \
    \     val min = numbers.reduce((x, y) => if (x < y) x else y)\n        val max\
    \ = numbers.reduce((x, y) => if (x > y) x else y)\n        val spread = max -\
    \ min\n        numbers.map(x => (x - min) / spread)", "        val (min, max)\
    \ = (numbers.min, numbers.max)\n        numbers.map((x : Float) => (x - min) /\
    \ (max - min))", "    \tval max = numbers.max\n    \tval min = numbers.min\n \
    \   \tnumbers.map(x => (x - min) / (max - min))", "        val scale = 1.0f.toFloat\
    \ / (numbers.max - numbers.min)\n        numbers.map(x => (x - numbers.min) *\
    \ scale)", "        val (min, max) = (numbers.min, numbers.max)\n        val range\
    \ = max - min\n        numbers.map(x => (x - min) / range)", "        val ln =\
    \ numbers.length.toFloat\n        var fmin = Float.MaxValue\n        var fmax\
    \ = Float.MinValue\n        var index = 0\n        while (index < ln) {\n    \
    \        if (numbers(index) < fmin) {\n                fmin = numbers(index)\n\
    \            }\n            if (numbers(index) > fmax) {\n                fmax\
    \ = numbers(index)\n            }\n            index += 1\n        }\n       \
    \ if (fmin == fmax) {\n            numbers.map(x => 0.5f)\n        } else {\n\
    \            numbers.map(x => (x - fmin) / (fmax - fmin))\n        }", "     \
    \   // Your code here\n        if (numbers.length == 0) List[Float]()\n      \
    \  else {\n          var max = numbers.max\n          var min = numbers.min\n\
    \          var dif = max - min\n          numbers.map(x => (x - min) / dif)\n\
    \        }", "        var scaledNumbers = new ListBuffer[Float]\n        if (numbers.length\
    \ > 0) {\n            val max = numbers.max\n            val min = numbers.min\n\
    \            scaledNumbers ++= (numbers.map(x => (x - min) / (max - min)))\n \
    \       }\n        scaledNumbers.toList", "        val sorted = numbers.sorted\n\
    \        val diff = sorted.last - sorted.head\n        val unit = 1.0f / diff\n\
    \        sorted.map(x => unit * (x - sorted.head))", "      val max = numbers.max\n\
    \      val min = numbers.min\n      numbers.map(x => (x - min) / (max - min))",
  "        val min = numbers.min\n        val max = numbers.max\n        val factor\
    \ = 1.0f / (max - min)\n        return numbers.map(x => (x - min) * factor)",
  "        val min = numbers.min\n        val max = numbers.max\n        val denominator\
    \ = max - min\n        val f = (x : Float) => (x - min) / denominator\n      \
    \  numbers.map(f)", "      val min = numbers.min\n      val max = numbers.max\n\
    \      val diff = max - min\n      if (diff == 0) {\n        return numbers\n\
    \      }\n      val multiplier = 1 / diff\n      numbers.map(x => (x - min) *\
    \ multiplier)", "        val max = numbers.reduceLeft((a, b) => if (a > b) a else\
    \ b)\n        val min = numbers.reduceLeft((a, b) => if (a < b) a else b)\n  \
    \      numbers.map(x => (x - min) / (max - min))", "      if (numbers.size < 2)\
    \ {\n        throw new RuntimeException(\"input list must contain at least two\
    \ numbers\")\n      }\n      val max = numbers.max\n      val min = numbers.min\n\
    \      val maxMinusMin = max - min\n      numbers.map(e => (e - min) / maxMinusMin)",
  "        val min = numbers.min\n        val max = numbers.max\n        val rescaled\
    \ = numbers.map(x => (x - min) / (max - min))\n        return rescaled", "   \
    \     val (min, max) = (numbers.min, numbers.max)\n        numbers.map(n => (n\
    \ - min) / (max - min))", "        var list = numbers.to[ArrayBuffer]\n      \
    \  var min = list.min\n        var max = list.max\n        var range = max - min\n\
    \        for (i <- 0 until list.length) {\n            list(i) = (list(i) - min)\
    \ / range\n        }\n        return list.toList", "        var min = numbers.min\n\
    \        var max = numbers.max\n        var result = ArrayBuffer[Float]()\n  \
    \      for (number <- numbers) result += (number - min) / (max - min)\n      \
    \  result.toList", "    \tval min = numbers.reduceLeft((a, b) => min(a, b))\n\
    \    \tval max = numbers.reduceLeft((a, b) => max(a, b))\n    \tnumbers.map(n\
    \ => (n - min) / (max - min))", "        val max = numbers.max\n        val min\
    \ = numbers.min\n        val maxMinusMin = max - min\n        numbers.map(x =>\
    \ (x - min) / maxMinusMin)", "      val min = numbers.min\n      val max = numbers.max\n\
    \      val range = max - min\n      numbers.map(x => (x - min) / range)", "  \
    \      var rescaled = List[Float]()\n        val diff = numbers.max - numbers.min\n\
    \        for (n <- numbers) rescaled = (n - numbers.min) / diff :: rescaled\n\
    \        rescaled.reverse", "        val min = numbers.min\n        val max =\
    \ numbers.max\n        numbers.map(n => (n - min) / (max - min))", "        val\
    \ b = numbers.reduceLeft(_ min _)\n        val c = numbers.reduceLeft(_ max _)\n\
    \        val r = c - b\n        numbers.map((x : Float) => if (r == 0) 1.0f else\
    \ (x - b) / r)", "        if (numbers.length > 1) {\n            val max = numbers.max\n\
    \            val min = numbers.min\n            val range = max - min\n      \
    \      if (range == 0) List.fill(numbers.length)(0.0f)\n            else numbers.map(x\
    \ => (x - min) / range)\n        } else numbers", "        val min = numbers.reduce(min)\n\
    \        val max = numbers.reduce(max)\n        numbers.map(x => (x - min) / (max\
    \ - min))", "    \tval min = numbers.reduceLeft(_ min _)\n    \tval max = numbers.reduceLeft(_\
    \ max _)\n    \tnumbers.map(x => (x - min) / (max - min))", "        if (numbers.size\
    \ < 2) throw new IllegalArgumentException(\"List of numbers must have at least\
    \ two elements\")\n        var smallest = numbers(0)\n        var largest = numbers(0)\n\
    \        for (number <- numbers) {\n            if (number < smallest) smallest\
    \ = number\n            if (number > largest) largest = number\n        }\n  \
    \      if (smallest == largest) throw new IllegalArgumentException(\"All numbers\
    \ are equal\")\n        numbers.map(number => ((number - smallest) / (largest\
    \ - smallest)))", "        if (numbers.length < 2) {\n            return numbers\n\
    \        }\n        val sortedNumbers = numbers.sorted\n        val minimum =\
    \ sortedNumbers.head\n        val maximum = sortedNumbers.last\n        val newMinimum\
    \ = 0.0f\n        val newMaximum = 1.0f\n        val linearTransformSlope = (newMaximum\
    \ - newMinimum) / (maximum - minimum)\n        val linearTransformIntercept =\
    \ newMinimum - linearTransformSlope * minimum\n        return numbers.map(i =>\
    \ linearTransformSlope * i + linearTransformIntercept)", "        // Use ListBuffer\
    \ since we need to be able to sort and then take the first and last elements\n\
    \        var list = ListBuffer(numbers : _*)\n        list = list.sorted\n   \
    \     val min = list.head\n        val max = list.last\n        list = list.map(x\
    \ => (x - min) / (max - min))\n        list.toList", "        val min = numbers.min\n\
    \        val max = numbers.max\n        numbers.map(x => (x - min) / (max - min))",
  "        val min : Float = numbers.min\n        val max : Float = numbers.max\n\
    \        val factor : Float = max - min\n        numbers.map(x => (x - min) /\
    \ factor)", "        val max = numbers.max\n        val min = numbers.min\n  \
    \      val range = max - min\n        numbers.map(x => (x - min) / range)", " \
    \       if (numbers.length <= 1) { throw new IllegalArgumentException() }\n  \
    \      val max = numbers.max\n        val min = numbers.min\n        val diff\
    \ = max - min\n        numbers.map(n => (n - min) / diff)", "        val (min,\
    \ max) = (numbers.min, numbers.max)\n        numbers.map(x => (x - min) / (max\
    \ - min))", "        var min = 0.0f\n        var max = 0.0f\n        for (i <-\
    \ 0 until numbers.length) {\n            if (numbers(i) < min) min = numbers(i)\n\
    \            if (numbers(i) > max) max = numbers(i)\n        }\n        var result\
    \ = List[Float]()\n        for (i <- 0 until numbers.length) {\n            result\
    \ = result ++ List((numbers(i) - min) / (max - min))\n        }\n        return\
    \ result", "        var numbersScaled = new ListBuffer[Float]()\n        for (number\
    \ <- numbers) {\n            numbersScaled += (number - numbers.min) / (numbers.max\
    \ - numbers.min)\n        }\n        numbersScaled.toList", "    \tval min = numbers.min\n\
    \    \tval max = numbers.max\n    \tnumbers.map(n => (n - min) / (max - min))",
  "        if (numbers.size < 2)\n            throw new Exception(\"Can't rescale\
    \ list of numbers of less than two elements\")\n        val min = numbers.reduceLeft(_\
    \ min _)\n        val max = numbers.reduceLeft(_ max _)\n        val diff = max\
    \ - min\n        numbers.map(x => (x - min) / diff)", "\t\tif (numbers.length\
    \ < 2) throw new IllegalArgumentException(\"Need at least two numbers to rescale\"\
    )\n\t\tval min = numbers.min\n\t\tval max = numbers.max\n\t\tval spread = max\
    \ - min\n\t\tnumbers.map(n => if (spread == 0) 0 else (n - min) / spread)\n\t\
    }\n\tdef rescaleToUnit(numbers : Array[Float]) : Array[Float] = {\n\t\tif (numbers.length\
    \ < 2) throw new IllegalArgumentException(\"Need at least two numbers to rescale\"\
    )\n\t\tval min = numbers.min\n\t\tval max = numbers.max\n\t\tval spread = max\
    \ - min\n\t\tnumbers.map(n => if (spread == 0) 0 else (n - min) / spread)\n\t\
    }\n\tdef rescaleToUnit(numbers : Array[Double]) : Array[Double] = {\n\t\tif (numbers.length\
    \ < 2) throw new IllegalArgumentException(\"Need at least two numbers to rescale\"\
    )\n\t\tval min = numbers.min\n\t\tval max = numbers.max\n\t\tval spread = max\
    \ - min\n\t\tnumbers.map(n => if (spread == 0) 0 else (n - min) / spread)\n\t\
    }\n\tdef rescaleToUnit(numbers : List[Double]) : List[Double] = {\n\t\tif (numbers.length\
    \ < 2) throw new IllegalArgumentException(\"Need at least two numbers to rescale\"\
    )\n\t\tval min = numbers.min\n\t\tval max = numbers.max\n\t\tval spread = max\
    \ - min\n\t\tnumbers.map(n => if (spread == 0) 0 else (n - min) / spread)\n\t\
    }\n\tdef rescaleToUnit(numbers : Array[Int]) : Array[Double] = {\n\t\tif (numbers.length\
    \ < 2) throw new IllegalArgumentException(\"Need at least two numbers to rescale\"\
    )\n\t\tval min = numbers.min\n\t\tval max = numbers.max\n\t\tval spread = max\
    \ - min\n\t\tnumbers.map(n => if (spread == 0) 0 else (n - min) / spread.toDouble)\n\
    \t}\n", "        if (numbers.length <= 1) throw new IllegalArgumentException(\"\
    Cannot rescale a list with less than two elements\")\n        else {\n       \
    \     val minValue = numbers.min\n            val maxValue = numbers.max\n   \
    \         numbers.map(n => (n - minValue) / (maxValue - minValue))\n        }",
  "        val min = numbers.min\n        val max = numbers.max\n        numbers.map((x)\
    \ => (x - min) / (max - min))", "      val maxNumber = numbers.max\n      val\
    \ minNumber = numbers.min\n      val transformedNumbers = numbers.map(x => (x\
    \ - minNumber)/(maxNumber - minNumber))\n      transformedNumbers", "        val\
    \ minValue = numbers.min\n        val maxValue = numbers.max\n        val delta\
    \ = maxValue - minValue\n        numbers.map(x => if (delta == 0) 0 else (x -\
    \ minValue) / delta)", "        val (min, max) = (numbers.min, numbers.max)\n\
    \        val result = for (n <- numbers) yield n - min\n        for (n <- result)\
    \ yield n / (max - min)", "        // Solution\n        val minNumber = numbers.min\n\
    \        val maxNumber = numbers.max\n        numbers.map(number => (number -\
    \ minNumber) / (maxNumber - minNumber))", "        if (numbers.length == 0) throw\
    \ new IllegalArgumentException(\"List should have at least one element\")\n  \
    \      val max = numbers.max\n        val min = numbers.min\n        val result\
    \ = numbers.map(x => ((x - min) / (max - min)))\n        result", "        val\
    \ min = numbers.min\n        val max = numbers.max\n        for (number <- numbers)\
    \ yield (number - min) / (max - min)", "        val min = numbers.min\n      \
    \  val max = numbers.max\n        numbers.map { x => (x - min) / (max - min) }",
  "        val minValue = numbers.min\n        val maxValue = numbers.max\n      \
    \  val linearTransform = (number : Float) => (number - minValue) / (maxValue -\
    \ minValue)\n        numbers.map(linearTransform)", "        val minimum = numbers.min\n\
    \        val maximum = numbers.max\n        val interval = maximum - minimum\n\
    \        numbers.map(x => (x - minimum) / interval)", "        if (numbers.size\
    \ < 2) {\n            numbers\n        } else {\n            val sortedNumbers\
    \ = numbers.sorted\n            val minVal = sortedNumbers.head\n            val\
    \ maxVal = sortedNumbers.last\n            val range = maxVal - minVal\n     \
    \       val rescaledNumbers = sortedNumbers.map(x => (x - minVal) / range)\n \
    \           rescaledNumbers\n        }", "        val min = numbers.reduceLeft(_\
    \ min _)\n        val max = numbers.reduceLeft(_ max _)\n        val range = max\
    \ - min\n        numbers.map(x => (x - min) / range)", "        val min = numbers.min\n\
    \        val max = numbers.max\n        numbers.map(n => (n - min) / (max - min))",
  "        // sort the list, find the minimum and maximum, then subtract the minimum\
    \ and divide by the difference\n        val sortedNumbers = numbers.sorted\n \
    \       val minimum = sortedNumbers.head\n        val maximum = sortedNumbers.last\n\
    \        val length = maximum - minimum\n        if (length == 0) {\n        \
    \    sortedNumbers\n        } else {\n            sortedNumbers.map(x => (x -\
    \ minimum) / length)\n        }", "        val (min, max) = numbers.foldLeft((Float.MaxValue,\
    \ Float.MinValue))((acc, num) => (min(acc._1, num), max(acc._2, num)))\n     \
    \   val delta = max - min\n        numbers.map(num => ((num - min) / delta))",
  "    \tif (numbers.size == 0) return List()\n    \tval min = numbers.min\n    \t\
    val max = numbers.max\n    \tval delta = max - min\n    \treturn numbers.map(x\
    \ => (x - min) / delta)", "      val length = numbers.length\n      val min =\
    \ numbers.min\n      val max = numbers.max\n      val multiplier = 1.0f / (max\
    \ - min)\n      numbers.map(a => ((a - min) * multiplier))", "        var minimum\
    \ = numbers.min\n        var maximum = numbers.max\n        var scaleFactor =\
    \ 1.0f.toFloat / (maximum - minimum)\n        numbers.map(x => (x - minimum) *\
    \ scaleFactor)", "        val min = numbers.min\n        val max = numbers.max\n\
    \        numbers.map(x => (x - min) / (max - min))", "        // Find max and\
    \ min values\n        val m = numbers.max\n        val n = numbers.min\n     \
    \   if (m == n) numbers else numbers.map(x => (x - n) / (m - n))", "        val\
    \ size = numbers.size\n        val mi = numbers.min\n        val ma = numbers.max\n\
    \        numbers.map((i : Float) => (i - mi) / (ma - mi))", "        val sortedNumbers\
    \ = numbers.sorted\n        val min = sortedNumbers.head\n        val max = sortedNumbers.last\n\
    \        val delta = max - min\n        sortedNumbers.map(n => (n - min) / delta)",
  "        // You can't rescale a list with one element, because what's the scale\
    \ factor?\n        // So it's an error to pass a list with one element\n     \
    \   require(numbers.length > 1)\n        var min = numbers.min\n        var max\
    \ = numbers.max\n        var diff = max - min\n        var factor = 1.0f / diff\n\
    \        var rescaled = numbers.map(n => factor * (n - min))\n        rescaled",
  "        var min = numbers.min\n        var max = numbers.max\n        numbers.map(x\
    \ => (x - min) / (max - min))", "\trequire(numbers.length >= 2)\n\tval minimum\
    \ = numbers.min\n\tval maximum = numbers.max\n\tval range = maximum - minimum\n\
    \tnumbers.map(x => (x - minimum) / range)", "        val min = numbers.min\n \
    \       val max = numbers.max\n        numbers.map(x => (x - min) / (max - min))",
  "        require(numbers.length >= 2)\n        val smallestNumber = numbers.min\n\
    \        val largestNumber = numbers.max\n        numbers.map(x => (x - smallestNumber)\
    \ / (largestNumber - smallestNumber))", "        val max = numbers.max\n     \
    \   val min = numbers.min\n        numbers.map(x => (x - min) / (max - min))"]
stop_tokens:
- "\n    }\n"
