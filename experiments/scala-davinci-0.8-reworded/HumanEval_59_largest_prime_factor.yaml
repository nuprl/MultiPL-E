name: HumanEval_59_largest_prime_factor
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  \    // >>> largestPrimeFactor((13195l))\n    // (29l)\n    // >>> largestPrimeFactor((2048l))\n\
  \    // (2l)\n    def largestPrimeFactor(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestPrimeFactor((15l))\
  \ == (5l));\n    assert(largestPrimeFactor((27l)) == (3l));\n    assert(largestPrimeFactor((63l))\
  \ == (7l));\n    assert(largestPrimeFactor((330l)) == (11l));\n    assert(largestPrimeFactor((13195l))\
  \ == (29l));\n    }\n\n}\n"
completions: ["        def largestPrimeFactorR(n : Long, divisor : Long) : Long =\
    \ {\n            // Assume n is not a prime\n            if (divisor * divisor\
    \ > n) n\n            else if (n % divisor == 0) largestPrimeFactorR(n / divisor,\
    \ divisor)\n            else largestPrimeFactorR(n, divisor + 1)\n        }\n\
    \        largestPrimeFactorR(n, 2)", "        def nextPrime(p : Long) : Long =\
    \ {\n            def isPrime(m : Long) : Boolean = (2l to sqrt(m).toLong).forall(m\
    \ % _ != 0)\n            var x = p + 1\n            while (!isPrime(x)) x += 1\n\
    \            x\n        }\n        var p = 2l\n        var n1 = n\n        while\
    \ (n1 % p != 0) p = nextPrime(p)\n        val d = n1 / p\n        if (d == 1)\
    \ p else max(p, largestPrimeFactor(d))", '        largestPrimeFactorAux(n, floor(sqrt(n)).toLong)',
  "        // We don't need to check factors that are bigger than sqrt(n)\n      \
    \  def getFactors(n : Long, m : Long) : Long = if (n % m == 0) {\n           \
    \ val x = n / m\n            if (x == 1) m else getFactors(x, 2)\n        } else\
    \ {\n            if (m > sqrt(n)) n else getFactors(n, m + 1)\n        }\n   \
    \     getFactors(n, 2)", "        val n2 = sqrt(n).toLong\n        def isPrime(m\
    \ : Long) : Boolean = {\n            if (m == 2) return true\n            if (m\
    \ % 2 == 0) return false\n            for (i <- 3l to sqrt(m).toLong by 2) {\n\
    \                if (m % i == 0) return false\n            }\n            return\
    \ true\n        }\n        for (i <- n2 to 2 by -1) {\n            if (n % i ==\
    \ 0 && isPrime(i)) return i\n        }\n        return n", "        // sieve of\
    \ eratosthenes\n        val numbers = ArrayBuffer.range(2, n+1).toBuffer\n   \
    \     val factors = new HashSet[Long]\n        while (numbers.length > 0) {\n\
    \            val p = numbers.head\n            factors += p\n            numbers\
    \ -= p\n            numbers --= numbers.filter(_ % p == 0)\n        }\n      \
    \  factors.max", "        val primeFactors = findPrimeFactors(n)\n        primeFactors.keys.max",
  "        def largestPrimeFactorHelper(n : Long, d : Long) : Long = {\n         \
    \   if (n == 1) d\n            else if (n % d == 0) largestPrimeFactorHelper(n\
    \ / d, d)\n            else largestPrimeFactorHelper(n, d + 1)\n        }\n  \
    \      largestPrimeFactorHelper(n, 2)", "    \tval primeFactors = primeFactors_(n)\n\
    \    \tprimeFactors.last", "        var cur = n\n        val primes = SortedSet[Long]()\n\
    \        var p = 2l\n        while (cur > 1) {\n            while (cur % p ==\
    \ 0) {\n                primes += p\n                cur /= p\n            }\n\
    \            p += 1\n        }\n        return primes.last", "        // take\
    \ x from 2 to sqrt(n) inclusive.\n        // if x divides n and n/x is prime,\
    \ then we are done.\n        // else, go to next x.\n        var x = 2\n     \
    \   while (x <= sqrt(n)) {\n            if (n % x == 0 && isPrime(n / x)) {\n\
    \                return n / x\n            }\n            x += 1\n        }\n\
    \        // n itself must be prime.\n        n", "        var n2 = n\n       \
    \ var i = 2l\n        var largest = 1l\n        while (i <= n2) {\n          \
    \  if (n2 % i == 0) {\n                largest = i\n                n2 /= i\n\
    \            }\n            else {\n                i += 1\n            }\n  \
    \      }\n        largest", "        var maxPrime = 0l\n        var number = n\n\
    \        while (number % 2 == 0) {\n            maxPrime = 2\n            number\
    \ /= 2\n        }\n        var i = 3\n        while (i <= sqrt(number.toDouble).toInt)\
    \ {\n            while (number % i == 0) {\n                maxPrime = i\n   \
    \             number /= i\n            }\n            i += 2\n        }\n    \
    \    if (number > 2) maxPrime = number\n        return maxPrime", "        var\
    \ largest : Long = -1\n        var factor = 2\n        while (factor * factor\
    \ <= n) {\n            if (n % factor == 0) {\n                largest = factor\n\
    \                while (n % factor == 0) n /= factor\n            }\n        \
    \    factor += 1\n        }\n        if (n > 1) largest = n\n        largest",
  "        def factor(n : Long, start : Long) : Long = {\n            if (n <= 1)\
    \ {\n                -1\n            } else if (n % start == 0) {\n          \
    \      factor(n / start, start)\n            } else {\n                factor(n,\
    \ start + 1)\n            }\n        }\n        factor(n, 2)", "        def helper(x\
    \ : Long, d : Long, p : Long) : Long = {\n            if (d * d > x) x\n     \
    \       else if (x % d == 0) helper(x / d, d, d)\n            else helper(x, d\
    \ + 1, p)\n        }\n        if (n % 2 == 0) helper(n, 2, 2)\n        else helper(n,\
    \ 3, 3)", "        def primeFactors(n : Long) : ArrayBuffer[Long] = {\n      \
    \      val factors = new ArrayBuffer[Long]\n            var x = n\n          \
    \  var primes = Prime.primes(2, sqrt(n).toInt + 1)\n            while (x > 1)\
    \ {\n                for (p <- primes) {\n                    if (x % p == 0)\
    \ {\n                        factors += p\n                        x /= p\n  \
    \                      break\n                    }\n                }\n     \
    \       }\n            factors\n        }\n        val factors = primeFactors(n)\n\
    \        factors.max", "    \tvar i = 2l\n    \twhile (i <= sqrt(n)) {\n    \t\
    \tif (n % i == 0) return largestPrimeFactor(n / i)\n    \t\ti += 1\n    \t}\n\
    \    \tn", "        var x = n\n        var factor = 3\n        while (factor <=\
    \ sqrt(x)) {\n            if (x % factor == 0) {\n                while (x % factor\
    \ == 0) x /= factor\n                if (x == 1) return factor\n            }\n\
    \            factor += 2\n        }\n        return x", "    \tdef findFactors(n\
    \ : Long, factor : Long) : Long = {\n    \t\tif (n % factor == 0) {\n    \t\t\t\
    val quotient = n / factor\n    \t\t\tif (quotient == 1) factor\n    \t\t\telse\
    \ findFactors(quotient, factor)\n    \t\t}\n    \t\telse findFactors(n, factor\
    \ + 1)\n    \t}\n    \tif (n % 2 == 0) findFactors(n, 2)\n    \telse findFactors(n,\
    \ 3)", "        val buf = Buffer[Long]()\n        var max = n\n        var x =\
    \ 2l\n        while (x <= max) {\n            if (max % x == 0) {\n          \
    \      buf += x\n                max /= x\n            }\n            else x +=\
    \ 1\n        }\n        buf.max", "        var maxPrimeFactor = 1l\n        var\
    \ x = n\n        while (x % 2 == 0) {\n            maxPrimeFactor = 2l\n     \
    \       x /= 2\n        }\n        var i = 3l\n        while (i <= sqrt(x)) {\n\
    \            while (x % i == 0) {\n                maxPrimeFactor = i\n      \
    \          x /= i\n            }\n            i += 2\n        }\n        if (x\
    \ > maxPrimeFactor) maxPrimeFactor = x\n        return maxPrimeFactor", "    \
    \    var primeFactors = new ArrayBuffer[Long]()\n        var d = 2\n        while\
    \ (n > 1) {\n            while (n % d == 0) {\n                primeFactors +=\
    \ d\n                n /= d\n            }\n            d += 1\n        }\n  \
    \      primeFactors.max", "        val nf = new mutable.ArrayBuffer[Long]\n  \
    \      def largestPrimeFactor(n : Long, i : Long) : Long = {\n            if (n\
    \ == 1) nf.max\n            else if (n % i == 0) {\n                nf += i\n\
    \                largestPrimeFactor(n / i, i)\n            }\n            else\
    \ largestPrimeFactor(n, i + 1)\n        }\n        largestPrimeFactor(n, 2)",
  "        var max : Long = 1l\n        var i : Long = 2l\n        while (i <= n)\
    \ {\n            if (n % i == 0) {\n                max = i\n                n\
    \ /= i\n            }\n            else {\n                i += 1\n          \
    \  }\n        }\n        return max", "        val x = new Prime.Iterator()\n\
    \        val s = new HashSet[Long]()\n        var t = n\n        for (p <- x)\
    \ {\n            if (t % p == 0) {\n                s += p\n                while\
    \ (t % p == 0) t /= p\n            }\n            if (t == 1) return s.max\n \
    \       }\n        throw new Exception(\"WTF\")", "        def sqrt(n : Long)\
    \ : Long = {\n            def recur(low : Long, high : Long) : Long = {\n    \
    \            if (low > high) high else {\n                    val mid = (low +\
    \ high) / 2\n                    if (mid * mid == n) mid else if (mid * mid <\
    \ n) recur(mid + 1, high) else recur(low, mid - 1)\n                }\n      \
    \      }\n            recur(1, n)\n        }\n        def isPrime(n : Long) :\
    \ Boolean = {\n            var found = false\n            def recur(i : Long)\
    \ : Unit = {\n                if (i <= sqrt(n) && !found) {\n                \
    \    if (n % i == 0) found = true else recur(i + 1)\n                }\n     \
    \       }\n            recur(2)\n            !found\n        }\n        def recur(i\
    \ : Long, n : Long) : Long = {\n            if (i > sqrt(n)) n else {\n      \
    \          if (n % i == 0 && isPrime(i)) recur(i, n / i) else recur(i + 1, n)\n\
    \            }\n        }\n        recur(2, n)", "        var result = 1l\n  \
    \      var i = 2l\n        while (i <= n) {\n            if (n % i == 0) {\n \
    \               result = i\n                while (n % i == 0) n /= i\n      \
    \      }\n            i += 1\n        }\n        result", "        var factor\
    \ = 2l\n        var sqrt = sqrt(n).toLong\n        while (factor <= sqrt) {\n\
    \            if (n % factor == 0) return largestPrimeFactor(n / factor)\n    \
    \        factor += 1\n        }\n        return n", "        var x = n\n     \
    \   val root = sqrt(n).toLong\n        val factors = new LinkedHashSet[Long]\n\
    \        for (i <- 2 to root) {\n            if (x % i == 0) {\n             \
    \   x /= i\n                factors += i\n            }\n        }\n        factors\
    \ += x\n        factors.last", "        def iter(m : Long, factors : List[Long])\
    \ : Long = {\n            if (m == 1) factors.head\n            else if (m % 2\
    \ == 0) iter(m / 2, 2 :: factors)\n            else {\n                val factor\
    \ = (1l to floor(sqrt(m)).toLong).find(m % _ == 0).get\n                iter(m\
    \ / factor, factor :: factors)\n            }\n        }\n        iter(n, Nil)",
  "        var factors = new ArrayBuffer[Long]\n        var cur = n\n        while\
    \ (cur % 2 == 0) {\n            factors += 2\n            cur /= 2\n        }\n\
    \        var i = 3\n        while (i <= sqrt(cur)) {\n            while (cur %\
    \ i == 0) {\n                factors += i\n                cur /= i\n        \
    \    }\n            i += 2\n        }\n        if (cur > 2) factors += cur\n \
    \       return factors.max", "        var largestFactor = 1l\n        if (n %\
    \ 2 == 0) {\n            largestFactor = 2l\n            while (n % 2 == 0) n\
    \ /= 2\n        }\n        for (i <- 3l to sqrt(n).toLong by 2) {\n          \
    \  if (n % i == 0) {\n                largestFactor = i\n                while\
    \ (n % i == 0) n /= i\n            }\n        }\n        if (n != 1) largestFactor\
    \ = n\n        largestFactor", "        val factorization = Problem.factorization(n)\n\
    \        factorization.keys.max", "        var a = 2l\n        var b = n\n   \
    \     var c = 0l\n        //println(a + \" \" + b)\n        while (a <= b) {\n\
    \            if (b % a == 0) {\n                b /= a\n                c = a\n\
    \            }\n            else a += 1\n        }\n        return c", "     \
    \   // Any number n can at most have one prime factor greater than sqrt(n).\n\
    \        val sqrtn = ceil(sqrt(n)).toLong\n        var result = 1l\n        for\
    \ (x <- 2l to sqrtn) {\n            if (n % x == 0) {\n                val y =\
    \ n / x\n                // println(x + \" \" + y)\n                if (isPrime(x))\
    \ result = max(result, x)\n                if (isPrime(y)) result = max(result,\
    \ y)\n            }\n        }\n        result", "        val primes = new PrimeSieve().getPrimesTo(n.toInt)\n\
    \        val result = primes.filter(p => n % p == 0).max\n        println(primes)\n\
    \        println(result)\n        result", "        def largestPrimeFactorIter(n\
    \ : Long, i : Long, j : Long) : Long = {\n            if (n == 1) i\n        \
    \    else if (n % j == 0) largestPrimeFactorIter(n / j, j, j)\n            else\
    \ largestPrimeFactorIter(n, i, j + 1)\n        }\n        val root = sqrt(n).toLong\n\
    \        largestPrimeFactorIter(n, 0, 2)", "        require(n > 1)\n        var\
    \ largestFactor = 0l\n        var k = n\n        while (k % 2 == 0) {\n      \
    \      largestFactor = 2\n            k /= 2\n        }\n        var i = 3\n \
    \       while (i <= sqrt(k)) {\n            while (k % i == 0) {\n           \
    \     largestFactor = i\n                k /= i\n            }\n            i\
    \ += 2\n        }\n        largestFactor max k", "        def isPrime(x : Long)\
    \ : Boolean = {\n            def isPrimeInner(y : Long) : Boolean = {\n      \
    \          if (y * y > x) true\n                else if (x % y == 0) false\n \
    \               else isPrimeInner(y + 1)\n            }\n            isPrimeInner(2)\n\
    \        }\n        def largestPrimeFactorInner(x : Long, factors : List[Long])\
    \ : Long = {\n            if (x == 1) factors.head\n            else if (x % 2\
    \ == 0) largestPrimeFactorInner(x / 2, 2 :: factors)\n            else if (isPrime(x))\
    \ x\n            else {\n                val p = nextPrime(x, 3)\n           \
    \     largestPrimeFactorInner(x / p, p :: factors)\n            }\n        }\n\
    \        largestPrimeFactorInner(n, Nil)", "        var lastFactor = 1l\n    \
    \    var curr = n\n        while (curr > 1) {\n            if (curr % lastFactor\
    \ == 0) {\n                curr /= lastFactor\n                lastFactor = 1\n\
    \            }\n            lastFactor += 1\n        }\n        lastFactor", " \
    \       def getFactor(n : Long, limit : Long, factor : Long) : Long = {\n    \
    \        if (factor > limit) n\n            else if (n % factor == 0) {\n    \
    \            println(n + \" \" + factor)\n                getFactor(n / factor,\
    \ min(n / factor, limit), factor)\n            }\n            else getFactor(n,\
    \ limit, factor + 1)\n        }\n        getFactor(n, sqrt(n).toLong, 2)", " \
    \       // Start with the largest possible prime factor that is smaller than n.\n\
    \        var a = (2 to round(sqrt(n)).toInt).filter(n % _ == 0).last\n       \
    \ var b = n / a\n        // Iterate through all prime factors from largest to\
    \ smallest.\n        while (a != b) {\n            a += 1\n            while (n\
    \ % a != 0) a += 1\n            b = n / a\n        }\n        a", "        def\
    \ largestPrimeFactor(i : Long, n : Long) : Long = {\n            if (n % i ==\
    \ 0)\n                largestPrimeFactor(i, n / i)\n            else if (i > 2)\n\
    \                largestPrimeFactor(i - 1, n)\n            else\n            \
    \    n\n        }\n        largestPrimeFactor(round(sqrt(n)).toLong, n)", "  \
    \      val factors = factor(n)\n        factors.last", '        (2l until sqrt(n).toLong).find(n
    % _ == 0 && (2l until sqrt(_).toLong).forall(_ % _ != 0)).get', "        // TODO:\
    \ Figure out how to handle the case where n is a prime number.\n        if (n\
    \ % 2 == 0) return largestPrimeFactor(n / 2)\n        for (i <- 3 to floor(sqrt(n)).toInt\
    \ by 2) {\n            if (n % i == 0) return largestPrimeFactor(n / i)\n    \
    \    }\n        n", "        // factorize n into a sequence of prime factors and\
    \ return the largest\n        var factors = new ArrayBuffer[Long]()\n        var\
    \ m = n\n        var i = 2l\n        while (i <= m) {\n            if (m % i ==\
    \ 0) {\n                factors += i\n                m /= i\n            }\n\
    \            else i += 1\n        }\n        factors.max", "        var factors\
    \ = HashSet[Long]()\n        var c = n\n        while (c % 2 == 0) {\n       \
    \     factors += 2\n            c /= 2\n        }\n        var factor = 3\n  \
    \      while (c > 1) {\n            while (c % factor == 0) {\n              \
    \  factors += factor\n                c /= factor\n            }\n           \
    \ factor += 2\n        }\n        factors.max", "        def loop(m : Long, lpf\
    \ : Long) : Long = {\n            if (m == 1) lpf\n            else if (m % lpf\
    \ == 0) loop(m / lpf, lpf)\n            else loop(m, nextPrime(lpf))\n       \
    \ }\n        loop(n, 2)", "        var (n1, i) = (n, 2l)\n        while (i * i\
    \ <= n1) {\n            if (n1 % i == 0) {\n                while (n1 % i == 0)\
    \ n1 /= i\n                return largestPrimeFactor(n1) * i\n            }\n\
    \            i += 1\n        }\n        return n1", "        var largest = 1l\n\
    \        var i = 2l\n        while (i * i <= n) {\n            if (n % i == 0)\
    \ {\n                largest = i\n                while (n % i == 0) n /= i\n\
    \            }\n            i += 1\n        }\n        if (n > 1) largest = n\n\
    \        largest", "        val primes = HashSet[Long]()\n        val sqrtn =\
    \ sqrt(n).toLong\n        var a = 2l\n        while (a <= sqrtn) {\n         \
    \   if (n % a == 0) {\n                if (primes.forall(p => a % p != 0)) {\n\
    \                    primes += a\n                }\n            }\n         \
    \   a += 1\n        }\n        if (primes.isEmpty) {\n            n\n        }\
    \ else {\n            primes.toList.sortWith(_ > _).head\n        }", "      \
    \  def largestPrimeFactor0(n : Long, factor : Long) : Long = {\n            if\
    \ (n % factor == 0) largestPrimeFactor0(n / factor, factor)\n            else\
    \ if (factor >= math.sqrt(n)) n\n            else largestPrimeFactor0(n, factor\
    \ + 1)\n        }\n        largestPrimeFactor0(n, 2)", "        val r = sqrt(n).toLong\n\
    \        var ret = n\n        for (i <- 2l to r if (ret % i == 0)) {\n       \
    \     while (ret % i == 0) {\n                ret /= i\n            }\n      \
    \  }\n        return ret", "        var m = n\n        var i = 2l\n        while\
    \ (i <= sqrt(m)) {\n            if (m % i == 0) {\n                m /= i\n  \
    \              while (m % i == 0) m /= i\n            }\n            i += 1\n\
    \        }\n        m", "\tval ps = primes.takeWhile(_ <= sqrt(n)).filter(n %\
    \ _ == 0)\n\tif (ps.isEmpty) n else largestPrimeFactor(n / ps.max)", "       \
    \ var largestFactor = 0l\n        var d = 2l\n        while (d * d <= n) {\n \
    \           if (n % d == 0) {\n                largestFactor = d\n           \
    \     while (n % d == 0) {\n                    n /= d\n                }\n  \
    \          }\n            d += 1\n        }\n        if (n > 1) largestFactor\
    \ = n\n        largestFactor", "        // Get list of prime numbers up to the\
    \ largest factor of n.\n        val primeList = getPrimeList(((ceil(sqrt(n))).toLong))\n\
    \        var factorList = new ArrayBuffer[Long]()\n        // Start with the largest\
    \ prime number possible to be a factor.\n        var factor = primeList.last\n\
    \        // Repeatedly divide n by the largest factor that divides it and add\n\
    \        // that factor to the list of factors.\n        while (factorList.lastOption\
    \ != Some(n)) {\n            if (n % factor == 0) {\n                factorList\
    \ += factor\n                n /= factor\n            }\n            // Decrement\
    \ the factor by 1, which may not be a prime number.\n            factor -= 1\n\
    \        }\n        factorList.last", "        var m = n\n        var p = 2l\n\
    \        var largestFactor = 0l\n        while (m % p == 0) {\n            largestFactor\
    \ = p\n            m /= p\n        }\n        p = 3l\n        while (m > 1) {\n\
    \            while (m % p == 0) {\n                largestFactor = p\n       \
    \         m /= p\n            }\n            p += 2\n        }\n        largestFactor",
  "        def findLargestPrimeFactor(n : Long, currFactor : Long) : Long = {\n  \
    \          if (n <= 1) throw new Exception(\"n must be > 1\")\n            if\
    \ (isPrime(n)) n\n            else if (n % currFactor == 0) findLargestPrimeFactor(n\
    \ / currFactor, currFactor)\n            else findLargestPrimeFactor(n, nextPrime(currFactor))\n\
    \        }\n        findLargestPrimeFactor(n, 2)", "        if (n % 2 == 0) return\
    \ largestPrimeFactor(n / 2)\n        (3 to (n/2).toInt by 2).filter(n % _ == 0).map(i\
    \ => {\n            if (i % 2 == 0) return largestPrimeFactor(i)\n           \
    \ largestPrimeFactor(i)\n        }).max", "        var m = n\n        var i =\
    \ 2l\n        while (i <= m) {\n            if (m % i == 0) {\n              \
    \  m /= i\n                if (isPrime(m)) return m\n            }\n         \
    \   i += 1\n        }\n        -1", "        var result = 0l\n        var m =\
    \ n\n        var i = 2l\n        while (i <= sqrt(m)) {\n            if (m % i\
    \ == 0) {\n                m /= i\n                if (isPrime(m)) {\n       \
    \             result = m\n                    break\n                }\n     \
    \           result = i\n            }\n            i += 1\n        }\n       \
    \ result", "    \tval upperBound = (sqrt(n)).toLong\n    \tval primes = primesIn(2l,\
    \ upperBound)\n    \tprimes.filter(p => n % p == 0).last", "        var k = primeGenerator.next\n\
    \        var m = n\n        while (m > 1) {\n            if (m % k == 0) {\n \
    \               m /= k\n            } else {\n                k = primeGenerator.next\n\
    \            }\n        }\n        k", "        val m = floor(sqrt(n)).toLong\n\
    \        if (m % 2 == 0) largestPrimeFactor(n, m - 1)\n        else largestPrimeFactor(n,\
    \ m)", "        var i = 3l\n        var largest = 0l\n        while (i <= sqrt(n)\
    \ && largest == 0) {\n            if (n % i == 0) {\n                var isPrime\
    \ = true\n                for (k <- 2l to sqrt(i).toLong) {\n                \
    \    if (i % k == 0) {\n                        isPrime = false\n            \
    \            k = sqrt(i).toLong + 1\n                    }\n                }\n\
    \                if (isPrime) largest = i\n            }\n            i += 2\n\
    \        }\n        if (largest == 0) n else largest", "        var largest =\
    \ 0l\n        var current = 2l\n        var value = n\n        while (value >\
    \ 1) {\n            if (value % current == 0) {\n                largest = current\n\
    \                value /= current\n            }\n            else current +=\
    \ 1\n        }\n        largest", "        var x = n\n        var largest = -1l\n\
    \        while (x % 2 == 0) {\n            largest = 2l\n            x /= 2\n\
    \        }\n        var i = 3l\n        while (i <= x) {\n            while (x\
    \ % i == 0) {\n                largest = i\n                x /= i\n         \
    \   }\n            i += 2\n        }\n        largest", "        var i = (sqrt(n)\
    \ + 1).toLong\n        while (i > 0) {\n            if (n % i == 0 && isPrime(i))\
    \ return i\n            i -= 1\n        }\n        0", "        val largestPrimeFactor\
    \ = 1l\n        return largestPrimeFactor", "        var x = n\n        var primes\
    \ = scala.collection.mutable.Set[Long]()\n        var i = 2l\n        while (i\
    \ <= x) {\n            if (x % i == 0) {\n                primes += i\n      \
    \          x /= i\n            }\n            else i += 1\n        }\n       \
    \ primes.max", "        var lpf = 1\n        var i = 2\n        while (i <= sqrt(n))\
    \ {\n            if (n % i == 0) {\n                lpf = i\n                while\
    \ (n % i == 0) n /= i\n            }\n            i += 1\n        }\n        if\
    \ (n > 1) lpf = n\n        lpf", "        var ps = ListBuffer[Long]()\n      \
    \  var n2 = n\n        var i = 2l\n        while (i <= n2) {\n            if (n2\
    \ % i == 0) {\n                n2 /= i\n                ps += i\n            }\n\
    \            else {\n                i += 1\n            }\n        }\n      \
    \  ps.last", "        var d = 2l\n        var x = n\n        while (x > 1) {\n\
    \            while (x % d == 0) {\n                x /= d\n            }\n   \
    \         d += 1\n        }\n        d - 1", "        // The number of factors\
    \ of n is sqrt(n) + 1.\n        val sqrt = Math.sqrt(n).toLong\n        // Prepare\
    \ a list that contains all numbers from 2 to sqrt(n) + 1.\n        var list =\
    \ (1l to sqrt).toList\n        // Prepare an array that contains all numbers from\
    \ 2 to sqrt(n) + 1.\n        var array = list.toArray\n        // Remove all non-prime\
    \ numbers from the list.\n        for (i <- 2 to sqrt.toInt) {\n            if\
    \ (array(i - 1) != 0) {\n                for (j <- i * i to sqrt.toInt by i) {\n\
    \                    array(j - 1) = 0\n                }\n            }\n    \
    \    }\n        // Filter the list for non-prime numbers.\n        list = list.filter(p\
    \ => array(p - 1) != 0)\n        // Filter the list for numbers that divide n.\n\
    \        list = list.filter(p => n % p == 0)\n        // Return the last element\
    \ in the list, which is the largest number.\n        list.last", "        val\
    \ primes = Primes.primes(ceil(sqrt(n)).toInt + 1)\n        primes.find(p => n\
    \ % p == 0).get", "        assert(n > 1 && !primes.isPrime(n), \"Largest prime\
    \ factor of n only exists when n > 1 and n is not a prime.\")\n        var m =\
    \ n\n        var largestFactor = 2l\n        while (m > 1) {\n            val\
    \ factor = smallestFactor(m)\n            m /= factor\n            largestFactor\
    \ = factor\n        }\n        largestFactor", "        var factor:Long = 0\n\
    \        var number:Long = n\n        while (number % 2 == 0) {\n            factor\
    \ = 2\n            number = number / 2\n        }\n        var currentFactor:Long\
    \ = 3\n        while (number > 1) {\n            while (number % currentFactor\
    \ == 0) {\n                factor = currentFactor\n                number = number\
    \ / currentFactor\n            }\n            currentFactor += 2\n        }\n\
    \        factor", "        val primes = new Primes(n / 2)\n        var n2 = n\n\
    \        while (n2 > 1) {\n            val p = primes.next()\n            if (n2\
    \ % p == 0) n2 /= p\n        }\n        n2", "        def largestPrimeFactor(n\
    \ : Long, f : Long) : Long = {\n            if (n % f == 0) largestPrimeFactor(n\
    \ / f, f)\n            else if (f == 2) largestPrimeFactor(n, f + 1)\n       \
    \     else if (f > sqrt(n)) n\n            else largestPrimeFactor(n, f + 2)\n\
    \        }\n        largestPrimeFactor(n, 2)", "        val sieve = new Sieve(n.toInt)\n\
    \        var num = n\n        var largest = 1l\n        var i = 2\n        while\
    \ (num > 1) {\n            if (num % i == 0) {\n                largest = i\n\
    \                num /= i\n            }\n            else {\n               \
    \ i = sieve.nextPrime(i)\n            }\n        }\n        largest", "    \t\
    for (x <- (2l to (n / 2).toLong).toList.reverse) {\n    \t\tif (n % x == 0 &&\
    \ isPrime(x)) return x\n    \t}\n    \treturn 1", "        var maxPrimeFactor\
    \ = -1l\n        for (i <- 1 to sqrt(n).toInt) {\n            if (n % i == 0)\
    \ {\n                if (isPrime(i)) maxPrimeFactor = i\n                if (isPrime(n\
    \ / i)) maxPrimeFactor = n / i\n            }\n        }\n        maxPrimeFactor",
  "        var p = 2l\n        var m = n\n        while (p * p <= m) {\n         \
    \   if (m % p == 0) {\n                while (m % p == 0) {\n                \
    \    m /= p\n                }\n            }\n            p += 1\n        }\n\
    \        if (m > 1) {\n            m\n        } else {\n            p - 1\n  \
    \      }", "    \tvar maxPrime = 2l\n    \twhile (n % 2 == 0) {\n    \t\tn /=\
    \ 2\n    \t}\n    \tfor (i <- 3 to sqrt(n).toInt by 2) {\n    \t\twhile (n % i\
    \ == 0) {\n    \t\t\tmaxPrime = i\n    \t\t\tn /= i\n    \t\t}\n    \t}\n    \t\
    if (n > 2) {\n    \t\tmaxPrime = n\n    \t}\n    \tmaxPrime", "        def recur(n\
    \ : Long, prime : Long, max : Long) : Long = {\n            if (n == 1) max\n\
    \            else if (n % prime == 0) recur(n / prime, prime, prime)\n       \
    \     else recur(n, nextPrime(prime), max)\n        }\n        recur(n, 2, 1)",
  "\t\tval divisors = ArrayBuffer[Long]()\n\t\tvar i = 2l\n\t\tvar nn = n\n\t\twhile\
    \ (i <= sqrt(nn)) {\n\t\t\tif (nn % i == 0) {\n\t\t\t\tdivisors += i\n\t\t\t\t\
    nn /= i\n\t\t\t}\n\t\t\telse i += 1\n\t\t}\n\t\tdivisors += nn\n\t\tdivisors.last",
  "        var d = 2l\n        var nn = n\n        while (nn % d == 0) {\n       \
    \     nn /= d\n        }\n        var dd = d\n        while (dd * dd <= nn) {\n\
    \            while (nn % dd == 0) {\n                nn /= dd\n            }\n\
    \            dd += 1\n        }\n        if (nn == 1) dd - 1 else nn", "\tval\
    \ factors = ArrayBuffer[Long]()\n\tvar k = 2l\n\tvar m = n\n\twhile (k <= m) {\n\
    \t    if (m % k == 0) {\n\t\tfactors += k\n\t\tm /= k\n\t    }\n\t    else k +=\
    \ 1\n\t}\n\tfactors.max", "        var x = n\n        val primes = HashSet[Long]()\n\
    \        while(true) {\n            val factor = smallestFactor(x)\n         \
    \   if (factor == x) {\n                primes += x\n                return primes.max\n\
    \            }\n            primes += factor\n            x /= factor\n      \
    \  }\n        throw new Exception", "        var m = n\n        for (i <- 2l to\
    \ floor(sqrt(n)).toLong) {\n            if (m % i == 0) m /= i\n        }\n  \
    \      m", "        def factorPair(n : Long) : (Long, Long) = {\n            var\
    \ i = 2l\n            while (i <= sqrt(n)) {\n                if (n % i == 0)\
    \ return (i, n / i)\n                i += 1\n            }\n            throw\
    \ new NoSuchElementException\n        }\n        var (f1, f2) = factorPair(n)\n\
    \        if (f1.isPrime) return f1\n        else return largestPrimeFactor(f1)",
  "        // >>> primeFactorization(13195l)\n        // (5, [(29l, 1), (13l, 1)])\n\
    \        // >>> primeFactorization(2048l)\n        // (2, [(2l, 11)])\n      \
    \  def primeFactorization(n : Long) : (Int, Array[(Long, Int)]) = {\n        \
    \    // >>> firstFactor(13195l)\n            // (29l)\n            // >>> firstFactor(7l)\n\
    \            // (7l)\n            def firstFactor(n : Long) : Long = {\n     \
    \           if (n % 2 == 0) return 2\n                var i = 3l\n           \
    \     while (i <= sqrt(n) + 1) {\n                    if (n % i == 0) return i\n\
    \                    i += 2\n                }\n                return n\n   \
    \         }\n            var n2 = n\n            var factors = new ArrayBuffer[(Long,\
    \ Int)]\n            while (n2 != 1) {\n                val f = firstFactor(n2)\n\
    \                val num = factors.find(_._1 == f)\n                if (num.isDefined)\
    \ factors(factors.indexOf(num.get)) = (f, num.get._2 + 1)\n                else\
    \ factors += ((f, 1))\n                n2 /= f\n            }\n            return\
    \ (factors.length, factors.toArray)\n        }\n        primeFactorization(n)._2.last._1",
  "        val limit = sqrt(n).toLong\n        var i = limit\n        while (i > 1)\
    \ {\n            if (n % i == 0 && isPrime(i)) return i\n            i -= 1\n\
    \        }\n        1", "        var x = 3l\n        while (x <= sqrt(n)) {\n\
    \            if (n % x == 0) return largestPrimeFactor(n / x)\n            x +=\
    \ 2\n        }\n        n", "        val factors = mutable.ListBuffer[Long]()\n\
    \        var x = n\n        while (x % 2 == 0) {\n            factors += 2\n \
    \           x /= 2\n        }\n        var i = 3\n        while (i <= sqrt(x))\
    \ {\n            while (x % i == 0) {\n                factors += i\n        \
    \        x /= i\n            }\n            i += 2\n        }\n        if (x >\
    \ 2) factors += x\n        factors.max", "        var largestFactor = 1l\n   \
    \     var i = 2l\n        var num = n\n        while (i <= num) {\n          \
    \  if (num % i == 0) {\n                largestFactor = i\n                num\
    \ /= i\n            }\n            else {\n                i += 1\n          \
    \  }\n        }\n        largestFactor", "        assert(n > 1)\n        var c\
    \ = n\n        for (p <- primes.takeWhile(p => p * p <= n)) {\n            while\
    \ (c % p == 0) {\n                c /= p\n            }\n        }\n        if\
    \ (c == 1) {\n            n / 2\n        } else {\n            c\n        }",
  '        return 0', "        val primes = Primes(sqrt(n).toInt)\n        var result\
    \ = 0l\n        for (p <- primes) {\n            if (n % p == 0) result = p\n\
    \        }\n        result", "        val factors = ListBuffer[Long]()\n     \
    \   for (i <- 2l to sqrt(n).toLong) {\n            if (n % i == 0) {\n       \
    \         if (isPrime(i)) factors += i\n                if (isPrime(n / i)) factors\
    \ += n / i\n            }\n        }\n        factors.max", "        val m = n\n\
    \        val l = (2l to ceil(sqrt(m)).toLong).filter(d => m % d == 0 && (2l to\
    \ ceil(sqrt(d)).toLong).forall(x => d % x != 0)).max\n        l", "        var\
    \ n1 = n\n        var maxFactor = 0l\n        var i = 2l\n        while (i <=\
    \ n1) {\n            if (n1 % i == 0) {\n                n1 /= i\n           \
    \     maxFactor = i\n            }\n            else i += 1\n        }\n     \
    \   maxFactor", "        var d = 2l\n        var nn = n\n        while (nn !=\
    \ 1) {\n            if (nn % d == 0) {\n                nn /= d\n            }\
    \ else {\n                d += 1\n            }\n        }\n        d", "    \
    \    def go(n : Long, largest : Long) : Long = {\n            def nextFactor(n\
    \ : Long, factor : Long) : Long = {\n                if (n % factor == 0) factor\n\
    \                else nextFactor(n, factor + 1)\n            }\n            if\
    \ (n == 1) largest\n            else {\n                val factor = nextFactor(n,\
    \ 2)\n                go(n / factor, max(largest, factor))\n            }\n  \
    \      }\n        go(n, 0)", "        def nextPrime(primes : List[Long]) : Long\
    \ = {\n            var candidate = primes.last\n            var found = false\n\
    \            while (!found) {\n                candidate += 2\n              \
    \  if (primes.forall(candidate % _ != 0)) {\n                    found = true\n\
    \                }\n            }\n            candidate\n        }\n        def\
    \ largestPrimeFactorIter(n : Long, primes : List[Long]) : Long = {\n         \
    \   if (n == 1) primes.last\n            else if (n % primes.last == 0) largestPrimeFactorIter(n\
    \ / primes.last, primes)\n            else largestPrimeFactorIter(n, nextPrime(primes)\
    \ :: primes)\n        }\n        largestPrimeFactorIter(n, List(2l))", "     \
    \   var lpf = 1l\n        var num = n\n        while (lpf < num) {\n         \
    \   lpf += 1\n            while (num % lpf == 0) num /= lpf\n        }\n     \
    \   lpf", "        require(n > 1)\n        var maxPrimeFactor = -1l\n        var\
    \ remaining = n\n        var i = 2l\n        while (i <= sqrt(n)) {\n        \
    \    if (remaining % i == 0) {\n                maxPrimeFactor = i\n         \
    \       remaining /= i\n                while (remaining % i == 0) remaining /=\
    \ i\n            }\n            i += 1\n        }\n        if (remaining != 1)\
    \ maxPrimeFactor = max(maxPrimeFactor, remaining)\n        maxPrimeFactor", " \
    \       var x = n\n        var i = 2l\n        while (i * i <= x) {\n        \
    \    if (x % i == 0) x /= i\n            else i += 1\n        }\n        x", " \
    \   \tval d = 2l\n    \tval m = n / d\n    \tif (m % d == 0) {\n    \t\tlargestPrimeFactor(m)\n\
    \    \t} else {\n    \t\tlargestPrimeFactorAux(n, 3l)\n    \t}", "    \tvar primeFactors\
    \ = MutableList[Long]()\n    \tvar cur = n\n    \tvar i = 2l\n    \twhile (i <=\
    \ cur) {\n    \t\tif (cur % i == 0) {\n    \t\t\tprimeFactors += i\n    \t\t\t\
    cur /= i\n    \t\t}\n    \t\telse i += 1\n    \t}\n    \treturn primeFactors.last",
  "        def largestPrimeFactorHelper(x : Long, f : Long) : Long = {\n         \
    \   if (x == 1) f\n            else if (x % f == 0) largestPrimeFactorHelper(x\
    \ / f, f)\n            else largestPrimeFactorHelper(x, f + 1)\n        }\n  \
    \      largestPrimeFactorHelper(n, 2)", "        val factors = ArrayBuffer[Long]()\n\
    \        var x = n\n        while (x % 2 == 0) {\n            factors += 2\n \
    \           x /= 2\n        }\n        var factor = 3\n        while (x > 1) {\n\
    \            while (x % factor == 0) {\n                factors += factor\n  \
    \              x /= factor\n            }\n            factor += 2\n        }\n\
    \        factors.last", "\tdef largestFactorHelper(p : Long, r : Long) : Long\
    \ = {\n\t    if (r == 1) p\n\t    else {\n\t\tval d = r / p\n\t\tif (d * p ==\
    \ r) largestFactorHelper(p, d)\n\t\telse largestFactorHelper(p + 1, r)\n\t   \
    \ }\n\t}\n\tlargestFactorHelper(2, n)", "        def recur(d : Long, r : Long)\
    \ : Long = {\n            if (r == 1) d\n            else if (r % d == 0) recur(d,\
    \ r / d)\n            else recur(d + 1, r)\n        }\n        recur(2, n)", " \
    \       val sqrt = sqrt(n).toLong\n        var p = 2l\n        while (p <= sqrt)\
    \ {\n            if (n % p == 0) return largestPrimeFactor(n / p)\n          \
    \  p += 1\n        }\n        n", "        def largestPrimeFactorHelper(n : Long,\
    \ currPrime : Long) : Long = {\n            if (n % currPrime == 0) largestPrimeFactorHelper(n\
    \ / currPrime, currPrime)\n            else if (currPrime == 2) largestPrimeFactorHelper(n,\
    \ currPrime + 1)\n            else if (currPrime % 2 == 0) largestPrimeFactorHelper(n,\
    \ currPrime + 1)\n            else largestPrimeFactorHelper(n, currPrime + 2)\n\
    \        }\n        largestPrimeFactorHelper(n, 2)", "        // Factor out the\
    \ largest prime factor\n        var m = n\n        var p = 2l\n        while (m\
    \ > 1) {\n            while (m % p == 0) {\n                m /= p\n         \
    \   }\n            p += 1\n        }\n        p - 1", "        var i = n\n   \
    \     for (j <- 2l to i/2l) {\n            while (i % j == 0) {\n            \
    \    i /= j\n            }\n        }\n        i", "        def divides(n : Long,\
    \ divisor : Long) : Boolean = n % divisor == 0\n        def factors(n : Long)\
    \ : List[Long] = {\n            var list = List[Long]()\n            val ub =\
    \ sqrt(n).toLong\n            var divisor = 2l\n            while (divisor <=\
    \ ub) {\n                if (divides(n, divisor)) {\n                    list\
    \ = divisor :: list\n                    list = (n / divisor) :: list\n      \
    \          }\n                divisor += 1\n            }\n            return\
    \ list\n        }\n        return factors(n).filter(Prime.isPrime).max", "   \
    \     def largestPrimeFactorAcc(n : Long, factor : Long) : Long = {\n        \
    \    if (n % factor == 0) {\n                if (n / factor == 1) factor\n   \
    \             else largestPrimeFactorAcc(n / factor, factor)\n            }\n\
    \            else {\n                if (factor == 2) largestPrimeFactorAcc(n,\
    \ factor + 1)\n                else largestPrimeFactorAcc(n, factor + 2)\n   \
    \         }\n        }\n        largestPrimeFactorAcc(n, 2)", "        def isPrime(num\
    \ : Long) : Boolean = {\n            if (num == 2 || num == 3) return true\n \
    \           if (num % 2 == 0 || num % 3 == 0) return false\n            var divisor\
    \ = 6l\n            while (divisor * divisor - 2 * divisor + 1 <= num) {\n   \
    \             if (num % (divisor - 1) == 0) return false\n                if (num\
    \ % (divisor + 1) == 0) return false\n                divisor += 6\n         \
    \   }\n            return true\n        }\n        var maxPrime = -1l\n      \
    \  var num = n\n        while (num % 2 == 0) {\n            maxPrime = 2\n   \
    \         num /= 2\n        }\n        var factor = 3l\n        while (factor\
    \ * factor <= num) {\n            if (num % factor == 0) {\n                if\
    \ (isPrime(factor)) maxPrime = factor\n                while (num % factor ==\
    \ 0) num /= factor\n            }\n            factor += 2\n        }\n      \
    \  if (num > 2) maxPrime = num\n        return maxPrime", "        /*\n      \
    \  n match {\n            case n if n <= 3 => n\n            case n if n % 2 ==\
    \ 0 => largestPrimeFactor(n / 2)\n            case n if n % 3 == 0 => largestPrimeFactor(n\
    \ / 3)\n            case n => largestPrimeFactor(n - 1)\n        }\n        */\n\
    \        var r = sqrt(n).toLong\n        while (r > 2) {\n            if (n %\
    \ r == 0 && isPrime(r)) return r\n            r -= 1\n        }\n        return\
    \ 1", "        var i = 2l\n        var m = n\n        while (i * i <= m) {\n \
    \           if (m % i == 0) m /= i\n            else i += 1\n        }\n     \
    \   m", "        var primes = new LinkedHashSet[Long]\n        var (i, max) =\
    \ (2l, sqrt(n).toLong)\n        while (i <= max) {\n            while (n % i ==\
    \ 0) {\n                primes += i\n                n /= i\n                max\
    \ = sqrt(n).toLong\n            }\n            i += 1\n        }\n        if (n\
    \ > 1) primes += n\n        primes.max", "        def loop(x : Long, acc : Long)\
    \ : Long = {\n            //println(x + \",\" + acc)\n            if (x == 1)\
    \ acc\n            else if (x % acc == 0) loop(x / acc, acc)\n            else\
    \ loop(x, acc + 1)\n        }\n        loop(n, 2)", "        def largestPrimeFactor0(n\
    \ : Long, i : Long, k : Long) : Long = if (i == k) i else if (n % i == 0) largestPrimeFactor0(n\
    \ / i, i, n) else largestPrimeFactor0(n, i + 1, k)\n        largestPrimeFactor0(n,\
    \ 2, n)", "        // Any factor of n must be at most its square root.\n     \
    \   val upperBound = ceil(sqrt(n)).toLong\n        // For each odd i < upperBound,\
    \ check to see if i divides n. If it does,\n        // store the factor i and\
    \ divide n by i.\n        var factor = n\n        for (i <- 3 to upperBound by\
    \ 2) {\n            while (factor % i == 0) {\n                factor /= i\n \
    \           }\n        }\n        // If factor = n, then n has no prime factors.\n\
    \        if (factor == n) 2\n        else factor", "        val primes = sieve(n)\n\
    \        var largestPrime = 1l\n        for (p <- primes) {\n            if (n\
    \ % p == 0) largestPrime = p\n        }\n        largestPrime", "        val ps\
    \ = PrimeSieve(ceil(sqrt(n)).toInt)\n        var d = n\n        var i = 0\n  \
    \      while (d > 1) {\n            while (d % ps(i) == 0) {\n               \
    \ d /= ps(i)\n            }\n            i += 1\n        }\n        ps(i - 1)",
  "        def oddFactors(n : Long) : Stream[Long] = {\n            if (n % 2 == 0)\n\
    \                Stream.empty\n            else {\n                val end = (sqrt(n)\
    \ + 1).toLong\n                var i = 3\n                while (i <= end && n\
    \ % i != 0)\n                    i += 2\n                if (i > end)\n      \
    \              Stream.empty\n                else\n                    Stream.cons(i,\
    \ oddFactors(n / i))\n            }\n        }\n        if (n % 2 == 0) {\n  \
    \          largestPrimeFactor(n / 2)\n        } else {\n            oddFactors(n).head\n\
    \        }", "        def loop(m : Long, factor : Long) : Long = {\n         \
    \   if (m == 1) factor\n            else if (m % factor == 0) loop(m / factor,\
    \ factor)\n            else loop(m, factor + 1)\n        }\n        loop(n, 2)",
  "        val factors = allFactors(n)\n        factors.filter(isPrime).max", "  \
    \      val factors = new ListBuffer[Long]\n        var nextFactor = 2l\n     \
    \   var quotient = n\n        while (quotient > 1) {\n            if (quotient\
    \ % nextFactor == 0) {\n                factors += nextFactor\n              \
    \  quotient /= nextFactor\n            }\n            else {\n               \
    \ nextFactor += 1\n            }\n        }\n        factors.last", "        var\
    \ x = n\n        var res = 0L\n        while (x % 2 == 0) {\n            res =\
    \ 2\n            x /= 2\n        }\n        var i = 3\n        while (i <= math.sqrt(x))\
    \ {\n            while (x % i == 0) {\n                res = i\n             \
    \   x /= i\n            }\n            i += 2\n        }\n        if (x > 2) return\
    \ x\n        return res", "        var (div, max) = (2l, 0l)\n        while (div\
    \ <= n) {\n            if (n % div == 0) {\n                n /= div\n       \
    \         max = max max div\n            }\n            else div += 1\n      \
    \  }\n        max", "        val lim = sqrt(n).toLong\n        val factors = new\
    \ ListBuffer[Long]\n        var c = n\n        for (p <- 2l to lim) {\n      \
    \      while (c % p == 0) {\n                factors += p\n                c /=\
    \ p\n            }\n        }\n        if (c > 1) factors += c\n        factors.max",
  "        val factors = mutable.Buffer[Long]()\n        def isPrime(n : Long) : Boolean\
    \ = {\n            for (i <- 2 to sqrt(n).toInt) if (n % i == 0) return false\n\
    \            true\n        }\n        for (i <- 2 to sqrt(n).toInt) if (n % i\
    \ == 0 && isPrime(i)) factors += i\n        factors.max", "        var c = n\n\
    \        var p = 2l\n        while (c > 1) {\n            if (c % p == 0) {\n\
    \                c /= p\n            } else {\n                p += 1\n      \
    \      }\n        }\n        p", "        assert(n > 1)\n        largestPrimeFactor(n,\
    \ 3l)", "        val primes = Sieve.getPrimesTo(n.toInt)\n        var p = n\n\
    \        for (prime <- primes) {\n            if (p % prime == 0) {\n        \
    \        p /= prime\n                if (p == 1) return prime\n            }\n\
    \        }\n        p", "        var divisor = 2l\n        var largestFactor =\
    \ 0l\n        while (n > 1) {\n            while (n % divisor == 0) {\n      \
    \          largestFactor = divisor\n                n /= divisor\n           \
    \ }\n            divisor += 1\n        }\n        largestFactor", "        var\
    \ factors = HashSet[Long]()\n        var cur = n\n        while (cur % 2 == 0)\
    \ {\n            factors += 2\n            cur /= 2\n        }\n        var i\
    \ = 3\n        while (i <= sqrt(cur)) {\n            while (cur % i == 0) {\n\
    \                factors += i\n                cur /= i\n            }\n     \
    \       i += 2\n        }\n        if (cur > 2) factors += cur\n        factors.max",
  "        var factors = getFactors(n)\n        var largestFactor = 0l\n        for\
    \ (f <- factors) {\n            if (f > largestFactor && isPrime(f)) {\n     \
    \           largestFactor = f\n            }\n        }\n        largestFactor",
  "        var result = n\n        val primes = Math.primes\n        while (result\
    \ > 1) {\n            if (result % primes.head == 0) {\n                result\
    \ /= primes.head\n            } else {\n                primes.next\n        \
    \    }\n        }\n        primes.head", "        var largest = 0l\n        var\
    \ divisor = 2l\n        while (n > 1) {\n            if (n % divisor == 0) {\n\
    \                largest = divisor\n                n /= divisor\n           \
    \ }\n            else divisor += 1\n        }\n        largest", "        var\
    \ largestFactor = 0l\n        var m = n\n        var i = 2l\n        while (i\
    \ <= m) {\n            if (m % i == 0) {\n                largestFactor = i\n\
    \                m /= i\n            }\n            else i += 1\n        }\n \
    \       largestFactor", "        // Parse out the first prime factor.\n      \
    \  val (p, next) = parsePrimeFactor(n)\n        // If we found a prime factor,\
    \ get the largest prime factor of the rest.\n        if (p > 1) p max largestPrimeFactor(next)\n\
    \        // Otherwise n itself is prime.\n        else n", "        val primeNumbers\
    \ = new SortedSet[Long]()\n        for (i <- 2l to n) {\n            var foundPrime\
    \ = true\n            for (prime <- primeNumbers) {\n                if (i % prime\
    \ == 0) {\n                    foundPrime = false\n                    break\n\
    \                }\n            }\n            if (foundPrime) {\n           \
    \     primeNumbers += i\n                if (n % i == 0) return i\n          \
    \  }\n        }\n        return -1", "        val sqrt = Math.sqrt(n).toLong\n\
    \        // n is not a prime\n        assert(n > 1 && !isPrime(n))\n        def\
    \ helper(m : Long) : Long = {\n            if (m < 2) throw new Exception(\"m\
    \ must be greater than or equal to 2\")\n            if (m % 2 == 0) {\n     \
    \           if (n % m == 0) m\n                else helper(m - 1)\n          \
    \  }\n            else helper(m - 1)\n        }\n        val result = helper(sqrt)\n\
    \        // result must be a factor of n\n        assert(n % result == 0)\n  \
    \      result", "        def f(i : Long) : Long = {\n            if (i <= 1) n\n\
    \            else if (n % i == 0) f(i - 1) max f(n / i)\n            else f(i\
    \ - 1)\n        }\n        f(sqrt(n).toLong)", "        def loop(n : Long, divisor\
    \ : Long) : Long = {\n            if (n % divisor == 0) loop(n / divisor, divisor)\n\
    \            else if (divisor > sqrt(n)) n\n            else loop(n, divisor +\
    \ 1)\n        }\n        loop(n, 2)", "        // This code is slow, but it is\
    \ correct.\n        // It relies on the fact that the number of prime factors\
    \ of a number\n        // is equal to the number of distinct prime factors of\
    \ the number.\n        var i = 2l\n        var j = n\n        var maxFactor =\
    \ 1l\n        while (i <= j) {\n            if (j % i == 0) {\n              \
    \  maxFactor = i\n                j /= i\n            } else {\n             \
    \   i += 1\n            }\n        }\n        return maxFactor", "        var\
    \ sqrtn = ceil(sqrt(n)).toLong\n        while (sqrtn >= 2) {\n            if (n\
    \ % sqrtn == 0 && isPrime(sqrtn)) return sqrtn\n            sqrtn -= 1\n     \
    \   }\n        return -1l", "        val primes = Sieve.primes(sqrt(n).toInt +\
    \ 1)\n        for (i <- primes.length - 1 to 0 by -1) {\n            if (n % primes(i)\
    \ == 0) {\n                return primes(i)\n            }\n        }\n      \
    \  // Impossible to reach this code, since n is assumed to be a composite number.\n\
    \        -1", "        // The largest prime factor of a number is less than or\
    \ equal to the square root of the number\n        val range = 2l to (floor(sqrt(n))).toLong\n\
    \        // Start with the highest possible factor and work downwards\n      \
    \  val factors = range.filter(n % _ == 0).reverse\n        val primeFactors =\
    \ factors.filter(isPrime(_))\n        primeFactors.head", "        var i = 2\n\
    \        while (n > 1) {\n            while (n % i == 0) {\n                n\
    \ /= i\n            }\n            i += 1\n        }\n        i - 1", "      \
    \  var a = 2l\n        while (a < n / 2) {\n            if (n % a == 0) {\n  \
    \              val b = largestPrimeFactor(n / a)\n                if (b > a) a\
    \ = b\n            }\n            a += 1\n        }\n        a", "        val\
    \ r = new util.Random(1)\n        def isProbablePrime(n : Long) : Boolean = {\n\
    \            if (n <= 1) return false\n            val m = n - 1\n           \
    \ val k = 0\n            while (m % 2 == 0) {\n                m /= 2\n      \
    \      }\n            for (i <- 0 until 100) {\n                val a = r.nextInt(n.toInt\
    \ - 2) + 2\n                var b = pow(a, m).toLong\n                var j =\
    \ 0\n                while (j < k && b != 1 && b != n - 1) {\n               \
    \     b = (b * b) % n\n                    j += 1\n                }\n       \
    \         if (b != n - 1 && j % 2 == 0) {\n                    return false\n\
    \                }\n            }\n            return true\n        }\n      \
    \  var count = 0\n        var max = 0l\n        for (i <- (2l to n)) {\n     \
    \       if (isProbablePrime(i)) {\n                if (n % i == 0) {\n       \
    \             count += 1\n                    max = i\n                }\n   \
    \         }\n        }\n        return max", "        val primes = Primes.getPrimes(math.floor(math.sqrt(n).toLong).toInt)\n\
    \        var i = primes.length - 1\n        while (n % primes(i) != 0) i -= 1\n\
    \        return primes(i)", "        var currentMax = -1l\n        // The following\
    \ code is slow because it computes all the prime numbers\n        // up to sqrt(n).\
    \ As we iterate, we should discard numbers that are\n        // divisible by prime\
    \ numbers we have already found.\n        var x = 2l\n        while (x * x <=\
    \ n) {\n            if (n % x == 0) {\n                currentMax = x\n      \
    \          n /= x\n            }\n            else x += 1\n        }\n       \
    \ return max(currentMax, n)", "        var remainder = n\n        var factor =\
    \ 2l\n        while (remainder > 1) {\n            while (remainder % factor ==\
    \ 0) {\n                remainder /= factor\n            }\n            factor\
    \ += 1\n        }\n        factor - 1", "        var i = 2l\n        var n1 =\
    \ n\n        var factor = 1l\n        while (i <= n1) {\n            if (n1 %\
    \ i == 0) {\n                factor = i\n                n1 /= i\n           \
    \ }\n            else {\n                i += 1\n            }\n        }\n  \
    \      factor", "        val sqrt = sqrt(n).toLong\n        var i = sqrt\n   \
    \     while (i > 1) {\n            if (n % i == 0 && isPrime(i)) return i\n  \
    \          i -= 1\n        }\n        throw new Error(\"Should not reach here:\
    \ \" + n)", "        var (m, largestPrime) = (n, 1l)\n        // factor 2 as much\
    \ as possible\n        while (m % 2 == 0) {\n            largestPrime = 2\n  \
    \          m /= 2\n        }\n        // find 3 or larger primes\n        var\
    \ (i, end) = (3, sqrt(m).toInt)\n        while (i <= end) {\n            if (m\
    \ % i == 0) {\n                largestPrime = i\n                m /= i\n    \
    \            end = sqrt(m).toInt\n            }\n            else i += 2\n   \
    \     }\n        // if m is not 1, then m is the last largest prime factor of\
    \ n\n        if (m != 1) largestPrime = m\n        largestPrime", "        val\
    \ primeFactors = primeFactorsList(n)\n        primeFactors(primeFactors.length\
    \ - 1)", "        def factors(n : Long) : List[Long] = {\n            def factorsHelper(n\
    \ : Long, d : Long) : List[Long] = {\n                if (d * d > n) List(n)\n\
    \                else if (n % d == 0) d :: factorsHelper(n / d, d)\n         \
    \       else factorsHelper(n, d + 1)\n            }\n            factorsHelper(n,\
    \ 2)\n        }\n        factors(n).last", "        def recur(n : Long, factor\
    \ : Long) : Long = {\n            if (n == 1) {\n                return factor\n\
    \            }\n            if (n % factor == 0) {\n                return recur(n\
    \ / factor, factor)\n            }\n            else {\n                return\
    \ recur(n, factor + 1)\n            }\n        }\n        return recur(n, 2)",
  "        if (n % 2 == 0) return 2\n        else {\n            var i = 3\n     \
    \       while (i <= sqrt(n)) {\n                if (n % i == 0) return largestPrimeFactor(n\
    \ / i)\n                i += 2\n            }\n            return n\n        }",
  "        var factor = 0l\n        var max = 0l\n        for (i <- 2l to sqrt(n).toLong)\
    \ {\n            if (n % i == 0) {\n                factor = if (i % 2 == 0) i\
    \ / 2 else i\n                max = if (factor > max) factor else max\n      \
    \      }\n        }\n        if (max > 0) return max\n        else return n",
  "        // Start with the largest prime factor, 3 and move down.\n        var x\
    \ = (n - 1) / 2\n        while (x > 2) {\n            if (isPrime(x) && n % x\
    \ == 0) return x\n            x -= 1\n        }\n        2l", "        var remainder\
    \ = n\n        var i = 2l\n        while (i <= remainder) {\n            if (remainder\
    \ % i == 0) {\n                remainder /= i\n                if (remainder %\
    \ i != 0) i = 2l\n            }\n            else i += 1\n        }\n        i",
  "        var d = 2l\n        var sqrt = sqrt(n).toLong\n        while (d <= sqrt)\
    \ {\n            if (n % d == 0) {\n                val largest = largestPrimeFactor(n\
    \ / d)\n                return largest\n            }\n            d += 1\n  \
    \      }\n        return n", "        var m = n\n        var i = 2l\n        while\
    \ (i <= m) {\n            if (m % i == 0) {\n                m /= i\n        \
    \    } else {\n                i += 1\n            }\n        }\n        return\
    \ i", "        var i = 2l\n        var m = n\n        var p = 2l\n        while\
    \ (m > 1) {\n            if (m % i == 0) {\n                m /= i\n         \
    \       p = i\n            }\n            else i += 1\n        }\n        p",
  "\t\tvar maxPrime = -1l\n\t\tval primeFactors = new HashSet[Long]\n\t\tvar count\
    \ = 2l\n\t\twhile (count <= sqrt(n)) {\n\t\t\tif (n % count == 0) {\n\t\t\t\t\
    if (isPrime(count)) {\n\t\t\t\t\tprimeFactors += count\n\t\t\t\t\tif (count >\
    \ maxPrime) maxPrime = count\n\t\t\t\t}\n\t\t\t\tif (isPrime(n / count)) {\n\t\
    \t\t\t\tprimeFactors += n / count\n\t\t\t\t\tif (n / count > maxPrime) maxPrime\
    \ = n / count\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount += 1\n\t\t}\n\t\treturn maxPrime",
  "        var factor = 2l\n        var current = n\n        while (current % factor\
    \ == 0) {\n            current /= factor\n        }\n        factor += 1\n   \
    \     while (factor * factor <= current) {\n            while (current % factor\
    \ == 0) {\n                current /= factor\n            }\n            factor\
    \ += 2\n        }\n        return current", "        // Find the largest prime\
    \ factor of n.\n        val result = sqrt(n).toLong + 1\n        for (i <- 2 to\
    \ result.toInt) {\n            if (n % i == 0) {\n                val factor =\
    \ n / i\n                if (isPrime(factor)) {\n                    return factor\n\
    \                }\n            }\n        }\n        return 0", "        val\
    \ powers = primeFactorPower(n)\n        val factor = powers.maxBy(_._2)._1\n \
    \       factor", "        val rp = n.to(0).reverse.filter(x => n % x == 0 && isPrime(x))\n\
    \        rp(0)", "        def largestPrimeFactor(n : Long, i : Long) : Long =\
    \ {\n            if (i * i > n) n\n            else if (n % i == 0) largestPrimeFactor(n\
    \ / i, i)\n            else largestPrimeFactor(n, i + 1)\n        }\n        largestPrimeFactor(n,\
    \ 2)", "        var n_ = n\n        var largestFactor = 1l\n        // we only\
    \ need to check up to sqrt(n)\n        val max = sqrt(n).toLong\n        // check\
    \ every 2nd odd number starting from 3\n        for (i <- 3 to max by 2) {\n \
    \           // check if i is a factor of n\n            while (n_ % i == 0) {\n\
    \                n_ /= i\n                largestFactor = i\n            }\n \
    \       }\n        // largestFactor might be 1, in which case we haven't found\
    \ a factor\n        // yet. So return n. If n is prime, that is the only factor.\n\
    \        if (largestFactor == 1) n else largestFactor", "        var result =\
    \ -1l\n        var i = 1l\n        while (n >= pow(i, 2)) {\n            if (n\
    \ % i == 0) {\n                val factor = i\n                result = if (factor\
    \ > result && isPrime(factor)) factor else result\n                val otherFactor\
    \ = n / factor\n                result = if (otherFactor > result && isPrime(otherFactor))\
    \ otherFactor else result\n            }\n            i += 1\n        }\n    \
    \    result", "        var m = n\n        var max = 2l\n        for (i <- 2l to\
    \ sqrt(n).toLong) {\n            if (m % i == 0) {\n                if (isPrime(i))\
    \ max = i\n                while (m % i == 0) m /= i\n            }\n        }\n\
    \        if (m > max) max = m\n        max", "        var i = 2l\n        var\
    \ div = n\n        while (i * i <= div) {\n            if (div % i == 0) {\n \
    \               div /= i\n            } else {\n                i += 1\n     \
    \       }\n        }\n        div", "        var result = 1l\n        var m =\
    \ n\n        for (i <- 2 to sqrt(n).toInt) {\n            while (m % i == 0) {\n\
    \                result = i\n                m /= i\n            }\n        }\n\
    \        if (m > 1) result = m\n        result", "        def primes(n : Long)\
    \ : List[Long] = {\n            val ns = new ListBuffer[Long]\n            (1l\
    \ until (sqrt(n) + 1)).foreach {i => if (n % i == 0) ns += i}\n            val\
    \ nList = ns.toList\n            val nList2 = nList.reverse\n            nList\
    \ ::: nList2\n        }\n        def largestPrime(n : Long) : Long = {\n     \
    \       primes(n).filter(p => (p != 1 && p != n) && isPrime(p)).max\n        }\n\
    \        if (isPrime(n)) n else largestPrime(n)", "        val g = (i : Long)\
    \ => i * i\n        var m = n / 2 + 1\n        while (m > 1) {\n            if\
    \ (n % m == 0 && isPrime(m)) return m\n            m -= 1\n        }\n       \
    \ return n", "        def recur(n : Long, acc : Long) : Long = {\n           \
    \ if (n == 1) return acc\n            if (n % acc == 0) recur(n / acc, acc)\n\
    \            else recur(n, acc + 1)\n        }\n        recur(n, 2)", "\t\tif\
    \ (n % 2 == 0)\n\t\t\tlargestPrimeFactor(n / 2)\n\t\telse {\n\t\t\tvar nn = n\n\
    \t\t\tvar i = 3\n\t\t\twhile (nn > 1) {\n\t\t\t\tif (nn % i == 0)\n\t\t\t\t\t\
    nn /= i\n\t\t\t\telse\n\t\t\t\t\ti += 2\n\t\t\t}\n\t\t\ti\n\t\t}", "        var\
    \ factor = 2l\n        var input = n\n        var result = 0l\n        while (input\
    \ > 1) {\n            if (input % factor == 0) {\n                input /= factor\n\
    \                result = factor\n            }\n            else factor += 1\n\
    \        }\n        result", "        def f(n : Long, d : Long) : Long = if (n\
    \ % d == 0) max(d, f(n / d, d)) else f(n, d + 1)\n        f(n, 2)", "        var\
    \ result = 0l\n        val factors = getFactors(n)\n        var i = factors.length\
    \ - 1\n        while (i >= 0) {\n            if (isPrime(factors(i))) {\n    \
    \            result = factors(i)\n                i = -1\n            }\n    \
    \        i -= 1\n        }\n        result", "    \t// Start by getting a list\
    \ of primes up to sqrt(n).\n    \tval primes = primesUpTo(sqrt(n).toInt)\n   \
    \ \t// Go through primes in descending order and return the first one that divides\
    \ n.\n    \tfor (p <- primes.reverse) {\n    \t\tif (n % p == 0) return p\n  \
    \  \t}\n    \tn", "        val factors = factorize(n).sorted\n        factors(factors.length\
    \ - 1)", "        // Trial division\n        var lpf = 1l\n        var i = 2l\n\
    \        while (i <= n) {\n            if (n % i == 0) {\n                // i\
    \ is a prime factor\n                n /= i\n                lpf = i\n       \
    \     } else {\n                i += 1\n            }\n        }\n        lpf",
  "        var primeFactors = ArrayBuffer[Long]()\n        var current = n\n     \
    \   while (current % 2 == 0) {\n            primeFactors += 2\n            current\
    \ /= 2\n        }\n        // Go up to sqrt(n) since you don't need to check past\
    \ this\n        for (i <- 3l to sqrt(n).toLong by 2) {\n            while (current\
    \ % i == 0) {\n                primeFactors += i\n                current /= i\n\
    \            }\n        }\n        if (current > 2) primeFactors += current\n\
    \        // The last prime factor added will be the largest\n        primeFactors.last",
  "        // Brute force approach.\n        def compute(num : Long, p : Long) : Long\
    \ = {\n            if (num % p == 0)\n                if (isPrime(num / p))\n\
    \                    num / p\n                else\n                    compute(num\
    \ / p, p)\n            else\n                compute(num, p + 1)\n        }\n\
    \        compute(n, 2)"]
stop_tokens:
- "\n    }\n"
