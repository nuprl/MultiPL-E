name: HumanEval_12_longest
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n    // strings of the same length. Return None in case the input\
  \ list is empty.\n    // >>> longest((List[String]()))\n    // None\n    // >>>\
  \ longest((List[String](\"a\", \"b\", \"c\")))\n    // \"a\"\n    // >>> longest((List[String](\"\
  a\", \"bb\", \"ccc\")))\n    // \"ccc\"\n    def longest(strings : List[String])\
  \ : Option[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(longest((List[String]())).equals(None));\n\
  \    assert(longest((List[String](\"x\", \"y\", \"z\"))).equals(\"x\"));\n    assert(longest((List[String](\"\
  x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"))).equals(\"zzzz\"));\n    }\n\
  \n}\n"
completions: ["        val lenList = strings.map(s => s.length).sortWith(_ > _)\n\
    \        if (lenList.length == 0) None\n        else strings.find(s => s.length\
    \ == lenList(0))", "        if (strings.isEmpty) {\n            None\n       \
    \ } else {\n            var length = strings(0).length\n            var index\
    \ = 0\n            for (i <- 1 until strings.length) {\n                if (strings(i).length\
    \ > length) {\n                    length = strings(i).length\n              \
    \      index = i\n                }\n            }\n            Some(strings(index))\n\
    \        }", "        if (strings.isEmpty) None\n        else Some(strings.maxBy(_.length))",
  "    \tvar maxLength = 0\n    \tvar longestString : Option[String] = None\n    \t\
    strings.foreach {\n    \t    string => {\n    \t        val len = string.length\n\
    \    \t        if (len > maxLength) {\n    \t            maxLength = len\n   \
    \ \t            longestString = Some(string)\n    \t        }\n    \t    }\n \
    \   \t}\n    \tlongestString", "        strings match {\n            case Nil\
    \ => None\n            case x :: xs => {\n                val y = longest(xs)\n\
    \                y match {\n                    case None => Some(x)\n       \
    \             case Some(z) => if (x.length > z.length) Some(x) else Some(z)\n\
    \                }\n            }\n        }", "        if (strings.isEmpty) {\n\
    \            None\n        } else {\n            Some(strings.maxBy(s => s.length))\n\
    \        }", "        var result : Option[String] = None\n        if (strings.isEmpty)\
    \ return result\n        var maxLen = 0\n        for (s <- strings) if (s.length\
    \ > maxLen) {\n            maxLen = s.length\n            result = Some(s)\n \
    \       }\n        result", "        // TODO: Implement function here\n      \
    \  return None", "      strings match {\n        case Nil => None\n        case\
    \ xs => xs.reduceLeft((x, y) => if (x.length > y.length) x else y)\n      }",
  "        if (strings.isEmpty) None\n        else Some(strings.sortWith(_.length\
    \ < _.length).last)", "        strings match {\n            case Nil => None\n\
    \            case h :: t => longest(t) match {\n                case None => Some(h)\n\
    \                case Some(h1) => if (h.length > h1.length) Some(h) else Some(h1)\n\
    \            }\n        }", "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.maxBy(_.length)\n            Some(longest)\n\
    \        }", "        def loop(strings : List[String], longest : Option[String])\
    \ : Option[String] = strings match {\n            case Nil => longest\n      \
    \      case head :: tail => {\n                val length = head.length\n    \
    \            val newlongest = longest match {\n                    case None =>\
    \ Some(head)\n                    case Some(s) => {\n                        if\
    \ (length > s.length) Some(head)\n                        else longest\n     \
    \               }\n                }\n                loop(tail, newlongest)\n\
    \            }\n        }\n        loop(strings, None)", "        if (strings.length\
    \ == 0) None\n        else {\n            var longest = strings(0)\n         \
    \   for (str <- strings) {\n                if (str.length() > longest.length())\
    \ longest = str\n            }\n            Some(longest)\n        }", "     \
    \   var max = strings.headOption\n        for (str <- strings) {\n           \
    \ if (str.length > max.getOrElse(\"\").length) {\n                max = Some(str)\n\
    \            }\n        }\n        max", "        // If there are no strings in\
    \ the list\n        if (strings.isEmpty) {\n            None\n        }\n    \
    \    // There are strings in the list\n        else {\n            // Create empty\
    \ variable to store the longest string\n            var longestString : String\
    \ = \"\"\n            // Loop through the list of strings\n            for (string\
    \ <- strings) {\n                // If the length of the current string is longer\
    \ than the length of the current\n                // longest string, then the\
    \ current string becomes the new longest string\n                if (string.length\
    \ > longestString.length) {\n                    longestString = string\n    \
    \            }\n            }\n            // Return the longest string\n    \
    \        Some(longestString)\n        }", "        return strings match {\n  \
    \          case List() => None\n            case x :: xs => {\n              \
    \  val longestInTail = longest(xs)\n                longestInTail match {\n  \
    \                  case None => Some(x)\n                    case Some(s) => if\
    \ (x.length > s.length) Some(x) else Some(s)\n                }\n            }\n\
    \        }", "        strings match {\n            case Nil => None\n        \
    \    case x :: Nil => Some(x)\n            case x :: y :: Nil => if (x.length\
    \ > y.length) Some(x) else Some(y)\n            case _ => Some(strings.sortWith((x,\
    \ y) => x.length > y.length)(0))\n        }", "        if (strings.length == 0)\
    \ None\n        else {\n            var result = strings(0)\n            for (i\
    \ <- 1 until strings.length) {\n                if (strings(i).length > result.length)\
    \ result = strings(i)\n            }\n            Some(result)\n        }", " \
    \       if (strings.length > 0) return Some(strings.maxBy(s => s.length))\n  \
    \      else return None", "        if (strings.length == 0) {\n            None\n\
    \        } else {\n            var max : String = strings(0)\n            for\
    \ (string <- strings) {\n                if (string.length > max.length) {\n \
    \                   max = string\n                }\n            }\n         \
    \   Some(max)\n        }", "        if (strings.length == 0) None\n        else\
    \ {\n            var result = strings(0)\n            for (i <- 1 until strings.length)\
    \ {\n                if (strings(i).length > result.length) {\n              \
    \      result = strings(i)\n                }\n            }\n            Some(result)\n\
    \        }", "        if (strings.isEmpty) None\n        else Some(strings.sortWith(_.length\
    \ > _.length).head)", "      strings match {\n        case Nil => None\n     \
    \   case _ => {\n          val maxLength = strings.map(x => x.length).max\n  \
    \        val firstOccurance = strings.zipWithIndex.find(x => x._1.length == maxLength).get._2\n\
    \          Some(strings(firstOccurance))\n        }\n      }", "        if (strings.isEmpty)\
    \ None\n        else Some(strings.reduceLeft((x, y) => if (x.length > y.length)\
    \ x else y))", "        // Add implementation here\n        return None", "  \
    \      if (strings.isEmpty) {\n            None\n        } else {\n          \
    \  Some(strings.maxBy(_.length))\n        }", "        strings match {\n     \
    \       case Nil => None\n            case xs => {\n                val max_index\
    \ = xs.reduceLeft((a, b) => if (a.length > b.length) a else b)\n             \
    \   Some(max_index)\n            }\n        }", "        strings match {\n   \
    \         case Nil => None\n            case h :: tail => \n                val\
    \ maxlen = strings.map(s => s.length).max\n                Some(strings.filter(s\
    \ => s.length == maxlen).head)\n        }", "        strings match {\n       \
    \     case Nil => None\n            case head :: tail =>\n                val\
    \ longestTail = longest(tail)\n                if (longestTail.isEmpty) Some(head)\n\
    \                else if (head.length > longestTail.get.length) Some(head)\n \
    \               else longestTail\n        }", "        if (strings.isEmpty) {\n\
    \            None\n        } else {\n            Some(strings.reduceLeft((left,\
    \ right) => if (left.length > right.length) left else right))\n        }", " \
    \       strings match {\n            case Nil => None\n            case x :: Nil\
    \ => Some(x)\n            case x :: xs => Some(xs.foldLeft(x)((a, b) => if (a.length\
    \ > b.length) a else b))\n        }", "        strings match {\n            case\
    \ List() => None\n            case _ => Some(strings.reduceLeft((x, y) => if (x.length\
    \ > y.length) x else y))\n        }", "        strings match {\n            case\
    \ Nil => None\n            case head :: Nil => Some(head)\n            case head\
    \ :: tail => if (head.length > longest(tail).get.length) Some(head) else longest(tail)\n\
    \        }", "        strings match {\n            case Nil => None\n        \
    \    case s : List[String] => {\n                var longest : String = s(0)\n\
    \                for (str <- s) {\n                    if (str.length > longest.length)\
    \ {\n                        longest = str\n                    }\n          \
    \      }\n                Some(longest)\n            }\n        }", "        var\
    \ longest : Option[String] = None\n        for (string <- strings) {\n       \
    \     longest match {\n                case None => longest = Some(string)\n \
    \               case Some(string2) => if (string.length > string2.length) longest\
    \ = Some(string)\n            }\n        }\n        longest", "        if (strings.isEmpty)\
    \ None\n        else Some(strings.sortWith(_.length > _.length).head)", '        return
    None', "        if (strings.isEmpty) None\n        else {\n            var longestString\
    \ : String = strings(0)\n            for (s <- strings) {\n                if\
    \ (s.length > longestString.length) longestString = s\n            }\n       \
    \     return Some(longestString)\n        }", "        if (strings.isEmpty) None\n\
    \        else strings.reduceLeft((a, b) => if (a.length > b.length) a else b)",
  "        if (strings.isEmpty) None\n        else Some(strings.foldLeft(strings.head)((x,\
    \ y) => if (x.length >= y.length) x else y))", "        if (strings.isEmpty) None\n\
    \        else {\n            var max_length = 0\n            var max_length_string\
    \ = \"\"\n            for (s <- strings) {\n                if (s.length > max_length)\
    \ {\n                    max_length = s.length\n                    max_length_string\
    \ = s\n                }\n            }\n            Some(max_length_string)\n\
    \        }", "        // TODO\n        var temp = strings\n        if (temp.length\
    \ == 0) {\n            return None\n        }\n        else {\n            val\
    \ a = temp.sorted\n            return Some(a(a.length - 1))\n        }", "   \
    \     if (strings.isEmpty) None\n        else Some(strings.sortWith(_.length >\
    \ _.length).head)", "        if (strings.isEmpty) None\n        else Some(strings.reduceLeft(max))",
  "        val len = strings.map(_.length).max\n        if (len == 0) None\n     \
    \   else Some(strings.filter(_.length == len).head)", '        return None', " \
    \       if (strings.isEmpty) return None\n        strings.reduce((a, b) => if\
    \ (a.length > b.length) a else b)", "        // Since we need to return the first\
    \ of multiple strings of the same length, we take advantage\n        // of the\
    \ fact that the map method iterates through the list in the same order.\n    \
    \    strings.map(s => (s, s.length)).sortBy(_._2).reverse.headOption match {\n\
    \            case Some((s, l)) => Some(s)\n            case None => None\n   \
    \     }", "        def f(strings : List[String], longest : Option[String]) : Option[String]\
    \ = strings match {\n            case Nil => longest\n            case x :: xs\
    \ => f(xs, if (longest.isEmpty || x.length > longest.get.length) Some(x) else\
    \ longest)\n        }\n        f(strings, None)", "        val sorted = strings.sortWith((s1,\
    \ s2) => s1.length > s2.length)\n        sorted match {\n            case Nil\
    \ => None\n            case x::xs => Some(x)\n        }", "        // Return the\
    \ string that has the longest length.\n        // Return the first one in case\
    \ of multiple strings of the same length.\n        def longestInner(strings :\
    \ List[String], longestSoFar : String) : String = {\n            if (strings.isEmpty)\
    \ longestSoFar\n            else if (strings.head.length > longestSoFar.length)\
    \ longestInner(strings.tail, strings.head)\n            else longestInner(strings.tail,\
    \ longestSoFar)\n        }\n        if (strings.isEmpty) None\n        else Some(longestInner(strings.tail,\
    \ strings.head))", "        if (strings.isEmpty) {\n            None\n       \
    \ } else {\n            val lengths = strings.map(x => x.length)\n           \
    \ strings(lengths.indexOf(lengths.max))\n        }", "        if (strings.length\
    \ == 0) None\n        else Some(strings.sortWith((s1, s2) => s1.length > s2.length)(0))",
  "        if (strings.length == 0) None\n        else Some(strings.maxBy(_.length))",
  "        var max : Option[String] = None\n        for (s <- strings) {\n       \
    \     if (max == None || max.get.length < s.length) max = Some(s)\n        }\n\
    \        return max", "    \tval longestWordOpt = strings.map(s => (s, s.length)).reduceLeft((a,\
    \ b) => if (a._2 > b._2) a else b)\n    \tif (longestWordOpt._2 > 0) Some(longestWordOpt._1)\
    \ else None", "        var result : Option[String] = None\n        for (i <- 0\
    \ until strings.length) {\n            val s = strings(i)\n            if (result\
    \ == None || result.get.length < s.length) {\n                result = Some(s)\n\
    \            }\n        }\n        return result", "        if (strings.length\
    \ == 0) return None\n        var longest = strings(0)\n        for (s <- strings)\
    \ if (s.length > longest.length) longest = s\n        return Some(longest)", " \
    \       if (strings.isEmpty) None\n        else Some(strings.reduceLeft((a, b)\
    \ => if (a.length > b.length) a else b))", "        strings match {\n        \
    \    case head :: tail => {\n                val tmax = longest(tail)\n      \
    \          tmax match {\n                    case None => Some(head)\n       \
    \             case Some(e) => if (head.length > e.length) Some(head) else Some(e)\n\
    \                }\n            }\n            case _ => None\n        }", " \
    \       if (strings.isEmpty) return None\n        var longest : String = strings(0)\n\
    \        for (i <- 1 until strings.length)\n            if (strings(i).length\
    \ > longest.length) longest = strings(i)\n        return Some(longest)", "   \
    \     if (strings.length == 0) None\n        else Some(strings.reduceLeft((str1,\
    \ str2) => if (str1.length >= str2.length) str1 else str2))", '        return
    null', "        var maxLength = -1\n        var ret : Option[String] = None\n\
    \        for (str <- strings) {\n            if (str.length > maxLength) {\n \
    \               maxLength = str.length\n                ret = Some(str)\n    \
    \        }\n        }\n        ret", "        // Exceptions are thrown when list\
    \ is empty, or head element is retrieved\n        if (strings.isEmpty) None\n\
    \        else Some(strings.reduceLeft((x, y) => if (x.length >= y.length) x else\
    \ y))", "        if (strings.isEmpty) None\n        else {\n            var result\
    \ = strings(0)\n            for (s <- strings) if (s.length > result.length) result\
    \ = s\n            Some(result)\n        }", "        if (strings.isEmpty) None\n\
    \        else Some(strings.sortWith(_.length > _.length).head)", "        if (strings.isEmpty)\
    \ None\n        else {\n            var maxLength = 0\n            var longestString\
    \ = \"\"\n            for (str <- strings) {\n                if (str.length >\
    \ maxLength) {\n                    maxLength = str.length\n                 \
    \   longestString = str\n                }\n            }\n            Some(longestString)\n\
    \        }", "        if (strings.length == 0) None\n        else strings.maxBy(_.length)",
  "    \t// If the input list is empty, return None.\n    \tif (strings.isEmpty) return\
    \ None\n    \t// Get the maximum string length from the list of strings.\n   \
    \ \tval maxlength = strings.foldLeft(strings(0).length)((a, b) => {\n    \t\t\
    if (a > b.length) a else b.length\n    \t})\n    \t// Return the first string\
    \ with the maximum length.\n    \tSome(strings.find((s) => s.length == maxlength).get)",
  "        if (strings.isEmpty) None\n        else Some(strings.maxBy(_.length))",
  "        if (strings.isEmpty) None\n        else strings.sortWith((s1, s2) => s1.length\
    \ > s2.length).headOption", "        val orderedStrings = strings.sortWith((a,\
    \ b) => a.length > b.length)\n        if (orderedStrings.length > 0)\n       \
    \     Some(orderedStrings(0))\n        else\n            None", "        val length\
    \ = strings.foldLeft(0)((a,b) => max(a, b.length))\n        if (length == 0) return\
    \ None\n        strings.filter(a => a.length == length)(0)", "        if (strings.isEmpty)\
    \ {\n            None\n        } else {\n            val max = strings.maxBy(_.length)\n\
    \            Some(max)\n        }", "        if (strings.isEmpty) None\n     \
    \   else Some(strings.maxBy(_.length))", "        if (strings.isEmpty) None\n\
    \        else {\n            val length = strings.map(_.length).max\n        \
    \    Some(strings.filter(_.length == length).head)\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            var longestLength = strings(0).length\n  \
    \          var longestString = strings(0)\n            for (s <- strings) {\n\
    \                if (s.length > longestLength) {\n                    longestLength\
    \ = s.length\n                    longestString = s\n                }\n     \
    \       }\n            Some(longestString)\n        }", "        strings match\
    \ {\n            case Nil => None\n            case s :: ss => longest(ss) match\
    \ {\n                case None => Some(s)\n                case Some(s2) => Some(if\
    \ (s.length > s2.length) s else s2)\n            }\n        }", "        var length\
    \ = 0\n        var longest = \"\"\n        strings.foreach(x => {\n          \
    \  if (x.length > length) {\n                length = x.length\n             \
    \   longest = x\n            }\n        })\n        if (longest.isEmpty) {\n \
    \           None\n        } else {\n            Some(longest)\n        }", " \
    \       strings match {\n            case Nil => None\n            case _ => Some(strings.maxBy(_.length))\n\
    \        }", "        strings match {\n            case Nil => None\n        \
    \    case head :: Nil => Some(head)\n            case head :: tail => {\n    \
    \            val longestTail = longest(tail)\n                if (head.length()\
    \ > longestTail.get.length()) Some(head) else longestTail\n            }\n   \
    \     }", "        if (strings.length == 0) {\n            None\n        } else\
    \ {\n            var max = strings(0)\n            for (s <- strings) {\n    \
    \            if (s.length() > max.length()) max = s\n            }\n         \
    \   Some(max)\n        }", "        strings match {\n            case Nil => None\n\
    \            case _ => strings.reduceLeft((left : String, right : String) => if\
    \ (left.length > right.length) left else right)\n        }", "        // your\
    \ code here\n        if (strings.isEmpty) None\n        else Option(strings.sortWith(_.length\
    \ > _.length).head)", "        if (strings.isEmpty) None\n        else Some(strings.sortWith((x,\
    \ y) => x.length > y.length)(0))", "        if (strings.length == 0) return None\n\
    \        var maxStr = strings(0)\n        for (str <- strings) {\n           \
    \ if (str.length > maxStr.length) maxStr = str\n        }\n        return Some(maxStr)",
  "        if (strings.length == 0) {\n            None\n        } else {\n      \
    \      Some(strings.sortWith((x, y) => x.length > y.length)(0))\n        }", " \
    \       // TODO your code here\n        val l = strings.length\n        if (l\
    \ == 0) {\n            None\n        } else {\n            strings.maxBy(x =>\
    \ x.length)\n        }", "        strings match {\n            case Nil => None\n\
    \            case xs => Some(xs.reduceLeft((x, y) => if (x.length > y.length)\
    \ x else y))\n        }", "        if (strings.isEmpty) None\n        else Some(strings.sortWith(_.length\
    \ > _.length).head)", "    \tif (strings.isEmpty) None\n    \telse Some(strings.sortWith((x,\
    \ y) => x.length > y.length)(0))", "        def longest0(s1 : String, s2 : String)\
    \ : String = {\n            if (s1.length >= s2.length) s1 else s2\n        }\n\
    \        if (strings.length == 0) None else Some(strings.foldLeft(\"\")(longest0))",
  "      def helper(strings : List[String], longest : Option[String]) : Option[String]\
    \ = {\n        if (strings.isEmpty) longest\n        else if (longest.isEmpty)\
    \ helper(strings.tail, Some(strings.head))\n        else {\n          if (strings.head.length\
    \ > longest.get.length) helper(strings.tail, Some(strings.head))\n          else\
    \ helper(strings.tail, longest)\n        }\n      }\n      helper(strings, None)",
  "        if (strings.isEmpty) None\n        else Some(strings.maxBy(_.length))",
  "        if (strings.isEmpty) None\n        else Some(strings.maxBy(_.length))",
  "        var max : String = \"\"\n        for (s <- strings) if (s.length > max.length)\
    \ max = s\n        if (max == \"\") None else Some(max)", "        if (strings.length\
    \ == 0) return None\n        strings.foldLeft(strings(0))((a, b) => if (a.length\
    \ > b.length) a else b)", "        strings match {\n            case Nil => None\n\
    \            case x :: Nil => Some(x)\n            case x :: xs => {\n       \
    \         val y = longest(xs)\n                y match {\n                   \
    \ case None => Some(x)\n                    case Some(str) => if (x.length > str.length)\
    \ Some(x) else Some(str)\n                }\n            }\n        }", "    \
    \    strings match {\n            case List() => None\n            case List(h)\
    \ => Some(h)\n            case h :: t => longest(t) match {\n                case\
    \ None => Some(h)\n                case Some(x) => if (h.length > x.length) Some(h)\
    \ else Some(x)\n            }\n        }", "        if (strings.length == 0) {\n\
    \            None\n        } else {\n            Some(strings.maxBy(i => i.length))\n\
    \        }", "      strings match {\n        case List() => None\n        case\
    \ head :: tail => {\n          val maxLength = strings.map(s => s.length).max\n\
    \          val index = strings.indexWhere(s => s.length == maxLength)\n      \
    \    Some(strings(index))\n        }\n      }", "        if (strings.isEmpty)\
    \ {\n            None\n        } else {\n            strings.sortWith((x, y) =>\
    \ x.length > y.length).headOption\n        }", "        val list = strings.sortWith((a,\
    \ b) => a.length < b.length)\n        if (list.length == 0) None else Some(list(0))",
  "        if (strings.isEmpty) return None\n        var longest : String = strings(0)\n\
    \        for (str <- strings) {\n            if (str.length > longest.length)\
    \ longest = str\n        }\n        return Some(longest)", "        strings match\
    \ {\n            case List() => None\n            case hd :: tl => {\n       \
    \         val best = longest(tl)\n                if (best.isEmpty) Some(hd)\n\
    \                else if (hd.length > best.get.length) Some(hd)\n            \
    \    else best\n            }\n        }", "        strings match {\n        \
    \    case Nil => None\n            case _ => Some(strings.maxBy(s => s.length))\n\
    \        }", "        strings match {\n            case Nil => None\n        \
    \    case List(s) => Some(s)\n            case x :: y :: rest => longest((if (x.length\
    \ > y.length) x else y) :: rest)\n        }", "        strings match {\n     \
    \       case Nil => None\n            case s :: Nil => Some(s)\n            case\
    \ s :: t => {\n                val length = s.length\n                val tailMax\
    \ = longest(t)\n                if (tailMax.isEmpty) Some(s)\n               \
    \ else if (length > tailMax.get.length) Some(s)\n                else tailMax\n\
    \            }\n        }", "        if (strings.isEmpty) None\n        else strings.reduceLeft((a,\
    \ b) => if (a.length > b.length) a else b)", "    \tvar res = strings.reduceLeft((x,\
    \ y) => if (x.length >= y.length) x else y)\n    \tif (res == null) {\n    \t\t\
    return None\n    \t}\n    \telse {\n    \t\treturn Some(res)\n    \t}", "    \
    \    if (strings.isEmpty) None\n        else Some(strings.sortWith((s1, s2) =>\
    \ s1.length >= s2.length)(0))", "        strings match {\n            case Nil\
    \ => None\n            case hd :: _ => strings.reduceLeft((s1, s2) => if (s1.length\
    \ > s2.length) s1 else s2)\n        }", "        strings match {\n           \
    \ case Nil => None\n            case x :: Nil => Some(x)\n            case x ::\
    \ xs => {\n                val longestOfRest = longest(xs)\n                longestOfRest\
    \ match {\n                    case None => Some(x)\n                    case\
    \ Some(l) => Some(if (x.length > l.length) x else l)\n                }\n    \
    \        }\n        }", "        var result : Option[String] = None\n        if\
    \ (strings.length == 0) {\n            result = None\n        } else {\n     \
    \       result = Some(strings(0))\n            for (string <- strings) {\n   \
    \             if (string.length > result.get.length) result = Some(string)\n \
    \           }\n        }\n        result", "        var len = 0\n        var ans\
    \ : Option[String] = None\n        for (s <- strings) {\n            if (s.length\
    \ > len) {\n                len = s.length\n                ans = Some(s)\n  \
    \          }\n        }\n        ans", "        if (strings.isEmpty) None\n  \
    \      else {\n            var maxLength = 0\n            var maxString = \"\"\
    \n            for (str <- strings) {\n                if (str.length > maxLength)\
    \ {\n                    maxLength = str.length\n                    maxString\
    \ = str\n                }\n            }\n            Some(maxString)\n     \
    \   }", "        return strings match {\n            case Nil => None\n      \
    \      case head :: Nil => Some(head)\n            case head :: tail => if (head.length\
    \ >= longest(tail).getOrElse(\"\").length) Some(head) else longest(tail)\n   \
    \     }", "        if (strings.isEmpty) None\n        else Some(strings.sortWith((a,\
    \ b) => a.length < b.length).last)", "        strings match {\n            case\
    \ Nil => None\n            case head :: Nil => Some(head)\n            case head\
    \ :: tail => {\n                val longest_tail = longest(tail)\n           \
    \     longest_tail match {\n                    case None => Some(head)\n    \
    \                case Some(tail_head) => {\n                        if (head.length\
    \ > tail_head.length)\n                            Some(head)\n              \
    \          else\n                            Some(tail_head)\n               \
    \     }\n                }\n            }\n        }", "        if (strings.isEmpty)\
    \ {\n            None\n        } else {\n            val str = strings.head\n\
    \            val maxLen = strings.tail.foldLeft(str.length)(max(_, _.length))\n\
    \            Some(strings.find(_.length == maxLen).get)\n        }", "       \
    \ // TODO\n        null", "        if (strings.isEmpty) return None\n        var\
    \ max = strings(0)\n        for (string <- strings) {\n            if (string.length\
    \ > max.length) max = string\n        }\n        return Some(max)", "        if\
    \ (strings.isEmpty) None\n        else Some(strings.maxBy(_.length))", "     \
    \   val n = strings.length\n        var ans = None : Option[String]\n        for\
    \ (i <- 0 until n) {\n            if (ans == None || ans.get.length < strings(i).length)\
    \ ans = Some(strings(i))\n        }\n        ans", "        def compare(strings\
    \ : List[String], res : Option[String]) : Option[String] = {\n            if (strings.length\
    \ == 0) res\n            else if (res.isEmpty) compare(strings.tail, Some(strings.head))\n\
    \            else if (strings.head.length > res.get.length) compare(strings.tail,\
    \ Some(strings.head))\n            else compare(strings.tail, res)\n        }\n\
    \        compare(strings, None)", "        if (strings.isEmpty) return None\n\
    \        var max = strings(0)\n        for (i <- 0 until strings.length) {\n \
    \           if (strings(i).length > max.length) max = strings(i)\n        }\n\
    \        return Some(max)", "        val str_length = strings.map(s => (s, s.length))\n\
    \        if (str_length.length == 0) {\n            None\n        } else {\n \
    \           str_length.sortWith((x, y) => (x._2 > y._2)).head._1\n        }",
  "        var maxLength = 0\n        var longestString : Option[String] = None\n\
    \        for (s <- strings) if (s.length > maxLength) {\n            maxLength\
    \ = s.length\n            longestString = Some(s)\n        }\n        longestString",
  "        // >>> strings\n        // (List[String](\"a\", \"bb\", \"ccc\"))\n   \
    \     // >>> strings.isEmpty\n        // false\n        // >>> strings.head\n\
    \        // \"a\"\n        // >>> strings.head.length\n        // 1\n        //\
    \ >>> strings.tail\n        // (List[String](\"bb\", \"ccc\"))\n        // >>>\
    \ strings.tail.length\n        // 2\n        // >>> strings.map(((x : String)\
    \ => (x.length)))\n        // (List[Int](1, 2, 3))\n        // >>> strings.map(((x\
    \ : String) => (x.length))).max\n        // 3\n        if (strings.isEmpty) None\
    \ else Some(strings(strings.map(_.length).indexOf(strings.map(_.length).max)))",
  "        if (strings.isEmpty) None\n        else Some(strings.sortWith(_.length\
    \ > _.length).head)", "      if (strings.length == 0) None\n      else if (strings.length\
    \ == 1) Some(strings(0))\n      else Some(strings.reduceLeft((x, y) => if (x.length\
    \ > y.length) x else y))", '        return null', "        if (strings.isEmpty)\
    \ None\n        else {\n            var maxLength = 0\n            var maxString\
    \ = strings(0)\n            for (s <- strings) {\n                if (s.length\
    \ > maxLength) {\n                    maxLength = s.length\n                 \
    \   maxString = s\n                }\n            }\n            return Some(maxString)\n\
    \        }", "        if (strings.isEmpty) None\n        else {\n            var\
    \ long = strings(0)\n            for (string <- strings) {\n                if\
    \ (string.length > long.length) long = string\n            }\n            Some(long)\n\
    \        }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ (word, _) = strings.foldLeft((\"\", 0))((current, element) => {\n          \
    \      if (element.length > current._2) (element, element.length)\n          \
    \      else current\n            })\n            Some(word)\n        }", "   \
    \     var res : Option[String] = None\n        var l = 0\n        for (s <- strings)\
    \ {\n            if (s.length > l) {\n                res = Some(s)\n        \
    \        l = s.length\n            }\n        }\n        res", "        val l\
    \ = strings.filter(_.length > 0)\n        if (l.length == 0) return None\n   \
    \     else return Some(l.maxBy(_.length))", "        if (strings.isEmpty) return\
    \ None\n        var result = strings(0)\n        for (i <- 1 until strings.length)\
    \ {\n            if (strings(i).length > result.length) result = strings(i)\n\
    \        }\n        return Some(result)", '        return None', "        if (strings.isEmpty)\
    \ None\n        else Some(strings.maxBy(_.length))", "        if (strings.isEmpty)\
    \ None\n        else Some(strings.maxBy(_.length))", "        if (strings.isEmpty)\
    \ None\n        else {\n            def maximum(strings: List[String]) : String\
    \ = {\n                if (strings.length == 1) strings.head\n               \
    \ else {\n                    val string1 = strings.head\n                   \
    \ val string2 = strings.tail.head\n                    if (string1.length > string2.length)\
    \ maximum(string1 :: strings.tail.tail)\n                    else maximum(string2\
    \ :: strings.tail.tail)\n                }\n            }\n            Some(maximum(strings))\n\
    \        }", "      if (strings.isEmpty) None\n      else Some(strings.reduce((a,\
    \ b) => if (a.length > b.length) a else b))", "        if (strings.length == 0)\
    \ {\n            None\n        } else {\n            Some(strings.maxBy(_.length))\n\
    \        }", "        if (strings.isEmpty) {\n            None\n        } else\
    \ {\n            Some(strings.maxBy(_.length))\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            var maxLength = 0\n            var longestString\
    \ = strings(0)\n            for (i <- 0 until strings.length) {\n            \
    \    if (strings(i).length > maxLength) {\n                    maxLength = strings(i).length\n\
    \                    longestString = strings(i)\n                }\n         \
    \   }\n            Some(longestString)\n        }", "        if (strings.length\
    \ == 0) None\n        else strings.sortWith((s1, s2) => s1.length > s2.length).headOption",
  "      require(strings != null)\n      if (strings.isEmpty) return None\n      var\
    \ ans = strings(0)\n      for (i <- 1 until strings.length) {\n        if (strings(i).length\
    \ > ans.length) ans = strings(i)\n      }\n      return Some(ans)", "        if\
    \ (strings.isEmpty) None\n        else {\n            var longest = strings(0)\n\
    \            for (str <- strings) {\n                if (str.length > longest.length)\
    \ longest = str\n            }\n            Some(longest)\n        }", "     \
    \   if (strings.isEmpty) return None\n        var ret = strings(0)\n        for\
    \ (string <- strings) {\n            if (string.length > ret.length) ret = string\n\
    \        }\n        return Some(ret)", "        if (strings.length == 0) return\
    \ None\n        val longestLength = strings.foldLeft(0)((acc, s) => max(acc, s.length))\n\
    \        return Some(strings.filter((s) => s.length == longestLength).head)",
  "        if (strings.isEmpty) None\n        else {\n            val sorted = strings.sortWith(_.length\
    \ < _.length)\n            Some(sorted.last)\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            var longestString = strings(0)\n         \
    \   for (s <- strings) if (s.length() > longestString.length()) longestString\
    \ = s\n            Some(longestString)\n        }", "        strings match {\n\
    \            case Nil => None\n            case head :: tail => Option(strings.maxBy(x\
    \ => x.length))\n        }", "        strings match {\n            case Nil =>\
    \ None\n            case head :: tail => longest(tail) match {\n             \
    \   case None => Some(head)\n                case Some(tailMax) => Some(max(head,\
    \ tailMax))\n            }\n        }", "        if (strings.isEmpty) {\n    \
    \        None\n        } else {\n            Some(strings.maxBy(_.length))\n \
    \       }", "        strings match {\n            case Nil => None\n         \
    \   case (x::xs) => {\n                val lengths = new ArrayBuffer[Int]()\n\
    \                for (i <- 0 until xs.length) lengths += xs(i).length\n      \
    \          val maxLength = if (lengths.length == 0) 0 else lengths.max\n     \
    \           for (i <- 0 until xs.length) if (xs(i).length == maxLength) return\
    \ Some(xs(i))\n                Some(x)\n            }\n        }", "        //\
    \ Fill in this part.\n        if (strings.isEmpty) None\n        else {\n    \
    \        var longest = strings(0)\n            for (str <- strings)\n        \
    \        if (str.length > longest.length) longest = str\n            Some(longest)\n\
    \        }", "        def max(l1 : Option[String], l2 : Option[String]) : Option[String]\
    \ = {\n            if (l1 == None) l2\n            else if (l2 == None) l1\n \
    \           else if (l1.get.length >= l2.get.length) l1\n            else l2\n\
    \        }\n        strings.foldLeft(None : Option[String])(max)", "        if\
    \ (strings.length == 0) {\n            None\n        } else {\n            var\
    \ max = strings(0)\n            for (s <- strings) {\n                if (s.length\
    \ > max.length) max = s\n            }\n            Some(max)\n        }", " \
    \       return strings match {\n            case Nil => None\n            case\
    \ h :: tail => tail.foldLeft(Some(h))((a, b) => if (a.get.length > b.length) a\
    \ else Some(b))\n        }", "        val numStrings = strings.length\n      \
    \  if (numStrings == 0) {\n            None\n        } else {\n            val\
    \ lengths = strings.map(s => s.length)\n            val maxLength = lengths.max\n\
    \            val longestStrings = strings.filter(s => s.length == maxLength)\n\
    \            Some(longestStrings(0))\n        }", '        ???', "        if (strings.isEmpty)\
    \ {\n            None\n        } else {\n            Some(strings.reduceLeft((x,\
    \ y) => if (x.length > y.length) x else y))\n        }", '        return None',
  '        return if (strings.isEmpty) None else Some(strings.reduceLeft((a, b) =>
    if (a.length >= b.length) a else b))', "        if (strings.isEmpty) return None\n\
    \        var res = strings(0)\n        for (string <- strings) if (string.length\
    \ > res.length) res = string\n        return Some(res)", "        if (strings.length\
    \ == 0) None\n        else {\n            var result = strings(0)\n          \
    \  for (s <- strings) {\n                if (s.length > result.length) result\
    \ = s\n            }\n            Some(result)\n        }", "        // Reversed\
    \ because since it's a linked list, delete head is much faster\n        // than\
    \ delete tail, and remove(0) is also much faster than remove(len - 1)\n      \
    \  strings.sortWith(_.length > _.length).reverse.headOption", "        // Solution\
    \ 1:\n        // var currentLength = -1\n        // var longestString : Option[String]\
    \ = None\n        // for (s <- strings) {\n        //     if (s.length > currentLength)\
    \ {\n        //         currentLength = s.length\n        //         longestString\
    \ = Some(s)\n        //     }\n        // }\n        // longestString\n      \
    \  // Solution 2:\n        strings match {\n            case Nil => None\n   \
    \         case x :: Nil => Some(x)\n            case x :: xs => longest(xs) match\
    \ {\n                case None => Some(x)\n                case Some(s) => if\
    \ (x.length > s.length) Some(x) else Some(s)\n            }\n        }", "   \
    \     if (strings.isEmpty) return None\n        strings.sortWith((a, b) => a.length\
    \ > b.length)(0)", "        if (strings.length == 0) return None\n        var\
    \ result = strings(0)\n        for (i <- 1 until strings.length) {\n         \
    \   if (strings(i).length > result.length) {\n                result = strings(i)\n\
    \            }\n        }\n        return Some(result)", '        ???', "    \
    \    // Write your code here\n        // Return the longest string. Return None\
    \ in case of an empty list.\n        return None", "        if (strings.isEmpty)\
    \ return None\n        val sorted = strings.sortWith(_.length < _.length)\n  \
    \      return Some(sorted.last)", "        return strings match {\n          \
    \  case Nil => None\n            case x :: xs => {\n                def longestInner(s1\
    \ : String, s2 : String) : String = {\n                    return s1.length >\
    \ s2.length match {\n                        case true => s1\n               \
    \         case false => s2\n                    }\n                }\n       \
    \         val sortedStrings = strings.sortBy(_.length)\n                val maxString\
    \ = sortedStrings.last\n                //val maxString = sortedStrings.foldLeft(sortedStrings.head)(longestInner)\n\
    \                return Some(maxString)\n            }\n        }", "        if\
    \ (strings.isEmpty) None\n        else strings.sortWith((x, y) => x.length > y.length).headOption",
  "        var result = \"\"\n        for (str <- strings) {\n            if (str.length\
    \ > result.length) result = str\n        }\n        if (result == \"\") None else\
    \ Some(result)", "        if (strings.length == 0) return None\n        var ans\
    \ = strings(0)\n        for (i <- 0 until strings.length) {\n            if (strings(i).length\
    \ > ans.length) {\n                ans = strings(i)\n            }\n        }\n\
    \        return Some(ans)", "        if (strings.length == 0) return None\n  \
    \      var l = strings(0)\n        for (s <- strings) {\n            if (s.length\
    \ > l.length) l = s\n        }\n        return Some(l)", "        // Complete\
    \ this function\n        if (strings.isEmpty) None\n        else {\n         \
    \   val max = strings.maxBy(x => x.length)\n            Some(max)\n        }",
  "        strings match {\n            case x :: xs => {\n                var xmax\
    \ = x\n                var xmaxLen = x.length\n                for (y <- xs) {\n\
    \                    if (y.length > xmaxLen) {\n                        xmax =\
    \ y\n                        xmaxLen = y.length\n                    }\n     \
    \           }\n                Some(xmax)\n            }\n            case Nil\
    \ => None\n        }", "        // If the list is empty, return None\n       \
    \ if (strings.isEmpty) return None\n        // Find the longest string\n     \
    \   var string_max = strings(0)\n        for (string <- strings) {\n         \
    \   if (string.length > string_max.length) string_max = string\n        }\n  \
    \      // Return the longest string\n        return Some(string_max)", "     \
    \   if (strings.isEmpty) return None\n        return Some(strings.maxBy(_.length))",
  "        //if (strings.length == 0) None\n        //else Some(strings.reduceLeft((a,\
    \ b) => if (a.length >= b.length) a else b))\n        strings match {\n      \
    \      case Nil => None\n            case h :: t => Some(strings.reduceLeft((a,\
    \ b) => if (a.length >= b.length) a else b))\n        }", "        var maxLength\
    \ = 0\n        var longestString : Option[String] = None\n        for (i <- 0\
    \ until strings.length) {\n            if (strings(i).length > maxLength) {\n\
    \                maxLength = strings(i).length\n                longestString\
    \ = Some(strings(i))\n            }\n        }\n        longestString", "    \
    \    if (strings.isEmpty) None\n        else Some(strings.reduceLeft((a, b) =>\
    \ if (a.length >= b.length) a else b))", "        // If the list is empty, then\
    \ return None.\n        if (strings.isEmpty) {\n            return None\n    \
    \    }\n        // If the list is not empty, then return the first element that\
    \ has the longest length.\n        return Some(strings.sortWith((s1, s2) => s1.length\
    \ >= s2.length)(0))", "        if (strings.isEmpty) {\n            None\n    \
    \    } else {\n            Some(strings.reduceLeft((x, y) => if (x.length > y.length)\
    \ x else y))\n        }", "        strings match {\n            case Nil => None\n\
    \            case string :: Nil => Some(string)\n            case string :: tail\
    \ => {\n                val longestTail = longest(tail)\n                if (string.length\
    \ > longestTail.get.length) Some(string) else longestTail\n            }\n   \
    \     }", "        // empty list\n        if (strings.length == 0) {\n       \
    \     return None\n        }\n        var maxLength = -1\n        var longestString\
    \ = \"\"\n        // iterate over all strings\n        for (str <- strings) {\n\
    \            if (str.length > maxLength) {\n                maxLength = str.length\n\
    \                longestString = str\n            }\n        }\n        return\
    \ Some(longestString)", "        if (strings.isEmpty) return None\n        else\
    \ strings.reduceLeft((x, y) => if (x.length > y.length) x else y)", "        if\
    \ (strings.isEmpty) return None\n        var longest = strings(0)\n        for\
    \ (s <- strings) {\n            if (s.length > longest.length) {\n           \
    \     longest = s\n            }\n        }\n        return Some(longest)", " \
    \       if (strings.length == 0) return None\n        var result = strings(0)\n\
    \        for (str <- strings) {\n            if (str.length > result.length) result\
    \ = str\n        }\n        return Some(result)", "        val maxLen = strings.map(_.length).max\n\
    \        strings.find(_.length == maxLen)", "        strings match {\n       \
    \     case Nil => None\n            case x :: xs => Some(strings.maxBy(_.length))\n\
    \        }", "        if (strings.length == 0) None\n        else Some(strings.reduceLeft((x,\
    \ y) => if (x.length > y.length) x else y))", "        if (strings.isEmpty) None\n\
    \        else {\n            val max = strings.maxBy(_.length)\n            val\
    \ maxs = strings.filter(_.length == max.length)\n            Some(maxs.head)\n\
    \        }"]
stop_tokens:
- "\n    }\n"
