name: HumanEval_99_closest_integer
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that takes a value (string) representing a number\n  \
  \  // and returns the closest integer to it. If the number is equidistant\n    //\
  \ from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"\
  10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    //\
  \ Note:\n    // Rounding away from zero means that if the given number is equidistant\n\
  \    // from two integers, the one you should return is the one that is the\n  \
  \  // farthest from zero. For example closest_integer(\"14.5\") should\n    // return\
  \ 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value\
  \ : String) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
  10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
  -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
  0\")) == (0l));\n    }\n\n}\n"
completions: ['        round(value.toDouble)', "        val n = BigDecimal(value)\n\
    \        if (n.signum == 0) {\n            0\n        } else {\n            val\
    \ d = n.abs\n            val i = d.toLong\n            if (d == i) {\n       \
    \         i\n            } else {\n                val h = d - i\n           \
    \     if (h >= 0.5) {\n                    i + 1\n                } else {\n \
    \                   i\n                }\n            }\n        }", "       \
    \ val number = BigDecimal(value)\n        val rounded = number.setScale(0, BigDecimal.RoundingMode.HALF_UP)\n\
    \        if (number < 0)\n            -rounded.toLong\n        else\n        \
    \    rounded.toLong", "        val doubleValue = value.toDouble\n        val doubleInt\
    \ = value.toDouble.toInt\n        if (doubleValue - doubleInt >= 0.5) doubleInt\
    \ + 1 else doubleInt", "        val split = value.split(\"\\\\.\")\n        if\
    \ (split.length == 1) {\n            return value.toLong\n        }\n        val\
    \ n = split(1).toInt\n        val b = (n - n % 10) / 10\n        val a = n - b\
    \ * 10\n        val c = value.toLong\n        val d = if (a <= 5) b else b + 1\n\
    \        if (d == 0) {\n            return c\n        }\n        if (c >= 0) {\n\
    \            return c + d\n        }\n        else {\n            return c - d\n\
    \        }", "        var result : Long = 0\n        val num : Double = value.toDouble\n\
    \        if (num % 1 == 0) {\n            result = num.toLong\n        } else\
    \ {\n            val s : String = num.toString.split(\"\\\\.\")(1)\n         \
    \   var n : Int = 0\n            for (i <- 0 until s.length) {\n             \
    \   if (s(i) != '0') {\n                    n = i\n                    break\n\
    \                }\n            }\n            if (n == 0) {\n               \
    \ result = num.toLong\n            } else {\n                val t : Double =\
    \ (1.0 * s.substring(0, n + 1).toInt) / pow(10, n + 1)\n                if (t\
    \ >= 0.5) {\n                    result = ceil(num).toLong\n                }\
    \ else {\n                    result = floor(num).toLong\n                }\n\
    \            }\n        }\n        result", '        0', "        var v = value.toDouble\n\
    \        var i = ceil(v)\n        var f = floor(v)\n        if (i == f) {\n  \
    \          if (i > 0) {\n                i\n            } else {\n           \
    \     f\n            }\n        } else {\n            if (abs(v - i) < abs(v -\
    \ f)) {\n                i\n            } else {\n                f\n        \
    \    }\n        }", "        var v = BigDecimal(value)\n        if (v < 0) -((-v).toLong)\n\
    \        else if (v - v.toLong >= 0.5) v.toLong + 1\n        else v.toLong", '        return
    0', '        value.toDouble.round', "        val doubleValue = value.toDouble\n\
    \        return round(doubleValue).toLong", "      try {\n        val n = value.toDouble\n\
    \        n.round\n      } catch {\n        case e: Exception => 0\n      }", " \
    \       val x = value.toDouble\n        if (value.length() < 1) {\n          \
    \  0\n        } else if (x.abs == floor(x.abs)) {\n            x.toLong\n    \
    \    } else if (x < 0) {\n            (floor(x) - 1).toLong\n        } else {\n\
    \            (ceil(x) + 1).toLong\n        }", '        0', "        val n = value.toDouble\n\
    \        round(n)", "        val a = BigDecimal(value)\n        val b = a.toLong\n\
    \        val c = BigDecimal(b.toString)\n        if (a > c) b + 1\n        else\
    \ if (a < c) b - 1\n        else b", "        var s = BigDecimal(value)\n    \
    \    if (s < 0) return -1 * closestInteger(value.substring(1))\n        val x\
    \ = s.toLong\n        val y = x + 1\n        if (s - x < y - s) x else y", " \
    \       val (d,f) = value.span(_ != '.')\n        if (f.size == 0) d.toLong\n\
    \        else {\n            val (i,_) = f.splitAt(1)\n            val floor =\
    \ d.toLong\n            val ceil = if (floor == 0) 1 else floor * -1\n       \
    \     val s = i.substring(1)\n            if (s.size == 0) floor\n           \
    \ else {\n                val n = s.toInt\n                if (n == 0) floor\n\
    \                else {\n                    val ceilVal = n + ceil\n        \
    \            val floorVal = n + floor\n                    if (floorVal == 0)\
    \ ceil\n                    else if (ceilVal == 0) floor\n                   \
    \ else if (abs(ceilVal) < abs(floorVal)) ceil\n                    else floor\n\
    \                }\n            }\n        }", "        val n = value.toDouble\n\
    \        if (abs(n - round(n)) > 0.5) {\n            if (n > 0)\n            \
    \    ceil(n)\n            else\n                floor(n)\n        } else\n   \
    \         round(n)", "        val dvalue = value.toDouble\n        val ivalue\
    \ = value.toLong\n        if (dvalue - ivalue == 0.5) {\n            if (dvalue\
    \ < 0) ivalue - 1\n            else ivalue + 1\n        }\n        else if (dvalue\
    \ > ivalue) ivalue + 1\n        else ivalue", "        val number = value.toDouble\n\
    \        val isNegative = number < 0\n        val intNumber = number.abs.toLong\n\
    \        val decimal = number - intNumber\n        var result = 0l\n        if\
    \ (decimal >= 0.5) {\n            result = intNumber + 1\n        } else {\n \
    \           result = intNumber\n        }\n        if (isNegative) {\n       \
    \     -result\n        } else {\n            result\n        }", "        var\
    \ doubleValue = value.toDouble\n        if (doubleValue == 0) {\n            0\n\
    \        } else if (doubleValue < 0) {\n            -floor(abs(doubleValue))\n\
    \        } else {\n            ceil(doubleValue)\n        }", "        var n =\
    \ BigDecimal(value)\n        var f = BigDecimal(floor(n.toDouble))\n        var\
    \ c = BigDecimal(ceil(n.toDouble))\n        var result = 0l\n        if (n - f\
    \ > c - n) result = c.toLong\n        else result = f.toLong\n        return result",
  "        val n = value.toDouble\n        val x = floor(n)\n        val y = ceil(n)\n\
    \        if (n - x >= y - n) y else x", "        val n = BigDecimal(value)\n \
    \       val floorN = n.floor\n        val ceilN = n.ceil\n        if (abs(n -\
    \ floorN) == abs(n - ceilN)) {\n            if (floorN > 0) floorN else ceilN\n\
    \        } else if (abs(n - floorN) < abs(n - ceilN)) floorN else ceilN", "  \
    \      val d = value.toDouble\n        return (round(d)).toLong", "        val\
    \ sign = value.take(1)\n        var n = value.drop(1).toDouble\n        n = n\
    \ + (n / abs(n)) * 0.5\n        return n.toLong * sign.toLong", "        val value_double\
    \ = value.toDouble\n        val lower = floor(value_double)\n        val upper\
    \ = ceil(value_double)\n        if (lower == upper) return lower.toLong\n    \
    \    if (abs(value_double - lower) < abs(value_double - upper)) return lower.toLong\n\
    \        else return upper.toLong", "        val d = value.toDouble\n        val\
    \ f = floor(d)\n        val c = ceil(d)\n        if (d - f > c - d) c else f",
  "        val d = value.toDouble\n        var l = floor(d).toLong\n        var r\
    \ = ceil(d).toLong\n        if (abs(d - l) > abs(d - r)) r else l", "        val\
    \ num = BigDecimal(value)\n        if (num % 1 == 0) {\n            return num.toLong\n\
    \        }\n        else {\n            if (num % 1 > 0.5) {\n               \
    \ return (num + 1 - (num % 1)).toLong\n            }\n            else {\n   \
    \             return (num - (num % 1)).toLong\n            }\n        }", '        return
    round(value.toDouble).toLong', "        // Write your code here\n        return\
    \ 0", "        var intVal = value.toDouble\n        var lVal = floor(intVal)\n\
    \        var hVal = ceil(intVal)\n        return if ((intVal - lVal) < (hVal -\
    \ intVal)) lVal.toLong else hVal.toLong", '        value.trim.toDouble.round',
  "        val num = value.toDouble\n        if (num == round(num))\n            return\
    \ round(num).toLong\n        else if (num < 0)\n            return (floor(num)\
    \ - 1).toLong\n        else\n            return (ceil(num) + 1).toLong", "   \
    \     val v = value.toDouble\n        if (v > 0) {\n            if (v - v.toLong\
    \ > 0.5) v.toLong + 1\n            else v.toLong\n        } else {\n         \
    \   if (v - v.toLong < -0.5) v.toLong - 1\n            else v.toLong\n       \
    \ }", "        val n = BigDecimal(value)\n        if (n < BigDecimal(0)) {\n \
    \           return -closestInteger(value.substring(1))\n        }\n        if\
    \ (n - n.floor < n.ceil - n) {\n            return n.floor.toLong\n        }\n\
    \        return n.ceil.toLong", "        val decimals = value.split(\"\\\\.\"\
    ).reverse\n        val decimal = if (decimals.length > 1) decimals(0) else \"\
    0\"\n        val num = if (decimals.length > 1) decimals(1) else decimals(0)\n\
    \        val n = num.toInt\n        val d = decimal.toInt\n        if (n >= 5)\
    \ {\n            n + 1\n        } else {\n            n\n        }", "       \
    \ def solve(x : BigDecimal) : Long = {\n            if (x < 0) {\n           \
    \     val n = -x\n                if (n - n.toLong < 0.5) (-n.toLong) else (-(n.toLong\
    \ + 1))\n            } else {\n                if (x - x.toLong < 0.5) x.toLong\
    \ else (x.toLong + 1)\n            }\n        }\n        val x = BigDecimal(value)\n\
    \        solve(x)", "        // check if value is positive or negative.\n    \
    \    // Convert the value to an integer.\n        // Get the decimals from the\
    \ value.\n        // Round the decimals.\n        // Return new value as an integer.\n\
    \        var valueToInt = value.toInt\n        var valueToDouble = value.toDouble\n\
    \        if (valueToDouble - valueToInt < 0.5) {\n            return valueToInt\n\
    \        } else {\n            return valueToInt + 1\n        }", "        val\
    \ num = value.toDouble\n        round(num)", "        val x = value.toDouble\n\
    \        val p = x.floor\n        val q = x.ceil\n        if (x - p < q - x) p.toLong\
    \ else q.toLong", "        val n = value.toDouble\n        val number = if (n\
    \ >= 0) ceil(n) else floor(n)\n        return number.toLong", '        BigDecimal(value).round.toLong',
  "        val integer = value.toLong\n        val decimal = value.toDouble - integer\n\
    \        if (decimal >= 0.5) integer + 1\n        else integer", "        val\
    \ input = value.toDouble\n        if (input - input.floor == 0.5)\n          \
    \  (if (input >= 0) input.ceil else input.floor).toLong\n        else\n      \
    \      input.round.toLong", "        val num = value.toDouble\n        round(num)",
  "        val number = java.lang.Double.parseDouble(value)\n        if (number >\
    \ 0) {\n            ceil(number).toLong\n        } else {\n            floor(number).toLong\n\
    \        }", "        val d = value.toDouble\n        val ret = if (d - d.toLong\
    \ > 0.5) d.toLong + 1 else d.toLong\n        return ret", "        val n = value.toDouble\n\
    \        if (n < 0) {\n            ceil(n).toLong\n        } else {\n        \
    \    floor(n).toLong\n        }", "        val doubleNum = BigDecimal(value)\n\
    \        if (doubleNum < 0) {\n            val l = ceil(doubleNum).toLong\n  \
    \          if (l - doubleNum == 0.5) l + 1 else l\n        } else {\n        \
    \    val l = floor(doubleNum).toLong\n            if (doubleNum - l == 0.5) l\
    \ - 1 else l\n        }", "        var v = value.toDouble\n        var r = round(v)\n\
    \        var f = floor(v)\n        var c = ceil(v)\n        if (v > 0) {\n   \
    \         if (v - f < c - v) f.toLong else c.toLong\n        } else {\n      \
    \      if (f - v < v - c) f.toLong else c.toLong\n        }", "        val d =\
    \ value.toDouble\n        val n = d.toLong\n        if (abs(d - n) < 0.5) n else\
    \ n + 1", "        def closest(num : Long, value : Double) : Long = {\n      \
    \      val next = num + 1\n            if (abs(num - value) < abs(next - value))\
    \ num\n            else next\n        }\n        val double = value.toDouble\n\
    \        if (double < 0) -closest(-double.toLong, -double)\n        else closest(double.toLong,\
    \ double)", "      var n = BigDecimal(value).toDouble\n      var ceil = ceil(n)\n\
    \      var floor = floor(n)\n      var diff1 = abs(ceil - n)\n      var diff2\
    \ = abs(floor - n)\n      if (diff1 > diff2) floor else ceil", "        val num\
    \ = value.toDouble\n        val closest = if (num >= 0) {\n            ceil(num).toLong\n\
    \        } else {\n            floor(num).toLong\n        }\n        val a = closest\
    \ - num\n        val b = num - closest + 1\n        if (abs(a) <= abs(b))\n  \
    \          closest - 1\n        else\n            closest", "        val d = value.toDouble\n\
    \        val a = floor(d)\n        val b = ceil(d)\n        if (d - a < b - d)\n\
    \            a.toLong\n        else\n            b.toLong", "        val n = java.lang.Double.parseDouble(value)\n\
    \        val n1 = round(n)\n        val n2 = floor(n)\n        val n3 = ceil(n)\n\
    \        //println(n1 + \" \" + n2 + \" \" + n3)\n        if (abs(n - n1) <= abs(n\
    \ - n2)) n1.toLong else n2.toLong", "        val v = value.toDouble\n        val\
    \ ci = round(v)\n        return ci.toLong", '        value.toDouble.round.toLong',
  "        val n = value.toDouble\n        if (n % 1 >= 0.5) (n + 1).toLong\n    \
    \    else n.toLong", "      var x = value.toDouble\n      if (x == 0) 0 else {\n\
    \        if (abs(x) >= 1)\n          round(x).toLong\n        else {\n       \
    \   var i = 1\n          while (abs(x * pow(10, i)) < 1) {\n            i += 1\n\
    \          }\n          round(x * pow(10, i)).toLong / pow(10, i).toLong\n   \
    \     }\n      }", '        ???', "        // You must fill in the definition\
    \ of this function.\n        val n = value.toDouble\n        if (n == floor(n))\
    \ floor(n).toLong\n        else if (n > 0) {\n            if (n - floor(n) < 0.5)\
    \ floor(n).toLong\n            else (floor(n) + 1).toLong\n        }\n       \
    \ else if (n < 0) {\n            if (ceil(n) - n < 0.5) ceil(n).toLong\n     \
    \       else (ceil(n) - 1).toLong\n        }\n        else 0l", "        val v\
    \ = value.toDouble\n        if (v - floor(v) > ceil(v) - v) ceil(v).toLong else\
    \ floor(v).toLong", "        val d = value.toDouble\n        val i = value.toLong\n\
    \        if (abs(d - i) >= 0.5)\n            round(d)\n        else\n        \
    \    i", "        val sign = if (value.head == '-') -1 else 1\n        val without_sign\
    \ = if (value.head == '-') value.tail else value\n        val k = without_sign.indexOf('.')\n\
    \        if (k == -1) {\n            sign * value.toLong\n        } else {\n \
    \           val (integral, frac) = without_sign.splitAt(k)\n            sign *\
    \ (integral.toLong + \n                (if (frac.tail.toLong >= 5l) 1l else 0l))\n\
    \        }", "        val num = value.toDouble\n        val ceil = math.ceil(num)\n\
    \        val floor = math.floor(num)\n        if (num - floor < ceil - num)\n\
    \            floor.toLong\n        else\n            ceil.toLong", "        var\
    \ x = value.toDouble\n        var y = x.toLong\n        if(x - y >= 0.5) y +=\
    \ 1\n        return y", "        val x = value.toDouble\n        if (x.isWhole)\
    \ return x.toLong\n        if (abs(x - floor(x)) < abs(x - ceil(x))) return floor(x).toLong\n\
    \        return ceil(x).toLong", "        val parsed = value.toDouble\n      \
    \  val floor = parsed.floor\n        val ceil = parsed.ceil\n        if (floor\
    \ == ceil) ceil\n        else if (parsed - floor < ceil - parsed) floor\n    \
    \    else ceil", "        var x = value.toDouble\n        var a = value.toDouble.round\n\
    \        var aa = if (a >= 0) a else -a\n        var b = value.toDouble.ceil\n\
    \        var bb = if (b >= 0) b else -b\n        if (x == a)\n            a\n\
    \        else if (x > 0) {\n            if (aa < bb)\n                a\n    \
    \        else\n                b\n        }\n        else {\n            if (aa\
    \ < bb)\n                -a\n            else\n                -b\n        }",
  "        val num = value.toDouble\n        round(num)", "        // Your implementation\
    \ goes here.\n        ???", '        return round(value.toDouble).toLong', " \
    \       // Uncomment to test against real input\n        // val in = io.Source.stdin.getLines\n\
    \        // val value = in.next\n        // val test = value.toFloat\n       \
    \ val test = value.toFloat\n        val rounded = round(test)\n        val ceiled\
    \ = ceil(test)\n        val floored = floor(test)\n        val testToCeil = abs(ceiled\
    \ - test)\n        val testToFloor = abs(floored - test)\n        val testToRound\
    \ = abs(rounded - test)\n        if (testToCeil == testToFloor) {\n          \
    \  if (testToCeil == testToRound) {\n                if (rounded > 0) rounded\
    \ else floored\n            } else if (testToRound < testToCeil) {\n         \
    \       rounded\n            } else {\n                if (ceiled > 0) ceiled\
    \ else floored\n            }\n        } else if (testToCeil == testToRound) {\n\
    \            if (ceiled > 0) ceiled else floored\n        } else if (testToFloor\
    \ == testToRound) {\n            if (floored > 0) floored else ceiled\n      \
    \  } else if (testToCeil < testToFloor) {\n            if (testToCeil < testToRound)\
    \ {\n                if (ceiled > 0) ceiled else floored\n            } else {\n\
    \                rounded\n            }\n        } else {\n            if (testToFloor\
    \ < testToRound) {\n                if (floored > 0) floored else ceiled\n   \
    \         } else {\n                rounded\n            }\n        }", "    \
    \    val v = BigDecimal(value)\n        if (v < 0) floor(v).toLong else ceil(v).toLong",
  "      def helper(n : Double) : Long = {\n        val p = n.ceil\n        val m\
    \ = n.floor\n        if (abs(n - p) < abs(n - m)) p else m\n      }\n      val\
    \ n = value.toDouble\n      if (n.isWhole) n.toLong else helper(n)", "       \
    \ def round(input : String) : Long = {\n            val x = input.toDouble\n \
    \           val a = floor(x)\n            val b = ceil(x)\n            if ((x\
    \ - a) == (b - x)) {\n                if (abs(a) > abs(b)) a.toLong else b.toLong\n\
    \            } else if ((x - a) < (b - x)) a.toLong else b.toLong\n        }\n\
    \        value.contains(\".\") match {\n            case true => round(value)\n\
    \            case false => value.toLong\n        }", "        // create a function\
    \ that converts number to string\n        // create a function that computes the\
    \ distance between two numbers\n        def toDouble(value : String) : Double\
    \ = {\n            try {\n                value.toDouble\n            } catch\
    \ {\n                case e : Exception => {\n                    0.0\n      \
    \          }\n            }\n        }\n        // create a function that takes\
    \ a number and returns the closest integer\n        def closestInt(value : Double)\
    \ : Long = {\n            val ceil = ceil(value)\n            val floor = floor(value)\n\
    \            if (value > 0.0) {\n                if (value - floor > ceil - value)\
    \ ceil.toLong else floor.toLong\n            } else {\n                if (value\
    \ - floor > ceil - value) floor.toLong else ceil.toLong\n            }\n     \
    \   }\n        // create a function that takes a number and returns the closest\
    \ integer\n        def closest(value : Double) : Long = {\n            (ceil(value)\
    \ - value).abs compare (floor(value) - value).abs match {\n                case\
    \ 1 => floor(value).toLong\n                case -1 => ceil(value).toLong\n  \
    \              case 0 => {\n                    if (value > 0.0) ceil(value).toLong\
    \ else floor(value).toLong\n                }\n            }\n        }\n    \
    \    closest(toDouble(value))", "        val d = value.toDouble\n        val d2\
    \ = d.round\n        if (d2 - d < 0) {\n            d2 - 1\n        } else {\n\
    \            d2\n        }", "    \tvar number = BigDecimal(value)\n    \tnumber.setScale(0,\
    \ BigDecimal.RoundingMode.HALF_UP).toLong", "      val d = value.toDouble\n  \
    \    val nearest = floor(d + 0.5)\n      nearest.toLong", '        return ceil(value.toDouble).toLong',
  "        val d = value.toDouble\n        if (d > 0)\n        \tceil(d).toLong\n\
    \        else\n        \tfloor(d).toLong", "      val x = value.toDouble\n   \
    \   val y = Math.floor(x)\n      if (abs(x - y) < 0.5)\n        y.toLong\n   \
    \   else\n        y.toLong + 1", "        val n = value.toDouble\n        round(n)",
  "        val n = value.toDouble\n        val c = floor(n)\n        val f = ceil(n)\n\
    \        if (abs(c - n) == abs(f - n)) {\n            if (n > 0) f else c\n  \
    \      } else if (abs(c - n) < abs(f - n)) c else f", "    \tval num = BigDecimal(value)\n\
    \    \tval floor = num.floor\n    \tval ceil = num.ceil\n    \tval ceiling = ceil.toLong\n\
    \    \tval floored = floor.toLong\n    \tif (num - floor <= 0.5) floored else\
    \ ceiling", '        return round(value.toDouble).toLong', "        val d = BigDecimal(value)\n\
    \        val (a,b) = (floor(d), ceil(d))\n        if (d - a == b - d) (if (d >\
    \ 0) b else a).toLong else d.toLong", "        var n = value.toDouble\n      \
    \  var x = round(n)\n        x", "        val x = value.toDouble\n        return\
    \ if (x < 0) ceil(x).toLong else floor(x).toLong", "      val d = value.toDouble\n\
    \      val result = round(d)\n      result.toLong", "        val n = value.toDouble\n\
    \        if (n < 0) ceil(n) - 1 else ceil(n)", "        var v : Double = value.toDouble\n\
    \        val floor = v.floor\n        val ceil = v.ceil\n        var r = if (abs(floor\
    \ - v) < abs(ceil - v)) floor else ceil\n        r.toLong", "    \tval d = value.toDouble\n\
    \    \tif(abs(d - round(d)) == 0.5) {\n    \t\tif(d > 0) round(d) + 1\n    \t\t\
    else round(d) - 1\n    \t}\n    \telse round(d)", "        def digitsToLong(s\
    \ : String) : Long = s.foldLeft(0l) { (sum, c) => sum * 10 + c.asDigit }\n   \
    \     // get rid of leading zeros\n        val t = value.dropWhile(_ == '0')\n\
    \        val p = if (t.head == '-') t.tail else t\n        if (p.isEmpty) return\
    \ 0\n        // The general idea is to use the following equation to get the closest\
    \ integer:\n        //   n = sgn(x) * (m / 10^(-d))  where m and d satisfy the\
    \ following conditions:\n        //   1. d is the smallest possible integer such\
    \ that m / 10^(-d) is an integer\n        //   2. x <= m / 10^(-d)\n        //\n\
    \        // For example, if x = 123.456, then we can let m = 1234 and d = 2. We\
    \ then have\n        //   n = 123 = sgn(x) * (1234 / 10^(-2)) = sgn(x) * (1234\
    \ / 0.01)\n        // If x = 123.456, then we can let m = 1234, m = 1235 and d\
    \ = 2. We then have\n        //   n = 123 = sgn(x) * (1234 / 10^(-2)) = sgn(x)\
    \ * (1234 / 0.01)\n        //   n' = 124 = sgn(x) * (1235 / 10^(-2)) = sgn(x)\
    \ * (1235 / 0.01)\n        //\n        // We also note that it is faster to compute:\n\
    \        //   n = sgn(x) * (m / 10^(-d)) = sgn(x) * (m * 10^d)\n        // instead\
    \ of\n        //   n = sgn(x) * (m / 10^(-d)) = sgn(x) * (m / (1 / 10^d))\n  \
    \      //\n        // Next, we need to find the values of m and d. We note that\n\
    \        //   d is equal to the number of digits after the decimal point\n   \
    \     // in the given number.\n        // Since we are rounding away from zero,\
    \ if the given number is negative", "        var d = value.toDouble\n        var\
    \ t = d.toLong\n        if (d - t > 0.5) t + 1 else t", "        val x = value.toDouble\n\
    \        if (x < 0) -1l * closestInteger((-1 * x).toString)\n        else if (x\
    \ % 1 == 0) x.toLong\n        else if (x % 1 < 0.5) (x.toLong)\n        else (x.toLong\
    \ + 1)", "      val num = BigDecimal(value)\n      val whole = num.toLong\n  \
    \    val decimal = num - whole\n      if (abs(decimal) <= 0.5) whole\n      else\
    \ if (decimal > 0) whole + 1\n      else whole - 1", "        val d = value.toDouble\n\
    \        val ceil = ceil(d)\n        val floor = floor(d)\n        if (ceil -\
    \ d < d - floor) ceil.toLong else floor.toLong", "        val decimalPart = value.split(\"\
    \\\\.\")(1).toInt\n        val sign = if (value.indexOf(\"-\") == 0) -1 else 1\n\
    \        val valueAsInt = (value.replace(\"-\", \"\").toDouble * 100 + sign *\
    \ 50).toInt\n        valueAsInt / 100", "        // TODO: implement\n        var\
    \ n = value.toDouble\n        var closest = round(n)\n        closest", "    \
    \    // Write your code here\n        0", "        // If a string is passed in,\
    \ turn it into a Double so we can\n        // compute its floor and ceiling.\n\
    \        val doubleValue = value.toDouble\n        val floor = floor(doubleValue)\n\
    \        val ceiling = ceil(doubleValue)\n        // Compute the distance from\
    \ the floor and ceiling to the input\n        // value.\n        val distToFloor\
    \ = doubleValue - floor\n        val distToCeiling = ceiling - doubleValue\n \
    \       // Check whether the distance to the floor or ceiling is shorter.\n  \
    \      // If it's the floor, round down and return the floor. Otherwise,\n   \
    \     // round up and return the ceiling.\n        if (distToFloor < distToCeiling)\
    \ floor.toLong else ceiling.toLong", '        return 0', "        val n = value.toDouble\n\
    \        if (n < 0) ceil(n).toLong else floor(n).toLong", "        val x = value.toDouble\n\
    \        if(value.endsWith(\".5\")) {\n            if(x > 0) (x+1).toLong\n  \
    \          else (x-1).toLong\n        }\n        else (x + 0.5).toLong", "   \
    \     // Split the string on the decimal place\n        val parts = value.split(\"\
    \\\\.\")\n        // Get the first number, and convert it to an integer\n    \
    \    val pre = parts(0).toInt\n        // Get the second number, and convert it\
    \ to an integer\n        val post = parts(1).toInt\n        // If the post is\
    \ less than half of the max value for an integer,\n        // return the pre,\
    \ otherwise return the pre + 1\n        if (post < 5000) pre else pre + 1", " \
    \       val n = value.toDouble\n        return Math.round(n)", "        if (value.contains(\"\
    .\") && value.split(\".\")(1).toInt == 5) {\n            if (value.contains(\"\
    -\")) return floor(value.toDouble).toLong - 1\n            else return ceil(value.toDouble).toLong\
    \ + 1\n        }\n        round(value.toDouble).toLong", "        val number =\
    \ value.toDouble\n        return round(number).toLong", "      val d = value.toDouble\n\
    \      val l = floor(d).toLong\n      val h = ceil(d).toLong\n      if (abs(d\
    \ - l) == abs(d - h)) if (d > 0) h else l else if (abs(d - l) < abs(d - h)) l\
    \ else h", "        def roundAwayFromZero(value : Double) : Long = {\n       \
    \     if (value.isNegInfinity) Long.MinValue\n            else if (value.isPosInfinity)\
    \ Long.MaxValue\n            else if (value < 0) -roundAwayFromZero(-value)\n\
    \            else if (value - value.toLong > 0.5) value.toLong + 1\n         \
    \   else value.toLong\n        }\n        roundAwayFromZero(value.toDouble)",
  "        // TODO: Implement a function that takes a value (string) representing\n\
    \        // a number and returns the closest integer to it. If the number is\n\
    \        // equidistant from two integers, round it away from zero.\n        //\
    \ Hint: this will use the Math.Round, Math.Floor, and Math.Ceiling\n        //\
    \ functions.\n        val t : Double = value.toDouble\n        val floor = floor(t)\n\
    \        val ceiling = ceil(t)\n        val diff1 = abs(t - floor)\n        val\
    \ diff2 = abs(t - ceiling)\n        if (diff1 < diff2) floor.toLong else ceiling.toLong",
  '        return (Math.round(value.toDouble));', "        val number = value.toDouble\n\
    \        val i = number.toLong\n        if (i + 0.5 == number) {\n           \
    \ i + 1\n        } else {\n            i\n        }", "        // note: the sign\
    \ of the fractional part determines which way to round\n        val Array(i, f)\
    \ = value.split(\"\\\\.\")\n        val integral = i.toLong\n        val fractional\
    \ = (f + \"0\").take(2).toLong\n        if (fractional <= 25) integral else integral\
    \ + 1", "        val sign = value.substring(0, 1)\n        val absValue = BigDecimal(value.substring(1))\n\
    \        val intValue = absValue.toInt\n        if (absValue - intValue >= 0.5)\
    \ intValue + 1\n        else intValue", "        val valueFloat = value.toFloat\n\
    \        return if (valueFloat > 0) round(valueFloat).toLong else -round(-valueFloat).toLong",
  "        val (decimal, _) = value.split(\"\\\\.\").map(_.toLong).partition(x =>\
    \ x > 0)\n        val (decimal_part, neg) = if (decimal.length == 0) (None, true)\
    \ else (Some(decimal.last), false)\n        if (decimal_part.isEmpty) return 0\n\
    \        val (fractional_part, tenth) = split(value.drop(decimal_part.get.toString.length\
    \ + neg.toInt))\n        val first_digit = fractional_part.head\n        val second_digit\
    \ = fractional_part.drop(1).head\n        val add_one = if (first_digit == 5 &&\
    \ second_digit == 0) 0 else if (first_digit > 5) 1 else 0\n        (if (neg) -1\
    \ else 1) * (decimal_part.get + add_one)", "        val n = BigDecimal(value)\n\
    \        if (n < 0) {\n            if (n + 0.5 < n.toLong) n.toLong - 1 else n.toLong\n\
    \        } else {\n            if (n + 0.5 > n.toLong) n.toLong + 1 else n.toLong\n\
    \        }", "        val d = value.toDouble\n        if (d >= 0) ceil(d).toLong\
    \ else floor(d).toLong", "        val dValue = BigDecimal(value)\n        val\
    \ negValue = BigDecimal(0) - dValue\n        val negInt = (negValue.toLongExact\
    \ - negValue.toBigIntExact.toLong)\n        if (negInt == 0) {\n            return\
    \ negValue.toLongExact\n        }\n        val posInt = dValue.toLongExact - dValue.toBigIntExact.toLong\n\
    \        if (posInt == 0) {\n            return dValue.toLongExact\n        }\n\
    \        if (negInt > posInt) {\n            return negValue.toLongExact\n   \
    \     }\n        return dValue.toLongExact", "      var number = value.toDouble\n\
    \      var ceiling = ceil(number)\n      var floor = floor(number)\n      var\
    \ closestNumber = abs(ceiling - number)\n      if (closestNumber >= abs(floor\
    \ - number)) {\n        closestNumber = floor\n      } else {\n        closestNumber\
    \ = ceiling\n      }\n      closestNumber.toLong", "        val n = BigDecimal(value)\n\
    \        n.setScale(0, BigDecimal.RoundingMode.HALF_UP).toLong", "        val\
    \ doubleVal = value.toDouble\n        var floorVal = floor(doubleVal)\n      \
    \  var ceilVal = ceil(doubleVal)\n        var lowerVal = abs(doubleVal - floorVal)\n\
    \        var upperVal = abs(doubleVal - ceilVal)\n        if (lowerVal < upperVal)\
    \ {\n            floorVal.toLong\n        } else {\n            ceilVal.toLong\n\
    \        }", "        if (value.contains(\".\")) {\n            var num = value.split(\"\
    \\\\.\")\n            if (num(1).startsWith(\"0\")) return num(0).toLong\n   \
    \         var n = num(1).toInt\n            if (n <= 5) return num(0).toLong\n\
    \            else return (num(0).toLong + 1)\n        }\n        return value.toLong",
  "        // Floor the number and add or subtract 0.5 as appropriate\n        val\
    \ number = value.toDouble\n        val floored = floor(number)\n        val difference\
    \ = number - floored\n        if (difference == 0.5) {\n            // Round away\
    \ from zero\n            val sign = math.signum(number)\n            if (sign\
    \ == 1) floored + 1 else floored - 1\n        } else if (difference < 0.5) {\n\
    \            floored\n        } else {\n            floored + 1\n        }", " \
    \       var number : Double = value.toDouble\n        var ceil : Double = ceil(number)\n\
    \        var floor : Double = floor(number)\n        var diff1 : Double = ceil\
    \ - number\n        var diff2 : Double = number - floor\n        if (diff1 < diff2)\
    \ {\n            return ceil.toLong\n        } else {\n            return floor.toLong\n\
    \        }", "        val numbers = value.split(\"\"\"\\.\"\"\").map(BigInt(_))\n\
    \        val number = numbers(0)\n        val decimal = BigDecimal(numbers(1))\n\
    \        if (decimal == 0) {\n            number.toLong\n        } else {\n  \
    \          val b = pow(10, value.length - number.toString.length - 1)\n      \
    \      val o = (b * (decimal / b + BigDecimal(0.5))).toLong\n            if (number\
    \ < 0) {\n                -(number * b + o)\n            } else {\n          \
    \      number * b + o\n            }\n        }", "        val d = value.toDouble\n\
    \        if (abs(d - ceil(d)) < abs(d - floor(d))) ceil(d).toLong\n        else\
    \ floor(d).toLong", "        val number = value.toDouble\n        val floor =\
    \ math.floor(number)\n        val ceil = math.ceil(number)\n        if (floor\
    \ == ceil) {\n            floor.toLong\n        } else {\n            if (number\
    \ > 0) {\n                if (number - floor < ceil - number) {\n            \
    \        floor.toLong\n                } else {\n                    ceil.toLong\n\
    \                }\n            } else {\n                if (floor - number <\
    \ number - ceil) {\n                    floor.toLong\n                } else {\n\
    \                    ceil.toLong\n                }\n            }\n        }",
  '        return round(value.toDouble).toLong', "        val d = value.toDouble\n\
    \        val m = d - floor(d)\n        val c = if (m < 0.5) d.toLong - 1 else\
    \ d.toLong\n        return c", "        val d = value.toDouble\n        val i\
    \ = round(d)\n        if (i > d) {\n            i - 1\n        } else {\n    \
    \        i\n        }", "        // code here\n        value.toDouble.round.toLong",
  "        val x = value.toDouble\n        return x.round", "        var value_float\
    \ = value.toFloat\n        var value_int = value.toInt\n        if (value_float\
    \ > value_int) value_int + 1 else value_int", "        val doubleValue = value.toDouble\n\
    \        if(doubleValue < 0) {\n            val ret = ceil(doubleValue)\n    \
    \        return ret.toLong\n        }\n        else {\n            val ret = floor(doubleValue)\n\
    \            return ret.toLong\n        }", "        val x = value.toDouble\n\
    \        floor(x + .5).toLong", "        val d = value.toDouble\n        val x\
    \ = abs(d)\n        val y = floor(x)\n        val z = ceil(x)\n        if (abs(y-x)\
    \ == abs(z-x))\n            if (d >= 0) z else -z\n        else if (abs(y-x) <\
    \ abs(z-x))\n            y.toLong\n        else\n            z.toLong", "    \
    \    val n = BigDecimal(value)\n        if (n - n.round == 0) n.round.toLong\n\
    \        else if (n < 0) n.round.toLong - 1\n        else n.round.toLong + 1",
  "        val v = value.toDouble\n        val i = round(v)\n        if (abs(v - i)\
    \ == 0.5) i.toLong + signum(v).toLong\n        else i.toLong", "        var a\
    \ = value.toFloat\n        var integer = round(a)\n        return integer.toLong",
  "        val number = value.toDouble\n        if (abs(number - floor(number + 0.5))\
    \ < 0.001) floor(number + 0.5).toLong\n        else if (number >= 0) floor(number\
    \ + 0.5).toLong\n        else ceil(number - 0.5).toLong", '      // Your code
    here', "    \tif (value == null) {\n    \t\tthrow new NullPointerException(\"\
    value must not be null\")\n    \t}\n    \tval f = value.toFloat\n    \tf match\
    \ {\n    \t\tcase _ if (f < 0) => ceil(f).toLong\n    \t\tcase _ if (f == 0) =>\
    \ 0\n    \t\tcase _ if (f > 0) => floor(f).toLong\n    \t}", "        val x =\
    \ value.toDouble\n        if (x == floor(x)) {\n            x.toLong\n       \
    \ } else {\n            val c = (floor(x), ceil(x))\n            val d = (x -\
    \ c._1).abs\n            val e = (x - c._2).abs\n            if (d < e) {\n  \
    \              c._1.toLong\n            } else {\n                c._2.toLong\n\
    \            }\n        }", "        val num = value.toDouble\n        val floor\
    \ = num.floor\n        val ceiling = num.ceil\n        if ((ceiling - num) ==\
    \ (num - floor)) {\n            if (num < 0) floor else ceiling\n        } else\
    \ if ((ceiling - num) < (num - floor)) {\n            ceiling\n        } else\
    \ {\n            floor\n        }", "        val a = new BigDecimal(value)\n \
    \       val b = a.setScale(0, BigDecimal.RoundingMode.HALF_UP)\n        b.toLong",
  "        val x = BigDecimal(value)\n        if (x == BigDecimal(x.toLongExact))\
    \ x.toLong else x.setScale(0, RoundingMode.HALF_UP).toLong", "        val x =\
    \ value.toDouble\n        val floor = math.floor(x)\n        val ceil = math.ceil(x)\n\
    \        val remainder = x - floor\n        return if (remainder >= 0.5) ceil.toLong\
    \ else floor.toLong", "        val floatValue = value.toFloat\n        val integerValue\
    \ = value.toInt\n        if (floatValue - integerValue > 0.5) integerValue + 1\n\
    \        else integerValue", "        val d = value.toDouble\n        return round(d).toLong",
  "        if (value.contains(\".\")) {\n            val d = BigDecimal(value)\n \
    \           val c = d.setScale(0, BigDecimal.RoundingMode.HALF_UP)\n         \
    \   return c.toLong\n        }\n        else return value.toLong", "        val\
    \ d = value.toDouble\n        round(d)", "        val v = value.toDouble\n   \
    \     val c = if (v > 0) v + 0.5 else v - 0.5\n        c.toLong", "        var\
    \ rounded = value.toDouble\n        var floor = floor(rounded)\n        var ceiling\
    \ = ceil(rounded)\n        var diff_ceiling = abs(ceiling - rounded)\n       \
    \ var diff_floor = abs(floor - rounded)\n        if (diff_ceiling < diff_floor)\
    \ ceiling.toLong else floor.toLong", '        return (round(value.toDouble)).toLong',
  "        if (value.length() == 0) return 0;\n        var value2 = value;\n     \
    \   var sign = \"\";\n        if (value.charAt(0) == '-') {\n            sign\
    \ = \"-\";\n            value2 = value.substring(1);\n        }\n        var point\
    \ = value2.indexOf('.');\n        if (point == -1) return value2.toLong;\n   \
    \     var before_point = value2.substring(0, point);\n        var after_point\
    \ = value2.substring(point + 1);\n        if (after_point.length() == 0) return\
    \ value2.toLong;\n        var first_after_point = after_point.charAt(0);\n   \
    \     var first_after_point_i = first_after_point.toInt - '0'.toInt;\n       \
    \ var candidate1 = value2.toLong;\n        var candidate2 = candidate1 + 1;\n\
    \        if (first_after_point_i > 4) {\n            return candidate2;\n    \
    \    } else if (first_after_point_i < 4) {\n            return candidate1;\n \
    \       } else {\n            var value2_array = value2.toCharArray.map(_.toInt);\n\
    \            var i = 1;\n            while (i < value2_array.length) {\n     \
    \           if (value2_array(point + i) > '0'.toInt) {\n                    return\
    \ candidate2;\n                } else if (value2_array(point + i) < '0'.toInt)\
    \ {\n                    return candidate1;\n                }\n             \
    \   i += 1;\n            }\n            return candidate1;\n        }", "    \
    \    val doubleValue = value.toDouble\n        val floorValue = floor(doubleValue)\n\
    \        val ceilValue = ceil(doubleValue)\n        if (abs(floorValue - doubleValue)\
    \ == abs(ceilValue - doubleValue)) {\n            if (floorValue >= 0) {\n   \
    \             ceilValue.toLong\n            } else {\n                floorValue.toLong\n\
    \            }\n        } else if (abs(floorValue - doubleValue) < abs(ceilValue\
    \ - doubleValue)) {\n            floorValue.toLong\n        } else {\n       \
    \     ceilValue.toLong\n        }", "        // Fill in the body of this function\n\
    \        // test if it is exactly an integer\n        if (value.last.toString.equals(\"\
    .\")) {\n            val v_int = value.split(\"\\\\.\")(0).toLong\n          \
    \  return v_int\n        }\n        val isInteger = value.contains(\".\")\n  \
    \      if (isInteger == false) {\n            return value.toLong\n        }\n\
    \        val v_float = value.toFloat\n        val v_double = value.toDouble\n\
    \        val floor = floor(v_double).toLong\n        val ceiling = ceil(v_double).toLong\n\
    \        // if it is an integer\n        if (v_float - floor == 0) {\n       \
    \     return floor\n        }\n        val diff_to_floor = abs(v_float - floor)\n\
    \        val diff_to_ceiling = abs(v_float - ceiling)\n        if (diff_to_floor\
    \ < diff_to_ceiling) {\n            return floor\n        }\n        else {\n\
    \            return ceiling\n        }", "        // TODO: Return the closest\
    \ integer to the given value.\n        val d : Double = value.toDouble\n     \
    \   return round(d)", "        // Implement your solution here\n        throw\
    \ new UnsupportedOperationException(\"Not yet implemented\")", "        val d\
    \ = value.toDouble\n        val a = ceil(d)\n        val b = floor(d)\n      \
    \  if (abs(d - a) == abs(d - b)) {\n            if (d >= 0) a.toLong else b.toLong\n\
    \        } else if (abs(d - a) < abs(d - b)) a.toLong else b.toLong", "      \
    \  val d = value.toDouble\n        if (d - floor(d) == 0.5)\n            if (d\
    \ > 0) ceil(d) else floor(d)\n        else\n            round(d)", "        //\
    \ Write your code here\n        val intval = if (value.indexOf(\".\") >= 0) value.substring(0,\
    \ value.indexOf(\".\")).toLong else value.toLong\n        if (value.indexOf(\"\
    .\") >= 0) {\n            val fracval = value.substring(value.indexOf(\".\") +\
    \ 1).toLong\n            if (fracval == 0) intval\n            else if (fracval\
    \ < 5) intval\n            else intval + 1\n        } else intval", "        val\
    \ number = value.toDouble\n        round(number)", "        val fValue = value.toFloat\n\
    \        if (fValue > 0) {\n            val decimals = fValue % 1\n          \
    \  if (decimals >= 0.5) {\n                return (fValue + 1 - decimals).toLong\n\
    \            } else {\n                return (fValue - decimals).toLong\n   \
    \         }\n        } else {\n            val decimals = fValue % 1\n       \
    \     if (decimals >= 0.5) {\n                return (fValue - 1 - decimals).toLong\n\
    \            } else {\n                return (fValue - decimals).toLong\n   \
    \         }\n        }", "        if (value.contains(\".\")) {\n            val\
    \ left = value.substring(0, value.indexOf(\".\"))\n            val right = value.substring(value.indexOf(\"\
    .\") + 1)\n            if (right.forall(_ == '0')) {\n                left.toLong\n\
    \            } else {\n                val r = left.toInt + (if (right.toInt >=\
    \ 5) 1 else 0)\n                r.toLong\n            }\n        } else {\n  \
    \          value.toLong\n        }", '        return round(value.toDouble).toLong',
  "        val x = value.toDouble\n        if(x.toInt.toDouble == x) {\n         \
    \   x.toInt.toLong\n        } else {\n            if(x > 0) {\n              \
    \  x.toInt.toLong + 1\n            } else {\n                x.toInt.toLong -\
    \ 1\n            }\n        }", '        return round(value.toDouble).toLong',
  "        var number : Double = value.toDouble\n        var isNegative : Boolean\
    \ = false\n        if (number < 0) {\n            isNegative = true\n        \
    \    number = -number\n        }\n        var integerPart : Long = (number).toLong\n\
    \        var fractionalPart : Double = number - integerPart\n        var result\
    \ : Long = integerPart\n        if (fractionalPart > 0.5) {\n            result\
    \ += 1\n        }\n        if (isNegative) {\n            result = -result\n \
    \       }\n        return result", '        BigDecimal(value).setScale(0, BigDecimal.RoundingMode.HALF_UP).toLong',
  "        val number = value.toDouble\n        val ceil = ceil(number)\n        val\
    \ floor = floor(number)\n        if (ceil - number == number - floor) {\n    \
    \        if (ceil >= 0) ceil.toLong else floor.toLong\n        } else if (ceil\
    \ - number < number - floor) ceil.toLong else floor.toLong", "        val result\
    \ = value.toDouble\n        val resultFloor = result.floor\n        val resultCeil\
    \ = result.ceil\n        if (resultFloor + 0.5 == result) resultCeil\n       \
    \ else if (resultFloor + 0.5 < result) resultCeil\n        else resultFloor",
  "        // TODO: Implement Me\n        return value.toLong", "        if (value.endsWith(\"\
    .0\")) value.substring(0, value.length - 2).toLong\n        else {\n         \
    \   val y = value.toDouble\n            if (y > 0) ceil(y).toLong\n          \
    \  else floor(y).toLong\n        }", "        var d = value.toDouble\n       \
    \ if (d < 0) {\n            val n = ceil(d)\n            val f = floor(d)\n  \
    \          if ((n - d) < (d - f)) n.toLong else f.toLong\n        } else {\n \
    \           val n = floor(d)\n            val f = ceil(d)\n            if ((d\
    \ - n) < (f - d)) n.toLong else f.toLong\n        }", "        val d = value.toDouble\n\
    \        val i = floor(d).toLong\n        if (i == d) {\n            i\n     \
    \   } else {\n            (i + 1)\n        }", "        val num = value.toDouble\n\
    \        val floor = floor(num)\n        if (floor - num == 0.5) round(num)\n\
    \        else if (floor - num < 0.5) floor\n        else floor + 1", "      val\
    \ num = value.toDouble\n      val round_to_nearest_int = round(num)\n      round_to_nearest_int.toLong",
  "        val n = value.toDouble\n        if (value.endsWith(\".5\")) {\n       \
    \     if (n < 0) ceil(n).toLong - 1 else ceil(n).toLong\n        } else {\n  \
    \          round(n).toLong\n        }", "        val number = BigDecimal(value)\n\
    \        // We add 0.5 to the number because the rounding mode is\n        //\
    \ set to 'round half to even' and this makes sure that\n        // the number\
    \ is rounded up or down when the fractional\n        // part is exactly 0.5.\n\
    \        (number + 0.5).round(new MathContext(0)).toLong", '        return value.toDouble.round',
  "        val v = value.toDouble\n        if (abs(v - round(v)) < abs(v - floor(v)))\
    \ round(v) else floor(v)", "        // Implement Here\n        return 0", "  \
    \      // Your code goes here.\n        val l = value.toLong\n        val d =\
    \ value.toDouble\n        if (abs(d - l) > 0.5)\n            l + signum(d - l)\n\
    \        else\n            l", "        if (value.isEmpty()) return 0\n      \
    \  val num : Double = value.toDouble\n        var fl : Float = (value.toFloat\
    \ - num).toFloat\n        var n : Long = round(num)\n        if (fl != 0) {\n\
    \            if (n < 0) n = n - 1\n            else n = n + 1\n        }\n   \
    \     return n", "        val v = value.toDouble\n        return round(v).toLong",
  "        val d = value.toDouble\n        if (d > 0) floor(d + 0.5) else ceil(d -\
    \ 0.5)", '        BigDecimal(value).round(new java.math.MathContext(1,java.math.RoundingMode.HALF_UP)).toLong',
  "        // Convert to BigDecimal.\n        val valueAsBigDecimal = BigDecimal(value)\n\
    \        // Find the nearest integer.\n        val nearestInteger = valueAsBigDecimal.setScale(0,\
    \ BigDecimal.RoundingMode.HALF_UP)\n        // Return the integer.\n        nearestInteger.toLong",
  "        var n = BigDecimal(value)\n        if (n < 0) {\n            // round away\
    \ from zero\n            BigDecimal((n + BigDecimal(\"0.5\")).toLong)\n      \
    \  } else {\n            // round away from zero\n            BigDecimal((n -\
    \ BigDecimal(\"0.5\")).toLong)\n        }", "        // (\"14.5\") -> (14l, 15l)\n\
    \        val (left, right) = {\n            val parts = value.split(\"\\\\.\"\
    )\n            if (parts.length == 1) (parts(0).toLong, parts(0).toLong)\n   \
    \         else (parts(0).toLong, parts(0).toLong + 1)\n        }\n        val\
    \ value0 = value.toDouble\n        val dl = abs(value0 - left)\n        val dr\
    \ = abs(value0 - right)\n        if (dl < dr) left\n        else right"]
stop_tokens:
- "\n    }\n"
