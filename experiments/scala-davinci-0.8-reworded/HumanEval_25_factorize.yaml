name: HumanEval_25_factorize
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return list of prime factors of given integer in the order from smallest\
  \ to largest.\n    // Each of the factors should be listed number of times corresponding\
  \ to how many times it appeares in factorization.\n    // Input number should be\
  \ equal to the product of all factors\n    // >>> factorize((8l))\n    // (List[Long](2l.toLong,\
  \ 2l.toLong, 2l.toLong))\n    // >>> factorize((25l))\n    // (List[Long](5l.toLong,\
  \ 5l.toLong))\n    // >>> factorize((70l))\n    // (List[Long](2l.toLong, 5l.toLong,\
  \ 7l.toLong))\n    def factorize(n : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(factorize((2l)).equals((List[Long](2l.toLong))));\n\
  \    assert(factorize((4l)).equals((List[Long](2l.toLong, 2l.toLong))));\n    assert(factorize((8l)).equals((List[Long](2l.toLong,\
  \ 2l.toLong, 2l.toLong))));\n    assert(factorize((57l)).equals((List[Long](3l.toLong,\
  \ 19l.toLong))));\n    assert(factorize((3249l)).equals((List[Long](3l.toLong, 3l.toLong,\
  \ 19l.toLong, 19l.toLong))));\n    assert(factorize((185193l)).equals((List[Long](3l.toLong,\
  \ 3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((20577l)).equals((List[Long](3l.toLong,\
  \ 19l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((18l)).equals((List[Long](2l.toLong,\
  \ 3l.toLong, 3l.toLong))));\n    }\n\n}\n"
completions: ["        val primes = PrimeNumbers.getPrimes(sqrt(n).toInt)\n      \
    \  // val factors = new ListBuffer[Long]\n        val factors = new ListBuffer[Long]\n\
    \        var n1 = n\n        while (n1 > 1) {\n            primes.find(n1 % _\
    \ == 0) match {\n                case Some(prime) => factors += prime; n1 /= prime\n\
    \                case None => throw new Exception(\"n1 should be equal to the\
    \ product of all factors\")\n            }\n        }\n        factors.toList",
  "        var lst = ArrayBuffer[Long]()\n        var nn = n\n        for (i <- 2l.to(sqrt(nn).toLong)\
    \ if (nn % i == 0)) {\n            while (nn % i == 0) {\n                lst\
    \ += i\n                nn /= i\n            }\n        }\n        if (nn > 1)\
    \ lst += nn\n        lst.toList", "        val sqrtn = sqrt(n).toLong\n      \
    \  var i = 2l;\n        var r = n\n        var result = List[Long]()\n       \
    \ while (i <= sqrtn) {\n            if (r % i == 0) {\n                result\
    \ = i :: result\n                r /= i\n            }\n            else {\n \
    \               i += 1\n            }\n        }\n        result = r :: result\n\
    \        result", "        var factors = List[Long]()\n        var m = n\n   \
    \     while (m % 2 == 0) {\n            factors = 2 :: factors\n            m\
    \ /= 2\n        }\n        var i = 3\n        while (i <= sqrt(m.toDouble)) {\n\
    \            while (m % i == 0) {\n                factors = i :: factors\n  \
    \              m /= i\n            }\n            i += 2\n        }\n        if\
    \ (m > 1) factors = m :: factors\n        factors", "        def isPrime(n : Long)\
    \ : Boolean = {\n            def isPrimeHelper(n : Long, i : Long) : Boolean =\
    \ {\n                if (i == n) true\n                else if (n % i == 0) false\n\
    \                else isPrimeHelper(n, i + 1)\n            }\n            isPrimeHelper(n,\
    \ 2)\n        }\n        def factorizeHelper(n : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (n == 1) acc\n            else {\n                val p\
    \ = (2 to n.toInt).find(i => isPrime(i) && n % i == 0).get\n                factorizeHelper(n\
    \ / p, p :: acc)\n            }\n        }\n        factorizeHelper(n, List())",
  "        var x = n\n        var factors = List[Long]()\n        var i = 2l\n   \
    \     while (i <= x) {\n            if (x % i == 0) {\n                factors\
    \ = factors :+ i\n                x /= i\n            }\n            else i +=\
    \ 1\n        }\n        factors", "        if (n == 1) return List(1l)\n     \
    \   val primeFactors = primes(sqrt(n).toInt)\n        var result = List[Long]()\n\
    \        var currentNumber = n\n        for (i <- 0 until primeFactors.length)\
    \ {\n            val primeFactor = primeFactors(i)\n            if (currentNumber\
    \ % primeFactor == 0) {\n                result = primeFactor :: result\n    \
    \            currentNumber /= primeFactor\n                if (currentNumber ==\
    \ 1) return result\n            }\n        }\n        // No proper prime factors\
    \ were found, so number is prime number\n        List(n)", "        // 1) get\
    \ all prime factors using trial division\n        var a = n\n        var factors\
    \ = List[Long]()\n        for (i <- 2l to n) {\n            while (a % i == 0)\
    \ {\n                factors = factors :+ i\n                a /= i\n        \
    \    }\n        }\n        factors", "        var factors = List[Long]()\n   \
    \     val bign = BigInt(n)\n        val sqrtn = sqrt(n)\n        var i = 2\n \
    \       while (i <= sqrtn) {\n            if (bign % i == 0) {\n             \
    \   factors ::= i\n                return factors ::: factorize(bign / i)\n  \
    \          }\n            i += 1\n        }\n        factors ::= n\n        factors",
  "        var result = new ListBuffer[Long]()\n        var m = n\n        for (prime\
    \ <- primes) {\n            while (m % prime == 0) {\n                result +=\
    \ prime\n                m /= prime\n            }\n            if (m == 1) return\
    \ result.toList\n        }\n        List(n)", "        var factors = new ListBuffer[Long]()\n\
    \        var counter = 2l\n        var x = n\n        while (counter <= (ceil(sqrt(x))).toLong)\
    \ {\n            if (x % counter == 0) {\n                x /= counter\n     \
    \           factors += counter\n            }\n            else counter += 1\n\
    \        }\n        factors += x\n        factors.toList", "        var n1 = n\n\
    \        var list = new ListBuffer[Long]()\n        while (n1 % 2 == 0) {\n  \
    \          list += 2\n            n1 /= 2\n        }\n        var limit = sqrt(n1).toLong\n\
    \        for (i <- 3 to limit by 2) {\n            while (n1 % i == 0) {\n   \
    \             list += i\n                n1 /= i\n            }\n        }\n \
    \       if (n1 > 2) list += n1\n        list.toList", "        var p = (2l to\
    \ sqrt(n).toLong).find(x => n % x == 0).get\n        val k = (1 to log(n) / log(p)).find(x\
    \ => pow(p, x).toLong > n).get - 1\n        List.fill(k)(p) ::: factorize(n /\
    \ pow(p, k).toLong)", "        if (n <= 1) return List()\n        var lst = new\
    \ ArrayBuffer[Long]()\n        var x = n\n        while (x % 2 == 0) {\n     \
    \       lst += 2\n            x /= 2\n        }\n        var p = 3\n        while\
    \ (x > 1) {\n            if (x % p == 0) {\n                lst += p\n       \
    \         x /= p\n            }\n            else p += 2\n        }\n        lst.toList",
  "        // Return empty list if n is 1, 2 or -1\n        if (n == 1l || n == 2l\
    \ || n == -1l) {\n            return List()\n        }\n        // Create prime\
    \ list till sqrt(n) and primes (HashSet) till sqrt(n)\n        val end = sqrt(n).toInt\n\
    \        val primes = (1 to end).filter(i => isPrime(i)).toList\n        val primeSet\
    \ = HashSet() ++ primes\n        // If n is a prime, return it\n        if (primeSet.contains(n))\
    \ {\n            return List(n)\n        }\n        // Else, find the smallest\
    \ prime factor\n        val pf = primes.filter(p => n % p == 0).head\n       \
    \ // If pf is 2, recursively factorize n/2\n        if (pf == 2) {\n         \
    \   return 2l :: factorize(n / 2)\n        }\n        // Else, factorize n/pf\n\
    \        else {\n            return pf :: factorize(n / pf)\n        }", "   \
    \     var x = n\n        var lst = new ListBuffer[Long]()\n        for (i <- (2l\
    \ to sqrt(n)).toList) {\n            while (x % i == 0) {\n                lst\
    \ += i\n                x /= i\n            }\n        }\n        if (x > 1) lst\
    \ += x\n        lst.toList", "        if (n == 1) return List[Long](1l)\n    \
    \    def factorize0(n : Long, f : Long, acc : List[Long]) : List[Long] = {\n \
    \           if (n <= 1) return acc\n            if (n % f == 0) factorize0(n /\
    \ f, f, f :: acc)\n            else factorize0(n, f + 1, acc)\n        }\n   \
    \     factorize0(n, 2, Nil)", "        val result = new ListBuffer[Long]\n   \
    \     for (i <- (2l to (n / 2l))) if (n % i == 0l) {\n            var j = i\n\
    \            while (n % j == 0l) {\n                result += j\n            \
    \    j *= i\n            }\n        }\n        result.toList", "        // Naive\
    \ algorithm\n        // 1) if the number is prime, return List(number)\n     \
    \   // 2) if the number is not prime,\n        // find the smallest prime divisor\
    \ (smallest factor)\n        // perform division, and recursively call the same\
    \ function on the remainder\n        def factorizeR(n : Long, primes : List[Long])\
    \ : List[Long] = {\n            // For a given number, return (true, factor) if\
    \ a factor exists, (false, -1) otherwise\n            def getFactor(n : Long,\
    \ primes : List[Long]) : (Boolean, Long) = {\n                def getFactorR(n\
    \ : Long, primes : List[Long]) : (Boolean, Long) = {\n                    if (primes.isEmpty)\
    \ {\n                        (false, -1)\n                    } else {\n     \
    \                   if (n % primes.head == 0) {\n                            (true,\
    \ primes.head)\n                        } else {\n                           \
    \ getFactorR(n, primes.tail)\n                        }\n                    }\n\
    \                }\n                getFactorR(n, primes)\n            }\n   \
    \         val (hasFactor, factor) = getFactor(n, primes)\n            if (hasFactor)\
    \ {\n                val remainder = n / factor\n                factor :: factorizeR(remainder,\
    \ primes)\n            } else {\n                List(n)\n            }\n    \
    \    }\n        val primes = List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l,\
    \ 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l,\
    \ 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l,\
    \ 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l,\
    \ 241l, 251l, 257l, 263l, 269l, 271l, 277l,", "        var remainder = n\n   \
    \     var factors = List[Long]()\n        var p = smallestPrimeFactor(remainder)\n\
    \        while (p != -1) {\n            factors = factors :+ p\n            remainder\
    \ /= p\n            p = smallestPrimeFactor(remainder)\n        }\n        if\
    \ (remainder > 1) {\n            factors = factors :+ remainder\n        }\n \
    \       factors", "        var curN = n\n        var cur = 2l\n        var list\
    \ = List[Long]()\n        while (curN != 1) {\n            while (curN % cur ==\
    \ 0) {\n                list = list :+ cur\n                curN /= cur\n    \
    \        }\n            cur += 1\n        }\n        list", "        def factorizeR(n\
    \ : Long, factors : List[Long]) : List[Long] = {\n            val toTry = (2 to\
    \ sqrt(n).toInt).find(n % _ == 0)\n            if (toTry.isEmpty) {\n        \
    \        if (n == 1) factors\n                else factors :+ n\n            }\n\
    \            else factorizeR(n / toTry.get, factors :+ toTry.get)\n        }\n\
    \        factorizeR(n, List())", "        val primeFactor = new ListBuffer[Long]\n\
    \        var m = n\n        var i = 2l\n        while (i * i <= m) {\n       \
    \     if (m % i == 0) {\n                primeFactor += i\n                m /=\
    \ i\n            }\n            else i += 1\n        }\n        if (m > 1) primeFactor\
    \ += m\n        primeFactor.toList", "        if (n == 1) List(1)\n        else\
    \ {\n            val root = sqrt(n).toLong\n            val factors = scala.collection.mutable.ArrayBuffer[Long]()\n\
    \            for (i <- 2 to root) {\n                if (n % i == 0) {\n     \
    \               val rest = n / i\n                    factors.append(i)\n    \
    \                factors.appendAll(factorize(rest))\n                    return\
    \ factors.toList\n                }\n            }\n            List(n)\n    \
    \    }", "        import scala.annotation.tailrec\n        @tailrec def factorizeHelper(n\
    \ : Long, f : Long, fs : List[Long]) : List[Long] = {\n            if (n == 1)\
    \ return fs\n            if (n % f == 0) factorizeHelper(n / f, f, f :: fs)\n\
    \            else factorizeHelper(n, f + 1, fs)\n        }\n        factorizeHelper(n,\
    \ 2, Nil)", "        def factorizeIter(accum : List[Long], n : Long, p : Long)\
    \ : List[Long] = {\n            if (n == 1) accum\n            else if (n % p\
    \ == 0) factorizeIter(p :: accum, n / p, p)\n            else factorizeIter(accum,\
    \ n, p + 1)\n        }\n        factorizeIter(Nil, n, 2)", "        var factors\
    \ = new ListBuffer[Long]()\n        var remain = n\n        for (i <- 2l to n)\
    \ {\n            while (remain % i == 0) {\n                factors += i\n   \
    \             remain /= i\n            }\n        }\n        factors.toList",
  "        def factorize(n : Long, fs : List[Long]) : List[Long] = {\n           \
    \ if (n == 1) fs\n            else {\n                val x = (2l to sqrt(n).toLong).find(n\
    \ % _ == 0).get\n                factorize(n / x, x :: fs)\n            }\n  \
    \      }\n        factorize(n, List())", "        if (n <= 0) {\n            return\
    \ Nil\n        }\n        var res = List[Long]()\n        var x = n\n        while\
    \ (x > 1) {\n            val factor = Utils.smallestFactor(x)\n            res\
    \ = factor :: res\n            x /= factor\n        }\n        res", "       \
    \ var factors = List[Long]()\n        var m = n\n        for (p <- 2l to (n /\
    \ 2l)) {\n            if (m % p == 0l) {\n                factors ::= p\n    \
    \            m /= p\n                return factors ::: factorize(m)\n       \
    \     }\n        }\n        factors ::= m\n        factors", "        var f :\
    \ List[Long] = List()\n        if (n == 1) f = List(1l)\n        else if (n %\
    \ 2 == 0) {\n            var k = n / 2\n            while (k % 2 == 0) {\n   \
    \             f = f ++ List(2l)\n                k = k / 2\n            }\n  \
    \          f = f ++ factorize(k)\n        }\n        else {\n            var p\
    \ = 3l\n            while (n % p != 0) p = p + 2\n            var k = n / p\n\
    \            while (k % p == 0) {\n                f = f ++ List(p)\n        \
    \        k = k / p\n            }\n            f = f ++ factorize(k)\n       \
    \ }\n        return f", "        var factors = new ListBuffer[Long]()\n      \
    \  var number = n\n        while (number > 1) {\n            val new_prime = primes(number)\n\
    \            factors += new_prime\n            number /= new_prime\n        }\n\
    \        factors.toList", "        val factors = scala.collection.mutable.ListBuffer[Long]()\n\
    \        var x = n\n        for (i <- 2 to n.toInt) {\n            if (x % i ==\
    \ 0) {\n                var b = true\n                while (b) {\n          \
    \          if (x % i == 0) {\n                        factors += i\n         \
    \               x /= i\n                    } else {\n                       \
    \ b = false\n                    }\n                }\n            }\n       \
    \ }\n        factors.toList", "        var lst = List[Long]()\n        var orig\
    \ = n\n        var i = 2l\n        while (i <= orig) {\n            if (orig %\
    \ i == 0) {\n                lst = i :: lst\n                orig /= i\n     \
    \       }\n            else i += 1\n        }\n        lst", "        var factors\
    \ = List[Long]()\n        var num = n\n        var factor = 2l\n        while\
    \ (num > 1) {\n            if (num % factor == 0) {\n                factors ::=\
    \ factor\n                num /= factor\n            }\n            else factor\
    \ += 1\n        }\n        factors", "        def factorizeAcc(acc : List[Long],\
    \ n : Long) : List[Long] = {\n            if (n == 1) acc\n            else {\n\
    \                val f = (2l to n).find(n % _ == 0).get\n                factorizeAcc(f\
    \ :: acc, n / f)\n            }\n        }\n        val fs = factorizeAcc(Nil,\
    \ n)\n        fs.sort(_ < _)", "        var toCheck = n\n        var factors =\
    \ List[Long]()\n        if (n % 2 == 0) {\n            factors :+= 2\n       \
    \     toCheck /= 2\n            while (toCheck % 2 == 0) {\n                factors\
    \ :+= 2\n                toCheck /= 2\n            }\n        }\n        var sqrt\
    \ = math.sqrt(toCheck).floor.toLong\n        for (i <- 3l to sqrt by 2) {\n  \
    \          if (toCheck % i == 0) {\n                factors :+= i\n          \
    \      toCheck /= i\n                while (toCheck % i == 0) {\n            \
    \        factors :+= i\n                    toCheck /= i\n                }\n\
    \                sqrt = math.sqrt(toCheck).floor.toLong\n            }\n     \
    \   }\n        if (toCheck > 1) factors :+= toCheck\n        factors", "     \
    \   var l = n\n        var a = n\n        var lst = new ListBuffer[Long]()\n \
    \       for (i <- 2 to sqrt(a).toInt) {\n            if (a % i == 0) {\n     \
    \           lst += i\n                a /= i\n                i -= 1\n       \
    \     }\n        }\n        return lst.toList", "        def factorize(n : Long,\
    \ p : Long) : List[Long] = {\n            //println(\"n = \" + n + \", p = \"\
    \ + p)\n            if (n == 1) return List()\n            if (n % p == 0) return\
    \ p :: factorize(n / p, p)\n            else return factorize(n, p + 1)\n    \
    \    }\n        factorize(n, 2)", "        var factors = new ListBuffer[Long]()\n\
    \        var j = 2l\n        while (n != 1) {\n            if (n % j == 0) {\n\
    \                factors += j\n                n /= j\n            }\n       \
    \     else j += 1\n        }\n        factors.toList", "        val factors =\
    \ new ListBuffer[Long]\n        var current = n\n        var i = 2l\n        while\
    \ (i <= current) {\n            if (current % i == 0) {\n                factors\
    \ += i\n                current /= i\n            } else {\n                i\
    \ += 1\n            }\n        }\n        factors.toList", "        if (n < 2)\
    \ {\n            return List[Long]()\n        }\n        def recurse(m : Long,\
    \ a : Long) : List[Long] = {\n            if (m % a == 0) {\n                return\
    \ a :: recurse(m / a, a)\n            }\n            return recurse(m, a + 1)\n\
    \        }\n        return recurse(n, 2)", "        def factorize0(n : Long, div\
    \ : Long) : List[Long] = {\n            if (n == 1) {\n                Nil\n \
    \           } else if (n % div == 0) {\n                div :: factorize0(n /\
    \ div, div)\n            } else {\n                factorize0(n, div + 1)\n  \
    \          }\n        }\n        factorize0(n, 2).reverse", "        val result\
    \ = ListBuffer[Long]()\n        var currentNumber = n\n        while (currentNumber\
    \ > 1) {\n            var currentDivisor = 2\n            while (currentNumber\
    \ % currentDivisor != 0) {\n                currentDivisor += 1\n            }\n\
    \            result += currentDivisor\n            currentNumber /= currentDivisor\n\
    \        }\n        result.toList", "        val ps = PrimeGenerator.sieve(sqrt(n).toInt\
    \ + 1)\n        def f(n : Long, ps : List[Int]) : List[Long] = {\n           \
    \ if (n == 1) Nil\n            else if (ps.isEmpty) List(n)\n            else\
    \ if (n % ps.head == 0) ps.head.toLong :: f(n / ps.head, ps)\n            else\
    \ f(n, ps.tail)\n        }\n        f(n, ps)", "        var fact : ArrayBuffer[Long]\
    \ = new ArrayBuffer[Long]\n        var k = n\n        while (k % 2 == 0) {\n \
    \           fact += 2\n            k /= 2\n        }\n        var i = 3\n    \
    \    while (i * i <= k) {\n            while (k % i == 0) {\n                fact\
    \ += i\n                k /= i\n            }\n            i += 2\n        }\n\
    \        if (k > 1) fact += k\n        fact.toList", "        def factorize(n\
    \ : Long, p : Long) : List[Long] = {\n            if (n % p == 0) {\n        \
    \        p :: factorize(n / p, p)\n            } else if (p * p > n) {\n     \
    \           if (n > 1) List(n) else List()\n            } else {\n           \
    \     factorize(n, p + 1)\n            }\n        }\n        factorize(n, 2)",
  "        def factorizeHelper(n : Long, p : Long) : List[Long] = {\n            if\
    \ (n == 1) return List()\n            if (n % p == 0) p :: factorizeHelper(n /\
    \ p, p)\n            else factorizeHelper(n, p + 1)\n        }\n        if (n\
    \ == 1) return List()\n        factorizeHelper(n, 2)", "        var factors =\
    \ List[Long]()\n        var reminder = n\n        var prime = 2l\n        while\
    \ (reminder > 1) {\n            while (reminder % prime == 0) {\n            \
    \    factors = factors :+ prime\n                reminder /= prime\n         \
    \   }\n            prime += 1\n        }\n        factors", "        var factorCount\
    \ = Map[Long, Long]()\n        var curr = n\n        var i = 2l\n        while\
    \ (i <= curr) {\n            if (curr % i == 0) {\n                factorCount(i)\
    \ = factorCount.getOrElse(i, 0l) + 1\n                curr /= i\n            }\n\
    \            else i += 1\n        }\n        factorCount.toList.flatMap(p => List.fill(p._2.toInt)(p._1))",
  "        var result = List[Long]()\n        var m = n\n        while (m % 2 == 0)\
    \ {\n            result = result :+ 2\n            m /= 2\n        }\n       \
    \ var i = 3\n        while (i <= sqrt(m).toInt) {\n            while (m % i ==\
    \ 0) {\n                result = result :+ i\n                m /= i\n       \
    \     }\n            i += 2\n        }\n        if (m > 1) result = result :+\
    \ m\n        result", "        var n0 = n\n        var res = new ArrayBuffer[Long]()\n\
    \        for (i <- 2l to sqrt(n0).toLong) {\n            var count = 0\n     \
    \       while (n0 % i == 0) {\n                count += 1\n                n0\
    \ /= i\n            }\n            for (j <- 1 to count) {\n                res\
    \ += i\n            }\n        }\n        if (n0 > 1) {\n            res += n0\n\
    \        }\n        res.toList", "        var p = primes(n)\n        // TODO:\
    \ Compute factorization of the given number\n        var result : List[Long] =\
    \ List.empty\n        // TODO: remove this\n        result = List(n)\n       \
    \ return result", "        var result = List[Long]()\n        val primeSet = new\
    \ PrimeSet(100000)\n        var p = 2l\n        var k = n\n        while (p <=\
    \ k) {\n            while (k % p == 0) {\n                result = result :+ p\n\
    \                k /= p\n            }\n            p = primeSet.getNext(p)\n\
    \        }\n        result", "        if (n == 1) return List(1l)\n        var\
    \ number = n\n        var factors = new ListBuffer[Long]\n        for (i <- 2l\
    \ to sqrt(n).toLong + 1) {\n            while (number % i == 0) {\n          \
    \      factors += i\n                number /= i\n            }\n        }\n \
    \       if (number != 1) factors += number\n        factors.toList", "       \
    \ var factors = new ListBuffer[Long]\n        var d = 2\n        var x = n\n \
    \       while (d <= x) {\n            if (x % d == 0) {\n                factors\
    \ += d\n                x /= d\n            } else {\n                d += 1\n\
    \            }\n        }\n        factors.toList", "        def factorize(n :\
    \ Long, acc : List[Long]) : List[Long] = {\n            if (n == 1) acc\n    \
    \        else {\n                val factor = (2 to n.toInt).find(n % _ == 0).get\n\
    \                factorize(n / factor, factor :: acc)\n            }\n       \
    \ }\n        factorize(n, List()).sorted", "        if (n < 2) return List[Long]()\n\
    \        var m = n\n        var factors = SortedSet[Long]()\n        var i = 2l\n\
    \        while (i <= m) {\n            if (m % i == 0) {\n                factors\
    \ += i\n                m /= i\n            }\n            else i += 1\n     \
    \   }\n        return factors.toList", "      var factors = new ListBuffer[Long]\n\
    \      if (n == 1) return factors.toList\n      var x = 2l\n      while (x <=\
    \ n) {\n        if (n % x == 0) {\n          factors += x\n          n /= x\n\
    \        }\n        else x += 1\n      }\n      factors.toList", "        val\
    \ result = ListBuffer[Long]()\n        var a = n\n        while (a % 2 == 0) {\n\
    \            result += 2\n            a /= 2\n        }\n        var b = 3\n \
    \       while (a > 1) {\n            while (a % b == 0) {\n                result\
    \ += b\n                a /= b\n            }\n            b += 2\n        }\n\
    \        result.toList", "        var factor = 2l\n        var tempN = n\n   \
    \     var factors = new ListBuffer[Long]()\n        while (factor <= tempN) {\n\
    \            if (tempN % factor == 0) {\n                factors += factor\n \
    \               tempN /= factor\n            }\n            else factor += 1\n\
    \        }\n        factors.toList", '        // Add your code here', "      \
    \  def factorizeR(n : Long, d : Long) : List[Long] = {\n            if (n == 1)\
    \ Nil\n            else if (n % d == 0) d :: factorizeR(n / d, d)\n          \
    \  else factorizeR(n, d + 1)\n        }\n        factorizeR(n, 2)", "        //\
    \ TODO\n        var list = List[Long]()\n        if (n == 0) return list\n   \
    \     var i = 2\n        while (i <= sqrt(n.toDouble).toInt) {\n            while\
    \ (n % i == 0) {\n                list :+= i\n                n /= i\n       \
    \     }\n            i += 1\n        }\n        if (n != 1) list :+= n\n     \
    \   list", "      var result = List[Long]()\n      var counter = 2l\n      while\
    \ (n > 1) {\n        while (n % counter == 0) {\n          result = result :+\
    \ counter\n          n /= counter\n        }\n        counter += 1\n      }\n\
    \      result", "        var m = n\n        var l : List[Long] = List()\n    \
    \    for (i <- 2l to n) {\n            while (m % i == 0) {\n                l\
    \ = l :+ i\n                m /= i\n            }\n        }\n        return l",
  "        var result = new ArrayBuffer[Long]\n        var current = n\n        while\
    \ (current % 2 == 0) {\n            result += 2\n            current /= 2\n  \
    \      }\n        var factor = 3\n        while (factor <= current) {\n      \
    \      while (current % factor == 0) {\n                result += factor\n   \
    \             current /= factor\n            }\n            factor += 2\n    \
    \    }\n        result.toList", "        val sqrtn = sqrt(n)\n        val p =\
    \ new PrimeIterator\n        var ret = new ListBuffer[Long]\n        var x = n\n\
    \        while (x > 1 && p.hasNext) {\n            val p1 = p.next\n         \
    \   if (p1 > sqrtn) {\n                ret += x\n                x = 1\n     \
    \       } else {\n                while (x % p1 == 0) {\n                    ret\
    \ += p1\n                    x /= p1\n                }\n            }\n     \
    \   }\n        ret.toList", "        var x = n\n        var f = List[Long]()\n\
    \        for (i <- 2l to sqrt(n).toLong) {\n            var c = 0\n          \
    \  while (x % i == 0) {\n                c += 1\n                x /= i\n    \
    \        }\n            for (j <- 1 to c) f = f :+ i\n        }\n        if (x\
    \ > 1) f = f :+ x\n        f", "        if (n <= 0) {\n            throw new IllegalArgumentException(\"\
    There is no factorization for nonpositive integers\")\n        }\n        var\
    \ factors = List[Long]()\n        var result = 1l\n        var current = n\n \
    \       var i = 2l\n        while (i <= n) {\n            var count = 0\n    \
    \        while (current % i == 0) {\n                count += 1\n            \
    \    current /= i\n            }\n            factors ++= List.fill(count)(i)\n\
    \            i += 1\n        }\n        factors", "        val primes = Prime.listPrimesInRange(2,\
    \ 1000).toList\n        def iter(n : Long, primes : List[Long], acc : List[Long])\
    \ : List[Long] = {\n            primes match {\n                case Nil => acc\n\
    \                case h :: t => {\n                    if (n % h == 0) {\n   \
    \                     iter(n / h, primes, h :: acc)\n                    } else\
    \ {\n                        iter(n, t, acc)\n                    }\n        \
    \        }\n            }\n        }\n        iter(n, primes, Nil)", "       \
    \ // return list of prime factors of given integer in the order from smallest\
    \ to largest\n        def go(n : Long, ps : List[Long]) : List[Long] = {\n   \
    \         if (n == 1) Nil\n            else if (ps.head * ps.head > n) List(n)\n\
    \            else if (n % ps.head == 0) ps.head :: go(n / ps.head, ps)\n     \
    \       else go(n, ps.tail)\n        }\n        go(n, primes(sqrt(n).toInt + 1))",
  "        if (n <= 0) {\n            Nil\n        } else {\n            val divisor\
    \ = nextDivisor(n)\n            if (divisor == n) {\n                List(n)\n\
    \            } else {\n                divisor :: factorize(n / divisor)\n   \
    \         }\n        }", "        var result = List[Long]()\n        var factor\
    \ = 2l\n        var number = n\n        while (factor <= number) {\n         \
    \   if (number % factor == 0) {\n                result = result :+ factor\n \
    \               number /= factor\n            } else {\n                factor\
    \ += 1\n            }\n        }\n        result", "        def cnt(x : Long,\
    \ n : Long) : Int = {\n            if (n % x == 0) 1 + cnt(x, n / x)\n       \
    \     else 0\n        }\n        def factorize(n : Long, lst : List[Long]) : List[Long]\
    \ = {\n            if (n == 1) lst\n            else {\n                val r\
    \ = lst(0)\n                val d = cnt(r, n)\n                if (d > 0) factorize(n\
    \ / (r ^ d), lst.tail) ::: List.fill(d)(r)\n                else factorize(n,\
    \ lst.tail)\n            }\n        }\n        factorize(n, (2l to n / 2l).filter(i\
    \ => n % i == 0).toList)", "        def factorize(n : Long, list : List[Long])\
    \ : List[Long] = {\n            if (n == 1) list\n            else {\n       \
    \         val div = divisors(n).filter(i => i != 1 && i != n).min\n          \
    \      factorize(n / div, list :+ div)\n            }\n        }\n        factorize(n,\
    \ List())", "        // If number is prime then just return the list of it.\n\
    \        if (isPrime(n))\n            return List(n)\n        // If number is\
    \ composite and even then return 2 multiplied by the number of times it's evenly\
    \ divisible by 2\n        if (n % 2 == 0)\n            return List.fill(n.toString.filter(x\
    \ => x == '0').length)(2)\n        // Otherwise, we need to find the number of\
    \ prime factors\n        var result = List[Long]()\n        var k = 3\n      \
    \  var t = n\n        while (k * k <= t) {\n            if (t % k == 0) {\n  \
    \              result ::= k\n                t /= k\n            }\n         \
    \   else\n                k += 2\n        }\n        if (t > 1)\n            result\
    \ ::= t\n        return result", "        var nn = n\n        var lst = new ListBuffer[Long]()\n\
    \        var primes = Array(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l,\
    \ 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l,\
    \ 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l,\
    \ 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l,\
    \ 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l,\
    \ 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l,\
    \ 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l,\
    \ 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l,\
    \ 571l, 577l, 587l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l,\
    \ 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l,\
    \ 739l, 743l, 751l, 757l, 761l, 769l, 773l, 787l, 797l, 809l, 811l, 821l, 823l,",
  "        def f(n : Long, p : Int) : List[Long] = {\n            if (n == 1) return\
    \ List()\n            if (p * p > n) return List(n)\n            val r = Stream.from(2).takeWhile(x\
    \ => n % x != 0).length\n            var q = pow(p, r).toLong\n            if\
    \ (n % q == 0) return List.fill(r)(p) ::: f(n / q, p + 1)\n            else return\
    \ f(n, p + 1)\n        }\n        if (n < 2) return List()\n        return f(n,\
    \ 2)", "        val primes = Sieve.sieve(ceil(sqrt(n).toInt).toInt)\n        val\
    \ p = primes.takeWhile(_ <= n).find(n % _ == 0)\n        if (p.isEmpty) List(n)\n\
    \        else p.get :: factorize(n / p.get)", "        if (n == 1) return List(1l)\n\
    \        var work = n\n        var result = List[Long]()\n        for (i <- 2\
    \ to (sqrt(n).toInt + 1)) {\n            while (work % i == 0) {\n           \
    \     result = result :+ i.toLong\n                work /= i\n            }\n\
    \        }\n        if (work != 1) result = result :+ work\n        return result",
  "        var primes = new PrimeIterator()\n        val factors = ListBuffer[Long]()\n\
    \        var n1 = n\n        while (n1 > 1) {\n            val p = primes.next()\n\
    \            while (n1 % p == 0) {\n                factors += p\n           \
    \     n1 /= p\n            }\n        }\n        factors.toList", "        var\
    \ factors = List[Long]()\n        var num = n\n        while (num % 2 == 0) {\n\
    \            factors = factors :+ 2\n            num /= 2\n        }\n       \
    \ for (i <- 3 to sqrt(num).toInt by 2) {\n            while (num % i == 0) {\n\
    \                factors = factors :+ i\n                num /= i\n          \
    \  }\n        }\n        if (num > 2) factors = factors :+ num\n        factors",
  "        // Generate list of prime numbers less than sqrt(n)\n        val primeNumbers\
    \ = ArrayBuffer[Long]()\n        var p = 2l\n        while (p <= sqrt(n)) {\n\
    \            primeNumbers += p\n            p = p + 1\n        }\n        val\
    \ factors = ArrayBuffer[Long]()\n        var nn = n\n        var i = 0\n     \
    \   // For each prime number, divide nn by it if nn is divisible by it.\n    \
    \    // After that, increment i and repeat from the start.\n        // If nn is\
    \ not divisible by it, increment i and repeat from the start.\n        // If nn\
    \ becomes 1, exit the loop.\n        while (nn != 1) {\n            if (nn % primeNumbers(i)\
    \ == 0) {\n                factors += primeNumbers(i)\n                nn = nn\
    \ / primeNumbers(i)\n            }\n            else i = i + 1\n        }\n  \
    \      factors.toList", "        var k = n\n        var factors = List[Long]()\n\
    \        var x = 2l\n        while (k != 1) {\n            if (k % x == 0) {\n\
    \                factors = factors :+ x\n                k /= x\n            }\n\
    \            else x += 1\n        }\n        factors", "        val primes = (1\
    \ to floor(sqrt(n)).toInt).filter(i => isPrime(i)).map(i => i.toLong)\n      \
    \  def factorize(n : Long, primes : List[Long]) : List[Long] = {\n           \
    \ if (n == 1) return List()\n            val nextPrime = primes.head\n       \
    \     if (n % nextPrime == 0) {\n                return nextPrime :: factorize(n\
    \ / nextPrime, primes)\n            }\n            factorize(n, primes.tail)\n\
    \        }\n        factorize(n, primes)", "        val primes = new PrimeGenerator().getPrimes(n\
    \ + 1)\n        val factor = new LinkedList[Long]\n        var temp = n\n    \
    \    for (i <- 0 until primes.length) {\n            while (temp % primes(i) ==\
    \ 0) {\n                factor.add(primes(i))\n                temp /= primes(i)\n\
    \            }\n        }\n        factor.toList", "        def iter(n : Long,\
    \ acc : List[Long]) : List[Long] = if (n == 1) acc else if (n % 2 == 0) iter(n\
    \ / 2, 2l :: acc) else for (i <- 3l to sqrt(n).toLong by 2 if n % i == 0) return\
    \ iter(n / i, i :: acc)\n        iter(n, Nil)", "      val primeFactors : ListBuffer[Long]\
    \ = new ListBuffer[Long]()\n      var quotient : Long = n\n      while (quotient\
    \ % 2 == 0) {\n        primeFactors += 2\n        quotient /= 2\n      }\n   \
    \   var divisor : Long = 3\n      while (quotient > 1) {\n        while (quotient\
    \ % divisor == 0) {\n          primeFactors += divisor\n          quotient /=\
    \ divisor\n        }\n        divisor += 2\n      }\n      primeFactors.toList",
  "        var factors = List[Long]()\n        var v = n\n        for (i <- 2l to\
    \ v) {\n            if (v % i == 0) {\n                factors :+= i\n       \
    \         v /= i\n                i -= 1\n            }\n        }\n        factors",
  "        // replace with your code.\n        var current = n\n        var factors\
    \ = new ArrayBuffer[Long]()\n        while (current % 2 == 0) {\n            factors\
    \ += 2\n            current /= 2\n        }\n        var factor = 3l\n       \
    \ while (factor <= sqrt(current)) {\n            while (current % factor == 0)\
    \ {\n                factors += factor\n                current /= factor\n  \
    \          }\n            factor += 2\n        }\n        if (current > 2) factors\
    \ += current\n        factors.toList", "        var result = List[Long]()\n  \
    \      var m = n\n        var p = 2\n        while (m > 1) {\n            while\
    \ (m % p == 0) {\n                result = result :+ p\n                m /= p\n\
    \            }\n            p += 1\n        }\n        result", "        var p\
    \ = n\n        var factors = new ListBuffer[Long]()\n        while (p % 2 == 0)\
    \ {\n            factors += 2\n            p /= 2\n        }\n        for (i <-\
    \ 3l to sqrt(p).toLong by 2) {\n            while (p % i == 0) {\n           \
    \     factors += i\n                p /= i\n            }\n        }\n       \
    \ if (p > 2) factors += p\n        factors.toList", "        var result = List[Long]()\n\
    \        var n_l = n\n        var factor = 2l\n        var done = false\n    \
    \    while(!done) {\n            if(n_l % factor == 0) {\n                result\
    \ = result :+ factor\n                n_l /= factor\n            }\n         \
    \   else {\n                factor += 1\n            }\n            if(factor\
    \ > n_l) {\n                done = true\n            }\n        }\n        return\
    \ result", "        var factors = List[Long]()\n        var m = n\n        var\
    \ p = 2l\n        while (m > 1) {\n            if (m % p == 0) {\n           \
    \     factors = factors :+ p\n                m /= p\n            } else {\n \
    \               p += 1\n            }\n        }\n        factors", "        var\
    \ result = List[Long]()\n        var m = n\n        var i = 2\n        while (i\
    \ * i <= m) {\n            while (m % i == 0) {\n                result = i ::\
    \ result\n                m /= i\n            }\n            i += 1\n        }\n\
    \        if (m > 1) result = m :: result\n        result", "        val factorization\
    \ = new ListBuffer[Long]\n        var factor = 2l\n        while (n > 1) {\n \
    \           while (n % factor == 0) {\n                factorization += factor\n\
    \                n /= factor\n            }\n            factor += 1\n       \
    \ }\n        factorization.toList", "      var m = n\n      var factors = List[Long]()\n\
    \      var k = 2l\n      while (m > 1) {\n          if (m % k == 0) {\n      \
    \        factors = factors :+ k\n              m /= k\n          } else {\n  \
    \            k += 1\n          }\n      }\n      factors", "\t\tdef fac(n : Long,\
    \ i : Long) : List[Long] = {\n\t\t\tif (n == 1) return Nil\n\t\t\telse if (n %\
    \ i == 0) i :: fac(n / i, i)\n\t\t\telse fac(n, i + 1)\n\t\t}\n\t\tfac(n, 2)",
  "        var p = n\n        var factors = List[Long]()\n        for (i <- 2l to\
    \ n) {\n            while (p % i == 0) {\n                factors = factors :+\
    \ i\n                p /= i\n            }\n        }\n        factors", "   \
    \     val l = new ListBuffer[Long]\n        var i = 2l\n        var nn = n\n \
    \       while (i <= nn) {\n            if (nn % i == 0) {\n                l +=\
    \ i\n                nn /= i\n            } else {\n                i += 1\n \
    \           }\n        }\n        l.toList", "        def factorizeHelper(n :\
    \ Long, factors : List[Long]) : List[Long] = {\n            if (n <= 1) return\
    \ factors\n            if (isPrime(n)) return n :: factors\n            var factors_new\
    \ = factors\n            for (factor <- 1 to sqrt(n).toInt if (n % factor == 0\
    \ && isPrime(factor))) {\n                factors_new = factor :: factors_new\n\
    \                return factorizeHelper(n / factor, factors_new)\n           \
    \ }\n            throw new Exception(\"prime factorization failed\")\n       \
    \ }\n        factorizeHelper(n, List[Long]())", "        // This is the list for\
    \ accumulating factors\n        var factorList = List[Long]()\n        var quotient\
    \ = n\n        // We know that prime number has only two factors. First one will\
    \ always be 1, the second one is the number itself.\n        // The only case\
    \ of n = 1 is when n = 1 because we don't allow 0 as input.\n        if (n <=\
    \ 1) {\n            return factorList\n        }\n        var i = 2\n        while\
    \ (i <= n) {\n            // if the remainder is 0, it means i is the factor of\
    \ n\n            if (quotient % i == 0) {\n                // add i to the list\n\
    \                factorList ::= i\n                // divide the quotient with\
    \ the factor\n                quotient /= i\n                // starting from\
    \ the factor again\n                i = 2\n            } else {\n            \
    \    // increase the number to check\n                i += 1\n            }\n\
    \        }\n        return factorList", "        var result = new ListBuffer[Long]\n\
    \        var k = n\n        var i = 2l\n        while (i * i <= k) {\n       \
    \     while (k % i == 0) {\n                result += i\n                k /=\
    \ i\n            }\n            i += 1\n        }\n        if (k > 1) result +=\
    \ k\n        result.toList", "      var list : List[Long] = List[Long]()\n   \
    \   var curr = n\n      while (curr % 2 == 0) {\n        list = 2 :: list\n  \
    \      curr /= 2\n      }\n      var i = 3\n      while (i <= sqrt(curr)) {\n\
    \        while (curr % i == 0) {\n          list = i :: list\n          curr /=\
    \ i\n        }\n        i += 2\n      }\n      if (curr > 2) {\n        list =\
    \ curr :: list\n      }\n      list", "        def factorize0(n : Long, curr :\
    \ Long, primes : List[Long]) : List[Long] = {\n            val divisor = primes.find(d\
    \ => n % d == 0)\n            if (divisor.isEmpty) {\n                List(n)\n\
    \            } else {\n                divisor.get :: factorize0(n / divisor.get,\
    \ divisor.get, primes)\n            }\n        }\n        def primes(n : Long)\
    \ : List[Long] = {\n            def primes0(curr : Long, knownPrimes : List[Long])\
    \ : List[Long] = {\n                if (curr >= n) {\n                    knownPrimes\n\
    \                } else {\n                    if (knownPrimes.forall(k => curr\
    \ % k != 0)) {\n                        primes0(curr + 1, curr :: knownPrimes)\n\
    \                    } else {\n                        primes0(curr + 1, knownPrimes)\n\
    \                    }\n                }\n            }\n            primes0(2,\
    \ List())\n        }\n        factorize0(n, 2, primes(sqrt(n).toLong))", "\t\t\
    val primes = sieve(sqrt(n).toInt)\n\t\tval factors = new ArrayBuffer[Long]\n\t\
    \tvar nn = n\n\t\twhile (nn > 1) {\n\t\t\tval maxFactor = primes.filter(p => nn\
    \ % p == 0).max\n\t\t\tfactors += maxFactor\n\t\t\tnn /= maxFactor\n\t\t}\n\t\t\
    factors.toList\n\t}\n\tdef sieve(n : Int) : List[Int] = {\n\t\tval primes = new\
    \ ArrayBuffer[Int]\n\t\tval sieve = new Array[Boolean](n + 1)\n\t\tfor (i <- 2\
    \ to n) sieve(i) = true\n\t\tfor (i <- 2 to n) {\n\t\t\tif (sieve(i)) {\n\t\t\t\
    \tprimes += i\n\t\t\t\tvar j = i\n\t\t\t\twhile (j <= n) {\n\t\t\t\t\tsieve(j)\
    \ = false\n\t\t\t\t\tj += i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprimes.toList\n\t\
    }\n}", "        var n1 = n\n        var factorization = List[Long]()\n       \
    \ var i = 2l\n        while (i <= n1) {\n            if (n1 % i == 0) {\n    \
    \            factorization ::= i\n                n1 /= i\n            }\n   \
    \         else i += 1\n        }\n        factorization", "        def isqrt(n\
    \ : Long) : Long = {\n            def isqrt0(a : Long, b : Long) : Long = {\n\
    \                if (a <= b) a\n                else isqrt0((a + b) / 2, b)\n\
    \            }\n            isqrt0(n, n / 2)\n        }\n        val a = ArrayBuffer[Long]()\n\
    \        var r = n\n        while (r % 2 == 0) { a += 2; r /= 2 }\n        var\
    \ i = 3l\n        while (i <= isqrt(r)) {\n            while (r % i == 0) { a\
    \ += i; r /= i }\n            i += 2\n        }\n        if (r > 1) a += r\n \
    \       a.toList", "        val factors = new ListBuffer[Long]\n        var nn\
    \ = n\n        var d = 2l\n        while (nn != 1) {\n            if (nn % d ==\
    \ 0) {\n                factors += d\n                nn /= d\n            } else\
    \ {\n                d += 1\n            }\n        }\n        factors.toList",
  "        def go(x : Long, ps : List[Long]) : List[Long] = x match {\n          \
    \  case x if x < 2 => ps\n            case x if x % 2 == 0 => go(x / 2, 2l ::\
    \ ps)\n            case x => go((x + 1) / 2, 2l :: ps)\n        }\n        go(n,\
    \ Nil)", "        var m = n\n        var factors = List[Long]()\n        while\
    \ (m % 2 == 0) {\n            factors = 2l :: factors\n            m /= 2\n  \
    \      }\n        var f = 3l\n        while (f * f <= m) {\n            while\
    \ (m % f == 0) {\n                factors = f :: factors\n                m /=\
    \ f\n            }\n            f += 2\n        }\n        if (m > 1) factors\
    \ = m :: factors\n        factors", "        val factors = new ListBuffer[Long]\n\
    \        for (p <- (2 to n.toInt).toList.par) {\n            if (n % p == 0) {\n\
    \                factors += p\n                return factors.toList ::: factorize(n\
    \ / p)\n            }\n        }\n        factors.toList", "        val primeFactors\
    \ = new ListBuffer[Long]()\n        var k = n\n        for (i <- 2l to n) {\n\
    \            while (k % i == 0) {\n                primeFactors += i\n       \
    \         k /= i\n            }\n        }\n        return primeFactors.toList",
  "        // Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n        // Each of the factors should be listed number of times\
    \ corresponding to how many times it appeares in factorization.\n        // Input\
    \ number should be equal to the product of all factors\n        var nn = n\n \
    \       var primeFactors = scala.collection.mutable.ListBuffer[Long]()\n     \
    \   for (k <- 2 to sqrt(nn).toInt) {\n            while (nn % k == 0) {\n    \
    \            primeFactors += k\n                nn /= k\n            }\n     \
    \   }\n        if (nn > 1) primeFactors += nn\n        primeFactors.toList", "\t\t\
    def helper(n : Long, p : Long, result : List[Long]) : List[Long] = {\n\t\t\tif\
    \ (n == 1) result\n\t\t\telse if (n % p == 0) helper(n / p, p, p :: result)\n\t\
    \t\telse helper(n, p + 1, result)\n\t\t}\n\t\thelper(n, 2, Nil)", "        val\
    \ primeFactors = ListBuffer[Long]()\n        def isPrime(x : Long) : Boolean =\
    \ {\n            if (x == 1) false\n            else if (x == 2) true\n      \
    \      else !(2 to (sqrt(x).toInt)).exists(i => x % i == 0)\n        }\n     \
    \   def factorize(n : Long, i : Long = 2) : Unit = {\n            if (n == 1)\
    \ ()\n            else if (isPrime(i) && n % i == 0) {\n                primeFactors\
    \ += i\n                factorize(n / i, i)\n            }\n            else factorize(n,\
    \ i + 1)\n        }\n        factorize(n)\n        primeFactors.toList", "   \
    \     val result = new ListBuffer[Long]()\n        var x = n\n        var sqrt\
    \ = scala.math.sqrt(x)\n        for (i <- 2 to sqrt.toInt) {\n            var\
    \ count = 0\n            while (x % i == 0) {\n                count += 1\n  \
    \              x /= i\n            }\n            if (count > 0) {\n         \
    \       for (j <- 1 to count) {\n                    result += i\n           \
    \     }\n            }\n        }\n        if (x > 1) {\n            result +=\
    \ x\n        }\n        result.toList", "        var factors = List[Long]()\n\
    \        var x = n\n        while (x > 1) {\n            val d = gcd(x, x - 1)\n\
    \            factors = factors :+ d\n            x /= d\n        }\n        factors",
  "\t\tif (n == 1) return List(1)\n\t\tif (isPrime(n)) return List(n)\n\t\tval nsqrt\
    \ = sqrt(n)\n\t\tval primes = scala.collection.mutable.HashSet[Long]()\n\t\tvar\
    \ factor = 2l\n\t\twhile (factor <= nsqrt) {\n\t\t\tif (n % factor == 0) {\n\t\
    \t\t\tval times = countFactor(n, factor)\n\t\t\t\tval pair = for (i <- 1 to times)\
    \ yield factor\n\t\t\t\tprimes ++= pair\n\t\t\t\tval new_n = n / factor\n\t\t\t\
    \tval other_factors = factorize(new_n)\n\t\t\t\tprimes ++= other_factors\n\t\t\
    \t\tbreak\n\t\t\t}\n\t\t\tfactor += 1\n\t\t}\n\t\tprimes.toList.sorted", "   \
    \     var factors = List[Long]()\n        var curr = n\n        while (curr %\
    \ 2 == 0) {\n            factors = 2l :: factors\n            curr /= 2\n    \
    \    }\n        for (i <- 3 to sqrt(curr).toInt by 2) {\n            while (curr\
    \ % i == 0) {\n                factors = i.toLong :: factors\n               \
    \ curr /= i\n            }\n        }\n        if (curr > 2) factors = curr ::\
    \ factors\n        factors", "        var num = n\n        var factors = List[Long]()\n\
    \        var i = 2l\n        while (i <= num) {\n            while (num % i ==\
    \ 0) {\n                factors = factors :+ i\n                num /= i\n   \
    \         }\n            i += 1\n        }\n        factors", "        def loop(n\
    \ : Long, ps : Stream[Long]) : List[Long] = {\n            if (n == 1) {\n   \
    \             List[Long]()\n            } else {\n                val (f, x) =\
    \ factorizeAux(n, ps)\n                f :: loop(x, ps)\n            }\n     \
    \   }\n        loop(n, primes)", "        var factors = List[Long]()\n       \
    \ var nn = n\n        var c = 2l\n        while (nn != 1) {\n            if (nn\
    \ % c == 0) {\n                factors = factors :+ c\n                nn /= c\n\
    \            } else {\n                c += 1\n            }\n        }\n    \
    \    factors", "        var primeFactorization = List[Long]()\n        var k =\
    \ n\n        while (k % 2 == 0) {\n            primeFactorization = 2l :: primeFactorization\n\
    \            k /= 2\n        }\n        var i = 3\n        while (i <= sqrt(k))\
    \ {\n            while (k % i == 0) {\n                primeFactorization = i.toLong\
    \ :: primeFactorization\n                k /= i\n            }\n            i\
    \ += 2\n        }\n        if (k > 2) primeFactorization = k.toLong :: primeFactorization\n\
    \        primeFactorization", "        var result = List[Long]()\n        var\
    \ remain = n\n        for (p <- primes.takeWhile(_ <= sqrt(n))) {\n          \
    \  var count = 0\n            while (remain % p == 0) {\n                remain\
    \ /= p\n                count += 1\n            }\n            for (i <- 1 to\
    \ count) {\n                result = result :+ p\n            }\n        }\n \
    \       if (remain != 1) {\n            result = result :+ remain\n        }\n\
    \        return result", "        var list : List[Long] = List();\n        var\
    \ x = n;\n        while (x % 2 == 0) {\n            list = 2 :: list;\n      \
    \      x /= 2;\n        }\n        var i = 3;\n        while (i <= sqrt(x)) {\n\
    \            while (x % i == 0) {\n                list = i :: list;\n       \
    \         x /= i;\n            }\n            i += 2;\n        }\n        if (x\
    \ > 1) list = x :: list;\n        return list;", "        var factors = new ArrayBuffer[Long]()\n\
    \        var baseFactor = 2\n        var n_base = n\n        while (n_base !=\
    \ 1) {\n            while (n_base % baseFactor == 0) {\n                factors\
    \ += baseFactor\n                n_base /= baseFactor\n            }\n       \
    \     baseFactor += 1\n        }\n        factors.toList", "        val result\
    \ = ListBuffer[Long]()\n        var num = n\n        var counter = 2l\n      \
    \  while (counter <= num) {\n            if (num % counter == 0) {\n         \
    \       result += counter\n                num /= counter\n            }\n   \
    \         else counter += 1\n        }\n        result.toList", "        var result\
    \ = List[Long]()\n        for (i <- (2l to n)) {\n            if (n % i == 0)\
    \ {\n                result = result :+ i\n                n /= i\n          \
    \      i -= 1\n            }\n        }\n        result", "        if (n < 2)\
    \ {\n            return List[Long]()\n        }\n        var n1 = n\n        var\
    \ m = 2l\n        var x = n\n        var result = new ListBuffer[Long]()\n   \
    \     while (m * m <= x) {\n            if (n1 % m == 0) {\n                result\
    \ += m\n                n1 /= m\n            } else {\n                m += 1\n\
    \            }\n        }\n        if (n1 > 1) {\n            result += n1\n \
    \       }\n        return result.toList", "        var result = List[Long]()\n\
    \        var m = n\n        while (m > 1) {\n            val b = findLargestFactor(m)\n\
    \            result = b :: result\n            m /= b\n        }\n        result",
  "        def nextFactor(n : Long, i : Long) : Long = {\n            if (i * i >\
    \ n) {\n                n\n            } else if (n % i == 0) {\n            \
    \    i\n            } else {\n                nextFactor(n, i + 1)\n         \
    \   }\n        }\n        def factors(n : Long, i : Long, fs : List[Long]) : List[Long]\
    \ = {\n            if (n == 1) {\n                fs\n            } else {\n \
    \               val f = nextFactor(n, i)\n                factors(n / f, f, f\
    \ :: fs)\n            }\n        }\n        factors(n, 2, Nil)", "        val\
    \ factors = new ListBuffer[Long]\n        val max = sqrt(n).toLong\n        var\
    \ i = 2l\n        while (i <= max) {\n            while (n % i == 0) {\n     \
    \           factors += i\n                n /= i\n            }\n            i\
    \ += 1\n        }\n        if (n > 1) factors += n\n        factors.toList", " \
    \       var res = List[Long]()\n        var x = n\n        while (x % 2 == 0)\
    \ {\n            res = 2l :: res\n            x /= 2\n        }\n        var i\
    \ = 3\n        while (i <= sqrt(x.toDouble)) {\n            while (x % i == 0)\
    \ {\n                res = i.toLong :: res\n                x /= i\n         \
    \   }\n            i += 2\n        }\n        if (x > 1) res = x :: res\n    \
    \    res", "        val factors = ListBuffer[Long]()\n        var d = 2\n    \
    \    var copy = n\n        while (d <= copy) {\n            if (copy % d == 0)\
    \ {\n                factors += d\n                copy /= d\n            }\n\
    \            else d += 1\n        }\n        factors.toList", "        // TODO:\
    \ implement solution (easy)\n        null", "        def f(n : Long, factors :\
    \ List[Long]) : List[Long] = n match {\n            case 1 => factors\n      \
    \      case _ => {\n                var k = n / 2\n                while (k >\
    \ 1 && n % k != 0) k -= 1\n                if (k == 1) n :: factors\n        \
    \        else f(n / k, k :: factors)\n            }\n        }\n        f(n, Nil)",
  "        // This is a very inefficient way. It should be implemented using sieve\
    \ of Eratosthenes or something similar\n        def factorize0(n : Long, divisor\
    \ : Long, factors : List[Long]) : List[Long] = {\n            if (n == 1) return\
    \ factors.reverse\n            else if (n % divisor == 0) factorize0(n / divisor,\
    \ divisor, divisor :: factors)\n            else factorize0(n, divisor + 1, factors)\n\
    \        }\n        factorize0(n, 2, Nil)", "        def factorize0(n : Long,\
    \ acc : List[Long]) : List[Long] = {\n            if (n == 1) acc.reverse\n  \
    \          else {\n                for (p <- 2 to sqrt(n).toInt) {\n         \
    \           if (n % p == 0) return factorize0(n / p, p :: acc)\n             \
    \   }\n                n :: acc\n            }\n        }\n        factorize0(n,\
    \ Nil)", "        val primes = sieve(sqrt(n).toInt)\n        val factors = new\
    \ ListBuffer[Long]\n        var q = n\n        while (q != 1) {\n            val\
    \ p = primes.find(q % _ == 0).get\n            factors += p\n            q /=\
    \ p\n        }\n        factors.toList", "        // List of tuples in the form\
    \ (factor, multiplicity)\n        val factors = ListBuffer[(Long, Int)]()\n  \
    \      var n_cur = n\n        // Factors of 2\n        var cnt_2 = 0\n       \
    \ while (n_cur % 2 == 0) {\n            cnt_2 += 1\n            n_cur /= 2\n \
    \       }\n        if (cnt_2 > 0) factors += ((2, cnt_2))\n        // Rest of\
    \ the factors\n        var factor = 3l\n        var stop = sqrt(n_cur).toLong\n\
    \        while (n_cur > 1 && factor <= stop) {\n            var cnt = 0\n    \
    \        while (n_cur % factor == 0) {\n                cnt += 1\n           \
    \     n_cur /= factor\n            }\n            if (cnt > 0) factors += ((factor,\
    \ cnt))\n            factor += 2\n            stop = sqrt(n_cur).toLong\n    \
    \    }\n        if (n_cur > 1) factors += ((n_cur, 1))\n        var result = List[Long]()\n\
    \        for (factor <- factors) {\n            for (i <- 1 to factor._2) {\n\
    \                result = factor._1 :: result\n            }\n        }\n    \
    \    result", "        val result = new ListBuffer[Long]\n        var m = n\n\
    \        for (i <- 2l to n) {\n            if (m % i == 0) {\n               \
    \ result += i\n                m /= i\n                i -= 1\n            }\n\
    \        }\n        result.toList", "        def factorize0(n : Long, acc : List[Long])\
    \ : List[Long] = {\n            val sqrt = sqrt(n).toLong\n            if (n <=\
    \ 1) acc.reverse\n            else {\n                val i = (2 to sqrt).find(n\
    \ % _ == 0).get\n                factorize0(n / i, i :: acc)\n            }\n\
    \        }\n        factorize0(n, Nil)", "        var p = 2l\n        var nn =\
    \ n\n        var l : List[Long] = Nil\n        while (p * p <= nn) {\n       \
    \     if (nn % p == 0) {\n                nn /= p\n                l = p :: l\n\
    \            } else {\n                p += 1\n            }\n        }\n    \
    \    if (nn > 1) l = nn :: l\n        l.reverse", "        var result = new ListBuffer[Long]\n\
    \        var nn = n\n        while (nn % 2 == 0) {\n            result += 2\n\
    \            nn /= 2\n        }\n        var i = 3l\n        while (i <= nn) {\n\
    \            if (nn % i == 0) {\n                result += i\n               \
    \ nn /= i\n            }\n            else i += 2\n        }\n        result.toList",
  "        val factors = ArrayBuffer[Long]()\n        var nn = n\n        while (nn\
    \ % 2 == 0) {\n            factors += 2\n            nn /= 2\n        }\n    \
    \    var d = 3\n        while (nn > 1) {\n            while (nn % d == 0) {\n\
    \                factors += d\n                nn /= d\n            }\n      \
    \      d += 2\n        }\n        factors.toList", "        var nn = n\n     \
    \   var results = new ListBuffer[Long]()\n        while (nn % 2 == 0) {\n    \
    \        results += 2\n            nn /= 2\n        }\n        val m = (math.sqrt(nn)\
    \ + 1).toLong\n        for (i <- 3l to m by 2) {\n            while (nn % i ==\
    \ 0) {\n                results += i\n                nn /= i\n            }\n\
    \        }\n        if (nn > 1) {\n            results += nn\n        }\n    \
    \    results.toList", "        // Counter: Maps each prime to number of times\
    \ it appears in factorization\n        var counter = new ListBuffer[Long]\n  \
    \      // Iterate over possible factors\n        var i = 2l\n        while (i\
    \ * i <= n) {\n            // If i is a factor, divide it out from n\n       \
    \     if (n % i == 0) {\n                counter += i\n                n /= i\n\
    \            }\n            // Otherwise, add 1 to i\n            else i += 1\n\
    \        }\n        // If after all the iterations, there is still a value for\
    \ n > 1,\n        // then it must be a prime greater than sqrt(n)\n        if\
    \ (n > 1) counter += n\n        counter.toList", "        def factors(n : Long,\
    \ x : Long, acc : List[Long]) : List[Long] = {\n            if (n == 1) return\
    \ acc\n            if (n % x == 0) return factors(n / x, x, x :: acc)\n      \
    \      else return factors(n, x + 1, acc)\n        }\n        return factors(n,\
    \ 2, Nil)", "        if (n <= 1) return List(n)\n        else {\n            val\
    \ primeFactors = new ArrayBuffer[Long]\n            var m = n\n            var\
    \ i = 2l\n            while (i <= m) {\n                if (m % i == 0) {\n  \
    \                  primeFactors += i\n                    m /= i\n           \
    \     }\n                else i += 1\n            }\n            primeFactors.toList\n\
    \        }", "        var l = List[Long]()\n        var t = n\n        var i =\
    \ 2l\n        while (i * i <= t) {\n            if (t % i == 0) {\n          \
    \      l = l :+ i\n                t /= i\n            } else {\n            \
    \    i += 1\n            }\n        }\n        if (t > 1) l = l :+ t\n       \
    \ return l", "        var f = List[Long]()\n        if (n < 1) throw new IllegalArgumentException(\"\
    n should be greater than 0\")\n        else if (n == 1) f = List[Long](1l)\n \
    \       else {\n            val sqrtn = ceil(sqrt(n)).toLong\n            var\
    \ i = 2l\n            while (i <= sqrtn) {\n                if (n % i == 0) {\n\
    \                    f = f :+ i\n                    f = f ::: factorize(n / i)\n\
    \                    return f\n                }\n                i += 1\n   \
    \         }\n            f = f :+ n\n        }\n        return f", "        val\
    \ factors = new ArrayBuffer[Long]()\n        if (n <= 2) {\n            factors\
    \ += n\n            return factors.toList\n        }\n        var num = n\n  \
    \      var prime = 2l\n        while (num > 1) {\n            if (num % prime\
    \ == 0) {\n                factors += prime\n                num /= prime\n  \
    \          }\n            else {\n                prime += 1\n            }\n\
    \        }\n        factors.toList", "        var result = List[Long]()\n    \
    \    var remainder = n\n        for (divisor <- 2l to round(sqrt(n)).toLong) {\n\
    \            while (remainder % divisor == 0) {\n                result = result\
    \ :+ divisor\n                remainder /= divisor\n            }\n        }\n\
    \        if (remainder > 1) result = result :+ remainder\n        result", " \
    \       var list = ArrayBuffer[Long]()\n        var primes = ArrayBuffer[Long]()\n\
    \        val set = HashSet[Long]()\n        val limit = (sqrt(n) + 1).toLong\n\
    \        var number = n\n        var d = 2l\n        while (d <= limit) {\n  \
    \          if (number % d == 0) {\n                number /= d\n             \
    \   if (!set.contains(d)) {\n                    set += d\n                  \
    \  primes += d\n                }\n                list += d\n            }\n\
    \            else d += 1\n        }\n        if (number != 1) {\n            if\
    \ (!set.contains(number)) primes += number\n            list += number\n     \
    \   }\n        primes.toList", "        var r = List[Long]()\n        var c =\
    \ n\n        for (i <- (2l to sqrt(n.toDouble).toLong)) {\n            var t =\
    \ 0\n            while (c % i == 0) {\n                c /= i\n              \
    \  t += 1\n            }\n            if (t > 0) r ::= i\n        }\n        if\
    \ (c > 1) r ::= c\n        r.reverse", "        val list = MutableList[Long]()\n\
    \        var r = n\n        while (r % 2 == 0) {\n            list += 2\n    \
    \        r /= 2\n        }\n        var i = 3\n        while (i <= sqrt(r)) {\n\
    \            while (r % i == 0) {\n                list += i\n               \
    \ r /= i\n            }\n            i += 2\n        }\n        if (r > 1) list\
    \ += r\n        list.toList", "        val factors = ListBuffer[Long]()\n    \
    \    var m = n\n        while (m % 2 == 0) {\n            factors += 2\n     \
    \       m /= 2\n        }\n        var p = 3\n        while (m > 1) {\n      \
    \      if (m % p == 0) {\n                factors += p\n                m /= p\n\
    \            } else {\n                p += 2\n            }\n        }\n    \
    \    factors.toList", "        val factors = ListBuffer[Long]()\n        var m\
    \ = n\n        for (i <- 2l to m) {\n            if (m % i == 0) {\n         \
    \       factors += i\n                m /= i\n                i -= 1\n       \
    \     }\n        }\n        factors.toList", "        // TODO: implement this\n\
    \        var c = n\n        var p = 2l\n        var result : List[Long] = Nil\n\
    \        while (c != 1) {\n            while (c % p == 0) {\n                result\
    \ = p :: result\n                c /= p\n            }\n            p += 1\n \
    \       }\n        result", "        var result = new ArrayBuffer[Long]\n    \
    \    var nn = n\n        var x = 2l\n        while (nn > 1) {\n            while\
    \ (nn % x == 0) {\n                result += x\n                nn /= x\n    \
    \        }\n            x += 1\n        }\n        result.toList", "      var\
    \ list = List[Long]()\n      var m = n\n      while (m % 2 == 0) {\n        list\
    \ = list :+ 2\n        m /= 2\n      }\n      var i = 3\n      while (i <= m)\
    \ {\n        if (m % i == 0) {\n          list = list :+ i\n          m /= i\n\
    \        } else {\n          i += 2\n        }\n      }\n      list", "      \
    \  val primes = Prime.primes(n).toList\n        val result = ListBuffer[Long]()\n\
    \        var remaining = n\n        for (p <- primes) {\n            while (remaining\
    \ % p == 0) {\n                result += p\n                remaining /= p\n \
    \           }\n        }\n        result.toList", "        var facs = new ArrayBuffer[Long]\n\
    \        var m = n\n        for (p <- primes) {\n            if (p * p > m) {\n\
    \                facs += m\n                return facs.toList\n            }\n\
    \            while (m % p == 0) {\n                facs += p\n               \
    \ m /= p\n            }\n        }\n        facs.toList", "        def factorizeHelper(n\
    \ : Long, res : List[Long]) : List[Long] = {\n            if (n == 1) res\n  \
    \          else {\n                val factors = (2l to sqrt(n).toLong).filter(n\
    \ % _ == 0)\n                if (factors.isEmpty) n :: res\n                else\
    \ {\n                    val factor = factors.head\n                    factorizeHelper(n\
    \ / factor, factor :: res)\n                }\n            }\n        }\n    \
    \    factorizeHelper(n, Nil).sorted", "        val r = factorize_helper(n, 2l)\n\
    \        if (r.keySet.map(e => Math.pow(e, r(e))).reduce(_ * _) != n) throw new\
    \ Exception(\"factorization error\");\n        r.keySet.toList.sorted.flatMap(e\
    \ => List.fill(r(e).toInt)(e))", "        var factors = List[Long]()\n       \
    \ for (i <- 1l to n; if (n % i == 0l)) {\n            factors = factors :+ i\n\
    \        }\n        factors", "        var factors = new ListBuffer[Long]\n  \
    \      var i = 2l\n        var current = n\n        while (i * i <= current) {\n\
    \            if (current % i == 0) {\n                factors += i\n         \
    \       current /= i\n            }\n            else i += 1\n        }\n    \
    \    if (current > 1) factors += current\n        factors.toList", "        if\
    \ (n == 1) return List[Long](1l)\n        var factors = new ArrayBuffer[Long]()\n\
    \        for (k <- (2l to n/2)) {\n            while (n % k == 0) {\n        \
    \        factors += k\n                n /= k\n            }\n        }\n    \
    \    if (n > 1) factors += n\n        factors.toList", "        if (n < 2) {\n\
    \            List[Long]()\n        } else {\n            val p = if (n % 2 ==\
    \ 0) 2 else Stream.from(3, 2).dropWhile(p => n % p != 0).head\n            if\
    \ (p == n) List[Long](n) else List[Long](p) ++ factorize(n / p)\n        }", "\t\t\
    def recurse(n : Long, primes : Stream[Long]) : List[Long] = {\n\t\t\tif (n ==\
    \ 1) Nil\n\t\t\telse if (n % primes.head == 0) primes.head :: recurse(n / primes.head,\
    \ primes)\n\t\t\telse recurse(n, primes.tail)\n\t\t}\n\t\trecurse(n, Stream.from(2).map(_.toLong))\n\
    \t}\n    def main(args: Array[String]) {", "        def div(n : Long, factor :\
    \ Long) : List[Long] = if (n % factor == 0) factor :: div(n / factor, factor)\
    \ else Nil\n        def factorize0(n : Long, factor : Long) : List[Long] = if\
    \ (n == 1) Nil else if (n % factor == 0) factor :: factorize0(n / factor, factor)\
    \ else factorize0(n, factor + 1)\n        factorize0(n, 2)", "        def factorizeHelper(n\
    \ : Long, list : List[Long], prime : Long) : List[Long] = {\n            if (n\
    \ == 1) list\n            else if (n % prime == 0) factorizeHelper(n / prime,\
    \ list :+ prime, prime)\n            else factorizeHelper(n, list, prime + 1)\n\
    \        }\n        factorizeHelper(n, List(), 2)", "        val primeList = new\
    \ PrimeList(sqrt(n).toInt)\n        var current = n\n        var factorList =\
    \ List[Long]()\n        while (current != 1) {\n            val factor = primeList.nextPrime\n\
    \            while (current % factor == 0) {\n                factorList = factor\
    \ :: factorList\n                current /= factor\n            }\n        }\n\
    \        factorList", "        var m = n\n        var k = 2l\n        var factors\
    \ = List[Long]()\n        while (m > 1) {\n            while (m % k == 0) {\n\
    \                factors = factors :+ k\n                m /= k\n            }\n\
    \            k += 1\n        }\n        factors", "        def factorize_(n :\
    \ Long, primes : List[Long]) : List[Long] = n match {\n            case 1 => Nil\n\
    \            case _ => {\n                val (quotient, remainder) = n /% primes.head\n\
    \                if (remainder == 0) primes.head :: factorize_(quotient, primes)\n\
    \                else factorize_(n, primes.tail)\n            }\n        }\n \
    \       factorize_(n, primes(n).takeWhile(_ <= sqrt(n).toLong))", "        var\
    \ primefactors = new ListBuffer[Long]\n        var factor = 2l\n        var remaining\
    \ = n\n        while (factor * factor <= remaining) {\n            if (remaining\
    \ % factor == 0) {\n                primefactors += factor\n                remaining\
    \ /= factor\n            }\n            else factor += (if (factor == 2) 1 else\
    \ 2)\n        }\n        if (remaining > 1) primefactors += remaining\n      \
    \  primefactors.toList", "        var n2 = n\n        var factors = List[Long]()\n\
    \        var i = 2l\n        while (i <= n2) {\n            while (n2 % i == 0)\
    \ {\n                factors = factors :+ i\n                n2 /= i\n       \
    \     }\n            i += 1\n        }\n        factors", "        var list =\
    \ new ArrayBuffer[Long]()\n        var sqrt = sqrt(n).toLong\n        while (n\
    \ % 2 == 0) {\n            list += 2\n            n /= 2\n        }\n        if\
    \ (n == 1) return list.toList\n        var factor = 3\n        while (factor <=\
    \ sqrt) {\n            while (n % factor == 0) {\n                list += factor\n\
    \                n /= factor\n            }\n            factor += 2\n       \
    \ }\n        if (n != 1) list += n\n        list.toList", "        var factors\
    \ = List[Long]()\n        var N = n\n        var i = 2\n        while (i <= N)\
    \ {\n            if (N % i == 0) {\n                factors = factors :+ i\n \
    \               N /= i\n            }\n            else i += 1\n        }\n  \
    \      factors", "        val primeFactors = ListBuffer[Long]()\n        var r\
    \ = n\n        for (i <- 2l to r) {\n            while (r % i == 0) {\n      \
    \          primeFactors += i\n                r /= i\n            }\n        }\n\
    \        return primeFactors.toList", "      var result = List[Long]()\n     \
    \ var temp = n\n      for (i <- 2l to sqrt(n).toLong) {\n        while (temp %\
    \ i == 0) {\n          result = result :+ i\n          temp /= i\n        }\n\
    \      }\n      if (temp != 1) result = result :+ temp\n      result", "     \
    \   var number = n\n        var factors = List[Long]()\n        var i = 2l\n \
    \       while (i <= number) {\n            if (number % i == 0) {\n          \
    \      factors ::= i\n                number /= i\n            }\n           \
    \ else i += 1\n        }\n        factors", "        def inner(n : Long, factor\
    \ : Long) : List[Long] = {\n            if (n == 1) Nil\n            else if (n\
    \ % factor == 0) factor :: inner(n / factor, factor)\n            else inner(n,\
    \ factor + 1)\n        }\n        inner(n, 2)", "        var remaining = n\n \
    \       var factors = new ListBuffer[Long]()\n        var d = 2l\n        while\
    \ (d * d <= remaining) {\n            while (remaining % d == 0) {\n         \
    \       factors += d\n                remaining /= d\n            }\n        \
    \    d += 1\n        }\n        if (remaining > 1) factors += remaining\n    \
    \    factors.toList", "        var nn = n\n        var l = List[Long]()\n    \
    \    for (i <- 2l to nn) {\n            while (nn % i == 0) {\n              \
    \  l = l :+ i\n                nn /= i\n            }\n        }\n        return\
    \ l", "        if (n == 1) {\n            return List[Long](1l)\n        }\n \
    \       var primes = Array[Long](2l)\n        var tmp = n\n        var answer\
    \ = List[Long]()\n        while (tmp != 1) {\n            var prime = primes.filter(p\
    \ => tmp % p == 0).last\n            var prime_power = prime\n            while\
    \ (tmp % prime_power == 0) {\n                answer = answer :+ prime\n     \
    \           prime_power *= prime\n            }\n            tmp /= prime_power\n\
    \            if (primes.last < prime) {\n                primes = primes :+ prime\n\
    \            }\n        }\n        answer", "        def factorizeHelper(n : Long,\
    \ primes : Stream[Long]) : List[Long] = {\n            if (n == 1) List[Long]()\n\
    \            else if (n % primes.head == 0) primes.head :: factorizeHelper(n /\
    \ primes.head, primes)\n            else factorizeHelper(n, primes.tail)\n   \
    \     }\n        factorizeHelper(n, primeStream)", "      // Compute power of\
    \ given prime factor that is returned by first call to primeFactorization\n  \
    \    // Return remainder of the number which can be again factorized.\n      def\
    \ computePower(n : Long, factor : Long) : (Long, Long) = {\n        //println(\"\
    ComputePower \" + n + \" \" + factor)\n        if (n % factor != 0) (1, n)\n \
    \       else {\n          val (power, remainder) = computePower(n / factor, factor)\n\
    \          (power + 1, remainder)\n        }\n      }\n      // Recursively perform\
    \ prime factorization.\n      // Return prime factor with corresponding power\
    \ and the remainder that needs to be factorized.\n      def primeFactorization(n\
    \ : Long) : (Long, Long, Long) = {\n        if (n % 2 == 0) {\n          val (power,\
    \ remainder) = computePower(n, 2)\n          (2, power, remainder)\n        }\n\
    \        else {\n          var factor = 3\n          while (n % factor != 0) factor\
    \ += 2\n          val (power, remainder) = computePower(n, factor)\n         \
    \ (factor, power, remainder)\n        }\n      }\n      // Recursively create\
    \ list of prime factors.\n      def createFactorList(n : Long, factorList : List[Long])\
    \ : List[Long] = {\n        //println(\"Factorize \" + n)\n        if (n == 1)\
    \ factorList\n        else {\n          val (factor, power, remainder) = primeFactorization(n)\n\
    \          val list = ArrayBuffer[Long]()\n          for (i <- 1 to power.toInt)\
    \ list += factor\n          createFactorList(remainder, factorList ++ list)\n\
    \        }\n      }\n      createFactorList(n, List[Long]())", "        def factorizeHelper(n\
    \ : Long, divisor : Long) : List[Long] = {\n            //println(\"fact(\" +\
    \ n + \", \" + divisor + \")\")\n            if (n <= 1) List[Long]()\n      \
    \      else if (n % divisor == 0) divisor :: factorizeHelper(n / divisor, divisor)\n\
    \            else factorizeHelper(n, divisor + 1)\n        }\n        factorizeHelper(n,\
    \ 2).reverse", "        if (n == 1) return List[Long](1l)\n        var factors\
    \ = List[Long]()\n        var temp = n\n        var i = 2l\n        while (i <=\
    \ temp) {\n            if (temp % i == 0) {\n                factors = factors\
    \ :+ i\n                temp /= i\n            }\n            else i += 1\n  \
    \      }\n        factors", "        val primes = primesBelow(sqrt(n).toInt +\
    \ 1)\n        def factorize(n : Long, ps : List[Int]) : List[Long] = {\n     \
    \       if (n == 1) Nil\n            else if (ps.isEmpty) List(n)\n          \
    \  else {\n                val p = ps.head\n                if (n % p == 0) p.toLong\
    \ :: factorize(n / p, ps)\n                else factorize(n, ps.tail)\n      \
    \      }\n        }\n        factorize(n, primes)", "        val factors = new\
    \ ArrayBuffer[Long]()\n        var m = n\n        var i = 2l\n        while (i\
    \ <= m) {\n            if (m % i == 0) {\n                factors += i\n     \
    \           m /= i\n            } else {\n                i += 1\n           \
    \ }\n        }\n        factors.toList", "        if (n == 0) return List(0l)\n\
    \        var n1 = abs(n)\n        var result = List[Long]()\n        var i = 2l\n\
    \        while (i <= n1) {\n            if (n1 % i == 0) {\n                result\
    \ = i :: result\n                n1 /= i\n            }\n            else i +=\
    \ 1\n        }\n        result", "\t\tval m = Array.fill(n.toInt + 1)(0)\n\t\t\
    for (i <- 2 to n.toInt) {\n\t\t\tif (m(i) == 0) {\n\t\t\t\tfor (j <- i until m.length\
    \ by i) {\n\t\t\t\t\tif (m(j) == 0) m(j) = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\
    def recur(n : Long, acc : List[Long]) : List[Long] = {\n\t\t\tval p = m(n.toInt)\n\
    \t\t\tif (p == 0) acc\n\t\t\telse recur(n / p, p :: acc)\n\t\t}\n\t\trecur(n,\
    \ Nil)", "\t\tdef factorize(n : Long, k : Long) : List[Long] = {\n\t\t\tvar factors\
    \ = new ListBuffer[Long]\n\t\t\tif (n % k == 0) {\n\t\t\t\tfactors += k\n\t\t\t\
    \tfactors ++= factorize(n / k, k)\n\t\t\t} else if (k * k <= n) {\n\t\t\t\tfactors\
    \ ++= factorize(n, k + 1)\n\t\t\t} else if (n > 1) {\n\t\t\t\tfactors += n\n\t\
    \t\t}\n\t\t\tfactors.toList\n\t\t}\n\t\tfactorize(n, 2)", "        def f(x : Long,\
    \ p : Long, acc : List[Long]) : List[Long] = {\n            if (x % p == 0) f(x\
    \ / p, p, p :: acc)\n            else if (x == 1) acc\n            else {\n  \
    \              val sqrtx = sqrt(x).toLong\n                if (p > sqrtx) x ::\
    \ acc\n                else {\n                    var a = p + 1\n           \
    \         while (a <= sqrtx && x % a != 0) a += 1\n                    if (a <=\
    \ sqrtx) f(x, a, acc)\n                    else x :: acc\n                }\n\
    \            }\n        }\n        f(n, 2, Nil)", "\t\tdef inner(n : Long, min\
    \ : Long) : List[Long] = {\n\t\t\tif (n == 1) List[Long]()\n\t\t\telse if (n %\
    \ min == 0) min :: inner(n / min, min)\n\t\t\telse inner(n, min + 1)\n\t\t}\n\t\
    \tinner(n, 2)", "        var primeFactors = new ListBuffer[Long]\n        var\
    \ num = n\n        while (num % 2 == 0) {\n            primeFactors += 2\n   \
    \         num /= 2\n        }\n        var factor = 3l\n        while (factor\
    \ <= sqrt(num)) {\n            while (num % factor == 0) {\n                primeFactors\
    \ += factor\n                num /= factor\n            }\n            factor\
    \ += 2\n        }\n        if (num > 2) primeFactors += num\n        primeFactors.toList"]
stop_tokens:
- "\n    }\n"
