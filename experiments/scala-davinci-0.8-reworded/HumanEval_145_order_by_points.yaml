name: HumanEval_145_order_by_points
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function which sorts the given list of integers\n    // in ascending\
  \ order according to the sum of their digits.\n    // Note: if there are several\
  \ items with similar sum of their digits,\n    // order them based on their index\
  \ in original list.\n    // For example:\n    // >>> orderByPoints((List[Long](1l.toLong,\
  \ 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong)))\n    // (List[Long](-1l.toLong,\
  \ -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))\n    // >>> orderByPoints((List[Long]()))\n\
  \    // (List[Long]())\n    def orderByPoints(nums : List[Long]) : List[Long] =\
  \ {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(orderByPoints((List[Long](1l.toLong,\
  \ 11l.toLong, -1l.toLong, -11l.toLong, -12l.toLong))).equals((List[Long](-1l.toLong,\
  \ -11l.toLong, 1l.toLong, -12l.toLong, 11l.toLong))));\n    assert(orderByPoints((List[Long](1234l.toLong,\
  \ 423l.toLong, 463l.toLong, 145l.toLong, 2l.toLong, 423l.toLong, 423l.toLong, 53l.toLong,\
  \ 6l.toLong, 37l.toLong, 3457l.toLong, 3l.toLong, 56l.toLong, 0l.toLong, 46l.toLong))).equals((List[Long](0l.toLong,\
  \ 2l.toLong, 3l.toLong, 6l.toLong, 53l.toLong, 423l.toLong, 423l.toLong, 423l.toLong,\
  \ 1234l.toLong, 145l.toLong, 37l.toLong, 46l.toLong, 56l.toLong, 463l.toLong, 3457l.toLong))));\n\
  \    assert(orderByPoints((List[Long]())).equals((List[Long]())));\n    assert(orderByPoints((List[Long](1l.toLong,\
  \ -11l.toLong, -32l.toLong, 43l.toLong, 54l.toLong, -98l.toLong, 2l.toLong, -3l.toLong))).equals((List[Long](-3l.toLong,\
  \ -32l.toLong, -98l.toLong, -11l.toLong, 1l.toLong, 2l.toLong, 43l.toLong, 54l.toLong))));\n\
  \    assert(orderByPoints((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
  \ 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong))).equals((List[Long](1l.toLong,\
  \ 10l.toLong, 2l.toLong, 11l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 8l.toLong, 9l.toLong))));\n    assert(orderByPoints((List[Long](0l.toLong,\
  \ 6l.toLong, 6l.toLong, -76l.toLong, -21l.toLong, 23l.toLong, 4l.toLong))).equals((List[Long](-76l.toLong,\
  \ -21l.toLong, 0l.toLong, 4l.toLong, 23l.toLong, 6l.toLong, 6l.toLong))));\n   \
  \ }\n\n}\n"
completions: ["        //if (nums.isEmpty) return nums\n        val numsWithPoints\
    \ = nums.zipWithIndex.map(x => (x._1, Problem.calculatePoint(x._1))).sortBy(x\
    \ => x._2)\n        numsWithPoints.map(x => x._1)", '        nums.map(x => (x,
    x.toString.toList.map(y => y.asDigit).sum)).sortBy(x => (x._2, x._1)).map(x =>
    x._1)', "        // Fill Up this function body\n        // You can add another\
    \ function as well, if required\n        nums.sortWith((x, y) => (x.toString.map(_.asDigit).sum,\
    \ x) < (y.toString.map(_.asDigit).sum, y))", "        nums.sortWith((a, b) =>\
    \ {\n            val aDigits = a.toString.split(\"\").map(_.toInt).sum\n     \
    \       val bDigits = b.toString.split(\"\").map(_.toInt).sum\n            if\
    \ (aDigits == bDigits) {\n                nums.indexOf(a) < nums.indexOf(b)\n\
    \            } else {\n                aDigits < bDigits\n            }\n    \
    \    })", "        // TODO\n        val result = ArrayBuffer[Long]()\n       \
    \ if(nums.isEmpty){\n            return result.toList\n        }\n        val\
    \ numsCopy = nums.map{x => abs(x)}\n        val numsSum = numsCopy.map{ x => (x.toString.map{_.asDigit}.sum,\
    \ x)}\n        val numsList = numsSum.sortBy{x => (x._1, x._2)}\n        val minusIndex\
    \ = nums.map{x => x > 0}.zipWithIndex.filter{x => x._1 == false}.map{x => x._2}\n\
    \        val minusNums = minusIndex.map{x => numsList(x)._2}.toList\n        numsList.map{x\
    \ => x._2}.filterNot{x => minusNums.contains(x)}.foreach{x => result += x}\n \
    \       minusNums.foreach{x => result += x}\n        result.toList", "       \
    \ // ???\n        var num_dict = Map[Long, Long]()\n        for (i <- 0 until\
    \ nums.length) {\n            var num = nums(i)\n            var sum = 0l\n  \
    \          while (num != 0) {\n                sum += num % 10\n             \
    \   num /= 10\n            }\n            num_dict += i -> sum\n        }\n  \
    \      var l = num_dict.toList.sortBy(x => (x._2, x._1))\n        var result =\
    \ List[Long]()\n        for (i <- 0 until l.length) {\n            result = nums(l(i)._1.toInt)\
    \ :: result\n        }\n        result", "        def sumDigits(n : Long) : Long\
    \ = {\n            var sum = 0l\n            var i = n\n            while (i !=\
    \ 0) {\n                sum += i % 10\n                i /= 10\n            }\n\
    \            sum\n        }\n        var l = new ArrayBuffer[(Long, Long)]\n \
    \       for (i <- 0 until nums.length) l += ((sumDigits(nums(i)), nums(i)))\n\
    \        var l2 = l.sortWith((x, y) => x._1 < y._1 || (x._1 == y._1 && x._2 <\
    \ y._2))\n        l2.map(_._2).toList", "        def sumOfDigits(n : Long) : Long\
    \ = if (n == 0) 0 else n % 10 + sumOfDigits(n / 10)\n        nums.sortWith((x,\
    \ y) => sumOfDigits(x) < sumOfDigits(y) || (sumOfDigits(x) == sumOfDigits(y) &&\
    \ nums.indexOf(x) < nums.indexOf(y)))", '        nums.zipWithIndex.sortBy(a =>
    (a._1.toString.map(_.asDigit).sum, a._2)).map(_._1)', "        // throw new Exception(\"\
    Not implemented yet\")\n        val compareByDigitSum = (a: Long, b: Long) =>\
    \ {\n            if (a == b) {\n                0\n            } else if (a >\
    \ b) {\n                1\n            } else {\n                -1\n        \
    \    }\n        }\n        val x = nums.zipWithIndex.map(n => (sumDigits(n._1),\
    \ n._2, n._1)).sortWith(compareByDigitSum)\n        x.map(n => n._3)", "     \
    \   def orderByPointsRecursive(nums : List[Long], acc : List[Long]) : List[Long]\
    \ = {\n            if (nums.length == 0) acc\n            else {\n           \
    \     val min = nums.minBy(sumDigits)\n                orderByPointsRecursive(nums.filterNot(x\
    \ => x == min), min :: acc)\n            }\n        }\n        orderByPointsRecursive(nums,\
    \ List[Long]())", "        var out = List[Long]()\n        var points = List[(Long,\
    \ Long)]()\n        for ((e, i) <- nums.zipWithIndex) {\n            var sum :\
    \ Long = 0\n            for (j <- 0 until e.toString.length) {\n             \
    \   sum += e.toString.substring(j, j + 1).toLong\n            }\n            points\
    \ ::= (sum, i)\n        }\n        points = points.sortWith(_._1 < _._1)\n   \
    \     for ((p, i) <- points.zipWithIndex) {\n            out ::= nums(p._2.toInt)\n\
    \        }\n        out.reverse", "        def sumOfDigits(x : Long) : Long =\
    \ {\n            if (x < 0) return sumOfDigits(-x)\n            if (x < 10) return\
    \ x\n            else return x % 10 + sumOfDigits(x / 10)\n        }\n       \
    \ if (nums.length == 0) return nums\n        val numsWithIndex = nums.zipWithIndex\n\
    \        val numsWithDigits = numsWithIndex.map((p) => (p._1, sumOfDigits(p._1)))\n\
    \        val ordered = numsWithDigits.sortWith((p1, p2) => p1._2 < p2._2 || (p1._2\
    \ == p2._2 && p1._1 < p2._1))\n        ordered.map((p) => p._1)", "        def\
    \ sumDigits(n : Long) : Long = {\n            n.toString.map(c => (c - '0').toLong).sum\n\
    \        }\n        (nums zip (nums map (sumDigits _))).sortBy(x => (x._2, x._1)).map(x\
    \ => x._1)", "        val map = new HashMap[Long, List[Long]]()\n        def add(index\
    \ : Long, score : Long) {\n            val list = map.getOrElse(score, List[Long]())\n\
    \            map += (score -> (index :: list))\n        }\n        for (i <- 0\
    \ until nums.length) {\n            var num = nums(i)\n            if (num < 0)\
    \ num = -num\n            var score = 0L\n            while (num > 0) {\n    \
    \            score += num % 10\n                num /= 10\n            }\n   \
    \         add(i, score)\n        }\n        def getMinScore = {\n            var\
    \ score = Long.MaxValue\n            for (s <- map.keys) score = min(score, s)\n\
    \            score\n        }\n        var ret = List[Long]()\n        var index\
    \ = 0\n        while (index < nums.length) {\n            val score = getMinScore\n\
    \            ret = map(score).map(nums(_)) ::: ret\n            map -= score\n\
    \            index += 1\n        }\n        ret", '        nums.zipWithIndex.sortBy
    { x => sumDigits(x._1, 0) }.map(_._1)', "        var lst = new ArrayBuffer[Long]\n\
    \        val sumofNum = new HashMap[Long, Int]\n        for (i <- nums) {\n  \
    \          var sum = 0\n            var tmp = i\n            while (tmp != 0)\
    \ {\n                sum += tmp % 10\n                tmp /= 10\n            }\n\
    \            sumofNum += (i -> sum)\n        }\n        val sorted = sumofNum.toSeq.sortBy(_._2)\n\
    \        for (i <- sorted) lst += i._1\n        lst.toList", "        val m =\
    \ new scala.collection.mutable.HashMap[Long, scala.collection.mutable.ArrayBuffer[Long]]()\n\
    \        for (i <- 0 until nums.length) {\n            val s = nums(i).toString\n\
    \            var sum = 0\n            for (j <- 0 until s.length) sum += (s(j)\
    \ - '0')\n            m.getOrElseUpdate(sum, new scala.collection.mutable.ArrayBuffer[Long])\
    \ += i\n        }\n        val m1 = m.map { case (k, v) => (k, v.sorted) }.toArray.sortBy(e\
    \ => e._1)\n        for (i <- 0 until m1.length) for (j <- 0 until m1(i)._2.length)\
    \ {\n            m1(i)._2(j) = nums(m1(i)._2(j).toInt)\n        }\n        var\
    \ res = new scala.collection.mutable.ArrayBuffer[Long]()\n        for (i <- 0\
    \ until m1.length) res ++= m1(i)._2\n        res.toList", "        def getPoints(x\
    \ : Long) : Int = {\n            var n = x\n            var result = 0\n     \
    \       while (n != 0) {\n                result += n % 10\n                n\
    \ /= 10\n            }\n            result\n        }\n        def comparePoints(x\
    \ : Long, y : Long) : Boolean = {\n            if (getPoints(x) < getPoints(y))\
    \ true\n            else if (getPoints(x) > getPoints(y)) false\n            else\
    \ if (nums.indexOf(x) < nums.indexOf(y)) true\n            else false\n      \
    \  }\n        nums.sortWith(comparePoints)", "        var sortIndex:MutableList[Int]\
    \ = MutableList()\n        var sorted:MutableList[Long] = MutableList()\n    \
    \    var points = new Array[Int](nums.length)\n        for (i <- 0 until nums.length)\
    \ {\n            points(i) = sumDigits(nums(i))\n            sortIndex = sortIndex\
    \ :+ i\n        }\n        quicksort(points, sortIndex, 0, points.length - 1)\n\
    \        for (i <- 0 until nums.length) {\n            sorted = sorted :+ nums(sortIndex(i))\n\
    \        }\n        sorted.toList", "        //val nums = List(1l, 11l, -1l, -11l,\
    \ -12l)\n        def countPoints(n : Long) : Int = {\n            val str = n.toString\n\
    \            var sum = 0\n            for (i <- 0 until str.length) {\n      \
    \          sum += (str(i) - '0')\n            }\n            sum\n        }\n\
    \        val tups = new ArrayBuffer[(Int, Long)]\n        for (i <- 0 until nums.length)\
    \ {\n            tups += ((countPoints(nums(i)), nums(i)))\n        }\n      \
    \  tups.sortWith(_._1 < _._1).map(_._2).toList", "        def sumDigits(num :\
    \ Long) : Long = {\n            var sum = 0l\n            var n = num\n      \
    \      while (n != 0) {\n                sum += n % 10\n                n /= 10\n\
    \            }\n            sum\n        }\n        nums.sortWith((x, y) => sumDigits(x)\
    \ < sumDigits(y))", "        return nums.sortWith( (x, y) => {\n            var\
    \ xs = x.toString.split(\"\").map(_.toInt).sum\n            var ys = y.toString.split(\"\
    \").map(_.toInt).sum\n            if (xs == ys) {\n                x < y\n   \
    \         } else {\n                xs < ys\n            }\n        })", "   \
    \     var list  = new ListBuffer[Long]()\n        if (nums == null || nums.isEmpty)\
    \ {\n            return list.toList\n        }\n        val map = new HashMap[Long,\
    \ Long]()\n        for (i <- 0 until nums.length) {\n            val n = nums(i)\n\
    \            var sum = n.abs\n            while (sum >= 10) {\n              \
    \  var t = sum\n                sum = 0\n                while (t > 0) {\n   \
    \                 sum += t % 10\n                    t /= 10\n               \
    \ }\n            }\n            if (map.contains(sum)) {\n                val\
    \ l = map(sum)\n                list(l.toInt) = min(list(l.toInt), n)\n      \
    \      } else {\n                map += (sum -> list.length)\n               \
    \ list += n\n            }\n        }\n        return list.sorted.toList", " \
    \       // your code here\n        var index: Map[Long, Int] = Map.empty\n   \
    \     for (i <- 0 until nums.length) {\n            index += (nums(i) -> i)\n\
    \        }\n        nums.sortWith((a, b) => {\n            var a1 = a\n      \
    \      var b1 = b\n            if (a < 0) a1 = -a\n            if (b < 0) b1 =\
    \ -b\n            val suma = a1.toString.split(\"\").map(x => x.toInt).sum\n \
    \           val sumb = b1.toString.split(\"\").map(x => x.toInt).sum\n       \
    \     if (suma == sumb) {\n                index(a) < index(b)\n            }\
    \ else {\n                suma < sumb\n            }\n        })", '        nums.zipWithIndex.sortBy(x
    => (x._1.toString.map(_.asDigit).sum, x._2)).map(_._1)', '        nums.sortWith((x,
    y) => x.toString.map(_.asDigit).sum < y.toString.map(_.asDigit).sum)', '      nums.sortWith((a,
    b) => (sumOfDigits(a) < sumOfDigits(b)) || (sumOfDigits(a) == sumOfDigits(b) &&
    nums.indexOf(a) < nums.indexOf(b)))', "        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        nums.sortWith((x,\
    \ y) => (x.toString.map(x => x.asDigit).sum, x) < (y.toString.map(x => x.asDigit).sum,\
    \ y))", "        def sumDigits(n : Long) : Long = {\n            var sum = 0l\n\
    \            var m = n\n            while (m != 0) {\n                sum += m\
    \ % 10\n                m /= 10\n            }\n            sum\n        }\n \
    \       val assocs = nums.map(n => (n, sumDigits(n)))\n        assocs.sortWith((a,\
    \ b) => {\n            if (a._2 != b._2) a._2 < b._2\n            else a._1 <\
    \ b._1\n        }).map(_._1)", "        // Fill up this function body\n      \
    \  // You can add another function as well, if required\n        return List()",
  "      nums.sortWith(\n        (x, y) => (\n          (x.toString.foldLeft(0l)((a,\
    \ b) => a + b.asDigit)) < (y.toString.foldLeft(0l)((a, b) => a + b.asDigit))\n\
    \        )\n      )", '        nums.zipWithIndex.sortBy(x => (x._1.toString.map(_.asDigit).sum,
    x._2)).map(_._1)', '        ???', "        // your solution here\n        Nil",
  "        nums.sortWith({\n            case (x, y) => {\n                val (xSum,\
    \ ySum) = (x.toString.toList.map(c => c.asDigit).sum, y.toString.toList.map(c\
    \ => c.asDigit).sum)\n                if (xSum < ySum) true\n                else\
    \ if (xSum > ySum) false\n                else x < y\n            }\n        })",
  "        // Fill in the implementation here\n        throw new NotImplementedError()",
  "        def t(n : Long) : Int = if (n == 0) 0 else t(n / 10) + n % 10\n       \
    \ val map = new HashMap[Long, Int]\n        nums.foreach(num => map += (num ->\
    \ t(num)))\n        nums.sortWith((x, y) => map(x) < map(y) || (map(x) == map(y)\
    \ && nums.indexOf(x) < nums.indexOf(y)))", "        if (nums.isEmpty) return List[Long]()\n\
    \        def sumDigits(num : Long) : Long = {\n            if (num == 0) return\
    \ 0\n            else return (num % 10) + sumDigits(num / 10)\n        }\n   \
    \     var ans = List[Long]()\n        var map = Map[Long, LinkedList[Long]]()\n\
    \        for (i <- 0 until nums.length) {\n            var sum = sumDigits(nums(i))\n\
    \            if (!map.contains(sum)) map(sum) = LinkedList(nums(i))\n        \
    \    else map(sum) = map(sum) :+ nums(i)\n        }\n        var keys = map.keys.toList.sorted\n\
    \        for (k <- keys) {\n            ans = ans ::: map(k).toList\n        }\n\
    \        return ans", "        // Add your code here\n        nums.sortWith((a,\
    \ b) => a.toString.map(x => x.asDigit).sum < b.toString.map(x => x.asDigit).sum)",
  "        def getPoints(n : Long) : Int = {\n            if (n == 0) 0\n        \
    \    else (n % 10).toInt + getPoints(n / 10)\n        }\n        nums.zipWithIndex.sortBy(x\
    \ => (getPoints(x._1), x._2)).map(_._1)", "        val withSum = nums.map(x =>\
    \ (x, x.toString.map(_.asDigit).sum)).zipWithIndex\n        withSum.sortBy(x =>\
    \ (x._1._2, x._2)).map(_._1._1)", "        nums.sortWith((x, y) => {\n       \
    \     val xSum = sumDigits(x)\n            val ySum = sumDigits(y)\n         \
    \   if (xSum == ySum) {\n                nums.indexOf(x) < nums.indexOf(y)\n \
    \           } else {\n                xSum < ySum\n            }\n        })",
  "        def sumDigits(x : Long) : Long = x.toString.map(y => y.asDigit).sum\n \
    \       nums.zipWithIndex.sortBy(x => (sumDigits(x._1), x._2)).map(x => x._1)",
  "        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n        var ans = nums.zipWithIndex\n        ans = ans.sortWith((a,\
    \ b) => {\n            if(sumDigits(a._1) == sumDigits(b._1))\n              \
    \  a._2 < b._2\n            else\n                sumDigits(a._1) < sumDigits(b._1)\n\
    \        })\n        ans.map(_._1)", "    \tnums.sortWith(sum(abs(_).toString.toList.map(toInt(_)))\
    \ < sum(abs(_).toString.toList.map(toInt(_))))", "        // Fill in the missing\
    \ code below\n        nums.sortWith((a, b) => a.toString.toList.map(_.asDigit).sum\
    \ <= b.toString.toList.map(_.asDigit).sum)", '        // Write your code here',
  '        // Add your code here', "        // Fill in the implementation details\n\
    \        return nums", "        // Implement\n        return List[Long]()", " \
    \       if (nums.isEmpty) List[Long]()\n        else (nums.zipWithIndex.sortWith((x,\
    \ y) => {if (x._1.toString.map(_.asDigit).sum != y._1.toString.map(_.asDigit).sum)\
    \ x._1.toString.map(_.asDigit).sum < y._1.toString.map(_.asDigit).sum else x._2\
    \ < y._2})).map(_._1)", "        val absDict = scala.collection.mutable.Map[Long,\
    \ Int]()\n        val ansDict = scala.collection.mutable.Map[Long, Int]()\n  \
    \      nums.zipWithIndex.foreach(pair => {\n            val (num, index) = pair\n\
    \            val abs = math.abs(num)\n            if (absDict.contains(abs)) {\n\
    \                absDict(abs) += index\n            } else {\n               \
    \ absDict += abs -> index\n            }\n            if (ansDict.contains(abs))\
    \ {\n                ansDict(abs) += num\n            } else {\n             \
    \   ansDict += abs -> num\n            }\n        })\n        //println(absDict)\n\
    \        //println(ansDict)\n        val keys = ansDict.keys.toList.sorted\n \
    \       keys.map(key => ansDict(key))", "\tval List(x1, x2, x3, x4, x5) = nums\n\
    \tval List(x1Points, x2Points, x3Points, x4Points, x5Points) = List(x1, x2, x3,\
    \ x4, x5).map(x => x.toString.map(c => Integer.parseInt(c.toString)).sum)\n\t\
    List(nums(x1Points.indexOf(nums.map(x => x.toString.map(c => Integer.parseInt(c.toString)).sum).min)),\
    \ nums(x2Points.indexOf(nums.map(x => x.toString.map(c => Integer.parseInt(c.toString)).sum).min)),\
    \ nums(x3Points.indexOf(nums.map(x => x.toString.map(c => Integer.parseInt(c.toString)).sum).min)),\
    \ nums(x4Points.indexOf(nums.map(x => x.toString.map(c => Integer.parseInt(c.toString)).sum).min)),\
    \ nums(x5Points.indexOf(nums.map(x => x.toString.map(c => Integer.parseInt(c.toString)).sum).min))).filter(x\
    \ => nums.contains(x))", '        return nums.sortWith(sumDigits(_) < sumDigits(_))',
  '        nums.map(n => (n, toInt(n.toString.toList).sum)).sortBy(x => (x._2, nums.indexOf(x._1))).map(x
    => x._1)', '        nums.sortWith((n1, n2) => sumDigits(n1) < sumDigits(n2))',
  "        return nums.zipWithIndex.sortBy(x => {x._1.toString.map(y => (y - '0').toInt).sum\
    \ + x._2}).map(x => x._1)", "      nums match {\n        case Nil => List()\n\
    \        case head :: tail => {\n          val pair = List(head) zip List(sumDigits(head))\n\
    \          pair ::: orderByPoints(tail)\n        }\n      }", '        nums.zipWithIndex.sortBy(x
    => (sumDigits(x._1), x._2)).map(_._1)', "        var list = ListBuffer[(Long,\
    \ Int)]()\n        for (i <- 0 until nums.length) list += Tuple2(nums(i), i)\n\
    \        list = list.sortWith(func)\n        var result = ListBuffer[Long]()\n\
    \        for (i <- 0 until list.length) result += list(i)._1\n        result.toList",
  "      // write your code here\n      // TODO\n      ???", '        ???', "    \
    \    if (nums.isEmpty) return nums\n        var cmap = new scala.collection.mutable.HashMap[Int,\
    \ List[Long]]\n        for (i <- 0 until nums.length) {\n            var sum =\
    \ 0\n            var n = nums(i)\n            while (n != 0) {\n             \
    \   sum += n % 10\n                n /= 10\n            }\n            if (!cmap.contains(sum))\
    \ cmap += (sum -> List(nums(i)))\n            else cmap(sum) = nums(i) :: cmap(sum)\n\
    \        }\n        var result = List[Long]()\n        for (i <- cmap.keySet.toList.sorted)\
    \ {\n            result = result ::: cmap(i)\n        }\n        result", '        nums.sortWith(abs(sumDigits(_))
    < abs(sumDigits(_)))', "        def f(x : Long) : Long = {\n            val s\
    \ = x.toString.split(\"\")\n            s.tail.foldLeft(0l)((r, i) => r + i.toLong)\n\
    \        }\n        nums.sortWith((x, y) => f(x) < f(y))", '        // fill in
    the code here', "        nums.zipWithIndex.sortBy(x => {\n            var sum\
    \ = 0\n            var n = x._1\n            while (n != 0) {\n              \
    \  sum += n % 10\n                n /= 10\n            }\n            (sum, x._2)\n\
    \        }).map(x => x._1)", "        var map = new HashMap[Int, List[Long]]\n\
    \        for (num <- nums) {\n            val sumOfDigits = num.toString.toList.map(x\
    \ => (x.toInt - 48).toLong).sum\n            if (map.contains(sumOfDigits)) {\n\
    \                map(sumOfDigits) = num :: map(sumOfDigits)\n            } else\
    \ {\n                map(sumOfDigits) = List(num)\n            }\n        }\n\
    \        val keys = map.keys.toList.sorted\n        keys.flatMap(x => map(x))",
  "        val z = nums.zipWithIndex\n        z.sortWith((x, y) => (x._1.toString.map(x\
    \ => x.asDigit).sum, x._2) < (y._1.toString.map(x => x.asDigit).sum, y._2)).map(x\
    \ => x._1)", "        var sol = new ListBuffer[Long]\n        var temp = new ListBuffer[(Long,\
    \ Long)]\n        for (i <- 0 until nums.length) {\n            temp += ((nums(i),\
    \ getSumOfDigits(nums(i))))\n        }\n        var newTemp = temp.sortWith((x,\
    \ y) => x._2 < y._2)\n        for (i <- 0 until newTemp.length) {\n          \
    \  sol += newTemp(i)._1\n        }\n        sol.toList", "        // your code\
    \ here\n        val z = for (i <- nums.indices) yield {\n            var sum =\
    \ 0;\n            var num = nums(i)\n            while (num != 0) {\n        \
    \        sum += num % 10\n                num /= 10\n            }\n         \
    \   (i, sum, nums(i))\n        }\n        z.sortBy(_._2).map(_._3).toList", '        return
    nums.sortWith((x, y) => sumOfDigits(x) < sumOfDigits(y))', "        var results\
    \ = new ArrayBuffer[Long]\n        for (num <- nums) {\n            val sum =\
    \ num.toString.map((c) => c.asDigit).sum\n            results += ((sum, num, nums.indexOf(num)))\n\
    \        }\n        results.sortBy((result) => (result._1, result._3)).map((result)\
    \ => result._2).toList", "        var list = List[(Long, Long)]()\n        for\
    \ (i <- 0 until nums.length) {\n            var sum = 0l\n            var num\
    \ = nums(i)\n            while (num != 0) {\n                sum += num % 10\n\
    \                num /= 10\n            }\n            list = (sum, nums(i)) ::\
    \ list\n        }\n        var result = List[Long]()\n        val sorted = list.sortWith((a,\
    \ b) => {\n            if (a._1 != b._1) a._1 < b._1\n            else a._2 <\
    \ b._2\n        })\n        for (i <- 0 until sorted.length) result = sorted(i)._2\
    \ :: result\n        result", "\t  val points = nums.map(sumOfDigits(_))\n\t \
    \ val numsWithPoints = nums.zip(points)\n\t  numsWithPoints.sortWith((a, b) =>\
    \ a._2 < b._2 || (a._2 == b._2 && a._1 < b._1)).map(_._1)", "        if (nums.isEmpty)\
    \ return nums\n        val b = scala.collection.mutable.Buffer[Long]()\n     \
    \   val s = scala.collection.mutable.Map[Long, ArrayBuffer[Long]]()\n        for\
    \ (i <- 0 until nums.length) {\n            val sum = sumDigits(nums(i))\n   \
    \         if (!s.contains(sum)) s(sum) = new ArrayBuffer[Long]()\n           \
    \ s(sum) += nums(i)\n        }\n        val keys = s.keys.toList.sorted\n    \
    \    for (key <- keys) {\n            b ++= s(key)\n        }\n        b.toList",
  '        nums.zipWithIndex.sortBy(i => sumDigits(i._1)).map(i => i._1)', '        nums.sortWith(compare)',
  "        // Implement this method\n        val a = ArrayBuffer[Long]()\n       \
    \ for (i <- nums) {\n            a += i.toString.split(\"\").map(_.toLong).sum\n\
    \        }\n        val sorted = a.sorted\n        val res = ArrayBuffer[Long]()\n\
    \        for (i <- sorted) {\n            res += nums(a.indexOf(i))\n        }\n\
    \        res.toList", "        // Fill up this function body\n        // You can\
    \ add another function as well, if required\n        var arrays: Array[Array[Long]]\
    \ = Array()\n        nums.foreach { (num) =>\n            var array: Array[Long]\
    \ = Array()\n            array = array :+ num\n            var sum: Long = 0\n\
    \            num.toString.foreach { (c) =>\n                sum += c.toInt - '0'.toInt\n\
    \            }\n            array = array :+ sum\n            arrays = arrays\
    \ :+ array\n        }\n        return arrays.sortWith { (a, b) =>\n          \
    \  if (a(1) == b(1)) a(0) < b(0)\n            else a(1) < b(1)\n        }.map(a\
    \ => a(0))", "      // Fill up this function body\n      // You can add another\
    \ function as well, if required\n      def digitsum(x:Long):Int = {\n        if\
    \ (x < 0) -digitsum(-x)\n        else if (x == 0) 0\n        else (x % 10) + digitsum(x\
    \ / 10)\n      }\n      val sums = nums.map(x => (x, digitsum(x)))\n      val\
    \ indices = nums.zipWithIndex.map(_.swap)\n      val zipped = sums.zip(indices)\n\
    \      zipped.sortBy(x => (x._1._2, x._2)).map(_._1._1)", '        nums.zipWithIndex.sortBy(x
    => (sumDigits(x._1), x._2)).map(_._1)', "        def sumDigits(num : Long) : Long\
    \ = {\n            var sum = 0l\n            var div = num\n            while\
    \ (div != 0) {\n                sum += div % 10\n                div /= 10\n \
    \           }\n            sum\n        }\n        nums.zipWithIndex.sortBy(x\
    \ => (sumDigits(x._1), x._2)).map(_._1)", "      val temp = nums.map { x =>\n\
    \        if (x < 0) (abs(x), x, abs(x).toString.map(_.asDigit).sum)\n        else\
    \ (x, x, x.toString.map(_.asDigit).sum)\n      }.sortBy(_._3)\n      temp.map(_._2)",
  "        val sumDigits = (l : Long) => l.toString.map(_.asDigit).sum\n        nums.zipWithIndex.sortBy({case\
    \ (a, b) => (sumDigits(a), b)}).map(_._1)", "        def addDigits(n : Long) :\
    \ Long = {\n            if (n == 0) 0 else n % 10 + addDigits(n / 10)\n      \
    \  }\n        def compare(a : Long, b : Long) : Boolean = {\n            val sumA\
    \ = addDigits(a)\n            val sumB = addDigits(b)\n            if (sumA ==\
    \ sumB) a < b else sumA < sumB\n        }\n        nums.sortWith(compare)", " \
    \       // your code here\n        return List[Long]()", '        nums.sortWith((a,
    b) => point(a) < point(b) || (point(a) == point(b) && a < b))', "        var map\
    \ = new HashMap[Long, Long]()\n        for (num <- nums) {\n            var sum\
    \ = 0l.toLong\n            var str = num.toString\n            while (!str.isEmpty)\
    \ {\n                sum += str.head.toString.toLong\n                str = str.tail\n\
    \            }\n            if (map.contains(sum)) {\n                map += sum\
    \ -> (map(sum) + num)\n            } else {\n                map += sum -> num\n\
    \            }\n        }\n        return map.toList.sortBy(_._1).map(_._2)",
  "        def f(n : Long) : Long = n.toString.toList.map(x => (x - '0').toLong).sum\n\
    \        nums.sortWith((a, b) => if (f(a) != f(b)) f(a) < f(b) else a < b)", '        nums.sortWith((x,
    y) => getDigitSum(x) < getDigitSum(y))', "        // Additional functions here\n\
    \        def getSum(x : Long) : Long = {\n            def getSum(x : Long, result\
    \ : Long) : Long = {\n                if (x == 0) result\n                else\
    \ getSum(x / 10, result + x % 10)\n            }\n            getSum(x, 0)\n \
    \       }\n        // Iterative solution is preferred.\n        // But if you\
    \ want to solve this problem\n        // using recursion, it's OK\n        //\
    \ Recursive solution here\n        var l = ListBuffer[Long]()\n        var m =\
    \ HashMap[Long, Long]()\n        for (i <- 0 until nums.length) {\n          \
    \  var v = getSum(nums(i))\n            if (m.contains(v)) m(v) = m(v) * -1\n\
    \            else m(v) = i + 1\n        }\n        var keys = m.keys.toList.sorted\n\
    \        for (i <- 0 until keys.length) {\n            var k = keys(i)\n     \
    \       if (m(k) > 0) l += nums(m(k).toInt - 1)\n            else {\n        \
    \        var v = m(k) * -1\n                while (v > 0) {\n                \
    \    l += nums(v.toInt - 1)\n                    v -= 1\n                }\n \
    \           }\n        }\n        l.toList", "        val sortedList = nums.zipWithIndex.sortBy(x\
    \ => \n            x._1.toString.map(digit => digit.asDigit).sum -> x._2\n   \
    \     )\n        sortedList.map(x => x._1)", '        nums.sortWith((x, y) =>
    {val sx = sumDigits(x); val sy = sumDigits(y); sx < sy || (sx == sy && x < y)})',
  "        // write solution here\n        nums.sortWith((x, y) => digitsSum(x) <\
    \ digitsSum(y))", "        //if (nums.isEmpty) return nums\n        //else {\n\
    \            //val numsSorted = nums.sortWith(digsum(_) < digsum(_))\n       \
    \     //numsSorted\n        //}\n        return nums.sortWith(digsum(_) < digsum(_))",
  "        val tmp = new ListBuffer[(Long, Int)]()\n        for (i <- 0 until nums.length)\
    \ {\n            var s = 0\n            for (ch <- nums(i).toString) s += ch.asDigit\n\
    \            tmp += new Tuple2(nums(i), s)\n        }\n        tmp.sortWith(_._2\
    \ < _._2).map(_._1).toList", "        def sum(x : Long) : Long = {\n         \
    \   if (x == 0) 0 else (x % 10) + sum(x / 10)\n        }\n        nums.sortWith((x,\
    \ y) => sum(x) < sum(y) || (sum(x) == sum(y) && nums.indexOf(x) < nums.indexOf(y)))",
  '        nums.zipWithIndex.sortBy(x => digitsSum(x._1)).map(x => x._1)', "\t\tvar\
    \ sortedNums = nums.zipWithIndex.sortBy(pair => (sumOfDigits(pair._1), pair._2))\n\
    \t\tsortedNums.map(pair => pair._1)", '        // Fill-in here', "        nums.sortWith({(x\
    \ : Long, y : Long) =>\n            (x.toString.map(c => c.asDigit).sum, x) <\
    \ (y.toString.map(c => c.asDigit).sum, y)\n        })", "        return nums.sortWith(\n\
    \            (a, b) => (a.toString.toList.map(x => (x.toString.toInt))).sum <\
    \ (b.toString.toList.map(x => (x.toString.toInt))).sum\n        )", "        return\
    \ nums.sortWith((x, y) => \n            sumDigits(x) < sumDigits(y) ||\n     \
    \       (sumDigits(x) == sumDigits(y) && nums.indexOf(x) < nums.indexOf(y)))",
  "        val tuples = nums.map {\n            case x => (x, x.toString.map {\n \
    \               case y => (y.toString.toInt)\n            }.sum)\n        }\n\
    \        tuples.sortBy(_._2).map(_._1)", "        val itemMap = new HashMap[Long,\
    \ Long]\n        nums.zipWithIndex.foreach(n => itemMap += (n._2 -> (n._1.toString.map(_.asDigit).sum)))\n\
    \        nums.zipWithIndex.sortBy(n => (itemMap(n._2), n._2)).map(_._1)", "\t\t\
    nums.sortWith((a, b) => a.toString.map(_.asDigit).sum < b.toString.map(_.asDigit).sum)",
  "        // your code here\n        null", "        var map = new HashMap[Long,\
    \ List[Long]]()\n        for (num <- nums) {\n            var sum : Long = 0\n\
    \            var n = num\n            while (n != 0) {\n                sum +=\
    \ n % 10\n                n /= 10\n            }\n            if (!map.contains(sum))\
    \ {\n                map += (sum -> List[Long]())\n            }\n           \
    \ map(sum) ::= num\n        }\n        var keys = map.keys.toList.sorted\n   \
    \     var result = List[Long]()\n        for (key <- keys) {\n            var\
    \ list = map(key)\n            list = list.sorted\n            for (num <- list)\
    \ {\n                result ::= num\n            }\n        }\n        result.reverse",
  "        var map = new HashMap[Long, Long]\n        def f(n : Long) : Long = if\
    \ (n < 0) -n else n\n        def ds(n : Long) : Long = {\n            if (n <\
    \ 10) n\n            else n % 10 + ds(n / 10)\n        }\n        for (i <- 0\
    \ until nums.length) {\n            var x = f(nums(i))\n            var s = ds(x)\n\
    \            if (map.contains(s)) map(s) = min(map(s), x)\n            else map\
    \ += (s -> x)\n        }\n        var p = List[Long]()\n        for (i <- 0 until\
    \ nums.length) {\n            var x = f(nums(i))\n            var s = ds(x)\n\
    \            if (map(s) == x) {\n                p = nums(i) :: p\n          \
    \      map.remove(s)\n            }\n        }\n        p.reverse", "        def\
    \ sumDigits(num : Long) : Long = {\n            var sum = 0l\n            var\
    \ n = num\n            while (n != 0) {\n                sum += n % 10\n     \
    \           n /= 10\n            }\n            sum\n        }\n        nums.zipWithIndex.sortBy(x\
    \ => (sumDigits(x._1), x._2)).map(_._1)", "        if (nums.isEmpty) {\n     \
    \       return nums\n        }\n        var points = Map[Long, Long]()\n     \
    \   for (num <- nums) {\n            points += (num -> sumDigits(num))\n     \
    \   }\n        var sorted = nums.sortWith(\n            (a, b) => {\n        \
    \        if (points(a) == points(b)) {\n                    a < b\n          \
    \      } else {\n                    points(a) < points(b)\n                }\n\
    \            }\n        )\n        return sorted", "        def points(x : Long)\
    \ : Int = {\n            if (x == 0) 0\n            else abs(x) % 10 + points(x\
    \ / 10)\n        }\n        nums.zipWithIndex.sortBy(x => (points(x._1), x._2)).map(_._1)",
  "    \tnums.sortWith(orderByPointsHelper)", "        def sumOfDigits(num : Long)\
    \ : Long = {\n            var result : Long = 0\n            var num2 : Long =\
    \ abs(num)\n            while (num2 > 0) {\n                result += num2 % 10\n\
    \                num2 /= 10\n            }\n            result\n        }\n  \
    \      nums.zipWithIndex.sortBy(x => (sumOfDigits(x._1), x._2)).map(x => x._1)",
  '        nums.zipWithIndex.sortBy(x => (x._1.toString.map(_.asDigit).sum, x._2)).map(_._1)',
  "        def sumDigits(x : Long) : Long = {\n            def recSumDigits(x : Long,\
    \ acc : Long) : Long = x match {\n                case 0 => acc\n            \
    \    case x => recSumDigits(x / 10, acc + x % 10)\n            }\n           \
    \ recSumDigits(x, 0)\n        }\n        nums.zipWithIndex.sortWith((t1, t2) =>\
    \ t1._1 + sumDigits(t1._1) < t2._1 + sumDigits(t2._1) || (t1._1 + sumDigits(t1._1)\
    \ == t2._1 + sumDigits(t2._1) && t1._2 < t2._2)).map(_._1)", "        def sumDigits(n\
    \ : Long) : Long = {\n        \tn.toString.map(c => c.asDigit).sum\n        }\n\
    \        nums.zipWithIndex.sortBy(e => (sumDigits(e._1), e._2)).map(e => e._1)",
  "        return nums.sortWith({\n            case (x, y) =>\n                val\
    \ (xs, ys) = (x.toString.map(_.asDigit.toLong).sum, y.toString.map(_.asDigit.toLong).sum)\n\
    \                if (xs == ys) x < y else xs < ys\n        })", "        val arr\
    \ = for (i <- 0 until nums.length) yield (i, nums(i))\n        val sorted = arr.sortWith((a,\
    \ b) => digitsSum(a._2) < digitsSum(b._2) || (digitsSum(a._2) == digitsSum(b._2)\
    \ && a._1 < b._1))\n        sorted.map(_._2).toList", "        // your code goes\
    \ here!\n        return List[Long]()", "    \tdef getSumOfDigits(x : Long) : Long\
    \ = {\n    \t\tvar sum = 0l.toLong\n    \t\tvar rem = x\n    \t\twhile (rem !=\
    \ 0) {\n    \t\t\tsum += rem % 10\n    \t\t\trem /= 10\n    \t\t}\n    \t\tsum\n\
    \    \t}\n    \tdef sortDigits(xs : List[Long]) : List[Long] = {\n    \t\tif (xs.length\
    \ <= 1) xs\n    \t\telse {\n    \t\t\tval pivot = xs(xs.length / 2)\n    \t\t\t\
    List.concat(\n    \t\t\t\tsortDigits(xs filter (x => getSumOfDigits(x) < getSumOfDigits(pivot))),\n\
    \    \t\t\t\txs filter (x => getSumOfDigits(x) == getSumOfDigits(pivot)),\n  \
    \  \t\t\t\tsortDigits(xs filter (x => getSumOfDigits(x) > getSumOfDigits(pivot)))\n\
    \    \t\t\t)\n    \t\t}\n    \t}\n    \tsortDigits(nums)", "        for (i <-\
    \ 0 until nums.length - 1)\n            for (j <- i + 1 until nums.length)\n \
    \               if (sumDigits(nums(i)) > sumDigits(nums(j))) {\n             \
    \       val t = nums(i)\n                    nums(i) = nums(j)\n             \
    \       nums(j) = t\n                }\n        nums", "        // TODO: finish\
    \ it\n        return nums", "        if (nums.isEmpty) return nums\n        val\
    \ rnd = new scala.util.Random(0)\n        var result = new ArrayBuffer[Long]()\n\
    \        result ++= nums\n        var l = 0\n        var r = result.length - 1\n\
    \        while (l < r) {\n            var i = l\n            var j = r\n     \
    \       var pivot = result(rnd.nextInt(r - l + 1) + l)\n            while (i <=\
    \ j) {\n                while (score(result(i)) < score(pivot)) i += 1\n     \
    \           while (score(result(j)) > score(pivot)) j -= 1\n                if\
    \ (i <= j) {\n                    val tmp = result(i)\n                    result(i)\
    \ = result(j)\n                    result(j) = tmp\n                    i += 1\n\
    \                    j -= 1\n                }\n            }\n            if\
    \ (j < r) l = i\n            if (i > l) r = j\n        }\n        result.toList",
  '        ???', '        (nums map {x => (x, x.toString.map(_.asDigit).sum)}).sortBy(x
    => (x._2, nums.indexOf(x._1))).map(_._1)', '        nums.map(x => (x, x.toString.map(x
    => x.asDigit).sum)).sortBy(x => (x._2, x._1)).map(x => x._1)', '        nums.zipWithIndex.sortBy(x
    => x._1.toString.map(_.asDigit).sum -> x._2).map(_._1)', '        nums.sortWith((x,
    y) => (x.toString.map(x => x.asDigit).sum, x) < (y.toString.map(x => x.asDigit).sum,
    y))', "        val n = nums.length\n        val ds = nums.zipWithIndex.map(x =>\
    \ (x._1, sumDigits(x._1), x._2)).sortWith(sumDigitsCompare)\n        val res =\
    \ new Array[Long](n)\n        ds.zipWithIndex.foreach(x => res(x._1._3) = x._1._1)\n\
    \        res.toList", "        if (nums.isEmpty) return nums\n        val indices\
    \ = nums.zipWithIndex\n        val s = indices.map {\n            case (x, i)\
    \ => (x, sumOfDigits(x.abs), i)\n        }\n        val t = s.sortWith((a, b)\
    \ => a._2 < b._2 || (a._2 == b._2 && a._3 < b._3))\n        t.map(x => x._1)",
  '        nums.sortWith((x, y) => sumDigits(x) < sumDigits(y))', '        nums.sortWith((x,
    y) => (x.toString.map(_.asDigit).sum, x) < (y.toString.map(_.asDigit).sum, y))',
  '        // Implement the function here', '        nums.map(x => (x, x.toString.map(y
    => y.asDigit).sum)).sortBy(x => (x._2, x._1)).map(x => x._1)', "        val orderedNums\
    \ = for (num <- nums.zipWithIndex) yield (num._1, sumDigits(num._1), num._2)\n\
    \        (orderedNums.sortWith((n1, n2) => {\n            if (n1._2 < n2._2) true\n\
    \            else if (n1._2 > n2._2) false\n            else n1._3 < n2._3\n \
    \       })).map(num => num._1)", '        nums.sortWith((a, b) => sumOfDigits(a)
    < sumOfDigits(b) || (sumOfDigits(a) == sumOfDigits(b) && nums.indexOf(a) < nums.indexOf(b)))',
  '        return nums.sortWith(sumOfDigits(_) < sumOfDigits(_))', "        val elemSum\
    \ = nums.map(n => {\n            var sum = 0\n            var num = n\n      \
    \      while (num != 0) {\n                sum += num % 10\n                num\
    \ /= 10\n            }\n            (n, sum)\n        })\n        elemSum.sortWith((a,\
    \ b) => {\n            if (a._2 == b._2) a._1 < b._1\n            else a._2 <\
    \ b._2\n        }).map(x => x._1)", "        def sumDigits(num : Long) : Long\
    \ = {\n            def aux(sum : Long, n : Long) : Long = if (n == 0) sum else\
    \ aux(sum + n % 10, n / 10)\n            aux(0, num)\n        }\n        nums.zipWithIndex.sortBy(x\
    \ => (sumDigits(x._1), x._2)).map(_._1)", "        val sum = nums.groupBy(sumOfDigits).toList.sortBy(_._1).map(_._2).flatten\n\
    \        return sum", '        nums.sortWith((a, b) => a.toString.map(x => x.asDigit).sum
    < b.toString.map(x => x.asDigit).sum)', "\t\t// Implement your solution here\n\
    \        return nums", "        def sumOfDigits(n : Long) : Long = {\n       \
    \ \tif (n == 0) return 0;\n        \tif (n % 10 < 0) return -n % 10 + sumOfDigits(-n\
    \ / 10);\n        \telse return n % 10 + sumOfDigits(n / 10);\n        }\n   \
    \     var result = new ArrayBuffer[Long]();\n        result ++= nums;\n      \
    \  result.sortWith((a, b) => {if (sumOfDigits(a) < sumOfDigits(b)) true else if\
    \ (sumOfDigits(a) > sumOfDigits(b)) false else a < b});\n        return result.toList;",
  "        //...\n        throw new Exception(\"Not Implemented!\")", "        def\
    \ digits(num : Long) : Long = {\n            if (num < 0) {\n                digits(-num)\n\
    \            } else if (num < 10) {\n                num\n            } else {\n\
    \                (num % 10) + digits(num / 10)\n            }\n        }\n   \
    \     nums.sortWith((a, b) => (digits(a) > digits(b)) || (digits(a) == digits(b)\
    \ && nums.indexOf(a) < nums.indexOf(b)))", "        def sumDigits(num : Long)\
    \ : Long = {\n            var sum = 0l\n            var n = num\n            while\
    \ (n != 0) {\n                sum += n % 10\n                n /= 10\n       \
    \     }\n            sum\n        }\n        nums.map(x => (x, sumDigits(x))).sortWith((a,\
    \ b) => a._2 < b._2 || (a._2 == b._2 && a._1 < b._1)).map(x => x._1)", "     \
    \   // Fill up this function body\n        // You can add another function as\
    \ well, if required\n        val sum = nums.map(x => (x, x.toString.toList.map(_.asDigit).sum)).sortBy(_._2)\n\
    \        sum.map(_._1)", '        nums.sortWith((x, y) => digitSum(x) < digitSum(y))',
  "\t\tval mapping = nums.map(x => (x, String.valueOf(x).foldLeft(0l)((a,b) => a +\
    \ b.asDigit)))\n\t\tprintln(mapping)\n\t\tval sort = mapping.sortWith((a,b) =>\
    \ a._2 < b._2)\n\t\tprintln(sort)\n\t\tsort.map(x => x._1)", "        // Write\
    \ your implementation here\n        nums.sortWith((l1, l2) => (l1.toString.toList.map(_.asDigit).sum.compareTo(l2.toString.toList.map(_.asDigit).sum)\
    \ < 0))", "        // your code here\n        nums.map(x => (x, x.toString.map(_.asDigit).sum)).sortBy(x\
    \ => (x._2, x._1)).map(_._1)", "        nums.sortWith((x, y) => {\n          \
    \  val a = sumOfDigits(x)\n            val b = sumOfDigits(y)\n            if\
    \ (a == b) nums.indexOf(x) < nums.indexOf(y)\n            else a < b\n       \
    \ })", "        def points(n : Long) : Int = {\n            def _points(n : Long,\
    \ acc : Int) : Int = {\n                if (n == 0) acc\n                else\
    \ _points(n / 10, acc + (n % 10).toInt)\n            }\n            _points(n,\
    \ 0)\n        }\n        def order(nums : List[Long], acc : List[Long]) : List[Long]\
    \ = {\n            if (nums.isEmpty) acc\n            else {\n               \
    \ var min = Long.MaxValue\n                var minNum = 0l\n                for\
    \ (i <- 0 until nums.length) {\n                    if (points(nums(i)) < min)\
    \ {\n                        min = points(nums(i))\n                        minNum\
    \ = nums(i)\n                    }\n                }\n                order(nums.filter(_\
    \ != minNum), acc :+ minNum)\n            }\n        }\n        order(nums, List())",
  "        nums.map { x =>\n            val list = x.toString.toList.map(_.asDigit)\n\
    \            (x, list.foldLeft(0)(_ + _))\n        }.sortWith((x, y) => x._2 <\
    \ y._2 || (x._2 == y._2 && x._1 < y._1)).map(_._1)", "        if (nums.length\
    \ == 0) return nums\n        val sumOfDigits = nums.map(x => digitSum(x))\n  \
    \      val sumOfDigitsSorted = sumOfDigits.sorted\n        val numsSorted = nums.map(x\
    \ => (x, digitSum(x))).sorted(new Ordering[(Long, Int)] {\n            def compare(x\
    \ : (Long, Int), y : (Long, Int)) = x._2 - y._2\n        }).map(x => x._1)\n \
    \       // println(sumOfDigitsSorted)\n        // println(numsSorted)\n      \
    \  numsSorted", '        nums.zipWithIndex.map{case (num, index) => (num, index,
    num.toString.map(_.asDigit).sum)}.sortBy(num => (num._3, num._2)).map(_._1)',
  "        val N = nums.length\n        val point = new Array[Int](N)\n        for\
    \ (i <- 0 until N) {\n            var cur = nums(i)\n            while (cur !=\
    \ 0) {\n                point(i) += cur % 10\n                cur /= 10\n    \
    \        }\n        }\n        val sorted = nums.zip(point).sortWith((a, b) =>\
    \ (a._2 != b._2) || (a._1 < b._1))\n        sorted.map(x => x._1)", '        nums.sortWith((x,
    y) => sumDigits(x) < sumDigits(y) || (sumDigits(x) == sumDigits(y) && nums.indexOf(x)
    < nums.indexOf(y)))', '        nums.zipWithIndex.sortBy(e => (e._1.toString.map(_.asDigit).sum,
    e._2)).map(_._1)', "        def points(n : Long) : Int = n.toString.map(_.asDigit).sum\n\
    \        def helper(nums : List[Long], result : List[Long]) : List[Long] = {\n\
    \            nums match {\n                case Nil => result\n              \
    \  case x :: xs => helper(xs, insert(result, x))\n            }\n        }\n \
    \       def insert(nums : List[Long], x : Long) : List[Long] = {\n           \
    \ nums match {\n                case Nil => List(x)\n                case y ::\
    \ ys => if (points(x) < points(y)) x :: nums else y :: insert(ys, x)\n       \
    \     }\n        }\n        helper(nums, List())", '        nums.zipWithIndex.map(x
    => (x._1, getDigitSum(x._1))).sortBy(x => (x._2, x._1)).map(x => x._1)', "   \
    \     // Fill up this function body\n        // You can add another function as\
    \ well, if required\n        var result : List[Long] = List[Long]()\n        //println(calculate_points(nums))\n\
    \        val temp = calculate_points(nums)\n        temp.foreach {\n         \
    \ item =>\n            result = result :+ item._1\n        }\n        result",
  "        val list : List[(Long, Long)] = nums.zipWithIndex.map(x => (x._1, x._1.toString.toList.map(x\
    \ => x.asDigit).sum))\n        list.sortBy(x => (x._2, x._2)).map(x => x._1)",
  '        nums.sortWith((x, y) => sumDigits(x) < sumDigits(y) || (sumDigits(x) ==
    sumDigits(y) && nums.indexOf(x) < nums.indexOf(y)))', "        var res : List[Long]\
    \ = Nil\n        var set : scala.collection.mutable.Map[Int, Long] = scala.collection.mutable.Map()\n\
    \        var index = 0\n        for (num <- nums) {\n            var sum = 0\n\
    \            var x = num\n            if (x < 0) x = -x\n            while (x\
    \ > 0) {\n                sum += x % 10\n                x /= 10\n           \
    \ }\n            set += (sum -> num)\n            index += 1\n        }\n    \
    \    val sorted = set.toSeq.sortBy(x => x._1)\n        for (s <- sorted) {\n \
    \           res = s._2 :: res\n        }\n        res", "        val m = new scala.collection.mutable.HashMap[Long,\
    \ Long]\n        for (i <- 0 until nums.length) m(nums(i)) = sumDigits(nums(i))\n\
    \        nums.sortWith((x : Long, y : Long) => m(x) < m(y) || (m(x) == m(y) &&\
    \ x < y))", '        nums.map(n => (n, sumDigits(n))).sortBy(p => (p._2, p._1)).map(p
    => p._1)', "        val sorted = nums.zipWithIndex.sortBy(x => (digitsSum(x._1),\
    \ x._2))\n        sorted.map(x => x._1)", '        ???', "        def sum(num\
    \ : Long) : Long = {\n            if (num == 0) 0\n            else if (num <\
    \ 0) sum(-num)\n            else num % 10 + sum(num / 10)\n        }\n       \
    \ nums.zipWithIndex.sortBy(n => (sum(n._1), n._2)).map(_._1)", '        nums.zipWithIndex.sortBy(x
    => (sumDigits(x._1), x._2)).map(_._1)', "        val sortedNums = nums.map { x\
    \ => (x, digitSum(x)) }.sortWith { (x, y) => \n            if (x._2 < y._2) true\
    \ else if (x._2 > y._2) false else x._1 < y._1\n        }\n        sortedNums.map\
    \ { x => x._1 }", "        // fill up this function body\n        // you can add\
    \ another function as well, if required\n        def sumDigits(x : Long) : Long\
    \ = {\n            var sum = 0l\n            var n = x\n            while (n !=\
    \ 0) {\n                sum += n % 10\n                n /= 10\n            }\n\
    \            sum\n        }\n        nums.sortWith((x, y) => sumDigits(x) < sumDigits(y))",
  "        var result = new Array[Long](nums.length)\n        var sum = new Array[Long](nums.length)\n\
    \        var index = new Array[Int](nums.length)\n        for (i <- 0 until nums.length)\
    \ {\n            index(i) = i\n            var num = abs(nums(i))\n          \
    \  sum(i) = 0\n            while (num > 0) {\n                sum(i) += num %\
    \ 10\n                num /= 10\n            }\n        }\n        for (i <- 0\
    \ until nums.length) {\n            for (j <- i + 1 until nums.length) {\n   \
    \             if (sum(i) > sum(j) || (sum(i) == sum(j) && index(i) > index(j)))\
    \ {\n                    var tmp = sum(i)\n                    sum(i) = sum(j)\n\
    \                    sum(j) = tmp\n                    tmp = index(i)\n      \
    \              index(i) = index(j)\n                    index(j) = tmp\n     \
    \           }\n            }\n        }\n        for (i <- 0 until nums.length)\
    \ result(i) = nums(index(i))\n        result.toList", '        nums.map(x => (sumDigits(x),
    x)).sortBy(x => (x._1, x._2)).map(x => x._2)', "        val nums_map = nums.zipWithIndex.toMap\n\
    \        val nums_sorted = nums.sortWith((a, b) => \n            sumOfDigits(a)\
    \ < sumOfDigits(b) || \n            (sumOfDigits(a) == sumOfDigits(b) && nums_map(a)\
    \ < nums_map(b)))\n        return nums_sorted", "        def sum(num : Long) :\
    \ Long = {\n            def rec(num : Long, rem : Long) : Long = {\n         \
    \       if (rem == 0) return 0\n                return (rem % 10) + rec(num, rem\
    \ / 10)\n            }\n            return rec(num, num)\n        }\n        val\
    \ indexed = nums.zipWithIndex\n        val sorted = indexed.sortWith((e1, e2)\
    \ => {\n            if (sum(e1._1) == sum(e2._1)) {\n                return e1._2\
    \ < e2._2\n            }\n            return sum(e1._1) < sum(e2._1)\n       \
    \ })\n        return sorted.map(_._1)", "        if (nums.isEmpty) return nums\n\
    \        var minSum = nums.map(sumDigits).min\n        var minNum = nums.find(sumDigits(_)\
    \ == minSum).get\n        return List(minNum) ::: orderByPoints(nums.filter(minNum\
    \ != _))", '        nums.zipWithIndex.sortBy(x => (x._1.toString.map(_.asDigit).sum,
    x._2)).map(_._1)', "        // Put your code here\n        nums.sortWith(sum(_)\
    \ < sum(_))", '        nums.map(f => (f, f.toString.map(d => d.asDigit).sum)).sortBy(f
    => (f._2, f._1)).map(f => f._1)', "        // ADD YOUR CODE HERE\n        return\
    \ nums", "      //print(nums)\n      if (nums.length == 0) return List[Long]()\n\
    \      //print(nums)\n      val nums1 = nums.map(x => x.abs)\n      val map =\
    \ collection.mutable.HashMap[Int, List[Long]]()\n      val maxx = nums1.map(x\
    \ => {\n          val res = x.toString.map(x => x.asDigit).sum\n          map.put(res,\
    \ map.getOrElse(res, List[Long]()) :+ x)\n          res\n      }).max\n      val\
    \ l = 0.to(maxx).toList.flatMap(x => map.getOrElse(x, List[Long]()))\n      val\
    \ l1 = l.zipWithIndex.sortBy(x => x._2).map(x => x._1)\n      val map1 = Map(l1.zip(nums):_*)\n\
    \      l1.map(x => if (nums(l1.indexOf(x)) > 0) map1(x) else -map1(x))", "   \
    \ \tvar pointmap = new HashMap[Long, Int]\n    \tvar i = 0\n    \tfor (num <-\
    \ nums) {\n    \t\tvar point = 0\n    \t\tvar tmp = num\n    \t\tif (tmp < 0)\
    \ tmp = -tmp\n    \t\twhile (tmp > 0) {\n    \t\t\tpoint += tmp % 10\n    \t\t\
    \ttmp /= 10\n    \t\t}\n    \t\tpointmap(num) = point\n    \t\ti += 1\n    \t\
    }\n    \treturn nums.sortWith((a, b) => {\n    \t\tif (pointmap(a) < pointmap(b))\
    \ true\n    \t\telse if (pointmap(a) > pointmap(b)) false\n    \t\telse nums.indexOf(a)\
    \ < nums.indexOf(b)\n    \t})", "        // TODO\n        List()", '        nums.sortWith((a,
    b) => (a % 10 + a / 10 % 10) < (b % 10 + b / 10 % 10))', "      val a = nums.filter(n\
    \ => n < 0).sortWith((a, b) => (a.toString.map(x => abs(x.toInt - 48)).sum - b.toString.map(x\
    \ => abs(x.toInt - 48)).sum) < 0)\n      val b = nums.filter(n => n >= 0).sortWith((a,\
    \ b) => (a.toString.map(x => abs(x.toInt - 48)).sum - b.toString.map(x => abs(x.toInt\
    \ - 48)).sum) < 0)\n      a ::: b", "        var list_long = List[Long]()\n  \
    \      var list_long_sort = nums.sorted\n        for (num <- list_long_sort) {\n\
    \            var sum_digit = 0\n            var num_copy = num\n            if\
    \ (num_copy < 0) {\n                num_copy = num_copy * -1\n            }\n\
    \            while (num_copy != 0) {\n                sum_digit += num_copy %\
    \ 10\n                num_copy = num_copy / 10\n            }\n            list_long\
    \ = sum_digit :: list_long\n        }\n        val list_long_sort_with_index =\
    \ list_long.zipWithIndex\n        val sorted_list_with_index = list_long_sort_with_index.sortBy(_._1)\n\
    \        val sorted_list = sorted_list_with_index.map(i => nums(i._2))\n     \
    \   return sorted_list", '        nums.sortWith((a, b) => (getPoint(a) < getPoint(b)
    || (getPoint(a) == getPoint(b) && nums.indexOf(a) < nums.indexOf(b))))', "   \
    \     def f(n : Long) : Long = {\n            def g(n : Long, s : Long) : Long\
    \ = if (n == 0) s else g(n / 10, s + n % 10)\n            g(n, 0)\n        }\n\
    \        nums.zipWithIndex.sortBy(x => (f(x._1), x._2)).map(_._1)", '        nums.zipWithIndex.map(x
    => (x._1, (x._1 / 10) + (x._1 % 10))).sortBy(x => (x._2, x._1)).map(x => x._1)',
  "        nums.sortWith({(x, y) => {\n            val xsum = x.toString.map(x =>\
    \ x.asDigit).sum\n            val ysum = y.toString.map(x => x.asDigit).sum\n\
    \            (xsum < ysum) || (xsum == ysum && nums.indexOf(x) < nums.indexOf(y))\n\
    \        }})", "        // Fill up this function body\n        // You can add\
    \ another function as well, if required\n        // nums.map(x => (x, x.toString.toCharArray.map(y\
    \ => y.asDigit).sum)).sortBy(x => (x._2, x._1)).map(x => x._1)\n        // def\
    \ foo(lst : List[Long]) : List[(Long, Long)] = {\n        //     if (lst.isEmpty)\
    \ Nil\n        //     else (lst.head, lst.head.toString.toCharArray.map(y => y.asDigit).sum)\
    \ :: foo(lst.tail)\n        // }\n        // foo(nums).sortBy(x => (x._2, x._1)).map(x\
    \ => x._1)\n        def foo(lst : List[Long]) : List[Long] = {\n            if\
    \ (lst.isEmpty) Nil\n            else (lst.head, lst.head.toString.toCharArray.map(y\
    \ => y.asDigit).sum) :: foo(lst.tail)\n        }\n        def bar(lst : List[(Long,\
    \ Long)]) : List[Long] = {\n            if (lst.isEmpty) Nil\n            else\
    \ lst.sortBy(x => (x._2, x._1)).map(x => x._1)\n        }\n        bar(foo(nums))",
  "        var queue = new Queue[Long]()\n        for (n <- nums) {\n            var\
    \ sum = 0\n            var tmp = n\n            while (tmp != 0) {\n         \
    \       sum += (tmp % 10).toInt\n                tmp /= 10\n            }\n  \
    \          var i = 0\n            while (i < queue.length && sum > 0) {\n    \
    \            var tmp = queue(i)\n                var tmpSum = 0\n            \
    \    while (tmp != 0) {\n                    tmpSum += (tmp % 10).toInt\n    \
    \                tmp /= 10\n                }\n                if (tmpSum > sum)\
    \ break else i += 1\n            }\n            queue.insert(i, n)\n        }\n\
    \        queue.toList", "        // replace the body of this function with your\
    \ implementation\n        nums.sortWith(fun)", "        nums.sortWith( (a, b)\
    \ => {\n            val sum1 = sumDigits(a)\n            val sum2 = sumDigits(b)\n\
    \            if (sum1 == sum2) {\n                nums.indexOf(a) < nums.indexOf(b)\n\
    \            } else {\n                sum1 < sum2\n            }\n        })",
  "        val digits = nums.map(x => x.toString.map(y => y.asDigit).sum)\n      \
    \  return nums.zip(digits).sortBy(x => (x._2, nums.indexOf(x._1))).map(x => x._1)"]
stop_tokens:
- "\n    }\n"
