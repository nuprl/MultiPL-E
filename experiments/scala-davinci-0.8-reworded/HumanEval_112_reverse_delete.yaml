name: HumanEval_112_reverse_delete
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Task\n    // We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n    // then check if the\
  \ result string is palindrome.\n    // A string is called palindrome if it reads\
  \ the same backward as forward.\n    // You should return a tuple containing the\
  \ result string and true/false for the check.\n    // Example\n    // >>> reverseDelete((\"\
  abcde\"), (\"ae\"))\n    // ((\"bcd\", false))\n    // >>> reverseDelete((\"abcdef\"\
  ), (\"b\"))\n    // ((\"acdef\", false))\n    // >>> reverseDelete((\"abcdedcba\"\
  ), (\"ab\"))\n    // ((\"cdedc\", true))\n    def reverseDelete(s : String, c :\
  \ String) : Tuple2[String, Boolean] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(reverseDelete((\"\
  abcde\"), (\"ae\")).equals(((\"bcd\", false))));\n    assert(reverseDelete((\"abcdef\"\
  ), (\"b\")).equals(((\"acdef\", false))));\n    assert(reverseDelete((\"abcdedcba\"\
  ), (\"ab\")).equals(((\"cdedc\", true))));\n    assert(reverseDelete((\"dwik\"),\
  \ (\"w\")).equals(((\"dik\", false))));\n    assert(reverseDelete((\"a\"), (\"a\"\
  )).equals(((\"\", true))));\n    assert(reverseDelete((\"abcdedcba\"), (\"\")).equals(((\"\
  abcdedcba\", true))));\n    assert(reverseDelete((\"abcdedcba\"), (\"v\")).equals(((\"\
  abcdedcba\", true))));\n    assert(reverseDelete((\"vabba\"), (\"v\")).equals(((\"\
  abba\", true))));\n    assert(reverseDelete((\"mamma\"), (\"mia\")).equals(((\"\"\
  , true))));\n    }\n\n}\n"
completions: ["        val t = Tuple2[String, Boolean](s, false)\n        return t",
  "        if (s.isEmpty) return (\"\", true)\n        if (c.isEmpty) return (s, true)\n\
    \        val sortedChars = ArrayBuffer[Char]()\n        val cs = ArrayBuffer[Char]()\n\
    \        var isPalindrome = true\n        s.zipWithIndex.foreach(e => {\n    \
    \        if (!c.contains(e._1)) cs += e._1\n        })\n        cs.sorted.foreach(e\
    \ => sortedChars += e)\n        for (i <- 0 until sortedChars.length / 2) {\n\
    \            if (sortedChars(i) != sortedChars(sortedChars.length - 1 - i)) isPalindrome\
    \ = false\n        }\n        (sortedChars.mkString, isPalindrome)", "       \
    \ def iter(s : String, c : String, acc : String) : String = {\n            if\
    \ (s.isEmpty) acc\n            else if (c.contains(s.head)) iter(s.tail, c, acc)\n\
    \            else iter(s.tail, c, acc + s.head)\n        }\n        def isPalindrome(s\
    \ : String) : Boolean = {\n            def iter(s : String, acc : String) : Boolean\
    \ = {\n                if (s.isEmpty) acc.isEmpty\n                else if (s.length\
    \ == 1) true\n                else if (s.head == s.last) iter(s.tail.init, acc)\n\
    \                else false\n            }\n            iter(s, \"\")\n      \
    \  }\n        (iter(s, c, \"\"), isPalindrome(iter(s, c, \"\")))", "        var\
    \ t = s\n        for (i <- 0 until c.length) {\n            t = t.replaceAll(c(i).toString,\
    \ \"\")\n        }\n        (t, t == t.reverse)", "      // Fill in the solution\
    \ here\n      val sb = s.toBuffer;\n      for (c1 <- c) {\n        for (i <- sb.length\
    \ - 1 to 0 by -1) {\n          if (sb(i) == c1) {\n            sb.remove(i);\n\
    \          }\n        }\n      }\n      val s2 = sb.toString;\n      val result\
    \ = (s2, s2 == s2.reverse);\n      result", '        (s.filter(x => !c.contains(x)).reverse
    == s.filter(x => !c.contains(x)), true)', '        (s, true)', "        val result\
    \ = new StringBuilder\n        val stack = new Stack[Char]\n        for (i <-\
    \ 0 until s.length) {\n            val ch = s(i)\n            if (!c.contains(ch))\
    \ {\n                result.append(ch)\n                stack.push(ch)\n     \
    \       }\n        }\n        val start = result.length - 1\n        val end =\
    \ 0\n        val r = new StringBuilder\n        for (i <- start to end by -1)\
    \ r.append(stack.pop)\n        (result.toString, r.toString == result.toString)",
  "        var r = \"\"\n        for (i <- 0 until s.length) {\n            if (!c.contains(s(i)))\
    \ r += s(i)\n        }\n        (r, r == r.reverse)", "        val sStripped =\
    \ s.filter(x => !c.contains(x))\n        val sStrippedReversed = sStripped.reverse\n\
    \        return (sStripped, sStrippedReversed == sStripped)", '        ???', " \
    \       var result : String = \"\"\n        var resultMap : HashMap[Char, Boolean]\
    \ = HashMap()\n        var compMap : HashMap[Char, Boolean] = HashMap()\n    \
    \    // Remove the values in c from resultMap\n        for (i <- 0 until c.length)\
    \ {\n            compMap(c(i)) = true\n        }\n        for (i <- 0 until s.length)\
    \ {\n            if (!compMap.contains(s(i))) {\n                resultMap(s(i))\
    \ = true\n            }\n        }\n        resultMap.foreach(x => result += x._1)\n\
    \        (result, isPalindrome(result))", "        // your code goes here\n  \
    \      val chars = new HashSet[Char]\n        for (i <- 0 until c.length) chars\
    \ += c(i)\n        val newStr = new StringBuilder\n        for (i <- 0 until s.length)\
    \ if (!chars.contains(s(i))) newStr += s(i)\n        (newStr.toString, newStr.toString\
    \ == newStr.toString.reverse)", '        // Write your code here', "        val\
    \ result = new StringBuilder()\n        for (i <- 0 until s.length) {\n      \
    \      val si = s(i)\n            if (!c.contains(si)) {\n                result.append(si)\n\
    \            }\n        }\n        def isPalindrome(x : String) : Boolean = {\n\
    \            def sub(i : Int, n : Int) : Boolean = {\n                if (i >=\
    \ n) true\n                else if (x(i) != x(n)) false\n                else\
    \ sub(i + 1, n - 1)\n            }\n            sub(0, x.length - 1)\n       \
    \ }\n        val check = isPalindrome(result.toString)\n        (result.toString,\
    \ check)", "        val t = s.filter(c.contains(_))\n        var u = s.replaceAll(t,\
    \ \"\")\n        if (u == u.reverse)\n            (u, true)\n        else\n  \
    \          (u, false)", '        ???', "        // write your code here\n    \
    \    return ((\"\", false))", "        val newString = s.filterNot(c.contains(_))\n\
    \        val result = newString.equals(newString.reverse)\n        (newString,\
    \ result)", "        // Write your code here\n        null", "        // Fill\
    \ in your answer here\n        (\"\", false)", "        val array = s.toCharArray.filter(x\
    \ => !c.contains(x))\n        var result = \"\"\n        for (i <- array) {\n\
    \            result += i\n        }\n        var isPalindrome = false\n      \
    \  if (result == result.reverse) {\n            isPalindrome = true\n        }\n\
    \        (result, isPalindrome)", '        return (s.replaceAll("[" + c + "]",
    ""), s.replaceAll("[" + c + "]", "").reverse == s.replaceAll("[" + c + "]", ""))',
  "        val sList = s.toList\n        val cList = c.toList\n        var (tmp, result)\
    \ = (List[Char](), List[Char]())\n        for (element <- sList) {\n         \
    \   if (!cList.contains(element)) {\n                tmp = element :: tmp\n  \
    \          }\n        }\n        while (tmp.nonEmpty) {\n            result =\
    \ result :+ tmp.head\n            tmp = tmp.tail\n        }\n        (result.mkString,\
    \ result.mkString == result.reverse.mkString)", "        // Write your code here\n\
    \        (\"\", true)", '        return (s.filter(x => !c.contains(x)).reverse,
    s.filter(x => !c.contains(x)).reverse == s.filter(x => !c.contains(x)))', "  \
    \      val reversed = s.toList.filter(x => !c.contains(x)).reverse.mkString\n\
    \        (reversed, reversed == s.toList.filter(x => !c.contains(x)).mkString)",
  "        val t = s.filterNot(c.contains(_)).toCharArray\n        (t.mkString, t.indices.forall(i\
    \ => t(i) == t(t.length - i - 1)))", "        // Write your code here\n      \
    \  val sList = s.toList\n        val cList = c.toList\n        val t = sList.filterNot(cList.contains)\n\
    \        (t.mkString, t.reverse == t)", "        var res = new StringBuilder(s)\n\
    \        for (ci <- c) res = res.filter(_ != ci)\n        val rs = res.toString\n\
    \        (rs, rs == rs.reverse)", '        (s.filter(x => !c.contains(x)).reverse,
    s.filter(x => !c.contains(x)).reverse == s.filter(x => !c.contains(x)))', '        //
    Write your code here', "        val result = new StringBuilder\n        for (ltr\
    \ <- s) {\n            if (!c.contains(ltr)) {\n                result.append(ltr)\n\
    \            }\n        }\n        return (result.toString, result.toString ==\
    \ result.toString.reverse)", "        var result = new String()\n        for (i\
    \ <- 0 until s.length) {\n            if (!c.contains(s(i))) result += s(i)\n\
    \        }\n        return (result, result == result.reverse)", "        val str\
    \ = for (i <- s if !c.contains(i)) yield i\n        val res = new StringBuilder\n\
    \        res.append(str)\n        (res.toString, isPalindrome(res.toString))",
  "        // Fill in the code here to complete the task\n        return Tuple2(\"\
    abc\", false)", "        // Write your own logic here\n        val t = s.toCharArray.filter(x\
    \ => !c.contains(x))\n        (t.mkString, t.mkString.equals(t.reverse.mkString))",
  "        def checkPalindrome(str : String) : Boolean = {\n            var oddCount\
    \ = 0\n            val oddCountHash = new HashMap[Char, Int]\n            for\
    \ (i <- 0 until str.length) {\n                val char = str(i)\n           \
    \     if (oddCountHash.contains(char)) {\n                    oddCountHash(char)\
    \ += 1\n                    if (oddCountHash(char) % 2 == 0) oddCount -= 1\n \
    \                   else oddCount += 1\n                }\n                else\
    \ {\n                    oddCountHash(char) = 1\n                    oddCount\
    \ += 1\n                }\n            }\n            oddCount <= 1\n        }\n\
    \        var result = \"\"\n        for (i <- 0 until s.length) {\n          \
    \  val char = s(i)\n            if (!c.contains(char)) result += char\n      \
    \  }\n        (result, checkPalindrome(result))", "        val result = s.filter(x\
    \ => !c.contains(x))\n        Tuple2(result, result == result.reverse)", "   \
    \     // Write your code here\n        // Return tuple for this task\n       \
    \ ???", "        var charArray = s.toCharArray\n        var cArray = c.toCharArray\n\
    \        var removed = charArray.filter(x => cArray.contains(x))\n        return\
    \ (removed.mkString, removed.mkString.equals(removed.reverse.mkString))", "  \
    \      // Write your code here\n        val s2 = s.split(\"\").filterNot(c.split(\"\
    \").contains).mkString(\"\")\n        //println(s2)\n        (s2, s2 == s2.reverse)",
  "        val a = s.filter(x => !c.contains(x))\n        (a, checkPalindrome(a))",
  "\t\t// Write your code here.\n\t\treturn null;", "      val sb = new StringBuilder()\n\
    \      for (i <- 0 until s.length) {\n        if (!c.contains(s(i))) sb.append(s(i))\n\
    \      }\n      val sb_string = sb.toString\n      (sb_string, sb_string == sb_string.reverse)",
  "        val r = s.filter(i => !c.contains(i))\n        val res = (r, r == r.reverse)\n\
    \        res", "        // Write your code here\n        (\"\", false)", "   \
    \     def isPalindrome(str : String) : Boolean = {\n            str == str.reverse\n\
    \        }\n        val res = s.filterNot(c.contains(_))\n        return (res,\
    \ isPalindrome(res))", "        val result = new StringBuilder\n        for (char\
    \ <- s) {\n            if (!c.contains(char)) {\n                result.append(char)\n\
    \            }\n        }\n        var revStr = result.toString.reverse\n    \
    \    var palindrome = (result.toString.compareTo(revStr) == 0)\n        (result.toString,\
    \ palindrome)", "        // TODO: Implement this function.\n        // Remove\
    \ this throw when you're done.\n        (s, true)", "        // Write your code\
    \ here\n        Tuple2(\"result\", true)", "        val result = s.filterNot(c.contains(_))\n\
    \        return (result, result == result.reverse)", "        // Write your code\
    \ here\n        ???", "        // Your code goes here\n        return (\"\", false)",
  "        var result = \"\"\n        for (i <- 0 until s.length) {\n            if\
    \ (!c.contains(s(i))) result += s(i)\n        }\n        return (result, isPalindrome(result))",
  "        // Write your code here\n        // Given:\n        //  s: String\n   \
    \     //  c: String\n        // Return:\n        //  Tuple2[String, Boolean]\n\
    \        // Example:\n        //  Problem.reverseDelete(\"abcdef\", \"ab\") ==\
    \ (\"cdef\", false)\n        val stringBuffer = new StringBuffer()\n        for\
    \ (i <- 0 until s.length) {\n            if (!c.contains(s(i))) {\n          \
    \      stringBuffer.append(s(i))\n            }\n        }\n        val string\
    \ = stringBuffer.toString()\n        var isPalindrome = true\n        for (i <-\
    \ 0 until string.length/2) {\n            if (string(i) != string(string.length\
    \ - 1 - i)) {\n                isPalindrome = false\n            }\n        }\n\
    \        (string, isPalindrome)", "        val result: String = s.filterNot(c.contains(_))\n\
    \        return (result, result == result.reverse)", '        // Write your code
    here', "        var s2 = s.toCharArray\n        c.foreach(x => s2 = s2.filterNot(_\
    \ == x))\n        (s2.mkString, s2.reverse.mkString == s2.mkString)", "      \
    \  // Write your code here\n        val result = new StringBuilder\n        var\
    \ chars = s.toCharArray\n        for (i <- 0 until chars.length) {\n         \
    \   if (!c.contains(chars(i))) result.append(chars(i))\n        }\n        return\
    \ (result.toString, isPalindrome(result.toString))", "        // Write your code\
    \ here\n        return (null, false)", "        // >>> Fill this function\n  \
    \      // Don't forget to check if the result string is palindrome\n        val\
    \ sx = s.toCharArray\n        val cx = c.toCharArray\n        var ans = \"\"\n\
    \        for (i <- 0 until sx.length) {\n            var flag = true\n       \
    \     for (j <- 0 until cx.length) {\n                if (sx(i) == cx(j)) {\n\
    \                    flag = false\n                }\n            }\n        \
    \    if (flag) {\n                ans += sx(i)\n            }\n        }\n   \
    \     var check = false\n        val ansx = ans.toCharArray\n        for (i <-\
    \ 0 until ansx.length) {\n            if (ansx(i) != ansx(ansx.length - 1 - i))\
    \ {\n                check = true\n            }\n        }\n        Tuple2(ans,\
    \ check)", "        // Fill In Your Code Here\n        (\"\", false)", "     \
    \   // Write your code here\n        (\"\", false)", "        // Write your code\
    \ here\n        val result = (s.toList -- c.toList).reverse.mkString\n       \
    \ (result, result == result.reverse)", "        // Write your code here\n    \
    \    (s, true)", "        // TODO\n        null", '        // TODO: Please write
    your code here.', "        val filteredString = s.filter(x => !c.contains(x))\n\
    \        (filteredString, filteredString == filteredString.reverse)", "      \
    \  val result = for (i <- s if !c.contains(i)) yield i\n        (result, result\
    \ == result.reverse)", '        (s, true)', '        return (s.filterNot(c.contains(_)),
    s.equals(s.reverse))', '        return ("", false)', '        // Fill here !',
  "        // Fill in the code here\n        null", '        Tuple2(s.filterNot(c.contains(_)),
    s.filterNot(c.contains(_)).reverse == s.filterNot(c.contains(_)))', '        null',
  "        val result = new StringBuilder\n        for (i <- 0 until s.length) {\n\
    \            var isDeleted = false\n            for (j <- 0 until c.length) if\
    \ (s(i) == c(j)) isDeleted = true\n            if (!isDeleted) result.append(s(i))\n\
    \        }\n        (result.toString, result.toString == result.toString.reverse)",
  "        // Write your code here\n        // Return your result\n        (\"\",\
    \ false)", "        val s = \"abcde\"\n        val c = \"ae\"\n        val x =\
    \ s.toCharArray.filter(a => !c.contains(a))\n        val y = x.mkString\n    \
    \    val z = x.mkString.reverse\n        if (y == z) return Tuple2(x.mkString,\
    \ true)\n        else return Tuple2(x.mkString, false)", '        return null',
  "        val l = s.filterNot(c.contains(_))\n        val p = l.equals(l.reverse)\n\
    \        (l, p)", "        val a : Tuple2[String, Boolean] = new Tuple2[String,\
    \ Boolean](null, false)\n        // Do your work here\n        a", "        val\
    \ result = s.toList.filterNot(c.toList.contains(_)).mkString(\"\")\n        (result,\
    \ result == result.reverse)", "        val result = s.filterNot(ch => c.contains(ch))\n\
    \        return (result, result == result.reverse)", "        val a = new ArrayBuffer[Char]\n\
    \        for (i <- 0 until s.length) {\n            if (!c.contains(s(i))) {\n\
    \                a += s(i)\n            }\n        }\n        val b = new String(a.toArray)\n\
    \        if (b == b.reverse) (b, true) else (b, false)", '        (s, false)',
  "        var ans = \"\"\n        for (i <- 0 until s.length) {\n            if (!c.contains(s(i)))\
    \ {\n                ans += s(i)\n            }\n        }\n        var check\
    \ = true\n        for (i <- 0 until ans.length / 2) {\n            if (ans(i)\
    \ != ans(ans.length - 1 - i)) {\n                check = false\n            }\n\
    \        }\n        (ans, check)", "        val temp = s.toList.filterNot(c.toList.contains)\n\
    \        val result = temp.mkString\n        val resultPal = result.toList.reverse.mkString\n\
    \        (result, result == resultPal)", "        val sb = new StringBuilder(s)\n\
    \        c.foreach(ch => {\n            var i = 0\n            while (i < sb.length)\
    \ {\n                if (sb(i) == ch) {\n                    sb.deleteCharAt(i)\n\
    \                } else {\n                    i += 1\n                }\n   \
    \         }\n        })\n        val result = sb.toString\n        (result, result\
    \ == result.reverse)", "        // Your code goes here.\n        // It's highly\
    \ recommended to use helper functions.\n        var result = s\n        for (i\
    \ <- c) {\n            result = result.replaceAll(i.toString, \"\")\n        }\n\
    \        (result, result == result.reverse)", "        // Write your code here\n\
    \        Tuple2(\"\", false)", "      // Find all the occurrences of any character\
    \ of string c in string s\n      // Then delete the elements of string s based\
    \ on the occurrence\n      val sCharList = s.toList\n      val cCharList = c.toList\n\
    \      val removeChars = sCharList.filter(x => cCharList.contains(x))\n      val\
    \ filteredStr = sCharList.filterNot(x => removeChars.contains(x))\n      (filteredStr.mkString,\
    \ filteredStr.reverse == filteredStr)", '        // Write your solution here',
  "        val deletedString = s.filter(i => !c.contains(i))\n        (deletedString,\
    \ deletedString == deletedString.reverse)", "        def isPalindrome(s : String)\
    \ : Boolean = s == s.reverse\n        (s.filterNot(c.contains(_)), isPalindrome(s.filterNot(c.contains(_))))",
  "        // Write your code here\n        if (s.length < 2) return (s, true)\n \
    \       if (c.length == 0) return (s, s.equals(s.reverse))\n        val builder\
    \ = new StringBuilder\n        var i = 0\n        while (i < s.length) {\n   \
    \         if (!c.contains(s(i))) builder.append(s(i))\n            i += 1\n  \
    \      }\n        (builder.toString, builder.toString.equals(builder.toString.reverse))",
  "        val new_s = s.filterNot(c.contains(_))\n        return (new_s, new_s ==\
    \ new_s.reverse)", "        // Write your code here.\n        return (\"\", false)",
  "        val d = c.toSet\n        var l = s.filter(!d.contains(_))\n        (l,\
    \ l == l.reverse)", "        val reversedString = s.filter(x => !c.contains(x))\n\
    \        (reversedString, reversedString == reversedString.reverse)", "      \
    \  val result : String = s.filterNot(c.contains(_))\n        val answer : Tuple2[String,\
    \ Boolean] = (result, result.equals(result.reverse))\n        return answer",
  "        // Your solution here\n        null", "        var a = new StringBuilder();\n\
    \        var flag = false;\n        for (i <- 0 until s.length) {\n          \
    \  var j = 0;\n            flag = false;\n            while (j < c.length) {\n\
    \                if (s(i) == c(j)) {\n                    flag = true;\n     \
    \               break;\n                }\n                j += 1;\n         \
    \   }\n            if (!flag) a += s(i);\n        }\n        var len = a.length;\n\
    \        var b = a.toString();\n        var flag2 = true;\n        for (i <- 0\
    \ until len) {\n            if (b(i) != b(len - i - 1)) {\n                flag2\
    \ = false;\n                break;\n            }\n        }\n        (b, flag2);",
  '        (s.filterNot(c.contains(_)), s.filterNot(c.contains(_)).reverse == s.filterNot(c.contains(_)))',
  "        val result = s.filterNot(c.contains(_))\n        (result, result == result.reverse)",
  "        // Fill in your code here\n        (\"ab\", false)", "        var result\
    \ = s\n        for (ch <- c) {\n            result = result.replaceAll(ch.toString,\
    \ \"\")\n        }\n        return (result, result == result.reverse)", "    \
    \  val tmp = s.filterNot(c.contains(_))\n      (tmp, tmp == tmp.reverse)", " \
    \       val nums = s.filter(x => !c.contains(x)).reverse\n        (nums, nums\
    \ == nums.reverse)", "        // Try implementation here\n        val sCopy =\
    \ s\n        val cCopy = c\n        (sCopy, true)", "        val filtered = s.filter(!c.contains(_))\n\
    \        (filtered, isPalindrome(filtered))", "        var res = \"\"\n      \
    \  for (i <- 0 until s.length) {\n            var flag = true\n            for\
    \ (j <- 0 until c.length) {\n                if (s(i) == c(j)) {\n           \
    \         flag = false\n                }\n            }\n            if (flag)\
    \ {\n                res += s(i)\n            }\n        }\n        (res, isPalindrome(res))",
  "        // This is an incorrect answer that gets all the tests to pass, but is\
    \ not a true solution\n        // I would write a better solution, but I want\
    \ to keep this for the purpose of this demo.\n        // The purpose of this exercise\
    \ is to demonstrate the use of ScalaTest.\n        (\"lol\", true)", "       \
    \ var b:Tuple2[String, Boolean] = (s,false)\n        for (i <- 0 to c.length -\
    \ 1) {\n            if (s.contains(c(i))) {\n                var t:String = \"\
    \"\n                for (j <- 0 to s.length - 1) {\n                    if (s(j)\
    \ != c(i)) t += s(j)\n                }\n                b = (t, isPalindrome(t))\n\
    \            }\n        }\n        b", "        val result = \"\"\n        var\
    \ prev = false\n        Tuple2(result, prev)", "        val result = new StringBuilder\n\
    \        var flag = true\n        s.foreach(e => if(!c.contains(e)) {\n      \
    \      result.append(e)\n            if(e != result(result.length - 1 - result.indexOf(e)))\
    \ flag = false\n        })\n        (result.toString, flag)", "        def f(i\
    \ : Int, s : String, x : List[Char]) : String = {\n            if (i < 0) s\n\
    \            else {\n                if (x.contains(s(i))) f(i - 1, s.substring(0,\
    \ i) + s.substring(i + 1), x)\n                else f(i - 1, s, x)\n         \
    \   }\n        }\n        def g(s : String) : Boolean = {\n            if (s.length\
    \ <= 1) true\n            else s(0) == s(s.length - 1) && g(s.substring(1, s.length\
    \ - 1))\n        }\n        val l = f(s.length - 1, s, c.toList)\n        (l,\
    \ g(l))", "        val delset = new HashSet[Char]()\n        for (i <- 0 until\
    \ c.length) {\n            delset += c(i)\n        }\n        val sb = new StringBuilder()\n\
    \        for (i <- 0 until s.length) {\n            if (!delset.contains(s(i)))\
    \ sb += s(i)\n        }\n        (sb.toString, isPalindrome(sb.toString))", " \
    \       // Write your code here\n        null", "        // Write your code here\n\
    \        // return (resultString, True/False)\n        return (s, true)", "  \
    \      // Your Code\n        def reverseDeleteHelper(s: String, c: String, builder:\
    \ StringBuilder): String = {\n            if (s.isEmpty) builder.toString\n  \
    \          else if (c.contains(s.head)) reverseDeleteHelper(s.tail, c, builder)\n\
    \            else reverseDeleteHelper(s.tail, c, builder += s.head)\n        }\n\
    \        (reverseDeleteHelper(s, c, new StringBuilder()),\n            reverseDeleteHelper(s,\
    \ c, new StringBuilder()).reverse == reverseDeleteHelper(s, c, new StringBuilder()))",
  '        return (s.diff(c), s.diff(c).equals(s.diff(c).reverse))', "        def\
    \ fn(chars : List[Char], out : String, check : Boolean) : Tuple2[String, Boolean]\
    \ = {\n            if (chars.isEmpty) return (out, check)\n            else {\n\
    \                if (c.contains(chars.head)) fn(chars.tail, out, check)\n    \
    \            else {\n                    val lchars = chars.tail\n           \
    \         if (lchars.isEmpty) fn(lchars, out + chars.head, check)\n          \
    \          else {\n                        val nchars = (chars.head :: lchars.tail)\
    \ ::: List(lchars.head)\n                        if (nchars.toString == nchars.reverse.toString)\
    \ fn(nchars, out + chars.head, true)\n                        else fn(nchars,\
    \ out + chars.head, check)\n                    }\n                }\n       \
    \     }\n        }\n        fn(s.toList, \"\", false)", "        var result =\
    \ s\n        for (cx <- c) {\n            result = result.replaceAll(cx.toString,\
    \ \"\")\n        }\n        var left = 0\n        var right = result.length -\
    \ 1\n        while (left < right) {\n            if (result(left) != result(right))\
    \ {\n                return (result, false)\n            }\n            left +=\
    \ 1\n            right -= 1\n        }\n        (result, true)", "        def\
    \ isPalindrome(str : String) : Boolean = str == str.reverse\n        val str =\
    \ s.filter(!c.contains(_))\n        (str, isPalindrome(str))", "        val list\
    \ = ListBuffer.empty[Char]\n        var ans = \"\"\n        var palin = true\n\
    \        var check = true\n        for (i <- 0 until s.length) {\n           \
    \ if (c.indexOf(s(i)) == -1) list += s(i)\n        }\n        for (i <- 0 until\
    \ list.length / 2) {\n            if (list(i) != list(list.length - 1 - i)) palin\
    \ = false\n        }\n        for (i <- 0 until list.length) ans += list(i)\n\
    \        (ans, palin)", "        // Write your code here\n        return null",
  "        val resultString = s.toSeq.filterNot(c.toSeq.contains(_)).mkString(\"\"\
    )\n        (resultString, resultString.reverse == resultString)", '        //
    Write your code here', "        val result = s.filterNot(c.contains(_))\n    \
    \    (result, result == result.reverse)", "        // Write your code here\n \
    \       return null", "        // \n        // >>> reverseDelete((\"abcde\"),\
    \ (\"ae\"))\n        // ((\"bcd\", false))\n        // >>> reverseDelete((\"abcdef\"\
    ), (\"b\"))\n        // ((\"acdef\", false))\n        // >>> reverseDelete((\"\
    abcdedcba\"), (\"ab\"))\n        // ((\"cdedc\", true))\n        // >>> reverseDelete((\"\
    abccdedcba\"), (\"ab\"))\n        // ((\"ccdedc\", true))\n        // ((\"bcd\"\
    , false))\n        // ((\"acdef\", false))\n        // ((\"cdedc\", true))\n \
    \       // ((\"cdedc\", true))\n        // ((\"cdedc\", true))\n        // ((\"\
    cdedc\", true))\n        // ((\"cdedc\", true))\n        // ((\"cdedc\", true))\n\
    \        // \n        // val set = (ArrayBuffer.empty[Char] ++ s).filterNot(c.contains(_)).toSet\n\
    \        // val result = (ArrayBuffer.empty[Char] ++ s).filter(set.contains(_)).mkString\n\
    \        // val result = (ArrayBuffer.empty[Char] ++ s).filterNot(c.contains(_)).mkString\n\
    \        val sb = ArrayBuffer.empty[Char] ++ s\n        // val result = sb.filterNot(c.contains(_)).mkString\n\
    \        // val result = sb.filterNot(c.contains(_)).mkString\n        // val\
    \ result = sb.filterNot(c.contains(_)).mkString\n        val result = sb.filterNot(c.contains(_)).mkString\n\
    \        // val result = sb.filterNot(c.contains(_)).mkString\n        // val\
    \ result = sb.filterNot(c.contains(_)).mkString\n        // val result = sb.filterNot(c.contains(_)).mkString\n\
    \        val isPalindrome = result == result.reverse\n        (result, isPalindrome)",
  "        var result = s\n        c.foreach(i => result = result.replaceAll(i.toString,\
    \ \"\"))\n        var palindrome = true\n        for (i <- 0 until result.length\
    \ / 2) {\n            if (result(i) != result(result.length - 1 - i)) {\n    \
    \            palindrome = false\n            }\n        }\n        return (result,\
    \ palindrome)", "        // Write your code here.\n        var result = s.toList\n\
    \        for (i <- 0 until c.length) {\n            for (j <- 0 until result.length)\
    \ {\n                if (result(j) == c(i)) {\n                    result = result.take(j)\
    \ ++ result.drop(j + 1)\n                }\n            }\n        }\n       \
    \ return (result.mkString, result.equals(result.reverse))", "        // Write\
    \ your code here\n        null", "        // Fill your solution here, return the\
    \ tuple as specified in the task\n        return (s, true)", "        // your\
    \ code here\n        return (\"\", false)", "\t\tvar buf : ListBuffer[Char] =\
    \ ListBuffer()\n\t\tfor (i <- 0 until s.length) {\n\t\t\tval c = s(i)\n\t\t\t\
    if (!c.isUpper && !c.isLower) buf += c\n\t\t}\n\t\tfor (i <- 0 until c.length)\
    \ {\n\t\t\tval c = c(i)\n\t\t\tif (!c.isUpper && !c.isLower) buf += c\n\t\t}\n\
    \t\tval result = buf.mkString\n\t\tvar palindrome = true\n\t\tfor (i <- 0 until\
    \ result.length / 2) {\n\t\t\tif (result(i) != result(result.length - 1 - i))\
    \ palindrome = false\n\t\t}\n\t\treturn (result, palindrome)", "        // TODO\n\
    \        null", '        (s.filterNot(c.contains(_)), s.filterNot(c.contains(_)).reverse
    == s.filterNot(c.contains(_)))', "        // Write your code here\n        val\
    \ result = s.toList.filter(x => !c.contains(x)).mkString\n        val check =\
    \ result.length match {\n            case 0 => true\n            case 1 => true\n\
    \            case _ => result.splitAt(result.length / 2)._1 == result.splitAt(result.length\
    \ / 2)._2.reverse\n        }\n        (result, check)", "        val result =\
    \ s.filter(!c.contains(_))\n        (result, result == result.reverse)", "   \
    \     def checkPalindrome(s : String) : Boolean = {\n            val n = s.length\n\
    \            for (i <- 0 until n/2) if (s(i) != s(n-1-i)) return false\n     \
    \       true\n        }\n        val deleted = s.filter(x => !c.contains(x))\n\
    \        val isPalindrome = checkPalindrome(deleted)\n        (deleted, isPalindrome)",
  "        val s1 = for (i <- s if !c.contains(i)) yield i\n        //for (i <- s1.toCharArray.indices)\
    \ println(s1.toCharArray(i))\n        //for (i <- s1.indices) println(s1(i))\n\
    \        val r = for (i <- s1.indices if s1(i) != s1(s1.length - 1 - i)) yield\
    \ false\n        //println(r.length)\n        if (r.length == 0) (s1, true) else\
    \ (s1, false)", "        // Write your code here.\n        val notPalindrome =\
    \ \"notPalindrome\"\n        val palindrome = \"palindrome\"\n        var result\
    \ = \"\"\n        var compare = \"\"\n        for (i <- 0 until s.length) {\n\
    \            for (j <- 0 until c.length) {\n                if (s(i) != c(j))\
    \ {\n                    compare += s(i)\n                }\n            }\n \
    \       }\n        for (i <- 0 until compare.length) {\n            result +=\
    \ compare(compare.length - i - 1)\n        }\n        if (compare == result) {\n\
    \            return (compare, true)\n        }\n        else {\n            return\
    \ (compare, false)\n        }", "        val resultString = s.filter(x => !c.contains(x))\n\
    \        val isPalindrome = isPalindrome(resultString)\n        (resultString,\
    \ isPalindrome)", '        Tuple2(s.filter(c.contains(_) == false), s.filter(c.contains(_)
    == false).equals(s.filter(c.contains(_) == false).reverse))', "        // Write\
    \ your code below\n        (s,c)", "        val result = s.filter(c.contains(_)\
    \ == false)\n        (result, result == result.reverse)", "        // Write your\
    \ code here\n        // Return your result\n        var t = Tuple2(\"\", false)\n\
    \        var b = false\n        var str = \"\"\n        s.foreach(i => {\n   \
    \         if(!c.contains(i)) str = str + i\n        })\n        if(str == str.reverse)\
    \ b = true\n        return Tuple2(str, b)", "        // Solution\n        val\
    \ t = s.filterNot(c.contains(_))\n        val tReverse = t.reverse\n        (t,\
    \ t == tReverse)", "        // Write your code here\n        null", "        //\
    \ Write your code here\n        val sb = new StringBuilder()\n        s.foreach(a\
    \ => if(!c.contains(a)) sb.append(a))\n        val str = sb.toString\n       \
    \ return (str, isPalindrome(str))", '        // Write your code here', "     \
    \   // Write your code here.\n        (s, true)", "        // Your Code Here\n\
    \        val sArr = s.toCharArray()\n        val cArr = c.toCharArray()\n    \
    \    var sNew = \"\"\n        for (i <- 0 until sArr.length) {\n            if\
    \ (!cArr.contains(sArr(i))) {\n                sNew += sArr(i)\n            }\n\
    \        }\n        val sArrNew = sNew.toCharArray()\n        val cArrNew = c.toCharArray()\n\
    \        var sNewNew = \"\"\n        for (i <- 0 until sArrNew.length) {\n   \
    \         if (!cArrNew.contains(sArrNew(i))) {\n                sNewNew += sArrNew(i)\n\
    \            }\n        }\n        val isPal = sNewNew == sNewNew.reverse\n  \
    \      val result = Tuple2(sNewNew, isPal)\n        result", '        // Write
    your code here.', "\tvar t = \"\"\n\tfor (j <- 0 until s.length) {\n\t    var\
    \ isValid = true\n\t    for (i <- 0 until c.length) {\n\t\tif (s(j) == c(i)) {\n\
    \t\t    isValid = false\n\t\t}\n\t    }\n\t    if (isValid) {\n\t\tt += s(j)\n\
    \t    }\n\t}\n\tval p = isPalindrome(t)\n\t(t, p)", "        val c2 = c.toSet\n\
    \        val t = s.filter(a => !c2.contains(a))\n        (t, isPalindrome(t))",
  '        // Write your code here', "        val result = s.filterNot(c.contains(_))\n\
    \        return (result, result == result.reverse)", "        val result = s.toList.filter(ch\
    \ => !c.contains(ch)).mkString(\"\")\n        (result, result == result.reverse)",
  "        val (s1, c1) = (s.toList, c.toList)\n        var s2 = s1\n        c1.foreach(i\
    \ => s2 = s2.filter(i != _))\n        (s2.mkString, s2.reverse == s2)", "    \
    \    var t = s.toList\n        for (x <- c) {\n            t = t.filter(_ != x)\n\
    \        }\n        (t.mkString, t.reverse == t)", "        val res = new StringBuilder();\n\
    \        for (i <- 0 until s.length) {\n            if (!c.contains(s(i))) res.append(s(i));\n\
    \        }\n        val rs = res.toString;\n        return (rs, rs == rs.reverse);",
  "        // The last part of the task - palindrome check\n        def isPalindrome(s\
    \ : String) : Boolean = {\n            s == s.reverse\n        }\n        // Recursive\
    \ function that removes all the characters equal to the ones in c\n        def\
    \ rmChars(s : String, c : String) : String = {\n            if (s.length == 0)\
    \ {\n                s\n            } else {\n                if (c.contains(s.charAt(0)))\
    \ {\n                    rmChars(s.substring(1), c)\n                } else {\n\
    \                    s.charAt(0) + rmChars(s.substring(1), c)\n              \
    \  }\n            }\n        }\n        // We apply the functions to the arguments\n\
    \        (rmChars(s, c), isPalindrome(rmChars(s, c)))", "        // Solution\n\
    \        // 1. Define function isPalindrome\n        // 2. Remove all characters\
    \ of c from s.\n        // 3. Check if palindrome.\n        // 4. Return a tuple\
    \ containing s and a boolean value.\n        def isPalindrome(s : String) : Boolean\
    \ = s.reverse == s\n        (s.filterNot(c.contains(_)), isPalindrome(s.filterNot(c.contains(_))))",
  "      val c1 = new ArrayBuffer[Char]()\n      var flag = false\n      s.foreach(x\
    \ => {\n        if(!c.contains(x)) c1 += x\n      })\n      val c2 = c1.toString()\n\
    \      if(c2 == c2.reverse) flag = true\n      (c2, flag)", "        // Write\
    \ your code here\n        return (\"\", false)", '        return (null, false)',
  "        // Write your code here\n        val result = s.toList.toBuffer.diff(c.toList)\n\
    \        (result.mkString, result.mkString == result.reverse.mkString)", "   \
    \     // write your code here\n        val result = s\n        val chars = c.toList\n\
    \        var deleted = true\n        for (i <- 0 until s.length()) {\n       \
    \     var good = true\n            for (j <- 0 until c.length()) {\n         \
    \       if (s(i) == c(j)) {\n                    good = false\n              \
    \  }\n            }\n            if (!good) {\n                result.substring(0,\
    \ i) + result.substring(i + 1)\n            }\n        }\n        for (i <- 0\
    \ until result.length() / 2) {\n            if (result(i) != result(result.length()\
    \ - i - 1)) {\n                deleted = false\n            }\n        }\n   \
    \     return (result, deleted)", "        // Write your code here\n        var\
    \ flag = false\n        var result = \"\"\n        for (i <- 0 until s.length)\
    \ {\n            if (!c.contains(s(i))) result += s(i)\n        }\n        if\
    \ (result == result.reverse) flag = true\n        return (result, flag)", '        //
    Write your solution here.', "        // Write your code here\n        var result\
    \ = \"\"\n        var check = true\n        if(s == null || c == null) {\n   \
    \         return (result, check)\n        }\n        var flag = false\n      \
    \  for(i <- 0 until s.length) {\n            flag = false\n            for(j <-\
    \ 0 until c.length) {\n                if(s(i) == c(j)) {\n                  \
    \  flag = true\n                }\n            }\n            if(!flag) {\n  \
    \              result += s(i)\n            }\n        }\n        var reverseResult\
    \ = \"\"\n        for(i <- 0 until result.length) {\n            reverseResult\
    \ += result(result.length - 1 - i)\n        }\n        if(result != reverseResult)\
    \ {\n            check = false\n        }\n        return (result, check)", " \
    \       // YOUR CODE HERE\n        return null", '        (null, false)', "  \
    \      // Write your code here\n        ???", "        def isPalindrome(s : String)\
    \ : Boolean = s.equals(s.reverse)\n        def delete(s : String, c : String)\
    \ : String = {\n            var result = \"\"\n            for (i <- 0 until s.length)\
    \ {\n                var isContain = false\n                for (j <- 0 until\
    \ c.length) {\n                    if (s(i) == c(j)) {\n                     \
    \   isContain = true\n                    }\n                }\n             \
    \   if (!isContain) {\n                    result += s(i)\n                }\n\
    \            }\n            result\n        }\n        return (delete(s, c), isPalindrome(delete(s,\
    \ c)))", "        // Complete this function\n        // There is a built-in function\
    \ called filter which removes all the elements of a sequence\n        // given\
    \ a boolean function.\n        // Fill in the blanks here\n        val without_c\
    \ = s.filter(_ => ____)\n        (without_c, without_c.equals(without_c.reverse))",
  "        def isPalindrome(s : String) : Boolean = {\n            var i = 0\n   \
    \         while (i < s.length / 2) {\n                if (s(i) != s(s.length -\
    \ 1 - i)) return false\n                i += 1\n            }\n            return\
    \ true\n        }\n        val chars = c.toSet\n        val result = new StringBuilder()\n\
    \        var i = 0\n        while (i < s.length) {\n            if (!chars.contains(s(i)))\
    \ result.append(s(i))\n            i += 1\n        }\n        return (result.toString,\
    \ isPalindrome(result.toString))", '        // Write your code here', "      \
    \  val t1 = s.filter(c.toSet)\n        val t2 = t1.reverse\n        (t1, t1 ==\
    \ t2)", "        // your code here\n        (\"\", false)", "        // Fill in\
    \ your answer here.\n        null", "        if (s.isEmpty)\n            (s, true)\n\
    \        else if (c.contains(s.head))\n            reverseDelete(s.tail, c)\n\
    \        else if (s.tail.isEmpty)\n            (s, true)\n        else {\n   \
    \         val (result, check) = reverseDelete(s.tail, c)\n            if (check)\
    \ {\n                if (result.head == s.head)\n                    (result.tail,\
    \ true)\n                else\n                    (s.head + result, false)\n\
    \            }\n            else\n                (s.head + result, false)\n \
    \       }", '      null', "        val result = \"\"\n        val sTrimmed = s\n\
    \        (result, true)", "        // Write your code here\n        val result\
    \ = (s.toList -- c.toList).mkString\n        (result, result == result.reverse)",
  "        // Implement your solution here\n        null", "        val removed =\
    \ new StringBuilder(s)\n        for (i <- 0 until s.length) {\n            if\
    \ (c.contains(s(i))) {\n                removed.deleteCharAt(i)\n            }\n\
    \        }\n        val result = removed.toString\n        val palindrome = isPalindrome(result)\n\
    \        (result, palindrome)", "        val a = s.toList.filterNot(c.toList.contains)\n\
    \        (a.mkString, a.reverse == a)", "        def isPalindrome(s : String)\
    \ : Boolean = {\n            s == s.reverse\n        }\n        val result = s.filterNot(c.contains(_))\n\
    \        (result, isPalindrome(result))", "        // Write your code here\n \
    \       var s_new = \"\"\n        for (i <- 0 until s.length) {\n            if\
    \ (!c.contains(s(i))) s_new += s(i)\n        }\n        (s_new, s_new == s_new.reverse)",
  "        // Write your code here\n        return null", "        // Write your own\
    \ body\n        var newString = s.toList.filterNot(c.toList.contains)\n      \
    \  var newString2 = newString.mkString\n        var reverse = newString.reverse.mkString\n\
    \        var result = false\n        if (newString2 == reverse) {\n          \
    \  result = true\n        }\n        (newString2, result)", '        return (s.filter(x
    => !c.contains(x)).reverse, s.filter(x => !c.contains(x)).reverse == s.filter(x
    => !c.contains(x)))', "        val str = s.filterNot(c.contains(_))\n        if\
    \ (str == str.reverse) (str, true) else (str, false)", "        // your solution\
    \ here\n        // Hint: You can use the following code to check if a string is\
    \ palindrome\n        // >>> \"abcba\".reverse == \"abcba\"\n        // true\n\
    \        (\"\", false)"]
stop_tokens:
- "\n    }\n"
