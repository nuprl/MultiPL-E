name: HumanEval_68_pluck
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // \"Given a list representing a branch of a tree that has non-negative integer\
  \ nodes\n    // your task is to pluck one of the nodes and return it.\n    // The\
  \ plucked node should be the node with the smallest even value.\n    // If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n    // The plucked node should be returned in a list, [ smalest_value,\
  \ its index ],\n    // If there are no even values or the given list is empty, return\
  \ [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n\
  \    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n\
  \    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n  \
  \  // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
  \ 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0\
  \ is the smallest value, but  there are two zeros,\n    // so we will choose the\
  \ first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <=\
  \ nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long])\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
  \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
  \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
  \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
  \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
  \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
  \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
  \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ['        arr.zipWithIndex.filter(p => p._1 % 2 == 0).sortBy(p => (p._1,
    p._2)).headOption.map(p => List(p._1, p._2)).getOrElse(List())', "        val\
    \ length = arr.length\n        if (length == 0) return List()\n        val even\
    \ = for (i <- 0 until length if arr(i) % 2 == 0) yield arr(i)\n        if (even.length\
    \ == 0) return List()\n        val min = even.min\n        return List(min, arr.indexOf(min).toLong)",
  '        return arr.filter(_ % 2 == 0).sortWith(_ < _).headOption.map(a => List(a,
    arr.indexOf(a).toLong)).getOrElse(List())', "      if (arr.isEmpty) return Nil\n\
    \      val evens = arr.filter(_ % 2 == 0)\n      if (evens.isEmpty) return Nil\n\
    \      val minEven = evens.min\n      val res = arr.zipWithIndex.filter(x => x._1\
    \ == minEven)\n      List(res.head._1, res.head._2)", "        val even = arr.filter(_\
    \ % 2 == 0)\n        if (even.length == 0) return List()\n        val min = even.min\n\
    \        val index = arr.indexOf(min)\n        List(min, index)", "        val\
    \ plucked = ListBuffer[Long]()\n        val evens = arr.filter(x => x % 2 == 0)\n\
    \        if (evens.isEmpty) return plucked.toList\n        val smallEven = evens.min\n\
    \        val smallEvenIndex = arr.indexOf(smallEven)\n        plucked += smallEven\n\
    \        plucked += smallEvenIndex\n        plucked.toList", "        val evenNodes\
    \ = arr.filter(_ % 2 == 0)\n        if (evenNodes.isEmpty) List()\n        else\
    \ {\n            val minEvenNode = evenNodes.min\n            val minEvenNodeIndex\
    \ = arr.indexOf(minEvenNode)\n            List(minEvenNode, minEvenNodeIndex)\n\
    \        }", "        if (arr.length == 0) {\n            return List()\n    \
    \    }\n        // TODO: add constraints on arr.\n        var min = Long.MaxValue\n\
    \        var min_i = Long.MaxValue\n        for (i <- 0 until arr.length) {\n\
    \            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n\
    \                min_i = i\n            }\n        }\n        if (min == Long.MaxValue)\
    \ {\n            return List()\n        }\n        return List(min, min_i)", " \
    \       if (arr.length == 0) List[Long]()\n        else {\n            val smallestEven\
    \ = arr.filter(x => x % 2 == 0).min\n            if (smallestEven == Long.MaxValue)\
    \ List[Long]()\n            else {\n                val index = arr.indexOf(smallestEven)\n\
    \                List[Long](smallestEven, index.toLong)\n            }\n     \
    \   }", "        // Write your code here\n        var even = Long.MaxValue\n \
    \       var index = -1\n        for (i <- 0 until arr.length) {\n            if\
    \ (arr(i) % 2 == 0 && arr(i) < even) {\n                even = arr(i)\n      \
    \          index = i\n            }\n        }\n        if (index == -1) Nil\n\
    \        else List(even, index)", "        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        if (evens.length == 0) {\n            return List()\n        }\n\
    \        val minEven = evens.min\n        val minEvenIndex = arr.indexOf(minEven)\n\
    \        return List(minEven, minEvenIndex)", '        return List[Long]()', " \
    \       // Fill up this function body\n        // You have to return a list of\
    \ Long.\n        // For example, if you return list [1, 2], it should be List[Long](1l.toLong,\
    \ 2l.toLong)\n        val res = List[Long]()\n        return res", "        def\
    \ valueFilter(v : Long) : Boolean = {\n            val mod : Long = v % 2\n  \
    \          return (mod == 0)\n        }\n        val evenArr : List[Long] = arr.filter(valueFilter)\n\
    \        val evenArrSize : Int = evenArr.size\n        val sortedEvenArr : List[Long]\
    \ = evenArr.sorted\n        if (evenArrSize == 0) return List[Long]()\n      \
    \  val smallestValue : Long = sortedEvenArr(0)\n        val index : Int = arr.indexOf(smallestValue)\n\
    \        return List[Long](smallestValue, index.toLong)", "        // Recursive:\
    \ O(n) time, O(n) space\n        arr match {\n            case Nil => Nil\n  \
    \          case x :: xs => {\n                val (plucked, newXs) = pluck(xs)\n\
    \                if (plucked.isEmpty) {\n                    if (x % 2 == 0) (List(x,\
    \ 1l), Nil)\n                    else (Nil, x :: newXs)\n                } else\
    \ {\n                    if (x % 2 == 0) {\n                        if (x < plucked(0))\
    \ (List(x, 1l), newXs)\n                        else (List(plucked(0), plucked(1)\
    \ + 1), x :: newXs)\n                    } else (plucked, x :: newXs)\n      \
    \          }\n            }\n        }", "        var even : scala.collection.mutable.ListBuffer[(Long,\
    \ Long)] = ListBuffer()\n        for (i <- 0 until arr.length) {\n           \
    \ if (arr(i) % 2 == 0) {\n                even += Tuple2(arr(i), i)\n        \
    \    }\n        }\n        even = even.sortWith((x, y) => x._1 < y._1)\n     \
    \   if (even.isEmpty) List()\n        else List(even(0)._1, even(0)._2)", "  \
    \      val even = arr.filter(_ % 2 == 0)\n        if (even.length > 0) {\n   \
    \         List(even.min, arr.indexOf(even.min).toLong)\n        } else {\n   \
    \         List()\n        }", "    \tvar evenNodes = List[Long]()\n    \tfor (i\
    \ <- 0 until arr.length) {\n    \t\tif (arr(i) % 2 == 0) evenNodes = evenNodes\
    \ :+ arr(i)\n    \t}\n    \tif (evenNodes.length == 0) return List[Long]()\n \
    \   \tval a = evenNodes.sorted.head\n    \tList[Long](a, arr.indexOf(a).toLong)",
  "        if (arr.isEmpty) return Nil\n        val evenIndices = arr.indices.filter(i\
    \ => arr(i) % 2 == 0)\n        if (evenIndices.isEmpty) return Nil\n        val\
    \ minIndex = evenIndices.min\n        val minValue = arr(minIndex)\n        val\
    \ minIndices = evenIndices.filter(i => arr(i) == minValue)\n        List(minValue,\
    \ minIndices.min)", "        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty)\
    \ return List()\n        val best = evens.min\n        List(best, arr.indexOf(best).toLong)",
  "        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i)\n                minIndex = i\n            }\n   \
    \     }\n        if (minIndex == -1) List[Long]()\n        else List[Long](min,\
    \ minIndex.toLong)", "      val isEven = ((n : Long) => n % 2 == 0)\n      val\
    \ minEven = (arr.filter(isEven)).min\n      val minEvenIndex = (i : Int) => (arr(i)\
    \ == minEven)\n      val isAllOdd = ((arr.size == 0) || (arr.map(isEven)).forall(x\
    \ => !x))\n      if (isAllOdd) List[Long]()\n      else {\n        val r = List(minEven,\
    \ arr.indexWhere(minEvenIndex)).toList\n        r\n      }", "        // Your\
    \ code here\n        return null;", "        var leastEven : Long = Int.MaxValue\n\
    \        var leastEvenIndex : Long = Int.MaxValue\n        for (i <- 0 until arr.length)\
    \ {\n            val n = arr(i)\n            if (n % 2 == 0 && n < leastEven)\
    \ {\n                leastEven = n\n                leastEvenIndex = i\n     \
    \       }\n        }\n        if (leastEven == Int.MaxValue) return List()\n \
    \       return List(leastEven, leastEvenIndex)", "        // Good Luck!\n    \
    \    def add(x : Long, curr : List[Long]) : List[Long] = {\n            if (x\
    \ % 2 == 0) {\n                if (curr.isEmpty) {\n                    List(x,\
    \ 1)\n                } else {\n                    if (x < curr(0)) {\n     \
    \                   List(x, 1)\n                    } else if (x == curr(0)) {\n\
    \                        List(x, curr(1) + 1)\n                    } else {\n\
    \                        curr\n                    }\n                }\n    \
    \        } else {\n                curr\n            }\n        }\n        arr.foldLeft(List[Long]())(add)",
  "        val answer = ArrayBuffer[Long]()\n        var min = Int.MaxValue\n    \
    \    var index = -1\n        var i = 0\n        for (a <- arr) {\n           \
    \ if (a % 2 == 0 && a < min) {\n                min = a.toInt\n              \
    \  index = i\n            }\n            i += 1\n        }\n        if (index\
    \ != -1) {\n            answer += min.toLong\n            answer += index.toLong\n\
    \        }\n        answer.toList", "        var minEven = -1l.toLong\n      \
    \  var idx = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0) {\n                if (minEven == -1l.toLong || arr(i) < minEven)\
    \ {\n                    minEven = arr(i)\n                    idx = i\n     \
    \           }\n            }\n        }\n        if (minEven == -1l.toLong) List()\
    \ else List(minEven, idx)", '      arr.zipWithIndex.foldLeft(List[Long]())((b,
    a) => if (a._1 % 2 == 0 && (b.length == 0 || a._1 < b(0))) List(a._1, a._2) else
    b)', "        if (arr.isEmpty) List()\n        else {\n            var min : Long\
    \ = Long.MaxValue\n            var index : Long = -1\n            for (i <- 0\
    \ until arr.length) {\n                if (arr(i) % 2 == 0 && arr(i) < min) {\n\
    \                    min = arr(i)\n                    index = i\n           \
    \     }\n            }\n            if (index == -1) List()\n            else\
    \ List(min, index)\n        }", "        var smallest = Long.MaxValue\n      \
    \  var index = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ > 0 && arr(i) % 2 == 0 && arr(i) < smallest) {\n                smallest = arr(i)\n\
    \                index = i\n            }\n        }\n        if (index == -1)\
    \ List() else List(smallest, index.toLong)", "        def pluck_helper(list :\
    \ List[Long], evens : List[Long], index : Int) : List[Long] = {\n            if\
    \ (list.isEmpty) {\n                if (evens.isEmpty) return List()\n       \
    \         evens.sortWith(_ < _)\n                return List(evens.head, index\
    \ - evens.length + 1)\n            }\n            if (list.head % 2 == 0) {\n\
    \                pluck_helper(list.tail, evens :+ list.head, index + 1)\n    \
    \        } else {\n                pluck_helper(list.tail, evens, index + 1)\n\
    \            }\n        }\n        pluck_helper(arr, List(), 0)", "        //\
    \ Write your code here\n        List[Long]()", "        var index = 0\n      \
    \  var min = 0l\n        var min_index = -1\n        var found = false\n     \
    \   while(index < arr.length) {\n            if(arr(index) > 0 && arr(index) %\
    \ 2 == 0) {\n                if(!found) {\n                    min = arr(index)\n\
    \                    min_index = index\n                    found = true\n   \
    \             } else {\n                    if(arr(index) < min) {\n         \
    \               min = arr(index)\n                        min_index = index\n\
    \                    }\n                }\n            }\n            index +=\
    \ 1\n        }\n        if(found) List(min, min_index.toLong) else List()", " \
    \       if (arr.length <= 0) return List()\n        val even = arr.filter(_ %\
    \ 2 == 0)\n        if (even.length <= 0) return List()\n        val minEven =\
    \ even.min\n        val minEvenIndex = arr.indexOf(minEven)\n        return List(minEven,\
    \ minEvenIndex)", "        if (arr.isEmpty) return List()\n        var evenMin\
    \ = arr.min\n        var idx = arr.indexOf(evenMin)\n        while (evenMin %\
    \ 2 != 0) {\n            arr(idx) = arr.max\n            evenMin = arr.min\n \
    \           idx = arr.indexOf(evenMin)\n        }\n        return List(evenMin,\
    \ idx)", "    \tval res = arr.zipWithIndex.filter(p => p._1 % 2 == 0).sortBy(p\
    \ => (p._1, p._2)).headOption\n    \tres match {\n    \t\tcase Some(t) => List(t._1,\
    \ t._2)\n    \t\tcase None => List()\n    \t}", "        if (arr.length == 0)\
    \ return List[Long]()\n        var evens = List[Long]()\n        var evenIndices\
    \ = List[Long]()\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0) {\n                evens = evens :+ arr(i)\n                evenIndices\
    \ = evenIndices :+ i\n            }\n        }\n        if (evens.length == 0)\
    \ return List[Long]()\n        var min = evens(0)\n        var minIndex = evenIndices(0)\n\
    \        for (i <- 1 until evens.length) {\n            if (evens(i) < min) {\n\
    \                min = evens(i)\n                minIndex = evenIndices(i)\n \
    \           }\n        }\n        return List[Long](min, minIndex)", "       \
    \ var arr2 = ListBuffer[(Long, Int)]()\n        var res = ListBuffer[Long]()\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0) arr2\
    \ += ((arr(i), i))\n        }\n        if (arr2.length > 0) {\n            val\
    \ min = arr2.sortBy(_._1).head\n            res += min._1\n            res +=\
    \ min._2.toLong\n        }\n        res.toList", "        if (arr.isEmpty)\n \
    \           List[Long]()\n        else {\n            val arr1 = arr.filter(x\
    \ => x % 2 == 0)\n            if (arr1.isEmpty)\n                List[Long]()\n\
    \            else {\n                val arr2 = arr1.sortWith((x, y) => x < y)\n\
    \                val index = arr.indexOf(arr2.head)\n                List[Long](arr2.head,\
    \ index.toLong)\n            }\n        }", "        // Type your solution here\n\
    \        List()", "        var ans = List[Long]()\n        var min = Int.MaxValue\n\
    \        var count = 0\n        for (i <- arr) {\n            if (i % 2 == 0 &&\
    \ i < min) {\n                ans = List[Long](i, count)\n                min\
    \ = i.toInt\n            }\n            count += 1\n        }\n        return\
    \ ans", "        // *** Write your answer within this method. You can make other\
    \ classes and methods as long as this file is submitted\n        // *** as the\
    \ entry point for the application. Do not modify the other files in the project\
    \ or the project settings.\n        var evens = List[Long]()\n        var index\
    \ = 0\n        var i = 0\n        while (i < arr.length) {\n            if (arr(i)\
    \ % 2 == 0) {\n                evens = arr(i) :: evens\n                index\
    \ = i\n            }\n            i += 1\n        }\n        if (evens.length\
    \ == 0) {\n            return List[Long]()\n        }\n        else {\n      \
    \      var min = evens(0)\n            i = 0\n            while (i < evens.length)\
    \ {\n                if (evens(i) < min) {\n                    min = evens(i)\n\
    \                    index = i\n                }\n                i += 1\n  \
    \          }\n            return List[Long](min, index)\n        }", "      //\
    \ your code here\n      val filtered = arr.filter(e => e % 2 == 0)\n      if (filtered.isEmpty)\
    \ return List()\n      val min = filtered.min\n      val index = arr.indexOf(min)\n\
    \      List(min, index)", "      return arr.filter(_ % 2 == 0).sorted.take(1).map(x\
    \ => List(x, arr.indexOf(x))) match {\n        case List() => List[Long]()\n \
    \       case _ => arr.filter(_ % 2 == 0).sorted.take(1).map(x => List(x, arr.indexOf(x))).head\n\
    \      }", "        def pluckHelper(arr : List[Long], index : Int, m : List[Long])\
    \ : List[Long] = {\n            if (arr.isEmpty) return m\n            if (arr.head\
    \ % 2 == 0) {\n                if (m.isEmpty) return pluckHelper(arr.tail, index\
    \ + 1, List(arr.head, index.toLong))\n                if (arr.head < m.head) return\
    \ pluckHelper(arr.tail, index + 1, List(arr.head, index.toLong))\n           \
    \     if (arr.head == m.head) {\n                    if (index < m.tail.head)\
    \ return pluckHelper(arr.tail, index + 1, List(arr.head, index.toLong))\n    \
    \            }\n            }\n            pluckHelper(arr.tail, index + 1, m)\n\
    \        }\n        pluckHelper(arr, 0, List())", "        var evens = new ListBuffer[Long]\n\
    \        for (x <- arr.indices) {\n            val i = arr(x)\n            if\
    \ (i % 2 == 0) evens += i\n        }\n        if (evens.length > 0) {\n      \
    \      val minEven = evens.min\n            val minEvenIdx = arr.indexOf(minEven)\n\
    \            List(minEven, minEvenIdx)\n        } else List()", "        var result\
    \ = List[Long]()\n        var min = 10001l.toLong\n        var index = -1\n  \
    \      for (i <- 0 until arr.length) {\n            if (arr(i) < min && arr(i)\
    \ % 2 == 0) {\n                min = arr(i)\n                index = i\n     \
    \       }\n        }\n        if (index == -1) return result\n        result =\
    \ List(min, index.toLong)\n        return result", "        // Fill up this function\
    \ body\n        // 'pluck' function should return an integer list.\n        //\
    \ 'pluck' accepts 1 argument, arr : List[Long]\n        if (arr.isEmpty) {\n \
    \           return List()\n        }\n        var evenNumbers = ListBuffer[Long]()\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0) {\n\
    \                evenNumbers += arr(i)\n            }\n        }\n        if (evenNumbers.isEmpty)\
    \ {\n            return List()\n        }\n        var min = evenNumbers(0)\n\
    \        var index = 0\n        for (i <- 0 until evenNumbers.length) {\n    \
    \        if (evenNumbers(i) < min) {\n                min = evenNumbers(i)\n \
    \               index = i\n            }\n        }\n        return List(min,\
    \ index)", '      arr.zipWithIndex.filter(e => e._1 % 2 == 0).sortBy(e => (e._1,
    e._2)).headOption.getOrElse(List()).toList', "        if (arr.isEmpty) return\
    \ List[Long]()\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ return List[Long]()\n        val even = evens.min\n        val indices = arr.zipWithIndex.filter(x\
    \ => x._1 == even)\n        val minIdx = indices.minBy(x => x._2)._2\n       \
    \ List[Long](even, minIdx)", "        var res = List[Long]()\n        arr.zipWithIndex.filter(e\
    \ => e._1 % 2 == 0).sortBy(e => e._1).headOption match {\n            case Some(e)\
    \ => res = List(e._1, e._2)\n            case None => res = List()\n        }\n\
    \        res", "        // If there are no even values or the given list is empty,\
    \ return []\n        if (arr.length == 0) return List[Long]()\n        val lst\
    \ = arr.filter(p => p % 2 == 0)\n        // If there are no even values return\
    \ []\n        if (lst.length == 0) return List[Long]()\n        // The plucked\
    \ node should be the node with the smallest even value.\n        val min = lst.min\n\
    \        val index = arr.indexOf(min)\n        // If multiple nodes with the same\
    \ smallest even value are found return the node that has smallest index.\n   \
    \     return List[Long](min, index.toLong)", "        if (arr.length == 0) return\
    \ List[Long]()\n        else {\n            val a = arr.filter(_ % 2 == 0)\n \
    \           if (a.length == 0) return List[Long]()\n            else {\n     \
    \           val min = a.min\n                val index = arr.indexOf(min)\n  \
    \              List[Long](min, index.toLong)\n            }\n        }", "   \
    \     val even = arr.filter(_ % 2 == 0)\n        if (even.isEmpty) List()\n  \
    \      else {\n            val min = even.min\n            val idx = arr.indexOf(min)\n\
    \            List(min, idx)\n        }", "        def isEven(x : Long) : Boolean\
    \ = (x % 2) == 0\n        var foundIndex = -1\n        var foundValue = -1\n \
    \       for (i <- 0 until arr.length) {\n            if (isEven(arr(i))) {\n \
    \               if (foundIndex == -1) {\n                    foundIndex = i\n\
    \                    foundValue = arr(i).toInt\n                } else {\n   \
    \                 if (arr(i) < foundValue) {\n                        foundIndex\
    \ = i\n                        foundValue = arr(i).toInt\n                   \
    \ }\n                }\n            }\n        }\n        if (foundIndex != -1)\
    \ {\n            List(foundValue, foundIndex)\n        } else {\n            List()\n\
    \        }", "        if (arr.isEmpty) return List[Long]()\n        var ans :\
    \ List[Long] = List[Long]()\n        var min : Long = 10000000000000l\n      \
    \  var minIndex : Long = -1\n        for (i <- 0 until arr.length) {\n       \
    \     if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n \
    \               minIndex = i\n            }\n        }\n        if (minIndex ==\
    \ -1) return List[Long]()\n        return List[Long](min, minIndex)", "      \
    \  arr.filter(_ % 2 == 0).sortWith(_ < _).headOption match {\n            case\
    \ Some(x) => List(x, arr.indexOf(x).toLong)\n            case None => List()\n\
    \        }", "        if (arr.isEmpty) return List[Long]()\n        val evenArr\
    \ = arr.filter(x => x % 2 == 0)\n        if (evenArr.isEmpty) return List[Long]()\n\
    \        val minValue = evenArr.min\n        return List[Long](minValue, arr.indexOf(minValue))",
  "        // Since the input array is small, we can afford to iterate over it multiple\
    \ times.\n        // The time complexity is O(n).\n        // The space complexity\
    \ is O(1).\n        var smallestEvenValue : Long = Long.MaxValue\n        var\
    \ indexOfSmallestEvenValue : Long = -1\n        var index : Long = 0\n       \
    \ for (elem <- arr) {\n            if (elem % 2 == 0 && elem < smallestEvenValue)\
    \ {\n                smallestEvenValue = elem\n                indexOfSmallestEvenValue\
    \ = index\n            }\n            index += 1\n        }\n        if (indexOfSmallestEvenValue\
    \ == -1) List[Long]()\n        else List[Long](smallestEvenValue, indexOfSmallestEvenValue)",
  "      if (arr.isEmpty) return List[Long]()\n      val evens = arr.filter((n : Long)\
    \ => (n % 2 == 0))\n      if (evens.isEmpty) return List[Long]()\n      val minEven\
    \ = evens.min\n      val index = arr.indexOf(minEven)\n      return List(minEven,\
    \ index)", "        var result = arr.zipWithIndex.filter(x => x._1 % 2 == 0).sortBy(x\
    \ => x._1).headOption.map(x => List(x._1, x._2.toLong)).getOrElse(List())\n  \
    \      result", "        val ans = new ArrayBuffer[Long]()\n        var min =\
    \ Long.MaxValue\n        var index = -1\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n                min =\
    \ arr(i)\n                index = i\n            }\n        }\n        if (index\
    \ == -1) return ans.toList\n        else {\n            ans += min\n         \
    \   ans += index\n            return ans.toList\n        }", "        val evenIndex\
    \ = new ArrayBuffer[Int]\n        val evenValue = new ArrayBuffer[Long]\n    \
    \    var index = -1\n        for (i <- arr) {\n            index += 1\n      \
    \      if (i % 2 == 0) {\n                evenIndex += index\n               \
    \ evenValue += i\n            }\n        }\n        if (evenIndex.length == 0)\
    \ return Nil\n        val minEvenValue = evenValue.min\n        val minEvenIndex\
    \ = evenIndex(evenValue.indexOf(minEvenValue))\n        List(minEvenValue, minEvenIndex)",
  "        def isEven(n : Long) : Boolean = {\n            return n % 2 == 0\n   \
    \     }\n        val len = arr.length\n        var min = Long.MaxValue\n     \
    \   var pos = -1\n        for (i <- 0 until len) {\n            val n = arr(i)\n\
    \            if (isEven(n) && n < min) {\n                min = n\n          \
    \      pos = i\n            }\n        }\n        if (pos == -1) {\n         \
    \   return List[Long]()\n        }\n        return List[Long](min, pos)", "  \
    \      var min = Long.MaxValue\n        var min_index = -1\n        for (i <-\
    \ 0 until arr.length) {\n            val num = arr(i)\n            if (num !=\
    \ 0 && num % 2 == 0 && num < min) {\n                min = num\n             \
    \   min_index = i\n            }\n        }\n        if (min == Long.MaxValue)\
    \ List()\n        else List(min, min_index)", "        var min = Long.MaxValue\n\
    \        var minIndex = -1\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n  \
    \              minIndex = i\n            }\n        }\n        List(min, minIndex)",
  "        if (arr.isEmpty) return List()\n        val r = new ListBuffer[Long]\n\
    \        for (i <- 0 until arr.length if (arr(i) % 2 == 0)) {\n            if\
    \ (r.isEmpty) r += arr(i)\n            else if (r(0) > arr(i)) r(0) = arr(i)\n\
    \        }\n        if (r.isEmpty) return List()\n        val e = arr.indexOf(r(0))\n\
    \        return List(r(0), e.toLong)", "        val e = arr.find(x => x % 2 ==\
    \ 0)\n        e match {\n            case Some(ev) => {\n                val ei\
    \ = arr.indexOf(ev)\n                List(ev, ei.toLong)\n            }\n    \
    \        case None => List()\n        }", "        var as = arr.filter(_ % 2 ==\
    \ 0)\n        if (as.isEmpty) return List[Long]()\n        var min = arr.zipWithIndex.filter(_._1\
    \ % 2 == 0).minBy(_._1)\n        List(min._1, min._2)", "        val evens = arr.filter(_\
    \ % 2 == 0)\n        if (evens.isEmpty) {\n            List[Long]()\n        }\
    \ else {\n            val minEven = evens.min\n            val index = arr.indexOf(minEven)\n\
    \            List[Long](minEven, index.toLong)\n        }", "        val evenNums\
    \ = arr.filter(_ % 2 == 0)\n        if (evenNums.isEmpty)\n            return\
    \ List()\n        val min = evenNums.min\n        List(min, arr.indexOf(min).toLong)",
  "    \tif (arr.isEmpty) return Nil\n    \tvar minNum = 1e15.toLong\n    \tvar minIndex\
    \ = -1\n    \tfor (i <- 0 until arr.length) {\n    \t\tif (arr(i) % 2 == 0 &&\
    \ arr(i) < minNum) {\n    \t\t\tminNum = arr(i)\n    \t\t\tminIndex = i\n    \t\
    \t}\n    \t}\n    \tif (minIndex == -1) return Nil\n    \tList(minNum, minIndex)",
  "    \tif (arr.length == 0) {\n    \t\tList[Long]()\n    \t} else {\n    \t\tval\
    \ a = arr.filter(_ % 2 == 0)\n    \t\tif (a.length == 0) {\n    \t\t\tList[Long]()\n\
    \    \t\t} else {\n    \t\t\tval min = a.min\n    \t\t\tval index = arr.indexOf(min)\n\
    \    \t\t\tList[Long](min, index.toLong)\n    \t\t}\n    \t}", "      var result\
    \ = List[Long]()\n      var even = List[Long]()\n      for (i <- 0 until arr.length)\
    \ if (arr(i) % 2 == 0) even = arr(i) :: even\n      if (even.length == 0) return\
    \ result\n      else result = List(even.min, arr.indexOf(even.min).toLong)\n \
    \     return result", "        if (arr.isEmpty) {\n            return List()\n\
    \        }\n        var min = arr.filter(n => n % 2 == 0).min\n        if (min\
    \ == Long.MaxValue) {\n            return List()\n        }\n        List(min,\
    \ arr.indexOf(min).toLong)", "        val result = arr.filter(n => n % 2 == 0).toList\n\
    \        val min = result.reduceOption(_ min _)\n        val indices = result.zipWithIndex.filter(_._1\
    \ == min.get).toList\n        indices.map {\n            case (n, i) => List(n,\
    \ i)\n        }.sortBy(n => n(1)).head", '        arr.filter(_ % 2 == 0).sorted.zipWithIndex.map(x
    => (x._1, x._2 + 1)).headOption.getOrElse(List[Long]())', "        var ans : List[Long]\
    \ = List()\n        var min : Long = Long.MaxValue\n        var min_index : Long\
    \ = Long.MaxValue\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                min_index\
    \ = i\n            }\n        }\n        if (min != Long.MaxValue) {\n       \
    \     ans = List(min, min_index)\n        }\n        ans", "        var n = arr.length\n\
    \        var index = n\n        var value = Long.MaxValue\n        for (i <- 0\
    \ until n) {\n            val element = arr(i)\n            if (element != 0 &&\
    \ element % 2 == 0 && element < value) {\n                value = element\n  \
    \              index = i\n            }\n        }\n        if (index != n) List(value,\
    \ index) else List()", "        val evens = arr.filter(_ % 2 == 0)\n        if\
    \ (evens.isEmpty) {\n            List()\n        } else {\n            val min\
    \ = evens.min\n            List(min, arr.indexOf(min).toLong)\n        }", " \
    \       var evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return\
    \ List[Long]()\n        var min = evens.min\n        var idx = arr.indexOf(min)\n\
    \        return List(min, idx)", "        arr.zipWithIndex.filter(t => t._1 %\
    \ 2 == 0).sortBy(t => t._1).headOption match {\n            case Some(t) => List(t._1,\
    \ t._2)\n            case None => List()\n        }", "        arr.filter( _ %\
    \ 2 == 0).sorted.headOption match {\n            case Some(head) => List(head,\
    \ arr.indexOf(head).toLong)\n            case None => List()\n        }", "  \
    \      var ans = List[Long]()\n        if (!arr.exists(_ % 2 == 0)) return ans\n\
    \        ans = ans :+ arr.filter(_ % 2 == 0).min\n        ans = ans :+ arr.indexOf(ans.head)\n\
    \        ans", "        val evens = arr.filter(_ % 2 == 0)\n        if (evens.length\
    \ == 0) return List()\n        else {\n            val min = evens.min\n     \
    \       val index = arr.indexOf(min)\n            return List(min, index.toLong)\n\
    \        }", "        var minEven = Long.MaxValue\n        var minEvenIndex =\
    \ -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0\
    \ && arr(i) < minEven) {\n                minEven = arr(i)\n                minEvenIndex\
    \ = i\n            }\n        }\n        if (minEvenIndex == -1) return List()\n\
    \        return List(minEven, minEvenIndex)", "        if (arr.length == 0) return\
    \ List[Long]()\n        var min = arr(0)\n        var min_index = 0\n        for\
    \ (i <- 1 until arr.length) {\n            val x = arr(i)\n            if (x %\
    \ 2 == 0 && x < min) {\n                min = x\n                min_index = i\n\
    \            }\n        }\n        if (min % 2 == 0) return List(min, min_index)\n\
    \        return List[Long]()", "        val l = arr.zipWithIndex.filter(_._1 %\
    \ 2 == 0).filter(_._1 > 0)\n        if (l.isEmpty) return List.empty\n       \
    \ val m = l.reduce((a, b) => if (a._1 < b._1) a else b)\n        List(m._1, m._2)",
  "        var index = 0\n        var minEven = Long.MaxValue\n        var minEvenIndex\
    \ = -1\n        for (i <- arr) {\n            if (i % 2 == 0 && i < minEven) {\n\
    \                minEven = i\n                minEvenIndex = index\n         \
    \   }\n            index += 1\n        }\n        if (minEvenIndex == -1) return\
    \ List[Long]()\n        return List[Long](minEven, minEvenIndex)", "        val\
    \ evens = arr.zipWithIndex.filter(x => x._1 % 2 == 0)\n        if (evens.length\
    \ == 0) List[Long]()\n        else List(evens.minBy(_._1)._1, evens.minBy(_._1)._2)",
  "        var node : List[Long] = List[Long]()\n        var result : List[Long] =\
    \ List[Long]()\n        var answer : List[Long] = List[Long]()\n        var smalest_value\
    \ : Long = Long.MaxValue\n        if(arr.length > 0) {\n            for(i <- 0\
    \ until arr.length) {\n                node = List[Long](arr(i), i)\n        \
    \        if(arr(i) % 2 == 0 && arr(i) < smalest_value) {\n                   \
    \ smalest_value = arr(i)\n                    result = node\n                }\n\
    \            }\n            if(smalest_value == Long.MaxValue) {\n           \
    \     return answer\n            }\n            else {\n                answer\
    \ = List[Long](result(0), result(1))\n                return answer\n        \
    \    }\n        }\n        else {\n            return answer\n        }", "  \
    \      var result = List[Long]()\n        if (arr.length == 0) {\n           \
    \ return result\n        }\n        val even = arr.filter(_ % 2 == 0)\n      \
    \  if (even.length == 0) {\n            return result\n        }\n        val\
    \ min = even.min\n        result = result :+ min\n        result = result :+ arr.indexOf(min).toLong\n\
    \        return result", '        arr.filter(_ % 2 == 0).zipWithIndex.sortBy(_._1).headOption.map(x
    => List(x._1, x._2.toLong + 1)).getOrElse(List())', "        if (arr.length ==\
    \ 0) return List()\n        var min : Long = Long.MaxValue\n        var index\
    \ : Long = 0\n        var minIndex : Long = 0\n        var hasFound = false\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i)\
    \ < min) {\n                min = arr(i)\n                minIndex = i\n     \
    \           hasFound = true\n            }\n        }\n        if (hasFound) return\
    \ List(min, minIndex)\n        else return List()", "        if (arr.length <\
    \ 1) return List[Long]()\n        if (arr.length == 1) return List[Long](arr(0),\
    \ 0)\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.length < 1)\
    \ return List[Long]()\n        val min = evens.min\n        val idx = arr.indexOf(min)\n\
    \        return List[Long](min, idx)", "    \t\tval even = arr.filter(_ % 2 ==\
    \ 0)\n    \t\tif (even.length > 0) {\n    \t\t\tval min = even.min\n    \t\t\t\
    List(min, arr.indexOf(min).toLong)\n    \t\t} else {\n    \t\t\tList()\n    \t\
    \t}", "        var ret : List[Long] = List()\n        if (arr.length == 0) {\n\
    \            return ret\n        }\n        var evens : List[Long] = List()\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0) {\n\
    \                evens = evens :+ arr(i)\n            }\n        }\n        if\
    \ (evens.length == 0) {\n            return ret\n        }\n        ret = ret\
    \ :+ evens.min\n        ret = ret :+ (arr.indexOf(evens.min) + 1).toLong\n   \
    \     return ret", "        def recurse(list : List[Long], smallest : Option[Long],\
    \ index : Option[Long], counter : Long) : List[Long] = {\n            list match\
    \ {\n                case Nil => List[Long]()\n                case x :: xs =>\
    \ if (x % 2 == 0) {\n                    if (smallest.isEmpty || x < smallest.get)\
    \ recurse(xs, Some(x), Some(counter), counter + 1)\n                    else if\
    \ (x == smallest.get) recurse(xs, Some(x), Some(index.get), counter + 1)\n   \
    \                 else recurse(xs, smallest, index, counter + 1)\n           \
    \     } else recurse(xs, smallest, index, counter + 1)\n            }\n      \
    \  }\n        recurse(arr, None, None, 0)", "        var result = List[Long]()\n\
    \        if (arr.isEmpty) {\n            return result\n        }\n        var\
    \ index = -1\n        var value = -1\n        var map = scala.collection.mutable.Map[Long,\
    \ Long]()\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2\
    \ == 0) {\n                if (index == -1) {\n                    index = i\n\
    \                    value = arr(i).toInt\n                } else {\n        \
    \            if (arr(i) < value) {\n                        index = i\n      \
    \                  value = arr(i).toInt\n                    }\n             \
    \   }\n            }\n        }\n        if (index == -1) {\n            return\
    \ result\n        }\n        result :+= value.toLong\n        result :+= index.toLong\n\
    \        return result", "        arr.zipWithIndex.filter(x => x._1 % 2 == 0).sortBy(x\
    \ => x._1).headOption match {\n            case Some(head) => List(head._1, head._2.toLong)\n\
    \            case None => List()\n        }", "        def rec(i : Int, m : Long,\
    \ index : Int, d : List[Long]) : List[Long] = {\n            if (d.isEmpty) return\
    \ List()\n            if (d.head % 2 == 0 && d.head < m) {\n                return\
    \ List(d.head, i)\n            }\n            rec(i + 1, m, index, d.tail)\n \
    \       }\n        if (arr.isEmpty) return List()\n        rec(0, Long.MaxValue,\
    \ 0, arr)", "        var set = mutable.HashSet[Long]()\n        for (i <- arr)\
    \ {\n            if (i % 2 == 0) set += i\n        }\n        if (set.size ==\
    \ 0) return List[Long]()\n        var min = set.min\n        for (i <- 0 until\
    \ arr.length) {\n            if (arr(i) == min) return List(min, i.toLong)\n \
    \       }\n        List[Long]()", "        var answer = List[Long]()\n       \
    \ if (arr.isEmpty) return answer\n        val as = arr.sorted\n        val filtered_arr\
    \ = as.filter(x => x % 2 == 0)\n        if (filtered_arr.isEmpty) return answer\n\
    \        val filtered_arr2 = filtered_arr.filter(x => x == filtered_arr(0))\n\
    \        answer = List(filtered_arr2(0), arr.indexOf(filtered_arr2(0)).toLong)\n\
    \        return answer", "        var result = List[Long]()\n        if (arr.isEmpty)\
    \ {\n            return result\n        }\n        var smallest = Long.MaxValue\n\
    \        var i = 0\n        var curr = 0\n        while (i < arr.length) {\n \
    \           curr = arr(i).toInt\n            if (curr % 2 == 0 && curr < smallest)\
    \ {\n                smallest = curr\n                result = List(smallest,\
    \ i.toLong)\n            }\n            i += 1\n        }\n        if (result.isEmpty)\
    \ {\n            return result\n        }\n        return result", "        var\
    \ l = arr.toList\n        var i = 0\n        var m = -1\n        var r = List[Long]()\n\
    \        while (i < l.length) {\n            if (l(i) % 2 == 0) {\n          \
    \      if (m == -1 || l(i) < l(m)) m = i\n            }\n            i += 1\n\
    \        }\n        if (m == -1) return r\n        r = l(m) :: m :: r\n      \
    \  r", "      val evens = arr.zipWithIndex.filter { case (x, y) => x % 2 == 0\
    \ }\n      if (evens.isEmpty) return List[Long]()\n      evens.minBy(_._1).productIterator.toList.asInstanceOf[List[Long]]",
  "        var result : List[Long] = List[Long]()\n        var hasEven = false\n \
    \       var minEvenValue = Long.MaxValue\n        var minEvenIndex = Long.MaxValue\n\
    \        for (i <- 0 until arr.length) {\n            val v = arr(i)\n       \
    \     if (v % 2 == 0) {\n                hasEven = true\n                if (v\
    \ < minEvenValue) {\n                    minEvenValue = v\n                  \
    \  minEvenIndex = i\n                }\n            }\n        }\n        if (hasEven)\
    \ {\n            result = List(minEvenValue, minEvenIndex)\n        }\n      \
    \  result", "        if (arr.isEmpty) List()\n        else {\n            val\
    \ evens = arr.filter(_ % 2 == 0)\n            if (evens.isEmpty) List()\n    \
    \        else {\n                val min = evens.min\n                val minIndex\
    \ = arr.indexOf(min)\n                List(min, minIndex)\n            }\n   \
    \     }", "        //Solution 1\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        if (evens.length == 0) return List()\n        val min = evens.min\n \
    \       val index = arr.indexOf(min)\n        List(min, index)\n        //Solution\
    \ 2\n        //arr.zipWithIndex.filter(_._1 % 2 == 0).sortBy(_._1).headOption.map(x\
    \ => List(x._1, x._2)).getOrElse(List())", "        var result : List[Long] =\
    \ Nil\n        var minimum = Long.MaxValue\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) != 0 && arr(i) % 2 == 0 && arr(i) < minimum) {\n \
    \               minimum = arr(i)\n                result = List(minimum, i)\n\
    \            }\n        }\n        return result", "        if (arr.length ==\
    \ 0) return List[Long]()\n        var minEven = -1l.toLong\n        var minIndex\
    \ = -1l.toLong\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0) {\n                if (minEven == -1l.toLong || arr(i) < minEven)\
    \ {\n                    minEven = arr(i)\n                    minIndex = i\n\
    \                }\n            }\n        }\n        if (minEven == -1l.toLong)\
    \ return List[Long]()\n        return List[Long](minEven, minIndex)", "      \
    \  var minval = arr.filter(_ % 2 == 0).min\n        var minidx = arr.zipWithIndex.filter(v\
    \ => v._1 == minval).map(_._2).min\n        return List(minval, minidx)", "  \
    \      arr.zipWithIndex.filter(x => x._1 % 2 == 0).sortBy(x => x._1).headOption\
    \ match {\n            case Some(x) => List(x._1, x._2.toLong)\n            case\
    \ None => List()\n        }", "        val isEven = (n : Long) => n % 2 == 0\n\
    \        val findEven = (arr : List[Long]) => arr.find(isEven)\n        findEven(arr)\
    \ match {\n            case Some(e) => arr.zipWithIndex.find(_._1 == e).get.productIterator.toList.map(a\
    \ => a.asInstanceOf[Long])\n            case None => List()\n        }", "   \
    \     var smallest : Long = 0\n        var smallestIndex : Long = 0\n        var\
    \ hasEven : Boolean = false\n        for (i <- 0 until arr.length) {\n       \
    \     if (i == 0 && arr(i) % 2 == 0) {\n                smallest = arr(i)\n  \
    \              smallestIndex = i\n                hasEven = true\n           \
    \ } else if (arr(i) % 2 == 0 && arr(i) < smallest) {\n                smallest\
    \ = arr(i)\n                smallestIndex = i\n                hasEven = true\n\
    \            }\n        }\n        if (hasEven) List(smallest, smallestIndex)\
    \ else List()", "        // Good Luck!\n        arr.zipWithIndex.filter(_._1 %\
    \ 2 == 0).sortBy(_._1).headOption.map(n => List(n._1, n._2)).getOrElse(List())",
  "        var result = List[Long]()\n        if (arr.length == 0) {\n           \
    \ return result\n        }\n        var minValue = Long.MaxValue\n        var\
    \ resultValue = Long.MaxValue\n        for (i <- 0 until arr.length) {\n     \
    \       if (arr(i) % 2 == 0 && arr(i) < minValue) {\n                minValue\
    \ = arr(i)\n                resultValue = i\n            }\n        }\n      \
    \  if (resultValue != Long.MaxValue) {\n            result = result :+ minValue\n\
    \            result = result :+ resultValue\n        }\n        return result",
  "        var evens = arr.filter(x => x % 2 == 0)\n        if (evens.length == 0)\
    \ {\n            List[Long]()\n        } else {\n            var even = evens.min\n\
    \            var index = arr.indexOf(even)\n            List[Long](even, index)\n\
    \        }", "        val tbl = collection.mutable.HashMap[Long, Long]()\n   \
    \     var min = -1\n        var ans = -1\n        arr.foreach(i => {\n       \
    \     if (i == 0) {\n                if (ans == -1) {\n                    ans\
    \ = 0\n                    min = 0\n                }\n            } else if (i\
    \ % 2 == 0) {\n                if (ans == -1) {\n                    ans = i\n\
    \                    min = i\n                } else if (i < min) {\n        \
    \            ans = i\n                    min = i\n                }\n       \
    \     }\n        })\n        if (ans == -1) List() else List(ans, min)", "   \
    \     val hash = new HashMap[Long, Int]()\n        var min = Long.MaxValue\n \
    \       var minIndex = Int.MaxValue\n        for (i <- 0 until arr.length) {\n\
    \            if (arr(i) != 0 && arr(i) % 2 == 0) {\n                if (hash.contains(arr(i)))\
    \ {\n                    hash(arr(i)) = min(hash(arr(i)), i)\n               \
    \ } else {\n                    hash(arr(i)) = i\n                }\n        \
    \        if (arr(i) < min) {\n                    min = arr(i)\n             \
    \       minIndex = i\n                }\n            }\n        }\n        if\
    \ (hash.size == 0) {\n            return List()\n        }\n        return List(min,\
    \ hash(min).toLong)", "        // Write your code here\n        val ret = ListBuffer[Long]()\n\
    \        var m = -1\n        var i = -1\n        var ind = -1\n        arr.foreach(x\
    \ => {\n            if (x % 2 == 0) {\n                if (m == -1 || x < m) {\n\
    \                    m = x.toInt\n                    ind = i\n              \
    \  }\n            }\n            i += 1\n        })\n        if (m != -1) {\n\
    \            ret += m\n            ret += ind\n        }\n        ret.toList",
  "        if (arr.length == 0) return List[Long]()\n        var minEvenIndex = -1\n\
    \        var minEvenValue = Int.MaxValue\n        for (i <- 0 until arr.length)\
    \ {\n            val value = arr(i).toInt\n            if (value % 2 == 0 && value\
    \ < minEvenValue) {\n                minEvenIndex = i\n                minEvenValue\
    \ = value\n            }\n        }\n        if (minEvenIndex == -1) return List[Long]()\n\
    \        return List[Long](minEvenValue, minEvenIndex)", "        val evens =\
    \ arr.filter(v => v % 2 == 0)\n        if (evens.isEmpty) List()\n        else\
    \ {\n            val min = evens.min\n            val minIndex = arr.indexOf(min)\n\
    \            List(min, minIndex)\n        }", "        var evenList = arr.filter(x\
    \ => x % 2 == 0)\n        if (evenList.isEmpty) return List()\n        var minEven\
    \ = evenList.min\n        return List(minEven, arr.indexOf(minEven).toLong)",
  "      val a = arr.zipWithIndex.filter(_._1 % 2 == 0).sortBy(_._1)\n      if (a.isEmpty)\
    \ List() else a.head.toList", "        // Write your code here\n        null",
  '        arr.zipWithIndex.filter(x => x._1 % 2 == 0).sortBy(x => x._1).sortBy(x
    => x._2).headOption.map(x => List(x._1, x._2.toLong)).getOrElse(List())', "  \
    \      if (arr.filter(x => x % 2 == 0).size == 0) {\n            List()\n    \
    \    } else {\n            var index = 0\n            var result = 0l\n      \
    \      for (x <- arr) {\n                if (x % 2 == 0) {\n                 \
    \   if (result == 0) {\n                        result = x\n                 \
    \   } else {\n                        if (x < result) {\n                    \
    \        result = x\n                        }\n                    }\n      \
    \          }\n                index += 1\n            }\n            List(result,\
    \ arr.indexOf(result))\n        }", "        var result = List[Long]()\n     \
    \   var smallestEven = Long.MaxValue\n        var smallestEvenIndex = -1\n   \
    \     for (i <- 0 until arr.length) {\n            val e = arr(i)\n          \
    \  if (e % 2 == 0 && e < smallestEven) {\n                smallestEven = e\n \
    \               smallestEvenIndex = i\n            }\n        }\n        if (smallestEvenIndex\
    \ >= 0) {\n            result = List(smallestEven, smallestEvenIndex)\n      \
    \  }\n        result", "        var smallestEven : Long = Long.MaxValue\n    \
    \    var smallestEvenIndex : Long = Long.MaxValue\n        for (i <- 0 until arr.length)\
    \ {\n            val v = arr(i)\n            if (v % 2 == 0 && v < smallestEven)\
    \ {\n                smallestEven = v\n                smallestEvenIndex = i\n\
    \            }\n        }\n        if (smallestEven == Long.MaxValue) return List[Long]()\n\
    \        else return List[Long](smallestEven, smallestEvenIndex)", "        //\
    \ Fill up this function body\n        // You can add another function as well,\
    \ if required\n        var minEven = arr.filter(x => x % 2 == 0).sortWith(_<_).headOption\n\
    \        if (minEven.isEmpty)\n            return List()\n        var index =\
    \ arr.indexOf(minEven.get)\n        return List(minEven.get, index.toLong)", " \
    \       // Implement this.\n        var result : List[Long] = Nil\n        if\
    \ (arr.length == 0) return result\n        var min = Long.MaxValue\n        var\
    \ min_pos = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < min) {\n                min = arr(i)\n                min_pos\
    \ = i\n            }\n        }\n        if (min_pos != -1) result ::= min\n \
    \       if (min_pos != -1) result ::= min_pos\n        return result", "     \
    \   if (arr.length == 0) return List[Long]()\n        var minval = min(arr.filter(_\
    \ % 2 == 0).toArray)\n        var minindex = arr.indexOf(minval)\n        List[Long](minval,\
    \ minindex)", "        if (arr.length == 0) return List[Long]()\n        val a\
    \ = arr.map(x => (x, x % 2 == 0)).filter(x => x._2 == true)\n        if (a.length\
    \ == 0) return List[Long]()\n        a.sortBy(x => x._1).sortBy(x => x._2).head",
  "        def pluck(arr : List[Long], res : List[Long], index : Int) : List[Long]\
    \ = {\n            if (arr.isEmpty) {\n                res\n            } else\
    \ {\n                if (arr.head % 2 == 0) {\n                    if (res.isEmpty)\
    \ {\n                        pluck(arr.tail, List(arr.head, index.toLong), index\
    \ + 1)\n                    } else {\n                        if (arr.head < res.head)\
    \ {\n                            pluck(arr.tail, List(arr.head, index.toLong),\
    \ index + 1)\n                        } else {\n                            pluck(arr.tail,\
    \ res, index + 1)\n                        }\n                    }\n        \
    \        } else {\n                    pluck(arr.tail, res, index + 1)\n     \
    \           }\n            }\n        }\n        pluck(arr, List(), 0)", "   \
    \     if (arr.length == 0) return List()\n        var smallest = arr(0)\n    \
    \    var index = 0\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < smallest) {\n                smallest = arr(i)\n      \
    \          index = i\n            }\n        }\n        if (smallest % 2 == 0)\
    \ return List(smallest, index.toLong)\n        else return List()", "        val\
    \ v = arr.filter(_ % 2 == 0).sortWith(_ < _)\n        if (v.length == 0) List[Long]()\n\
    \        else List[Long](v(0), arr.indexOf(v(0))).map(_.toLong)", "        var\
    \ a = arr.filter(_ % 2 == 0)\n        if (a.isEmpty) Nil\n        else List(a.min,\
    \ arr.indexOf(a.min).toLong)", "        var res = List[Long]()\n        for (item\
    \ <- arr.indices) {\n            if (arr(item) % 2 == 0) {\n                if\
    \ (res.length == 0) {\n                    res = List(arr(item), item.toLong)\n\
    \                } else {\n                    if (res(0) > arr(item)) {\n   \
    \                     res = List(arr(item), item.toLong)\n                   \
    \ }\n                }\n            }\n        }\n        return res", "     \
    \   val evens = arr.zipWithIndex.filter(p => p._1 % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else List(evens.map(p => p._1).min, evens.filter(p => p._1 ==\
    \ evens.map(p => p._1).min).map(p => p._2).min)", "        // Your code goes here.\n\
    \        // Return the correct list containing [smallest_even_value, index]\n\
    \        var min = Long.MaxValue\n        var index = -1\n        for (i <- 0\
    \ until arr.length) {\n            val elem = arr(i)\n            if (elem !=\
    \ 0 && elem % 2 == 0 && elem < min) {\n                min = elem\n          \
    \      index = i\n            }\n        }\n        List(min, index)", "     \
    \   val index = (arr.indexWhere(_ % 2 == 0) + 1)\n        if (index == 0) List()\n\
    \        else List(arr(index - 1), index)", "        // Implement this function.\n\
    \        // Solution 1:\n        // val result = ArrayBuffer[Long]()\n       \
    \ // for (i <- 0 until arr.length) {\n        //     if (arr(i) % 2 == 0) {\n\
    \        //         result += arr(i)\n        //         result += i\n       \
    \ //         return result.toList\n        //     }\n        // }\n        //\
    \ return List[Long]()\n        // Solution 2:\n        var result = List[Long]()\n\
    \        if (arr.length == 0) return result\n        var left = 0\n        var\
    \ right = arr.length - 1\n        while (left < right) {\n            while (left\
    \ < right && arr(left) % 2 == 1) left += 1\n            while (left < right &&\
    \ arr(right) % 2 == 1) right -= 1\n            if (left < right) {\n         \
    \       val t = arr(left)\n                arr(left) = arr(right)\n          \
    \      arr(right) = t\n                left += 1\n                right -= 1\n\
    \            }\n        }\n        if (arr(0) % 2 == 0) {\n            result\
    \ = List(arr(0), 0)\n        }\n        return result", "        var index = -1\n\
    \        var min = Long.MaxValue\n        for (i <- 0 until arr.length) {\n  \
    \          val num = arr(i)\n            if (num % 2 == 0 && num < min) {\n  \
    \              min = num\n                index = i\n            }\n        }\n\
    \        if (index >= 0) List(min, index) else List()", "        var result =\
    \ List[Long]()\n        var min = Long.MaxValue\n        var index = -1\n    \
    \    for (i <- 0 until arr.length) {\n            val c = arr(i)\n           \
    \ if (c < min && c % 2 == 0) {\n                min = c\n                index\
    \ = i\n            }\n        }\n        if (index == -1) return result\n    \
    \    result :+= min\n        result :+= index\n        result", "        if (arr.isEmpty)\
    \ return List.empty[Long]\n        val x = arr.zipWithIndex.filter(x => x._1 %\
    \ 2 == 0).sortBy(x => x._1)\n        if (x.isEmpty) return List.empty[Long]\n\
    \        return List(x.head._1, x.head._2.toLong)", "        if (arr.isEmpty)\
    \ return List[Long]()\n        var min = Long.MaxValue\n        var minIndex =\
    \ Long.MaxValue\n        for (x <- arr.indices) {\n            if (arr(x) % 2\
    \ == 0 && arr(x) < min) {\n                min = arr(x)\n                minIndex\
    \ = x\n            }\n        }\n        if (min == Long.MaxValue) return List[Long]()\n\
    \        List[Long](min, minIndex)", '      arr.filter(_ % 2 == 0).map(x => List(x,
    arr.indexOf(x) + 1)).sortBy(_(0)).headOption.getOrElse(List[Long]())', "     \
    \   val l = arr.filter(x => x % 2 == 0)\n        if (l.isEmpty)\n            List()\n\
    \        else {\n            val min = l.min\n            val ans = l.indexOf(min)\n\
    \            List(min, ans.toLong)\n        }", "        val root = Node(arr(0))\n\
    \        val nodes = HashMap[Int, Node]()\n        nodes(1) = root\n        var\
    \ currentIndex = 1\n        for (i <- arr.drop(1)) {\n            currentIndex\
    \ += 1\n            val currentNode = Node(i)\n            nodes(currentIndex)\
    \ = currentNode\n            var parentIndex = currentIndex / 2\n            if\
    \ (parentIndex > 0) {\n                val parentNode = nodes(parentIndex)\n \
    \               if (currentIndex % 2 == 0) {\n                    parentNode.left\
    \ = currentNode\n                } else {\n                    parentNode.right\
    \ = currentNode\n                }\n            }\n        }\n        val leaves\
    \ = HashMap[Long, Int]()\n        def travel(node : Node) {\n            if (node.left\
    \ == null && node.right == null) {\n                if (node.value % 2 == 0) {\n\
    \                    leaves(node.value) = node.index\n                }\n    \
    \        } else {\n                if (node.left != null) travel(node.left)\n\
    \                if (node.right != null) travel(node.right)\n            }\n \
    \       }\n        travel(root)\n        val result = leaves.toList.sortWith((a,\
    \ b) => a._1 < b._1).headOption\n        if (result.isEmpty) List() else List(result.get._1,\
    \ result.get._2)", "        var ans = List[Long]()\n        val list = arr.zipWithIndex.filter(x\
    \ => x._1 % 2 == 0).sorted\n        if (list.isEmpty) ans\n        else {\n  \
    \          ans = List(list.head._1, list.head._2.toLong)\n        }\n        ans",
  "        val even = arr.filter(x => x % 2 == 0)\n        if (even.length == 0) {\n\
    \            List()\n        } else {\n            val smallestEven = even.min\n\
    \            val smallestEvenIndex = arr.indexOf(smallestEven)\n            List(smallestEven,\
    \ smallestEvenIndex)\n        }", "        val even_arr = arr.filter(e => e %\
    \ 2 == 0)\n        if (even_arr.length == 0) {\n            return List[Long]()\n\
    \        }\n        var min_value = even_arr(0)\n        var min_index = 0\n \
    \       for (i <- 0 until even_arr.length) {\n            if (even_arr(i) < min_value)\
    \ {\n                min_value = even_arr(i)\n                min_index = i\n\
    \            }\n        }\n        List[Long](min_value, min_index.toLong)", " \
    \       if (arr.isEmpty) return List()\n        val even = arr.filter(_ % 2 ==\
    \ 0)\n        if (even.isEmpty) return List()\n        val min = even.min\n  \
    \      val index = arr.indexOf(min)\n        return List(min, index.toLong)",
  '      arr.zipWithIndex.filter{case (v, i) => v % 2 == 0}.sortBy{case (v, i) =>
    (v, i)}.headOption.map{case (v, i) => List(v, i)}.getOrElse(List())', "      \
    \  val xs = arr.filter(_ % 2 == 0)\n        if (xs.isEmpty) List()\n        else\
    \ {\n            val ys = xs.zipWithIndex.filter(_._1 == xs.min)\n           \
    \ val ys2 = ys.filter(_._2 == ys.map(_._2).min)\n            ys2.map(_._1).toList\n\
    \        }", "        def findEven(arr : List[Long], index : Int, result : List[Long])\
    \ : List[Long] = {\n            if (arr.length == 0) {\n                result\n\
    \            } else {\n                val x = arr.head\n                if (x\
    \ % 2 == 0) {\n                    val newResult = if (result.length == 0) List(x,\
    \ index) else if (result.head > x) List(x, index) else result\n              \
    \      findEven(arr.tail, index + 1, newResult)\n                } else {\n  \
    \                  findEven(arr.tail, index + 1, result)\n                }\n\
    \            }\n        }\n        findEven(arr, 0, List())", "        //val evens\
    \ = arr.filter(_ % 2 == 0)\n        //if (evens.isEmpty) return List()\n     \
    \   //val minEven = evens.min\n        //val idx = arr.indexOf(minEven)\n    \
    \    //List(minEven, idx)\n        List()", "        if (arr.isEmpty) return List[Long]()\n\
    \        var min = 10000000\n        var min_i = 10000000\n        for (i <- 0\
    \ until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n  \
    \              min = arr(i).toInt\n                min_i = i\n            }\n\
    \        }\n        if (min == 10000000) return List[Long]()\n        List[Long](min,\
    \ min_i)", "        var minEven : Long = Long.MaxValue\n        var minEvenIndex\
    \ : Long = -1\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && arr(i) < minEven) {\n                minEven = arr(i)\n        \
    \        minEvenIndex = i\n            }\n        }\n        if (minEven == Long.MaxValue)\
    \ List()\n        else List(minEven, minEvenIndex)", "        var result : List[Long]\
    \ = List()\n        if (arr.length > 0) {\n            val minEvenIndex = arr.indexWhere(x\
    \ => x % 2 == 0)\n            if (minEvenIndex > -1) {\n                val minEvenValue\
    \ = arr(minEvenIndex)\n                result = List(minEvenValue, minEvenIndex.toLong)\n\
    \            }\n        }\n        result", "        // Write your code here\n\
    \        // To print results to the standard output you can use Console.println\n\
    \        // Example:\n        // Console.println(\"Hello world!\")\n        List[Long]()",
  "        val s = arr.sorted\n        s.indexWhere(_ % 2 == 0) match {\n        \
    \    case -1 => List()\n            case x => List(s(x), arr.indexOf(s(x)).toLong)\n\
    \        }", "        val evens = arr.zipWithIndex.filter(_._1 % 2 == 0)\n   \
    \     if (evens.isEmpty) List()\n        else List(evens.minBy(_._1)._1, evens.minBy(_._1)._2)",
  "        // Implement this function\n        if (arr.isEmpty) List()\n        else\
    \ {\n            var min = Long.MaxValue\n            var minIndex = 0\n     \
    \       for (i <- 0 until arr.length) {\n                if (arr(i) < min && arr(i)\
    \ % 2 == 0) {\n                    min = arr(i)\n                    minIndex\
    \ = i\n                }\n            }\n            if (min == Long.MaxValue)\
    \ List()\n            else List(min, minIndex)\n        }", "        val even\
    \ = arr.filter((x) => x % 2 == 0)\n        if (even.isEmpty) return List[Long]()\n\
    \        val m = even.min\n        val i = arr.indexOf(m)\n        return List(m,\
    \ i)", "        val index = arr.indexWhere(_ % 2 == 0)\n        if (index == -1)\
    \ List()\n        else List(arr(index), index.toLong)", "      // your code goes\
    \ here\n      var min = 100000000000l.toLong\n      var idx = -1\n      var res\
    \ = ListBuffer[Long]()\n      arr.zipWithIndex.foreach{ case (x, i) =>\n     \
    \   if (x % 2 == 0 && x < min) {\n          min = x\n          idx = i\n     \
    \   }\n      }\n      if (idx == -1) {\n        return List[Long]()\n      }\n\
    \      res += min\n      res += idx\n      res.toList", '        arr.zipWithIndex.filter(e
    => e._1 % 2 == 0).sortBy(e => (e._1, e._2)).headOption.toList.map(e => List(e._1,
    e._2))', "        if (arr.filter(x => x % 2 == 0).isEmpty) return List()\n   \
    \     val pos = arr.indexOf(arr.filter(x => x % 2 == 0).min)\n        List(arr(pos),\
    \ pos.toLong)", "        val arr2 = arr.filter(e => e % 2 == 0)\n        if (arr2.length\
    \ == 0) return List()\n        var arr3 = arr2.sorted\n        var smallestEven\
    \ = arr3(0)\n        var min = Long.MaxValue\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) == smallestEven) {\n                min = min min\
    \ i\n            }\n        }\n        return List(smallestEven, min)", "    \
    \    // your code here\n        List()", "        // Write your code here\n  \
    \      return List()", "        var result = List[Long]()\n        var idx = -1\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0) {\n\
    \                if (idx == -1) {\n                    idx = i\n             \
    \       result = List(arr(i), i)\n                } else {\n                 \
    \   if (arr(i) < result(0)) {\n                        idx = i\n             \
    \           result = List(arr(i), i)\n                    }\n                }\n\
    \            }\n        }\n        return result", "        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ def search(arr : List[Long], c : Long, ci : Long) : (Long, Long) = {\n     \
    \       arr match {\n                case Nil => (c, ci)\n                case\
    \ (x :: xs) => {\n                    if (x > 0 && x % 2 == 0) {\n           \
    \             if (c == -1 || x < c) search(xs, x, ci + 1)\n                  \
    \      else search(xs, c, ci + 1)\n                    }\n                   \
    \ else search(xs, c, ci + 1)\n                }\n            }\n        }\n  \
    \      val r = search(arr, -1, 0)\n        if (r._1 == -1) List()\n        else\
    \ List(r._1, r._2)", "      val s = arr.groupBy(identity).toList.sortBy(_._1)\n\
    \      val e = s.filter(_._1 % 2 == 0)\n      if (e.length == 0) List()\n    \
    \  else List(e(0)._1, e(0)._2(0).toLong)", "        var result : List[Long] =\
    \ List()\n        for (i <- 0 until arr.length) {\n            val n = arr(i)\n\
    \            if (n % 2 == 0) {\n                if (result.length == 0) {\n  \
    \                  result = List(n, i.toLong)\n                } else {\n    \
    \                if (n < result(0)) {\n                        result = List(n,\
    \ i.toLong)\n                    }\n                }\n            }\n       \
    \ }\n        result", '        arr.filter(_ % 2 == 0).zipWithIndex.sortBy(_._1).headOption.map(x
    => List(x._1, x._2.toLong)).getOrElse(List())', "        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ arr.filter(_ % 2 == 0).sorted match {\n            case Nil => Nil\n       \
    \     case l => List(l.head, arr.indexOf(l.head).toLong)\n        }", "      \
    \  // error handling\n        if (arr.length < 1 || arr.length > 10000) {\n  \
    \          return List[Long]()\n        }\n        var result : List[Long] = List[Long]()\n\
    \        var min : Long = Long.MaxValue\n        var minIndex : Long = Long.MaxValue\n\
    \        for (i <- 0 until arr.length) {\n            val value = arr(i)\n   \
    \         if (value < min && value % 2 == 0) {\n                min = value\n\
    \                minIndex = i\n            }\n        }\n        if (min == Long.MaxValue)\
    \ {\n            return List[Long]()\n        }\n        else {\n            return\
    \ List[Long](min, minIndex)\n        }", "        if (arr.length == 0) List[Long]()\n\
    \        else {\n            val evens = arr.filter(x => x % 2 == 0)\n       \
    \     if (evens.length == 0) List[Long]()\n            else {\n              \
    \  val minVal = evens.min\n                val minValIndex = arr.indexOf(minVal)\n\
    \                List(minVal, minValIndex)\n            }\n        }", "     \
    \   // Write your code here\n        null", "        arr.indexWhere(_ % 2 == 0)\
    \ match {\n            case -1 => List()\n            case x => List(arr(x), x.toLong)\n\
    \        }", "        arr.filter(x => x % 2 == 0).distinct.sortWith(_ < _).headOption\
    \ match {\n            case Some(value) => List(value, arr.indexOf(value) + 1l)\n\
    \            case None => List()\n        }", "        val evens = new ListBuffer[Long]()\n\
    \        val indices = new ListBuffer[Int]()\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0) {\n                evens += arr(i)\n   \
    \             indices += i\n            }\n        }\n        if (evens.length\
    \ == 0) List[Long]()\n        else {\n            val min = evens.min\n      \
    \      val minindices = new ListBuffer[Int]()\n            for (i <- 0 until evens.length)\
    \ {\n                if (evens(i) == min) minindices += indices(i)\n         \
    \   }\n            List(min, minindices.min.toLong)\n        }", "      // Complexity:\
    \ O(n)\n      var index = 0\n      var min = Long.MaxValue\n      var found =\
    \ false\n      for (i <- arr) {\n        if (i % 2 == 0 && i < min) {\n      \
    \    min = i\n          found = true\n        }\n        index += 1\n      }\n\
    \      if (found) List(min, index) else List()", "      // your code here\n  \
    \    return arr", "        // Fill up this function body\n        // 'nodes' is\
    \ a list of integer representing nodes in a tree.\n        // Array.filter(_ %\
    \ 2 == 0).sorted.take(1).map(x => List(x, nodes.indexOf(x)))\n        List()",
  "        val map = new HashMap[Long, Long]()\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0) {\n                if (!map.contains(arr(i)))\
    \ {\n                    map += (arr(i) -> i)\n                }\n           \
    \ }\n        }\n        if (map.size == 0) return List()\n        var key = map.keys.toArray.sorted(0)(0)\n\
    \        for (i <- 1 until map.keys.toArray.sorted.length) {\n            if (map.keys.toArray.sorted(i)\
    \ % 2 == 0) {\n                key = map.keys.toArray.sorted(i)\n            \
    \    break\n            }\n        }\n        val index = map(key)\n        return\
    \ List(key, index)", "        if (arr.isEmpty) return List[Long]()\n        val\
    \ evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List[Long]()\n\
    \        return List[Long](evens.min, arr.indexOf(evens.min).toLong)", "     \
    \   // Given a list, we will return the smallest even number and its index\n \
    \       // because the lowest index should be returned first,\n        // our\
    \ solution will use a Stack (FILO) to store the lowest even numbers and their\
    \ indices.\n        val s = new Stack[List[Long]]()\n        // iterate through\
    \ the list, and add the lowest even numbers and their indices to the stack,\n\
    \        // if there are two even numbers with the same value, add the number\
    \ with the lowest index\n        for ((ele, idx) <- arr.zipWithIndex) {\n    \
    \        // if ele is an even number and its smaller than the number in the stack\
    \ or the stack is empty,\n            // then push ele and its index on the stack\n\
    \            if (ele % 2 == 0 && (s.isEmpty || ele < s.top(0))) {\n          \
    \      s.push(List(ele, idx.toLong))\n            }\n        }\n        // if\
    \ the stack is empty, return an empty list\n        if (s.isEmpty)\n         \
    \   List()\n        // otherwise, return the last element in the stack, which\
    \ is the smallest even number and its index\n        else\n            s.pop()",
  "      // your code here\n      null", "      var z = arr.zipWithIndex\n      var\
    \ y = z.filter(_._1 % 2 == 0)\n      if (y.length == 0)\n        return List()\n\
    \      var min = Long.MaxValue\n      var minIndex = Long.MaxValue\n      for\
    \ (c <- y) {\n        if (c._1 < min) {\n          min = c._1\n          minIndex\
    \ = c._2\n        }\n      }\n      List(min, minIndex)", "        val array =\
    \ arr.toArray\n        val even = new ArrayBuffer[Long]\n        for (i <- 0 until\
    \ array.length) {\n            if (array(i) % 2 == 0) even += array(i)\n     \
    \   }\n        if (even.isEmpty) return List()\n        else {\n            val\
    \ min = even.min\n            var index = -1\n            for (i <- 0 until array.length)\
    \ {\n                if (array(i) == min) {\n                    index = i\n \
    \                   break\n                }\n            }\n            return\
    \ List(min, index)\n        }", "        if (arr.isEmpty) return List.empty[Long]\n\
    \        var min = Long.MaxValue\n        var minIndex = -1\n        for (i <-\
    \ 0 until arr.length) {\n            if (arr(i) % 2 == 0 && arr(i) < min) {\n\
    \                min = arr(i)\n                minIndex = i\n            }\n \
    \       }\n        if (min == Long.MaxValue) return List.empty[Long]\n       \
    \ List(min, minIndex)", "        if (arr.isEmpty) return List[Long]()\n      \
    \  val even = arr.filter(_ % 2 == 0)\n        if (even.isEmpty) return List[Long]()\n\
    \        val minEven = even.min\n        val idx = arr.indexOf(minEven)\n    \
    \    List(minEven, idx)", "        var ls = arr.zipWithIndex\n        ls = ls.filter(p\
    \ => p._1 % 2 == 0)\n        if (ls.isEmpty) {\n            return List()\n  \
    \      }\n        ls = ls.sortWith((p1, p2) => {\n            if (p1._1 == p2._1)\
    \ {\n                p1._2 < p2._2\n            } else {\n                p1._1\
    \ < p2._1\n            }\n        })\n        List(ls.head._1, ls.head._2)", " \
    \       val even = arr.filter(_ % 2 == 0)\n        val min = if (even.length ==\
    \ 0) None else Some(even.min)\n        min match {\n            case None => List[Long]()\n\
    \            case Some(m) => List[Long](m, arr.indexOf(m).toLong)\n        }",
  "        if (arr.length == 0) {\n            return List[Long]()\n        }\n  \
    \      var min = Long.MaxValue\n        var minValue = Long.MaxValue\n       \
    \ for (i <- 0 until arr.length) {\n            if (arr(i) != 0 && arr(i) % 2 ==\
    \ 0 && arr(i) < min) {\n                min = arr(i)\n                minValue\
    \ = i\n            }\n        }\n        if (min == Long.MaxValue) {\n       \
    \     return List[Long]()\n        }\n        return List[Long](min, minValue)",
  "        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty) return List[Long]()\n\
    \        val min = evens.min\n        List(min, arr.indexOf(min).toLong)"]
stop_tokens:
- "\n    }\n"
