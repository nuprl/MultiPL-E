language: scala
name: HumanEval_2_truncate_number
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = number.toInt\n        return\
    \ number - integerPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      return number - math.floor(number)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp96og_800.scala:11:13\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m      \e[33mreturn\e[0m number\
    \ - math.floor(number)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    Double\n\e[31m   |\e[0m           \
    \  Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        (number - number.toInt).toFloat\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer = floor(number).toInt\n        number\
    \ - integer\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val truncated = floor(number).toInt\n        number\
    \ - truncated\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgyxx1q0y.scala:11:15\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - Math.floor(number).toFloat\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val x = (number - floor(number)).toFloat\n   \
    \     x\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val num : Float = ceil(number).toFloat\n     \
    \   return number - num + 1f\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn8xv21d7.scala:17)\n\tat Problem.main(tmpn8xv21d7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = number.toInt\n        return number\
    \ - intPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var result = number % 1\n        if (result <\
    \ 0)\n            result = result + 1\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = floor(number).toInt\n      \
    \  val decimalPart = number - integerPart\n        decimalPart\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - floor(number)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54v90nhr.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        number - floor(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val floor = floor(number).toInt\n        val decimals\
    \ = number - floor\n        decimals\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpuizyvzt9.scala:11:20 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(number).toInt\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009934
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgyxx1q0y.scala:11:15\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - floor(number)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54v90nhr.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        number - floor(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - floor(number)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54v90nhr.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        number - floor(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var left = number\n        while (left >= 1) {\n\
    \            left -= 1\n        }\n        return left\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var truncated = 0f\n        var remainder = 0f\n\
    \        truncated = (number).toInt\n        remainder = number - truncated\n\
    \        return remainder\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - floor(number)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54v90nhr.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        number - floor(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - floor(number)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54v90nhr.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        number - floor(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val (intPart, decimalPart) = number.toString.splitAt(number.toString.indexOf(\"\
    .\"))\n        decimalPart.toFloat\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgyxx1q0y.scala:11:15\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val (intPart, decimalPart) = number.toString.splitAt(number.toString.indexOf(\"\
    .\"))\n        decimalPart.toFloat\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - (floor(number)).toFloat\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number < 0) {\n            return 0\n    \
    \    }\n        val numberAsString = number.toString\n        val intPart = numberAsString.split(\"\
    \\\\.\")(0).toInt\n        return number - intPart\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number).toFloat\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgyxx1q0y.scala:11:15\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number % 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      var decimalPart = number - floor(number)\n     \
    \ if (decimalPart < 0) {\n        decimalPart = 1 + decimalPart\n      }\n   \
    \   return decimalPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9ghm2lzw.scala:15:13\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m      \e[33mreturn\e[0m decimalPart\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \   Found:    (decimalPart : Double)\n\e[31m   |\e[0m             Required: Float\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009944
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number % 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // How to truncate a number: round it down to\
    \ integer\n        // and subtract it from the number itself\n        val integerPart\
    \ = floor(number).toInt\n        number - integerPart\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val rounded = round(number).toInt\n        return\
    \ number - rounded\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeqhce91c.scala:15)\n\tat Problem.main(tmpeqhce91c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var number_truncated = number\n        while (number_truncated\
    \ > 1.0f) {\n            number_truncated -= 1.0f\n        }\n        return number_truncated\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2j7qaux7.scala:20)\n\tat Problem.main(tmp2j7qaux7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val truncated = number.toInt\n        return number\
    \ - truncated\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val sign = signum(number)\n        val decimals\
    \ = number - sign * floor(abs(number))\n        if (decimals >= 1) return (decimals\
    \ - 1) * sign\n        return decimals * sign\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppep2nr75.scala:13:34\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mif\e[0m (decimals\
    \ >= \e[31m1\e[0m) \e[33mreturn\e[0m (decimals - \e[31m1\e[0m) * sign\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                  Found:    Double\n\e[31m   |\e\
    [0m                                  Required: Float\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmppep2nr75.scala:14:15 --------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mreturn\e[0m decimals * sign\n\e[31m\e[31m\
    \   |\e[0m               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    Double\n\e[31m   |\e[0m               Required: Float\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgyxx1q0y.scala:11:15\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number > 0) {\n            val integerPart\
    \ = floor(number).toInt\n            number - integerPart\n        } else {\n\
    \            val integerPart = ceil(number).toInt\n            number - integerPart\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      val integerPart = floor(number).toInt\n      val\
    \ leftoverPart = number - integerPart\n      leftoverPart\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009947
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer = floor(number).toInt\n        return\
    \ number - integer\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009947
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val numberInt = number.toInt\n        number -\
    \ numberInt\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var n = number\n        while (n >= 1) {\n   \
    \         n -= 1\n        }\n        return n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009947
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number).toFloat\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = number.toInt\n        number\
    \ - integerPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - (floor(number)).toFloat\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val num = floor(number)\n        return number\
    \ - num\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp90j5ty_2.scala:12:15\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mreturn\e[0m number\
    \ - num\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \               Found:    Double\n\e[31m   |\e[0m               Required: Float\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009947
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var intPart = number.toInt\n        return number\
    \ - intPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        (number - number.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - (number.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - (number.toInt.toFloat)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - floor(number)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54v90nhr.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        number - floor(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - (number.toInt)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - number.floor\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009947
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Some trick to achieve.\n        return number\
    \ - number.toInt\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009947
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgyxx1q0y.scala:11:15\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        //println(number, 1 - number.floor)\n        number\
    \ - number.floor\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009947
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - math.floor(number).toFloat\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009947
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = Math.floor(number)\n       \
    \ number - integerPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_5zi9jg5.scala:12:8\
    \ ---------------------\e[0m\e[0m\n\e[31m12 |\e[0m        number - integerPart\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \  Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val r = round(number)\n        number - r\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4lj8bhfo.scala:15)\n\tat Problem.main(tmp4lj8bhfo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009954
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      def loop(num : Float, decimals : List[Int]) : Float\
    \ = {\n        if (num == 0) {\n          decimals.mkString(\".\").toFloat\n \
    \       } else {\n          val mult = num * 10\n          val intPart = mult.toInt\n\
    \          loop(mult - intPart, intPart :: decimals)\n        }\n      }\n   \
    \   loop(number, List())\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvgdpbfma.scala:23)\n\tat Problem.main(tmpvgdpbfma.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - floor(number)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54v90nhr.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        number - floor(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number >= 0) return number - number.toInt\n\
    \        return number + 1 - number.toInt\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009954
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Convert to Int, compare with Float\n      \
    \  val numberInt = number.toInt\n        val decimals = number - numberInt\n \
    \       decimals\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009955
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number).toFloat\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return (number - Math.floor(number))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvv9ct_p4.scala:11:16\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m (number\
    \ - Math.floor(number))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Found:    Double\n\e[31m   |\e[0m        \
    \        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009955
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - floor(number)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54v90nhr.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        number - floor(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        assert(number > 0f)\n        return (number -\
    \ floor(number))\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzxhilepy.scala:12:16\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mreturn\e[0m (number\
    \ - floor(number))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Found:    Double\n\e[31m   |\e[0m        \
    \        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number).toFloat\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val truncated = math.floor(number).toFloat\n \
    \       val decimals = number - truncated\n        decimals\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val int = number.toInt\n        return number\
    \ - int\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009955
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer : Int = floor(number).toInt\n    \
    \    number - integer\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009955
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val floor = number.floor\n        return number\
    \ - floor\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var integerPart = (number.toInt).toFloat\n   \
    \     return number - integerPart\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009955
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number < 0) throw new IllegalArgumentException(\"\
    \" + number)\n        return number % 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val truncated = floor(number).toInt\n        number\
    \ - truncated\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Remove decimal part.\n        val integerPart\
    \ = number.toInt\n        // Keep only leftover part.\n        number - integerPart\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009955
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var decimalPart = number - number.floor\n    \
    \    return decimalPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val (intPart, _) = number.asInstanceOf[Int]\n\
    \        return number - intPart\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpdraezi8l.scala:12:22 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mreturn\e[0m number - intPart\n\e[31m\e\
    [31m   |\e[0m               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mFloat\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Float\n\e[31m   |\e[0m (x: Int): Float\n\e\
    [31m   |\e[0m (x: Char): Float\n\e[31m   |\e[0m (x: Short): Float\n\e[31m   |\e\
    [0m (x: Byte): Float\n\e[31m   |\e[0mmatch arguments ((intPart : Any))\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009955
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      if (number < 0) return -truncateNumber(-number)\n\
    \      val truncate : Float = floor(number).toFloat\n      val decimal : Float\
    \ = number - truncate\n      decimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val n = floor(number)\n        number - n\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz72qt4ej.scala:12:8\
    \ ---------------------\e[0m\e[0m\n\e[31m12 |\e[0m        number - n\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Double\n\
    \e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = number.toInt\n        return\
    \ number - integerPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        floor(number).toFloat\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpskpbks95.scala:14)\n\tat Problem.main(tmpskpbks95.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - Math.floor(number).toFloat\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - (number.asInstanceOf[Int])\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = number.toInt\n        number\
    \ - integerPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgyxx1q0y.scala:11:15\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number > 0) {\n            var intPart = floor(number).toInt\n\
    \            var decimalPart = number - intPart\n            decimalPart\n   \
    \     } else {\n            println(\"Number should be positive!\")\n        \
    \    -1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        floor(number).toFloat\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpskpbks95.scala:14)\n\tat Problem.main(tmpskpbks95.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        floor(number).toFloat\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpskpbks95.scala:14)\n\tat Problem.main(tmpskpbks95.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - math.floor(number).toFloat\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        (number - floor(number))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6_d_e4fy.scala:11:9\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        (number - floor(number))\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \      Found:    Double\n\e[31m   |\e[0m         Required: Float\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - floor(number)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54v90nhr.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        number - floor(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val numberParts = number.toString.split(\"\\\\\
    .\")\n        if (numberParts.length > 1) {\n            return numberParts(1).toFloat\
    \ / pow(10, numberParts(1).length).toFloat\n        }\n        else {\n      \
    \      return 0\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgyxx1q0y.scala:11:15\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var tmp = number\n        while (tmp >= 1) {\n\
    \            tmp -= 1\n        }\n        tmp\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = floor(number).toInt\n        number\
    \ - intPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - (number.toInt)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number).toFloat\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      val int = floor(number).toInt\n      return number\
    \ - int\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      val integerPart = floor(number).toInt\n      val\
    \ decimals = number - integerPart\n      decimals\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val int = floor(number).toInt\n        return\
    \ number - int\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return ((number % 1) + 1) % 1;\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - floor(number)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54v90nhr.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        number - floor(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val truncated = floor(number).toInt.toFloat\n\
    \        number - truncated\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009965
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val (integer, decimals) = number.toInt -> (number\
    \ - number.toInt)\n        decimals\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009965
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer = number.toInt\n        number - integer\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = round(number)\n        number\
    \ - integerPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwr2crwnt.scala:15)\n\tat Problem.main(tmpwr2crwnt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var intNumber = number.toInt\n        return number\
    \ - intNumber\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009965
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      val decimalPart = number - number.toInt\n      decimalPart\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var negative = number < 0\n        val truncated\
    \ = floor(abs(number)).toInt\n        val decimal = if (negative) number + truncated\
    \ else number - truncated\n        return decimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009965
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val rounded = floor(number).toInt\n        number\
    \ - rounded\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009965
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      val roundedNumber = Math.floor(number).toInt\n \
    \     return number - roundedNumber\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009965
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      // 1.0f - 0.1f = 0.89999997615f\n      // 0.9f +\
    \ 0.1f = 1.0f\n      // We should use the difference between 1.0f and 0.1f to\
    \ compare,\n      // otherwise 1.0f and 0.9f + 0.1f will be considered equal.\n\
    \      if (abs(1.0f - 0.1f - number) < 0.000001f) return 0.0f\n      val intPart\
    \ = floor(number).toInt\n      number - intPart\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009965
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number).toFloat\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Get number's integer part and return the difference\n\
    \        number - number.toInt\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      val decimal = number - floor(number)\n      decimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxch_77ic.scala:12:6\
    \ ---------------------\e[0m\e[0m\n\e[31m12 |\e[0m      decimal\n\e[31m\e[31m\
    \   |\e[0m      ^^^^^^^\e[0m\n\e[31m   |\e[0m      Found:    (decimal : Double)\n\
    \e[31m   |\e[0m      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009965
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - Math.floor(number).toFloat\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // use round() to round to the closest integer\n\
    \        val intPart = floor(number).toInt\n        number - intPart\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009965
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var int_part = floor(number).toInt\n        var\
    \ dec_part = number - int_part\n        return dec_part\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number == 0) {\n            return 0\n   \
    \     }\n        if (number < 0) {\n            return -truncateNumber(-number)\n\
    \        }\n        return number - floor(number)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb905yyig.scala:17:15\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009965
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = floor(number).toInt\n      \
    \  val decimalPart = number - integerPart\n        return decimalPart\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009965
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      val intPart = number.toInt\n      return number\
    \ - intPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = (number).toInt\n        return\
    \ number - integerPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009973
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number <= 0)\n            return 0.0f\n  \
    \      val i = floor(number).toInt\n        return number - i\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009973
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = floor(number).toInt\n      \
    \  number - integerPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009973
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var intPart = number.toInt\n        number - intPart\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number < 0) 0 else (number - floor(number))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnn38z60z.scala:11:32\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mif\e[0m (number\
    \ < \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m (number - floor(number))\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                Found:    Double\n\e[31m   |\e[0m  \
    \                              Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009973
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      if (number > 1) {\n        val numberString = number.toString\n\
    \        val numberStringArray = numberString.split(\"\\\\.\")\n        val decimalsString\
    \ = numberStringArray(1)\n        decimalsString.toFloat / pow(10, decimalsString.length).toFloat\n\
    \      } else {\n        number\n      }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val tmp = floor(number)\n        number - tmp\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsas3ub7q.scala:12:8\
    \ ---------------------\e[0m\e[0m\n\e[31m12 |\e[0m        number - tmp\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Double\n\
    \e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val truncated = scala.math.floor(number)\n   \
    \     number - truncated\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr5dw76dy.scala:12:8\
    \ ---------------------\e[0m\e[0m\n\e[31m12 |\e[0m        number - truncated\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // floor is the largest integer smaller than the\
    \ number\n        return number - floor(number)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw4i4o9i2.scala:12:15\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - floor(number)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54v90nhr.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        number - floor(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number).toFloat\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = number.toInt\n        number - intPart\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val truncated = number.toInt\n        number -\
    \ truncated\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgyxx1q0y.scala:11:15\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgyxx1q0y.scala:11:15\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val numberToInt = math.floor(number).toInt\n \
    \       return number - numberToInt\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // TODO: Implement\n        var x = number.toString\n\
    \        var i = 0\n        while (x(i) != '.') {\n            i = i + 1\n   \
    \     }\n        var y = x.substring(i, x.length()).toFloat\n        return y\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integralPart = floor(number).toInt\n     \
    \   number - integralPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val numberAsString = number.toString\n       \
    \ val indexOfDecimal = numberAsString.indexOf(\".\")\n        numberAsString.substring(indexOfDecimal).toFloat\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      (number % 1.0f)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - (number.floor)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // TODO\n        return 0\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgcxmr1pa.scala:15)\n\tat Problem.main(tmpgcxmr1pa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      val decimalPart = number - floor(number)\n     \
    \ decimalPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnaygladm.scala:12:6\
    \ ---------------------\e[0m\e[0m\n\e[31m12 |\e[0m      decimalPart\n\e[31m\e\
    [31m   |\e[0m      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      Found:    (decimalPart\
    \ : Double)\n\e[31m   |\e[0m      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer = ceil(number).toInt\n        return\
    \ number - integer\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwg4jdqgr.scala:15)\n\tat Problem.main(tmpwg4jdqgr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = number.toInt\n        number\
    \ - integerPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number % 1f\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = number.toInt\n        return\
    \ number - integerPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intpart = floor(number).toInt\n        return\
    \ number - intpart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - Math.floor(number)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6vubz0fw.scala:11:15\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m number\
    \ - Math.floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Calculate the floor (the integer part) and\
    \ subtract it from the input\n        return number - floor(number)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy28a0v13.scala:12:15\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      val truncated = floor(number).toInt\n      number\
    \ - truncated\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = number.toInt\n        number - intPart\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      0.toFloat\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa3o4lcvp.scala:14)\n\tat Problem.main(tmpa3o4lcvp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = number.toInt\n        number\
    \ - integerPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = floor(number).toInt\n        number\
    \ - intPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - math.floor(number).toFloat\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number).toFloat\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = floor(number).toInt\n        number\
    \ - intPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intpart = floor(number).toInt\n        return\
    \ number - intpart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var string = number.toString.split(\"\\\\.\");\n\
    \        return string(1).toFloat / (Math.pow(10, string(1).length()).toFloat);\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        (number - floor(number)).toFloat\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number).toFloat\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val floor = floor(number).toInt\n        val leftover\
    \ = number - floor\n        leftover\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdm5dljo6.scala:11:20 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(number).toInt\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009978
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // 2.5 -> 2, 0.5\n        // 2.0 -> 2, 0.0\n \
    \       // 2.6 -> 2, 0.6\n        // 2 -> 2, 0\n        // 2.6 -> 2, 0.6\n   \
    \     // 2.01 -> 2, 0.01\n        val numberString = number.toString\n       \
    \ val (integer, decimal) = numberString.splitAt(numberString.indexOf('.'))\n \
    \       decimal.substring(1).toFloat\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppx0bkq8z.scala:22)\n\tat Problem.main(tmppx0bkq8z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      if (number <= 0) return 0\n      val integerPart\
    \ = floor(number).toInt\n      val decimalPart = number - integerPart\n      return\
    \ decimalPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - number.toInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        def tailRecur(number : Float, intPart : Int) :\
    \ Float = {\n            if (number < 1) {\n                return number\n  \
    \          }\n            return tailRecur(number - 1, intPart + 1)\n        }\n\
    \        return tailRecur(number, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      return number - number.floor\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgyxx1q0y.scala:11:15\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - (number / 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpivnj82a5.scala:14)\n\tat Problem.main(tmpivnj82a5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number - floor(number)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54v90nhr.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        number - floor(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        floor(number).toFloat\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpskpbks95.scala:14)\n\tat Problem.main(tmpskpbks95.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val numberString = number.toString\n        var\
    \ positionOfPoint = numberString.indexOf('.')\n        if (positionOfPoint ==\
    \ -1) return 0f\n        val integerPart = numberString.substring(0, positionOfPoint)\n\
    \        val decimalPart = numberString.substring(positionOfPoint + 1)\n     \
    \   return decimalPart.toFloat / pow(10, decimalPart.length).toFloat\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        abs(number - abs(number.toInt))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val (integer, decimals) = number.toString.split(\"\
    \\\\.\").toList match {\n            case List(integer, decimals) => (integer.toInt,\
    \ \"0.\" + decimals)\n            case List(integer) => (integer.toInt, \"0\"\
    )\n        }\n        return decimals.toFloat\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        return number - floor(number)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgyxx1q0y.scala:11:15\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mreturn\e[0m number\
    \ - floor(number)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        (number - number.toInt).toFloat\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var (intPart, decPart) = number.asInstanceOf[Double].toString.split(\"\
    \\\\.\").map(_.toFloat)\n        return decPart\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprz3t3i3l.scala:12:15\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mreturn\e[0m decPart\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \   Found:    (decPart : Any)\n\e[31m   |\e[0m               Required: Float\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      return (number % 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer : Int = number.toInt\n        return\
    \ number - integer\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        (number % 1).toFloat\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009981
