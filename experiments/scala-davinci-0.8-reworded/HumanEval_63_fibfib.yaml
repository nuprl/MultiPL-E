name: HumanEval_63_fibfib
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // The FibFib number sequence is a sequence similar to the Fibbonacci sequnece\
  \ that's defined as follows:\n    // fibfib(0) == 0\n    // fibfib(1) == 0\n   \
  \ // fibfib(2) == 1\n    // fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n\
  \    // Please write a function to efficiently compute the n-th element of the fibfib\
  \ number sequence.\n    // >>> fibfib((1l))\n    // (0l)\n    // >>> fibfib((5l))\n\
  \    // (4l)\n    // >>> fibfib((8l))\n    // (24l)\n    def fibfib(n : Long) :\
  \ Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(fibfib((2l)) == (1l));\n\
  \    assert(fibfib((1l)) == (0l));\n    assert(fibfib((5l)) == (4l));\n    assert(fibfib((8l))\
  \ == (24l));\n    assert(fibfib((10l)) == (81l));\n    assert(fibfib((12l)) == (274l));\n\
  \    assert(fibfib((14l)) == (927l));\n    }\n\n}\n"
completions: ["        var fibs = ListBuffer(0, 0, 1)\n        if (n < 3) return fibs(n.toInt)\n\
    \        for (i <- 3 to n.toInt) {\n            fibs += fibs(i - 1) + fibs(i -\
    \ 2) + fibs(i - 3)\n        }\n        fibs(n.toInt)", "        return n match\
    \ {\n            case 0 => 0\n            case 1 => 0\n            case 2 => 1\n\
    \            case n => fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n       \
    \ }", "        // Your code here\n        fibfib_(n, Map(0l -> 0l, 1l -> 0l, 2l\
    \ -> 1l))", "        if (n == 0) 0\n        else if (n == 1) 0\n        else if\
    \ (n == 2) 1\n        else fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)", " \
    \       // Your code here\n        if (n < 3) 0\n        else fibfib(n - 1) +\
    \ fibfib(n - 2) + fibfib(n - 3)", '        if (n == 0) 0 else if (n == 1) 0 else
    if (n == 2) 1 else fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)', "        if\
    \ (n == 0 || n == 1) 0\n        else if (n == 2) 1\n        else fibfib(n - 1)\
    \ + fibfib(n - 2) + fibfib(n - 3)", "        val X = Array(0L, 0L, 1L)\n     \
    \   if (n == 0 || n == 1) {\n            return X(n.toInt)\n        }\n      \
    \  else {\n            var a = X(0)\n            var b = X(1)\n            var\
    \ c = X(2)\n            for (i <- 3 to n.toInt) {\n                var d = a +\
    \ b + c\n                a = b\n                b = c\n                c = d\n\
    \            }\n            return c\n        }", "        var f = scala.collection.mutable.Map[Long,\
    \ Long]()\n        f(0) = 0\n        f(1) = 0\n        f(2) = 1\n        def ffb(n\
    \ : Long) : Long = {\n            if (f.contains(n)) f(n)\n            else {\n\
    \                val num = ffb(n - 1) + ffb(n - 2) + ffb(n - 3)\n            \
    \    f(n) = num\n                num\n            }\n        }\n        ffb(n)",
  "        // You are forbidden to use recursion.\n        def inner(n : Long, memo\
    \ : scala.collection.mutable.HashMap[Long, Long]) : Long = {\n            if (memo.contains(n))\
    \ memo(n)\n            else {\n                val x = inner(n - 1, memo) + inner(n\
    \ - 2, memo) + inner(n - 3, memo)\n                memo(n) = x\n             \
    \   x\n            }\n        }\n        val memo = new scala.collection.mutable.HashMap[Long,\
    \ Long]\n        memo(0) = 0\n        memo(1) = 0\n        memo(2) = 1\n     \
    \   inner(n, memo)", "        var f1 = 0l\n        var f2 = 0l\n        var f3\
    \ = 1l\n        var f4 = 0l\n        for (i <- 2l to n) {\n            f4 = f1\
    \ + f2 + f3\n            f1 = f2\n            f2 = f3\n            f3 = f4\n \
    \       }\n        f4", "        // \n        // your code here\n        // \n\
    \        0", "        val fibfibHelper = (n : Long, acc : Array[Long]) => n match\
    \ {\n            case n if n == 0 => acc(0)\n            case n if n == 1 => acc(1)\n\
    \            case n if n == 2 => acc(2)\n            case n => {\n           \
    \     val next = acc(0) + acc(1) + acc(2)\n                acc(0) = acc(1)\n \
    \               acc(1) = acc(2)\n                acc(2) = next\n             \
    \   fibfibHelper(n - 1, acc)\n            }\n        }\n        fibfibHelper(n,\
    \ Array(0, 0, 1))", "        var a = 0l\n        var b = 0l\n        var c = 1l\n\
    \        for (i <- 1 to n.toInt) {\n            a = b\n            b = c\n   \
    \         c = a + b + c\n        }\n        a", "        // Your code here\n \
    \       1l", "        if (n == 0) return 0\n        if (n == 1) return 0\n   \
    \     if (n == 2) return 1\n        var dp = ArrayBuffer.fill(n.toInt + 1)(0L)\n\
    \        dp(0) = 0\n        dp(1) = 0\n        dp(2) = 1\n        for (i <- 3\
    \ to n.toInt) {\n            dp(i) = dp(i - 1) + dp(i - 2) + dp(i - 3)\n     \
    \   }\n        return dp(n.toInt)", "\t\tdef fibfib1(n : Long, a : Long, b : Long,\
    \ c : Long) : Long = {\n\t\t\tif (n == 0) a\n\t\t\telse if (n == 1) b\n\t\t\t\
    else if (n == 2) c\n\t\t\telse fibfib1(n - 1, b, c, a + b + c)\n\t\t}\n\t\tfibfib1(n,\
    \ 0, 0, 1)", "        //get the nth fibfib number\n        return 0", '        return
    if (n == 0 || n == 1) 0 else if (n == 2) 1 else fibfib(n - 1) + fibfib(n - 2)
    + fibfib(n - 3)', "        def fibfibHelper(n : Long, n1 : Long, n2 : Long, n3\
    \ : Long) : Long = {\n            if (n == 0) 0\n            else if (n == 1)\
    \ 0\n            else if (n == 2) 1\n            else fibfibHelper(n - 1, n2,\
    \ n3, n1 + n2 + n3)\n        }\n        fibfibHelper(n, 0, 0, 1)", '        //
    Your code here (and the code below.)', "        var q = mutable.Queue[Long]()\n\
    \        q += 0\n        q += 0\n        q += 1\n        for (i <- 3 to n.toInt)\
    \ {\n            q += q.dequeue + q.dequeue + q.dequeue\n        }\n        q.dequeue",
  "        // Fill up this function body\n        // 'n' is the n-th element in the\
    \ sequence that your function has to compute\n        // You can add another function\
    \ as well, if that helps\n        if (n < 2) 0\n        else if (n == 2) 1\n \
    \       else fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)", "        var a =\
    \ 0l\n        var b = 0l\n        var c = 1l\n        for (x <- 1 to n.toInt)\
    \ {\n            a = b\n            b = c\n            c = a + b + c\n       \
    \ }\n        return a", "\tvar temp0 = 0l\n\tvar temp1 = 0l\n\tvar temp2 = 1l\n\
    \tfor (i <- 1l to n) {\n\t    val temp3 = temp0 + temp1 + temp2\n\t    temp0 =\
    \ temp1\n\t    temp1 = temp2\n\t    temp2 = temp3\n\t}\n\ttemp0", "        if\
    \ (n == 0) return 0\n        if (n == 1) return 0\n        if (n == 2) return\
    \ 1\n        var last = 1l\n        var last2 = 0l\n        var last3 = 0l\n \
    \       var result = 0l\n        for (i <- 3l to n) {\n            result = last\
    \ + last2 + last3\n            last3 = last2\n            last2 = last\n     \
    \       last = result\n        }\n        return result", "        var memo :\
    \ HashMap[Long, Long] = HashMap()\n        def recurse(n : Long) : Long = {\n\
    \            if (memo.contains(n)) return memo(n)\n            val result = if\
    \ (n <= 2) 1 else recurse(n - 1) + recurse(n - 2) + recurse(n - 3)\n         \
    \   memo += (n -> result)\n            result\n        }\n        recurse(n)",
  "        val fibs = new Array[Long](n.toInt + 1)\n        fibs(0) = 0\n        fibs(1)\
    \ = 0\n        fibs(2) = 1\n        for (i <- 3 to n.toInt) {\n            fibs(i)\
    \ = fibs(i - 1) + fibs(i - 2) + fibs(i - 3)\n        }\n        fibs(n.toInt)",
  "        def fibfibR(n : Long, a : Long, b : Long, c : Long) : Long = n match {\n\
    \            case 0 => a\n            case 1 => b\n            case 2 => c\n \
    \           case _ => fibfibR(n - 1, b, c, a + b + c)\n        }\n        fibfibR(n,\
    \ 0, 0, 1)", "        // Your Code Here.\n        return 0l", "        // Fill\
    \ up this function body\n        // 'map' is a mutable data structure you can\
    \ use to store previously computed values.\n        // map.getOrElseUpdate(n,\
    \ nth_fibfib_value) \n        // This function returns the value associated with\
    \ n in the map if n is present in the map.\n        // If n is not present in\
    \ the map, it adds the key value pair (n, nth_fibfib_value) to the map and returns\
    \ nth_fibfib_value.\n        val map = HashMap[Long, Long]()\n        def fibfib_iter(i\
    \ : Long) : Long = {\n            if (i == 0 || i == 1) 0\n            else if\
    \ (i == 2) 1\n            else {\n                val fb = map.getOrElseUpdate(i\
    \ - 1, fibfib_iter(i - 1))\n                val fc = map.getOrElseUpdate(i - 2,\
    \ fibfib_iter(i - 2))\n                val fd = map.getOrElseUpdate(i - 3, fibfib_iter(i\
    \ - 3))\n                fb + fc + fd\n            }\n        }\n        fibfib_iter(n)",
  "        // From this problem we can derive a pattern in the fibfib number sequence:\n\
    \        // 0, 0, 1, 1, 4, 5, 11, 15, 26, 37, ...\n        // and the differences\
    \ between successive terms:\n        // 0, 1, 3, 4, 5, 6, 7, 9, 10, 11, ...\n\
    \        // which are the Fibonacci numbers.\n        // The fibfib sequence is\
    \ also known as the Fibonacci numbers in base 3, as all numbers are Fibonacci\
    \ numbers,\n        // but with all digits in base 3, and each digit can be 0,\
    \ 1, or 2.\n        // >>> convert_base((1), (3))\n        // 1\n        // >>>\
    \ convert_base((2), (3))\n        // 10\n        // >>> convert_base((3), (3))\n\
    \        // 11\n        // >>> convert_base((4), (3))\n        // 12\n       \
    \ // >>> convert_base((5), (3))\n        // 20\n        // >>> convert_base((6),\
    \ (3))\n        // 21\n        // >>> convert_base((7), (3))\n        // 22\n\
    \        // >>> convert_base((8), (3))\n        // 100\n        // >>> convert_base((9),\
    \ (3))\n        // 101\n        // >>> convert_base((10), (3))\n        // 102\n\
    \        // Here is a function that converts an integer to a Fibonacci number\
    \ in base 3:\n        def convert_base(n : Long, base : Long) : Long = {\n   \
    \         def helper(n : Long, base : Long, digits : List[Long]) : List[Long]\
    \ = {\n                if (n < base) List(n)\n                else helper(n /\
    \ base, base, n % base :: digits)\n            }\n            helper(n, base,\
    \ Nil).reverse.foldLeft(0l)((a, b) => a * 10 + b)\n        }\n        // To find\
    \ the n-th element of the fibfib sequence, simply convert n to a Fibonacci number\
    \ in base 3,\n        // and then convert it back to base 10.\n        convert_base(convert_base(n,\
    \ 3), 10)", "        def loop(n : Long, a : Long, b : Long, c : Long) : Long =\
    \ if (n == 0) a else loop(n - 1, b, c, a + b + c)\n        loop(n, 0, 0, 1)",
  "        def fibfibR(n : Long, a : Long, b : Long, c : Long) : Long = {\n      \
    \      if (n == 0) a\n            else if (n == 1) b\n            else if (n ==\
    \ 2) c\n            else fibfibR(n - 1, b, c, a + b + c)\n        }\n        fibfibR(n,\
    \ 0, 0, 1)", "        var fibs = ArrayBuffer(0l, 0l, 1l)\n        for (i <- 3\
    \ to n.toInt) {\n            fibs.append(fibs(i - 1) + fibs(i - 2) + fibs(i -\
    \ 3))\n        }\n        fibs(n.toInt)", "        if (n < 0) {\n            return\
    \ 0;\n        }\n        if (n == 0) {\n            return 0;\n        }\n   \
    \     if (n == 1) {\n            return 0;\n        }\n        if (n == 2) {\n\
    \            return 1;\n        }\n        var a : Long = 0;\n        var b :\
    \ Long = 0;\n        var c : Long = 1;\n        var i : Long = 2;\n        while\
    \ (i < n) {\n            {\n                var d : Long = b + c + a;\n      \
    \          a = b;\n                b = c;\n                c = d;\n          \
    \      i += 1;\n            }\n        }\n        return c;", "        if (n ==\
    \ 0) 0\n        else if (n == 1) 0\n        else if (n == 2) 1\n        else fibfib(n\
    \ - 1) + fibfib(n - 2) + fibfib(n - 3)", "        // Your code here\n        n\
    \ match {\n            case n if n <= 1 => 0\n            case n if n == 2 =>\
    \ 1\n            case n => fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n   \
    \     }", "        if (n < 0) throw new IllegalArgumentException(\"Negative n\
    \ not allowed\")\n        var a = 0l\n        var b = 0l\n        var c = 1l\n\
    \        var d = 1l\n        var temp = 0l\n        if (n == 0) return 0\n   \
    \     if (n == 1) return 0\n        if (n == 2) return 1\n        for (i <- 2l\
    \ until n) {\n            temp = a + b + c\n            a = b\n            b =\
    \ c\n            c = d\n            d = temp\n        }\n        d", "       \
    \ // We'll use the same approach here as in the Fibonacci number problem.\n  \
    \      // The matrix\n        // | 1 1 1 |\n        // | 1 0 0 |\n        // |\
    \ 0 1 0 |\n        // has the property that matrix^(n) * | 0 |\n        //   \
    \                                 | 1 |\n        //                          \
    \          | 0 |\n        // equals | F_(n+1) |\n        //        | F_(n)   |\n\
    \        //        | F_(n-1) |\n        // where F_(n) is the n-th Fibonacci number,\
    \ and F_(n+1) is the n-th FibFib number.\n        // Furthermore, the characteristic\
    \ polynomial of the matrix is x^3 - x^2 - x - 1, which has roots\n        // at\
    \ -0.839286755, 0.60653066, and 1.2357, so the matrix is diagonalizable, which\
    \ allows us to use\n        // the same approach as in the Fibonacci number problem\
    \ to compute the n-th FibFib number.\n        val c0 = -0.839286755d\n       \
    \ val c1 = 0.60653066d\n        val c2 = 1.2357d\n        val p0 = 1.0d\n    \
    \    val p1 = -1.0d\n        val p2 = -1.0d\n        val p3 = -1.0d\n        val\
    \ m = new Array[Array[Double]](3)\n        for (i <- 0 until 3) m(i) = new Array[Double](3)\n\
    \        m(0)(0) = c0\n        m(0)(1) = 0.0d\n        m(0)(2) = 0.0d\n      \
    \  m(1)(0) = 0.0d\n        m(1)(1) = c1\n        m(1)(2) = 0.0d\n        m(2)(0)\
    \ = 0.0d\n        m(2)(1) = 0.0d\n        m(2)(2) = c2\n        val mb = new Array[Array[Double]](3)\n\
    \        for (i <- 0 until 3) mb(i) = new Array[Double](3)\n        m", "    \
    \    val fib = new Array[Long](n.toInt + 1)\n        for (i <- 0 to n.toInt) {\n\
    \            if (i == 0) fib(i) = 0\n            else if (i == 1) fib(i) = 0\n\
    \            else if (i == 2) fib(i) = 1\n            else fib(i) = fib(i - 1)\
    \ + fib(i - 2) + fib(i - 3)\n        }\n        fib(n.toInt)", "        // Your\
    \ Code Here\n        if (n == 0) 0\n        else if (n == 1) 0\n        else if\
    \ (n == 2) 1\n        else fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)", " \
    \       // Your Code Here\n        0l", "        def fibfibTail(n : Long, a :\
    \ Long, b : Long, c : Long) : Long = {\n            if (n == 0) a\n          \
    \  else if (n == 1) b\n            else if (n == 2) c\n            else fibfibTail(n\
    \ - 1, b, c, a + b + c)\n        }\n        fibfibTail(n, 0, 0, 1)", "       \
    \ // your code goes here\n        return 0", "    \t(n, n % 3) match {\n    \t\
    \tcase (0, _) => 0\n    \t\tcase (1, _) => 0\n    \t\tcase (2, _) => 1\n    \t\
    \tcase (_, 0) => fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    \t\tcase (_,\
    \ 1) => fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    \t\tcase (_, 2) =>\
    \ fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    \t}", "        // Your Code\
    \ Here\n        var f = new Array[Long](n.toInt + 1)\n        f(0) = 0\n     \
    \   f(1) = 0\n        f(2) = 1\n        for (i <- 3 to n.toInt) {\n          \
    \  f(i) = f(i - 1) + f(i - 2) + f(i - 3)\n        }\n        f(n.toInt)", "  \
    \      //>>> fibfib((8l))\n        //(24l)\n        //>>> fibfib((11l))\n    \
    \    //(67l)\n        //>>> fibfib((16l))\n        //(362l)\n        //>>> fibfib((22l))\n\
    \        //(1741l)\n        //>>> fibfib((34l))\n        //(25047l)\n        //>>>\
    \ fibfib((38l))\n        //(36481l)\n        //>>> fibfib((46l))\n        //(102051l)\n\
    \        //>>> fibfib((58l))\n        //(349391l)\n        //>>> fibfib((72l))\n\
    \        //(1184040l)\n        //>>> fibfib((90l))\n        //(4522884l)\n   \
    \     //>>> fibfib((110l))\n        //(16472661l)\n        //>>> fibfib((136l))\n\
    \        //(74099191l)\n        //>>> fibfib((168l))\n        //(327766613l)\n\
    \        //>>> fibfib((206l))\n        //(1617216901l)\n        //>>> fibfib((254l))\n\
    \        //(8643059324l)\n        //>>> fibfib((314l))\n        //(45351071937l)\n\
    \        //>>> fibfib((390l))\n        //(246257266456l)\n        //>>> fibfib((486l))\n\
    \        //(1408115833507l)\n        //>>> fibfib((608l))\n        //(8180285096701l)\n\
    \        //>>> fibfib((764l))\n        //(48495262355443l)\n        //>>> fibfib((964l))\n\
    \        //(299475665739569l)\n        //>>> fibfib((1222l))\n        //(1971037408900340l)\n\
    \        //>>> fibfib((1550l))\n        //(13393947613048236l)\n        //>>>\
    \ fibfib((1980l))\n        //(95451328487358230l)\n        //", "        def f(n\
    \ : Long, seq : Array[Long]) : Long = {\n            if (n <= 2) 0\n         \
    \   else {\n                if (seq(n.toInt) == 0) {\n                    seq(n.toInt)\
    \ = f(n - 1, seq) + f(n - 2, seq) + f(n - 3, seq)\n                }\n       \
    \         seq(n.toInt)\n            }\n        }\n        f(n, Array.fill(n.toInt\
    \ + 1)(0))", "        // Your code here\n        return 0l", "        def fibfib_helper(n\
    \ : Long, last3 : List[Long]) : Long = {\n            if (n == 0) last3(0)\n \
    \           else if (n == 1) last3(1)\n            else if (n == 2) last3(2)\n\
    \            else fibfib_helper(n - 1, (last3(1) + last3(2) + last3(0)) :: last3)\n\
    \        }\n        fibfib_helper(n, List(0, 0, 1))", "        def fibfibHelper(n\
    \ : Long, previousLast : Long, last : Long, twoBack : Long) : Long = {\n     \
    \       if (n == 0) 0\n            else if (n == 1) 0\n            else if (n\
    \ == 2) 1\n            else fibfibHelper(n - 1, last, last + twoBack + previousLast,\
    \ last)\n        }\n        fibfibHelper(n, 0, 1, 0)", "\t\t// Fill Up this function\
    \ body\n                // You can add another function as well, if required\n\
    \t\tif(n == 0) return 0\n\t\telse if(n == 1) return 0\n\t\telse if(n == 2) return\
    \ 1\n\t\telse return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\t}\n    //Given\
    \ a string, find the longest substring that contains only two unique characters.\
    \ For example, given \"abcbbbbcccbdddadacb\", the longest substring that contains\
    \ 2 unique character is \"bcbbbbcccb\".\n    def longestSubStr(s : String) : String\
    \ = {\n\t\t// Fill Up this function body\n                // You can add another\
    \ function as well, if required\n                val subStr = new HashMap[Int,String]()\n\
    \                var max = \"\"\n                for(i <- 0 to s.length-1){\n\
    \                  var j = i+1\n                  while(j < s.length){\n     \
    \               val substr = s.substring(i,j)\n                    val temp =\
    \ substr.toSet\n                    if(temp.size == 2){\n                    \
    \  subStr += (substr.length -> substr)\n                    }\n              \
    \      j += 1\n                  }\n                }\n                if(subStr.size\
    \ > 0){\n                  max = subStr.get(subStr.keys.max).get\n           \
    \     }\n                max\n\t}\n    //Given a string, find the length of the\
    \ longest substring without repeating characters. For example, the longest substring\
    \ without repeating letters for \"abcabcbb\" is \"abc\", which the length is 3.\
    \ For \"bbbbb\" the longest substring is \"b\", with the length of 1.\n    def\
    \ longestSubStr2(s : String) : String = {\n\t\t// Fill Up this function body\n\
    \                // You can add another function as well, if required\n      \
    \          var max = \"\"\n                for(i <- 0 to s.length-1){\n      \
    \            var j = i+1\n                  while(j < s.length){\n           \
    \         val substr = s.substring(i,j)\n                    val temp = substr.toSet\n\
    \                    if(temp.size == substr.length && substr.length > max.length",
  "        var a = 0l\n        var b = 0l\n        var c = 1l\n        var i = 2l\n\
    \        while (i <= n) {\n            var d = a + b + c\n            a = b\n\
    \            b = c\n            c = d\n            i += 1\n        }\n       \
    \ return c", "        // Your Code Here\n        0", "        // Implement me!\n\
    \        return 0", "        // Your code here\n        return 0", "        n\
    \ match {\n            case 0 => 0\n            case 1 => 0\n            case\
    \ 2 => 1\n            case _ => fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n\
    \        }", "        // Implement me!\n        0", "        var a = 0l\n    \
    \    var b = 0l\n        var c = 1l\n        var d = 0l\n        var i = 2l\n\
    \        while (i <= n) {\n            d = a + b + c\n            a = b\n    \
    \        b = c\n            c = d\n            i += 1\n        }\n        return\
    \ d", "        // fill in the code here\n        def fibfib(n : Long, cache :\
    \ Array[Long]) : Long = {\n            if (n <= 1) 0\n            else if (n ==\
    \ 2) 1\n            else if (cache(n.toInt) != 0) cache(n.toInt)\n           \
    \ else {\n                val result = fibfib(n - 1, cache) + fibfib(n - 2, cache)\
    \ + fibfib(n - 3, cache)\n                cache(n.toInt) = result\n          \
    \      result\n            }\n        }\n        fibfib(n, Array.fill(n.toInt\
    \ + 1)(0l))", "        return n match {\n            case 0l => 0l\n         \
    \   case 1l => 0l\n            case 2l => 1l\n            case _ => fibfib(n -\
    \ 1) + fibfib(n - 2) + fibfib(n - 3)\n        }", "        // We'll use bottom-up\
    \ dynamic programming to solve this problem.\n        // dp[i] = the i-th FibFib\
    \ number\n        val dp = Array.fill(n.toInt + 1)(0L)\n        // base cases\n\
    \        dp(0) = 0\n        dp(1) = 0\n        dp(2) = 1\n        // bottom-up\
    \ dynamic programming\n        for (i <- 3 to n.toInt) {\n            dp(i) =\
    \ dp(i - 1) + dp(i - 2) + dp(i - 3)\n        }\n        dp(n.toInt)", "      \
    \  // Your code here\n        if (n == 0) 0 else if (n == 1) 0 else if (n == 2)\
    \ 1 else fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)", "        // Your Code\
    \ Here\n        return 1", "        if (n == 0) return 0\n        if (n == 1)\
    \ return 0\n        if (n == 2) return 1\n        var a = 0l\n        var b =\
    \ 0l\n        var c = 1l\n        for (i <- 3 to n.toInt) {\n            val d\
    \ = a + b + c\n            a = b\n            b = c\n            c = d\n     \
    \   }\n        return c", "        // Your code here\n        return 0", "   \
    \     def fibfib_helper(n : Long, s : List[Long]) : Long = {\n            if (n\
    \ == 0) {\n                s.head\n            } else {\n                val next\
    \ = s.take(3).sum\n                fibfib_helper(n - 1, next :: s)\n         \
    \   }\n        }\n        fibfib_helper(n, List(0, 0, 1))", "        // Your code\
    \ here\n        val dp = Array.fill(n.toInt+1)(0l)\n        for (i <- 0 to n.toInt)\
    \ {\n            if (i <= 1) dp(i) = 0\n            else if (i == 2) dp(i) = 1\n\
    \            else dp(i) = dp(i-1) + dp(i-2) + dp(i-3)\n        }\n        dp(n.toInt)",
  "        // Your Code Here\n        return 0", "        // Your code here\n    \
    \    def fibfib_t(n : Long, prev1 : Long, prev2 : Long, prev3 : Long) : Long =\
    \ {\n            if (n == 0) prev1\n            else if (n == 1) prev2\n     \
    \       else if (n == 2) prev3\n            else fibfib_t(n - 1, prev2, prev3,\
    \ prev1 + prev2 + prev3)\n        }\n        fibfib_t(n, 0, 0, 1)", "        if\
    \ (n < 2) 0\n        else if (n == 2) 1\n        else fibfib(n - 1) + fibfib(n\
    \ - 2) + fibfib(n - 3)", "        // Your code here.\n        def loop(n : Long,\
    \ acc : List[Long]) : Long = {\n            n match {\n                case 1\
    \ => acc(0)\n                case 2 => acc(1)\n                case _ => loop(n\
    \ - 1, acc.takeRight(3).sum :: acc)\n            }\n        }\n        loop(n,\
    \ List(0l, 0l, 1l))", "        var fib : Array[Long] = Array.fill(3)(0)\n    \
    \    var i = 2\n        while (i <= n) {\n            fib = Array(fib(2), fib(0)\
    \ + fib(1) + fib(2), fib(1))\n            i += 1\n        }\n        fib(1)",
  "        // Fill Up this function body\n        // `0` is already implemented for\
    \ you\n        var a:Long = 0\n        var b:Long = 0\n        var c:Long = 1\n\
    \        if(n==0){\n            a\n        }\n        else if(n==1){\n       \
    \     b\n        }\n        else{\n            for(i <- 2l to n){\n          \
    \      var d:Long = a+b+c\n                a = b\n                b = c\n    \
    \            c = d\n            }\n            c\n        }", "        // Your\
    \ code here\n        0l", "        val m = n - 1\n        val l = n - 2\n    \
    \    val k = n - 3\n        if (m == 0) 0\n        else if (m == 1) 0\n      \
    \  else if (m == 2) 1\n        else fibfib(m) + fibfib(l) + fibfib(k)", "    \
    \    if (n == 0) {\n            0\n        } else if (n == 1) {\n            0\n\
    \        } else if (n == 2) {\n            1\n        } else {\n            fibfib(n\
    \ - 1) + fibfib(n - 2) + fibfib(n - 3)\n        }", "        // Your code here\n\
    \        return n", "        // Your Code Here\n        0", "        var a = 0l\n\
    \        var b = 0l\n        var c = 1l\n        var d = 1l\n        var e = 1l\n\
    \        var i = 2l\n        while (i <= n) {\n            val f = a + b + c\n\
    \            a = b\n            b = c\n            c = d\n            d = e\n\
    \            e = f\n            i += 1\n        }\n        return e", "      \
    \  def run(n : Long, a : Long, b : Long, c : Long) : Long = {\n            if\
    \ (n == 0) a\n            else if (n == 1) b\n            else if (n == 2) c\n\
    \            else run(n - 1, b, c, a + b + c)\n        }\n        run(n, 0, 0,\
    \ 1)", "        // Your code here.\n        n match {\n            case 0 => 0\n\
    \            case 1 => 0\n            case 2 => 1\n            case _ => fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\n        }", "        // Fill up this function body\n\
    \        // You can add another function as well, if required", "        // Your\
    \ code here.\n        val a = ArrayBuffer[Long](0, 0, 1)\n        if (n <= 3)\
    \ return a(n.toInt - 1)\n        else {\n            for (i <- 3 to n.toInt) {\n\
    \                a += a(i - 1) + a(i - 2) + a(i - 3)\n            }\n        \
    \    return a(n.toInt - 1)\n        }", "        // Your Code Here\n        (0l)",
  "        def iter(n : Long, a : Long, b : Long, c : Long) : Long = {\n         \
    \   if (n == 0) a\n            else if (n == 1) b\n            else if (n == 2)\
    \ c\n            else iter(n - 1, b, c, a + b + c)\n        }\n        iter(n,\
    \ 0, 0, 1)", "        // TODO\n        return 0", "        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ def fibfibhelp(n : Long, a : Long, b : Long, c : Long) : Long = {\n        \
    \    if (n == 0) a\n            else if (n == 1) b\n            else if (n ==\
    \ 2) c\n            else fibfibhelp(n - 1, b, c, a + b + c)\n        }\n     \
    \   fibfibhelp(n, 0, 0, 1)", "        // Fill up this function body\n        //\
    \ You can add another function as well, if required\n        1", '        ???',
  "        // fill this in\n        return 0;", "        def f(n : Long, a : Long,\
    \ b : Long, c : Long) : Long = {\n            if (n == 0) a\n            else\
    \ if (n == 1) b\n            else if (n == 2) c\n            else f(n - 1, b,\
    \ c, a + b + c)\n        }\n        f(n, 0, 0, 1)", "        var fibs = new Array[Long](2)\n\
    \        if (n == 0) return 0\n        if (n == 1) return 0\n        if (n ==\
    \ 2) return 1\n        fibs(0) = 0\n        fibs(1) = 1\n        var i = 3\n \
    \       while (i <= n) {\n            val next = fibs(0) + fibs(1) + (i - 3)\n\
    \            fibs(0) = fibs(1)\n            fibs(1) = next\n            i += 1\n\
    \        }\n        fibs(1)", "        require(n >= 0)\n        val result = n\
    \ match {\n            case 0l => 0l\n            case 1l => 0l\n            case\
    \ 2l => 1l\n            case _ =>\n                var a : Long = 0l\n       \
    \         var b : Long = 0l\n                var c : Long = 1l\n             \
    \   for (i <- 3l to n) {\n                    val d = a + b + c\n            \
    \        a = b\n                    b = c\n                    c = d\n       \
    \         }\n                c\n        }\n        result", "        var i = 0;\n\
    \        var j = 0;\n        var k = 1;\n        for (x <- 2 until n.toInt) {\n\
    \            val l = j + k + i;\n            i = j;\n            j = k;\n    \
    \        k = l;\n        }\n        return k;", "        def fibfib_rec(n : Long,\
    \ a : Long, b : Long, c : Long) : Long = {\n            if (n == 0) a\n      \
    \      else if (n == 1) b\n            else if (n == 2) c\n            else fibfib_rec(n\
    \ - 1, b, c, a + b + c)\n        }\n        fibfib_rec(n, 0, 0, 1)", "       \
    \ // Your Code Here\n        null", "        // Fill up this function body\n \
    \       // 'n' is the n-th element of the sequence that your function has to compute\n\
    \        val fib = new Array[Long](n.toInt+1)\n        fib(0) = 0\n        fib(1)\
    \ = 0\n        fib(2) = 1\n        for (i <- 3 to n.toInt) {\n          fib(i)\
    \ = fib(i-1) + fib(i-2) + fib(i-3)\n        }\n        fib(n.toInt)", "\tvar a\
    \ = 0l\n\tvar b = 0l\n\tvar c = 1l\n\tfor (i <- 2l to n) {\n\t    var d = a +\
    \ b + c\n\t    a = b\n\t    b = c\n\t    c = d\n\t}\n\tc", "        var f = ArrayBuffer[Long](0,\
    \ 0, 1)\n        for (i <- 3 to n.toInt) {\n            f.append(f(i - 1) + f(i\
    \ - 2) + f(i - 3))\n        }\n        f(n.toInt)", "        var first = 0l\n\
    \        var second = 0l\n        var third = 1l\n        if (n <= 2) {\n    \
    \        if (n == 0) 0l\n            else 1l\n        }\n        else {\n    \
    \        var i = 0l\n            while (i < n - 2) {\n                first =\
    \ second\n                second = third\n                third = first + second\
    \ + third\n                i += 1\n            }\n            third\n        }",
  "        if (n < 3) n\n        else {\n            var n1 = 0L\n            var\
    \ n2 = 0L\n            var n3 = 1L\n            var nn = 0L\n            for (i\
    \ <- 3 to n.toInt) {\n                nn = n1 + n2 + n3\n                n1 =\
    \ n2\n                n2 = n3\n                n3 = nn\n            }\n      \
    \      nn\n        }", "        var a = 0l\n        var b = 0l\n        var c\
    \ = 1l\n        var d = 1l\n        val m = n\n        if (n <= 0) a\n       \
    \ else if (n == 1) b\n        else if (n == 2) c\n        else {\n           \
    \ for (i <- 0 to m.toInt - 2) {\n                a = b\n                b = c\n\
    \                c = d\n                d = a + b + c\n            }\n       \
    \     d\n        }", "        // We can solve this problem using linear algebra.\
    \ The transformation matrix for the fibfib sequence is:\n        // M = |0 1 1|\n\
    \        //     |1 0 1|\n        //     |1 1 0|\n        // We can compute powers\
    \ of this matrix recursively to get the n-th transformation matrix.\n        //\
    \ T(n) = T(n - 1) * M\n        // We can then derive the n-th fibfib number by\
    \ multiplying T(n) by the zero matrix using a dot product.\n        val M = Array(Array(0l,\
    \ 1l, 1l), Array(1l, 0l, 1l), Array(1l, 1l, 0l))\n        def mult(A : Array[Array[Long]],\
    \ B : Array[Array[Long]]) : Array[Array[Long]] = {\n            // Multiply two\
    \ matrices of size 3 by 3.\n            var C = Array.ofDim[Long](3, 3)\n    \
    \        for (i <- 0 to 2) {\n                for (j <- 0 to 2) {\n          \
    \          for (k <- 0 to 2) {\n                        C(i)(j) += A(i)(k) * B(k)(j)\n\
    \                    }\n                }\n            }\n            C\n    \
    \    }\n        def identity() : Array[Array[Long]] = {\n            // The identity\
    \ matrix for a 3 by 3 matrix.\n            Array(Array(1l, 0l, 0l), Array(0l,\
    \ 1l, 0l), Array(0l, 0l, 1l))\n        }\n        def pow(M : Array[Array[Long]],\
    \ n : Long) : Array[Array[Long]] = {\n            // Compute the n-th power of\
    \ the transformation matrix.\n            if (n == 0) return identity()\n    \
    \        if (n == 1) return M\n            val A = pow(M, n / 2)\n           \
    \ val B = mult(A, A)\n            if (n % 2 == 0) return B\n            else return\
    \ mult(B, M)\n        }\n        val T = pow(M, n)\n        T(0)(0) + T(0)(1)\
    \ + T(0)(2)", "        if (n == 0) return 0\n        if (n == 1) return 0\n  \
    \      if (n == 2) return 1\n        var a = 0l\n        var b = 0l\n        var\
    \ c = 1l\n        for (i <- 3 to n.toInt) {\n            val d = a + b + c\n \
    \           a = b\n            b = c\n            c = d\n        }\n        return\
    \ c", "        n match {\n            case 0 => 0\n            case 1 => 0\n \
    \           case 2 => 1\n            case _ => fibfib(n - 1) + fibfib(n - 2) +\
    \ fibfib(n - 3)\n        }", "        // Fill up this function body\n        //\
    \ 'n' is the n-th element in the sequence that your function has to compute\n\
    \        var fib:Vector[Long] = Vector(0,0,1)\n        for(i <- 3 to n.toInt)\
    \ {\n            fib = fib :+ (fib(i-1) + fib(i-2) + fib(i-3))\n        }\n  \
    \      return fib(n.toInt)", "        val cache = new Array[Long](n.toInt + 1)\n\
    \        def fib(n : Long) : Long = {\n            var a = 0l\n            var\
    \ b = 0l\n            var c = 1l\n            var d = 0l\n            var e =\
    \ 0l\n            var i = 0l\n            if (n <= 1) 0\n            else if (n\
    \ == 2) 1\n            else {\n                while (i < n - 2) {\n         \
    \           d = a + b + c\n                    a = b\n                    b =\
    \ c\n                    c = d\n                    i += 1\n                }\n\
    \                c\n            }\n        }\n        fib(n)", "        // Fill\
    \ up this function body\n        // 'n' is the argument that means the n-th element\
    \ of the fibfib number sequence.\n        // You have to return the n-th element\
    \ of the fibfib number sequence.\n        var a = 0l\n        var b = 0l\n   \
    \     var c = 1l\n        for (i <- 3l to n) {\n        \ta = b\n        \tb =\
    \ c\n        \tc = a + b + c\n        }\n        return c", "        if (n ==\
    \ 0) return 0\n        if (n == 1) return 0\n        if (n == 2) return 1\n  \
    \      var k = 2;\n        var fn_2 = 0;\n        var fn_1 = 1;\n        var fn\
    \ = 1;\n        while (k < n) {\n            fn = fn_1 + fn_2 + fn;\n        \
    \    fn_2 = fn_1;\n            fn_1 = fn;\n            k = k + 1;\n        }\n\
    \        return fn;", "        var mem = new Array[Long](n.toInt)\n        def\
    \ fibfibHelper(n : Long) : Long = {\n            if (n == 0) return 0\n      \
    \      if (n == 1) return 0\n            if (n == 2) return 1\n            if\
    \ (mem(n.toInt - 1) != 0) return mem(n.toInt - 1)\n            var res = fibfibHelper(n\
    \ - 1) + fibfibHelper(n - 2) + fibfibHelper(n - 3)\n            mem(n.toInt -\
    \ 1) = res\n            return res\n        }\n        fibfibHelper(n)", "   \
    \     // Fill in the code here\n        return 0;", "        // Your code here\n\
    \        fibfib_helper(n, 0, 0, 1)", "        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        0l", " \
    \       var a = 0l\n        var b = 0l\n        var c = 1l\n        for (i <-\
    \ 3l to n) {\n            val d = a + b + c\n            a = b\n            b\
    \ = c\n            c = d\n        }\n        c", "        def recursion(a : Long,\
    \ b : Long, c : Long, idx : Long) : Long = {\n            if (idx == n) a\n  \
    \          else recursion(b, c, a + b + c, idx + 1)\n        }\n        recursion(0,\
    \ 0, 1, 3)", "        var u = 0l\n        var v = 0l\n        var w = 1l\n   \
    \     var t = 1l\n        for (i <- 3l to n) {\n            t = u + v + w\n  \
    \          u = v\n            v = w\n            w = t\n        }\n        t",
  "        if (n == 0) 0\n        else if (n == 1) 0\n        else if (n == 2) 1\n\
    \        else fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)", "        val nums\
    \ = new Array[Long](3)\n        for (i <- 0 until 3) nums(i) = 0\n        for\
    \ (i <- 3 to n.toInt) {\n            nums(i % 3) = nums(0) + nums(1) + nums(2)\n\
    \        }\n        return nums(n.toInt % 3)", "        if (n == 0) 0\n      \
    \  else if (n == 1) 0\n        else if (n == 2) 1\n        else fibfib(n - 1)\
    \ + fibfib(n - 2) + fibfib(n - 3)", "        // Implement me!\n        if (n <=\
    \ 0) return 0\n        if (n == 1) return 0\n        if (n == 2) return 1\n  \
    \      return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)", "        if (n ==\
    \ 0 || n == 1) return 0\n        if (n == 2) return 1\n        var a = 0l\n  \
    \      var b = 0l\n        var c = 1l\n        for (i <- 3 to n.toInt) {\n   \
    \         val next = a + b + c\n            a = b\n            b = c\n       \
    \     c = next\n        }\n        c", "        def fibfib_helper(n : Long, m\
    \ : Long, k : Long, s : Long) : Long = {\n            if (n == k) s\n        \
    \    else if (k > n) 0\n            else fibfib_helper(n, m, k + 1, s + m + k)\n\
    \        }\n        fibfib_helper(n, 0, 0, 0)", "        // Insert code here\n\
    \        0", "        val buf = new ArrayBuffer[Long]\n        buf += 0\n    \
    \    buf += 0\n        buf += 1\n        for (i <- 3 to n.toInt) {\n         \
    \   buf += buf(i - 1) + buf(i - 2) + buf(i - 3)\n        }\n        buf(n.toInt)",
  "        var a = 0l\n        var b = 0l\n        var c = 1l\n        for (i <- 1l\
    \ to n) {\n            var temp = a + b + c\n            a = b\n            b\
    \ = c\n            c = temp\n        }\n        return a", "        var buf =\
    \ ArrayBuffer[Long](0, 0, 1)\n        for (i <- 3 to n.toInt) {\n            buf\
    \ += buf(i - 1) + buf(i - 2) + buf(i - 3)\n        }\n        buf(n.toInt)", '        return
    0l', "        var v2 = 0l\n        var v1 = 0l\n        var v0 = 1l\n        for\
    \ (i <- 1 to n.toInt) {\n            val v = v2 + v1 + v0\n            v2 = v1\n\
    \            v1 = v0\n            v0 = v\n        }\n        v2", "        if\
    \ (n == 0) return 0\n        if (n == 1) return 0\n        if (n == 2) return\
    \ 1\n        var a = 0l\n        var b = 0l\n        var c = 1l\n        for (i\
    \ <- 3 to n.toInt) {\n            val d = a + b + c\n            a = b\n     \
    \       b = c\n            c = d\n        }\n        return c", "        // Fill\
    \ up this function body\n        // 'n' is the nth element in the fibfib sequence\n\
    \        // you need to return the nth element in the fibfib sequence\n      \
    \  var n0 = 0l\n        var n1 = 0l\n        var n2 = 1l\n        var n3 = 0l\n\
    \        if (n < 3) {\n            return n\n        }\n        else {\n     \
    \       var i = 3l\n            while (i <= n) {\n                n3 = n0 + n1\
    \ + n2\n                n0 = n1\n                n1 = n2\n                n2 =\
    \ n3\n                i += 1\n            }\n            return n3\n        }",
  "        // Implement this function\n        0", "        // Your answer here.\n\
    \        var arr = Array(0l, 0l, 1l)\n        for (i <- 3 to n.toInt) {\n    \
    \        arr(0) = arr(1)\n            arr(1) = arr(2)\n            arr(2) = arr(1)\
    \ + arr(0) + arr(2)\n        }\n        return arr(2)", '        if (n < 3) n
    else fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)', "        // Your code here.\n\
    \        if (n == 0) 0\n        else if (n == 1) 0\n        else if (n == 2) 1\n\
    \        else fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)", "        var a =\
    \ 0l\n        var b = 0l\n        var c = 1l\n        for (i <- 3l to n) {\n \
    \           val d = a + b + c\n            a = b\n            b = c\n        \
    \    c = d\n        }\n        c", "        // Your code here\n        return\
    \ 0", "        var a = 0L\n        var b = 0L\n        var c = 1L\n        var\
    \ d = 0L\n        var i = 0L\n        while (i < n) {\n            d = a + b +\
    \ c\n            a = b\n            b = c\n            c = d\n            i +=\
    \ 1\n        }\n        return d", "        def _fibfib(n : Long, cache : Array[Long])\
    \ : Long = {\n            if (n <= 2) 0\n            else if (n == 3) 1\n    \
    \        else if (cache(n.toInt) != 0) cache(n.toInt)\n            else {\n  \
    \              cache(n.toInt) = _fibfib(n - 1, cache) + _fibfib(n - 2, cache)\
    \ + _fibfib(n - 3, cache)\n                cache(n.toInt)\n            }\n   \
    \     }\n        _fibfib(n, Array.fill(n.toInt + 1)(0))", "        // Your code\
    \ here\n        (0l)", "        if (n == 0) 0\n        else if (n == 1) 0\n  \
    \      else if (n == 2) 1\n        else fibfib(n - 1) + fibfib(n - 2) + fibfib(n\
    \ - 3)", "        var a = 0L\n        var b = 0L\n        var c = 1L\n       \
    \ var i = 2L\n        while (i <= n) {\n            var d = b + c + a\n      \
    \      a = b\n            b = c\n            c = d\n            i += 1\n     \
    \   }\n        return c", "        // Your code here\n        return n", "   \
    \     def fibfib_helper(n : Long, nMinus1 : Long, nMinus2 : Long, nMinus3 : Long)\
    \ : Long = {\n            if (n == 0) {\n                nMinus3\n           \
    \ } else {\n                fibfib_helper(n - 1, nMinus1 + nMinus2 + nMinus3,\
    \ nMinus1, nMinus2)\n            }\n        }\n        fibfib_helper(n, 0, 0,\
    \ 1)", "        // Your code here\n        (0l)", '      ???', "        if (n\
    \ < 3) n\n        else {\n            var n_1 = 0l\n            var n_2 = 1l\n\
    \            var n_3 = 0l\n            var r = 0l\n            for (i <- 3l to\
    \ n) {\n                r = n_1 + n_2 + n_3\n                n_3 = n_2\n     \
    \           n_2 = n_1\n                n_1 = r\n            }\n            r\n\
    \        }", "        // If a number is a FibFib number we just return it\n  \
    \      if (n == 0) return 0\n        if (n == 1) return 0\n        if (n == 2)\
    \ return 1\n        // Otherwise we use a 3-element rolling buffer to compute\
    \ the result\n        var a : Long = 0\n        var b : Long = 0\n        var\
    \ c : Long = 1\n        for (i <- 3 to n.toInt) {\n            var current = a\
    \ + b + c\n            a = b\n            b = c\n            c = current\n   \
    \     }\n        return c", "        if (n == 0) return 0\n        if (n == 1)\
    \ return 0\n        if (n == 2) return 1\n        var n_minus_1 = 1l\n       \
    \ var n_minus_2 = 1l\n        var n_minus_3 = 0l\n        var i = 3l\n       \
    \ while (i <= n) {\n            var prev_n_minus_1 = n_minus_1\n            n_minus_1\
    \ = n_minus_1 + n_minus_2 + n_minus_3\n            n_minus_3 = n_minus_2\n   \
    \         n_minus_2 = prev_n_minus_1\n            i += 1\n        }\n        return\
    \ n_minus_1", "        def fibfib(n : Long, p3 : Long, p2 : Long, p1 : Long) :\
    \ Long = n match {\n            case 0 => p3\n            case 1 => p2\n     \
    \       case 2 => p1\n            case _ => fibfib(n - 1, p2, p1, p3 + p2 + p1)\n\
    \        }\n        fibfib(n, 0, 0, 1)", "        if (n == 0) 0\n        else\
    \ if (n == 1) 0\n        else if (n == 2) 1\n        else fibfib(n - 1) + fibfib(n\
    \ - 2) + fibfib(n - 3)", "\t\tval (a, b, c) = (0l, 0l, 1l)\n\t\tdef aux(n : Long,\
    \ a : Long, b : Long, c : Long) : Long = n match {\n\t\t\tcase 0 => a\n\t\t\t\
    case 1 => b\n\t\t\tcase 2 => c\n\t\t\tcase _ => aux(n - 1, b, c, a + b + c)\n\t\
    \t}\n\t\taux(n, a, b, c)", "        var c = Array(0, 0, 1)\n        for (i <-\
    \ 3 to n.toInt) {\n            c(0) = c(1)\n            c(1) = c(2)\n        \
    \    c(2) = c(0) + c(1) + c(2)\n        }\n        c(2)", "      def rec(x : Long,\
    \ prevprev : Long, prev : Long) : Long = if (x == n) prevprev + prev else rec(x\
    \ + 1, prev, prevprev + prev)\n      if (n == 0) 0 else if (n == 1) 0 else if\
    \ (n == 2) 1 else rec(3, 0, 1)", "        if (n == 0) return 0;\n        if (n\
    \ == 1) return 0;\n        if (n == 2) return 1;\n        var index = 3;\n   \
    \     var a = 1;\n        var b = 0;\n        var c = 0;\n        while (index\
    \ <= n) {\n            val tmp = c;\n            c = a + b + c;\n            b\
    \ = a;\n            a = tmp;\n            index += 1;\n        }\n        return\
    \ c;", "        // Your Code Here\n        return n", "        var a = 0L\n  \
    \      var b = 0L\n        var c = 1L\n        var index = 1L\n        while (index\
    \ < n) {\n            val tmp = a + b + c\n            a = b\n            b =\
    \ c\n            c = tmp\n            index += 1\n        }\n        c", "   \
    \     def fibfibHelper(n : Long, a : Long, b : Long, c : Long) : Long = n match\
    \ {\n            case 0 => a\n            case 1 => b\n            case 2 => c\n\
    \            case _ => fibfibHelper(n - 1, b, c, a + b + c)\n        }\n     \
    \   fibfibHelper(n, 0, 0, 1)", "        if (n == 0) {\n            0\n       \
    \ } else if (n == 1) {\n            0\n        } else if (n == 2) {\n        \
    \    1\n        } else {\n            fibfib(n - 1) + fibfib(n - 2) + fibfib(n\
    \ - 3)\n        }", "        var fibfib = ArrayBuffer[Long](0l, 0l, 1l)\n    \
    \    if (n < 2) return fibfib(n.toInt)\n        var index = 2\n        while (index\
    \ < n) {\n            val total = fibfib(index - 1) + fibfib(index - 2) + fibfib(index\
    \ - 3)\n            fibfib += total\n            index += 1\n        }\n     \
    \   fibfib(n.toInt)", "        // Fill up this function body\n        // You can\
    \ add another function as well, if required\n        if (n == 0) {\n         \
    \   return 0\n        }\n        if (n == 1) {\n            return 0\n       \
    \ }\n        if (n == 2) {\n            return 1\n        }\n        var ans :\
    \ Long = 0\n        var temp1 : Long = 0\n        var temp2 : Long = 1\n     \
    \   var temp3 : Long = 1\n        var i : Long = 3\n        while (i <= n) {\n\
    \            ans = temp1 + temp2 + temp3\n            temp1 = temp2\n        \
    \    temp2 = temp3\n            temp3 = ans\n            i += 1\n        }\n \
    \       return ans", "        if (n < 0)\n            return -1\n        else\
    \ if (n == 0)\n            return 0\n        else if (n == 1)\n            return\
    \ 0\n        else if (n == 2)\n            return 1\n        else {\n        \
    \    var prev : Long = 1\n            var prevPrev : Long = 0\n            var\
    \ current : Long = 2\n            for (i <- 3 to n.toInt) {\n                var\
    \ temp = current\n                current = current + prev + prevPrev\n      \
    \          prevPrev = prev\n                prev = temp\n            }\n     \
    \       return current\n        }", "        // Your Code Here\n        var a\
    \ = 0\n        var b = 0\n        var c = 1\n        var d = 0\n        for (i\
    \ <- 0 to n.toInt - 1) {\n            d = a + b + c\n            a = b\n     \
    \       b = c\n            c = d\n        }\n        d", "        // Fill in the\
    \ implementation of this method\n        if (n == 0) 0\n        else if (n ==\
    \ 1) 0\n        else if (n == 2) 1\n        else fibfib(n-1) + fibfib(n-2) + fibfib(n-3)",
  "        if (n == 0) return 0\n        if (n == 1) return 0\n        if (n == 2)\
    \ return 1\n        var a = 0l\n        var b = 0l\n        var c = 1l\n     \
    \   for (i <- 3 to n.toInt) {\n            var d = a + b + c\n            a =\
    \ b\n            b = c\n            c = d\n        }\n        return c", "   \
    \     // Your code here\n        0l", "        var a = 0L\n        var b = 0L\n\
    \        var c = 1L\n        var i = 2L\n        while (i <= n) {\n          \
    \  val d = a + b + c\n            a = b\n            b = c\n            c = d\n\
    \            i += 1\n        }\n        c", '        0L', "        if (n == 0)\
    \ 0\n        else if (n == 1) 0\n        else if (n == 2) 1\n        else fibfib(n\
    \ - 1) + fibfib(n - 2) + fibfib(n - 3)", "        // Good luck!\n        null",
  "        if (n == 0) 0\n        else if (n == 1) 0\n        else if (n == 2) 1\n\
    \        else fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)", '        ???', " \
    \       if (n < 3) 0\n        else if (n == 3) 1\n        else {\n           \
    \ var prevPrev = 1L\n            var prev = 1L\n            var sum = 2L\n   \
    \         for (i <- 3 to n.toInt) {\n                val curr = prevPrev + prev\
    \ + sum\n                prevPrev = prev\n                prev = sum\n       \
    \         sum = curr\n            }\n            sum\n        }", "        if\
    \ (n == 0) {\n            0\n        } else if (n == 1) {\n            0\n   \
    \     } else if (n == 2) {\n            1\n        } else {\n            fibfib(n\
    \ - 1) + fibfib(n - 2) + fibfib(n - 3)\n        }", '        // Fill in the code
    here.', "        var a = 0l\n        var b = 0l\n        var c = 1l\n        var\
    \ d = 0l\n        for (i <- 0l until n) {\n            d = a + b + c\n       \
    \     a = b\n            b = c\n            c = d\n        }\n        return d",
  "        if (n == 0) 0\n        else if (n == 1) 0\n        else if (n == 2) 1\n\
    \        else fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)", "        // Your\
    \ Code Here\n        return -1", "        val s = ArrayBuffer.fill(3)(0l)\n  \
    \      for (i <- 0 until n) {\n            s(0) = s(1) + s(2)\n            s(2)\
    \ = s(1)\n            s(1) = s(0)\n        }\n        s(2)", "        var fibs\
    \ = new Array[Long](3)\n        fibs(0) = 0\n        fibs(1) = 0\n        fibs(2)\
    \ = 1\n        (2l to n).foreach(i => {\n            fibs(i.toInt % 3) = fibs((i\
    \ - 1).toInt % 3) + fibs((i - 2).toInt % 3) + fibs((i - 3).toInt % 3)\n      \
    \  })\n        fibs(n.toInt % 3)", '        ???', "        if (n == 0) {\n   \
    \         0\n        } else if (n == 1) {\n            0\n        } else if (n\
    \ == 2) {\n            1\n        } else {\n            var a : Long = 0\n   \
    \         var b : Long = 0\n            var c : Long = 1\n            var sum\
    \ : Long = 0\n            for (i <- 3l to n) {\n                sum = a + b +\
    \ c\n                a = b\n                b = c\n                c = sum\n \
    \           }\n            sum\n        }", "        if (n == 0) 0\n        else\
    \ if (n == 1) 0\n        else if (n == 2) 1\n        else fibfib(n - 1) + fibfib(n\
    \ - 2) + fibfib(n - 3)", "        // This function is provided as an example;\
    \ please implement a solution.\n        ???", "        // edge case\n        if\
    \ (n == 0) 0 else if (n == 1) 0 else if (n == 2) 1 else {\n            // dynamic\
    \ programming approach\n            val f : Array[Long] = new Array[Long](n.toInt\
    \ + 1)\n            f(0) = 0\n            f(1) = 0\n            f(2) = 1\n   \
    \         for (i <- 3 to n.toInt) {\n                f(i) = f(i - 1) + f(i - 2)\
    \ + f(i - 3)\n            }\n            f(n.toInt)\n        }", "        // Your\
    \ code here\n        0", "        // Your Code Here\n        if (n == 0) 0\n \
    \       else if (n == 1) 0\n        else if (n == 2) 1\n        else {\n     \
    \       var a = 0l\n            var b = 0l\n            var c = 1l\n         \
    \   var x = 3l\n            while (x <= n) {\n                var d = a + b +\
    \ c\n                a = b\n                b = c\n                c = d\n   \
    \             x += 1\n            }\n            c\n        }", "        //\n\
    \        // Insert code here\n        //\n        if (n == 0) 0\n        else\
    \ if (n == 1) 0\n        else if (n == 2) 1\n        else fibfib(n - 1) + fibfib(n\
    \ - 2) + fibfib(n - 3)", "        // Your code here\n        (n, n - 1, n - 2,\
    \ n - 3) match {\n            case (x, 0, 0, 0) => x\n            case (x, y,\
    \ z, 0) => fibfib(x - 1) + fibfib(y - 1) + fibfib(z - 1)\n            case (x,\
    \ y, z, a) => fibfib(x - 1) + fibfib(y - 1) + fibfib(z - 1) + fibfib(a - 1)\n\
    \        }", "        // Your code here\n        return 0;", "        // replace\
    \ 0 with the correct implementation.\n        0", "        // Your code here\n\
    \        (0l)", "      n match {\n        case 0 => 0\n        case 1 => 0\n \
    \       case 2 => 1\n        case 3 => 1\n        case 4 => 2\n        case 5\
    \ => 4\n        case _ => fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n      }", " \
    \       var a = 0l\n        var b = 0l\n        var c = 1l\n        var res =\
    \ 0l\n        for (i <- 3l to n) {\n            res = a + b + c\n            a\
    \ = b\n            b = c\n            c = res\n        }\n        res", "    \
    \    if (n < 0) throw new IllegalArgumentException(\"n cannot be negative!\")\n\
    \        var map = HashMap[Long, Long]()\n        map += (0 -> 0)\n        map\
    \ += (1 -> 0)\n        map += (2 -> 1)\n        def get(n : Long) : Long = {\n\
    \            if (map.contains(n)) return map(n)\n            else {\n        \
    \        val r = get(n - 1) + get(n - 2) + get(n - 3)\n                map +=\
    \ (n -> r)\n                return r\n            }\n        }\n        get(n)",
  "        var a = 0l\n        var b = 0l\n        var c = 1l\n        for (i <- 0l\
    \ until n) {\n            val d = a + b + c\n            a = b\n            b\
    \ = c\n            c = d\n        }\n        c", "        def fibfibhelper(n :\
    \ Long, n1 : Long, n2 : Long, n3 : Long) : Long = n match {\n            case\
    \ 0 => n1\n            case 1 => n2\n            case 2 => n3\n            case\
    \ _ => fibfibhelper(n - 1, n2, n3, n1 + n2 + n3)\n        }\n        fibfibhelper(n,\
    \ 0, 0, 1)", "        // Fill up this function body\n        // 'n' is the nth\
    \ element in the fibfib sequence to find\n        // Your code here\n        var\
    \ nthFibfib:Long = 0\n        if(n == 0) {\n            nthFibfib = 0\n      \
    \  }\n        else if(n == 1) {\n            nthFibfib = 0\n        }\n      \
    \  else if(n == 2) {\n            nthFibfib = 1\n        }\n        else {\n \
    \           var a = 0\n            var b = 0\n            var c = 1\n        \
    \    for(i <- 3 to n.toInt) {\n                nthFibfib = a + b + c\n       \
    \         a = b\n                b = c\n                c = nthFibfib\n      \
    \      }\n        }\n        nthFibfib", "        var a = 0L\n        var b =\
    \ 0L\n        var c = 1L\n        var d = 0L\n        for (i <- 1L to n) {\n \
    \           d = c + b + a\n            a = b\n            b = c\n            c\
    \ = d\n        }\n        d"]
stop_tokens:
- "\n    }\n"
