name: HumanEval_10_make_palindrome
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Find the shortest palindrome that begins with a supplied string.\n    //\
  \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
  \ that is a palindrome.\n    // - Append to the end of the string reverse of a string\
  \ prefix that comes before the palindromic suffix.\n    // >>> makePalindrome((\"\
  \"))\n    // (\"\")\n    // >>> makePalindrome((\"cat\"))\n    // (\"catac\")\n\
  \    // >>> makePalindrome((\"cata\"))\n    // (\"catac\")\n    def makePalindrome(string\
  \ : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
  \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
  \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
  xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\"\
  )));\n    }\n\n}\n"
completions: ["        if (string.isEmpty) return string\n        val len = string.length\n\
    \        val halfLen = len / 2\n        val postfix = (1 to halfLen).foldLeft(string)((a,\
    \ b) => a.take(len - b) + a.takeRight(b).reverse)\n        return postfix + string.drop(len\
    \ - halfLen)", "        // Base case: empty strings (not valid)\n        if (string.isEmpty)\
    \ {\n            return \"\"\n        }\n        // Base case: single character\
    \ strings (already palindromes)\n        if (string.length == 1) {\n         \
    \   return string\n        }\n        // Iterate over all postfixes of the string\
    \ and find the longest that is a palindrome\n        var palindromePostfix = \"\
    \"\n        for (i <- 0 to string.length - 1) {\n            val postfix = string.substring(i)\n\
    \            if (isPalindrome(postfix)) {\n                palindromePostfix =\
    \ postfix\n            }\n        }\n        // Return the appended string (prefix\
    \ + postfix + reverse of prefix)\n        val prefix = string.substring(0, string.length\
    \ - palindromePostfix.length)\n        prefix + palindromePostfix + prefix.reverse",
  "        def reverse(string : String) : String = {\n            val builder = new\
    \ StringBuilder\n            for (i <- string.length - 1 to 0 by -1) {\n     \
    \           builder.append(string(i))\n            }\n            builder.toString\n\
    \        }\n        def isPalindrome(string : String) : Boolean = {\n        \
    \    val halfLength = string.length / 2\n            for (i <- 0 until halfLength)\
    \ {\n                if (string(i) != string(string.length - 1 - i)) return false\n\
    \            }\n            true\n        }\n        val length = string.length\n\
    \        if (length == 0) return \"\"\n        var maxPalindrome = \"\"\n    \
    \    var maxPalindromeLength = 0\n        for (i <- 0 until length) {\n      \
    \      val prefix = string.substring(0, i)\n            val suffix = string.substring(i,\
    \ length)\n            if (isPalindrome(suffix) && suffix.length > maxPalindromeLength)\
    \ {\n                maxPalindrome = suffix\n                maxPalindromeLength\
    \ = suffix.length\n            }\n        }\n        string + reverse(string.substring(0,\
    \ length - maxPalindromeLength))", "        val suffix = suffixOfLongestPalindrome(string)\n\
    \        val prefix = string.substring(0, string.length - suffix.length)\n   \
    \     prefix + suffix + (prefix.reverse)", "        val longestSuffix = string.substring(string.size\
    \ - string.size / 2, string.size).reverse\n        val prefix = string.substring(0,\
    \ string.size / 2)\n        prefix + longestSuffix + prefix.reverse", "      \
    \  val suffix = longestPalindromicSuffix(string)\n        val prefix = string.slice(0,\
    \ string.length - suffix.length)\n        string + prefix.reverse", "        val\
    \ n = string.length\n        val suffixLength = longestPalindromicSuffix(string)\n\
    \        val prefix = string.substring(0, n - suffixLength)\n        val suffix\
    \ = string.substring(n - suffixLength)\n        val prefixReverse = prefix.reverse\n\
    \        return prefixReverse + suffix + prefixReverse", "        // Look for\
    \ a palindromic postfix.\n        var length : Int = string.length\n        val\
    \ prefix : String = string.substring(0, string.length / 2)\n        val palindromeLength\
    \ : Int = (0 to prefix.length - 1).takeWhile(index => prefix(index) == string(length\
    \ - 1 - index)).lastOption.getOrElse(0)\n        val suffix : String = prefix.substring(0,\
    \ prefix.length - palindromeLength)\n        // Append the reverse of the prefix\
    \ before palindromic postfix to the end of the string.\n        return string\
    \ + suffix.reverse", "        var result = string + reverse(string)\n        var\
    \ palindromeSuffix = \"\"\n        for (i <- 0 to string.length - 1) {\n     \
    \       if (isPalindrome(string.substring(i))) {\n                palindromeSuffix\
    \ = string.substring(i)\n                break\n            }\n        }\n   \
    \     var prefix = string.substring(0, string.length - palindromeSuffix.length)\n\
    \        result = prefix + palindromeSuffix + reverse(prefix)\n        return\
    \ result", "        // Find the longest palindromic suffix\n        def makePalindromeHelper(string\
    \ : String, longestPalindrome : String) : String = {\n            if (string.length\
    \ < 1) {\n                longestPalindrome\n            } else {\n          \
    \      if (isPalindrome(string)) {\n                    makePalindromeHelper(string.substring(0,\
    \ string.length - 1), string)\n                } else {\n                    makePalindromeHelper(string.substring(0,\
    \ string.length - 1), longestPalindrome)\n                }\n            }\n \
    \       }\n        val longestPalindrome = makePalindromeHelper(string, \"\")\n\
    \        // Append reverse of the prefix to the palindromic suffix\n        string.substring(0,\
    \ string.length - longestPalindrome.length) + longestPalindrome + string.substring(0,\
    \ string.length - longestPalindrome.length).reverse", "        val n = string.length;\n\
    \        val palindrome = new StringBuilder;\n        var i = n - 1;\n       \
    \ while (i >= 0) {\n            if (isPalindrome(string.substring(i))) {\n   \
    \             palindrome.append(string.substring(0, i));\n                palindrome.append(string.substring(i).reverse);\n\
    \                return palindrome.toString;\n            }\n            i -=\
    \ 1;\n        }\n        palindrome.append(string.reverse);\n        palindrome.append(string);\n\
    \        return palindrome.toString;", "        val s = string.toArray\n     \
    \   val (s1, s2) = (s.slice(0, s.length / 2), s.slice(s.length / 2, s.length))\n\
    \        val (longestPalindromePrefix, longestPalindromePostfix) = (s1.reverse.intersect(s2),\
    \ s1.intersect(s2.reverse))\n        val (prefix, postfix) = (s1.drop(longestPalindromePrefix.length),\
    \ s2.drop(longestPalindromePostfix.length))\n        if (prefix.length > 0) prefix.reverse\
    \ ++ s ++ postfix else s", "        var reverse : String = string.reverse\n  \
    \      val stringSize : Int = string.size\n        val first : Int = stringSize\n\
    \        val second : Int = stringSize - string.indexOf(reverse)\n        val\
    \ prefix : String = string.slice(0, second)\n        val suffix : String = string.slice(second,\
    \ stringSize)\n        suffix + prefix.reverse", "        def substring(string\
    \ : String, start : Int, end : Int) : String = {\n            var index = start\n\
    \            var result = \"\"\n            while (index < end) {\n          \
    \      result += string(index)\n                index += 1\n            }\n  \
    \          result\n        }\n        def isPalindrome(string : String) : Boolean\
    \ = {\n            var i = 0\n            var j = string.length - 1\n        \
    \    while (i < j) {\n                if (string(i) != string(j)) return false\n\
    \                i += 1\n                j -= 1\n            }\n            true\n\
    \        }\n        var suffix = 0\n        while (true) {\n            val substring\
    \ = substring(string, string.length - suffix, string.length)\n            if (isPalindrome(substring))\
    \ return string + substring.reverse\n            suffix += 1\n        }\n    \
    \    \"\"", "        // If the string is not a palindrome then the prefix before\
    \ palindromic suffix is non-empty.\n        // Otherwise, the string itself is\
    \ a palindrome, so the reverse of the prefix before palindromic suffix is empty.\n\
    \        if (!isPalindrome(string))\n            string + string.substring(0,\
    \ string.length - findLongestPalindromicSuffix(string)).reverse\n        else\n\
    \            string", "        // Find the longest palindromic suffix of supplied\
    \ string.\n        def iter(postfix : String, suffix : String) : String = {\n\
    \            if (postfix.isEmpty) suffix\n            else {\n               \
    \ val maybeSuffix = postfix.last + suffix\n                if (maybeSuffix ==\
    \ maybeSuffix.reverse) iter(postfix.init, maybeSuffix)\n                else iter(postfix.init,\
    \ suffix)\n            }\n        }\n        if (string.isEmpty) \"\"\n      \
    \  else string + string.init.reverse.drop(iter(string.init, \"\").length)", " \
    \       def reverse(string : String) : String = {\n            var newString =\
    \ \"\"\n            for (ch <- string) newString = ch + newString\n          \
    \  newString\n        }\n        def isPalindrome(string : String) : Boolean =\
    \ {\n            if (string.length <= 1) true\n            else if (string(0)\
    \ != string(string.length - 1)) false\n            else isPalindrome(string.substring(1,\
    \ string.length - 1))\n        }\n        def findLongestPalindrome(string : String)\
    \ : String = {\n            if (isPalindrome(string)) string\n            else\
    \ findLongestPalindrome(string.substring(0, string.length - 1))\n        }\n \
    \       def findLongestNonPalindrome(string : String) : String = {\n         \
    \   if (!isPalindrome(string)) string\n            else findLongestNonPalindrome(string.substring(1,\
    \ string.length))\n        }\n        var suffix = findLongestPalindrome(string)\n\
    \        var prefix = findLongestNonPalindrome(string.substring(0, string.length\
    \ - suffix.length))\n        prefix + string + reverse(prefix)", "        if (string.length\
    \ <= 1) {\n            return string\n        }\n        val array = string.toCharArray\n\
    \        var palindromeSize = 1\n        for (i <- array.length - 1 to 1 by -1)\
    \ {\n            if (array(i) == array(i - 1)) {\n                palindromeSize\
    \ += 1\n            } else {\n                break\n            }\n        }\n\
    \        var prefix = \"\"\n        for (i <- 0 until array.length - palindromeSize)\
    \ {\n            prefix += array(i)\n        }\n        prefix.reverse + string",
  "        if (string.length == 0) return string\n        val suffixes = Range(string.length\
    \ - 1, -1, -1).map(i => string.substring(i, string.length))\n        val postfixes\
    \ = suffixes.filter(suffix => isPalindrome(suffix))\n        val longestPalindromicPostfix\
    \ = postfixes.maxBy(postfix => postfix.length)\n        string + reverse(string.substring(0,\
    \ string.length - longestPalindromicPostfix.length))", "        val length = string.length\n\
    \        var longestPalindromeLength = 0\n        for (i <- 0 to length) {\n \
    \           if (isPalindrome(string.substring(i))) longestPalindromeLength = i\n\
    \        }\n        val prefix = string.substring(0, length - longestPalindromeLength)\n\
    \        val reversedPrefix = prefix.reverse\n        string + reversedPrefix",
  "        if (string.isEmpty) {\n            return string\n        }\n        var\
    \ i = string.length - 1\n        while(i >= 0) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                val reversedPrefix = string.substring(0, i).reverse\n   \
    \             return string + reversedPrefix\n            }\n            i -=\
    \ 1\n        }\n        throw new IllegalArgumentException(\"Unable to make palindrome\"\
    )", "        if (string.isEmpty) return string\n        val suffix = makePalindromeSuffix(string)\n\
    \        val prefix = string.drop(suffix.length)\n        prefix.reverse + string",
  "        // Return the longest postfix that is a palindrome.\n        def suffix(string\
    \ : String) : String = {\n            // If string is a palindrome, return it.\n\
    \            def isPalindrome(string : String) : Boolean = {\n               \
    \ // Return true if `string` is a palindrome and false otherwise.\n          \
    \      def stringIterator(string : String) : Iterator[Char] = {\n            \
    \        // Return iterator to the string.\n                    val stringBuffer\
    \ = new ListBuffer[Char]\n                    for (i <- 0 until string.length)\
    \ {\n                        stringBuffer += string(i)\n                    }\n\
    \                    return stringBuffer.toIterator\n                }\n     \
    \           // `halfLength` will be the length of a string in the middle of a\
    \ string and its reverse.\n                val halfLength = string.length / 2\n\
    \                for (i <- 0 until halfLength) {\n                    if (string(i)\
    \ != string(string.length - 1 - i)) {\n                        return false\n\
    \                    }\n                }\n                return true\n     \
    \       }\n            // Return index of the first occurence of a palindrome.\n\
    \            def recursion(i : Int) : Int = {\n                if (i >= string.length)\
    \ {\n                    return -1\n                }\n                else if\
    \ (isPalindrome(string.substring(i))) {\n                    return i\n      \
    \          }\n                else {\n                    return recursion(i +\
    \ 1)\n                }\n            }\n            if (string.length == 0) {\n\
    \                return \"\"\n            }\n            val index = recursion(0)\n\
    \            if (index != -1) {\n                return string.substring(index)\n\
    \            }\n            else {\n                return \"\"\n            }\n\
    \        }\n        // Return a string that is equal to its reverse.\n       \
    \ def makeReversed(string : String) : String = {\n            val reversed = new\
    \ StringBuilder\n            for (i <- string.length - 1 to 0 by -1) {\n     \
    \           reversed += string(i)\n            }\n            return reversed.toString\n\
    \        }\n        // Return the shortest palindrome that starts with a supplied\
    \ string.\n        def recursion(string : String) : String = {\n            val\
    \ suffix = suffix(string)\n           ", "        // Find the longest palindromic\
    \ suffix.\n        def findLongestPalindromicSuffix(string : String) : String\
    \ = {\n            def find(string : String, i : Int) : String = {\n         \
    \       if (i > string.length) \"\"\n                else if (string.take(i) ==\
    \ string.takeRight(i).reverse) string.take(i)\n                else find(string,\
    \ i + 1)\n            }\n            find(string, 1)\n        }\n        string\
    \ + string.take(string.length - findLongestPalindromicSuffix(string).length).reverse",
  "        val substrings = for(i <- 0 to string.length / 2) yield string.substring(0,\
    \ string.length - i)\n        val palindromes = substrings.filter(s => s == s.reverse)\n\
    \        val maxPalindrome = palindromes.map(s => (s, s.length)).maxBy(_._2)._1\n\
    \        maxPalindrome + string.reverse.substring(0, string.length - maxPalindrome.length)",
  "        val prefix = string.substring(0, string.length - longestPalindromeSuffixLength(string))\n\
    \        string + prefix.reverse", "        def helper(s : String, pos : Int)\
    \ : String = {\n            if (pos == s.length) s\n            else if (s.charAt(pos)\
    \ == s.charAt(0)) helper(s, pos + 1)\n            else s.substring(pos, s.length)\
    \ + s.substring(0, pos).reverse\n        }\n        if (string.length == 0) string\n\
    \        else helper(string + string.reverse, 1)", "        var palindromeSuffix\
    \ = \"\"\n        var palindromeSuffixLength = 0\n        for (i <- 0 to string.length)\
    \ {\n            val suffix = string.substring(i)\n            if (isPalindrome(suffix))\
    \ {\n                palindromeSuffix = suffix\n                palindromeSuffixLength\
    \ = palindromeSuffix.length\n                break\n            }\n        }\n\
    \        string + (string.substring(0, string.length - palindromeSuffixLength).reverse)",
  "        val length = string.length\n        val n = 2 * length + 1\n        val\
    \ longestPalindromeAt = Array.fill(n)(0)\n        longestPalindromeAt(0) = 0\n\
    \        longestPalindromeAt(1) = 1\n        var center = 1\n        var right\
    \ = 2\n        for (i <- 2 until n) {\n            val j = 2 * center - i\n  \
    \          longestPalindromeAt(i) = min(right - i, longestPalindromeAt(j))\n \
    \           val left = i - 1 - longestPalindromeAt(i)\n            val right =\
    \ i + 1 + longestPalindromeAt(i)\n            while (left >= 0 && right < n &&\
    \ string(left / 2) == string(right / 2)) {\n                longestPalindromeAt(i)\
    \ += 1\n                left -= 1\n                right += 1\n            }\n\
    \            if (i + longestPalindromeAt(i) > right) {\n                center\
    \ = i\n                right = i + longestPalindromeAt(i)\n            }\n   \
    \     }\n        var maxIndex = 0\n        for (i <- 1 until n) {\n          \
    \  if (longestPalindromeAt(i) > longestPalindromeAt(maxIndex)) maxIndex = i\n\
    \        }\n        string.substring(0, (maxIndex - longestPalindromeAt(maxIndex))\
    \ / 2) + string.reverse + string.substring((maxIndex + longestPalindromeAt(maxIndex))\
    \ / 2)", "        val n = string.length\n        def getFirstOccurence(prefix\
    \ : String) : Int = {\n            var i = n - 1\n            while (i >= 0) {\n\
    \                if (string.charAt(i) == prefix.charAt(0)) {\n               \
    \     var j = 1\n                    while (j < prefix.length && i + j < n &&\
    \ string.charAt(i + j) == prefix.charAt(j)) {\n                        j += 1\n\
    \                    }\n                    if (j == prefix.length) return i\n\
    \                }\n                i -= 1\n            }\n            return\
    \ -1\n        }\n        def getFirstOccurenceMirror(prefix : String) : Int =\
    \ {\n            var i = n - 1\n            while (i >= 0) {\n               \
    \ if (string.charAt(i) == prefix.charAt(prefix.length - 1)) {\n              \
    \      var j = 1\n                    while (j < prefix.length && i + j < n &&\
    \ string.charAt(i + j) == prefix.charAt(prefix.length - 1 - j)) {\n          \
    \              j += 1\n                    }\n                    if (j == prefix.length)\
    \ return i\n                }\n                i -= 1\n            }\n       \
    \     return -1\n        }\n        def getFirstOccurenceGreedy(prefix : String)\
    \ : Int = {\n            var i = n - 1\n            while (i >= 0) {\n       \
    \         if (string.charAt(i) == prefix.charAt(prefix.length - 1)) {\n      \
    \              var j = 1\n                    while (j < prefix.length && i +\
    \ j < n && string.charAt(i + j) == prefix.charAt(prefix.length - 1 - j)) {\n \
    \                       j += 1\n                    }\n                    if\
    \ (j == prefix.length) return i\n                }\n                i -= 1\n \
    \           }\n            return -1\n        }\n        var i = 0\n        while\
    \ (i < n) {\n            val prefix = string.substring(0, n - i)\n           \
    \ val mirrorPrefix = string.substring(0, i)\n            val greedyPrefix = string.substring(0,\
    \ n - i)\n            if (prefix == string.substring(i, n)) {", "        val len\
    \ = string.length\n        val lenOver2 = len / 2\n        for (i <- 0 to lenOver2)\
    \ {\n            val curr = string.substring(i)\n            if (curr == curr.reverse)\
    \ return string + curr.reverse.substring(0, len - i)\n        }\n        string",
  "        if (string.isEmpty) return string\n        val reverse = string.reverse\n\
    \        val reverseIndex = reverse.indexOf(string)\n        string + reverse.substring(reverseIndex\
    \ + 1)", "        val suffix = string.substring(string.length / 2)\n        val\
    \ prefix = string.substring(0, string.length / 2)\n        val reversed = prefix.reverse\n\
    \        val palindrome = reversed + string + reversed\n        palindrome", " \
    \       val length = string.length\n        val reversePrefixLength = (0 until\
    \ length).find(i => isPalindrome(string.substring(0, i))).getOrElse(0)\n     \
    \   (string + string.substring(0, length - reversePrefixLength).reverse)", " \
    \       val str = string + \"#\" + string.reverse\n        val suffixArray = new\
    \ SuffixArray(str)\n        suffixArray.findShortestPrefix(string)", "       \
    \ val reversed = string.reverse\n        for (i <- string.length - 1 to 0 by -1)\
    \ {\n            if (string.startsWith(reversed.substring(string.length - i)))\
    \ {\n                return string + reversed.substring(0, string.length - i)\n\
    \            }\n        }\n        throw new IllegalArgumentException(\"Can't\
    \ make palindrome from string \\\"\" + string + \"\\\"\")", "        val n = string.length\n\
    \        var maxPalindromeLength = 0\n        var maxPalindromeBegin = 0\n   \
    \     for (i <- 0 until n) {\n            var l = i\n            var r = i\n \
    \           while (l >= 0 && r < n && string(l) == string(r)) {\n            \
    \    if (r - l + 1 > maxPalindromeLength) {\n                    maxPalindromeLength\
    \ = r - l + 1\n                    maxPalindromeBegin = l\n                }\n\
    \                l -= 1\n                r += 1\n            }\n            l\
    \ = i\n            r = i + 1\n            while (l >= 0 && r < n && string(l)\
    \ == string(r)) {\n                if (r - l + 1 > maxPalindromeLength) {\n  \
    \                  maxPalindromeLength = r - l + 1\n                    maxPalindromeBegin\
    \ = l\n                }\n                l -= 1\n                r += 1\n   \
    \         }\n        }\n        string + string.substring(0, n - maxPalindromeLength).reverse",
  "        // Helper function to find the longest palindromic suffix, the substring\
    \ of string that is a palindrome and is at the end of the string.\n        def\
    \ findLongestPalindromicSuffix(string : String) : String = {\n            if (string.length\
    \ == 0) return string\n            for (len <- string.length to 0 by -1) {\n \
    \               if (isPalindrome(string.substring(string.length - len))) return\
    \ string.substring(string.length - len)\n            }\n            return \"\"\
    \n        }\n        // Helper function to check if a string is a palindrome.\n\
    \        def isPalindrome(string : String) : Boolean = {\n            for (i <-\
    \ 0 until string.length / 2) {\n                if (string(i) != string(string.length\
    \ - 1 - i)) return false\n            }\n            return true\n        }\n\
    \        // Find the longest palindromic suffix.\n        val palindromicSuffix\
    \ = findLongestPalindromicSuffix(string)\n        // The prefix of the string\
    \ is the string minus the palindromic suffix.\n        val prefix = string.substring(0,\
    \ string.length - palindromicSuffix.length)\n        // To make a palindrome,\
    \ take the prefix and reverse it and append it to the original string.\n     \
    \   return string + prefix.reverse", "        var i = 0\n        var j = string.length\
    \ - 1\n        while (i < j) {\n            if (string(i) != string(j)) {\n  \
    \              return string.substring(0, j) + string.reverse.substring(string.length\
    \ - j) + string.substring(j)\n            }\n            i += 1\n            j\
    \ -= 1\n        }\n        return string", "        val stringReverse = string.reverse\n\
    \        val stringWithReverse = string + ' ' + stringReverse\n        val lps\
    \ = longestPalindromicSubstring(stringWithReverse)\n        stringReverse.substring(0,\
    \ stringReverse.length - lps.length) + string", "        if (string.length() ==\
    \ 0) {\n            return string\n        }\n        var maxPalindromeSuffixLength\
    \ = 0\n        for (i <- string.length() - 1 to 0 by -1) {\n            val suffix\
    \ = string.substring(i)\n            if (isPalindrome(suffix)) {\n           \
    \     maxPalindromeSuffixLength = suffix.length()\n                break\n   \
    \         }\n        }\n        val prefix = string.substring(0, string.length()\
    \ - maxPalindromeSuffixLength)\n        string + reverse(prefix)", "      def\
    \ isPalindrome(string : String) : Boolean = string == string.reverse\n      def\
    \ getPostfix(string : String) : (String, String) = {\n        val halves = string.splitAt(string.length\
    \ / 2)\n        val prefix = halves._1\n        val postfix = halves._2\n    \
    \    val reversedPostfix = postfix.reverse\n        val prefixesPostfix = prefix.endsWith(reversedPostfix)\n\
    \        if (prefixesPostfix) (string, \"\")\n        else {\n          val postfixWithoutLastChar\
    \ = postfix.tail\n          val prefixWithCharFromPostfix = prefix + postfixWithoutLastChar.head\n\
    \          val withoutCharResult = getPostfix(prefixWithCharFromPostfix)\n   \
    \       (withoutCharResult._1, postfixWithoutLastChar.head + withoutCharResult._2)\n\
    \        }\n      }\n      val nonPalindromicString = getPostfix(string)._1\n\
    \      val palindromicSuffix = getPostfix(string)._2\n      nonPalindromicString\
    \ + palindromicSuffix.reverse", "        val reversedString = string.reverse\n\
    \        var longestPalindromePostfix = \"\"\n        var longestPalindromePostfixIndex\
    \ = -1\n        for (i <- 0 to string.length - 1) {\n            val candidatePostfix\
    \ = string.slice(i, string.length)\n            if (candidatePostfix == reversedString.slice(0,\
    \ string.length - i)) {\n                longestPalindromePostfix = candidatePostfix\n\
    \                longestPalindromePostfixIndex = i\n            }\n        }\n\
    \        string + reversedString.slice(string.length - longestPalindromePostfixIndex,\
    \ string.length)", "        val sb = new StringBuilder(string)\n        sb.append(string.reverse.substring(findLongestPalindromicSuffix(string)))\n\
    \        sb.toString", "        val longestPalindrome = longestPalindromeInSuffix(string)\n\
    \        val prefix = string.substring(0, string.length - longestPalindrome.length)\n\
    \        string + reverse(prefix)", "        if (string.isEmpty) string\n    \
    \    else {\n            val suf = longestSuffixPalindrome(string)\n         \
    \   string + (string.drop(suf.length) reverse)\n        }", "        def findPalindromeSuffix(string\
    \ : String) : String = {\n            for (i <- 0 to string.length) {\n      \
    \          if (isPalindrome(string.substring(i))) return string.substring(i)\n\
    \            }\n            \"\"\n        }\n        def isPalindrome(string :\
    \ String) : Boolean = {\n            if (string.length == 0) return true\n   \
    \         return string.substring(0, 1) == string.substring(string.length - 1,\
    \ string.length) && isPalindrome(string.substring(1, string.length - 1))\n   \
    \     }\n        return string + string.substring(0, string.length - findPalindromeSuffix(string).length).reverse",
  "        def prefixMatching(index : Int, length : Int) : Boolean = {\n         \
    \   for (i <- index until length) if (string(i) != string(length - i + index -\
    \ 1)) return false\n            return true\n        }\n        for (length <-\
    \ string.length to 1 by -1) {\n            if (prefixMatching(0, length)) return\
    \ string + string.substring(length).reverse\n        }\n        return string",
  "        // >>> getPalindromicPostfix((\"\"))._1\n        // (\"\")\n        //\
    \ >>> getPalindromicPostfix((\"cat\"))._1\n        // (\"\")\n        // >>> getPalindromicPostfix((\"\
    atac\"))._1\n        // (\"atac\")\n        // >>> getPalindromicPostfix((\"catac\"\
    ))._1\n        // (\"catac\")\n        def getPalindromicPostfix(string : String)\
    \ : (String, Int) = {\n            val size = string.size\n            val upperLimit\
    \ = size / 2 + 1\n            def getPalindromicPostfixHelper(index : Int) : (String,\
    \ Int) = {\n                if (index == 0) (\"\", 0)\n                else {\n\
    \                    val c1 = string(size - index)\n                    val c2\
    \ = string(size - index - 1)\n                    if (c1 == c2) getPalindromicPostfixHelper(index\
    \ - 1)\n                    else {\n                        val (string, size)\
    \ = getPalindromicPostfixHelper(index - 1)\n                        (string, size)\n\
    \                    }\n                }\n            }\n            getPalindromicPostfixHelper(upperLimit)\n\
    \        }\n        val (postfix, postfixSize) = getPalindromicPostfix(string)\n\
    \        val prefix = string.slice(0, string.size - postfixSize)\n        string\
    \ + prefix.reverse", "        val suffix = (for (i <- 0 to string.length - 1)\
    \ yield string.substring(i, string.length)).filter(s => s == s.reverse).maxBy(_.length)\n\
    \        string + string.substring(0, string.length - suffix.length).reverse",
  "        val (pre, pal) = string.foldLeft((\"\", \"\"))((x, e) => {\n          \
    \  if (isPalindrome(x._1 + e + x._2)) (x._1 + e, x._2)\n            else (x._1,\
    \ e + x._2)\n        })\n        pre + pal", "        def reverse(string : String)\
    \ : String = {\n            var stringBuilder = new StringBuilder\n          \
    \  for (i <- string.length - 1 to 0 by -1) stringBuilder += string(i)\n      \
    \      stringBuilder.toString\n        }\n        def longestPostfixPalindrome(string\
    \ : String) : String = {\n            var map = Map[(Int, Int), Boolean]()\n \
    \           var length = 0\n            var postfix = \"\"\n            for (start\
    \ <- 0 to string.length - 1) {\n                for (i <- start to string.length\
    \ - 1) {\n                    val j = string.length - 1 - i + start\n        \
    \            val isPalindrome = if (start == i) true else if (start + 1 == i)\
    \ string(start) == string(i) else if (map((start + 1, i - 1)) && string(start)\
    \ == string(i)) true else false\n                    map += ((start, i) -> isPalindrome)\n\
    \                    if (isPalindrome && i - start + 1 > length) {\n         \
    \               length = i - start + 1\n                        postfix = string.substring(start,\
    \ i + 1)\n                    }\n                }\n            }\n          \
    \  postfix\n        }\n        val postfix = longestPostfixPalindrome(string)\n\
    \        val prefix = string.substring(0, string.length - postfix.length)\n  \
    \      string + reverse(prefix)", "        var s = string\n        var longestPalindrome\
    \ = \"\"\n        while (s.length != 0) {\n            if (s == s.reverse) {\n\
    \                if (s.length > longestPalindrome.length) longestPalindrome =\
    \ s\n            }\n            s = s.dropRight(1)\n        }\n        string\
    \ + string.reverse.drop(longestPalindrome.length)", "        val s = string.toLowerCase\n\
    \        var max = 0\n        var start = 0\n        for (i <- 0 to s.length /\
    \ 2) {\n            val j = s.length - 1 - i\n            if (s(i) == s(j)) {\n\
    \                var i1 = i\n                var j1 = j\n                while\
    \ (i1 < j1 && s(i1) == s(j1)) {\n                    i1 += 1\n               \
    \     j1 -= 1\n                }\n                if (i1 >= j1 && j - i > max)\
    \ {\n                    max = j - i\n                    start = i\n        \
    \        }\n            }\n        }\n        s.substring(0, start) + s + s.substring(start,\
    \ start + max + 1).reverse", "        // Precondition: n > 0\n        // Postcondition:\
    \ string[0..n-1] returns the longest palindromic suffix of the string[0..n-1]\n\
    \        def findPalindromicSuffix(n : Int) : Int = {\n            if (n == 0)\
    \ 0\n            else {\n                val m = findPalindromicSuffix(n - 1)\n\
    \                // Can we expand prefix of length m by 1 character on each side?\n\
    \                if (n - 1 - m == -1 || string(n - 1 - m) != string(n - 1)) m\n\
    \                else m + 1\n            }\n        }\n        // Precondition:\
    \ 0 <= i < string.length, 0 <= j < string.length, 0 <= j - i < string.length\n\
    \        // Postcondition: returns true iff string[i..j] is a palindrome\n   \
    \     def isPalindrome(i : Int, j : Int) : Boolean = {\n            if (i >= j)\
    \ true\n            else if (string(i) != string(j)) false\n            else isPalindrome(i\
    \ + 1, j - 1)\n        }\n        // Precondition: n > 0\n        // Postcondition:\
    \ string[0..n-1] is a palindrome and\n        // string[0..n-1] is a shortest\
    \ palindrome that starts with the string[0..n-1]\n        def palindromize(n :\
    \ Int) : String = {\n            if (n == 0) \"\"\n            else {\n      \
    \          val m = findPalindromicSuffix(n)\n                if (m == n) string.substring(0,\
    \ n)\n                else {\n                    val postfix = palindromize(n\
    \ - 1 - m)\n                    string.substring(0, m) + postfix + string.substring(m,\
    \ n)\n                }\n            }\n        }\n        palindromize(string.length)",
  "        if (string.isEmpty) return string\n        // If string is already a palindrome,\
    \ we're done.\n        if (string == string.reverse) return string\n        //\
    \ If string is just a single character, append it back to itself.\n        if\
    \ (string.length == 1) return string + string\n        // Otherwise, we need to\
    \ find a suffix of string that is a palindrome.\n        val (palindromeSuffix,\
    \ palindromeSuffixLength) = (0 to string.length).map(l => (string.takeRight(l),\
    \ l)).filter(x => x._1 == x._1.reverse).maxBy(_._2)\n        // Now we can construct\
    \ the result.\n        val result = string + string.take(string.length - palindromeSuffixLength).reverse\n\
    \        result", "        // This solution is O(n^2) in time complexity.\n  \
    \      // Here we use a dynamic programming solution that computes the length\
    \ of the longest palindromic suffix in O(n)\n        // (we can also do O(1) by\
    \ leveraging symmetry).\n        // Next we find the length of a prefix that comes\
    \ before the palindromic suffix by subtracting the length of the\n        // palindromic\
    \ suffix from the original string length.\n        // Finally we append reverse\
    \ of the prefix to the end of the original string to form a new string.\n    \
    \    def palindromicSuffix(string : String) : Int = {\n            val n = string.length\n\
    \            var result = 0\n            for (i <- (0 until n).reverse) {\n  \
    \              val palindrome = ((0 to i).reverse.mkString(string.slice(i, n))\
    \ + string.slice(i, n)).mkString\n                if (palindrome == palindrome.reverse)\
    \ {\n                    result = palindrome.length\n                    return\
    \ result\n                }\n            }\n            result\n        }\n  \
    \      val suffixLength = palindromicSuffix(string)\n        if (suffixLength\
    \ == string.length) return string\n        val prefixLength = string.length -\
    \ suffixLength\n        val prefix = string.slice(0, prefixLength)\n        val\
    \ palindrome = string + prefix.reverse\n        palindrome", "        def helper(string\
    \ : String, m : Int) : String = {\n            if (m == 0) {\n               \
    \ return string + string.reverse\n            }\n            else {\n        \
    \        val suffix = string.substring(string.length - m)\n                val\
    \ prefix = string.substring(0, string.length - m)\n                val reversedPrefix\
    \ = prefix.reverse\n                if (suffix == reversedPrefix) {\n        \
    \            return string + reversedPrefix.substring(m)\n                }\n\
    \                else {\n                    return helper(string, m - 1)\n  \
    \              }\n            }\n        }\n        return helper(string, string.length)",
  "        val length = string.length\n        var longestSuffix = 0\n        for\
    \ (i <- 0 until length - 1) {\n            if (string.substring(i).reverse ==\
    \ string.substring(i)) {\n                longestSuffix = length - i\n       \
    \         break\n            }\n        }\n        return string + string.substring(0,\
    \ length - longestSuffix).reverse", "        // Algorithm requires O(n^2) running\
    \ time and O(n) space.\n        val n = string.length\n        val prefixLength\
    \ = (0 until n).indexWhere(i => string.substring(0, i + 1) == string.substring(n\
    \ - i - 1, n).reverse)\n        string + string.substring(prefixLength + 1, n).reverse",
  "        def isPalindrome(string : String) : Boolean = {\n            val length\
    \ = string.length\n            for (i <- 0 until length / 2) {\n             \
    \   if (string(i) != string(length - 1 - i)) {\n                    return false\n\
    \                }\n            }\n            return true\n        }\n      \
    \  val length = string.length\n        for (i <- length to 0 by -1) {\n      \
    \      if (isPalindrome(string.substring(i))) {\n                return string\
    \ + string.substring(0, i).reverse\n            }\n        }\n        return string",
  "        if (string.length() == 0) return string\n        var largestSuffix = 0\n\
    \        for (i <- 1 to string.length()) if (string.substring(0, i) == string.substring(string.length()\
    \ - i, string.length())) largestSuffix = i\n        var prefix = string.substring(0,\
    \ string.length() - largestSuffix)\n        return prefix + string + prefix.reverse",
  "        val longestPalindrome = string.sliding(string.length).takeWhile(s => s\
    \ == s.reverse).toList.last\n        string + (string.take(string.length - longestPalindrome.length)).reverse",
  "        def findPalindromeSuffix() : String = {\n            var result = \"\"\n\
    \            for (i <- 0 to string.length) {\n                val suffix = string.substring(i)\n\
    \                if (suffix == suffix.reverse) result = suffix\n            }\n\
    \            result\n        }\n        if (string == \"\") return \"\"\n    \
    \    val suffix = findPalindromeSuffix()\n        if (suffix == string) return\
    \ string\n        string + string.substring(0, string.length - suffix.length).reverse",
  "        val last = string.length - 1\n        val right = (0 to last).find(j =>\
    \ string(j) == string(last - j))\n        val palindrome = string.substring(0,\
    \ right.getOrElse(0))\n        string + palindrome.reverse", "        val sLen\
    \ = string.length\n        val palindrome = mutable.StringBuilder.newBuilder\n\
    \        val pLen = sLen\n        val isPalindrome = Array.ofDim[Boolean](sLen,\
    \ sLen)\n        for (i <- 0 until sLen) {\n            isPalindrome(i)(i) = true\n\
    \            if (i > 0) {\n                isPalindrome(i)(i - 1) = true\n   \
    \         }\n        }\n        for (len <- 2 to sLen) {\n            for (i <-\
    \ 0 to sLen - len) {\n                val j = i + len - 1\n                isPalindrome(i)(j)\
    \ = string(i) == string(j) && isPalindrome(i + 1)(j - 1)\n            }\n    \
    \    }\n        var j = 0\n        while (j < sLen && !isPalindrome(0)(j)) {\n\
    \            j += 1\n        }\n        palindrome.append(string.substring(j +\
    \ 1).reverse)\n        palindrome.append(string)\n        palindrome.toString",
  "        var longestSuffix = -1\n        for (i <- 0 to string.length) {\n     \
    \       var prefix = string.substring(0, i)\n            var suffix = string.substring(i,\
    \ string.length)\n            if (suffix == prefix.reverse) {\n              \
    \  longestSuffix = i\n            }\n        }\n        string + string.substring(0,\
    \ string.length - longestSuffix).reverse", "        val reversedString = string.reverse\n\
    \        // E.g. reversedString = \"tac\", string = \"cat\"\n        val maxPalindrome\
    \ = string.zip(reversedString).foldLeft(0) {\n            case (maxPalindrome,\
    \ (char1, char2)) => if (char1 == char2) maxPalindrome + 1 else maxPalindrome\n\
    \        }\n        val (prefix, _) = string.splitAt(string.length - maxPalindrome)\n\
    \        string + prefix.reverse", "        var result = \"\"\n        var maxPostfixLength\
    \ = 0\n        var longestPostfix = \"\"\n        // find the longest palindromic\
    \ suffix of the string\n        for (i <- string.length - 1 to 0 by -1) {\n  \
    \          var postfix = string.substring(i)\n            if (isPalindrome(postfix))\
    \ {\n                if (postfix.length > maxPostfixLength) {\n              \
    \      maxPostfixLength = postfix.length\n                    longestPostfix =\
    \ postfix\n                }\n            }\n        }\n        if (longestPostfix\
    \ == \"\") {\n            result = string + reverse(string)\n        } else {\n\
    \            result = string + reverse(string.substring(0, string.length - longestPostfix.length))\n\
    \        }\n        result", "        def invert(string : String) : String = {\n\
    \            var result = \"\"\n            for (ch <- string) {\n           \
    \     result = ch + result\n            }\n            return result\n       \
    \ }\n        val strlen = string.length\n        var longestPalindromeIndex =\
    \ 0\n        for (i <- 0 to strlen - 1) {\n            // Longest palindrome must\
    \ be with even length.\n            if (i - longestPalindromeIndex < strlen -\
    \ i - 1 && string(i - longestPalindromeIndex) == string(i + 1)) {\n          \
    \      var j = 1\n                while (i - j >= 0 && i + j < strlen && string(i\
    \ - j) == string(i + j)) {\n                    j += 1\n                }\n  \
    \              longestPalindromeIndex = j - 1\n            }\n            // Longest\
    \ palindrome must be with odd length.\n            if (i - longestPalindromeIndex\
    \ >= 0 && string(i - longestPalindromeIndex) == string(i)) {\n               \
    \ var j = 1\n                while (i - j >= 0 && i + j - 1 < strlen && string(i\
    \ - j) == string(i + j - 1)) {\n                    j += 1\n                }\n\
    \                longestPalindromeIndex = j - 1\n            }\n        }\n  \
    \      val palindromeSize = longestPalindromeIndex * 2 + 1\n        val nonPalindromeSize\
    \ = strlen - palindromeSize\n        val nonPalindromeInverted = invert(string.substring(0,\
    \ nonPalindromeSize))\n        return string + nonPalindromeInverted", "     \
    \   val LPS = longestPalindromicSubstring(string)\n        val rest = string.drop(LPS.length)\n\
    \        val prefix = rest.reverse\n        prefix + string", "        val longestPostfix\
    \ = string.indexOf(string.reverse.find(string.startsWith(_)))\n        string\
    \ + string.substring(0, string.length - longestPostfix).reverse", "        def\
    \ reverse(str : String) : String = {\n            if (str.length == 0) return\
    \ \"\"\n            str.substring(str.length - 1) + reverse(str.substring(0, str.length\
    \ - 1))\n        }\n        def makePalindrome(string : String, longest : String)\
    \ : String = {\n            if (string.length == 0) return reverse(longest)\n\
    \            val firstChar = string.substring(0, 1)\n            val rest = string.substring(1)\n\
    \            if (firstChar == reverse(longest)) longest + firstChar + reverse(rest)\n\
    \            else makePalindrome(rest, firstChar + longest)\n        }\n     \
    \   makePalindrome(string, \"\")", "        val palindrome = findLongestPalindrome(string)\n\
    \        val reverse = string.substring(0, string.length - palindrome.length).reverse\n\
    \        string + reverse", "        def makePalindrome(string : String, longestPalindromeLength\
    \ : Int) : String = {\n            val prefix = string.substring(0, string.length\
    \ - longestPalindromeLength)\n            prefix + string + prefix.reverse\n \
    \       }\n        var longestPalindromeLength = 0\n        for (i <- 0 to string.length)\
    \ {\n            val substr = string.substring(i)\n            if (substr == substr.reverse)\
    \ {\n                longestPalindromeLength = max(longestPalindromeLength, substr.length)\n\
    \            }\n        }\n        makePalindrome(string, longestPalindromeLength)",
  "        def isPalindrome(string : String) : Boolean = string.reverse == string\n\
    \        if (isPalindrome(string)) return string\n        val prefix = string.dropRight(longestPalindromeSuffix(string).length)\n\
    \        prefix.reverse + string", "        val reversed = string.reverse\n  \
    \      val length = string.length\n        var palindrome = string\n        for\
    \ (i <- length to 0 by -1) {\n            val prefix = string.substring(0, i)\n\
    \            val suffix = reversed.substring(length - i)\n            if (prefix\
    \ == suffix) {\n                palindrome += reversed.substring(0, length - i)\n\
    \                return palindrome\n            }\n        }\n        palindrome",
  "        if (string.length == 0) return \"\"\n        val suffix = new StringBuffer(string.substring(string.length\
    \ - 1, string.length))\n        val prefix = new StringBuffer()\n        var i\
    \ = string.length - 2\n        while (i >= 0) {\n            if (suffix.length\
    \ > 0 && string(i) == suffix(0)) {\n                suffix.append(string(i))\n\
    \                prefix.append(string(i))\n            }\n            i -= 1\n\
    \        }\n        suffix.toString() + prefix.reverse.toString()", "        var\
    \ result = \"\"\n        val prefix = string.substring(0, string.length() - 1)\n\
    \        val suffix = string.substring(string.length() - 1)\n        val reversedPrefix\
    \ = prefix.reverse\n        for (i <- 0 to string.length() - 1) {\n          \
    \  if (isPalindrome(string.substring(i))) {\n                result = reversedPrefix\
    \ + string\n                return result\n            }\n        }\n        \"\
    \"", "        val len = string.length\n        for (i <- (0 to len / 2).reverse)\
    \ {\n            val prefix = string.slice(0, i)\n            val suffix = string.slice(len\
    \ - i, len)\n            if (prefix == suffix) {\n                return string\
    \ + string.slice(i, len).reverse\n            }\n        }\n        return string\
    \ + string.reverse", "        if (string.length == 0) return string\n        val\
    \ rev = string.reverse\n        var longestPalindromeLength = 0\n        for (i\
    \ <- 0 to rev.length - 1) {\n            if (rev.substring(i) == string.substring(0,\
    \ string.length - i)) longestPalindromeLength = string.length - i\n        }\n\
    \        return string + rev.substring(0, rev.length - longestPalindromeLength)",
  "        def iter(s : String, acc : List[Char]) : List[Char] = s match {\n     \
    \       case \"\" => acc\n            case x => iter(s.tail, s.head :: acc)\n\
    \        }\n        def isPalindrome(string : String) : Boolean = {\n        \
    \    val length = string.length\n            for (i <- 0 until length / 2) if\
    \ (string(i) != string(length - 1 - i)) return false\n            true\n     \
    \   }\n        for (prefix <- (0 until string.length).reverse) if (isPalindrome(string.substring(prefix)))\
    \ {\n            return string + (iter(string.substring(0, prefix), Nil)).mkString\n\
    \        }\n        throw new NoSuchElementException", "        def isPalindrome(string\
    \ : String) : Boolean = {\n            if (string.length % 2 == 0) {\n       \
    \         val n = string.length\n                val middle = n / 2\n        \
    \        string.substring(0, middle) == string.substring(middle, n).reverse\n\
    \            } else {\n                val n = string.length\n               \
    \ val middle = n / 2\n                string.substring(0, middle) == string.substring(middle\
    \ + 1, n).reverse\n            }\n        }\n        val n = string.length\n \
    \       for (length <- (n, 1, -1)) {\n            val prefix = string.substring(0,\
    \ length)\n            if (isPalindrome(prefix)) return prefix + string.substring(length,\
    \ n).reverse\n        }\n        return string", "        if (string.length ==\
    \ 0) return string\n        val (suffixStart, suffix) = string.splitAt(string.length\
    \ - 1)\n        val reversedPrefix = suffixStart.reverse\n        suffix + reversedPrefix",
  "        val n = string.length\n        // Find the longest palindromic suffix of\
    \ a supplied string.\n        def longestPalindromicSuffix(string : String) :\
    \ String = {\n            val n = string.length\n            def suffixLength(index\
    \ : Int) : Int = {\n                // Get substring of a supplied string that\
    \ starts at the supplied index.\n                def substr(index : Int) : String\
    \ = string.substring(index)\n                if (index < 0) 0\n              \
    \  else if (substr(index) == substr(0).reverse) n - index\n                else\
    \ suffixLength(index - 1)\n            }\n            string.substring(n - suffixLength(n\
    \ - 1))\n        }\n        val reversedPrefix = string.substring(0, n - longestPalindromicSuffix(string).length).reverse\n\
    \        string + reversedPrefix", "        def getPalindromeSuffix(string : String)\
    \ : String = {\n            val prefix : String = string.substring(0, string.length\
    \ / 2)\n            val suffix : String = string.substring(string.length / 2,\
    \ string.length)\n            if (prefix.equals(suffix.reverse)) suffix else getPalindromeSuffix(prefix)\n\
    \        }\n        val palindromeSuffix : String = getPalindromeSuffix(string)\n\
    \        val prefix : String = string.substring(0, string.length - palindromeSuffix.length)\n\
    \        prefix + palindromeSuffix + prefix.reverse", "        var prefix : String\
    \ = \"\"\n        for (start <- 0 to string.length) {\n            val substring\
    \ = string.substring(start)\n            if (isPalindrome(substring)) {\n    \
    \            prefix = string.substring(0, start)\n                return string\
    \ + prefix.reverse\n            }\n        }\n        return \"\"", "        val\
    \ reverse = string.reverse\n        var i = 0\n        while (i < string.length\
    \ && string(i) != reverse(0)) i += 1\n        return if (i < string.length) string\
    \ + reverse.substring(1) else string + reverse", "        // The function uses\
    \ this suffix string to check if a suffix of a given string is a palindrome.\n\
    \        // >>> isPalindromeSuffix(\"catac\", \"ac\")\n        // true\n     \
    \   // >>> isPalindromeSuffix(\"catac\", \"cat\")\n        // false\n        def\
    \ isPalindromeSuffix(string : String, suffix : String) : Boolean = {\n       \
    \     if (suffix.length == 0) true\n            else if (string.length < suffix.length)\
    \ false\n            else if (string.endsWith(suffix)) true\n            else\
    \ isPalindromeSuffix(string.dropRight(1), suffix)\n        }\n        // Function\
    \ first finds the longest palindromic suffix of a string.\n        // Then it\
    \ finds a prefix of a string that comes before the suffix, and returns a palindrome.\n\
    \        // >>> constructPalindrome(\"cat\")\n        // \"catac\"\n        //\
    \ >>> constructPalindrome(\"cata\")\n        // \"catac\"\n        def constructPalindrome(string\
    \ : String) : String = {\n            // Finds the longest palindromic suffix.\n\
    \            def findPalindromeSuffix(string : String, suffix : String) : String\
    \ = {\n                if (isPalindromeSuffix(string, suffix)) suffix\n      \
    \          else findPalindromeSuffix(string, suffix.drop(1))\n            }\n\
    \            // Returns a prefix of a string that comes before the palindromic\
    \ suffix.\n            def getPrefix(string : String, suffix : String) : String\
    \ = {\n                if (string.endsWith(suffix)) string.dropRight(suffix.length)\n\
    \                else getPrefix(string.dropRight(1), suffix)\n            }\n\
    \            val suffix = findPalindromeSuffix(string, string)\n            val\
    \ prefix = getPrefix(string, suffix)\n            string + prefix.reverse\n  \
    \      }\n        constructPalindrome(string)", "        def palindromeAt(string\
    \ : String, position : Int) : Boolean = {\n            var char1 = string(position)\n\
    \            var char2 = string(string.length - 1 - position)\n            (char1\
    \ == char2) && (if (position > 0) palindromeAt(string, position - 1) else true)\n\
    \        }\n        def reverse(string : String) : String = {\n            var\
    \ output = new StringBuilder()\n            for (i <- 0 until string.length) {\n\
    \                output += string(string.length - 1 - i)\n            }\n    \
    \        output.toString\n        }\n        def findLongestPalindrome(string\
    \ : String) : String = {\n            var long = \"\"\n            for (i <- 0\
    \ until string.length) {\n                if (palindromeAt(string, i)) {\n   \
    \                 long = string.substring(0, i + 1)\n                }\n     \
    \       }\n            long\n        }\n        var long = findLongestPalindrome(string)\n\
    \        var prefix = string.substring(long.length, string.length)\n        prefix\
    \ + string + reverse(prefix)", "        val r = string.reverse\n        val complete\
    \ = string + r\n        var (b, e) = (0, string.length)\n        var longest =\
    \ complete.substring(b, e)\n        while (e < complete.length) {\n          \
    \  if (complete.substring(b, e) == complete.substring(b, e).reverse) {\n     \
    \           longest = complete.substring(b, e)\n            }\n            b +=\
    \ 1\n            e += 1\n        }\n        longest + string.substring(longest.length,\
    \ string.length)", "        val (prefix, suffix) = string.span(s => s != string.last)\n\
    \        if (suffix.isEmpty) string\n        else suffix + prefix.reverse + suffix.last",
  "        val reversed = string.reverse\n        val (pre, suf) = string.zip(reversed).span(x\
    \ => x._1 != x._2)\n        return string + suf.reverse + pre.map(_._1).reverse",
  "      if (string.length <= 1) return string\n      val substrings = string.length\
    \ - 1 to 0 by -1 map(n => string.takeRight(n))\n      val palindromicSubstrings\
    \ = substrings filter {str => str == str.reverse}\n      val sortedSubstrings\
    \ = palindromicSubstrings sortBy {_.length}\n      val palindrome = sortedSubstrings.last\n\
    \      val prefix = string.dropRight(palindrome.length)\n      string + prefix.reverse",
  "        def isPalindrome(string : String) : Boolean = {\n            val n = string.length\n\
    \            if (n <= 1) {\n                true\n            } else {\n     \
    \           string(0) == string(n - 1) && isPalindrome(string.substring(1, n -\
    \ 1))\n            }\n        }\n        def findLongestPalindromeSuffix(string\
    \ : String) : String = {\n            if (isPalindrome(string)) {\n          \
    \      string\n            } else {\n                findLongestPalindromeSuffix(string.substring(1))\n\
    \            }\n        }\n        val suffix = findLongestPalindromeSuffix(string)\n\
    \        string + suffix.reverse.substring(string.length)", "        var longestPalindromePostfix\
    \ : String = \"\"\n        for (j <- 0 to string.length) {\n            val postfix\
    \ : String = string.substring(j)\n            if (isPalindrome(postfix)) {\n \
    \               longestPalindromePostfix = postfix\n                break\n  \
    \          }\n        }\n        val suffix : String = string.substring(0, string.length\
    \ - longestPalindromePostfix.length)\n        suffix.reverse + string", "    \
    \    val map = Map[Char, ListBuffer[Int]]()\n        val n = string.length\n \
    \       // Build map of indices of each character in the string.\n        for\
    \ (i <- 0 until n) {\n            val c = string(i)\n            if (!map.contains(c))\
    \ map(c) = ListBuffer[Int]()\n            map(c) += i\n        }\n        // Find\
    \ last index of the longest postfix that is a palindrome.\n        val palindromeEnd\
    \ = {\n            var maxEnd = 0\n            for (i <- 0 until n) {\n      \
    \          if (i < maxEnd) {\n                    val list = map(string(i))\n\
    \                    for (j <- list.size - 1 to 0 by -1) {\n                 \
    \       val candidate = list(j)\n                        if (i + candidate - 2\
    \ * maxEnd + 1 >= 0 && string(i - (candidate - maxEnd)) == string(candidate))\
    \ {\n                            maxEnd = candidate\n                        \
    \    break\n                        }\n                    }\n               \
    \ }\n                else {\n                    val list = map(string(i))\n \
    \                   for (j <- list.size - 1 to 0 by -1) {\n                  \
    \      val candidate = list(j)\n                        if (string(candidate)\
    \ == string(i)) {\n                            maxEnd = candidate\n          \
    \                  break\n                        }\n                    }\n \
    \               }\n            }\n            maxEnd\n        }\n        // Append\
    \ reversed prefix to the end of the string.\n        val prefix = string.substring(0,\
    \ n - palindromeEnd - 1)\n        string + prefix.reverse", "        def makePalindrome(s\
    \ : String, suffix : String) : String = {\n            if (s.length == 0) suffix\n\
    \            else {\n                val first = s.head\n                val last\
    \ = s.last\n                if (first == last) makePalindrome(s.slice(1, s.length\
    \ - 1), first + suffix)\n                else makePalindrome(s.slice(1, s.length),\
    \ suffix)\n            }\n        }\n        val suffix = makePalindrome(string,\
    \ \"\")\n        string + suffix.reverse", "        // Finds the longest palindromic\
    \ suffix of the string.\n        def findPalindromicSuffix(s : String) : String\
    \ = {\n            // Keeps track of the index of the suffix that is palindromic\
    \ so far.\n            var index : Int = s.length - 1\n            while (index\
    \ >= 0) {\n                if (s.substring(index).equals(s.substring(index).reverse))\
    \ return s.substring(index)\n                index -= 1\n            }\n     \
    \       return s\n        }\n        val suf = findPalindromicSuffix(string)\n\
    \        val prefix = string.substring(0, string.length - suf.length)\n      \
    \  return prefix + suf + prefix.reverse", "        val len = string.length\n \
    \       var palindromePostfixIndex = 0\n        for (i <- 1 to len) {\n      \
    \      if (isPalindrome(string.substring(len - i))) {\n                palindromePostfixIndex\
    \ = len - i\n                break\n            }\n        }\n        string +\
    \ (string.substring(0, palindromePostfixIndex)).reverse", "        val strlen\
    \ = string.length\n        val palindrome = Array.fill(strlen + 1, strlen + 1)(false)\n\
    \        var maxPalindrome = \"\"\n        for (len <- 0 to strlen) {\n      \
    \      for (i <- 0 to strlen - len) {\n                if (len == 0) palindrome(i)(i)\
    \ = true\n                else if (len == 1) palindrome(i)(i + 1) = string(i)\
    \ == string(i + 1)\n                else palindrome(i)(i + len) = string(i) ==\
    \ string(i + len) && palindrome(i + 1)(i + len - 1)\n                if (palindrome(i)(i\
    \ + len) && len > maxPalindrome.length) maxPalindrome = string.substring(i, i\
    \ + len + 1)\n            }\n        }\n        string + string.substring(maxPalindrome.length\
    \ + 1).reverse", "        val n = string.length\n        var maxi = -1\n     \
    \   var maxlen = -1\n        var palindrome = Array.ofDim[Int](n)\n        for\
    \ (i <- 0 until n) {\n            var start = 0\n            var end = min(i,\
    \ n - i - 1)\n            var len = 0\n            while (start <= end) {\n  \
    \              if (string(start) == string(n - 1 - end)) {\n                 \
    \   len += 1\n                    if (start == end) len += 1\n               \
    \ }\n                else len = 0\n                start += 1\n              \
    \  end -= 1\n            }\n            palindrome(i) = len\n            if (len\
    \ > maxlen) {\n                maxlen = len\n                maxi = i\n      \
    \      }\n        }\n        string + string.substring(maxi + maxlen).reverse",
  "        var prefix = \"\"\n        var palindrome = \"\"\n        for (i <- 0 to\
    \ string.length - 1) {\n            var j = i\n            while (j >= 0 && string(j)\
    \ == string(i - j)) j -= 1\n            if (j < 0) {\n                prefix =\
    \ string.substring(0, i + 1)\n                palindrome = string.substring(i\
    \ + 1)\n            }\n        }\n        return prefix + palindrome.reverse +\
    \ palindrome", "        if (string.isEmpty) return string\n        def removeLongestPostfix(s\
    \ : String) : (String, String) = {\n            var palindromeSuffix = string.substring(string.length\
    \ - s.length)\n            if (palindromeSuffix == s) (string.substring(0, string.length\
    \ - s.length), s)\n            else removeLongestPostfix(s.substring(0, s.length\
    \ - 1))\n        }\n        val (prefix, suffix) = removeLongestPostfix(string)\n\
    \        prefix + suffix + prefix.reverse", "        val len = string.length\n\
    \        val len_p = 2 * len + 1\n        val pal = Array.fill(len_p)(0)\n   \
    \     // '#' as a separator\n        val p : StringBuilder = new StringBuilder(len_p)\n\
    \        for (i <- 0 until len) {\n            p.append('#')\n            p.append(string(i))\n\
    \        }\n        p.append('#')\n        // Process palindromes\n        var\
    \ center = 0\n        var right = 0\n        for (i <- 0 until len_p) {\n    \
    \        var i_mirror = 2 * center - i\n            pal(i) = if (right > i) min(right\
    \ - i, pal(i_mirror)) else 0\n            while (i + 1 + pal(i) < len_p && i -\
    \ 1 - pal(i) >= 0 && p(i + 1 + pal(i)) == p(i - 1 - pal(i))) pal(i) += 1\n   \
    \         if (i + pal(i) > right) {\n                center = i\n            \
    \    right = i + pal(i)\n            }\n        }\n        // Find the longest\
    \ palindrome\n        val max_i = pal.indexOf(pal.max)\n        var prefix : StringBuilder\
    \ = new StringBuilder(max_i)\n        for (i <- 0 until max_i) prefix.append(p(i))\n\
    \        val reverse_prefix = prefix.reverse\n        prefix.append(string)\n\
    \        prefix.append(reverse_prefix)\n        return prefix.toString", "   \
    \     val rev = string.reverse\n        def rec(i : Int) : String = {\n      \
    \      if (i == string.length) string + rev\n            else if (string.substring(i,\
    \ string.length) == rev.substring(0, string.length - i)) string + rev.substring(string.length\
    \ - i)\n            else rec(i + 1)\n        }\n        rec(0)", "        var\
    \ palindrome : String = \"\"\n        if (string.length == 0) return string\n\
    \        val suffix : String = suffixPalindrome(string)\n        val prefix :\
    \ String = string.substring(0, string.length - suffix.length)\n        palindrome\
    \ = string + reverse(prefix)\n        return palindrome", "        def rev(s :\
    \ String) : String = if (s.isEmpty) \"\" else rev(s.tail) + s.head\n        def\
    \ loop(string : String, begin : Int, end : Int) : String = {\n            val\
    \ n = string.length\n            if (begin >= end) {\n                rev(string.substring(n\
    \ - begin, n)) + string\n            } else if (string(begin) == string(end))\
    \ {\n                loop(string, begin + 1, end - 1)\n            } else {\n\
    \                loop(string, begin, end - 1)\n            }\n        }\n    \
    \    loop(string, 0, string.length - 1)", "        var reversed = string.reverse\n\
    \        def isPalindrome(str : String) : Boolean = {\n            for (i <- 0\
    \ until str.length / 2) if (str(i) != str(str.length - 1 - i)) return false\n\
    \            return true\n        }\n        for (i <- 1 to string.length) {\n\
    \            if (isPalindrome(string.substring(string.length - i))) return string\
    \ + reversed.substring(string.length - i)\n        }\n        return string +\
    \ reversed", "        val length = string.length\n        val halfLength = length\
    \ / 2\n        val postfix = string.substring(halfLength)\n        val prefix\
    \ = string.substring(0, halfLength)\n        val reversedPrefix = prefix.reverse\n\
    \        // Find the suffix of the prefix that is a palindrome.\n        val suffix\
    \ = prefix.zipWithIndex.dropWhile(c => (c._1 != postfix(0))).map(_._1).mkString\n\
    \        if (suffix == \"\") {\n            val prefixLength = prefix.length\n\
    \            val suffixLength = postfix.length\n            val halfSuffixLength\
    \ = suffixLength / 2\n            val prefixSuffix = postfix.substring(0, halfSuffixLength)\n\
    \            val postfixSuffix = postfix.substring(halfSuffixLength)\n       \
    \     val postfixSuffixReversed = postfixSuffix.reverse\n            if (prefixSuffix\
    \ != postfixSuffixReversed) {\n                prefix + reversedPrefix + postfixSuffixReversed\
    \ + postfixSuffix\n            } else {\n                prefix + reversedPrefix\
    \ + postfix\n            }\n        } else {\n            prefix + reversedPrefix\
    \ + suffix\n        }", "        if (string.isEmpty) return string\n        def\
    \ reverse(s : String) : String = s.reverse\n        def isPalindrome(s : String)\
    \ : Boolean = s == reverse(s)\n        def findLongestPostfixPalindrome(str :\
    \ String) : String = {\n            if (str.isEmpty) return str\n            for\
    \ (i <- 0 to str.length - 1) {\n                val suffix = str.substring(i)\n\
    \                if (isPalindrome(suffix)) return suffix\n            }\n    \
    \        return str\n        }\n        val postfix = findLongestPostfixPalindrome(string)\n\
    \        val prefix = string.substring(0, string.length - postfix.length)\n  \
    \      return string + reverse(prefix)", "        def recurse(string : String,\
    \ prefix : String, suffix : String) : String = {\n            if (suffix.isEmpty)\
    \ string + prefix\n            else if (string(suffix.length) == suffix.last)\
    \ recurse(string, string(suffix.length) + prefix, suffix.dropRight(1))\n     \
    \       else recurse(string, prefix, suffix.dropRight(1))\n        }\n       \
    \ recurse(string, \"\", string)", "        val result : StringBuilder = new StringBuilder(string)\n\
    \        val longestPalindromeSuffix : String = findLongestPalindromeSuffix(string)\n\
    \        val prefix : String = string.substring(0, string.length - longestPalindromeSuffix.length)\n\
    \        result.append(reverse(prefix))\n        return result.toString", "  \
    \      if (string.length == 0) string\n        else {\n            val longestPostfix\
    \ = longestPalindromicPostfix(string, string.length)\n            val prefixLength\
    \ = string.length - longestPostfix\n            val prefix = string.substring(0,\
    \ prefixLength)\n            val reversePrefix = prefix.reverse\n            string\
    \ + reversePrefix\n        }", "        // Find the longest postfix of supplied\
    \ string that is a palindrome.\n        def findLongestPalindromicSuffix(string\
    \ : String) : (String, String) = {\n            def helper(string : String, suffix\
    \ : String) : (String, String) = {\n                if (suffix.length == string.length)\
    \ return (\"\", string)\n                val stringIndex = string.length - suffix.length\
    \ - 1\n                if (string.charAt(stringIndex) == suffix.charAt(0)) return\
    \ helper(string, suffix.substring(1))\n                (\"\", string.substring(stringIndex\
    \ + 1))\n            }\n            helper(string, string)\n        }\n      \
    \  // Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n        def appendReversePrefix(string : String, palindromicSuffix\
    \ : String) : String = {\n            val prefix = string.substring(0, string.length\
    \ - palindromicSuffix.length)\n            string + prefix.reverse\n        }\n\
    \        val (reversePrefix, palindromicSuffix) = findLongestPalindromicSuffix(string)\n\
    \        appendReversePrefix(string, palindromicSuffix)", "        // Find the\
    \ longest postfix of supplied string that is a palindrome.\n        def longestPalindromicPostfix(string\
    \ : String) : String = {\n            val n = string.length\n            var i\
    \ = n - 1\n            var j = 0\n            while (i >= 0) {\n             \
    \   val s = string.substring(i, n)\n                if (s == s.reverse) return\
    \ s\n                j += 1\n                i = n - j - 1\n            }\n  \
    \          return \"\"\n        }\n        // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n     \
    \   def appendReversePrefix(string : String, suffix : String) : String = {\n \
    \           val prefix = string.substring(0, string.length - suffix.length)\n\
    \            return string + prefix.reverse\n        }\n        // Find the longest\
    \ postfix of supplied string that is a palindrome.\n        val suffix = longestPalindromicPostfix(string)\n\
    \        // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n        appendReversePrefix(string, suffix)",
  "        if (string.length == 0) return string\n        val length = string.length\n\
    \        var longestPalindrome = string(0).toString\n        for (i <- 1 to length\
    \ - 1) {\n            val reversed = string.substring(0, i).reverse\n        \
    \    val substring = string.substring(i, length)\n            if (substring.startsWith(reversed)\
    \ && substring.length > longestPalindrome.length) {\n                longestPalindrome\
    \ = substring\n            }\n        }\n        return (string.substring(0, length\
    \ - longestPalindrome.length) + longestPalindrome.reverse + longestPalindrome)",
  "        val lps = longestPalindromicSubstring(string)\n        val prefix = string.substring(0,\
    \ string.length - lps.length)\n        val reversePrefix = prefix.reverse\n  \
    \      string + reversePrefix", "        val prefix = new StringBuilder\n    \
    \    var suffix = new StringBuilder\n        var i = 0\n        while (i < string.length)\
    \ {\n            suffix += string(i)\n            if (string.endsWith(suffix.toString))\
    \ prefix += string(i)\n            i += 1\n        }\n        string + prefix.reverse.toString",
  "        def postfixIsPalindrome(string : String) : Boolean = {\n            string.length\
    \ <= 1 || string.head == string.last && postfixIsPalindrome(string.tail.init)\n\
    \        }\n        def findLargestPostfixPalindrome(string : String) : String\
    \ = {\n            if (postfixIsPalindrome(string)) string\n            else findLargestPostfixPalindrome(string.init)\n\
    \        }\n        string + string.reverse.drop(findLargestPostfixPalindrome(string).length)",
  "        val longestSuffix = for(i <- string.indices) yield (i, string.substring(i))\n\
    \        val palindromicSuffix = longestSuffix.find(pair => (pair._2 == pair._2.reverse))\n\
    \        val reversePrefix = string.substring(0, palindromicSuffix.get._1).reverse\n\
    \        string + reversePrefix", "        val n = string.length\n        // Find\
    \ the longest suffix that is a palindrome.\n        var longest = -1\n       \
    \ for (i <- (0 until n)) {\n            if (string.charAt(i) == string.charAt(n\
    \ - 1)) {\n                var j = 0\n                while (j < n && string.charAt(i\
    \ + j) == string.charAt(n - 1 - j)) j += 1\n                if (j > longest) longest\
    \ = j\n            }\n        }\n        if (longest == n) return string\n   \
    \     // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n        val prefix = string.slice(0, n - longest)\n\
    \        (prefix + prefix.reverse).mkString + string", "        val l = string.length;\n\
    \        val palindromeSuffix = (1 to l).foreach(i => {\n            if (string.substring(0,\
    \ l - i).equals(string.substring(i, l).reverse)) return string.substring(i, l).reverse\
    \ + string\n        })\n        return string", "        def findPalindrome(string\
    \ : String) : (String, String) = {\n            val palindrome = new ArrayBuffer[Char]\n\
    \            val (head, tail) = string.splitAt(string.length / 2)\n          \
    \  var matched = true\n            for (i <- (0 until min(head.length, tail.length)).reverse)\
    \ {\n                val (headChar, tailChar) = (head(i), tail(tail.length - i\
    \ - 1))\n                if (headChar != tailChar) {\n                    matched\
    \ = false\n                    val palindrome = new ArrayBuffer[Char]\n      \
    \              val (prefix, suffix) = string.splitAt(i)\n                    for\
    \ (i <- (0 until (prefix.length - 1))) palindrome += prefix(i)\n             \
    \       for (i <- (0 until suffix.length)) palindrome += suffix(i)\n         \
    \           return (string.drop(i + 1), palindrome.mkString)\n               \
    \ }\n            }\n            if (matched) (string.drop(tail.length), string.take(tail.length))\n\
    \            else (\"\", \"\")\n        }\n        val (palindrome, prefix) =\
    \ findPalindrome(string)\n        val suffix = prefix.reverse\n        palindrome\
    \ + suffix", "        // Check that supplied string is not empty.\n        if\
    \ (string.length == 0) {\n            return \"\";\n        }\n        // Find\
    \ the longest postfix of supplied string that is a palindrome.\n        // Keep\
    \ a map of indices at which a string that starts at 0 ends and a postfix of\n\
    \        // the remainder is a palindrome.\n        // Map an index to a string\
    \ that starts at 0, ends at the index, and has a postfix that\n        // is a\
    \ palindrome.\n        var map : HashMap[Int, String] = new HashMap[Int, String];\n\
    \        map(0) = string.substring(0, 1);\n        for (i <- 2 to string.length)\
    \ {\n            val previousString = map(i - 2);\n            val currentSubstring\
    \ = string.substring(i - 1, i);\n            // Substring that starts at 0, ends\
    \ at i - 1, and has a palindromic postfix.\n            val previousPostfix =\
    \ previousString.substring(previousString.length - 1, previousString.length);\n\
    \            val previousStringReversed = previousString.reverse;\n          \
    \  // Substring that starts at 0, ends at i - 1, and has a palindromic postfix.\n\
    \            val currentString = previousString + currentSubstring;\n        \
    \    val currentPostfix = currentString.substring(currentString.length - 1, currentString.length);\n\
    \            val currentStringReversed = currentString.reverse;\n            //\
    \ String that starts at 0, ends at i - 1, and has a palindromic postfix.\n   \
    \         val currentPalindromicPostfixString = if (previousPostfix == currentSubstring)\
    \ previousString else currentString;\n            // Check if a substring that\
    \ starts at 0, ends at i, and has a palindromic postfix exists.\n            if\
    \ (currentStringReversed.substring(0, previousPostfix.length) == previousPostfix)\
    \ {\n                map(i - 1) = currentPalindromicPostfixString;\n         \
    \   }\n            if (currentStringReversed.substring(0, currentPostfix.length)\
    \ == currentPostfix) {\n                map(i) = currentPalindromicPostfixString;",
  "        if (string.isEmpty) return string\n        val reverse = string.reverse\n\
    \        val suffix = string.zip(reverse).takeWhile(function => function._1 ==\
    \ function._2).map(function => function._1).mkString\n        val prefix = string.substring(0,\
    \ string.length - suffix.length)\n        string + prefix.reverse", "        for\
    \ (len <- string.length to 0 by -1) {\n            val left = string.substring(0,\
    \ len)\n            val right = string.substring(len)\n            if (left ==\
    \ right.reverse) return string + right.reverse.substring(1)\n        }\n     \
    \   return \"\"", "        def solve(string : String, longestPalindromeEndIndex\
    \ : Int) : String = {\n            if (longestPalindromeEndIndex == string.length)\
    \ string\n            else solve(string + string.substring(0, string.length -\
    \ longestPalindromeEndIndex).reverse, longestPalindromeEndIndex + 1)\n       \
    \ }\n        solve(string, (0 to string.length).toList.filter(i => string.substring(i).reverse\
    \ == string.substring(i)).last)", "        val prefix = string.take(string.length\
    \ - longestPalindromeSuffix(string).length)\n        string + prefix.reverse",
  "        def longestPalindromeSuffix(string : String) : String = {\n           \
    \ val midpoint = string.length / 2\n            val left = midpoint\n        \
    \    val right = midpoint + (string.length % 2)\n            var found = false\n\
    \            var length = min(left, right)\n            while (!found && length\
    \ > 0) {\n                if (string(left - length) == string(right)) {\n    \
    \                found = true\n                    for (i <- 1 until length) {\n\
    \                        if (string(left - i) != string(right + i)) {\n      \
    \                      found = false\n                            length = i -\
    \ 1\n                            break\n                        }\n          \
    \          }\n                }\n                else length -= 1\n          \
    \  }\n            if (found) string.substring(left - length, right + length +\
    \ 1)\n            else string.substring(0, 1)\n        }\n        val suffix =\
    \ longestPalindromeSuffix(string)\n        val prefix = suffix.substring(0, string.length\
    \ - suffix.length)\n        string + prefix.reverse", "        if (string.length\
    \ == 0) return string\n        var maxPostfixLength = 0\n        for (i <- 0 to\
    \ string.length / 2) {\n            val prefixLength = string.length - i\n   \
    \         if (prefixLength == string.length) return string\n            val postfixLength\
    \ = string.length - prefixLength\n            val prefix = string.substring(0,\
    \ prefixLength)\n            val postfix = string.substring(postfixLength, string.length)\n\
    \            if (prefix == postfix) maxPostfixLength = max(maxPostfixLength, postfixLength)\n\
    \        }\n        return string + string.substring(0, string.length - maxPostfixLength).reverse",
  "        val suffix = suffixPalindrome(string)\n        if (suffix.length == string.length)\
    \ {\n            string\n        } else {\n            string + reverse(string.substring(0,\
    \ string.length - suffix.length))\n        }", "        var suffix = getLongestPalindromicSuffix(string)\n\
    \        if (suffix == string) return string\n        return string + reverse(string.substring(0,\
    \ string.length - suffix.length))", "        def helper(string : String, n : Int)\
    \ : String = {\n            if (n == 0) {string}\n            else if (string.substring(0,\
    \ n) == string.substring(string.length - n, string.length).reverse) {helper(string,\
    \ n - 1)}\n            else {helper(string, n + 1)}\n        }\n        val prefix\
    \ = string.substring(0, helper(string, 0))\n        return string + prefix.reverse",
  "        if (string.length == 0) return string\n        var longestPalindromePostfix\
    \ = 0\n        val L = string.length\n        var (i, j) = (0, L - 1)\n      \
    \  while (i < j) {\n            if (string(i) == string(j)) {\n              \
    \  longestPalindromePostfix += 1\n                i += 1\n                j -=\
    \ 1\n            }\n            else {\n                i = 0\n              \
    \  j -= 1\n                longestPalindromePostfix = 0\n            }\n     \
    \   }\n        val prefix = string.substring(0, L - longestPalindromePostfix)\n\
    \        return prefix + string + prefix.reverse", "        if (string.length\
    \ <= 1) return string\n        // We use ints for memoization.\n        // For\
    \ a character c and index i, memo(c)(i) stores the length of a postfix that starts\
    \ at i and which is a palindrome.\n        val memo = Array.fill(256)(Array.fill(string.length)(-1))\n\
    \        def findPalindromeLength(c : Char, i : Int) : Int = {\n            if\
    \ (memo(c)(i) != -1) return memo(c)(i)\n            var l = 0\n            var\
    \ j = i\n            while (j >= 0 && string(j) == c) {\n                if (j\
    \ > 0 && string(j - 1) == c) {\n                    l = 2\n                  \
    \  if (memo(c)(j - 1) != -1) {\n                        l += memo(c)(j - 1)\n\
    \                        break\n                    }\n                }\n   \
    \             else {\n                    l = 1\n                    break\n \
    \               }\n                j -= 1\n            }\n            memo(c)(i)\
    \ = l\n            return l\n        }\n        var maxLength = 1\n        var\
    \ i = string.length - 1\n        while (i >= 0) {\n            val l = findPalindromeLength(string(i),\
    \ i)\n            if (l > maxLength) maxLength = l\n            i -= 1\n     \
    \   }\n        val prefix = string.substring(0, string.length - maxLength)\n \
    \       val suffix = string.substring(string.length - maxLength)\n        return\
    \ prefix + suffix + prefix.reverse", "        val n = string.length\n        if\
    \ (n == 0) return \"\"\n        var i = n - 1\n        while (i >= 0) {\n    \
    \        if (string(i) == string(0)) {\n                var j = 0\n          \
    \      while (j < n - i) {\n                    if (string(i + j) != string(j))\
    \ break\n                    j += 1\n                }\n                if (j\
    \ == n - i) return string + string.substring(n - i).reverse\n            }\n \
    \           i -= 1\n        }\n        i = 0\n        while (i < n) {\n      \
    \      if (string(i) == string(n - 1)) {\n                var j = 0\n        \
    \        while (j < i) {\n                    if (string(i - j - 1) != string(n\
    \ - j - 1)) break\n                    j += 1\n                }\n           \
    \     if (j == i) return string.substring(0, i).reverse + string\n           \
    \ }\n            i += 1\n        }\n        \"\"", "      val l = string.length\n\
    \      var i = 1\n      while(i <= l / 2) {\n        if (string.substring(0, l\
    \ - i) == string.substring(i).reverse) return string + string.substring(0, l -\
    \ i).reverse\n        i += 1\n      }\n      return string + string.substring(1).reverse",
  "        // Find the longest suffix of string that is a palindrome\n        def\
    \ isPalindrome(s : String) : Boolean = s == s.reverse\n        val longestPalindromePostfix\
    \ = string.inits.find(isPalindrome(_)).get\n        val stringPrefix = string.substring(0,\
    \ string.length - longestPalindromePostfix.length)\n        string + stringPrefix.reverse",
  "        val s = new StringBuilder(string)\n        for (i <- 0 until string.length)\
    \ {\n            if (string.substring(i, string.length) == string.substring(i,\
    \ string.length).reverse) {\n                s.append(string.substring(0, i).reverse)\n\
    \                return s.toString\n            }\n        }\n        return string",
  "        val s = string.toArray\n        val dp = Array.fill(s.length, s.length)(0)\n\
    \        for (length <- 0 to s.length - 1) {\n            for (start <- 0 to s.length\
    \ - 1 - length) {\n                if (length == 0) dp(start)(start) = 1\n   \
    \             else if (length == 1) dp(start)(start + 1) = if (s(start) == s(start\
    \ + 1)) 2 else 1\n                else dp(start)(start + length) = if (s(start)\
    \ == s(start + length) && dp(start + 1)(start + length - 1) > 0) dp(start + 1)(start\
    \ + length - 1) + 2 else max(dp(start + 1)(start + length), dp(start)(start +\
    \ length - 1))\n            }\n        }\n        val prefix = s.slice(0, s.length\
    \ - dp(0)(s.length - 1)).reverse\n        return string + prefix.mkString", " \
    \       val postfix = longestPalindromicPostfix(string)\n        val prefix =\
    \ string.substring(0, string.length - postfix.length)\n        return prefix +\
    \ postfix + prefix.reverse", "        var prefix = string\n        while (!prefix.isEmpty\
    \ && !prefix.equals(prefix.reverse)) {\n            prefix = prefix.substring(0,\
    \ prefix.length - 1)\n        }\n        if (prefix.isEmpty) string + string.reverse\n\
    \        else {\n            val suffix = string.substring(prefix.length)\n  \
    \          val prefix = string.substring(0, string.length - suffix.length)\n \
    \           prefix + suffix + prefix.reverse\n        }", "        // 1. Build\
    \ longest suffix that is a palindrome\n        var suffix = string\n        var\
    \ suffixPalindrome : String = \"\"\n        while (suffix.length > 0) {\n    \
    \        if (isPalindrome(suffix)) {\n                suffixPalindrome = suffix\n\
    \                break\n            }\n            suffix = suffix.drop(1)\n \
    \       }\n        // 2. Build a reverse string that contains everything before\
    \ the palindromic suffix\n        var prefix : String = \"\"\n        for (ch\
    \ <- string.drop(suffixPalindrome.length)) prefix = ch + prefix\n        // 3.\
    \ Concatenate and return\n        return string + prefix", "        def reverse(str\
    \ : String) : String = {\n            str.toCharArray.reverse.mkString\n     \
    \   }\n        if (string.length == 0) string\n        else {\n            val\
    \ postfixLength = palindromePostfixLength(string)\n            if (postfixLength\
    \ == string.length) string\n            else {\n                val prefix = string.substring(0,\
    \ string.length - postfixLength)\n                val reversePrefix = reverse(prefix)\n\
    \                string + reversePrefix\n            }\n        }", "        def\
    \ reverse(string : String) : String = string.reverse\n        def checkPalindrome(string\
    \ : String) : Boolean = string == reverse(string)\n        def accumulatePalindrome(string\
    \ : String, accumulator : String) : String = {\n            if (checkPalindrome(string))\
    \ accumulator\n            else accumulatePalindrome(string.dropRight(1), accumulator\
    \ + string.takeRight(1))\n        }\n        accumulatePalindrome(string, \"\"\
    ) + reverse(string.take(string.length - accumulatePalindrome(string, \"\").length))",
  "        // Find the longest palindromic suffix.\n        def findSuffix(s : String)\
    \ : String = {\n            if (s.length <= 1) return s\n            val (l, r)\
    \ = (s.length / 2, s.length / 2 + s.length % 2)\n            var i = 0\n     \
    \       while (i < l && s(i) == s(r + i)) { i += 1 }\n            if (i == l)\
    \ return s\n            else return findSuffix(s.substring(0, l - i))\n      \
    \  }\n        val suffix = findSuffix(string)\n        return string + suffix.reverse.substring(string.length\
    \ - suffix.length)", "        def palindrome(string : String) : Boolean = {\n\
    \            def loop(i : Int, j : Int) : Boolean = {\n                if (i ==\
    \ j) true\n                else if (i + 1 == j) string(i) == string(j)\n     \
    \           else if (string(i) == string(j)) loop(i + 1, j - 1)\n            \
    \    else false\n            }\n            loop(0, string.length - 1)\n     \
    \   }\n        if (palindrome(string)) string\n        else {\n            val\
    \ prefix = string.take(string.length - 1)\n            val reversedPrefix = prefix.reverse\n\
    \            string + reversedPrefix\n        }", "        val length = string.length\n\
    \        val maxPalindromeLength = (1 to length / 2).foldLeft(1)((accum, i) =>\
    \ {\n            if (string(i - 1) == string(length - i)) accum + 2 else accum\n\
    \        })\n        string + string.take(length - maxPalindromeLength).reverse",
  "        if (string.length == 0) return \"\"\n        def longestPostfixPalindrome(string\
    \ : String) : String = {\n            def isPalindrome(string : String) : Boolean\
    \ = {\n                val rev = string.reverse\n                return string\
    \ == rev\n            }\n            var index = 0\n            while (index <\
    \ string.length && !isPalindrome(string.substring(index))) {\n               \
    \ index += 1\n            }\n            return string.substring(index)\n    \
    \    }\n        val lpp = longestPostfixPalindrome(string)\n        if (lpp.length\
    \ == string.length) return string\n        else return string + string.substring(0,\
    \ string.length - lpp.length).reverse", "        def findMaxPostfixPalindrome(string\
    \ : String) : (String, String) = {\n            var max : (String, String) = (\"\
    \", \"\")\n            for (i <- 0 to string.length) {\n                val s\
    \ = string.substring(0, i)\n                if (s == s.reverse) max = (s, string.substring(i))\n\
    \            }\n            max\n        }\n        val (s1, s2) = findMaxPostfixPalindrome(string)\n\
    \        s1 + s2.reverse + s2", "        def make(input : String) : String = {\n\
    \            if (input.isEmpty) \"\"\n            else {\n                val\
    \ suffix = longestPalindrome(input)\n                val prefix = input.substring(0,\
    \ input.length - suffix.length)\n                return input + prefix.reverse\n\
    \            }\n        }\n        return make(string)", "        def recurse(length\
    \ : Int) : Int = if (length == 0) 0 else if (string.substring(0, length) == string.substring(string.length\
    \ - length)) length else recurse(length - 1)\n        val prefix = string.substring(0,\
    \ recurse(string.length - 1))\n        string + prefix.reverse", "        val\
    \ r = new StringBuilder(string).reverse.toString\n        val p = (string + \"\
    #\" + r).toArray\n        val z = new Array[Int](p.length)\n        for (i <-\
    \ 1 until p.length) {\n            if (p(i) == p(z(i - 1))) z(i) = z(i - 1) +\
    \ 1\n            else {\n                var l = 0\n                var r = min(z(i\
    \ - 1), i)\n                while (l < r) {\n                    val m = (l +\
    \ r) / 2\n                    if (z(m) < i - m) l = m + 1\n                  \
    \  else r = m\n                }\n                z(i) = l\n            }\n  \
    \      }\n        string + r.substring(r.length - z(p.length - 1))", "       \
    \ def postfixPalindromeLength(string : String) : Int = {\n            var length\
    \ = 0\n            for (i <- 0 to string.length / 2) {\n                if (string(i)\
    \ == string(string.length - 1 - i)) length += 1\n                else return length\n\
    \            }\n            length\n        }\n        val length = postfixPalindromeLength(string)\n\
    \        if (length == string.length) return string\n        else return string\
    \ + string.slice(0, string.length - length).reverse", "        val palindrome\
    \ = new StringBuilder()\n        val postfix = new StringBuilder()\n        val\
    \ prefix = new StringBuilder()\n        val (end, length) = postfixPalindrome(string)\n\
    \        prefix.append(string.substring(0, end + 1))\n        postfix.append(string.substring(end\
    \ + 1, string.length))\n        palindrome.append(postfix.toString() + prefix.toString().reverse)\n\
    \        palindrome.toString()", "        var i = 0\n        var j = string.length\
    \ - 1\n        while (i < j) {\n            if (string(i) != string(j)) return\
    \ string.substring(0, i) + string.substring(j + 1, string.length) + string.substring(i,\
    \ j + 1).reverse\n            i += 1\n            j -= 1\n        }\n        return\
    \ string", "        val longestPalindromeSuffix = string.tails.find(_ == _.reverse).get\n\
    \        string + longestPalindromeSuffix.reverse.drop(1)", "        if (string.length()\
    \ == 0) return \"\"\n        val reversed = string.reverse\n        val n = string.length()\n\
    \        for (i <- n until 0 by -1) {\n            if (string.substring(0, i)\
    \ == reversed.substring(n - i)) return string + reversed.substring(0, n - i)\n\
    \        }\n        return \"\"", "        if (string.length <= 1) return string\n\
    \        var longestPalindromeLength = 0\n        var longestPalindromePosition\
    \ = 0\n        for (position <- 0 to string.length - 1) {\n            var start\
    \ = position - 1\n            var end = position + 1\n            while (start\
    \ >= 0 && end < string.length && string(start) == string(end)) {\n           \
    \     start -= 1\n                end += 1\n            }\n            if (end\
    \ - start - 1 > longestPalindromeLength) {\n                longestPalindromeLength\
    \ = end - start - 1\n                longestPalindromePosition = start + 1\n \
    \           }\n            start = position\n            end = position + 1\n\
    \            while (start >= 0 && end < string.length && string(start) == string(end))\
    \ {\n                start -= 1\n                end += 1\n            }\n   \
    \         if (end - start - 1 > longestPalindromeLength) {\n                longestPalindromeLength\
    \ = end - start - 1\n                longestPalindromePosition = start + 1\n \
    \           }\n        }\n        if (longestPalindromeLength != 0) {\n      \
    \      return string + string.substring(0, string.length - longestPalindromePosition).reverse\n\
    \        }\n        return string + string.reverse.substring(1)", "        def\
    \ longestPalindromeSuffix(string : String) : String = {\n            def isPalindrome(string\
    \ : String) : Boolean = {\n                var (i, j) = (0, string.length - 1)\n\
    \                while (i < j) {\n                    if (string(i) != string(j))\
    \ return false\n                    i += 1\n                    j -= 1\n     \
    \           }\n                return true\n            }\n            var i =\
    \ string.length\n            while (i > 0) {\n                if (isPalindrome(string.substring(string.length\
    \ - i))) return string.substring(string.length - i)\n                i -= 1\n\
    \            }\n            return \"\"\n        }\n        return string + string.substring(0,\
    \ string.length - longestPalindromeSuffix(string).length).reverse", "        val\
    \ suffixLength = string.length - 1 - (0 until string.length / 2).reverse.find(\n\
    \                i => string(i) == string(string.length - 1 - i)).getOrElse(0)\n\
    \        string + string.substring(0, string.length - suffixLength).reverse",
  "        val stringReverse = string.reverse\n        val suffix = {\n          \
    \  var result = string.length\n            while (result > 0 && !string.endsWith(stringReverse.substring(0,\
    \ result))) {\n                result -= 1\n            }\n            result\n\
    \        }\n        string + stringReverse.substring(suffix)", "        val suf\
    \ = SuffixTree(string)\n        val stringSuffixLength = suf.getPalindromicSuffixLength()\n\
    \        string + string.substring(0, string.length - stringSuffixLength).reverse",
  "        var longestPalindrome : String = \"\"\n        for (i <- 0 to string.length)\
    \ {\n            val str = string.substring(i)\n            if (isPalindrome(str))\
    \ {\n                longestPalindrome = str\n                break\n        \
    \    }\n        }\n        val prefix = string.substring(0, string.length - longestPalindrome.length)\n\
    \        string + prefix.reverse", "        var buffer = new StringBuilder(string);\n\
    \        if (buffer.isEmpty) return \"\";\n        for (i <- 1 to buffer.length)\
    \ {\n            if (buffer.endsWith(buffer.take(i).reverse)) {\n            \
    \    return buffer.reverse.append(buffer.drop(i)).toString;\n            }\n \
    \       }\n        return \"\";", "        def isPalindrome(string : String) :\
    \ Boolean = {\n            val n = string.length\n            for (i <- 0 until\
    \ (n / 2)) {\n                if (string(i) != string(n - 1 - i)) {\n        \
    \            return false\n                }\n            }\n            return\
    \ true\n        }\n        var reversed = \"\"\n        for (i <- 0 until string.length)\
    \ {\n            val str = string.substring(0, i)\n            if (isPalindrome(str))\
    \ {\n                reversed = string.substring(i)\n            }\n        }\n\
    \        return string + reversed.reverse", "        if (string.length == 0) return\
    \ \"\"\n        val m = Array.ofDim[Int](string.length + 1, string.length + 1)\n\
    \        for (i <- 0 to string.length) m(i)(0) = 0\n        for (j <- 0 to string.length)\
    \ m(0)(j) = 0\n        for (i <- 1 to string.length) {\n            for (j <-\
    \ 1 to string.length) {\n                if (string(i - 1) == string(string.length\
    \ - j)) {\n                    m(i)(j) = m(i - 1)(j - 1) + 1\n               \
    \ } else {\n                    m(i)(j) = max(m(i - 1)(j), m(i)(j - 1))\n    \
    \            }\n            }\n        }\n        val maxPostfixLength = m(string.length)(string.length)\n\
    \        var reversePrefix = \"\"\n        for (i <- 0 until string.length - maxPostfixLength)\
    \ reversePrefix += string(i)\n        return string + reversePrefix.reverse",
  "        val reversedString = string.reverse\n        val pairs = string.zip(reversedString)\n\
    \        val index = pairs.lastIndexWhere(_._1 != _._2)\n        val palindrome\
    \ = pairs.slice(0, index + 1).unzip._1.mkString\n        val prefix = string.substring(index\
    \ + 1, string.length)\n        return prefix + palindrome + prefix.reverse", " \
    \       val N = string.length\n        // Find the longest postfix of a string\
    \ that is a palindrome.\n        // This is done via dynamic programming.\n  \
    \      // The function f(i) is the length of the longest palindromic postfix of\
    \ a string with a length of i.\n        val f = Array.fill(N)(0)\n        for\
    \ (i <- (1 to N-1).reverse) {\n            val j = i - f(i) - 1\n            if\
    \ (string(i) == string(j)) {\n                var prefixLength = 0\n         \
    \       while (i + prefixLength + 1 < N && string(i + prefixLength + 1) == string(j\
    \ - prefixLength - 1)) {\n                    prefixLength += 1\n            \
    \    }\n                f(i) = f(i) + prefixLength + 1\n            }\n      \
    \  }\n        // Find the first index k such that f(k) = 0.\n        // This is\
    \ where we'll split our string.\n        var k = N - 1\n        while (k >= 0\
    \ && f(k) != 0) k -= 1\n        val prefix = string.substring(0, k + 1)\n    \
    \    string + prefix.reverse", "        if (string.length == 0) return string\n\
    \        // Find the longest postfix of the supplied string that is a palindrome\n\
    \        def findLongestPalindromicPostfix(string : String) : (String, String)\
    \ = {\n            if (string.length <= 1) return (string, \"\")\n           \
    \ if (string.charAt(0) == string.charAt(string.length - 1)) {\n              \
    \  val postfix = string.substring(0, string.length - 1)\n                val pair\
    \ = findLongestPalindromicPostfix(postfix)\n                (pair._1 + pair._2,\
    \ pair._2 + string.charAt(string.length - 1))\n            } else {\n        \
    \        (\"\", string)\n            }\n        }\n        val pair = findLongestPalindromicPostfix(string)\n\
    \        pair._1 + string + pair._2.reverse", "        val length = string.length\n\
    \        if (length == 0) return \"\"\n        // Compute the longest suffix which\
    \ is a palindrome.\n        val longestSuffixLength = new Array[Int](length)\n\
    \        longestSuffixLength(length - 1) = 1\n        // Traverse the string backwards.\n\
    \        for (i <- length - 2 to 0 by -1) {\n            if (string(i) == string(length\
    \ - 1)) {\n                // Compute the length of palindromic suffix and store\
    \ it.\n                longestSuffixLength(i) = 1 + longestSuffixLength(i + 1)\n\
    \            } else {\n                // Current suffix is not a palindrome so\
    \ store 0.\n                longestSuffixLength(i) = 0\n            }\n      \
    \  }\n        // The idea of this computation is that if the longest palindromic\
    \ suffix of a string does not include\n        // first character of the string\
    \ then the string itself is a palindrome and no further manipulation is\n    \
    \    // needed. Otherwise we need to append to the end of the string the reverse\
    \ of a prefix which comes\n        // before the palindromic suffix.\n       \
    \ if (longestSuffixLength(0) == 0) return string\n        // Append prefix that\
    \ comes before the palindromic suffix.\n        var result = string\n        for\
    \ (i <- 0 until length - longestSuffixLength(0)) {\n            result += string(i)\n\
    \        }\n        return result", "        if (string.length == 0) return string\n\
    \        val length = string.length\n        var i = 1\n        var j = length\
    \ - 1\n        var palindrome = \"\"\n        while (i <= j) {\n            if\
    \ (string(i - 1) == string(j)) {\n                palindrome = string.substring(i\
    \ - 1, j + 1)\n                i += 1\n                j -= 1\n            } else\
    \ {\n                i = 1\n                j -= 1\n            }\n        }\n\
    \        return string + new StringBuffer(string.substring(0, length - palindrome.length)).reverse",
  "        var prefix : String = \"\"\n        var postfix : String = \"\"\n     \
    \   var length = string.length\n        var length_test = length\n        for\
    \ (i <- length - 1 to 0 by -1) {\n            length_test -= 1\n            prefix\
    \ = string.substring(0, length_test)\n            postfix = string.substring(i,\
    \ length)\n            if (prefix == postfix.reverse) return string + postfix.reverse.substring(length_test)\n\
    \        }\n        string + postfix.reverse", "        if (string.length == 0)\n\
    \            return string\n        val prefix = string.substring(0, string.length\
    \ - 1)\n        return string + prefix.reverse", "        val maxPostfixLength\
    \ = findMaxPostfixLength(string)\n        string + new StringBuilder(string.substring(0,\
    \ string.length - maxPostfixLength)).reverse.toString", "        def rotate(string\
    \ : String) : String = {\n            if (string.length == 0) return \"\"\n  \
    \          val h = string.head\n            val t = string.tail\n            val\
    \ rotated = t + h\n            rotated\n        }\n        def isPalindrome(string\
    \ : String) : Boolean = {\n            for (i <- 0 until string.length / 2) {\n\
    \                if (string(i) != string(string.length - 1 - i)) return false\n\
    \            }\n            return true\n        }\n        if (isPalindrome(string))\
    \ return string\n        var prefix = \"\"\n        var suffix = string\n    \
    \    while (!isPalindrome(suffix)) {\n            prefix = rotate(prefix)\n  \
    \          suffix = rotate(suffix)\n        }\n        val s = string.substring(0,\
    \ string.length - suffix.length)\n        return (s + suffix + s.reverse)", " \
    \       var length = string.length\n        var index = 0\n        var palindrome\
    \ = string\n        for (index <- 1 to length / 2) {\n            var prefix =\
    \ string.substring(0, length - index)\n            var suffix = string.substring(length\
    \ - index, length)\n            if (prefix == suffix.reverse) {\n            \
    \    palindrome = prefix + string\n                return palindrome\n       \
    \     }\n        }\n        return palindrome", "        for (i <- string.length\
    \ - 1 to 0 by -1) {\n            if (string.substring(i).equals(string.substring(i).reverse))\
    \ return string + string.substring(0, i).reverse\n        }\n        string",
  "        // Find longest palindromic suffix (must be non-empty).\n        def findPalindromicSuffix(s\
    \ : String) : (String, String) = {\n            // Check if the string is a palindrome.\n\
    \            def isPalindrome(s : String) : Boolean = (s == s.reverse)\n     \
    \       // Make the string longer and longer by appending to its postfix.\n  \
    \          for (suffix <- Range(1, s.length + 1)) {\n                val candidateSuffix\
    \ = s.substring(s.length - suffix)\n                if (isPalindrome(candidateSuffix))\
    \ {\n                    val prefix = s.substring(0, s.length - suffix)\n    \
    \                return (prefix, candidateSuffix)\n                }\n       \
    \     }\n            // No palindromic suffix found.\n            (\"\", \"\"\
    )\n        }\n        val (prefix, suffix) = findPalindromicSuffix(string)\n \
    \       prefix + suffix + prefix.reverse", "        val postfixPalindrome = Problem.maxPostfixPalindrome(string)\n\
    \        val prefix = string.substring(0, string.length - postfixPalindrome.length)\n\
    \        prefix + postfixPalindrome + prefix.reverse", "        val palindromePostfix\
    \ = findPalindromePostfix(string)\n        val prefixReverse = findPrefixReverse(string,\
    \ palindromePostfix)\n        string + prefixReverse", "        val l = string.length\n\
    \        val end = l\n        var mid = (l - 1) / 2\n        var i = l - 1\n \
    \       while (i >= 0) {\n            while (mid - i >= 0 && mid + i < end &&\
    \ string(mid - i) == string(mid + i)) i -= 1\n            if (mid - i < 0 || mid\
    \ + i >= end) {\n                val prefix = string.substring(mid + i + 1)\n\
    \                return prefix + string + prefix.reverse\n            }\n    \
    \        else i = l - 1\n            mid -= 1\n        }\n        string", " \
    \       def suffix(string : String) : String = if (string.length == 0) string\
    \ else string.charAt(string.length - 1) + suffix(string.substring(0, string.length\
    \ - 1))\n        def isPalindrome(string : String) : Boolean = {\n           \
    \ val half = string.length / 2\n            if (string.length == 0) true\n   \
    \         else if (string.charAt(0) != string.charAt(string.length - 1)) false\n\
    \            else isPalindrome(string.substring(1, string.length - 1))\n     \
    \   }\n        def palindromeSuffix(string : String) : String = {\n          \
    \  val suffixLength = 1 to string.length\n            val palindromicSuffix =\
    \ suffixLength.map(l => (l, string.substring(string.length - l, string.length))).filter(x\
    \ => isPalindrome(x._2)).sortBy(x => x._1).last\n            palindromicSuffix._2\n\
    \        }\n        val palindromicSuffix = palindromeSuffix(string)\n       \
    \ val palindromicPrefix = string.substring(0, string.length - palindromicSuffix.length)\n\
    \        palindromicPrefix + palindromicSuffix + suffix(palindromicPrefix)", " \
    \       def isPalindrome(string : String) : Boolean = string.zip(string.reverse).takeWhile(x\
    \ => x._1 == x._2).length == string.length\n        if (isPalindrome(string))\
    \ string\n        else {\n            val suffixLength = ((string.length - 1)\
    \ to 0 by -1).find(suffixLength => isPalindrome(string.substring(string.length\
    \ - suffixLength))) match {\n                case Some(suffixLength) => suffixLength\n\
    \                case None => throw new IllegalArgumentException\n           \
    \ }\n            string + string.substring(0, string.length - suffixLength).reverse\n\
    \        }", "        val n = string.length\n        val lps = longestPalindromicSubstring(string)\n\
    \        val p = string.substring(0, n - lps.length)\n        string + reverse(p)",
  "        val length = string.length\n        var longestPalindromeLength = 0\n \
    \       var longestPalindromeEndingAtIndex = -1\n        var i = 0\n        while\
    \ (i < length) {\n            var start = i\n            var end = i\n       \
    \     while (start >= 0 && end < length && string(start) == string(end)) {\n \
    \               start -= 1\n                end += 1\n            }\n        \
    \    start += 1\n            end -= 1\n            val palindromeLength = end\
    \ - start + 1\n            if (palindromeLength > longestPalindromeLength) {\n\
    \                longestPalindromeLength = palindromeLength\n                longestPalindromeEndingAtIndex\
    \ = end\n            }\n            i += 1\n        }\n        val longestPalindrome\
    \ = string.substring(longestPalindromeEndingAtIndex - longestPalindromeLength\
    \ + 1, longestPalindromeEndingAtIndex + 1)\n        val stringPrefixBeforePalindrome\
    \ = string.substring(0, longestPalindromeEndingAtIndex - longestPalindromeLength\
    \ + 1)\n        return longestPalindrome + new StringBuffer(stringPrefixBeforePalindrome).reverse.toString",
  "        var palindrome : StringBuilder = new StringBuilder(string)\n        //\
    \ If the string is a palindrome already, no need to do anything.\n        if (!isPalindrome(string))\
    \ {\n            // Find the longest palindromic suffix of the string.\n     \
    \       var suffix : String = longestPalindromicSuffix(string)\n            //\
    \ Append to the end of the string reverse of a prefix that comes before the palindromic\
    \ suffix.\n            palindrome.append(reverse(string.substring(0, string.length\
    \ - suffix.length)))\n        }\n        return palindrome.toString", "      \
    \  var palindrome = new StringBuilder(string)\n        val len = string.length\n\
    \        for (i <- len - 1 to 0 by -1) {\n            val prefix = string.substring(0,\
    \ i)\n            val suffix = string.substring(i, len)\n            if (prefix\
    \ == suffix.reverse) {\n                palindrome.append(prefix.reverse)\n  \
    \              return palindrome.toString\n            }\n        }\n        palindrome.append(string.reverse)\n\
    \        return palindrome.toString", "        val n = string.length\n       \
    \ var maxPalindromeStart = 0\n        var maxPalindromeLength = 0\n        for\
    \ (i <- (0 until n).reverse) {\n            if (string(i) == string(0)) {\n  \
    \              var length = 0\n                for (k <- 0 until n) {\n      \
    \              if (k + i < n && string(k) == string(k + i)) length += 1\n    \
    \                else break\n                }\n                if (length > maxPalindromeLength)\
    \ {\n                    maxPalindromeStart = i\n                    maxPalindromeLength\
    \ = length\n                }\n            }\n        }\n        string + string.substring(0,\
    \ maxPalindromeStart).reverse", "      if (string.isEmpty) return string\n   \
    \   var prefix : String = \"\"\n      var suffix : String = \"\"\n      for (i\
    \ <- 0 to string.length) {\n        if (string.substring(0, i) == string.substring(i,\
    \ string.length).reverse) {\n          prefix = string.substring(0, i)\n     \
    \     suffix = string.substring(i, string.length)\n        }\n      }\n      return\
    \ prefix + suffix.reverse + suffix", "        val stringBuffer = new StringBuffer(string)\n\
    \        val stringList = stringBuffer.toList\n        val stringListRev = stringList.reverse\n\
    \        val length = stringList.length\n        for (i <- (1 to length)) {\n\
    \            if (stringList.drop(length - i) == stringListRev.take(i)) return\
    \ stringBuffer.append(stringListRev.drop(i)).toString\n        }\n        stringBuffer.append(stringListRev).toString",
  "        val n = string.length\n        val suffix = (0 until n).find(i => isPalindrome(string.substring(i))).getOrElse(0)\n\
    \        val prefix = string.substring(0, n - suffix)\n        string + prefix.reverse",
  "        val length = string.length\n        if (length == 0) {\n            return\
    \ string\n        }\n        var j = 0\n        while (j < length && (string(j)\
    \ == string(length - 1 - j))) {\n            j += 1\n        }\n        val prefix\
    \ = string.substring(0, j)\n        return string + prefix.reverse", "       \
    \ var longestPostfix : String = \"\"\n        for (substring <- string.substrings)\
    \ if (substring.isPalindrome && substring.length > longestPostfix.length) longestPostfix\
    \ = substring\n        return string + string.substring(0, string.length - longestPostfix.length).reverse",
  "        if (string.length == 0) return \"\"\n        var suffix = findPalindromicSuffix(string)\n\
    \        val prefix = string.substring(0, string.length - suffix.length)\n   \
    \     return prefix + suffix + prefix.reverse", "        var longestPalindrome\
    \ = \"\"\n        for (i <- 0 to string.length) {\n            val suffix = string.substring(i)\n\
    \            if (isPalindrome(suffix)) longestPalindrome = suffix\n        }\n\
    \        string + string.substring(0, string.length - longestPalindrome.length).reverse",
  "        val l = string.length\n        var max = 0\n        for (i <- 0 until l)\
    \ {\n            if (i + 1 < l && string(i) == string(i + 1)) {\n            \
    \    var j = 0\n                while (i - j >= 0 && i + 1 + j < l && string(i\
    \ - j) == string(i + 1 + j)) j += 1\n                if (i - j < 0) max = j *\
    \ 2 + 1\n            }\n            if (string(i) == string(i)) {\n          \
    \      var j = 0\n                while (i - j >= 0 && i + j < l && string(i -\
    \ j) == string(i + j)) j += 1\n                if (i - j < 0) max = j * 2\n  \
    \          }\n        }\n        string + string.substring(0, l - max).reverse",
  "        val palindromeSuffix = findPalindromeSuffix(string)\n        string + reverseString(string.substring(0,\
    \ string.length - palindromeSuffix.length))", "        val suffixes = string.tails.map(_.mkString).toArray.reverse\n\
    \        val matchingSuffix = suffixes.find(suffix => {\n            if (suffix.length\
    \ == 1) true\n            else suffix.substring(0, (suffix.length + 1) / 2) ==\
    \ suffix.substring((suffix.length + 1) / 2).reverse\n        })\n        matchingSuffix\
    \ match {\n            case Some(suffix) => string + string.substring(0, string.length\
    \ - suffix.length).reverse\n            case None => string\n        }"]
stop_tokens:
- "\n    }\n"
