name: HumanEval_139_special_factorial
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // The Brazilian factorial is defined as:\n    // brazilian_factorial(n) =\
  \ n! * (n-1)! * (n-2)! * ... * 1!\n    // where n > 0\n    // For example:\n   \
  \ // >>> specialFactorial((4l))\n    // (288l)\n    // The function will receive\
  \ an integer as input and should return the special\n    // factorial of this integer.\n\
  \    def specialFactorial(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(specialFactorial((4l))\
  \ == (288l));\n    assert(specialFactorial((5l)) == (34560l));\n    assert(specialFactorial((7l))\
  \ == (125411328000l));\n    assert(specialFactorial((1l)) == (1l));\n    }\n\n}\n"
completions: ["\tif (n <= 0) 1l\n\telse n * specialFactorial(n - 1)", "        var\
    \ rs = n\n        for (i <- (1 to n.toInt - 1).reverse) rs *= i\n        rs",
  "        val l = List.range(1, n + 1)\n        l.map(BigInt(_)).product.toLong",
  "        def specialFactorialImpl(n : Long, acc : Long) : Long = {\n           \
    \ if (n == 0) acc\n            else specialFactorialImpl(n - 1, acc * n)\n   \
    \     }\n        specialFactorialImpl(n, 1)", "        def specialFactorial(n\
    \ : Long, acc : Long) : Long = n match {\n            case 0 => acc\n        \
    \    case _ => specialFactorial(n - 1, acc * n)\n        }\n        specialFactorial(n,\
    \ 1)", "        var m = n\n        var p = 1l\n        while (m > 0) {\n     \
    \       p *= factorial(m)\n            m -= 1\n        }\n        p", "    \t\
    var list = new ArrayBuffer[Long]()\n    \tfor (i <- 1 to n.toInt) {\n    \t\t\
    list += i\n    \t}\n    \treturn list.product", "        if (n <= 0) return 0\n\
    \        var i = 1l\n        var factorial = 1l\n        var factorials = List[Long]()\n\
    \        while (i <= n) {\n            factorial *= i\n            factorials\
    \ = factorials :+ factorial\n            i += 1\n        }\n        factorials.product",
  '        return n.toLong * ((n - 1).toLong) * ((n - 2).toLong)', "        var f\
    \ = 1l\n        var a = 1l\n        for (i <- 2 to n.toInt) {\n            f *=\
    \ i\n            a *= f\n        }\n        a", "        def helper(n : Long,\
    \ p : Long) : Long = {\n            if (n == 1) 1 else (n * p) * helper(n - 1,\
    \ p)\n        }\n        helper(n, p = 1)", '        (BigInt(1) to BigInt(n)).product.toLong',
  "    \tvar result = n;\n    \tfor (i <- (1 to n - 1).reverse) result *= i;\n   \
    \ \tresult", "        def f(n : Long, acc : Long) : Long = {\n            if (n\
    \ == 0) return acc\n            return f(n - 1, n * acc)\n        }\n        return\
    \ f(n, 1)", "        def nFactorial(i : Long) : Long = if (i == 0) 1 else i *\
    \ nFactorial(i - 1)\n        def helper(i : Long) : Long = if (i == 1) nFactorial(1)\
    \ else nFactorial(i) * helper(i - 1)\n        helper(n)", "        val factorial\
    \ = (1l to n).foldLeft(BigInt(1))(_ * _)\n        factorial.toLong", "      var\
    \ ans = 1L\n      for (i <- (1 to n.toInt).reverse) {\n        ans *= i\n    \
    \  }\n      for (i <- 1 to n.toInt) {\n        ans *= i\n      }\n      ans",
  "        def helper(acc : Long, n : Long) : Long = {\n            if (n == 0) return\
    \ acc\n            helper(acc * n, n - 1)\n        }\n        if (n == 0) 1 else\
    \ helper(1, n)", '        (1L to n).foldLeft(1L)((r, i) => r * i) * (1L to n -
    1).foldLeft(1L)((r, i) => r * i)', "        if (n == 0)\n            return 1\n\
    \        n * specialFactorial(n - 1)", "        var r = 1L\n        var f = n\n\
    \        while (f > 0) {\n            r *= f\n            f -= 1\n        }\n\
    \        var k = n - 1\n        while (k > 0) {\n            var rk = 1L\n   \
    \         var fk = k\n            while (fk > 0) {\n                rk *= fk\n\
    \                fk -= 1\n            }\n            r *= rk\n            k -=\
    \ 1\n        }\n        r", "        var p = 2L;\n        var r = n;\n       \
    \ var ret : Long = 1L;\n        while (p <= n) {\n            r = n;\n       \
    \     var k = 0;\n            while (r % p == 0) {\n                r /= p;\n\
    \                k += 1;\n            }\n            ret *= (p.toLong - 1L) *\
    \ pow(p.toLong, k - 1L).toLong;\n            p += 1;\n        }\n        return\
    \ ret;", '        (1L to n).foldLeft(1L)((acc, i) => acc * i) * (1L to n - 1).foldLeft(1L)((acc,
    i) => acc * i)', "        var result = 1l\n        for (i <- n to 1 by -1) {\n\
    \            result *= i\n        }\n        result", "        var result = n;\n\
    \        for (i <- n - 1 to 1 by -1) {\n            result *= i;\n        }\n\
    \        return result;", "        if (n <= 0) 1\n        else {\n           \
    \ var f = specialFactorial(n - 1)\n            f * (n - 1)\n        }", "    \
    \    def f(acc : Long, i : Long) : Long = if (i == 0) acc else f(acc * i, i -\
    \ 1)\n        f(f(f(1, n), n - 1), n - 2)", '        (1L to n).map(BigInt(_)).foldLeft(BigInt(1))(_
    * _).toLong', "        // create the regular factorial\n        def factorial(n\
    \ : Long) : Long = {\n            def factorHelper(n : Long, accumulator : Long)\
    \ : Long = {\n                if (n <= 1) accumulator\n                else factorHelper(n\
    \ - 1, n * accumulator)\n            }\n            factorHelper(n, 1)\n     \
    \   }\n        if (n <= 1) 1\n        else n * specialFactorial(n - 1)", "   \
    \     if (n <= 0) return 0\n        var product = 1l\n        for (i <- n to 1\
    \ by -1) product *= i\n        return product", "        val (result, _) = Stream.iterate((1l,\
    \ n))(p => (p._1 * p._2, p._2 - 1)).dropWhile(_._2 != 0).head\n        result",
  "      var result = 1l\n      for (i <- n to 1 by -1) {\n        result *= i\n \
    \     }\n      for (i <- (n - 1) to 1 by -1) {\n        result *= i\n      }\n\
    \      for (i <- (n - 2) to 1 by -1) {\n        result *= i\n      }\n      result",
  "        if (n <= 0) return 0\n        else {\n            val l = 1 to n\n    \
    \        var r = 1l\n            l.foreach(r *= _)\n            l.drop(1).foreach(r\
    \ *= _)\n            r\n        }", "        var result : Long = 1\n        for\
    \ (i <- 2l to n) result *= i * specialFactorial(i - 1)\n        result", "   \
    \ \tdef factorial(n : Long) : Long = {\n    \t\tif (n == 0) 1 else n * factorial(n\
    \ - 1)\n    \t}\n    \tfactorial(n) * factorial(n - 1)", '        (1l to n).foldLeft(BigInt(1))(BigInt(_)
    * _).bigInteger.multiply((1l to n - 1).foldLeft(BigInt(1))(BigInt(_) * _).bigInteger).longValue',
  "        var f : Long = 1\n        for (i <- n to 1 by -1) f *= i\n        return\
    \ f", "        var ret = 1L\n        for (i <- 2L to n) {\n            ret *=\
    \ i\n            ret *= specialFactorial(i - 1)\n        }\n        ret", "  \
    \      var memo = new HashMap[Long, Long]\n        def brazilian_factorial(n :\
    \ Long) : Long = {\n            if (n == 0) 1 else {\n                if (memo.contains(n))\
    \ memo(n) else {\n                    val res = n * brazilian_factorial(n - 1)\n\
    \                    memo(n) = res\n                    res\n                }\n\
    \            }\n        }\n        brazilian_factorial(n)", "        var res =\
    \ n\n        for (i <- 2l to n - 1) res *= i\n        res", '        (1l to n).map(i
    => factorial(i)).reduceLeft(_ * _)', "        var m = n;\n        var arr = new\
    \ Array[Long](n.toInt + 1);\n        arr(0) = 1;\n        for (i <- 1 to n.toInt)\
    \ {\n            arr(i) = arr(i - 1) * i;\n        }\n        arr.reverse.reduceLeft(_\
    \ * _);", "        if (n == 0 || n == 1) 1\n        else n * specialFactorial(n\
    \ - 1)", "        if (n <= 0) throw new Exception(\"Illegal input\")\n       \
    \ val result = new Array[Long](n.toInt)\n        result(0) = 1\n        for (i\
    \ <- 1 to n.toInt - 1) result(i) = i * result(i - 1)\n        result.reduceLeft(_\
    \ * _)", '        (1 to n.toInt).map(x => BigInt(x).factorial).reduceLeft(_ *
    _).toLong', "        var f : Long = 1\n        for (i <- n to 1 by -1) {\n   \
    \         f *= i\n        }\n        var s : Long = 1\n        for (i <- f to\
    \ 1 by -1) {\n            s *= i\n        }\n        return s", "        def factorial(n\
    \ : Long) : Long = {\n            if (n == 0) 1\n            else n * factorial(n\
    \ - 1)\n        }\n        var result = 1L\n        var i = n\n        while (i\
    \ > 0) {\n            result *= factorial(i)\n            i -= 1\n        }\n\
    \        result", "        var result = BigInt(1)\n        for (i <- 2 to n.toInt)\
    \ {\n            result *= BigInt(i)\n            result *= factorial(i)\n   \
    \     }\n        result.toLong", '        if (n == 0) 1 else n * specialFactorial(n
    - 1)', "        val facs = new HashMap[Long, Long]\n        def fac(n : Long)\
    \ : Long = {\n            if (n == 0) {\n                1\n            } else\
    \ {\n                facs.getOrElseUpdate(n, n * fac(n - 1))\n            }\n\
    \        }\n        var result = 1l\n        for (i <- (1 to n.toInt).reverse)\
    \ {\n            result *= fac(i)\n        }\n        result", "        if (n\
    \ == 0) return 1\n        var product = 1l\n        for (i <- n to 1 by -1) product\
    \ *= i\n        for (i <- n - 1 to 1 by -1) product *= i\n        return product",
  "        if (n <= 0) 1 else\n        (2 to n.toInt).map(x => factorial(x)).reduceLeft(_\
    \ * _)", "        if (n <= 0) 1\n        else (1 to n.toInt).map(i => factorial(i)).product",
  "        if (n == 0) return 1\n        var factorial = n\n        var result = n\n\
    \        for (i <- 1 to n.toInt - 1) {\n            result *= factorial\n    \
    \        factorial -= 1\n        }\n        return result", "        if (n <=\
    \ 0) throw new IllegalArgumentException\n        var answer : Long = 1\n     \
    \   for (i <- n to 1 by -1) {\n            answer *= i\n        }\n        answer",
  "        def loop(m : Long, fact : Long) : Long = {\n            if (m == 0) fact\n\
    \            else loop(m - 1, fact * m)\n        }\n        loop(n, 1)", "   \
    \     var factorialProduct = 1l\n        var sum = 0l\n        for (i <- 1 to\
    \ n.toInt) {\n            sum += i\n            factorialProduct *= sum\n    \
    \    }\n        factorialProduct", "        var prod = 1l\n        for (i <- (1\
    \ to n.toInt).reverse) prod *= i\n        prod", "    \tif (n == 0) 1\n    \t\
    else n * specialFactorial(n - 1)", "        def f(n : Long, acc : Long) : Long\
    \ = {\n            if (n == 0) acc\n            else f(n - 1, n * acc)\n     \
    \   }\n        f(n, 1)", "        var output = 1l\n        for (i <- n to 1 by\
    \ -1) output *= factorial(i)\n        output", "        /**\n         * The input\
    \ must be positive\n         */\n        if (n <= 0) throw new IllegalArgumentException(\"\
    n must be positive\")\n        // Your code here\n        var brazilianFactorial\
    \ = 1L\n        for (i <- 1 to n.toInt) {\n            brazilianFactorial *= i\
    \ * (i - 1)\n        }\n        brazilianFactorial", "      var result = n\n \
    \     for (i <- (1l to n - 1l)) {\n        result *= i\n      }\n      result",
  '        if (n == 0 || n == 1) 1 else n * specialFactorial(n - 1)', "        if\
    \ (n == 0) return 1\n        var result = n\n        for (i <- n-1 to 1 by -1)\
    \ result *= i\n        result", "        if (n == 0) return 1\n        var result\
    \ = 1l\n        for (i <- 1 to n.toInt) {\n            result *= factorial(i)\n\
    \        }\n        return result", "      // The answer is given by the formula:\n\
    \      // (1/n) * sum (from i = 1 to n) i^(n-1)\n      // The numerator is 1,\
    \ so we only need to compute the sum.\n      var x = 0l\n      for (i <- 1 to\
    \ n.toInt) x += pow(i, n - 1).toLong\n      x", "        def loop(acc : Long,\
    \ i : Long) : Long = {\n            if (i == 0) acc\n            else loop(acc\
    \ * i, i - 1)\n        }\n        loop(n, n - 1)", "        def factorial(n :\
    \ Long) : Long = (1 to n.toInt).product\n        val fac = factorial(n)\n    \
    \    def a(t : List[Long], acc : Long) : Long = t match {\n            case Nil\
    \ => acc\n            case x :: xs => a(xs, acc * factorial(x))\n        }\n \
    \       a((1 to n.toInt).toList, 1)", "        var cache = Map[Long, Long]()\n\
    \        def factorial(n : Long) : Long = {\n            if (n == 0) return 1\n\
    \            else if (cache.contains(n)) cache(n)\n            else {\n      \
    \          val result = n * factorial(n - 1)\n                cache += (n -> result)\n\
    \                result\n            }\n        }\n        (1 to n.toInt).foldLeft(1l)((acc,\
    \ n) => acc * factorial(n))", "      def factorial(n : Long) : Long = {\n    \
    \    if (n == 0) 1\n        else n * factorial(n - 1)\n      }\n      def specialFactorialHelper(n\
    \ : Long, result : Long) : Long = {\n        if (n == 0) result\n        else\
    \ specialFactorialHelper(n - 1, result * factorial(n))\n      }\n      specialFactorialHelper(n,\
    \ 1)", "        var cache = Map[Long, Long]()\n        def f(n : Long) : Long\
    \ = {\n            if (n == 0) return 1\n            if (cache.contains(n)) return\
    \ cache(n)\n            val res = n * f(n - 1)\n            cache(n) = res\n \
    \           return res\n        }\n        f(n) / f(n - 2)", "        if (n ==\
    \ 0) return 1\n        var result = n\n        for (i <- 2 to n.toInt) result\
    \ *= i\n        for (i <- n - 1 to 1 by -1) result *= i\n        result", "  \
    \      if (n == 0) return 1\n        var result = factorial(n)\n        for (i\
    \ <- 1 to n - 1) {\n            result *= factorial(i)\n        }\n        return\
    \ result", "        if (n == 0) 1\n        else n * specialFactorial(n - 1)",
  "        def factorial(n : Long) : Long = {\n            if (n == 0) 1 else n *\
    \ factorial(n - 1)\n        }\n        // 1! = 1\n        // 2! = 2 * 1! = 2\n\
    \        // 3! = 3 * 2! = 6\n        // 4! = 4 * 3! = 24\n        // 5! = 5 *\
    \ 4! = 120\n        // 6! = 6 * 5! = 720\n        def specialFactorial(n : Long)\
    \ : Long = {\n            if (n == 1) 1 else n * specialFactorial(n - 1)\n   \
    \     }\n        specialFactorial(n)", "        def r(m : Long, result : Long)\
    \ : Long = {\n            if (m == 0) result\n            else r(m - 1, result\
    \ * m)\n        }\n        r(n, 1)", "        var a : Long = 1\n        for (i\
    \ <- 1 to n.toInt) {\n            var b : Long = 1\n            for (j <- 1 to\
    \ i) {\n                b *= j\n            }\n            a *= b\n        }\n\
    \        return a", "        def specialFactorial(n : Long, m : Long) : Long =\
    \ {\n            if (n <= 1) m\n            else specialFactorial(n - 1, m * n)\n\
    \        }\n        specialFactorial(n, 1)", "        var prod = 1l\n        for\
    \ (i <- 1 to n.toInt) prod *= i\n        (1 to n.toInt).map(x => (1 to x).product).product",
  "      require(n > 0)\n      val factorials = MutableList.fill(n.toInt)(1l)\n  \
    \    for (i <- 1 to n.toInt - 1) {\n        factorials(i) = factorials(i - 1)\
    \ * i\n      }\n      val factorial = factorials.foldRight(1l)(_ * _)\n      factorial\
    \ * factorials(n.toInt - 1)", "        var factorial = 1l\n        for (i <- n\
    \ to 1 by -1) factorial *= i\n        for (i <- n - 1 to 1 by -1) factorial *=\
    \ i\n        factorial", "        def specialFactorialHelper(n : Long, acc : Long)\
    \ : Long = n match {\n            case 0 => acc\n            case n => specialFactorialHelper(n\
    \ - 1, acc * factorial(n))\n        }\n        specialFactorialHelper(n, 1)",
  '        ((1L to n).map(x => factorial(x)).product).toLong', "        if (n <= 0)\
    \ throw new IllegalArgumentException\n        factorial(n).toLong", "        def\
    \ factorial(n : Long) : Long = {\n            if (n == 0) return 1\n         \
    \   return n * factorial(n - 1)\n        }\n        def loop(n : Long, acc : Long)\
    \ : Long = {\n            if (n == 0) return acc\n            return loop(n -\
    \ 1, acc * factorial(n))\n        }\n        return loop(n, 1)", "        if (n\
    \ == 0) return 1\n        var m = n\n        var result = n\n        while (m\
    \ > 1) {\n            result *= m - 1\n            m -= 1\n        }\n       \
    \ return result", "        val factorial = (1l to n).product\n        (1l to n).foldLeft(factorial)((s,\
    \ i) => s / i)", "        def factorial(n : Long) : Long = {\n            def\
    \ fact(n : Long, acc : Long) : Long = {\n                if (n == 0) acc\n   \
    \             else fact(n - 1, n * acc)\n            }\n            fact(n, 1)\n\
    \        }\n        factorial(n) / factorial(n - 1)", "        var total : Long\
    \ = 1\n        for (i <- n until 1 by -1) {\n            total *= i\n        }\n\
    \        return total", "        var result : Long = 1\n        for (i <- n to\
    \ 1 by -1) result *= i\n        for (i <- n to 1 by -1) {\n            var divisor\
    \ : Long = 1\n            for (j <- i to 1 by -1) divisor *= j\n            result\
    \ /= divisor\n        }\n        result", "      def f(n : Long, accum : Long)\
    \ : Long = {\n        if (n == 0) accum\n        else f(n - 1, n * accum)\n  \
    \    }\n      f(n, 1)", "        if (n == 0) 1\n        else n * specialFactorial(n\
    \ - 1)", "        var current = n\n        var acc = 1l\n        while (current\
    \ > 0) {\n            acc *= current\n            current -= 1\n        }\n  \
    \      return acc", "        val p = new Prime\n        val arr = new Array[Long](n.toInt\
    \ + 1)\n        for (i <- 0 to n.toInt) arr(i) = p.factorial(i)\n        var res\
    \ = 1l\n        for (i <- 0 to n.toInt) res *= arr(i)\n        res", "       \
    \ if (n == 0) {\n            1\n        } else {\n            (1 to n.toInt).map(_.toLong).foldLeft(1l)(_\
    \ * _)\n        }", "        def factorial(n : Long) : Long = if (n <= 1) 1 else\
    \ n * factorial(n - 1)\n        var result = 1l\n        var i = n\n        while\
    \ (i > 0) {\n            result *= factorial(i)\n            i -= 1\n        }\n\
    \        result", "        n match {\n            case n if n == 0 => 1\n    \
    \        case n if n == 1 => 1\n            case n if n == 2 => 2\n          \
    \  case n if n == 3 => 6\n            case n if n == 4 => 24\n            case\
    \ n if n == 5 => 120\n            case n if n == 6 => 720\n            case n\
    \ if n == 7 => 5040\n            case n if n == 8 => 40320\n            case n\
    \ if n == 9 => 362880\n            case n if n == 10 => 3628800\n            case\
    \ n if n == 11 => 39916800\n            case n if n == 12 => 479001600\n     \
    \       case n if n == 13 => 6227020800l\n            case n if n == 14 => 87178291200l\n\
    \            case n if n == 15 => 1307674368000l\n            case n if n == 16\
    \ => 20922789888000l\n            case n if n == 17 => 355687428096000l\n    \
    \        case n if n == 18 => 6402373705728000l\n            case n if n == 19\
    \ => 121645100408832000l\n            case n if n == 20 => 2432902008176640000l\n\
    \            case n if n == 21 => 51090942171709440000l\n            case n if\
    \ n == 22 => 1124000727777607680000l\n            case n if n == 23 => 25852016738884976640000l\n\
    \            case n if n == 24 => 620448401733239439360000l\n            case\
    \ n if n == 25 => 15511210043330985984000000l\n            case n if n == 26 =>\
    \ 403291461126605635584000000l\n            case n if n == 27 => 10888869450418352160768000000l\n\
    \            case n if n == 28 => 304888344611713860501504000000l\n          \
    \  case n if n == 29 => 8841761993739701954543616000000l\n            case n if\
    \ n == 30 => 265252859812191058636308480000000l\n            case n if n == 31\
    \ => 8222838654177922817725562880000000l\n            case n if n == 32 => 2631308369336935",
  "        var arr = List[Long]()\n        for (i <- n to 1 by -1) arr :+= i\n   \
    \     arr.product", "        def factorial(n : Long) : Long = {\n            if\
    \ (n <= 1) 1 else n * factorial(n - 1)\n        }\n        def helper(n : Long,\
    \ i : Long) : Long = {\n            if (i == 0) 1 else factorial(i) * helper(n,\
    \ i - 1)\n        }\n        helper(n, n)", "        var nFactorial : Long = n\n\
    \        for (i <- (2 to n.toInt).reverse) {\n            nFactorial *= i\n  \
    \      }\n        nFactorial", "        val factorial = Array.ofDim[Long](n.toInt\
    \ + 1)\n        factorial(0) = 1\n        for (i <- 1 to n.toInt) factorial(i)\
    \ = factorial(i - 1) * i\n        factorial.reverse.foldLeft(1l)((x, y) => x *\
    \ y)", "        if (n <= 0) return 0\n        var r = n\n        for (i <- 1 until\
    \ n) {\n            r *= i\n        }\n        return r", "    \tvar f = ListBuffer[Long]()\n\
    \    \tfor (i <- 1 to n.toInt) f += i\n    \tf.reduceLeft(_ * _)", "        var\
    \ result = 1l\n        for (i <- n to 1 by -1) result *= i\n        for (i <-\
    \ n - 1 to 1 by -1) result *= i\n        result", "      var r = 1L\n      for\
    \ (i <- (1 to n.toInt).reverse) {\n        r *= factorial(i)\n      }\n      r",
  "\tval sf = new SpecialFactorial(n)\n\tsf.result", "        // Implement this function\n\
    \        def factorial(n : Long) : Long = {\n            if (n == 0) 1 else n\
    \ * factorial(n - 1)\n        }\n        (1 to n.toInt).map(factorial(_)).product",
  "        if (n == 0) 1\n        else (1l to n).product * specialFactorial(n - 1)",
  "        def combiner(n: Long, list: List[Long]): List[Long] = {\n            def\
    \ helper(cnt: Long, l: List[Long]): List[Long] = l match {\n                case\
    \ Nil => l\n                case h :: t => if (cnt > 1) h :: helper(cnt - 1, t)\
    \ else helper(1, t)\n            }\n            helper(n, list)\n        }\n \
    \       def recur(n: Long, m: Long, acc: Long): Long = {\n            if (n <\
    \ 1) acc\n            else {\n                val d = n / m\n                val\
    \ r = n % m\n                val list = combiner(d, (m to 1 by -1).toList)\n \
    \               val product = list.product\n                recur(r, m, acc *\
    \ product)\n            }\n        }\n        recur(n, n, 1)", "        var result\
    \ = n\n        for (i <- 2 to n.toInt) {\n            result *= i\n        }\n\
    \        for (i <- n.toInt to 2 by -1) {\n            result *= i\n        }\n\
    \        result", "        def prod(l : Long) : Long = l match {\n           \
    \ case 1 => 1\n            case _ => l * prod(l - 1)\n        }\n        n match\
    \ {\n            case n if n <= 0 => 1\n            case n => n * specialFactorial(n\
    \ - 1)\n        }", "        def factorial(x : Long) : Long = {\n            if\
    \ (x == 0) 1\n            else x * factorial(x - 1)\n        }\n        if (n\
    \ <= 0) throw new IllegalArgumentException(\"n must be positive\")\n        else\
    \ if (n == 1) 1\n        else n * specialFactorial(n - 1) / factorial(n - 1)",
  "        if (n <= 0) 1\n        else (1 to n.toInt).map(x => factorial(x)).product",
  "        var m = n\n        var product = 1l\n        while (m >= 1) {\n       \
    \     var i = m\n            var partial = 1l\n            while (i >= 1) {\n\
    \                partial *= i\n                i -= 1\n            }\n       \
    \     product *= partial\n            m -= 1\n        }\n        product", " \
    \       if (n == 0) 1\n        else factorial(n) * specialFactorial(n - 1)", " \
    \       if (n == 0) return 1\n        factorial(n) * specialFactorial(n - 1)",
  '        (1l to n).foldLeft(1l)((prod, e) => prod * (1l to e).product)', "     \
    \   val products = for (i <- 1 to n.toInt) yield factorial(i)\n        products.foldLeft(1l)(_\
    \ * _)", "        val f = Array.fill(n.toInt)(1l)\n        for (i <- 1 until n.toInt)\
    \ f(i) = f(i - 1) * i\n        f.reduceLeft(_ * _)", '        n * specialFactorial(n
    - 1)', "        var result = n\n        for (i <- (n - 1) to 1 by -1) {\n    \
    \        result *= i\n        }\n        result", '        (1l /: (1 to n.toInt))
    (_ * _)', "        var result : Long = 1\n        for (i <- 1l to n) {\n     \
    \       result *= i\n            for (j <- 1l to i - 1) {\n                result\
    \ *= j\n            }\n        }\n        return result", "        var result\
    \ = 1l\n        for (i <- 1 to n.toInt) {\n            result *= factorial(i)\n\
    \        }\n        result", "        // Write your code here\n        return\
    \ (1 to n.toInt).map(i => factorial(i)).product", "      if (n == 0) 1\n     \
    \ else n * specialFactorial(n - 1)", "        var stack = Stack[Long]()\n    \
    \    for (i <- n to 1 by -1) {\n            stack.push(i)\n        }\n       \
    \ var f = 1l\n        while (!stack.isEmpty) {\n            f *= stack.pop\n \
    \       }\n        return f", "        if (n == 0) 1\n        else (1 to n.toInt).foldLeft(1l)((r,\
    \ c) => r * c) * specialFactorial(n - 1)", "        var r = 1l\n        for (i\
    \ <- 2 to n.toInt) {\n            r *= factorial(i)\n        }\n        r", " \
    \       val facs = ArrayBuffer[Long]()\n        var i = 1\n        while (i <=\
    \ n) {\n            facs += i\n            i += 1\n        }\n        facs.foldLeft(1l)(_\
    \ * _)", "        if (n == 0) return 1l\n        var factorial = BigInt(1)\n \
    \       var i = n\n        while (i > 0) {\n            factorial *= BigInt(i)\n\
    \            i -= 1\n        }\n        factorial.toLong", "        var result\
    \ = 1l\n        for (i <- 1 to n.toInt) {\n            result *= factorial(i)\n\
    \        }\n        result", "        def factors(n : Long) : List[Long] = n match\
    \ {\n            case n if n < 2 => Nil\n            case n => n :: factors(n\
    \ - 1)\n        }\n        factors(n).product", "        var x = 1l\n        for\
    \ (i <- 1 to n.toInt) x *= i\n        for (i <- 1 to n.toInt - 1) x *= i\n   \
    \     return x", "        var r = 1l\n        var i = n\n        while (i > 0)\
    \ {\n            r *= i\n            i -= 1\n        }\n        var j = n - 1\n\
    \        while (j > 0) {\n            r *= j\n            j -= 1\n        }\n\
    \        return r", "        var res = 1l\n        for (i <- 1l to n) res *= i\
    \ * factorial(i - 1)\n        res", "        var f = 1l\n        for (i <- 1 to\
    \ n.toInt) f *= i\n        for (i <- 1 to n.toInt - 1) f *= i\n        f", " \
    \   \tif (n == 0) return 1\n    \tvar result = n\n    \tfor (i <- n - 1 to 1 by\
    \ -1) {\n    \t\tresult *= i\n    \t}\n    \treturn result", '        if (n <=
    0) 1 else n * specialFactorial(n - 1)', "        var current = n\n        var\
    \ result = 1l\n        while (current > 0) {\n            result *= current\n\
    \            current -= 1\n        }\n        result", '        return specialFactorialHelper(n,
    1l)', "        if (n == 0) 1\n        else (1l to n).reduceLeft(_ * _) * specialFactorial(n\
    \ - 1)", "      var result : Long = 1\n      if (n == 0) {\n        return 1\n\
    \      }\n      var factorial : Long = 1\n      var i : Long = 1\n      while\
    \ (i <= n) {\n        factorial *= i\n        result *= factorial\n        i +=\
    \ 1\n      }\n      return result", "        var p = BigInt(1)\n        var m\
    \ = BigInt(1)\n        for (i <- 1 to n.toInt) {\n            p *= i\n       \
    \     m *= p\n        }\n        m.toLong", "        // Write your solution here.\n\
    \        return 0;", "        var answer : Long = 1\n        for (i <- n to 1\
    \ by -1) {\n            answer *= i\n        }\n        for (i <- n - 1 to 1 by\
    \ -1) {\n            answer *= i\n        }\n        return answer", "       \
    \ def helper(num : Long, acc : Long) : Long = {\n            if (num == 0) acc\n\
    \            else helper(num - 1, acc * num)\n        }\n        if (n <= 0) throw\
    \ new IllegalArgumentException\n        else {\n            var acc = helper(n,\
    \ 1)\n            var i = n - 1\n            while (i > 0) {\n               \
    \ acc *= helper(i, 1)\n                i -= 1\n            }\n            acc\n\
    \        }", "        require(n > 0, \"\")\n        (2 to n.toInt).foldLeft(n)((acc,\
    \ x) => acc * x)", "    \tvar result = 1l\n    \tfor (i <- n to 1 by -1) {\n \
    \   \t\tvar m = factorial(i)\n    \t\tvar k = factorial(i - 1)\n    \t\tvar l\
    \ = (m / k)\n    \t\tresult *= l\n    \t}\n    \treturn result", "        val\
    \ f = new Array[Long](n.toInt + 1)\n        f(0) = 1\n        for (i <- 1 to n.toInt)\
    \ f(i) = i * f(i - 1)\n        f.foldLeft(1l)(_ * _)", "        def factorial(x\
    \ : Long) : Long = if (x == 0) 1 else x * factorial(x - 1)\n        def brazilianFactorial(x\
    \ : Long) : Long = if (x == 0) 1 else brazilianFactorial(x - 1) * factorial(x)\n\
    \        brazilianFactorial(n)", "        // Your code here:\n        if (n <=\
    \ 0) return 1\n        var result = 1\n        for (i <- 1 to n.toInt) {\n   \
    \         var factorial = 1\n            for (j <- 1 to i) {\n               \
    \ factorial *= j\n            }\n            result *= factorial\n        }\n\
    \        result", "        if (n == 0) return 1\n        var result = 1l\n   \
    \     for (i <- 2 to n.toInt) {\n            result *= factorial(i)\n        }\n\
    \        result", "        var answer : Long = 1\n        for (i <- 1 to n.toInt)\
    \ answer *= i\n        for (i <- 1 to n.toInt - 1) answer *= i\n        for (i\
    \ <- 1 to n.toInt - 2) answer *= i\n        return answer", "        if (n ==\
    \ 0) return 1\n        specialFactorial(n - 1) * n", "        val facs = ArrayBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) facs += factorial(i)\n        facs.foldLeft(1l)(_\
    \ * _)", '        (1L to n).foldLeft(1L)((a, b) => a * b) * (1L to n - 1).foldLeft(1L)((a,
    b) => a * b)', '      return (1 to n.toInt).map(BigInt(_)).foldLeft(BigInt(1))(_
    * _).toLong;', "        var ret = 1l\n        var i = 1\n        while (i <= n)\
    \ {\n            ret *= factorial(i)\n            i += 1\n        }\n        ret",
  "        var f = 1l\n        for (i <- n to 1 by -1) f *= i\n        var r = f\n\
    \        for (i <- (n - 1) to 1 by -1) r *= f\n        return r", "        //\
    \ (n! * (n-1)! * (n-2)! * ... * 1!) / (n! * (n-1)! * (n-2)! * ... * 1!) = 1\n\
    \        // n! / (n-1)!\n        // (n * (n-1) * (n-2) * ... * 1) / (n-1)!\n \
    \       // n * (n-1) * (n-2) * ... * 1\n        val r = for (i <- n to 1 by -1)\
    \ yield i\n        val result = r.reduceLeft(_ * _)\n        result", "      \
    \  if (n == 0)\n            1\n        else\n            n * specialFactorial(n\
    \ - 1)", '        (1l to n).map(i => i.toLong).product', '        // Your code
    here', "        var p = 1l\n        for (i <- 1 to n.toInt) p *= i\n        for\
    \ (i <- n.toInt to 1 by -1) p *= i\n        p", "        var dp = Array.fill(n.toInt\
    \ + 1)(0l)\n        dp(0) = 1\n        dp(1) = 1\n        for (i <- 2 to n.toInt)\
    \ {\n            dp(i) = dp(i - 1) * i\n        }\n        dp(n.toInt)", "   \
    \     def gcd(a : Long, b : Long) : Long = {\n            if (b == 0) a else gcd(b,\
    \ a % b)\n        }\n        def reduce(p : (Long, Long)) : (Long, Long) = {\n\
    \            val g = gcd(p._1, p._2)\n            (p._1 / g, p._2 / g)\n     \
    \   }\n        def solve(n : Long) : (Long, Long) = {\n            if (n == 1)\
    \ (1, 1) else reduce((n * solve(n - 1)._1, n - 1))\n        }\n        solve(n)._1",
  "        var mul = n\n        var res = n\n        while (mul > 1) {\n         \
    \   mul -= 1\n            res *= mul\n        }\n        (1l to n).map(x => x).product",
  "        var f = new Array[Long](n.toInt + 1)\n        f(0) = 1\n        for (i\
    \ <- 1 to n.toInt) f(i) = f(i - 1) * i\n        var ans = f(n.toInt)\n       \
    \ for (i <- n.toInt - 1 to 1 by -1) ans *= f(i)\n        ans", '        return
    (1 to n.toInt).map(x => factorial(x)).product', "        var results = ArrayBuffer(1l)\n\
    \        for (i <- 1 to n.toInt) {\n            results += (i * results(i - 1))\n\
    \        }\n        results.reduce(_ * _)", "        if (n <= 0) 1\n        else\
    \ (1 to n.toInt).toList.map(BigInt(_)).reduce(_ * _).toLong", "        // Factorials\n\
    \        def factorials(k : Long) : List[Long] = {\n            if (k == 0) List()\n\
    \            else k * factorials(k - 1).head :: factorials(k - 1)\n        }\n\
    \        // Recursion\n        def aux(n : Long, fs : List[Long]) : Long = {\n\
    \            if (n == 0) 1\n            else fs.head * aux(n - 1, fs.tail)\n \
    \       }\n        aux(n, factorials(n))", "        def specialFactorial(n : Long,\
    \ acc : Long) : Long = {\n            if (n == 1) 1 * acc\n            else specialFactorial(n\
    \ - 1, n * acc)\n        }\n        specialFactorial(n, 1)", "        def f(n\
    \ : Long, acc : Long) : Long = {\n            if (n == 0) acc\n            else\
    \ f(n - 1, acc * factorial(n))\n        }\n        f(n, 1)", "        def factorial(n\
    \ : Long) : Long = if (n == 0) 1 else n * factorial(n - 1)\n        def solve(n\
    \ : Long) : Long = if (n == 0) 1 else factorial(n) * solve(n - 1)\n        solve(n)",
  "        if (n == 0) 0\n        else {\n            n * specialFactorial(n - 1)\n\
    \        }", "      var a : Long = 1\n      for (i <- 1 to n.toInt) a *= i\n \
    \     a * specialFactorial(n - 1)", "        var product = 1l\n        for (i\
    \ <- 2 to n.toInt) {\n            product *= specialFactorial(i - 1) * i\n   \
    \     }\n        product", "        if (n <= 0) return 0\n        def b(x : Long)\
    \ : Long = {\n            if (x == 1) 1\n            else x * b(x - 1)\n     \
    \   }\n        b(n) * b(n - 1)", '        return n.toLong;', "        val array\
    \ = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) {\n         \
    \   array(i) = (i + 1).toLong\n        }\n        array.foldLeft(1l)((x, y) =>\
    \ x * y)", "        var total : Long = 1\n        for (i <- n to 1 by -1) {\n\
    \            total *= i\n        }\n        for (i <- (n - 1) to 1 by -1) {\n\
    \            total *= i\n        }\n        return total", "        var f = new\
    \ Array[Long](n.toInt + 1)\n        f(0) = 1\n        for (i <- 1 to n.toInt)\
    \ f(i) = f(i - 1) * i\n        f.filter(_ > 0).reduceLeft(_ * _)", "        var\
    \ result : Long = 1\n        var i : Long = n\n        while (i >= 1) {\n    \
    \        result *= i\n            i -= 1\n        }\n        result", "\t\tvar\
    \ map = Map[Long, Long]()\n\t\tmap(0) = 1\n\t\tmap(1) = 1\n\t\tdef f(n : Long)\
    \ : Long = {\n\t\t\tif (map.contains(n)) map(n)\n\t\t\telse {\n\t\t\t\tmap(n)\
    \ = n * f(n - 1)\n\t\t\t\tmap(n)\n\t\t\t}\n\t\t}\n\t\tvar result = 1l\n\t\tfor\
    \ (i <- (1 to n.toInt).reverse) result *= f(i)\n\t\tresult", "        def factorial(n\
    \ : Long) : Long = {\n            if (n <= 1) 1 else n * factorial(n - 1)\n  \
    \      }\n        def specialFactorialHelper(n : Long, s : Long) : Long = {\n\
    \            if (n <= 1) s else specialFactorialHelper(n - 1, s * factorial(n))\n\
    \        }\n        specialFactorialHelper(n, 1)", "        // the scala way\n\
    \        def factorial(i : Long) : Long = if (i == 0) 1 else i * factorial(i -\
    \ 1)\n        (2 to n.toInt).map(i => factorial(i)).foldLeft(factorial(n))((product,\
    \ fact) => product * fact)", "        var result : Long = 1\n        for (i <-\
    \ 2 to n.toInt) result *= factorial(i)\n        result", "        var fact = 1l\n\
    \        for (i <- 1 to n.toInt) {\n            fact *= i\n        }\n       \
    \ var res = fact\n        for (i <- 1 to n.toInt) {\n            res *= fact\n\
    \            fact /= i\n        }\n        res", '        ((1l to n).map(BigInt(_)).reduce(_
    * _) * (1l to n - 1).map(BigInt(_)).reduce(_ * _)).toLong', "        //(n to 2\
    \ by -1).toList.map(x => (x to 1 by -1).toList.product).product\n        (n to\
    \ 2 by -1).map(x => (x to 1 by -1).product).product", "        def factorial(n\
    \ : Long) : Long = {\n            if (n == 0) 1\n            else factorial(n\
    \ - 1) * n\n        }\n        if (n == 0) 1\n        else factorial(n) * specialFactorial(n\
    \ - 1)", "    \tval facs = for (i <- 1 to n.toInt) yield factorial(i)\n    \t\
    facs.product", "        var factorials = Array.ofDim[Long](n.toInt)\n        factorials(0)\
    \ = 1\n        factorials(1) = 1\n        for (i <- 2 to n.toInt - 1) {\n    \
    \        factorials(i) = factorials(i - 1) * i\n        }\n        factorials.foldLeft(1l)(_\
    \ * _)", "        val factorials = HashMap[Long, Long]()\n        def factorial(n\
    \ : Long) : Long = {\n            if (n == 0) return 1\n            if (factorials.contains(n))\
    \ return factorials(n)\n            val result = n * factorial(n - 1)\n      \
    \      factorials(n) = result\n            return result\n        }\n        if\
    \ (n == 0) return 1\n        var result = factorial(n)\n        for (i <- 1 to\
    \ n.toInt) result *= factorial(i)\n        return result", '        (1l to n).map(x
    => factorial(x)).product', "        val factorial = new Array[Long](n.toInt +\
    \ 1)\n        factorial(0) = 1\n        factorial(1) = 1\n        for (i <- 2\
    \ to n.toInt) {\n            factorial(i) = factorial(i - 1) * i\n        }\n\
    \        (1l to n).map(i => factorial(i.toInt)).reduce(_ * _)", "        def factorial(n\
    \ : Long) : Long = {\n            if (n == 0) 1 else n * factorial(n - 1)\n  \
    \      }\n        var result = 1l\n        for (i <- 1 to n.toInt) result *= factorial(i)\n\
    \        result"]
stop_tokens:
- "\n    }\n"
