name: HumanEval_106_f
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Implement the function f that takes n as a parameter,\n    // and returns\
  \ a list of size n, such that the value of the element at index i is the factorial\
  \ of i if i is even\n    // or the sum of numbers from 1 to i otherwise.\n    //\
  \ i starts from 1.\n    // the factorial of i is the multiplication of the numbers\
  \ from 1 to i (1 * 2 * ... * i).\n    // Example:\n    // >>> f((5l))\n    // (List[Long](1l.toLong,\
  \ 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))\n    def f(n : Long) : List[Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(f((5l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))));\n    assert(f((7l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong, 720l.toLong, 28l.toLong))));\n \
  \   assert(f((1l)).equals((List[Long](1l.toLong))));\n    assert(f((3l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 6l.toLong))));\n    }\n\n}\n"
completions: ["        def g(i : Long) : Long = if (i % 2 == 0) f(i) else 1l.toLong\n\
    \        def f(i : Long) : Long = if (i == 0l) 1l.toLong else i * f(i - 1l)\n\
    \        var L = ListBuffer[Long]()\n        for (i <- 1l to n) L += g(i)\n  \
    \      L.toList", "        var list = ListBuffer[Long]()\n        var i = 1l\n\
    \        while (i <= n) {\n            if (i % 2 == 0) list += factorial(i)\n\
    \            else list += sum(i)\n            i += 1\n        }\n        list.toList",
  "        var list : List[Long] = List()\n        var i = 1l\n        while (i <=\
    \ n) {\n            list = list :+ (if (i % 2 == 0) (1l to i).product else (1l\
    \ to i).sum)\n            i += 1\n        }\n        list", "        //if(n <=\
    \ 0)\n          //  List()\n        //else {\n            //var result = List[Long]()\n\
    \            //for(i <- 1 to n.toInt) {\n              //  if(i % 2 == 0)\n  \
    \              //    result = result :+ factorial(i)\n                //else\n\
    \                  //  result = result :+ sumRange(1, i)\n            //}\n  \
    \          //result\n        //}\n        var result = List[Long]()\n        for(i\
    \ <- 1 to n.toInt) {\n            if(i % 2 == 0)\n                result = result\
    \ :+ factorial(i)\n            else\n                result = result :+ sumRange(1,\
    \ i)\n        }\n        result", "      val result = new ListBuffer[Long]\n \
    \     for (i <- 1l to n) {\n        if (i % 2 == 0) result += factorial(i)\n \
    \       else result += (1l to i).sum\n      }\n      result.toList", "       \
    \ val list = new ArrayBuffer[Long]()\n        for (i <- 1l to n) {\n         \
    \   if (i % 2 == 0) list += factorial(i)\n            else list += sumOfNumbers(i)\n\
    \        }\n        list.toList", "        var a = List[Long]()\n        for (i\
    \ <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n                var x = 1l\n\
    \                for (j <- 1 to i) {\n                    x *= j\n           \
    \     }\n                a = a :+ x\n            } else {\n                var\
    \ x = 0l\n                for (j <- 1 to i) {\n                    x += j\n  \
    \              }\n                a = a :+ x\n            }\n        }\n     \
    \   a", "        // your code\n        return List(1,2,6,24,120)", "        val\
    \ l = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if\
    \ (i % 2 == 0) l += i.toLong * (i - 1).toLong\n            else l += ((1 to i).toList).sum\n\
    \        }\n        l.toList", "        // Write your code here\n        var l\
    \ = new ListBuffer[Long]()\n        for (i <- 1L to n) {\n            if (i %\
    \ 2 == 0) l += (1L to i).foldLeft(1L)(_ * _)\n            else l += (1L to i).foldLeft(0L)(_\
    \ + _)\n        }\n        l.toList", "        var ret = List[Long]()\n      \
    \  for (i <- 1l to n) {\n            if (i % 2 == 0) ret ::= (1l to i).reduce(_\
    \ * _)\n            else ret ::= (1l to i).reduce(_ + _)\n        }\n        ret.reverse",
  "        val ls = new ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n  \
    \          ls += (if (i % 2 == 0) {\n                (1l to i.toLong).foldLeft(1l)(_\
    \ * _)\n            } else {\n                (1l to i.toLong).foldLeft(0l)(_\
    \ + _)\n            })\n        }\n        ls.toList", '        (1 to n.toInt).map(x
    => if (x % 2 == 0) factorial(x) else (1 to x).sum).toList', "        // Fill up\
    \ this function body\n        // You may also need to define some other functions\
    \ or classes\n        def factorial(x: Long): Long = if (x < 2) 1 else x * factorial(x\
    \ - 1)\n        //def oddSum(x: Long): Long = if (x % 2 == 0) factorial(x) else\
    \ oddSum(x - 1) + x\n        def oddSum(x: Long): Long = if (x % 2 == 0) factorial(x)\
    \ else if (x == 1) 1 else oddSum(x - 1) + x\n        var a = new ListBuffer[Long]()\n\
    \        for (i <- 1L to n) a += oddSum(i)\n        a.toList", "        val list\
    \ = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (i\
    \ % 2 == 0) {\n                list += (1 to i).product\n            } else {\n\
    \                list += (1 to i).sum\n            }\n        }\n        list.toList",
  "        def calc(i : Long) : Long = {\n            if (i == 0) {\n            \
    \    1\n            } else {\n                i * calc(i - 1)\n            }\n\
    \        }\n        val l = new ListBuffer[Long]\n        for (i <- 1 to n.toInt)\
    \ {\n            if (i % 2 == 0) {\n                l += calc(i)\n           \
    \ } else {\n                l += (1 to i).sum\n            }\n        }\n    \
    \    l.toList", "      var result = new ListBuffer[Long]\n      var s = 1l\n \
    \     var f = 1l\n      for (i <- 1l to n) {\n        if (i % 2 == 0) {\n    \
    \      f *= i\n          result += f\n        } else {\n          s += i\n   \
    \       result += s\n        }\n      }\n      result.toList", "        def g(i\
    \ : Long) : Long = if (i == 0) 1 else i * g(i - 1)\n        def h(i : Long) :\
    \ Long = if (i % 2 == 0) g(i) else i * (i + 1) / 2\n        List.range(1, n.toInt\
    \ + 1).map(h(_))", "    var m: List[Long] = List()\n    for (i <- 1l to n) {\n\
    \      if (i % 2 == 0) {\n        m = m :+ factorial(i)\n      } else {\n    \
    \    m = m :+ sum(i)\n      }", "        // Write your code here\n        return\
    \ List.range(1, n.toInt+1).toList.map(i => {\n            if (i % 2 == 0) factorial(i)\n\
    \            else i.toLong * (i.toLong + 1) / 2\n        })", "        // Fill\
    \ Up this function body\n        // `index` is the index of the list you're trying\
    \ to construct\n        // so, if the value of `index` is `i`, the value at index\
    \ `i` in the list\n        // will be added to the list.\n        val list = ListBuffer[Long]()\n\
    \        def go(index : Long) : List[Long] = {\n            if (index <= n) {\n\
    \                list += (if (index % 2 == 0) factorial(index) else sum(index))\n\
    \                go(index + 1)\n            }\n            else list.toList\n\
    \        }\n        go(1)", "        //fill up the list with 0\n        var list\
    \ = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) list += 0\n        //mutable\
    \ variable\n        var i = 1\n        while (i <= n) {\n            //even number\n\
    \            if (i % 2 == 0) list(i - 1) = factorial(i)\n            //odd number\n\
    \            else list(i - 1) = (1 to i).sum\n            i += 1\n        }\n\
    \        list.toList", "        if (n < 1) {\n            return List()\n    \
    \    }\n        val res = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            if (i % 2 == 0) {\n                res += (1 to i).product\n\
    \            } else {\n                res += (1 to i).sum\n            }\n  \
    \      }\n        res.toList", "        // Type your solution here\n        ???",
  "        // function to calculate factorial of i\n        def factorial(i : Long)\
    \ : Long = {\n            if (i <= 1) 1\n            else i * factorial(i - 1)\n\
    \        }\n        // function to calculate sum of first i numbers\n        def\
    \ sum(i : Long) : Long = {\n            if (i <= 1) 1\n            else i + sum(i\
    \ - 1)\n        }\n        if (n <= 0) List()\n        else if (n == 1) List(1)\n\
    \        else if (n % 2 == 0) List(factorial(n)) ::: f(n - 1)\n        else List(sum(n))\
    \ ::: f(n - 1)", "        val ans = new ListBuffer[Long]()\n        for (i <-\
    \ 1 to n.toInt) {\n            if (i % 2 == 0) ans += factorial(i)\n         \
    \   else ans += i\n        }\n        ans.toList", "        // Write your code\
    \ here\n        null", "      if (n == 0) List()\n      else {\n        def g(i\
    \ : Long) : Long = if (i % 2 == 0) (1 to i.toInt).foldLeft(1)(_ * _) else (1 to\
    \ i.toInt).sum\n        (1 to n.toInt).map(g).toList\n      }", "        val output\
    \ = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if (i %\
    \ 2 == 0) output += factorial(i)\n            else output += sum1toi(i)\n    \
    \    }\n        output.toList", "        // In this version, I used ranges.\n\
    \        // This version is slower than the other version (v1).\n        val r\
    \ = (1 to n.toInt).toList\n        r.map(i => if (i % 2 == 0) (1l to i.toLong).reduceLeft(_\
    \ * _) else (1l to i.toLong).reduceLeft(_ + _))", "        (1l to n).toList.map(x\
    \ => {\n            if (x % 2 == 0) factorial(x)\n            else x * (x + 1)\
    \ / 2\n        })", "      def factorial(n : Long) : Long = if (n < 1) 1 else\
    \ n * factorial(n - 1)\n      (1 to n.toInt).toList.map { i => if (i % 2 == 0)\
    \ factorial(i) else i * (i + 1) / 2 }", "      val lst = ListBuffer[Long]()\n\
    \      for (i <- 1l to n) lst += (if (i % 2 == 0) (1l to i).product else (1l to\
    \ i).sum)\n      lst.toList", "    \t(1l to n).toList.map(i => if (i % 2 == 0)\
    \ factorial(i) else sum(i))", '        (1 to n.toInt).toList.map(i => if (i %
    2 == 0) (1 to i).toList.product else (1 to i).toList.sum)', "        var result\
    \ = new ListBuffer[Long]\n        for (i <- 1l to n) {\n            var x = if\
    \ (i % 2 == 0) {\n                (1l to i).product\n            } else {\n  \
    \              (1l to i).sum\n            }\n            result += x\n       \
    \ }\n        result.toList", "        val data = new ListBuffer[Long]\n      \
    \  for (i <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n                var\
    \ fact = 1\n                for (j <- 1 to i) fact *= j\n                data\
    \ += fact\n            } else {\n                var sum = 0\n               \
    \ for (j <- 1 to i) sum += j\n                data += sum\n            }\n   \
    \     }\n        data.toList", "        var result = ListBuffer[Long]()\n    \
    \    for (i <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n              \
    \  result += factorial(i)\n            } else {\n                result += (1\
    \ to i).reduceLeft(_ + _)\n            }\n        }\n        result.toList", " \
    \       // your code here\n        null", "        val xs = new ArrayBuffer[Long]\n\
    \        xs.append(1)\n        if (n > 1) xs.append(2)\n        if (n > 2) {\n\
    \            xs.append(6)\n            for (i <- 4 until n.toInt + 1) {\n    \
    \            if (i % 2 == 0) xs.append(xs(i / 2 - 1) * i)\n                else\
    \ xs.append(i * (i + 1) / 2)\n            }\n        }\n        xs.toList", '      (1
    to n.toInt).map(x => if (x % 2 == 0) factorial(x) else sum(x)).toList', "    \
    \    // Write your code here.\n        var a: List[Long] = List()\n        for\
    \ (i <- 1 to n.toInt) {\n            if (i % 2 == 0) a = a :+ (1l to i.toLong).product\n\
    \            else a = a :+ (1l to i.toLong).sum\n        }\n        a", '        List[Long]()',
  "    }\n    // Implement the function g that takes n as a parameter,\n    // and\
    \ returns a list of size n, such that the value of the element at index i is i^i\
    \ (i to the power of i).\n    // i starts from 1.\n    // Example:\n    // >>>\
    \ g((5l))\n    // (List[Long](1l.toLong, 4l.toLong, 27l.toLong, 256l.toLong, 3125l.toLong))\n\
    \    def g(n : Long) : List[Long] = {", "        var result : List[Long] = Nil\n\
    \        var i = 1L\n        while (i <= n) {\n            if (i % 2 == 0) result\
    \ = result :+ factorial(i)\n            else result = result :+ sum(i)\n     \
    \       i += 1\n        }\n        result", "        // TIP: use List, Array and\
    \ ArrayBuffer for building the result and/or for higher performance\n        //\
    \ TIP: you can use map or for loops\n\n        def factorial(n:Long):Long = {\n\
    \            //throw new NotImplementedError()\n            var i = 0l\n     \
    \       var factorial = 1l\n            while (i < n) {\n                i = i\
    \ + 1\n                factorial = factorial * i\n            }\n            factorial\n\
    \        }\n\n        var i = 0l\n        var list1 = List[Long]()\n        while\
    \ (i < n) {\n            i = i + 1\n            if (i % 2 == 0) {\n          \
    \      list1 = list1 :+ factorial(i)\n            } else {\n                list1\
    \ = list1 :+ i\n            }\n        }\n        list1", "        if (n == 0)\
    \ return Nil\n        var result = ListBuffer[Long]()\n        result.append(1)\n\
    \        for (i <- 2 to n.toInt) {\n            if (i % 2 == 0) {\n          \
    \      result.append(result(i - 2) * i)\n            } else {\n              \
    \  result.append((1 to i).reduce(_ + _))\n            }\n        }\n        result.toList",
  "        // Write your code here\n        val l = new ListBuffer[Long]()\n     \
    \   for (i <- 1 to n.toInt) {\n            if (i % 2 == 0) l += fac(i)\n     \
    \       else l += sum(i)\n        }\n        l.toList", "        def append(num\
    \ : Long, list : List[Long]) : List[Long] = {\n            // append num to the\
    \ end of list\n            list :+ num\n        }\n        var list = List[Long]()\n\
    \        var lst = List[Long]()\n        for (i <- 1l to n) {\n            if\
    \ (i % 2 == 0) {\n                var product = 1l\n                for (j <-\
    \ 1l to i) {\n                    product *= j\n                }\n          \
    \      list = append(product, list)\n            }\n            else {\n     \
    \           var sum = 0l\n                for (j <- 1l to i) {\n             \
    \       sum += j\n                }\n                list = append(sum, list)\n\
    \            }\n        }\n        list", "        def f(n : Long, acc : List[Long])\
    \ : List[Long] = {\n        \tif (n == 0) acc\n        \telse if (n % 2 == 0)\
    \ f(n - 1, n * acc.head :: acc)\n        \telse f(n - 1, (1 to n.toInt).sum ::\
    \ acc)\n        }\n        f(n, List(1))", '        ???', "        def func(i\
    \ : Long) : Long = {\n            if (i % 2 == 0) {\n                var j = 1l\n\
    \                var res = 1l\n                while (j <= i) {\n            \
    \        res *= j\n                    j += 1\n                }\n           \
    \     res\n            } else {\n                var j = 1l\n                var\
    \ res = 0l\n                while (j <= i) {\n                    res += j\n \
    \                   j += 1\n                }\n                res\n         \
    \   }\n        }\n        var res = List[Long]()\n        var i = 1l\n       \
    \ while (i <= n) {\n            res ::= func(i)\n            i += 1\n        }\n\
    \        res.reverse", '        return List.range(1, (n + 1).toInt).map(i => if(i
    % 2 == 0) {i} else {List.range(1, i + 1).sum}).toList', "        var l = List[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n          \
    \      l = l :+ (1 to i).product\n            } else {\n                l = l\
    \ :+ (1 to i).sum\n            }\n        }\n        l", "        var l = new\
    \ ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            l += (if (i\
    \ % 2 == 0) i.toLong.factorial else i.toLong)\n        }\n        l.toList", " \
    \       def g(n : Long) : Long = {\n            if (n == 0) 1 else g(n - 1) *\
    \ n\n        }\n        def h(n : Long) : Long = {\n            if (n == 0) 0\
    \ else h(n - 1) + n\n        }\n        var i = 0l\n        var list = List[Long]()\n\
    \        while (i < n) {\n            if (i % 2 == 0) list = list :+ g(i)\n  \
    \          else list = list :+ h(i)\n            i += 1\n        }\n        list",
  "      var i = 0\n      var list = List[Long]()\n      while (i < n) {\n       \
    \ if (i % 2 == 0) {\n          list = list :+ (1l to i).product\n        } else\
    \ {\n          list = list :+ (1l to i).sum\n        }\n        i += 1\n     \
    \ }\n      list", "        def fInner(i : Long, result : List[Long]) : List[Long]\
    \ = {\n            if (i > n) result\n            else {\n                if (i\
    \ % 2 == 0) fInner(i + 1, result :+ (1L to i).reduce(_ * _))\n               \
    \ else fInner(i + 1, result :+ (1L to i).reduce(_ + _))\n            }\n     \
    \   }\n        fInner(1, List[Long]())", "        // Fill in the implementation\
    \ here\n        def loop(i : Long, acc : List[Long]) : List[Long] = {\n      \
    \      if (i == n) acc.reverse\n            else if (i % 2 == 0) loop(i + 1, acc.::(i\
    \ * (i - 1) to 1 by -1 reduceLeft (_ * _)))\n            else loop(i + 1, acc.::(i\
    \ * (i + 1) / 2))\n        }\n        loop(1, Nil)", "        var list = List[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n          \
    \      var product = 1\n                for (j <- 1 to i) {\n                \
    \    product *= j\n                }\n                list = list :+ product\n\
    \            } else {\n                var sum = 0\n                for (j <-\
    \ 1 to i) {\n                    sum += j\n                }\n               \
    \ list = list :+ sum\n            }\n        }\n        list", '        List.range(1,
    n.toInt + 1).map(x => (if (x % 2 == 0) factorial(x) else sum(x))).toList', '        List[Long]()',
  "      // for example:\n      // f(5)\n      // = List(1, 2, 6, 24, 15)\n      //\
    \ f(5) = List(1, 2, 6, 4!, 5!)\n      val list = new ListBuffer[Long]()\n    \
    \  for (i <- 1 to n.toInt) {\n        if (i % 2 == 0) {\n          var product\
    \ = 1\n          for (j <- 1 to i) {\n            product *= j\n          }\n\
    \          list += product\n        } else {\n          var sum = 0\n        \
    \  for (j <- 1 to i) {\n            sum += j\n          }\n          list += sum\n\
    \        }\n      }\n      list.toList", '        List.tabulate(n.toInt)(x =>
    if (x % 2 == 0) (1 to x).reduce(_ * _) else (1 to x).reduce(_ + _))', "      \
    \  // The answer should be returned in a List[Long].\n        // The easiest way\
    \ to create a list of a specific size is to use List.fill function.\n        //\
    \ For example:\n        // >>> List.fill(5)(1)\n        // List(1, 1, 1, 1, 1)\n\
    \        // Please note that the size of the list is 5 instead of 4.\n       \
    \ // You will have to do some math calculations.\n        // You will have to\
    \ return a List[Long] instead of a List[Int].\n        var list: List[Long] =\
    \ List.fill(n.toInt)(0)\n        for (x <- 1 to n.toInt) {\n            if (x\
    \ % 2 == 0) {\n                var factorial: Long = 1;\n                for (y\
    \ <- 1 to x) {\n                    factorial *= y\n                }\n      \
    \          list = list.updated(x - 1, factorial)\n            } else {\n     \
    \           var sum: Long = 0;\n                for (y <- 1 to x) {\n        \
    \            sum += y\n                }\n                list = list.updated(x\
    \ - 1, sum)\n            }\n        }\n        return list", "        // Write\
    \ your code here.\n        var a: List[Long] = List()\n        for (i <- 1L to\
    \ n) {\n            if (i % 2 == 0) {\n                a = a :+ (i - 1).toLong\n\
    \            } else {\n                a = a :+ (i * (i + 1) / 2).toLong\n   \
    \         }\n        }\n        return a", "        var lst = List[Long]()\n \
    \       for (i <- 1l to n) {\n            if (i % 2 == 0) {\n                var\
    \ fct = 1l\n                for (j <- 1l to i) {\n                    fct *= j\n\
    \                }\n                lst :+= fct\n            } else {\n      \
    \          var sum = 0l\n                for (j <- 1l to i) {\n              \
    \      sum += j\n                }\n                lst :+= sum\n            }\n\
    \        }\n        lst", "        def loop(i : Long, accum : List[Long]) : List[Long]\
    \ = {\n            if (i == n) accum\n            else if (i % 2 == 0) loop(i\
    \ + 1, accum :+ (i to 1 by -1).map(i => i).product)\n            else loop(i +\
    \ 1, accum :+ (i to 1 by -1).map(i => i).sum)\n        }\n        loop(1, List())",
  "        // write the body of this function\n        // f(n)", "        var r =\
    \ List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (i % 2 == 0)\
    \ {\n                var rr = 1l\n                for (j <- 1 to i) rr *= j\n\
    \                r = rr :: r\n            } else {\n                var rr = 0l\n\
    \                for (j <- 1 to i) rr += j\n                r = rr :: r\n    \
    \        }\n        }\n        r.reverse", "        // Write your code here\n\
    \        return List(1l, 2l, 6l, 24l, 15l)", "        var l = ListBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            if (i % 2 == 0) l += factorial(i)\n\
    \            else l += sum(i)\n        }\n        l.toList", '        for (i <-
    1l to n.toLong) yield if (i % 2 == 0) (2l to i).product else (1l to i).sum', '        //
    Write your code here', "        // Implement this function and change the return\
    \ value\n        List(1l)", "        val l = new ArrayList[Long]()\n        for\
    \ (i <- 1l to n) {\n            if (i % 2 == 0) l.add(factorial(i))\n        \
    \    else l.add(sum(i))\n        }\n        l.toList", "        // Start writing\
    \ your ScalaFiddle code here\n        def factorial(n : Long) : Long = {\n   \
    \       if (n <= 1) 1\n          else n * factorial(n - 1)\n        }\n      \
    \  def sum(n : Long) : Long = {\n          (1 to n.toInt).toList.sum\n       \
    \ }\n        (1 to n.toInt).toList.map(n => if (n % 2 == 0) factorial(n) else\
    \ sum(n))", "        def factorial(n : Long) : Long = (1l to n).reduceLeft(_ *\
    \ _)\n        def sum(n : Long) : Long = (1l to n).reduceLeft(_ + _)\n       \
    \ val list = for(i <- 1l to n) yield i % 2 match {\n            case 0 => factorial(i)\n\
    \            case _ => sum(i)\n        }\n        list.toList", "        var p\
    \ = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if (i\
    \ % 2 == 0) {\n                p += (1 to i).reduceLeft(_ * _)\n            }\
    \ else {\n                p += (1 to i).reduceLeft(_ + _)\n            }\n   \
    \     }\n        p.toList", "        val a = List.range(1, n.toInt + 1).map {i\
    \ =>\n            if (i % 2 == 0) (1L to i).product else i.toLong * (i.toLong\
    \ + 1L) / 2L\n        }\n        a.toList", "        val result = new ListBuffer[Long]\n\
    \        for (i <- 1l to n) {\n            val num = if (i % 2 == 0) {\n     \
    \           var sum = 1l\n                for (j <- 1l to i) {\n             \
    \       sum *= j\n                }\n                sum\n            } else {\n\
    \                (1l to i).sum\n            }\n            result += num\n   \
    \     }\n        result.toList", "        // works for n = 1000\n        var result\
    \ = ListBuffer[Long]()\n        for (i <- 1l to n) {\n            if (i % 2 ==\
    \ 0) result += factorial(i)\n            else result += sum(i)\n        }\n  \
    \      result.toList", "        var l = List[Long]()\n        for (i <- 1l to\
    \ n) {\n            if (i % 2 == 0) {\n                l = l :+ 1l.toLong\n  \
    \              for (j <- 2l to i) {\n                    l = l.updated(l.length\
    \ - 1, l(l.length - 1) * j)\n                }\n            } else {\n       \
    \         l = l :+ i * (i + 1) / 2\n            }\n        }\n        l", "  \
    \  // Write your code here\n        var a:List[Long] = new ListBuffer[Long]()\n\
    \        for(i <- 1l to n) {\n            if(i % 2 == 0) a += ((1l to i).product)\n\
    \            else a += ((1l to i).sum)\n        }\n        a.toList", "      \
    \  val l = new ArrayList[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i % 2 == 0) l.add(factorial(i))\n            else l.add(sum(i))\n   \
    \     }\n        l.toList", "\tval s = List.range(1, n.toInt + 1).map(x => (x\
    \ % 2, x)).map(y => if (y._1 == 0) factorial(y._2) else sum(y._2))\n\ts.toList",
  "        // your code here\n        (1l to n).map(x => if (x % 2 == 0) List(factorial(x))\
    \ else List(sumTo(x))).toList.flatten", "        def getList(n : Long) : List[Long]\
    \ = {\n            if (n == 0) List()\n            else getList(n - 1) :+ n\n\
    \        }\n        getList(n).map(x => if (x % 2 == 0) getList(x).product else\
    \ getList(x).sum)", "        val list = ListBuffer[Long]()\n        for (i <-\
    \ 1 to n.toInt) {\n            if (i % 2 == 0) list += factorial(i)\n        \
    \    else list += sum(i)\n        }\n        list.toList", "        val l = new\
    \ ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (i % 2 ==\
    \ 0) {\n                var fact = 1\n                for (j <- 1 to i) fact *=\
    \ j\n                l += fact\n            } else {\n                var sum\
    \ = 0\n                for (j <- 1 to i) sum += j\n                l += sum\n\
    \            }\n        }\n        l.toList", "        var result = List[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            if (i % 2 == 0) result = result\
    \ :+ (2 to i).product\n            else result = result :+ (1 to i).sum\n    \
    \    }\n        result", "        var list = new ListBuffer[Long]()\n        for\
    \ (i <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n                list +=\
    \ List.range(1, i + 1).reduceLeft(_ * _)\n            } else {\n             \
    \   list += List.range(1, i + 1).reduceLeft(_ + _)\n            }\n        }\n\
    \        list.toList", "        val l = new ListBuffer[Long]\n        for (i <-\
    \ 1 to n.toInt) {\n            if (i % 2 == 0) l += factorial(i)\n           \
    \ else l += sum(i)\n        }\n        l.toList", "        var list = List[Long]()\n\
    \        for (i <- 1l to n) {\n            if (i % 2 == 0) {\n               \
    \ var ans = 1l\n                for (j <- 1l to i) ans *= j\n                list\
    \ = list :+ ans\n            }\n            else {\n                var ans =\
    \ 0l\n                for (j <- 1l to i) ans += j\n                list = list\
    \ :+ ans\n            }\n        }\n        list", "        var L = new ListBuffer[Long]\n\
    \        for (i <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n          \
    \      L += i.toLong * i.toLong\n            } else {\n                L += (1\
    \ to i).sum\n            }\n        }\n        L.toList", "        val list =\
    \ new ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if (i\
    \ % 2 == 0) {\n                var sum = 1\n                for (j <- 1 to i)\
    \ {\n                    sum *= j\n                }\n                list +=\
    \ sum\n            } else {\n                var sum = 0\n                for\
    \ (j <- 1 to i) {\n                    sum += j\n                }\n         \
    \       list += sum\n            }\n        }\n        list.toList", "       \
    \ def factorial(n : Long) : Long = {\n            if (n == 0) 1\n            else\
    \ n * factorial(n - 1)\n        }\n        (1l to n).map(i => if (i % 2 == 0)\
    \ factorial(i) else i * (i + 1) / 2).toList", "        // TODO: finish the function\
    \ definition here\n        null", "      // Write here your code.\n\tval result\
    \ = ArrayBuffer[Long]()\n\tfor (i <- 1 to n.toInt) {\n\t    if (i % 2 == 0) {\n\
    \t\tresult += (1 to i).product\n\t    } else {\n\t\tresult += (1 to i).sum\n\t\
    \    }\n\t}\n\tresult.toList", "        var result : List[Long] = Nil\n      \
    \  for (i <- 1l to n) {\n            if (i % 2 == 0) {\n                var f\
    \ : Long = 1\n                for (j <- 1l to i) {\n                    f *= j\n\
    \                }\n                result = f :: result\n            } else {\n\
    \                var sum : Long = 0\n                for (j <- 1l to i) {\n  \
    \                  sum += j\n                }\n                result = sum ::\
    \ result\n            }\n        }\n        result.reverse", "      val res =\
    \ (1 to n.toInt).foldLeft(List[Long]())((acc, x) => acc :+ ((if (x % 2 == 0) (2\
    \ to x).foldLeft(1l)((acc2, x2) => acc2 * x2) else x.toLong)))\n      return res",
  "        var l = List[Long]()\n        for (i <- 1l to n) {\n            var a =\
    \ 1l\n            if (i % 2 == 0) {\n                for (j <- 1l to i) {\n  \
    \                  a *= j\n                }\n            } else {\n         \
    \       for (j <- 1l to i) {\n                    a += j\n                }\n\
    \            }\n            l = l :+ a\n        }\n        return l", "      \
    \  val l = List.tabulate(n.toInt)((i : Int) => {\n        \tif (i % 2 == 0) factorial(i)\n\
    \        \telse sum(i)\n        })\n        l", "        var l = new ListBuffer[Long]\n\
    \        var i = 1\n        while (i <= n) {\n            if (i % 2 == 0) l +=\
    \ factorial(i)\n            else l += (1 to i).reduceLeft(_ + _)\n           \
    \ i += 1\n        }\n        l.toList", "        // Write your code here\n   \
    \     // Return an empty list\n        return List[Long]()", "        val l =\
    \ ListBuffer[Long]()\n        l += 1\n        var i = 2\n        while (i <= n)\
    \ {\n            l += (if (i % 2 == 0) (2 to i).reduceLeft(_ * _) else (1 to i).reduceLeft(_\
    \ + _))\n            i += 1\n        }\n        l.toList", "        var list =\
    \ List[Long]()\n        for (i <- 1l to n) {\n            if (i % 2 == 0) list\
    \ = list :+ (i - 1).product + 2\n            else list = list :+ (1l to i).sum\n\
    \        }\n        list", "        def g(list : List[Long], value : Long) : List[Long]\
    \ = {\n            val head = list.head\n            val tail = list.tail\n  \
    \          if (head == 0) {\n                if (value % 2 == 0) value\n     \
    \           else head + value\n            }\n            else {\n           \
    \     if (value % 2 == 0) value * head\n                else head + value\n  \
    \          }\n            val new_head = if (value % 2 == 0) value * head else\
    \ head + value\n            val new_tail = tail :+ value\n            (new_head\
    \ :: new_tail)\n        }\n        var result = List[Long](0)\n        for (i\
    \ <- 1 to n.toInt) {\n            result = g(result, i)\n        }\n        result",
  "        def factorial(i : Long) : Long = (1l to i).foldLeft(1l)(_ * _)\n      \
    \  (1l to n).map(i => if (i % 2 == 0) factorial(i) else (1l to i).sum).toList",
  "        var l = ListBuffer[Long]()\n        for (i <- 1l to n) {\n            if\
    \ (i % 2 == 0) l += factorial(i)\n            else l += (1l to i).sum\n      \
    \  }\n        l.toList", "\t\tList.range(1,n.toInt+1).map(x => if (x % 2 == 0)\
    \ factorial(x) else sum(x)).toList", "        // Fill up this function body\n\
    \        // 'val' is a keyword that declares a read-only variable.\n        //\
    \ 'to' is a keyword used for creating ranges.\n        // 'take' is a method that\
    \ takes the first n elements from a list or a range.\n        // 'map' is a method\
    \ that creates a new list by applying a function to each element of a list.\n\
    \        val nl = (1l to n).toList\n        nl.map(i => if (i % 2 == 0) (1l to\
    \ i).toList.foldLeft(1l)(_ * _) else i * (i + 1) / 2)", "        def fac(a : Long)\
    \ : Long = (1 to a.toInt).foldLeft(1)(_ * _)\n        def sum(a : Long) : Long\
    \ = (1 to a.toInt).foldLeft(0)(_ + _)\n        (1l to n).map(x => if (x % 2 ==\
    \ 0) fac(x) else sum(x)).toList", "      if (n <= 0) List()\n      else {\n  \
    \      var ret = new ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n\
    \          if (i % 2 == 0) ret += (1L to i.toLong).reduce(_ * _)\n          else\
    \ ret += (1L to i.toLong).reduce(_ + _)\n        }\n        ret.toList\n     \
    \ }", "        // Write your code here\n        return List[Long]()", "      \
    \  if (n < 1) {\n            return Nil\n        }\n        def f2(m : Long) :\
    \ Long = {\n            if (m == 1) return 1\n            if (m == 2) return 2\n\
    \            var sum = 1\n            for (x <- 2 to m.toInt) {\n            \
    \    sum *= x\n            }\n            return sum\n        }\n        val lst\
    \ = new ListBuffer[Long]\n        for (i <- 1l to n) {\n            if (i % 2\
    \ == 0) {\n                lst += f2(i)\n            } else {\n              \
    \  lst += (1 to i.toInt).sum\n            }\n        }\n        return lst.toList",
  "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i % 2 == 0) result ::= (1 to i).product\n            else result ::=\
    \ (1 to i).sum\n        }\n        result.reverse", "        // Write your solution\
    \ here\n        def factorial(num: Int): Long = {\n            var sum = 1L\n\
    \            for (i <- 1 to num) {\n                sum *= i\n            }\n\
    \            sum\n        }\n        var list = new ListBuffer[Long]()\n     \
    \   for (i <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n               \
    \ list += factorial(i)\n            } else {\n                list += (1 to i).sum\n\
    \            }\n        }\n        list.toList", '        List()', "    }\n}",
  "        var factorial = 1l\n        var list = List[Long]()\n        for (i <-\
    \ 1 to n.toInt) {\n            if (i % 2 == 0) {\n                factorial *=\
    \ i\n                list = list :+ factorial\n            }\n            else\
    \ list = list :+ ((i * (i + 1)) / 2)\n        }\n        list", "        // Write\
    \ your implementation here\n        //\n        def factorial(n: Long) : Long\
    \ = {\n            var result = 1l\n            for (i <- 1l to n) {\n       \
    \         result *= i\n            }\n            result\n        }\n        def\
    \ sum(n: Long) : Long = {\n            (1l to n).sum\n        }\n        var result\
    \ = List[Long]()\n        for (i <- 1l to n) {\n            if (i % 2 == 0) {\n\
    \                result :+= factorial(i)\n            } else {\n             \
    \   result :+= sum(i)\n            }\n        }\n        result", "        var\
    \ result = List[Long]()\n        for (i <- 1l to n) {\n            if (i % 2 ==\
    \ 0) result ::= (2l to i).product\n            else result ::= (1l to i).sum\n\
    \        }\n        result.reverse", "        var f = new ListBuffer[Long]\n \
    \       for (i <- 1l to n) {\n            if (i % 2 == 0) {\n                f\
    \ += (1l to i).product\n            } else {\n                f += (1l to i).sum\n\
    \            }\n        }\n        f.toList", "      var result = new ListBuffer[Long]\n\
    \      var i = 1\n      while (i <= n) {\n        if (i % 2 == 0) {\n        \
    \  var j = 2\n          var f = 1\n          while (j <= i) {\n            f *=\
    \ j\n            j += 1\n          }\n          result += f\n        } else {\n\
    \          var j = 1\n          var f = 0\n          while (j <= i) {\n      \
    \      f += j\n            j += 1\n          }\n          result += f\n      \
    \  }\n        i += 1\n      }\n      result.toList", "        def f_rec(n : Long,\
    \ acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n          \
    \  else if (n % 2 == 0) f_rec(n - 1, acc :+ (1 to n.toInt).product.toLong)\n \
    \           else f_rec(n - 1, acc :+ (1 to n.toInt).sum.toLong)\n        }\n \
    \       f_rec(n, List())", "        var list = new ListBuffer[Long]\n        for\
    \ (i <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n                var product\
    \ = 1l\n                for (j <- 1 to i) product *= j\n                list +=\
    \ product\n            }\n            else {\n                var sum = 0l\n \
    \               for (j <- 1 to i) sum += j\n                list += sum\n    \
    \        }\n        }\n        list.toList", "      def factorial(i : Long) :\
    \ Long = {\n        (1l to i).foldLeft(1l)(_ * _)\n      }\n      (1l to n).toList.map(i\
    \ => if (i % 2 == 0) factorial(i) else (1l to i).sum)", "        val list = ArrayBuffer[Long]()\n\
    \        for (i <- 1l to n) {\n            if (i % 2 == 0) list += fRange(1l,\
    \ i)\n            else list += i * (i + 1) / 2\n        }\n        list.toList",
  "        var ans = ListBuffer[Long]()\n        var count = 1\n        while (count\
    \ <= n) {\n            if (count % 2 == 0) ans += factorial(count)\n         \
    \   else ans += sigma(count)\n            count += 1\n        }\n        ans.toList",
  "        for (i <- 1 to n.toInt) yield if (i % 2 == 0) factorial(i) else sum(i)\n\
    \    }.toList\n    \n    def factorial(i : Int) : Long = {\n        (1 to i).reduceLeft(_\
    \ * _)", "        var l : List[Long] = Nil\n        for (i <- 1 to n.toInt) {\n\
    \            if (i % 2 == 0) {\n                var k = 1l\n                for\
    \ (j <- 1 to i) k *= j\n                l = l :+ k\n            } else {\n   \
    \             var k = 0l\n                for (j <- 1 to i) k += j\n         \
    \       l = l :+ k\n            }\n        }\n        l", "        // Write your\
    \ code here\n        var l = List[Long]()\n        for (i <- 1l to n) {\n    \
    \        if (i % 2 == 0) {\n                var ans = 1l\n                for\
    \ (j <- 1l to i) ans *= j\n                l = ans :: l\n            }\n     \
    \       else {\n                var ans = 0l\n                for (j <- 1l to\
    \ i) ans += j\n                l = ans :: l\n            }\n        }\n      \
    \  l.reverse", '        return List[Long]()', "      val l = new ArrayBuffer[Long]\n\
    \      for (i <- 1 to n.toInt) {\n        if (i % 2 == 0) {\n          l += (1L\
    \ to i.toLong).product\n        } else {\n          l += (1L to i.toLong).sum\n\
    \        }\n      }\n      l.toList", "        val lst = new ListBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n          \
    \      lst += (1 to i).product\n            } else {\n                lst += (1\
    \ to i).sum\n            }\n        }\n        lst.toList", "        def factorial(n\
    \ : Long) : Long = {\n            if (n == 0) 1 else n * factorial(n - 1)\n  \
    \      }\n        var l = List[Long]()\n        for (i <- 1l to n) {\n       \
    \     if (i % 2 == 0) l :+= factorial(i)\n            else l :+= (1l to i).sum\n\
    \        }\n        l", "        var result = new ListBuffer[Long]\n        for\
    \ (i <- 1 to n.toInt) {\n            if (i % 2 == 0) result += (1 to i).product\n\
    \            else result += (1 to i).sum\n        }\n        result.toList", " \
    \       val l = ListBuffer[Long]()\n        var i = 1l\n        while (i <= n)\
    \ {\n            if (i % 2 == 0) {\n                l += (1l to i).product\n \
    \           } else {\n                l += (1l to i).sum\n            }\n    \
    \        i += 1\n        }\n        l.toList", "        // Write your code here.\n\
    \        if (n == 0) return List()\n        val r = new ArrayBuffer[Long]\n  \
    \      r += 1\n        var i = 2l\n        var p = 1l\n        while (i <= n)\
    \ {\n            val t = if (i % 2 == 0) i else (1l to i).reduceLeft(_ + _)\n\
    \            r += t\n            i += 1\n        }\n        r.toList", "     \
    \ var r = ListBuffer[Long]()\n      for (i <- 1 to n.toInt) {\n        r += ((if\
    \ (i % 2 == 0) (1 to i).product else (1 to i).sum).toLong)\n      }\n      r.toList",
  "      def g(i : Long) : Long = if (i % 2 == 0) (1 to i.toInt).map(x => x.toLong).product\
    \ else i * (i + 1) / 2\n      (1 to n.toInt).map(x => g(x.toLong)).toList", " \
    \       // write your code here.\n        var ans = List[Long]()\n        for\
    \ (i <- 1l to n) {\n            if (i % 2 == 0) {\n                var result\
    \ = 1l\n                for (j <- 1l to i) {\n                    result *= j\n\
    \                }\n                ans :+= result\n            } else {\n   \
    \             var result = 0l\n                for (j <- 1l to i) {\n        \
    \            result += j\n                }\n                ans :+= result\n\
    \            }\n        }\n        ans", "\t\tvar xs = List[Long]()\n\t\tfor (i\
    \ <- 1l to n) {\n\t\t\tif (i % 2 == 0) {\n\t\t\t\txs ::= (1l to i).reduceLeft(_\
    \ * _)\n\t\t\t} else {\n\t\t\t\txs ::= (1l to i).reduceLeft(_ + _)\n\t\t\t}\n\t\
    \t}\n\t\txs.reverse", '        ???', "      // Write your code here\n      val\
    \ lst = (1l to n).toList\n      var result = new ListBuffer[Long]()\n      for\
    \ (i <- lst) {\n        if (i % 2 == 0) {\n          var ret = 1l\n          for\
    \ (j <- 1l to i) {\n            ret *= j\n          }\n          result += ret\n\
    \        } else {\n          var ret = 0l\n          for (j <- 1l to i) {\n  \
    \          ret += j\n          }\n          result += ret\n        }\n      }\n\
    \      result.toList", "        def fInternal(n : Long, acc : List[Long]) : List[Long]\
    \ = n match {\n            case n if n <= 0 => acc\n            case n if n %\
    \ 2 == 0 => fInternal(n - 1, n :: acc)\n            case n => fInternal(n - 1,\
    \ (1l to n).sum :: acc)\n        }\n        fInternal(n, Nil).reverse", "    \
    \    if (n == 0) Nil\n        else if (n % 2 == 0) (n - 1) * n :: f(n - 1)\n \
    \       else n * (n + 1) / 2 :: f(n - 1)", "        val list = new ListBuffer[Long]\n\
    \        (1 to n.toInt).foreach(i => {\n            if (i % 2 == 0) {\n      \
    \          var f = 1\n                (1 to i).foreach(f *= _)\n             \
    \   list += f\n            } else {\n                var f = 0\n             \
    \   (1 to i).foreach(f += _)\n                list += f\n            }\n     \
    \   })\n        list.toList", "      val out = new ArrayBuffer[Long]()\n     \
    \ for (i <- 1l to n) {\n        if (i % 2 == 0) out += factorial(i)\n        else\
    \ out += (1l to i).sum\n      }\n      out.toList", "        // Write your implementation\
    \ here.\n        n match {\n            case 1 => List(1l)\n            case _\
    \ => {\n                var l = f(n - 1)\n                if (n % 2 == 0) {\n\
    \                    l :+ l.last * n\n                } else {\n             \
    \       l :+ (1 to n.toInt).sum\n                }\n            }\n        }",
  "        require(n > 0)\n        if (n == 1) {\n            List(1)\n        } else\
    \ {\n            var i = 1\n            var l : List[Long] = List[Long]()\n  \
    \          var even = false\n            for (i <- 1 to n.toInt) {\n         \
    \       if (even) {\n                    l = l :+ factorial(i)\n             \
    \   } else {\n                    l = l :+ (1 to i).sum\n                }\n \
    \               even = !even\n            }\n            l\n        }", "    \
    \    // TODO implement this function.\n        return List()", "        var result\
    \ = ListBuffer[Long]()\n        for (i <- 1l to n) {\n            if (i % 2 ==\
    \ 0) {\n                result += (1l to i).foldLeft(1l)(_ * _)\n            }\
    \ else {\n                result += (1l to i).sum\n            }\n        }\n\
    \        result.toList", '        return List[Long]()', "        val l = new ListBuffer[Long]\n\
    \        for (i <- 1 to n.toInt) {\n            if (i % 2 == 0) l += (1 to i).product\n\
    \            else l += (1 to i).sum\n        }\n        l.toList", "    // Write\
    \ your implementation here\n    //return null\n    n match {\n        case n if\
    \ n <= 0 => List()\n        case 1 => List(1)\n        case n => val prev = f(n-1)\n\
    \        if (n % 2 == 0) prev:+n.factorial\n        else prev:+prev.last + n",
  "      def sum(n : Long) : Long = {\n        if (n == 1) 1\n        else n + sum(n\
    \ - 1)\n      }\n      def factorial(n : Long) : Long = {\n        if (n == 1)\
    \ 1\n        else n * factorial(n - 1)\n      }\n      val l = new ListBuffer[Long]\n\
    \      (1l to n).foreach(i => if (i % 2 == 0) l += factorial(i) else l += sum(i))\n\
    \      l.toList", "        // Fill up this function body.\n        // You can\
    \ add another function as well, if required.\n        // first element is 1\n\
    \        // second element is 2 (1 + 1)\n        // third element is 6 (1 + 2\
    \ + 3)\n        // fourth element is 24 (1 * 2 * 3 * 4)\n        // fifth element\
    \ is 15 (1 + 2 + 3 + 4 + 5)\n        // sixth element is 720 (1 * 2 * 3 * 4 *\
    \ 5 * 6)\n        // seventh element is 28 (1 + 2 + 3 + 4 + 5 + 6 + 7)\n     \
    \   // eighth element is 40320 (1 * 2 * 3 * 4 * 5 * 6 * 7 * 8)\n        var result\
    \ = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (i\
    \ % 2 == 0) {\n                result += factorial(i)\n            } else {\n\
    \                result += sum(i)\n            }\n        }\n        result.toList",
  "        def g(i : Long) : Long = if (i == 0) 1 else i * g(i - 1)\n        var result\
    \ = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            result\
    \ += (if (i % 2 == 0) g(i) else ((1 to i).toList.reduce(_ + _)))\n        }\n\
    \        result.toList", "        // Fill up this function body\n        // You\
    \ may also need to define some auxiliary functions or classes\n        def factorial(n:\
    \ Long): Long = {\n            def findFactorial(n: Long, accumulator: Long):\
    \ Long = {\n                if (n <= 1) accumulator\n                else findFactorial(n\
    \ - 1, n * accumulator)\n            }\n            findFactorial(n, 1)\n    \
    \    }\n        var list: List[Long] = List()\n        for (i <- 1L to n) {\n\
    \            if (i % 2 == 0) {\n                list = list :+ factorial(i)\n\
    \            } else {\n                list = list :+ (1L to i).sum\n        \
    \    }\n        }\n        list", "        var result = List[Long]()\n       \
    \ for (i <- 1l to n) {\n            if (i % 2 == 0) {\n                var factorial\
    \ : Long = 1\n                for (j <- 1l to i) {\n                    factorial\
    \ *= j\n                }\n                result = result :+ factorial\n    \
    \        } else {\n                var sum : Long = 0\n                for (j\
    \ <- 1l to i) {\n                    sum += j\n                }\n           \
    \     result = result :+ sum\n            }\n        }\n        return result",
  "        var a = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n       \
    \     if (i % 2 == 0) a += factorial(i)\n            else a += i.toLong\n    \
    \    }\n        a.toList", '        ???', "        val res = ListBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n          \
    \      res += (1l to i).product\n            } else {\n                res +=\
    \ (1l to i).sum\n            }\n        }\n        res.toList", "        def factorial(n\
    \ : Long) : Long = if (n <= 1) 1 else n * factorial(n - 1)\n        val list =\
    \ ListBuffer[Long]()\n        var i = 1\n        while (i <= n) {\n          \
    \  if (i % 2 == 0) {\n                list += factorial(i)\n            } else\
    \ {\n                list += (1 to i).sum\n            }\n            i += 1\n\
    \        }\n        list.toList", "        var l = List[Long]()\n        for (i\
    \ <- 1 to n.toInt) {\n            if (i % 2 == 0) l = l :+ (2 to i).product\n\
    \            else l = l :+ (1 to i).sum\n        }\n        l", "        // implemented\
    \ by myself.\n        def isEven(n : Long) : Boolean = {\n            if(n % 2\
    \ == 0) true else false\n        }\n        def factorical(n : Long) : Long =\
    \ {\n            if(n <= 1) 1 else n * factorical(n - 1)\n        }\n        def\
    \ sum(n : Long) : Long = {\n            if(n <= 1) 1 else n + sum(n - 1)\n   \
    \     }\n        def g(n : Long) : Long = {\n            if(isEven(n)) factorical(n)\
    \ else sum(n)\n        }\n        if(n <= 0) Nil else g(n) :: f(n - 1)", "   \
    \     var l = List[Long]()\n        for (i <- 1 to n.toInt) l = l :+ ((if (i %\
    \ 2 == 0) factorial(i) else sum(i)))\n        l", "        def factorial(x : Long)\
    \ : Long = {\n            (1l to x).foldLeft(1l)(_ * _)\n        }\n        (1l\
    \ to n).map(i => if (i % 2 == 0) factorial(i) else (1l to i).sum).toList", " \
    \       // input : n, the size of the list\n        // output : a list of size\
    \ n\n        // i: index starts from 1\n        // if i is even, the element of\
    \ the list is the factorial of i, 1 * 2 * 3 * ... * i\n        // if i is odd,\
    \ the element of the list is the sum of numbers from 1 to i, 1 + 2 + 3 + ... +\
    \ i\n        // the function should return (List[Long](1l.toLong, 2l.toLong, 6l.toLong,\
    \ 24l.toLong, 15l.toLong))\n        // for n = 5\n        // 1 2 6 24 15\n   \
    \     var list = new ListBuffer[Long]\n        for (i <- 1l to n) {\n        \
    \    if (i % 2 == 0) {\n                var t = 1l\n                for (j <-\
    \ 1l to i) {\n                    t *= j\n                }\n                list\
    \ += t\n            } else {\n                var t = 0l\n                for\
    \ (j <- 1l to i) {\n                    t += j\n                }\n          \
    \      list += t\n            }\n        }\n        list.toList", "        def\
    \ factorial(i : Long) : Long = {\n            (1l to i).foldLeft(1l)(_ * _)\n\
    \        }\n        (1l to n).map(i => if (i % 2 == 0) factorial(i) else (1l to\
    \ i).foldLeft(0l)(_ + _)).toList", "        val o = Buffer[Long]()\n        for\
    \ (i <- 1 to n.toInt) o += (if (i % 2 == 0) (2 to i).foldLeft(1l)(_ * _) else\
    \ (1 to i).sum)\n        o.toList", "        var factorial = 1l\n        var list:\
    \ List[Long] = List()\n        for (i <- 1 to n.toInt) {\n            if (i %\
    \ 2 == 0) {\n                factorial *= i\n                list = list :+ factorial\n\
    \            } else {\n                list = list :+ (1l to i.toLong).sum\n \
    \           }\n        }\n        list", "        // throw new NotImplementedError()\n\
    \        val list = new ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n\
    \            if (i % 2 == 0) {\n                list += (1 to i).foldLeft(1l)(_\
    \ * _)\n            } else {\n                list += (1 to i).foldLeft(0l)(_\
    \ + _)\n            }\n        }\n        list.toList", "      var list = List[Long]()\n\
    \      for (i <- 1 to n.toInt) {\n        if (i % 2 == 0) list = list :+ (1l to\
    \ i).reduce(_ * _)\n        else list = list :+ (1l to i).reduce(_ + _)\n    \
    \  }\n      list", "        //TODO\n        List(0l)", "    }\n    // Implement\
    \ the function g that takes the list l as a parameter,\n    // and returns a list\
    \ that has the elements of l where the value of each element is squared.\n   \
    \ // Example:\n    // >>> g((List[Int](1, 2, 3, 4, 5)))\n    // (List[Int](1,\
    \ 4, 9, 16, 25))\n    def g(l : List[Int]) : List[Int] = {", "        // TODO:\
    \ implement this function\n        val list = new ListBuffer[Long]()\n       \
    \ for (i <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n                var\
    \ fac = 1\n                for (j <- 1 to i) fac *= j\n                list +=\
    \ fac\n            } else {\n                var sum = 0\n                for\
    \ (j <- 1 to i) sum += j\n                list += sum\n            }\n       \
    \ }\n        list.toList", "        var lst = new ListBuffer[Long]()\n       \
    \ for (i <- 1l to n) {\n            lst += (if (i % 2 == 0) factorial(i) else\
    \ sumTo(i))\n        }\n        lst.toList", "    }\n    // If a person chooses\
    \ to take a cab, the person pays a fixed cost of $2, plus $0.23 per kilometer\
    \ traveled.\n    // If a person chooses to take the bus, the person pays a fixed\
    \ cost of $1.50 per ride, plus a fixed cost of $0.10\n    // per kilometer traveled.\n\
    \    // A ride on the bus is considered to be a sequence of trips from one bus\
    \ stop to the next.\n    // A bus ride can have at most 40 stops and is at least\
    \ 4 stops.\n    //\n    // Implement the function cost that takes an array of\
    \ numbers as input, where each number corresponds to the\n    // distance (in\
    \ kilometers) from one bus stop to the next.\n    // The function should return\
    \ the cost of using the bus and the cost of using a cab.\n    //\n    // Example:\n\
    \    // >>> cost(Array(1.0, 2.0, 3.0, 4.0))\n    // (7.60, 6.92)\n    def cost(distances\
    \ : Array[Double]) : (Double, Double) = {", "        var result = ListBuffer[Long]()\n\
    \        for (i <- 1 to n.toInt) {\n            result += (if (i % 2 == 0) f1(i)\
    \ else f2(i))\n        }\n        result.toList", "        // Write your code\
    \ here\n        val list:Array[Long] = new Array[Long](n.toInt)\n        for (i\
    \ <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n                list(i -\
    \ 1) = (1 to i).product\n            } else {\n                list(i - 1) = (1\
    \ to i).sum\n            }\n        }\n        list.toList", "        // TODO\n\
    \        null", '        List[Long]()', "        val list = new ListBuffer[Long]\n\
    \        for (i <- 1l to n) {\n            if (i % 2 == 0) list += factorial(i)\n\
    \            else list += (1l to i).sum\n        }\n        list.toList", "  \
    \      def f(l : List[Long], i : Long) : List[Long] = {\n            if (i ==\
    \ n) l\n            else {\n                val n = if (i % 2 == 0) {\n      \
    \              (1l to i).toList.product\n                } else {\n          \
    \          (1l to i).toList.sum\n                }\n                f(l :+ n,\
    \ i + 1)\n            }\n        }\n        f(List[Long](), 1)", '        // Your
    code goes here', "        // Please implement here\n        return List[Long]()",
  "      //TODO\n        List()", "        val output = new ListBuffer[Long]()\n \
    \       for (i <- 1l to n) {\n            output += (if (i % 2 == 0) factorial(i)\
    \ else sum(i))\n        }\n        output.toList", "      def g(n : Long, acc\
    \ : List[Long]) : List[Long] = if (n == 0) acc else if (n % 2 == 0) g(n - 1, acc\
    \ :+ n.toLong) else g(n - 1, acc :+ (1L to n).reduce(_ + _))\n      g(n, List())",
  "        // Write your code here\n        // Return an empty list\n        List[Long]()",
  "        var list = List[Long]()\n        for (i <- 1 to n.toInt) {\n          \
    \  if (i % 2 == 0) list = list :+ (1l to i.toLong).product\n            else list\
    \ = list :+ (1l to i.toLong).sum\n        }\n        list", "        def fac(n\
    \ : Long) : Long = if (n == 0) 1 else n * fac(n - 1)\n        def acc(n : Long)\
    \ : Long = if (n == 0) 0 else n + acc(n - 1)\n        var r = List[Long]()\n \
    \       for (i <- 1 to n.toInt) {\n            val v = if (i % 2 == 0) fac(i)\
    \ else acc(i)\n            r = r :+ v\n        }\n        r", "        def g(n\
    \ : Long) : Long = if (n == 0) 1 else n * g(n - 1)\n        (1l to n).map(x =>\
    \ if (x % 2 == 0) g(x) else x * (x + 1) / 2).toList", "        val result = new\
    \ ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if (i % 2\
    \ == 0) {\n                result += (1l.toLong to i.toLong).reduce(_ * _)\n \
    \           } else {\n                result += (1l.toLong to i.toLong).reduce(_\
    \ + _)\n            }\n        }\n        result.toList", "        var result\
    \ : List[Long] = List[Long]()\n        if (n > 0) {\n            var i : Long\
    \ = 1\n            while (i <= n) {\n                if (i % 2 == 0) result =\
    \ result :+ (1 to i).foldLeft(1l)(_ * _)\n                else result = result\
    \ :+ (1 to i).foldLeft(0l)(_ + _)\n                i += 1\n            }\n   \
    \     }\n        result", "        if (n == 0) return Nil\n        val list =\
    \ new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (i %\
    \ 2 == 0) list += (1L to i).product\n            else list += (1L to i).sum\n\
    \        }\n        list.toList", "        val res = new ListBuffer[Long]\n  \
    \      if (n == 0) res.toList\n        else {\n            for (i <- 1l to n)\
    \ {\n                if (i % 2 == 0) res += factorial(i)\n                else\
    \ res += (1l to i).sum\n            }\n            res.toList\n        }"]
stop_tokens:
- "\n    }\n"
