name: HumanEval_161_solve
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a string s.\n    // if s[i] is a letter, reverse its case\
  \ from lower to upper or vise versa, \n    // otherwise keep it as it is.\n    //\
  \ If the string contains no letters, reverse the string.\n    // The function should\
  \ return the resulted string.\n    // Examples\n    // >>> solve((\"1234\"))\n \
  \   // (\"4321\")\n    // >>> solve((\"ab\"))\n    // (\"AB\")\n    // >>> solve((\"\
  #a@C\"))\n    // (\"#A@c\")\n    def solve(s : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(solve((\"AsDf\")).equals((\"\
  aSdF\")));\n    assert(solve((\"1234\")).equals((\"4321\")));\n    assert(solve((\"\
  ab\")).equals((\"AB\")));\n    assert(solve((\"#a@C\")).equals((\"#A@c\")));\n \
  \   assert(solve((\"#AsdfW^45\")).equals((\"#aSDFw^45\")));\n    assert(solve((\"\
  #6@2\")).equals((\"2@6#\")));\n    assert(solve((\"#$a^D\")).equals((\"#$A^d\")));\n\
  \    assert(solve((\"#ccc\")).equals((\"#CCC\")));\n    }\n\n}\n"
completions: ["        if (s.length() == 0) return \"\"\n        else if (s.length()\
    \ == 1) return if (s.matches(\"[a-zA-Z]+\")) s.toUpperCase() else s.toLowerCase()\n\
    \        else {\n            val sb = new StringBuilder\n            for (i <-\
    \ 0 until s.length()) {\n                if (s(i).matches(\"[a-zA-Z]+\")) {\n\
    \                    if (s(i).isUpper) sb.append(s(i).toLower)\n             \
    \       else sb.append(s(i).toUpper)\n                }\n                else\
    \ sb.append(s(i))\n            }\n            return sb.toString\n        }",
  "        // Type your solution here\n        \"\".toString", "        // Write your\
    \ code here\n        \"\"", "        if (s.isEmpty) \"\"\n        else {\n   \
    \         if (s.forall(!_.isLetter)) {\n                val r = new StringBuilder\n\
    \                r.append(s.charAt(s.length - 1))\n                for (i <- (0\
    \ until s.length - 1).reverse) {\n                    r.append(s.charAt(i))\n\
    \                }\n                r.toString\n            }\n            else\
    \ {\n                var r = new StringBuilder\n                for (i <- 0 until\
    \ s.length) {\n                    if (s.charAt(i).isLetter) {\n             \
    \           if (s.charAt(i).isUpper) {\n                            r.append(s.charAt(i).toLower)\n\
    \                        }\n                        else {\n                 \
    \           r.append(s.charAt(i).toUpper)\n                        }\n       \
    \             }\n                    else {\n                        r.append(s.charAt(i))\n\
    \                    }\n                }\n                r.toString\n      \
    \      }\n        }", "        if (s.isEmpty) return s\n        var res = \"\"\
    \n        for (c <- s) {\n            if (c.isLetter) {\n                if (c.isUpper)\
    \ res += c.toLower\n                else res += c.toUpper\n            }\n   \
    \         else res += c\n        }\n        if (res.exists(_.isLetter)) res\n\
    \        else res.reverse", '        s.reverse.map(ch => if(ch.isLetter) ch.toUpperCase
    else ch.toLowerCase).mkString', "        if (s.forall(!_.isLetter)) {\n      \
    \      s.reverse\n        } else {\n            s.map(c => if (c.isLetter) c.toUpper\
    \ ^ c.toLower else c)\n        }", "        val n = s.length\n        val nl =\
    \ s.count(_.isLetter)\n        if (nl == 0) s.reverse\n        else s.map(x =>\
    \ if (x.isLetter) x.toggleCase else x)", '        ???', "      val isLowerCase\
    \ = {\n        s.filter(ch => ch.isLetter).length == s.filter(ch => ch.isLetter\
    \ && ch.isLower).length\n      }\n      if(s.filter(ch => ch.isLetter).length\
    \ == 0) {\n        s.reverse\n      } else {\n        if(isLowerCase) {\n    \
    \      s.map(ch => if(ch.isLetter) ch.toUpper else ch)\n        } else {\n   \
    \       s.map(ch => if(ch.isLetter) ch.toLower else ch)\n        }\n      }",
  "        if (s.exists(c => c.isLetter)) s.map(c => if (c.isLetter) c.toUpper else\
    \ c.toLower)\n        else s.reverse", "        var charArray : Array[Char] =\
    \ s.toCharArray\n        var isLetter : Boolean = false\n        for (ch <- charArray)\
    \ {\n            if (Character.isLetter(ch)) {\n                isLetter = true\n\
    \                break\n            }\n        }\n        if (isLetter) {\n  \
    \          for (i <- 0 until charArray.length) {\n                if (Character.isLetter(charArray(i)))\
    \ {\n                    charArray(i) = charArray(i) match {\n               \
    \         case 'a' => 'A'\n                        case 'b' => 'B'\n         \
    \               case 'c' => 'C'\n                        case 'd' => 'D'\n   \
    \                     case 'e' => 'E'\n                        case 'f' => 'F'\n\
    \                        case 'g' => 'G'\n                        case 'h' =>\
    \ 'H'\n                        case 'i' => 'I'\n                        case 'j'\
    \ => 'J'\n                        case 'k' => 'K'\n                        case\
    \ 'l' => 'L'\n                        case 'm' => 'M'\n                      \
    \  case 'n' => 'N'\n                        case 'o' => 'O'\n                \
    \        case 'p' => 'P'\n                        case 'q' => 'Q'\n          \
    \              case 'r' => 'R'\n                        case 's' => 'S'\n    \
    \                    case 't' => 'T'\n                        case 'u' => 'U'\n\
    \                        case 'v' => 'V'\n                        case 'w' =>\
    \ 'W'\n                        case 'x' => 'X'\n                        case 'y'\
    \ => 'Y'\n                        case 'z' => 'Z'\n                        case\
    \ 'A' => 'a'\n                        case 'B' => 'b'\n                      \
    \  case 'C' => 'c'\n                        case 'D' => 'd'\n                \
    \        case 'E' => 'e'\n                        case 'F' => 'f'\n          \
    \              case 'G' => 'g'\n                        case 'H' => 'h'\n    \
    \                    case 'I' => 'i'\n                        case 'J' => 'j'\n\
    \                        case 'K' => 'k'\n                        case 'L' =>\
    \ 'l'\n                        case 'M' => 'm'\n                        case 'N'\
    \ => '", "        // Write your code here\n        var res : String = \"\"\n \
    \       for (c <- s) {\n            res += if (c.isLetter) c.toUpper ^ c.toLower\
    \ else c\n        }\n        if (res.length == s.length) res else res.reverse",
  "        // Write your solution here\n        val i = s.indices.find(s(_).isLetter)\n\
    \        if (i.isEmpty) s.reverse\n        else {\n            def swap(str :\
    \ String, i : Int) : String = str.indices.map(j => {\n                if (j ==\
    \ i) str(j) match {\n                    case c if c.isUpper => c.toLower\n  \
    \                  case c if c.isLower => c.toUpper\n                    case\
    \ _ => c\n                }\n                else str(j)\n            }).mkString\n\
    \            swap(s, i.get)\n        }", "        // Fill up this function body\n\
    \        // 'best' is the best answer found so far\n        var best = \"\"\n\
    \        // 'cand' is the candidate answer\n        var cand = \"\"\n        //\
    \ 'candi' is the string generated by the candidate answer\n        var candi =\
    \ \"\"\n        // Iterate over all possible combinations of the letters\n   \
    \     for (cand <- 0 to (1 << s.size) - 1) {\n            candi = \"\"\n     \
    \       for (i <- 0 to s.size - 1) {\n                if ((cand & (1 << i)) !=\
    \ 0) {\n                    candi += s(i).toUpper\n                } else {\n\
    \                    candi += s(i).toLower\n                }\n            }\n\
    \            if (best == \"\" || candi < best) {\n                best = candi\n\
    \            }\n        }\n        return best", "        var alphabets = ListBuffer[Char]()\n\
    \        for (c <- s) {\n            if (c.isLetter) alphabets += c\n        }\n\
    \        if (alphabets.isEmpty) {\n            return s.reverse\n        }\n \
    \       for (c <- s) {\n            if (c.isLetter) {\n                if (c.isUpper)\
    \ alphabets += c.toLower\n                else alphabets += c.toUpper\n      \
    \      }\n            else alphabets += c\n        }\n        alphabets.mkString",
  '        ???', "        // Write your code here\n        def upper(ch : Char) :\
    \ Char = if (ch >= 'a' && ch <= 'z') ch.toUpper else ch.toLower\n        if (s.length\
    \ == 0) return s\n        var p = 0\n        var q = s.length - 1\n        while\
    \ (p < q) {\n            while (p < q && s(p) < 'a' || s(p) > 'z') p += 1\n  \
    \          while (p < q && s(q) < 'a' || s(q) > 'z') q -= 1\n            if (p\
    \ < q) {\n                val tmp = s(p)\n                s(p) = upper(s(q))\n\
    \                s(q) = upper(tmp)\n                p += 1\n                q\
    \ -= 1\n            }\n        }\n        s", "        var c = new Array[Char](s.length)\n\
    \        for (i <- 0 until s.length) {\n            if (s(i).isLetter) {\n   \
    \             if (s(i).isUpper) c(i) = s(i).toLower\n                else c(i)\
    \ = s(i).toUpper\n            }\n            else c(i) = s(i)\n        }\n   \
    \     var a = new StringBuffer()\n        for (i <- 0 until s.length) a += c(i)\n\
    \        return a.toString", "        var res = \"\"\n        for (c <- s) {\n\
    \            if (c.isLetter) {\n                if (c.isUpper) res += c.toLower\n\
    \                else res += c.toUpper\n            }\n            else res +=\
    \ c\n        }\n        if (res == s) res.reverse\n        else res", "      \
    \  if (s.count(x => x.isLetter) == 0)\n            return s.reverse\n        val\
    \ result = s.map(x => if (x.isLetter) x.swapCase else x)\n        result", " \
    \       val letters = s.toCharArray.filter(_.isLetter)\n        if (letters.length\
    \ == 0) {\n            s.reverse\n        } else {\n            val nstr = s.toCharArray.map(ch\
    \ => if (ch.isLetter) ch.toLower else ch)\n            var i = 0\n           \
    \ while (i < letters.length) {\n                val index = nstr.indexOf(letters(i).toLower)\n\
    \                nstr(index) = letters(i)\n                i += 1\n          \
    \  }\n            nstr.mkString\n        }", "        if (s.forall(_.isDigit))\
    \ {\n            s.reverse\n        } else {\n            val (x, y) = s.partition(_.isDigit)\n\
    \            val z = y.toLowerCase.zip(y).map{case (c1, c2) => if (c1 == c2) c1.toUpper\
    \ else c1.toLower}\n            x + z\n        }", "        var ans = \"\"\n \
    \       for (i <- 0 until s.length) {\n            if (s(i).isLetter) {\n    \
    \            if (s(i).isUpper) ans += s(i).toLower\n                else ans +=\
    \ s(i).toUpper\n            }\n            else ans += s(i)\n        }\n     \
    \   if (ans.length == s.length) ans.reverse\n        else ans", "        s.toList.reverse.map{\n\
    \            case ch if 'a' <= ch && ch <= 'z' => ch.toUpper\n            case\
    \ ch if 'A' <= ch && ch <= 'Z' => ch.toLower\n            case ch => ch\n    \
    \    }.mkString", "        val chars = s.toCharArray.map(c => {\n            if(c.isLetter)\
    \ c.toUpper ^ c.toLower ^ c\n            else c\n        })\n        new String(chars)",
  '        ""', "        // Write your code here\n        def lower(char : Char) :\
    \ Char = char.toLower\n        def upper(char : Char) : Char = char.toUpper\n\
    \        val caps = ('A' to 'Z').toSet\n        if (s.forall(char => !caps.contains(char)\
    \ && !caps.contains(lower(char)))) s.reverse\n        else s.map(c => if (caps.contains(c))\
    \ lower(c) else upper(c))", "        // Write your code here\n        var res\
    \ = \"\"\n        for (c <- s) {\n            if (c.isLetter) {\n            \
    \    res += if (c.isUpper) c.toLower else c.toUpper\n            } else {\n  \
    \              res += c\n            }\n        }\n        if (res.isEmpty) s.reverse\
    \ else res", "        val letters = ('a' to 'z') ++ ('A' to 'Z')\n        if (s.exists(letters.contains(_)))\
    \ {\n            val trans = (c : Char) => if (letters.contains(c)) c.toLower\
    \ ^ c.toUpper else c\n            return s.map(trans)\n        }\n        return\
    \ s.reverse", "        val isUpper = (c : Char) => c.isUpper\n        val toUpper\
    \ = (c : Char) => c.toUpper\n        val toLower = (c : Char) => c.toLower\n \
    \       if (s.exists(c => c.isLetter)) {\n            s.map(c => if (isUpper(c))\
    \ toLower(c) else toUpper(c))\n        } else {\n            s.reverse\n     \
    \   }", "        val len = s.length\n        var swap = true\n        var result\
    \ = \"\"\n        for (i <- 0 until len) {\n            if (Character.isLetter(s(i)))\
    \ {\n                if (swap) {\n                    if (Character.isUpperCase(s(i)))\
    \ {\n                        result += Character.toLowerCase(s(i))\n         \
    \           } else {\n                        result += Character.toUpperCase(s(i))\n\
    \                    }\n                } else {\n                    result +=\
    \ s(i)\n                }\n                swap = !swap\n            } else {\n\
    \                result += s(i)\n            }\n        }\n        if (swap) result.reverse\
    \ else result", "        val hasLetter = s.exists(p => p.isLetter)\n        if\
    \ (hasLetter) {\n            val result = s.map(p => if (p.isLetter) p.toUpper\
    \ else p.toLower)\n            result\n        } else {\n            val result\
    \ = s.reverse\n            result\n        }", "        // Complete this function\n\
    \        val s_ = s.filter(x => x.isLetter)\n        if (s_.isEmpty) return s.reverse\n\
    \        val s__ = s_.map(x => x.toLower)\n        val res = s.map(x => if (x.isLetter)\
    \ x.toLower else x)\n        val ans = res.zip(s__).map(y => if (y._1 == y._2)\
    \ y._1.toUpper else y._1.toLower)\n        ans.mkString", "        // your solution\
    \ goes here\n        if (s.exists(_.isLetter)) {\n            s.map(x => if (x.isLetter)\
    \ if (x.isUpper) x.toLower else x.toUpper else x)\n        } else {\n        \
    \    s.reverse\n        }", "        // Write your code here\n        s", "  \
    \      if (s.map(c => c.isLetter).forall(b => !b)) return s.reverse\n        s.map(c\
    \ => if (c.isLetter) c.toLower.toUpper.toLower else c).reverse", "        val\
    \ isLetter = (c : Char) => c.isLetter\n        def rev(c : Char) = if (isLetter(c))\
    \ c.toUpperCase else c.toLowerCase\n        if (s.exists(isLetter)) s.map(rev)\
    \ else s.reverse", "        s.map {\n            x =>\n                if (x.isLetter)\n\
    \                    if (x.isUpper)\n                        x.toLower\n     \
    \               else\n                        x.toUpper\n                else\n\
    \                    x\n        }.reverse", "        if(s.forall(!_.isLetter))\
    \ s.reverse\n        else s.toCharArray.map(x => if(x.isLetter) x.toLower ^ x.toUpper\
    \ else x).mkString", "        s.count(_.isLetter) match {\n            case 0\
    \ => s.reverse\n            case _ => s.map(a => if (a.isLetter) if (a.isUpper)\
    \ a.toLower else a.toUpper else a)\n        }", "        val n = s.length\n  \
    \      var i = 0\n        while (i < n && !s(i).isLetter) {\n            i +=\
    \ 1\n        }\n        if (i == n) return s.reverse\n        var ret = \"\"\n\
    \        i = 0\n        while (i < n) {\n            if (s(i).isLetter) {\n  \
    \              ret += s(i).toLower.toUpper.toLower\n            } else {\n   \
    \             ret += s(i)\n            }\n            i += 1\n        }\n    \
    \    ret", "        var result = \"\"\n        for (i <- 0 until s.length) {\n\
    \            if (Character.isLetter(s(i))) {\n                result += s(i) match\
    \ {\n                    case Character.toLowerCase(s(i)) => Character.toUpperCase(s(i))\n\
    \                    case Character.toUpperCase(s(i)) => Character.toLowerCase(s(i))\n\
    \                }\n            } else {\n                result += s(i)\n   \
    \         }\n        }\n        if (result == \"\") {\n            result = s.reverse\n\
    \        }\n        result", "        // Let's add code here\n        val letters\
    \ = List('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\
    \ 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n        var chars\
    \ = s.toCharArray()\n        var hasLetters = false\n        for (i <- 0 until\
    \ chars.length) {\n            val ch = chars(i)\n            if (letters.contains(ch))\
    \ {\n                hasLetters = true\n                chars(i) = if (letters.contains(ch.toLower))\
    \ ch.toUpper else ch.toLower\n            }\n        }\n        if (hasLetters)\
    \ new String(chars) else s.reverse", "        var ans = \"\"\n        if (s.forall(!_.isLetter))\
    \ ans = s.reverse\n        else {\n            for (i <- 0 until s.length) {\n\
    \                if (s(i).isLetter) {\n                    if (s(i).isUpper) ans\
    \ += s(i).toLower\n                    else ans += s(i).toUpper\n            \
    \    }\n                else ans += s(i)\n            }\n        }\n        ans",
  "        val letters = s.filter(c => c.isLetter)\n        if (letters.isEmpty) s.reverse\n\
    \        else {\n            val result = new StringBuilder()\n            for\
    \ (i <- 0 until s.length) {\n                if (s(i).isLetter) {\n          \
    \          result.append(s(i).toUpper)\n                } else {\n           \
    \         result.append(s(i))\n                }\n            }\n            result.toString\n\
    \        }", "        if (s.matches(\"[A-Za-z]*\")) s.reverse\n        else s.toList.map\
    \ { \n            case c if c.isLetter => if (c.isUpper) c.toLower else c.toUpper\n\
    \            case c => c\n        }.mkString(\"\")", "        val flag = s.map(c\
    \ => if (c.isLetter) true else false).toList.contains(true)\n        if (flag)\
    \ {\n            s.map(c => if (c.isLetter) c.toLower else c.toUpper).reverse\n\
    \        } else {\n            s.reverse\n        }", "        def f(c : Char)\
    \ : Char = if (c.isLetter) c.toUpper ^ c.toLower else c\n        if (s.exists(_.isLetter))\
    \ s.map(f) else s.reverse", "        // Write your code here\n        var hasLetter\
    \ = false\n        var result = new StringBuilder()\n        for (c <- s) {\n\
    \            if (c.isLetter) {\n                hasLetter = true\n           \
    \     result += c.toLowerCase\n            } else {\n                result +=\
    \ c\n            }\n        }\n        if (hasLetter) {\n            var result2\
    \ = new StringBuilder()\n            for (c <- result) {\n                if (c.isLetter)\
    \ {\n                    result2 += c.toUpper\n                } else {\n    \
    \                result2 += c\n                }\n            }\n            result2.toString\n\
    \        } else {\n            result.reverse.toString\n        }", "        var\
    \ str = \"\"\n        for (i <- 0 until s.length) {\n            if (s(i).isLetter)\
    \ {\n                if (s(i).isUpper) {\n                    str += s(i).toLower\n\
    \                } else {\n                    str += s(i).toUpper\n         \
    \       }\n            } else {\n                str += s(i)\n            }\n\
    \        }\n        if (str.length == s.length) {\n            return str\n  \
    \      } else {\n            return s.reverse\n        }", "        def helper(cs\
    \ : List[Char]) : List[Char] = {\n            if (cs.isEmpty) return cs\n    \
    \        val ch = cs.head\n            val nch = if (ch.isLetter) {\n        \
    \        if (ch.isUpper) ch.toLower else ch.toUpper\n            } else ch\n \
    \           nch :: helper(cs.tail)\n        }\n        if (s.isEmpty) s\n    \
    \    else helper(s.toList).mkString", "        if (s.forall(!_.isLetter)) s.reverse\n\
    \        else s.map(c => if (c.isLetter) c.toLower ^ c.toUpper else c)", "   \
    \     // Write your code here\n        s", "        var solution : String = \"\
    \"\n        for (i <- 0 until s.length) {\n            if (s(i).isLetter) {\n\
    \                solution += s(i).toUpper\n            } else {\n            \
    \    solution += s(i)\n            }\n        }\n        solution.reverse", " \
    \   \tval x = s.toCharArray\n    \tval y = x.map( x => if (x.isLetter) {\n   \
    \ \t\tif (x.isUpper) x.toLower else x.toUpper\n    \t} else x)\n    \tnew String(y)",
  "        val str = s.map(c => if (c.isLetter) c.toUpper.toString else c.toLower.toString)\n\
    \        if (str.exists(c => c.isLetter)) str.mkString\n        else str.reverse.mkString",
  "        val noLetters = s.forall(c => !c.isLetter)\n        if (noLetters) s.reverse\n\
    \        else s.map(c => if (c.isLetter) c.toLowerCase() else c.toUpperCase()).reverse",
  "        val letter = s.filter(_.isLetter)\n        if (letter.isEmpty) s.reverse\n\
    \        else s.map(c => if (c.isLetter) c.toUpper ^ c.toLower else c)", "   \
    \ \tif (s.isEmpty()) \"\"\n    \telse if (s.forall(!_.isLetter)) s.reverse\n \
    \   \telse s.map(c => if (c.isUpper) c.toLower else c.toUpper)", "        if (s.length\
    \ == 0) s\n        else {\n            val isLetter = s.map(x => if (x.isLetter)\
    \ true else false)\n            if (isLetter.contains(true)) s.map(x => if (x.isUpper)\
    \ x.toLower else x.toUpper)\n            else s.reverse\n        }", "       \
    \ if (s.isEmpty) s else {\n            val first = s.head\n            val firstIsLetter\
    \ = first.isLetter\n            val firstIsLetterUpper = first.isUpper\n     \
    \       val rest = s.tail\n            val restIsLetter = rest.exists(_.isLetter)\n\
    \            if (firstIsLetter && restIsLetter) {\n                if (firstIsLetterUpper)\
    \ first.toLower + solve(rest) else first.toUpper + solve(rest)\n            }\
    \ else if (firstIsLetter && !restIsLetter) {\n                if (firstIsLetterUpper)\
    \ first.toLower + solve(rest) else first.toUpper + solve(rest)\n            }\
    \ else if (!firstIsLetter && restIsLetter) {\n                first + solve(rest)\n\
    \            } else {\n                solve(rest) + first\n            }\n  \
    \      }", "        if (s.isEmpty) return s\n        val ls = s.charAt(0).isLetter\n\
    \        val rs = s.charAt(s.length - 1).isLetter\n        var t = s\n       \
    \ if (ls) t = t.charAt(0).toUpper.toString + t.substring(1)\n        if (rs) t\
    \ = t.substring(0, t.length - 1) + t.charAt(t.length - 1).toUpper.toString\n \
    \       return t", '        return s.reverse.map(i => if (i.isLetter) i.toUpper
    else i.toLower).reverse', "        if (s.exists(_.isLetter)) {\n            s.map(x\
    \ => if (x.isLetter) if (x.isUpper) x.toLower else x.toUpper else x)\n       \
    \ } else {\n            s.reverse\n        }", "        var (chars, r) = s.partition(c\
    \ => c.isLetter)\n        if (chars.length == 0) return r.reverse\n        var\
    \ arr = chars.toCharArray\n        for (i <- 0 until arr.length) {\n         \
    \   if (arr(i).isUpper) arr(i) = arr(i).toLower\n            else arr(i) = arr(i).toUpper\n\
    \        }\n        r + arr.mkString(\"\")", "        // Write your code here\n\
    \        s.filter(x => x.isLetter).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString",
  "        val letters = (s.toLowerCase().diff(s.toUpperCase())).distinct.sorted\n\
    \        var order = s.toLowerCase().toList.distinct.sorted\n        if (letters.length\
    \ > 0) {\n            order = order.filter(!letters.contains(_))\n           \
    \ letters ++ order\n        } else letters\n        new String(letters.toArray)",
  "        val regex = \"([a-z]|[A-Z])\".r\n        val x = regex.findAllIn(s)\n \
    \       if (x.isEmpty)\n            s.reverse\n        else {\n            val\
    \ res = new StringBuilder(s)\n            for (i <- 0 until res.length()) {\n\
    \                val c = res(i)\n                if (c.isLetter) {\n         \
    \           if (c.isUpper) res(i) = c.toLower\n                    else res(i)\
    \ = c.toUpper\n                }\n            }\n            res.toString\n  \
    \      }", "        val a = s.toCharArray()\n        val n = a.length\n      \
    \  var i = 0\n        var f = false\n        while (i < n) {\n            if (a(i).isLetter)\
    \ {\n                f = true\n                if (a(i).isUpper) a(i) = a(i).toLower\n\
    \                else a(i) = a(i).toUpper\n            }\n            i += 1\n\
    \        }\n        if (!f) {\n            val b = new Array[Char](n)\n      \
    \      i = 0\n            while (i < n) {\n                b(i) = a(n - i - 1)\n\
    \                i += 1\n            }\n            new String(b)\n        } else\
    \ new String(a)", "        def helper(i : Int, r : String) : String = {\n    \
    \        if (i == s.length) r\n            else {\n                if (s(i).isLetter)\
    \ {\n                    if (s(i).isUpper) helper(i + 1, r + s(i).toLower)\n \
    \                   else helper(i + 1, r + s(i).toUpper)\n                }\n\
    \                else helper(i + 1, r + s(i))\n            }\n        }\n    \
    \    if (s.forall(c => !c.isLetter)) s.reverse\n        else helper(0, \"\")",
  "        if (s.forall(p => p.isDigit)) s.reverse\n        else s.map(p => if (p.isLetter)\
    \ if (p.isUpper) p.toLower else p.toUpper else p)", "        var res = \"\"\n\
    \        var flag = true\n        for (c <- s) {\n            if (c.isLetter)\
    \ {\n                if (flag) {\n                    res += c.toUpper\n     \
    \               flag = false\n                } else {\n                    res\
    \ += c.toLower\n                    flag = true\n                }\n         \
    \   } else {\n                res += c\n            }\n        }\n        if (flag)\
    \ res.reverse else res", "        val str_array = s.split(\"\")\n        var contains_letter\
    \ = false\n        var changed_str_array = ArrayBuffer[String]()\n        for\
    \ (str <- str_array) {\n            if (str.matches(\"[a-zA-Z]\")) {\n       \
    \         contains_letter = true\n                changed_str_array += str.reverse\n\
    \            } else {\n                changed_str_array += str\n            }\n\
    \        }\n        if (contains_letter)\n            changed_str_array.mkString(\"\
    \")\n        else\n            s.reverse", "        def isLetter(ch : Char) :\
    \ Boolean = {\n            return ch.isLetter\n        }\n        val s = s.toLowerCase\n\
    \        if (s.filter(isLetter).isEmpty) s.reverse\n        else s.map(ch => if\
    \ (isLetter(ch)) ch.toUpper else ch.toLower)", "        val l = s.length\n   \
    \     var upper = false\n        for (i <- 0 until l) {\n            if ('a' <=\
    \ s(i) && s(i) <= 'z') upper = true\n            if ('A' <= s(i) && s(i) <= 'Z')\
    \ upper = true\n        }\n        if (upper) {\n            s.map(c => if ('a'\
    \ <= c && c <= 'z') c.toUpper else if ('A' <= c && c <= 'Z') c.toLower else c)\n\
    \        } else {\n            s.reverse\n        }", "        if (s.forall(!_.isLetter))\
    \ {\n            s.reverse\n        } else {\n            s.map(x => if (x.isLetter)\
    \ {\n                if (x.isUpper) {\n                    x.toLower\n       \
    \         } else {\n                    x.toUpper\n                }\n       \
    \     } else {\n                x\n            })\n        }", "        if (s.forall(c\
    \ => !c.isLetter))\n            s.reverse\n        else\n            s.map(c =>\
    \ if (c.isLetter) (if (c.isUpper) c.toLower else c.toUpper) else c)", "      \
    \  val reverseS = s.map(c => if (c.isLetter) c.toLower else c.toUpper)\n     \
    \   if (s.equals(reverseS)) reverseS.reverse else reverseS", "        val r =\
    \ new StringBuilder\n        for (c <- s) {\n            if (c.isLetter) {\n \
    \               if (c.isUpper) r += c.toLower\n                else r += c.toUpper\n\
    \            } else r += c\n        }\n        r.reverse.toString", "        var\
    \ str = s\n        var lower_count = 0\n        for (i <- 0 until s.length())\
    \ {\n            if (isLetter(s(i))) {\n                lower_count += 1\n   \
    \             str = str.updated(i, if (s(i).isLower) s(i).toUpper else s(i).toLower)\n\
    \            }\n        }\n        return if (lower_count == 0) s.reverse else\
    \ str", "        var lst = s.toList\n        for (i <- 0 until lst.length) {\n\
    \            if (lst(i).isLetter) {\n                if (lst(i).isUpper) {\n \
    \                   lst = lst.updated(i, lst(i).toLower)\n                } else\
    \ {\n                    lst = lst.updated(i, lst(i).toUpper)\n              \
    \  }\n            }\n        }\n        return lst.reverse.mkString", "      \
    \  val rev : List[Char] = s.toCharArray.toList.filter(c => c.isLetter)\n     \
    \   if (rev.isEmpty) {\n            s.reverse\n        } else {\n            val\
    \ letters : List[Char] = s.toCharArray.toList.map(c => if (c.isLetter) if (c.isUpper)\
    \ c.toLower else c.toUpper else c)\n            letters.mkString\n        }",
  "        var a = ArrayBuffer[Char]()\n        var b = ArrayBuffer[Char]()\n    \
    \    for (i <- 0 until s.length) {\n            if (Character.isLetter(s(i)))\
    \ {\n                a += s(i)\n                b += Character.toUpperCase(s(i))\n\
    \            }\n        }\n        if (a.length == 0) return s.reverse\n     \
    \   for (i <- 0 until s.length) {\n            if (Character.isLetter(s(i))) {\n\
    \                if (s(i) == b(0)) s(i) = a(0)\n                else s(i) = b(0)\n\
    \            }\n        }\n        return s", "        val reverseString = s.map(x\
    \ => if (x.isLetter) x.toLower ^ 32 else x)\n        reverseString match {\n \
    \           case string if (string.exists(x => x.isLetter)) => string\n      \
    \      case _ => reverseString.reverse\n        }", "        val digits = \"1234567890\"\
    .toList\n        val letters = \"abcdefghijklmnopqrstuvwxyz\".toList\n       \
    \ if (s.exists(d => digits.contains(d))) s.reverse\n        else {\n         \
    \   val reverse = s.map(c => {\n                if (letters.contains(c.toLower))\
    \ {\n                    if (c.isUpper) c.toLower\n                    else c.toUpper\n\
    \                }\n                else c\n            })\n            reverse\n\
    \        }", "        val letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val num = \"0123456789\"\n        var flag = true\n        var result\
    \ = \"\"\n        for (i <- 0 until s.length) {\n            if (letters.contains(s(i)))\
    \ {\n                if (s(i).isUpper) result += s(i).toLower else result += s(i).toUpper\n\
    \                flag = false\n            } else if (num.contains(s(i))) {\n\
    \                result += s(i)\n                flag = false\n            }\n\
    \        }\n        if (flag) result = s.reverse\n        result", '        s.map(i
    => if (i.isLetter) if (i.isUpper) i.toLower else i.toUpper else i).reverse', " \
    \       def allLetters(s : String) : Boolean = {\n            s.forall(x => Character.isLetter(x))\n\
    \        }\n        def toRev(s : String) : String = {\n            s.map(x =>\
    \ if (Character.isLowerCase(x)) x.toUpper else x.toLower)\n        }\n       \
    \ def rev(s : String) : String = {\n            if (allLetters(s)) {\n       \
    \         toRev(s)\n            } else {\n                s.reverse\n        \
    \    }\n        }\n        if (s.size == 0) {\n            \"\"\n        } else\
    \ {\n            rev(s)\n        }", "        val charArr = s.toCharArray\n  \
    \      val charArrSize = charArr.size\n        var hasLetter = false\n       \
    \ var newCharArr = new Array[Char](charArrSize)\n        for (i <- 0 until charArrSize)\
    \ {\n            charArr(i) match {\n                case 'a' | 'b' | 'c' | 'd'\
    \ | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q'\
    \ | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' => {\n               \
    \     newCharArr(i) = charArr(i).toUpper\n                    hasLetter = true\n\
    \                }\n                case 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'\
    \ | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'\
    \ | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' => {\n                    newCharArr(i)\
    \ = charArr(i).toLower\n                    hasLetter = true\n               \
    \ }\n                case _ => newCharArr(i) = charArr(i)\n            }\n   \
    \     }\n        if (hasLetter) {\n            new String(newCharArr)\n      \
    \  } else {\n            new String(newCharArr.reverse)\n        }", "       \
    \ var res = \"\"\n        for (c <- s) {\n            c match {\n            \
    \    case 'A' => res += 'a'\n                case 'B' => res += 'b'\n        \
    \        case 'C' => res += 'c'\n                case 'D' => res += 'd'\n    \
    \            case 'E' => res += 'e'\n                case 'F' => res += 'f'\n\
    \                case 'G' => res += 'g'\n                case 'H' => res += 'h'\n\
    \                case 'I' => res += 'i'\n                case 'J' => res += 'j'\n\
    \                case 'K' => res += 'k'\n                case 'L' => res += 'l'\n\
    \                case 'M' => res += 'm'\n                case 'N' => res += 'n'\n\
    \                case 'O' => res += 'o'\n                case 'P' => res += 'p'\n\
    \                case 'Q' => res += 'q'\n                case 'R' => res += 'r'\n\
    \                case 'S' => res += 's'\n                case 'T' => res += 't'\n\
    \                case 'U' => res += 'u'\n                case 'V' => res += 'v'\n\
    \                case 'W' => res += 'w'\n                case 'X' => res += 'x'\n\
    \                case 'Y' => res += 'y'\n                case 'Z' => res += 'z'\n\
    \                case 'a' => res += 'A'\n                case 'b' => res += 'B'\n\
    \                case 'c' => res += 'C'\n                case 'd' => res += 'D'\n\
    \                case 'e' => res += 'E'\n                case 'f' => res += 'F'\n\
    \                case 'g' => res += 'G'\n                case 'h' => res += 'H'\n\
    \                case 'i' => res += 'I'\n                case 'j' => res += 'J'\n\
    \                case 'k' => res += 'K'\n                case 'l' => res += 'L'\n\
    \                case 'm' => res += 'M'\n                case 'n' => res += 'N'\n\
    \                case 'o' => res += 'O'", "        // Write your code here\n \
    \       val chars = s.toCharArray\n        for (i <- 0 until chars.length) {\n\
    \            if (chars(i).isLetter) {\n                chars(i) = chars(i).toLower\n\
    \            }\n        }\n        new String(chars)", "        // Print output\
    \ to STDOUT\n        val len = s.length\n        var ans = \"\"\n        for (i\
    \ <- 0 until len) {\n            val c = s(i)\n            if (c.isLetter) {\n\
    \                if (c.isUpper) ans += c.toLower\n                else ans +=\
    \ c.toUpper\n            }\n            else ans += c\n        }\n        if (ans\
    \ == s) ans.reverse\n        else ans", "        // Write your code here\n   \
    \     // s.map(ch => if (ch.isLetter) ch.toUpper else ch.toLower).reverse\n  \
    \      if (s.isEmpty || !s.exists(_.isLetter))\n            return s.reverse\n\
    \        val newStr = s.map {\n            case ch: Char if ch.isUpper => ch.toLower\n\
    \            case ch: Char if ch.isLower => ch.toUpper\n            case ch: Char\
    \ => ch\n        }\n        newStr", "        if (s.toCharArray.exists(e => e.isLetter))\
    \ {\n            s.map(e => if (e.isLetter) e.toLower ^ 32 else e).reverse\n \
    \       } else {\n            s.reverse\n        }", '        return "";', " \
    \       val  isLetter = (c : Char) => c >= 'a' && c <= 'z' || c >= 'A' && c <=\
    \ 'Z'\n        val swapCase = (c : Char) => if (c >= 'a' && c <= 'z') c.toUpper\
    \ else c.toLower\n        if (s.exists(isLetter)) s.map(swapCase) else s.reverse",
  "        val swap = (ch: Char) => if(ch.isLetter) ch.toUpperCase else ch.toLowerCase\n\
    \        if(s.exists(_.isLetter)) s.map(swap) else s.reverse", "        def swap(c\
    \ : Char) : Char = if (c.isLetter) if (c.isUpper) c.toLower else c.toUpper else\
    \ c\n        s.map(swap).reverse", "        if (s.forall(c => !c.isLetter)) s.reverse\n\
    \        else s.map(c => if (c.isLetter) c.toLowerCase() else c.toUpperCase()).reverse",
  "        val chars = s.toCharArray\n        // create an array of booleans that\
    \ are true if the corresponding letter is upper case, \n        // false otherwise.\n\
    \        val isUpperCase = new Array[Boolean](chars.length)\n        var index\
    \ = 0\n        // iterate over the array of chars\n        for (char <- chars)\
    \ {\n            // check if it is a letter\n            if (char.isLetter) {\n\
    \                // if it is a letter, check whether it is uppercase\n       \
    \         isUpperCase(index) = char.isUpper\n                // flip the case\
    \ of the letter\n                chars(index) = char.toLower\n            }\n\
    \            index += 1\n        }\n        // iterate over the array of booleans\n\
    \        for (i <- 0 until isUpperCase.length) {\n            // if it is true,\
    \ transform the letter to uppercase\n            if (isUpperCase(i)) {\n     \
    \           chars(i) = chars(i).toUpper\n            }\n        }\n        //\
    \ create and return a new string from the array of chars\n        new String(chars)",
  "        val rev = s.reverse\n        val output = new StringBuilder\n        var\
    \ i = 0\n        while (i < rev.length) {\n            val c = rev(i)\n      \
    \      if (c.isLetter) output.append(if (c.isUpper) c.toLower else c.toUpper)\n\
    \            else output.append(c)\n            i += 1\n        }\n        output.toString",
  "        val letters = s.filter(ch => ch.isLetter)\n        if (letters.isEmpty)\
    \ s.reverse\n        else letters.map(ch => if (ch.isUpper) ch.toLower else ch.toUpper)",
  "        if (s.isEmpty) return \"\"\n        var a = new Array[Char](s.length)\n\
    \        for (i <- 0 until s.length) a(i) = s(i)\n        var maxIndex = 0\n \
    \       for (i <- 0 until s.length) if (Character.isLetter(s(i))) maxIndex = i\n\
    \        if (maxIndex == 0) return a.reverse.mkString\n        for (i <- 0 until\
    \ (maxIndex + 1) / 2) {\n            var temp = a(i)\n            a(i) = a(maxIndex\
    \ - i)\n            a(maxIndex - i) = temp\n        }\n        for (i <- 0 until\
    \ s.length) {\n            if (Character.isLowerCase(a(i))) a(i) = Character.toUpperCase(a(i))\n\
    \            else if (Character.isUpperCase(a(i))) a(i) = Character.toLowerCase(a(i))\n\
    \        }\n        a.mkString", "        // Write your code here\n        val\
    \ newStr = s.map(x => x match {\n            case _ if x.isLetter => if (x.isUpper)\
    \ x.toLower else x.toUpper\n            case _ => x\n        })\n        if (newStr.exists(x\
    \ => x.isLetter)) newStr else newStr.reverse", "        // let's do some string\n\
    \        var result : String = \"\"\n        var found : Boolean = false\n   \
    \     for (i <- 0 until s.length) {\n            if (s(i).isLetter) {\n      \
    \          found = true\n                if (s(i).isUpper) result += s(i).toLower\n\
    \                else result += s(i).toUpper\n            }\n            else\
    \ result += s(i)\n        }\n        if (found) result\n        else result.reverse",
  "      if (s.isEmpty()) return s\n      val char = s.head\n      val lower = char.isLower\n\
    \      val first = if (lower) char.toUpper else char.toLower\n      val rest =\
    \ s.tail\n      if (rest.isEmpty) return first.toString\n      else return first\
    \ + solve(rest)", "        if (s.exists(x => x.isLetter)) {\n            s.map(x\
    \ => if (x.isLetter) x.toUpper else x.toLower)\n        } else {\n           \
    \ s.reverse\n        }", "        // Write your code here\n        var t = s.toCharArray\n\
    \        val l = s.length\n        var l_flag = false\n        var r_flag = false\n\
    \        for (i <- 0 until l) {\n            if (t(i).isLetter) {\n          \
    \      l_flag = true\n                if (t(i).isUpper)\n                    t(i)\
    \ = t(i).toLower\n                else\n                    t(i) = t(i).toUpper\n\
    \            }\n        }\n        if (l_flag)\n            t.mkString\n     \
    \   else {\n            for (i <- 0 until l / 2) {\n                t(i) = t(l\
    \ - i - 1)\n            }\n            t.mkString\n        }", '        return
    s.reverse', "        var t = s.filter(c => c.isLetter)\n        var r = t.reverse\n\
    \        var ans = new StringBuilder\n        for (i <- 0 until s.length) {\n\
    \            if (s(i).isLetter) {\n                ans += r(0)\n             \
    \   r = r.substring(1)\n            } else {\n                ans += s(i)\n  \
    \          }\n        }\n        return ans.toString", "        if (s == \"\"\
    ) s\n        else if (s.exists(_.isLetter)) s.map(x => if (x.isLetter) x.toLower\
    \ ^ ('a' ^ 'A') else x)\n        else s.reverse", "        def swapCase(c : Char)\
    \ : Char = if (c.isLetter) c.toUpperCase ^ c.toLowerCase else c\n        s.map(swapCase(_)).reverse",
  '        return null', "        val str = s.filter(_.isLetter)\n        if (str.isEmpty)\
    \ s.reverse\n        else s.map(x => if (x.isUpper) x.toLower else x.toUpper)",
  "        val chs = s.toCharArray\n        val letters = chs.filter(_.isLetter)\n\
    \        if (letters.isEmpty) {\n            return chs.reverse.mkString\n   \
    \     }\n        for (i <- 0 until chs.length) {\n            if (chs(i).isLetter)\
    \ {\n                chs(i) = chs(i).toLower ^ ' '\n            }\n        }\n\
    \        return chs.mkString", "        val letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        var lettersMap = new HashMap[Char, Char]()\n        letters.zip(letters.reverse).foreach\
    \ {case (x, y) => lettersMap(x) = y}\n        s.reverse.map {x => if (letters.contains(x))\
    \ lettersMap(x) else x}", "    \tvar str = s.reverse\n    \tstr = str.map(c =>\
    \ \n    \t\tif (c.isUpper) c.toLower else c.toUpper)\n    \tstr", "        //\
    \ Write your code here\n        val l = s.toList\n        val r = l.map(x => x\
    \ match {\n            case c if ('a' <= c && c <= 'z') => c.toUpper\n       \
    \     case c if ('A' <= c && c <= 'Z') => c.toLower\n            case _ => x\n\
    \        })\n        val t = r.mkString(\"\")\n        if (s.matches(\"[^a-zA-Z]+\"\
    )) t.reverse else t", "        // Write your code here\n        null", '        s.map(c
    => if (c.isLetter) if (c.isUpper) c.toLower else c.toUpper else c).reverse', '        s.map(c
    => if (c.isLetter) c.toUpper else c.toLower).reverse', "        // your code goes\
    \ here\n        var a = s.toCharArray\n        var i = 0\n        var isOnlyDigits\
    \ = true\n        for (i <- 0 until a.length) {\n            if (a(i).isLetter)\
    \ {\n                isOnlyDigits = false\n                a(i) = a(i).toLower\n\
    \            }\n        }\n        if (isOnlyDigits) return s.reverse\n      \
    \  else {\n            var b = a.reverse\n            for (i <- 0 until b.length)\
    \ {\n                if (b(i).isLetter) {\n                    b(i) = b(i).toUpper\n\
    \                }\n            }\n            return b.mkString\n        }",
  "        var t = s.toList.map(c => if (c.isLetter) if (c.isUpper) c.toLower else\
    \ c.toUpper else c)\n        var k = t.filter(c => c.isLetter)\n        if (k.isEmpty)\
    \ {\n            t.reverse.mkString\n        } else {\n            t.mkString\n\
    \        }", "        var r = new StringBuilder\n        for (i <- 0 until s.length)\
    \ {\n            if (s(i).isLetter) {\n                if (s(i).isUpper) r.append(s(i).toLower)\n\
    \                else r.append(s(i).toUpper)\n            }\n            else\
    \ r.append(s(i))\n        }\n        var ret = r.toString\n        if (ret ==\
    \ s) ret = new StringBuilder(ret).reverse.toString\n        ret", "        if\
    \ (s.isEmpty) {\n            return s\n        }\n        var str = s\n      \
    \  var isLetter = false\n        for (i <- 0 until s.length) {\n            if\
    \ (s(i).isLetter) {\n                isLetter = true\n                break\n\
    \            }\n        }\n        if (!isLetter) {\n            return s.reverse\n\
    \        }\n        str = str.map(l => if (l.isUpper) l.toLower else l.toUpper)\n\
    \        str", "        var r = \"\"\n        for (i <- 0 until s.length) {\n\
    \            val c = s(i)\n            if (c >= 'a' && c <= 'z') r += (c - 32).toChar\n\
    \            else if (c >= 'A' && c <= 'Z') r += (c + 32).toChar\n           \
    \ else r += c\n        }\n        r", "        // Write your code here\n     \
    \   \"\"", "      if (s.isEmpty) return \"\"\n      val found = (s :\\ false)\
    \ {(x, b) => if (b) b else x.isLetter}\n      if (found) return s.map(x => if\
    \ (x.isLetter) if (x.isUpper) x.toLower else x.toUpper else x)\n      else return\
    \ s.reverse", "        //Write your code here\n        \"\"", "        if (s.isEmpty)\
    \ {\n            return \"\"\n        }\n        else if (s.forall(x => \"1234\"\
    .contains(x))) {\n            return s.reverse\n        }\n        else {\n  \
    \          return s.map(x => if (x.isUpper) x.toLower else x.toUpper)\n      \
    \  }", "        // startsWith and endsWith do not work with empty strings\n  \
    \      if (s.isEmpty) return \"\"\n        var lc = false\n        var uc = false\n\
    \        // This is a bit of a hack\n        var xs = List.empty[Char]\n     \
    \   s.foreach(x => xs = x :: xs)\n        xs = xs.reverse\n        var xs2 = List.empty[Char]\n\
    \        xs.foreach(x => {\n            x match {\n                case 'a' |\
    \ 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n'\
    \ | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' => lc\
    \ = true\n                case 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' |\
    \ 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U'\
    \ | 'V' | 'W' | 'X' | 'Y' | 'Z' => uc = true\n                case _ =>\n    \
    \        }\n            xs2 = x match {\n                case 'a' | 'b' | 'c'\
    \ | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p'\
    \ | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' => (x.toUpper).toChar\
    \ :: xs2\n                case 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' |\
    \ 'I", "        val containsLetters = s.exists(_.isLetter)\n        if (!containsLetters)\
    \ return s.reverse\n        s.map(c => if (c.isLetter) c.toUpper.toLower)", " \
    \       var t = s.reverse\n        var result = \"\"\n        for (i <- 0 until\
    \ t.length) {\n            if (t(i).isLetter) result += t(i).toUpper\n       \
    \     else result += t(i)\n        }\n        result", "        if (s.length()\
    \ == 0) s\n        else {\n            val t = new StringBuilder()\n         \
    \   for (i <- 0 until s.length()) {\n                if (s(i).isLetter) t.append(s(i).toLowerCase()\
    \ match {\n                    case 'a' => 'A'\n                    case 'b' =>\
    \ 'B'\n                    case 'c' => 'C'\n                    case 'd' => 'D'\n\
    \                    case 'e' => 'E'\n                    case 'f' => 'F'\n  \
    \                  case 'g' => 'G'\n                    case 'h' => 'H'\n    \
    \                case 'i' => 'I'\n                    case 'j' => 'J'\n      \
    \              case 'k' => 'K'\n                    case 'l' => 'L'\n        \
    \            case 'm' => 'M'\n                    case 'n' => 'N'\n          \
    \          case 'o' => 'O'\n                    case 'p' => 'P'\n            \
    \        case 'q' => 'Q'\n                    case 'r' => 'R'\n              \
    \      case 's' => 'S'\n                    case 't' => 'T'\n                \
    \    case 'u' => 'U'\n                    case 'v' => 'V'\n                  \
    \  case 'w' => 'W'\n                    case 'x' => 'X'\n                    case\
    \ 'y' => 'Y'\n                    case 'z' => 'Z'\n                    case 'A'\
    \ => 'a'\n                    case 'B' => 'b'\n                    case 'C' =>\
    \ 'c'\n                    case 'D' => 'd'\n                    case 'E' => 'e'\n\
    \                    case 'F' => 'f'\n                    case 'G' => 'g'\n  \
    \                  case 'H' => 'h'\n                    case 'I' => 'i'\n    \
    \                case 'J' => 'j'\n                    case 'K' => 'k'\n      \
    \              case 'L' => 'l'\n                    case 'M' => 'm'\n        \
    \            case 'N' => 'n'\n                    case 'O' => 'o'\n          \
    \          case 'P' => 'p'\n                    case 'Q' => 'q'\n            \
    \        case 'R' => 'r'\n                    case 'S' => 's", "        if (s.isEmpty)\
    \ return s\n        val l = s.length\n        var n = 0\n        for (i <- 0 until\
    \ l) {\n            if (s(i).isLetter) n += 1\n        }\n        if (n == 0)\
    \ return s.reverse\n        var isLower = new Array[Boolean](l)\n        for (i\
    \ <- 0 until l) {\n            if (s(i).isLetter) {\n                isLower(i)\
    \ = s(i).isLower\n            }\n        }\n        val builder = new StringBuilder\n\
    \        for (i <- 0 until l) {\n            if (s(i).isLetter) {\n          \
    \      if (isLower(i)) builder.append(s(i).toUpper)\n                else builder.append(s(i).toLower)\n\
    \            } else {\n                builder.append(s(i))\n            }\n \
    \       }\n        builder.toString", '        return s.reverse.map((c : Char)
    => if (c.isLetter) c.toUpper else c.toLower).mkString("")', "      def isLetter(x\
    \ : Char) : Boolean = {\n        if (x == 'a' || x == 'b' || x == 'c' || x ==\
    \ 'd' || x == 'e' || x == 'f' || x == 'g' || x == 'h' || x == 'i' || x == 'j'\
    \ || x == 'k' || x == 'l' || x == 'm' || x == 'n' || x == 'o' || x == 'p' || x\
    \ == 'q' || x == 'r' || x == 's' || x == 't' || x == 'u' || x == 'v' || x == 'w'\
    \ || x == 'x' || x == 'y' || x == 'z' || x == 'A' || x == 'B' || x == 'C' || x\
    \ == 'D' || x == 'E' || x == 'F' || x == 'G' || x == 'H' || x == 'I' || x == 'J'\
    \ || x == 'K' || x == 'L' || x == 'M' || x == 'N' || x == 'O' || x == 'P' || x\
    \ == 'Q' || x == 'R' || x == 'S' || x == 'T' || x == 'U' || x == 'V' || x == 'W'\
    \ || x == 'X' || x == 'Y' || x == 'Z') true else false\n      }\n      def flipLetter(x\
    \ : Char) : Char = {\n        if (x == 'a') 'A'\n        else if (x == 'b') 'B'\n\
    \        else if (x == 'c') 'C'\n        else if (x == 'd') 'D'\n        else\
    \ if (x == 'e') 'E'\n        else if (x == 'f') 'F'\n        else if (x == 'g')\
    \ 'G'\n        else if (x == 'h') 'H'\n        else if (x == 'i') 'I'\n      \
    \  else if (x == 'j') 'J'\n        else if (x == 'k') 'K'\n        else if (x\
    \ == 'l') 'L'\n        else if (x == '", '        return s.foldLeft("")((acc,
    c) => if(c.isLetter) acc + c.toUpper else acc + c.toLower)', "        // The solution\
    \ is here\n        var r = s.toCharArray.map { c =>\n            if (c.isLetter)\
    \ {\n                if (c.isUpper) c.toLower else c.toUpper\n            } else\
    \ c\n        }\n        if (r.forall(_.isLetter == false)) r.reverse\n       \
    \ else r.mkString", "        var has_letter = false\n        var result = \"\"\
    \n        s.foreach {c =>\n            if (c.isLetter) {\n                result\
    \ += c.toLower.toUpper\n                has_letter = true\n            } else\
    \ {\n                result += c\n            }\n        }\n        if (has_letter)\
    \ result else s.reverse", "        // Your code here\n        return s", "   \
    \     if (s.filter(c => c.isLetter).isEmpty)\n            s.reverse\n        else\n\
    \            s.map(c => if (c.isLetter) c.toLower ^ c.toUpper else c)", "    \
    \    if (s.isEmpty) return \"\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val capitals = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        val sb = new\
    \ StringBuilder\n        val array = s.toCharArray\n        for (i <- 0 until\
    \ array.length) {\n            if (alphabet.contains(array(i))) sb.append(capitals(alphabet.indexOf(array(i))))\n\
    \            else if (capitals.contains(array(i))) sb.append(alphabet(capitals.indexOf(array(i))))\n\
    \            else sb.append(array(i))\n        }\n        sb.toString", "    \
    \    if (s.exists(x => x.isLetter)) {\n            s.map(x => if (x.isLetter)\
    \ x.toUpper ^ x.toLower else x)\n        } else {\n            s.reverse\n   \
    \     }", "        // Write your code here\n        return \"\"", "        var\
    \ n = s.length\n        var result = \"\"\n        for (i <- 0 until n) {\n  \
    \          if (s(i).isLetter) {\n                result += s(i).toUpper\n    \
    \        } else {\n                result += s(i)\n            }\n        }\n\
    \        if (result.toLowerCase.equals(result)) {\n            s.reverse\n   \
    \     } else {\n            result\n        }", "        val first = s.find(_.isLetter)\n\
    \        val (left, right) = s.span(!_.isLetter)\n        if (first.isEmpty) right.reverse\
    \ + left else left + right.reverse", "        val input = s.toCharArray\n    \
    \    var result = new String\n        var hasChar = false\n        var hasNonChar\
    \ = false\n        for (i <- 0 until input.length) {\n            if (input(i).isLetter)\
    \ {\n                hasChar = true\n                result += input(i).toUpper.toString\n\
    \            } else {\n                hasNonChar = true\n                result\
    \ += input(i).toLower.toString\n            }\n        }\n        if (hasChar\
    \ && hasNonChar) {\n            result\n        } else {\n            result.reverse\n\
    \        }", "        val nums = s.split(\"\").filter(_.matches(\"\"\"\\d\"\"\"\
    ))\n        val letters = s.split(\"\").filter(_.matches(\"\"\"[a-zA-Z]\"\"\"\
    ))\n        if (letters.length == 0) nums.reverse.mkString\n        else letters.map(x\
    \ => if (x.matches(\"\"\"[a-z]\"\"\")) x.toUpperCase else x.toLowerCase).mkString",
  "        val letters = s.filter(i => i.isLetter)\n        if (letters.isEmpty) return\
    \ s.reverse\n        var result = letters.map(c => if (c.isUpper) c.toLower else\
    \ c.toUpper)\n        for (i <- 0 until s.length) {\n            if (s(i).isLetter)\
    \ {\n                result += s(i)\n            } else {\n                result\
    \ = result.updated(i, s(i))\n            }\n        }\n        result", "    \
    \    var reversed : String = \"\"\n        for (c <- s) {\n            if (c.isLetter)\
    \ {\n                reversed += c.toUpper ^ c.toLower\n            } else {\n\
    \                reversed += c\n            }\n        }\n        return reversed.reverse",
  '        ???', "        if (s.length == 0) s\n        else {\n            val sb\
    \ = new StringBuilder\n            var letter = false\n            for (i <- 0\
    \ until s.length) {\n                val c = s(i)\n                if (c.isLetter)\
    \ {\n                    letter = true\n                    sb.append(if (c.isUpper)\
    \ c.toLower else c.toUpper)\n                }\n                else sb.append(c)\n\
    \            }\n            if (letter) sb.toString\n            else sb.reverse.toString\n\
    \        }", "        val t = for (c <- s.toCharArray()) yield {\n           \
    \ c match {\n                case 'a' => 'A'\n                case 'b' => 'B'\n\
    \                case 'c' => 'C'\n                case 'd' => 'D'\n          \
    \      case 'e' => 'E'\n                case 'f' => 'F'\n                case\
    \ 'g' => 'G'\n                case 'h' => 'H'\n                case 'i' => 'I'\n\
    \                case 'j' => 'J'\n                case 'k' => 'K'\n          \
    \      case 'l' => 'L'\n                case 'm' => 'M'\n                case\
    \ 'n' => 'N'\n                case 'o' => 'O'\n                case 'p' => 'P'\n\
    \                case 'q' => 'Q'\n                case 'r' => 'R'\n          \
    \      case 's' => 'S'\n                case 't' => 'T'\n                case\
    \ 'u' => 'U'\n                case 'v' => 'V'\n                case 'w' => 'W'\n\
    \                case 'x' => 'X'\n                case 'y' => 'Y'\n          \
    \      case 'z' => 'Z'\n                case 'A' => 'a'\n                case\
    \ 'B' => 'b'\n                case 'C' => 'c'\n                case 'D' => 'd'\n\
    \                case 'E' => 'e'\n                case 'F' => 'f'\n          \
    \      case 'G' => 'g'\n                case 'H' => 'h'\n                case\
    \ 'I' => 'i'\n                case 'J' => 'j'\n                case 'K' => 'k'\n\
    \                case 'L' => 'l'\n                case 'M' => 'm'\n          \
    \      case 'N' => 'n'\n                case 'O' => 'o'\n                case\
    \ 'P' => 'p'\n                case 'Q' => 'q'\n                case 'R' => 'r'\n\
    \                case 'S' => 's'\n                case 'T' => 't'\n          \
    \      case 'U' => 'u'\n                case 'V' => 'v'\n                case\
    \ 'W' => 'w'", "        var b = false\n        val sb = new StringBuilder\n  \
    \      for (i <- 0 until s.length) {\n            if (Character.isLetter(s(i)))\
    \ {\n                b = true\n                sb.append(if (Character.isUpperCase(s(i)))\
    \ Character.toLowerCase(s(i)) else Character.toUpperCase(s(i)))\n            }\
    \ else sb.append(s(i))\n        }\n        if (b) sb.toString else sb.reverse.toString",
  "        var result = \"\"\n        for (c <- s) {\n            if (c.isLetter)\
    \ {\n                if (c.isUpper) result += c.toLower\n                else\
    \ result += c.toUpper\n            }\n            else result += c\n        }\n\
    \        if (result == s) result.reverse\n        else result", "    \tvar new_s\
    \ = \"\"\n    \tvar has_letter = false\n    \tfor (i <- 0 until s.length) {\n\
    \    \t\tif (s(i).isLetter) {\n    \t\t\thas_letter = true\n    \t\t\tif (s(i).isUpper)\
    \ {\n    \t\t\t\tnew_s += s(i).toLower\n    \t\t\t} else {\n    \t\t\t\tnew_s\
    \ += s(i).toUpper\n    \t\t\t}\n    \t\t} else {\n    \t\t\tnew_s += s(i)\n  \
    \  \t\t}\n    \t}\n    \tif (has_letter) new_s.reverse else new_s", "        var\
    \ sLower = s.toLowerCase\n        var sUpper = s.toUpperCase\n        var result\
    \ = \"\"\n        for (i <- 0 until s.length) {\n            if (sLower(i) ==\
    \ s(i)) result += sUpper(i)\n            else result += sLower(i)\n        }\n\
    \        return result", "        if (s.map(x => if ('a' <= x && x <= 'z') 1 else\
    \ 0).sum == 0)\n            s.reverse\n        else\n            s.map(x => if\
    \ ('a' <= x && x <= 'z') x.toUpper else if ('A' <= x && x <= 'Z') x.toLower else\
    \ x)", "    \ts.map(c => \n    \t    if (c.isLetter) c.toLower\n    \t    else\
    \ c.toUpper).reverse", "        val chars = s.toList\n        if (chars.forall(c\
    \ => !c.isLetter))\n            chars.reverse.mkString\n        else\n       \
    \     chars.map(c => if (c.isLetter) c.toUpper.toLower else c).mkString", '      ???',
  "        val letters = ('a' to 'z') ++ ('A' to 'Z')\n        val res = new StringBuilder\n\
    \        for (i <- 0 until s.length) {\n            if (letters.contains(s(i)))\
    \ {\n                if (s(i).isUpper) res += s(i).toLower\n                else\
    \ res += s(i).toUpper\n            }\n            else res += s(i)\n        }\n\
    \        res.toString.reverse", "    \t\tif (s.length == 0) return s\n    \t\t\
    val a = s.toCharArray\n    \t\tval l = a.length\n    \t\tif (a.forall(x => ! x.isLetter))\
    \ return s.reverse\n    \t\telse {\n    \t\t    for (i <- 0 until l) {\n    \t\
    \t        if (a(i).isLetter) {\n    \t\t            if (a(i).isUpper) a(i) = a(i).toLower\n\
    \    \t\t            else a(i) = a(i).toUpper\n    \t\t        }\n    \t\t   \
    \ }\n    \t\t    return a.mkString\n    \t\t}", "        val r : StringBuilder\
    \ = new StringBuilder()\n        var containsLetter : Boolean = false\n      \
    \  for (i <- 0 until s.length) {\n            if (s(i).isLetter) {\n         \
    \       containsLetter = true\n                r.append(s(i).toUpper)\n      \
    \      } else {\n                r.append(s(i))\n            }\n        }\n  \
    \      if (containsLetter) return r.toString\n        else return r.reverse.toString",
  "        // Your code here\n        return null;", "        def swapCase(c : Char)\
    \ : Char = if(c.isLetter) if(c.isUpper) c.toLower else c.toUpper else c\n    \
    \    val str = s.toList.map(swapCase(_))\n        if(str.count(_.isLetter) ==\
    \ 0) str.reverse.mkString else str.mkString", "        val b = new StringBuilder()\n\
    \        for (c <- s) {\n            if (c.isLetter) {\n                if (c.isUpper)\
    \ {\n                    b.append(c.toLower)\n                } else {\n     \
    \               b.append(c.toUpper)\n                }\n            } else {\n\
    \                b.append(c)\n            }\n        }\n        val r = b.toString\n\
    \        if (r.matches(\"[a-zA-Z]+\")) {\n            r.reverse\n        } else\
    \ {\n            r\n        }", "        var count = 0\n        for (i <- 0 until\
    \ s.length()) {\n            if (s(i).isLetter) count += 1\n        }\n      \
    \  if (count == 0) return s.reverse\n        var ns = \"\"\n        for (i <-\
    \ 0 until s.length()) {\n            if (s(i).isLetter) {\n                if\
    \ (s(i).isUpper) ns += s(i).toLower\n                else ns += s(i).toUpper\n\
    \            }\n            else ns += s(i)\n        }\n        return ns", " \
    \       if (s.exists(x => x.isLetter)) {\n            var res = \"\"\n       \
    \     for (c <- s)\n                if (c.isLetter)\n                    res +=\
    \ c.toLowerCase + c.toUpperCase - c\n                else\n                  \
    \  res += c\n            res\n        }\n        else {\n            s.reverse\n\
    \        }", "        val chars = s.toCharArray\n        val containsLetters =\
    \ s.exists(c => c.isLetter)\n        val res = chars.map(c => if(c.isLetter) c.toUpper.toLower\
    \ else c)\n        if(containsLetters) res.reverse.mkString\n        else s.reverse",
  "        // Fill up this function body\n        // 'a' - 'z' = 97 - 122\n      \
    \  // 'A' - 'Z' = 65 - 90\n        // '0' - '9' = 48 - 57\n        val buf = new\
    \ StringBuilder\n        for (c <- s) buf += ((if (c >= 'a' && c <= 'z') c - 32\
    \ else if (c >= 'A' && c <= 'Z') c + 32 else c).toChar)\n        if (buf.toString.find(c\
    \ => c >= 'a' && c <= 'z').isEmpty) buf.reverse.toString else buf.toString", " \
    \       val letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        if (s.exists(ch => letters.contains(ch))) {\n            s.map(ch =>\
    \ if (letters.contains(ch)) (if (ch.isUpper) ch.toLower else ch.toUpper) else\
    \ ch).mkString\n        } else {\n            s.reverse\n        }", "       \
    \ // Write your code here\n        //   retur", "        val letters = s.filter(isLetter)\n\
    \        if (letters.isEmpty) s.reverse\n        else s.map(x => if (isLetter(x))\
    \ x.toUpper.toLower else x.toUpper.toLower)", "        var ret = \"\"\n      \
    \  if (s.count(c => c.isLetter) == 0) {\n            ret = s.reverse\n       \
    \ } else {\n            for (c <- s) {\n                if (c.isLetter) {\n  \
    \                  ret += c.toUpperCase\n                } else {\n          \
    \          ret += c\n                }\n            }\n        }\n        ret",
  "        var str = s.toCharArray\n        var found = false\n        for (i <- 0\
    \ until str.length) {\n            if (str(i).isLetter) {\n                str(i)\
    \ = str(i).toLower\n                found = true\n            }\n        }\n \
    \       var res = new String(str)\n        if (found) {\n            res = res.reverse\n\
    \            str = res.toCharArray\n            for (i <- 0 until str.length)\
    \ {\n                if (str(i).isLetter) str(i) = str(i).toUpper\n          \
    \  }\n            res = new String(str)\n        }\n        res", "        if\
    \ (s.isEmpty) return s\n        var rev = \"\"\n        if (s.toUpperCase != s.toLowerCase)\n\
    \            for (x <- s) rev = x.toString() + rev\n        else rev = s.reverse\n\
    \        return rev", "        if (s.matches(\"[A-Za-z]+\")) {\n            s.map(char\
    \ => if (char.isUpper) char.toLower else char.toUpper)\n        } else {\n   \
    \         s.reverse\n        }", "        val sb = new StringBuilder\n       \
    \ val indexes = new ArrayBuffer[Int]\n        for (i <- 0 until s.length) {\n\
    \            if (s(i).isLetter) indexes += i\n        }\n        if (indexes.length\
    \ == 0) {\n            return s.reverse\n        }\n        val start = indexes.head\n\
    \        val end = indexes.last\n        for (i <- 0 until s.length) {\n     \
    \       if (i < start || i > end) {\n                sb += s(i)\n            }\
    \ else {\n                sb += s(end - (i - start))\n            }\n        }\n\
    \        sb.toString", "        if (s.isEmpty) {\n            s\n        } else\
    \ {\n            if (s.filter(c => c.isLetter).isEmpty) {\n                s.reverse\n\
    \            } else {\n                s.map(c => if (c.isLetter) c.toUpper.toLower\
    \ else c)\n            }\n        }", "        var ans = \"\"\n        for (x\
    \ <- s) {\n            if (x.isLetter) {\n                if (x.isUpper) ans +=\
    \ x.toLower\n                else ans += x.toUpper\n            }\n          \
    \  else ans += x\n        }\n        if (ans.forall(!_.isLetter)) ans.reverse\n\
    \        else ans", "        val chars = s.toCharArray\n        if (chars.map(isLetter(_)).foldLeft(false)(_\
    \ || _)) {\n            chars.map(c => if (isLetter(c)) if (isUpper(c)) toLower(c)\
    \ else toUpper(c) else c).mkString\n        } else {\n            chars.reverse.mkString\n\
    \        }", "    \tif (s.isEmpty) return \"\"\n    \tval sb = new StringBuilder\n\
    \    \tvar allCaps = true\n    \tfor (c <- s) {\n    \t\tif (c.isUpper) allCaps\
    \ = false\n    \t\tsb.append(c)\n    \t}\n    \tif (allCaps) return sb.reverse.toString\n\
    \    \tsb.reverse.toString.map(c => if (c.isUpper) c.toLower else c.toUpper)",
  "        val nonLetters = s.toList.filterNot(c => c.isLetter)\n        val letters\
    \ = s.toList.filter(c => c.isLetter)\n        if (letters.isEmpty) {\n       \
    \     s.reverse\n        } else {\n            (nonLetters ++ letters.map(c =>\
    \ if (c.isUpper) c.toLower else c.toUpper)).mkString\n        }", "        if\
    \ (!s.exists(c => c.isLetter)) s.reverse\n        else s.map(c => if (c.isLetter)\
    \ c.toUpper ^ c.toLower else c)", "        if (s.forall(!_.isLetter)) return s.reverse\n\
    \        val sb = new StringBuilder()\n        for (c <- s) {\n            c match\
    \ {\n                case c if c.isLetter && c.isUpper => sb.append(c.toLower)\n\
    \                case c if c.isLetter && c.isLower => sb.append(c.toUpper)\n \
    \               case _ => sb.append(c)\n            }\n        }\n        sb.toString",
  "        // Write your code here\n        // return \"\"\n        val onlyLetters\
    \ = s.toCharArray.filter(c => c.isLetter)\n        val revOnlyLetters = onlyLetters.reverse\n\
    \        for (i <- 0 until s.length) {\n            if (s(i).isLetter) {\n   \
    \             s(i) = revOnlyLetters(i)\n            }\n        }\n        s",
  "        val build = new StringBuilder\n        var foundLetter = false\n      \
    \  for (c <- s) {\n            if (c.isLetter) {\n                foundLetter\
    \ = true\n                if (c.isUpper) build += c.toLower\n                else\
    \ build += c.toUpper\n            }\n            else build += c\n        }\n\
    \        if (foundLetter) build.toString\n        else build.reverse.toString",
  '        if (s.count(Character.isLetter(_)) == 0) s.reverse else s.map(x => if (Character.isLetter(x))
    Character.toLowerCase(x) else Character.toUpperCase(x))', "        var result\
    \ = \"\"\n        var nonAlphachar = true\n        for (c <- s) {\n          \
    \  if (c.isLetter) {\n                nonAlphachar = false\n                result\
    \ += c.toUpper\n            } else {\n                result += c\n          \
    \  }\n        }\n        if (nonAlphachar) result = s.reverse\n        return\
    \ result", "        // your code here\n        \"string\"", "        // we need\
    \ to check if the string is empty first\n        if (s.length == 0) return s\n\
    \        // init new stringbuilder\n        val builder = new StringBuilder()\n\
    \        // iterate through s\n        for (i <- 0 until s.length) {\n       \
    \     // if the character is a letter \n            if (s(i).isLetter) {\n   \
    \             // append the character in opposite case\n                builder.append(s(i).toLowerCase)\n\
    \            } else {\n                // append the character\n             \
    \   builder.append(s(i))\n            }\n        }\n        // return the reverse\
    \ string\n        builder.reverse.toString", "        val x = for (char <- s)\
    \ yield if (char.isLetter) if (char.isUpper) char.toLower else char.toUpper else\
    \ char\n        return x.mkString", "        // set toList to fix \"Cannot mutate\
    \ immutable value\" error\n        val sList = s.toList\n        var noLetter\
    \ = true\n        var result = \"\"\n        for (i <- 0 until sList.length) {\n\
    \            if (sList(i).isLetter) {\n                noLetter = false\n    \
    \            if (sList(i).isUpper) result += sList(i).toLower\n              \
    \  else result += sList(i).toUpper\n            }\n            else result +=\
    \ sList(i)\n        }\n        if (noLetter) result = s.reverse\n        result",
  "        // Write your code here\n        s", "        // Write your code here\n\
    \        var result = \"\"\n        if (s.exists(_.isLetter)) {\n            for\
    \ (i <- 0 until s.length) {\n                if (s(i).isLetter) {\n          \
    \          if (s(i).isUpper) result += s(i).toLower\n                    else\
    \ result += s(i).toUpper\n                }\n                else result += s(i)\n\
    \            }\n        }\n        else {\n            result = s.reverse\n  \
    \      }\n        result", "        var result = \"\"\n        if (s.filter(c\
    \ => c.isLetter).length == 0) {\n            result = s.reverse\n        } else\
    \ {\n            result = s.map(c => if (c.isLetter) if (c.isUpper) c.toLower\
    \ else c.toUpper else c)\n        }\n        result", "        val reverse = (s.filter(c\
    \ => c.isLetter).map(c => if (c.isUpper) c.toLower else c.toUpper))\n        if\
    \ (reverse.isEmpty) s.reverse else reverse"]
stop_tokens:
- "\n    }\n"
