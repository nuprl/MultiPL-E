name: HumanEval_158_find_max
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that accepts a list of strings.\n    // The list contains\
  \ different words. Return the word with maximum number\n    // of unique characters.\
  \ If multiple strings have maximum number of unique\n    // characters, return the\
  \ one which comes first in lexicographical order.\n    // >>> findMax((List[String](\"\
  name\", \"of\", \"string\")))\n    // (\"string\")\n    // >>> findMax((List[String](\"\
  name\", \"enam\", \"game\")))\n    // (\"enam\")\n    // >>> findMax((List[String](\"\
  aaaaaaa\", \"bb\", \"cc\")))\n    // (\"aaaaaaa\")\n    def findMax(words : List[String])\
  \ : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(findMax((List[String](\"\
  name\", \"of\", \"string\"))).equals((\"string\")));\n    assert(findMax((List[String](\"\
  name\", \"enam\", \"game\"))).equals((\"enam\")));\n    assert(findMax((List[String](\"\
  aaaaaaa\", \"bb\", \"cc\"))).equals((\"aaaaaaa\")));\n    assert(findMax((List[String](\"\
  abc\", \"cba\"))).equals((\"abc\")));\n    assert(findMax((List[String](\"play\"\
  , \"this\", \"game\", \"of\", \"footbott\"))).equals((\"footbott\")));\n    assert(findMax((List[String](\"\
  we\", \"are\", \"gonna\", \"rock\"))).equals((\"gonna\")));\n    assert(findMax((List[String](\"\
  we\", \"are\", \"a\", \"mad\", \"nation\"))).equals((\"nation\")));\n    assert(findMax((List[String](\"\
  this\", \"is\", \"a\", \"prrk\"))).equals((\"this\")));\n    assert(findMax((List[String](\"\
  b\"))).equals((\"b\")));\n    assert(findMax((List[String](\"play\", \"play\", \"\
  play\"))).equals((\"play\")));\n    }\n\n}\n"
completions: ["        var dict = Map[String, Int]()\n        var res = \"\"\n   \
    \     for (word <- words) {\n            var unique = Set[Char]()\n          \
    \  for (ch <- word) {\n                unique += ch\n            }\n         \
    \   dict += (word -> unique.size)\n        }\n        var max = 0\n        for\
    \ ((k, v) <- dict) {\n            if (v > max) {\n                max = v\n  \
    \              res = k\n            }\n        }\n        return res", "     \
    \   var max_word = \"\"\n        var max_cnt = 0\n        for (word <- words)\
    \ {\n            val tmp = word.toSet.size\n            if (tmp > max_cnt) {\n\
    \                max_cnt = tmp\n                max_word = word\n            }\n\
    \        }\n        max_word", "        if (words.length == 0) return null\n \
    \       var max = words(0)\n        for (word <- words) {\n            if (word.length\
    \ > max.length) max = word\n            else if (word.length == max.length) if\
    \ (word < max) max = word\n        }\n        return max", "        var ans =\
    \ \"\";\n        var count = 0;\n        for (word <- words) {\n            val\
    \ unique = uniqueCharacters(word);\n            if (unique.size > count) {\n \
    \               ans = word;\n                count = unique.size;\n          \
    \  }\n        }\n        return ans;", "        var maxWord = \"\";\n        var\
    \ maxUnique = 0;\n        for (word <- words) {\n            val unique = word.groupBy(identity).size;\n\
    \            if (unique > maxUnique) {\n                maxUnique = unique;\n\
    \                maxWord = word;\n            }\n        }\n        return maxWord;",
  "        val a = for (word <- words) yield (word, word.toSet.size)\n        val\
    \ b = a.sortWith((i, j) => i._2 > j._2 || (i._2 == j._2 && i._1 < j._1))\n   \
    \     b.head._1", '        return words.maxBy(word => word.toSet.size)', "   \
    \     var best = words(0)\n        var max = 0\n        for (word <- words) {\n\
    \            val set = word.toSet\n            if (set.size > max) {\n       \
    \         max = set.size\n                best = word\n            }\n       \
    \ }\n        best", "        // Use a hash to store the frequency of each char.\n\
    \        // This can be implemented as a mutable map or a immutable map,\n   \
    \     // or even an array.\n        var best = words(0)\n        var bestSize\
    \ = best.distinct.size\n        for (w <- words.tail) {\n            val size\
    \ = w.distinct.size\n            if (size > bestSize) {\n                best\
    \ = w\n                bestSize = size\n            }\n        }\n        best",
  "        def count(s : String) : Int = {\n            var c = 0\n            for\
    \ (c1 <- 'a' to 'z')\n                if (s.indexOf(c1) >= 0) c += 1\n       \
    \     c\n        }\n        var mx = 0\n        var index = 0\n        for (i\
    \ <- 0 until words.length) {\n            val s = words(i)\n            val x\
    \ = count(s)\n            if (x > mx) {\n                mx = x\n            \
    \    index = i\n            }\n        }\n        words(index)", "      var current\
    \ = \"\"\n      var currentSet = Set[Char]()\n      var max = \"\"\n      var\
    \ maxSet = Set[Char]()\n      for (word <- words) {\n        current = word\n\
    \        currentSet = current.toSet\n        if (currentSet.size > maxSet.size)\
    \ {\n          max = current\n          maxSet = currentSet\n        }\n     \
    \   else if (currentSet.size == maxSet.size) {\n          max = if (max > current)\
    \ max else current\n        }\n      }\n      max", "        var max = 0\n   \
    \     var index = 0\n        for (i <- 0 until words.length) {\n            val\
    \ cnt = words(i).toSet.size\n            if (cnt > max) {\n                max\
    \ = cnt\n                index = i\n            }\n        }\n        words(index)",
  "        // Your code here\n        return \"\"", "        var chars = new HashMap[Char,\
    \ Int]\n        var answer = \"\"\n        var max = 0\n        var result = 0\n\
    \        for (word <- words) {\n            for (c <- word) {\n              \
    \  if (chars.contains(c)) {\n                    chars(c) += 1\n             \
    \   } else {\n                    chars(c) = 1\n                }\n          \
    \  }\n            for (c <- chars.keySet) {\n                if (chars(c) == 1)\
    \ {\n                    result += 1\n                }\n            }\n     \
    \       if (result > max) {\n                max = result\n                answer\
    \ = word\n            } else if (result == max) {\n                if (word <\
    \ answer) {\n                    answer = word\n                }\n          \
    \  }\n            result = 0\n            chars.clear\n        }\n        answer",
  "        def findMax0(max : String, words : List[String]) : String = {\n       \
    \     if (words.isEmpty) max\n            else {\n                val max1 = if\
    \ (words.head.distinct.length > max.distinct.length) words.head else max\n   \
    \             findMax0(max1, words.tail)\n            }\n        }\n        findMax0(words.head,\
    \ words.tail)", "        var max = (\"\", Set[Char]())\n        for (word <- words)\
    \ {\n            var set = Set[Char]()\n            for (c <- word) set += c\n\
    \            if (set.size > max._2.size) max = (word, set)\n            else if\
    \ (set.size == max._2.size && word < max._1) max = (word, set)\n        }\n  \
    \      max._1", "        val sorted = words.sortWith(_.length < _.length)\n  \
    \      for (i <- sorted.indices) {\n            val temp = sorted(i)\n       \
    \     if (sorted.exists(temp.length < _.length))\n                return temp\n\
    \        }\n        return \"\"", "        var map = Map[String, Int]()\n    \
    \    for (word <- words) {\n            map(word) = word.distinct.length\n   \
    \     }\n        return map.maxBy(_._2)._1", '        return words.minBy(x =>
    (x.length, x))', "        var result = \"\"\n        var max = -1\n        words.foreach(word\
    \ => {\n            val currentUnique = word.groupBy(x => x).keys.size\n     \
    \       if (currentUnique > max) {\n                max = currentUnique\n    \
    \            result = word\n            }\n        })\n        result", '        words.foldLeft("")((m,
    x) => if (m.length < x.length) x else m)', "        // Define an ordering on strings\
    \ by their maximum number of unique\n        // characters.\n        val o = Ordering.by((s\
    \ : String) => s.toSet.size)\n        // Apply this ordering to each string in\
    \ the list of words, sorting\n        // them in increasing order according to\
    \ their maximum number of unique\n        // characters.\n        val wordsSorted\
    \ = words.sorted(o)\n        // Since the list is sorted, the maximum number of\
    \ unique characters\n        // is attained by the last element in the list, and\
    \ any words tied for\n        // maximum number of unique characters are adjacent\
    \ to it.\n        // We filter these words, leaving only the one which comes first\
    \ in\n        // lexicographical order.\n        wordsSorted.filter((s : String)\
    \ => s.toSet.size == wordsSorted.last.toSet.size).head", "        val characters\
    \ = words.map(w => w.toSet)\n        val max = characters.map(s => s.size).max\n\
    \        characters.zip(words).filter(_._1.size == max).map(_._2).sortWith(_ <\
    \ _).head", "        var uniqueMax = -1\n        var uniqueWord = \"\"\n     \
    \   words.foreach(word => {\n            var uniqueCount = 0\n            word.foreach(char\
    \ => {\n                if (word.count(_ == char) == 1) uniqueCount += 1\n   \
    \         })\n            if (uniqueCount > uniqueMax) {\n                uniqueMax\
    \ = uniqueCount\n                uniqueWord = word\n            }\n        })\n\
    \        uniqueWord", "        // Your code here!\n        if (words.isEmpty)\
    \ return \"\"\n        else {\n            var word = words.head\n           \
    \ var word_char_count = words.head.toSet.size\n            for (w <- words) {\n\
    \                val char_count = w.toSet.size\n                if (char_count\
    \ > word_char_count) {\n                    word = w\n                    word_char_count\
    \ = char_count\n                }\n                else if (char_count == word_char_count)\
    \ {\n                    if (w < word) word = w\n                }\n         \
    \   }\n            return word\n        }", "        var dict = Map[String, List[String]]()\n\
    \        for (word <- words) {\n            var value = word.toSet.toList.sorted\n\
    \            if (dict.contains(value.mkString)) dict(value.mkString) = dict(value.mkString)\
    \ :+ word\n            else dict += (value.mkString -> List(word))\n        }\n\
    \        var max = 0\n        var result = \"\"\n        for (word <- words) {\n\
    \            var value = word.toSet.toList.sorted\n            if (value.length\
    \ > max) {\n                max = value.length\n                result = word\n\
    \            }\n        }\n        dict(result.toSet.toList.sorted.mkString).sorted.head",
  '        words.sortWith((a, b) => (f(a) > f(b)) || ((f(a) == f(b)) && (a < b))).head',
  '        words.sortWith((a, b) => a.length > b.length).filter(word => word.length
    == words.map(word => word.length).max).sortWith((a, b) => a < b).head', "    \
    \    var maxLen = 0\n        var maxWord = \"\"\n        for (w <- words) {\n\
    \            val len = w.toSet.size\n            if (len > maxLen) {\n       \
    \         maxLen = len\n                maxWord = w\n            }\n        }\n\
    \        maxWord", "        val map = new HashMap[String, Set[Char]]\n       \
    \ words.foreach {s =>\n            val chars = s.toSet\n            map(s) = chars\n\
    \        }\n        var max = map(words(0)).size\n        words.foreach {word\
    \ =>\n            val size = map(word).size\n            if (size > max) {\n \
    \               max = size\n            }\n        }\n        var min = map(words(0))\n\
    \        words.foreach {word =>\n            val chars = map(word)\n         \
    \   if (chars.size == max && chars < min) {\n                min = chars\n   \
    \         }\n        }\n        words.find(map(_) == min).get", "        var maxWord\
    \ = words(0)\n        var max = countDistinctChars(words(0))\n        for (i <-\
    \ 1 until words.length) {\n            val cur = countDistinctChars(words(i))\n\
    \            if (cur > max) {\n                max = cur\n                maxWord\
    \ = words(i)\n            }\n        }\n        maxWord", "        var maxWord\
    \ = \"\"\n        var maxNum = 0\n        for (word <- words) {\n            val\
    \ num = (word.toSet).size\n            if (num > maxNum) {\n                maxNum\
    \ = num\n                maxWord = word\n            }\n        }\n        maxWord",
  "        val s = words.map(s => (s, s.toSet.size)).sortWith(_._2 > _._2)\n     \
    \   s.head._1", "        var maxLen = 0\n        var maxWord = \"\"\n        for\
    \ (word <- words) {\n            val uniqueChars = word.toSet\n            if\
    \ (uniqueChars.size > maxLen) {\n                maxLen = uniqueChars.size\n \
    \               maxWord = word\n            }\n        }\n        maxWord", " \
    \     val res = words.map(word => (word, word.toSet.size)).sortWith((a, b) =>\
    \ a._2 > b._2 || (a._2 == b._2 && a._1 < b._1))\n      return res.head._1", " \
    \       if (words.isEmpty) \"\"\n        else words.sortWith((x, y) => x.length\
    \ > y.length || (x.length == y.length && x.compareTo(y) < 0)).head", '        words.maxBy(word
    => word.toSet.size)', "        val wordCount = words.map(x => (x, x.toSet.size)).sortBy(x\
    \ => (x._2, x._1))\n        wordCount.reverse.head._1", '        words.maxBy(w
    => w.toSet.size)', "        // Hint: How do you find the maximum number in a list?\n\
    \        def findMaxUnique(words : List[String]) : Int = {\n            var list\
    \ = new ListBuffer[Int]()\n            for (i <- 0 until words.length) {\n   \
    \             var number = 0\n                var unique = new ListBuffer[Char]()\n\
    \                for (j <- 0 until words(i).length) {\n                    var\
    \ c = words(i)(j)\n                    if (!unique.contains(c)) {\n          \
    \              unique += c\n                        number += 1\n            \
    \        }\n                }\n                list += number\n            }\n\
    \            return list.max\n        }\n        var result = \"\"\n        var\
    \ max = findMaxUnique(words)\n        for (i <- 0 until words.length) {\n    \
    \        var number = 0\n            var unique = new ListBuffer[Char]()\n   \
    \         for (j <- 0 until words(i).length) {\n                var c = words(i)(j)\n\
    \                if (!unique.contains(c)) {\n                    unique += c\n\
    \                    number += 1\n                }\n            }\n         \
    \   if (number == max) {\n                result = words(i)\n                break\n\
    \            }\n        }\n        return result", "        var best = \"\"\n\
    \        for (w <- words) {\n            if (best == \"\" || w.distinct.length\
    \ > best.distinct.length ||\n                    (w.distinct.length == best.distinct.length\
    \ && w < best)) {\n                best = w\n            }\n        }\n      \
    \  best", "        if (words.length == 0) return \"\"\n        var max = words(0)\n\
    \        var maxSet : Set[Char] = Set()\n        for (word <- words) {\n     \
    \       val set = word.toSet\n            if (set.size > maxSet.size) {\n    \
    \            max = word\n                maxSet = set\n            }\n       \
    \ }\n        return max", "        val sizes = for(word <- words) yield (word,\
    \ word.groupBy(identity).size)\n        sizes.maxBy(x => (x._2, x._1))._1", " \
    \       words.sortWith(\n            (left, right) => {\n                if (left.distinct.length\
    \ > right.distinct.length)\n                    true\n                else if\
    \ (left.distinct.length < right.distinct.length)\n                    false\n\
    \                else\n                    left.compareTo(right) < 0\n       \
    \     }\n        ).last", "        def findMax(words : List[String], current :\
    \ (String, Int)) : String = {\n            def uniqCharCount(word : String) :\
    \ Int = {\n                word.toList.distinct.length\n            }\n      \
    \      words match {\n                case Nil => current._1\n               \
    \ case x :: xs => {\n                    val curCount = uniqCharCount(x)\n   \
    \                 if (curCount > current._2) findMax(xs, (x, curCount))\n    \
    \                else if (curCount == current._2) findMax(xs, (if (x < current._1)\
    \ x else current._1, curCount))\n                    else findMax(xs, current)\n\
    \                }\n            }\n        }\n        findMax(words, (\"\", 0))",
  "        words.foldLeft(words.head)((x, y) =>\n            if (unique(x) > unique(y))\n\
    \                x\n            else if (unique(x) < unique(y))\n            \
    \    y\n            else if (x < y)\n                x\n            else\n   \
    \             y)", "        val list = words.map(x => (x, x.toSet.size)).toList\n\
    \        list.reduce((a, b) => if (a._2 >= b._2) a else b)._1", "        // Solution\
    \ 1. Use the last, which is safe for the first condition\n        // and sort\
    \ for the second condition.\n        // words.filter(w => w.length == words.map(w\
    \ => w.toSet.size).max).last\n        // Solution 2. Use groupBy to group words\
    \ by the length of the set of\n        // characters they contain, then reverse\
    \ to get the longest word, then\n        // apply a custom sorting function.\n\
    \        words.groupBy(w => w.toSet.size).toList.sortBy(pair => (pair._1, pair._2)).last._2.sorted.head",
  '        words.sortWith((a, b) => a.length > b.length || (a.length == b.length &&
    a < b)).find(a => a.toSet.size == a.length).get', "        // Case 1: words contains\
    \ single string.\n        if (words.size == 1) return words(0)\n        // Case\
    \ 2: words contains multiple strings.\n        var max : Int = 0\n        var\
    \ maxString : String = \"\"\n        for (w <- words) {\n            val count\
    \ = w.toCharArray.toSet.size\n            if (count > max) {\n               \
    \ max = count\n                maxString = w\n            }\n        }\n     \
    \   return maxString", "        var max = 0\n        var maxw = \"\"\n       \
    \ for (w <- words) {\n            if (w.toSet.size > max) {\n                max\
    \ = w.toSet.size\n                maxw = w\n            }\n        }\n       \
    \ maxw", "        words.sortWith((a, b) => (a.distinct.length compare b.distinct.length)\
    \ match {\n            case 1 => true\n            case -1 => false\n        \
    \    case 0 => a < b\n        }).last", "        var bestWord = \"\"\n       \
    \ var bestCount = 0\n        for (word <- words) {\n            val count = word.toSet.size\n\
    \            if (count > bestCount) {\n                bestCount = count\n   \
    \             bestWord = word\n            }\n        }\n        bestWord", " \
    \       var lst = new ListBuffer[String]\n        var lst2 = new ListBuffer[String]\n\
    \        var lst3 = new ListBuffer[String]\n        var str = \"\"\n        for\
    \ (i <- words) {\n            for (j <- 0 until i.length) {\n                var\
    \ flag = false\n                for (k <- 0 until lst.length) {\n            \
    \        if (i(j) == lst(k)) {\n                        flag = true\n        \
    \            }\n                }\n                if (flag == false) {\n    \
    \                lst += i(j).toString\n                }\n            }\n    \
    \        lst2 += lst.length.toString\n            lst.clear\n        }\n     \
    \   var max = -99999\n        for (i <- 0 until lst2.length) {\n            if\
    \ (lst2(i).toInt > max) {\n                max = lst2(i).toInt\n            }\n\
    \        }\n        for (i <- 0 until lst2.length) {\n            if (lst2(i).toInt\
    \ == max) {\n                lst3 += words(i)\n            }\n        }\n    \
    \    if (lst3.length > 1) {\n            str = lst3(0)\n            for (i <-\
    \ 1 until lst3.length) {\n                if (lst3(i) < str) {\n             \
    \       str = lst3(i)\n                }\n            }\n        } else {\n  \
    \          str = lst3(0)\n        }\n        str", "        words.foldLeft(\"\"\
    ) { (acc, word) =>\n            if (acc == \"\") word\n            else if (acc.distinct.length\
    \ < word.distinct.length) word\n            else if (acc.distinct.length == word.distinct.length)\
    \ {\n                if (acc > word) acc\n                else word\n        \
    \    }\n            else acc\n        }", "    \twords.reduceLeft((acc, word)\
    \ => {\n    \t\tif (word.distinct.length > acc.distinct.length) word\n    \t\t\
    else if (word.distinct.length == acc.distinct.length) {\n    \t\t\tif (word.compareTo(acc)\
    \ < 0) word\n    \t\t\telse acc\n    \t\t}\n    \t\telse acc\n    \t})", "   \
    \   if (words.isEmpty) null\n      else words.reduce((a, b) => {\n        if (a.length\
    \ > b.length) a\n        else if (a.length < b.length) b\n        else if (a.compareTo(b)\
    \ < 0) a\n        else b\n      })", "        var max : String = words(0)\n  \
    \      var maxUniqueCharacters : Int = 0\n        for (i <- 0 until words.length)\
    \ {\n            val uniqueChars = getUniqueChars(words(i))\n            if (uniqueChars.length\
    \ > maxUniqueCharacters) {\n                max = words(i)\n                maxUniqueCharacters\
    \ = uniqueChars.length\n            }\n        }\n        return max", "     \
    \ val numUniques = words.map(word => word.groupBy(char => char).keys.size)\n \
    \     val maxUniques = numUniques.max\n      val numWithMaxUniques = numUniques.zipWithIndex.filter(_._1\
    \ == maxUniques).map(_._2)\n      words(numWithMaxUniques.min)", "        var\
    \ max = \"\"\n        for (w <- words) {\n            if (w.size > max.size) {\n\
    \                max = w\n            } else if (w.size == max.size) {\n     \
    \           if (w < max) {\n                    max = w\n                }\n \
    \           }\n        }\n        max", "        var map = Map[String, Int]()\n\
    \        words.foreach(word => map += (word -> word.toSet.size))\n        map.toList.maxBy(_._2)._1",
  "        if (words.length == 0) return null\n        var maxWord = words(0)\n  \
    \      for (word <- words) {\n            if (word.distinct.length > maxWord.distinct.length)\
    \ maxWord = word\n            else if (word.distinct.length == maxWord.distinct.length)\
    \ {\n                if (word < maxWord) maxWord = word\n            }\n     \
    \   }\n        return maxWord", "        val wordWithUniqueCharacters = for (word\
    \ <- words) yield word -> word.distinct.length\n        wordWithUniqueCharacters.sortBy(x\
    \ => (-x._2, x._1)).head._1", "        var max : String = \"\"\n        for (word\
    \ <- words) {\n            if (max == \"\") max = word\n            else if (word.toSet.size\
    \ > max.toSet.size) max = word\n            else if (word.toSet.size == max.toSet.size\
    \ && word < max) max = word\n        }\n        return max", '        words.maxBy(_.toSet.size)',
  "        var max = \"\";\n        for (word <- words) {\n            if (word.length\
    \ > max.length) max = word;\n            else if (word.length == max.length) max\
    \ = word.compareTo(max) match {\n                case -1 => word;\n          \
    \      case 0 => word;\n                case 1 => max;\n            }\n      \
    \  }\n        return max;", "      def f(word : String) : Int = {\n        var\
    \ c = Set[Char]()\n        for (i <- 0 until word.length) {\n          c += word(i)\n\
    \        }\n        c.size\n      }\n      var result = words(0)\n      var max\
    \ = f(result)\n      for (i <- 1 until words.length) {\n        val word = words(i)\n\
    \        val m = f(word)\n        if (m > max) {\n          max = m\n        \
    \  result = word\n        }\n      }\n      result", "        def unique(word\
    \ : String) : HashSet[Char] = {\n            val hs = new HashSet[Char]\n    \
    \        for (i <- 0 until word.length) {\n                hs += word(i)\n   \
    \         }\n            hs\n        }\n        def uniqueMax(word : String, max\
    \ : Int, maxWord : String) : String = {\n            if (unique(word).size > max)\
    \ word\n            else if (unique(word).size == max) {\n                if (word\
    \ < maxWord) word\n                else maxWord\n            }\n            else\
    \ maxWord\n        }\n        words.foldLeft(\"\")((maxWord, word) => uniqueMax(word,\
    \ unique(maxWord).size, maxWord))", "      if (words.length == 0)\n        return\
    \ \"\"\n      words.foldLeft(words.head)((max : String, word : String) => {\n\
    \        if (word.length > max.length)\n          word\n        else if (word.length\
    \ == max.length) {\n          val mchars = countChars(max)\n          val wchars\
    \ = countChars(word)\n          if (mchars.size < wchars.size)\n            word\n\
    \          else if (mchars.size == wchars.size) {\n            if (word < max)\n\
    \              word\n            else\n              max\n          }\n      \
    \    else\n            max\n        }\n        else\n          max\n      })",
  "        def f(x : String, y : String) : Boolean = x.size > y.size || (x.size ==\
    \ y.size && x < y)\n        if (words.size == 0) \"\"\n        else words.reduceLeft((x,\
    \ y) => if (f(x, y)) x else y)", '        words.maxBy(word => word.groupBy(x =>
    x).size)', "        val u = words.map(x => x.toSet)\n        val q = words.zip(u)\n\
    \        val w = q.sortBy(x => x._2.size)\n        val e = w.map(x => x._1)\n\
    \        return e.last", "        val wordScore = words.map { word =>\n      \
    \      (word, word.toSet.size)\n        }\n        val maxScore = wordScore.maxBy(_._2)._2\n\
    \        wordScore.filter(_._2 == maxScore).minBy(_._1)._1", "        var maxString\
    \ = \"\"\n        var maxLength = 0\n        for (word <- words) {\n         \
    \   val length = word.groupBy(c => c).size\n            if (length > maxLength)\
    \ {\n                maxLength = length\n                maxString = word\n  \
    \          }\n        }\n        maxString", "        var pairs = new ListBuffer[(String,\
    \ Int)]\n        for (word <- words) {\n            pairs += ((word, word.length))\n\
    \        }\n        pairs.sortWith((x, y) => if (x._2 == y._2) x._1 < y._1 else\
    \ x._2 > y._2).head._1", "        var result = words(0)\n        for (i <- 1 until\
    \ words.length) {\n            if (words(i).toSet.size > result.toSet.size) result\
    \ = words(i)\n            else if (words(i).toSet.size == result.toSet.size &&\
    \ words(i) < result) result = words(i)\n        }\n        result", '        words.foldLeft(("",
    0))((acc, cur) => if (cur.distinct.length > acc._2) (cur, cur.distinct.length)
    else acc)._1', "        var max = (\"\", 0)\n        for (word <- words) {\n \
    \           val unique = new HashSet[Char]\n            for (c <- word) unique\
    \ += c\n            if (unique.size > max._2) max = (word, unique.size)\n    \
    \        else if (unique.size == max._2 && word < max._1) max = (word, unique.size)\n\
    \        }\n        max._1", "        def f(words : List[String], max : (String,\
    \ Int)) : String = {\n            if (words.length == 0) max._1\n            else\
    \ {\n                val (word, count) = words.head.distinct.foldLeft((words.head,\
    \ 0))((a, b) => (a._1, a._2 + 1))\n                if (count > max._2) f(words.tail,\
    \ (word, count))\n                else if (count == max._2) {\n              \
    \      if (word < max._1) f(words.tail, (word, count))\n                    else\
    \ f(words.tail, max)\n                }\n                else f(words.tail, max)\n\
    \            }\n        }\n        f(words, (\"\", 0))", '        words.maxBy(w
    => (w.toSet.size, w))', "        var max : String = \"\"\n        var maxCount\
    \ : Int = 0\n        for (word <- words) {\n            val count = word.toSet.size\n\
    \            if (count > maxCount) {\n                max = word\n           \
    \     maxCount = count\n            }\n        }\n        max", "        if (words.isEmpty)\
    \ \"\"\n        else {\n            val unsorted = words.map(word => (word, word.toSet.size))\n\
    \            val sorted = unsorted.sortWith((x, y) => x._2 > y._2 || (x._2 ==\
    \ y._2 && x._1 < y._1))\n            sorted.head._1\n        }", "        var\
    \ max = 1\n        var maxWords = Array[String]()\n        for (word <- words)\
    \ {\n            val uniques = word.distinct.length\n            if (uniques >\
    \ max) {\n                max = uniques\n                maxWords = Array[String](word)\n\
    \            } else if (uniques == max) {\n                maxWords :+= word\n\
    \            }\n        }\n        maxWords.sortWith(_ < _)(0)", "        // Use\
    \ a HashMap to count the number of unique characters in each word.\n        val\
    \ uniqueChars = new HashMap[String, Int]()\n        for (word <- words) {\n  \
    \          uniqueChars += word -> word.distinct.length\n        }\n        //\
    \ Use a Buffer to store the words with max number of unique characters.\n    \
    \    val mostUniqueChars = new Buffer[String]()\n        for ((word, numUniqueChars)\
    \ <- uniqueChars) {\n            if (mostUniqueChars.isEmpty) {\n            \
    \    mostUniqueChars += word\n            } else {\n                if (numUniqueChars\
    \ > uniqueChars(mostUniqueChars(0))) {\n                    mostUniqueChars.clear\n\
    \                    mostUniqueChars += word\n                } else if (numUniqueChars\
    \ == uniqueChars(mostUniqueChars(0))) {\n                    mostUniqueChars +=\
    \ word\n                }\n            }\n        }\n        // Sort the words\
    \ with max number of unique characters and return the first one.\n        return\
    \ mostUniqueChars.sortWith(_ < _)(0)", "    \tif (words.isEmpty) \"\"\n    \t\
    else words.map((word) => word -> word.distinct.length).maxBy(_._2)._1", "    \t\
    var max : String = \"\"\n    \tvar l : Int = -1\n    \tfor (i <- 0 until words.length)\
    \ {\n    \t\tval word = words(i)\n    \t\tval m = word.toSet.size\n    \t\tif\
    \ (m > l) {\n    \t\t\tmax = word\n    \t\t\tl = m\n    \t\t}\n    \t}\n    \t\
    max", "        var map = new HashMap[String, Int]\n        for (word <- words)\
    \ {\n            map += (word -> word.distinct.length)\n        }\n        var\
    \ max = (words(0), 0)\n        for ((word, count) <- map) {\n            if (count\
    \ > max._2) max = (word, count)\n        }\n        max._1", '        return words.maxBy(x
    => x.distinct.length)', "        var result = \"\"\n        var max = -1\n   \
    \     for (word <- words) {\n            val unique = word.toSet.size\n      \
    \      if (unique > max) {\n                max = unique\n                result\
    \ = word\n            }\n        }\n        result", "        var maxWord = \"\
    \"\n        var maxUniqChars = 0\n        for (word <- words) {\n            val\
    \ uniqChars = word.toList.distinct.length\n            if (uniqChars > maxUniqChars)\
    \ {\n                maxUniqChars = uniqChars\n                maxWord = word\n\
    \            }\n        }\n        maxWord", "        def findUniqueChars(s :\
    \ String) : List[Char] = {\n            var charSet = Set[Char]()\n          \
    \  for (c <- s) {\n                charSet += c\n            }\n            charSet.toList\n\
    \        }\n        def maxWord(s1 : String, s2 : String) : String = {\n     \
    \       if (findUniqueChars(s1).length > findUniqueChars(s2).length) s1\n    \
    \        else if (findUniqueChars(s1).length < findUniqueChars(s2).length) s2\n\
    \            else if (s1 < s2) s1\n            else s2\n        }\n        words.reduceLeft(maxWord)",
  "        val distinct = words.map(w => w.distinct)\n        val (max_len, max_string)\
    \ = distinct.zip(words).maxBy(_._1.length)\n        max_string", "        def\
    \ findMax(currentMax : String, words : List[String]) : String = {\n          \
    \  if (words.isEmpty) currentMax\n            else {\n                val currentUnique\
    \ = words.head.groupBy(ch => ch).mapValues(s => s.length).values.sum\n       \
    \         val maxUnique = currentMax.groupBy(ch => ch).mapValues(s => s.length).values.sum\n\
    \                if (currentUnique > maxUnique) findMax(words.head, words.tail)\n\
    \                else if (currentUnique == maxUnique) {\n                    if\
    \ (words.head < currentMax) findMax(words.head, words.tail)\n                \
    \    else findMax(currentMax, words.tail)\n                }\n               \
    \ else findMax(currentMax, words.tail)\n            }\n        }\n        findMax(words.head,\
    \ words.tail)", '        words.maxBy(word => word.toSet.size)', "        val allChars\
    \ = words.foldLeft(Set[Char]())((set, word) => set ++ word.toSet)\n        val\
    \ wordsWithCharCount = words.map(word => (word, word.map(c => allChars.count(c2\
    \ => c == c2)).sum))\n        var maxWord = wordsWithCharCount.head\n        wordsWithCharCount.tail.foreach(word\
    \ => if (word._2 > maxWord._2) maxWord = word)\n        maxWord._1", "       \
    \ words.foldLeft((\"\", (HashSet[Char](), 0)))((state, word) => {\n          \
    \  val uniqueChars = word.toSet\n            val numUniqueChars = uniqueChars.size\n\
    \            if (numUniqueChars > state._2._2) {\n                (word, (uniqueChars,\
    \ numUniqueChars))\n            } else if (numUniqueChars == state._2._2) {\n\
    \                if (word < state._1) {\n                    (word, (uniqueChars,\
    \ numUniqueChars))\n                } else {\n                    state\n    \
    \            }\n            } else {\n                state\n            }\n \
    \       })._1", "        val (max, word) = words.foldLeft((0, \"\"))((max, word)\
    \ => {\n            val count = word.toSet.size\n            if (count > max._1)\
    \ (count, word) else (max._1, max._2)\n        })\n        word", "      var sortedWords\
    \ = words.sortWith(_ < _)\n      var result : String = \"\"\n      var maxLength\
    \ : Int = 0\n      sortedWords.foreach(word => {\n        if (word.length > maxLength)\
    \ {\n          var duplicates = new HashSet[Char]\n          var uniqueCount :\
    \ Int = 0\n          word.foreach(ch => {\n            if (!duplicates.contains(ch))\
    \ {\n              uniqueCount += 1\n              duplicates.add(ch)\n      \
    \      }\n          })\n          if (uniqueCount >= maxLength) {\n          \
    \  maxLength = uniqueCount\n            result = word\n          }\n        }\n\
    \      })\n      result", "        def isUnique(c : Char, word : String) : Boolean\
    \ = {\n            if (word.isEmpty) false\n            else if (word.head ==\
    \ c) true\n            else isUnique(c, word.tail)\n        }\n        def getUniqueChar(word\
    \ : String) : List[Char] = {\n            if (word.isEmpty) Nil\n            else\
    \ if (isUnique(word.head, word.tail)) word.head :: getUniqueChar(word.tail)\n\
    \            else getUniqueChar(word.tail)\n        }\n        words.filter(word\
    \ => getUniqueChar(word).length == words.map(w => getUniqueChar(w).length).max).sortWith((a,\
    \ b) => a < b).head", "        def helper(words : List[String], word : String,\
    \ max : Int) : String = {\n            if (words.isEmpty) word\n            else\
    \ {\n                val c = count(words.head)\n                if (c > max) helper(words.tail,\
    \ words.head, c)\n                else if (c == max) helper(words.tail, if (words.head\
    \ < word) words.head else word, c)\n                else helper(words.tail, word,\
    \ max)\n            }\n        }\n        def count(word : String) : Int = {\n\
    \            val set = HashSet[Char]()\n            for (i <- 0 until word.length)\
    \ {\n                set += word(i)\n            }\n            set.size\n   \
    \     }\n        helper(words, \"\", 0)", "        if (words.length == 0) throw\
    \ new IllegalArgumentException\n        if (words.length == 1) return words(0)\n\
    \        val uniqueChars : List[Tuple2[String, Int]] = for (word <- words) yield\
    \ (word, word.distinct.length)\n        var max = 0\n        for (uniqueChar <-\
    \ uniqueChars) {\n            if (uniqueChar._2 > max) max = uniqueChar._2\n \
    \       }\n        var candidates : List[String] = for (uniqueChar <- uniqueChars\
    \ if uniqueChar._2 == max) yield uniqueChar._1\n        var minIndex = candidates(0)\n\
    \        for (candidate <- candidates) {\n            if (candidate < minIndex)\
    \ minIndex = candidate\n        }\n        return minIndex", "        var max\
    \ = 0\n        var maxWord = \"\"\n        for (word <- words) {\n           \
    \ val count = word.groupBy(identity).mapValues(_.size).size\n            if (count\
    \ > max) {\n                max = count\n                maxWord = word\n    \
    \        }\n        }\n        maxWord", "        var set = Set[Char]()\n    \
    \    var map = Map[String, Int]()\n        for (word <- words) {\n           \
    \ set.clear\n            for (ch <- word) set += ch\n            map += (word\
    \ -> set.size)\n        }\n        var max : String = null\n        var maxVal\
    \ : Int = 0\n        for ((word, cnt) <- map) {\n            if (max == null ||\
    \ maxVal < cnt || (maxVal == cnt && word < max)) {\n                max = word\n\
    \                maxVal = cnt\n            }\n        }\n        max", "     \
    \   var maxLength = -1\n        var maxString = \"\"\n        for (word <- words)\
    \ {\n            val chars = new HashSet[Char]\n            for (c <- word) {\n\
    \                chars += c\n            }\n            if (chars.size > maxLength)\
    \ {\n                maxLength = chars.size\n                maxString = word\n\
    \            }\n        }\n        maxString", "        var maxString = \"\"\n\
    \        var max = 0\n        for (word <- words) {\n            val set = new\
    \ HashSet[Char]\n            for (ch <- word) set += ch\n            if (set.size\
    \ > max) {\n                max = set.size\n                maxString = word\n\
    \            }\n        }\n        maxString", '        words.map(word => (word,
    word.toSet.size)).sortWith((x, y) => { if (x._2 == y._2) (x._1 < y._1) else (x._2
    > y._2) }).head._1', "        var maxWord = \"\"\n        var maxLength = 0\n\
    \        for (word <- words) {\n            if (word.distinct.length > maxLength)\
    \ {\n                maxWord = word\n                maxLength = word.distinct.length\n\
    \            }\n        }\n        return maxWord", "        val groupedWords\
    \ = words.map(x => (x, x.toSet.size)).groupBy(_._2).toList.sortBy(_._1).reverse\n\
    \        val numUnique = groupedWords.head._1\n        val wordsOfNumUnique =\
    \ groupedWords.head._2.map(_._1).sortWith(_ < _)\n        wordsOfNumUnique.head",
  "        // all lowercase characters from 'a' to 'z'\n        val allChars = List.range('a',\
    \ 'z' + 1).map(c => c.toChar)\n        // all characters in the word\n       \
    \ def getChars(word : String) : List[Char] = word.toList.map(c => c.toLower)\n\
    \        // get the unique characters of a string\n        def getUniqueChars(word\
    \ : String) : List[Char] = {\n            val chars = getChars(word)\n       \
    \     var uniqueChars = List[Char]()\n            for (c <- allChars) {\n    \
    \            if (chars.contains(c)) uniqueChars ::= c\n            }\n       \
    \     uniqueChars\n        }\n        // get the number of unique characters of\
    \ a string\n        def getUniqueCharCount(word : String) : Int = getUniqueChars(word).length\n\
    \        // get all strings with the max number of unique characters\n       \
    \ def getMax(words : List[String]) : List[String] = {\n            val max = words.map(w\
    \ => getUniqueCharCount(w)).max\n            words.filter(w => getUniqueCharCount(w)\
    \ == max)\n        }\n        // get the string that comes first in lexicographical\
    \ order\n        def getLexi(words : List[String]) : String = words.min\n    \
    \    getLexi(getMax(words))", "        // let unique characters be the number\
    \ of unique characters\n        // let characters be the number of characters\n\
    \        // if unique characters is greater, then that word is most unique\n \
    \       // if unique characters is the same, then we check lexicographically\n\
    \        val list = for (word <- words) yield {\n            (word, word.distinct.length,\
    \ word.length)\n        }\n        var index = 0\n        var maxCharacters =\
    \ 0\n        var maxUniqueCharacters = 0\n        for (i <- 0 until list.length)\
    \ {\n            val (word, uniqueCharacters, characters) = list(i)\n        \
    \    if (uniqueCharacters > maxUniqueCharacters) {\n                maxUniqueCharacters\
    \ = uniqueCharacters\n                maxCharacters = characters\n           \
    \     index = i\n            } else if (uniqueCharacters == maxUniqueCharacters)\
    \ {\n                if (characters > maxCharacters) {\n                    maxCharacters\
    \ = characters\n                    index = i\n                }\n           \
    \ }\n        }\n        list(index)._1", '        words.reduceLeft((a, b) => if
    (a.toSet.size > b.toSet.size) a else b)', '        words.maxBy(word => word.toSet.size)',
  "        // Your code goes here\n        return \"\"", "        // TODO\n      \
    \  \"\"", "        def findMaxIter(words : List[String], max : String) : String\
    \ = {\n            if (words.isEmpty) max\n            else if (words.head.toSet.size\
    \ > max.toSet.size) findMaxIter(words.tail, words.head)\n            else if (words.head.toSet.size\
    \ == max.toSet.size) findMaxIter(words.tail, if (words.head < max) words.head\
    \ else max)\n            else findMaxIter(words.tail, max)\n        }\n      \
    \  if (words.isEmpty) \"\"\n        else findMaxIter(words.tail, words.head)",
  "        def findMax(words : List[String], max : (String, Int)) : String = {\n \
    \           if (words.length == 0) max._1\n            else {\n              \
    \  val count = words.head.groupBy(x => x).values.map(x => x.length).toList.sorted\n\
    \                val current = (words.head, count.last)\n                if (current._2\
    \ > max._2) findMax(words.tail, current)\n                else if (current._2\
    \ == max._2) {\n                    if (current._1 < max._1) findMax(words.tail,\
    \ current)\n                    else findMax(words.tail, max)\n              \
    \  }\n                else findMax(words.tail, max)\n            }\n        }\n\
    \        findMax(words, (\"\", 0))", "        val res = new ArrayBuffer[String]()\n\
    \        var max = -1\n        for (word <- words) {\n            val u = word.toSet.size\n\
    \            if (u > max) {\n                max = u\n                res.clear\n\
    \                res += word\n            } else if (u == max) {\n           \
    \     res += word\n            }\n        }\n        return res.min", '        words.maxBy((word
    : String) => word.distinct.length)', "        val freq = scala.collection.mutable.Map[Char,\
    \ Int]()\n        def count(word : String) : Int = {\n            freq.clear\n\
    \            for (ch <- word)\n                freq(ch) = freq.getOrElse(ch, 0)\
    \ + 1\n            return freq.size\n        }\n        var best = \"\"\n    \
    \    var bestCount = 0\n        for (word <- words) {\n            val count =\
    \ count(word)\n            if (count > bestCount) {\n                best = word\n\
    \                bestCount = count\n            }\n            else if (count\
    \ == bestCount && word < best) {\n                best = word\n              \
    \  bestCount = count\n            }\n        }\n        return best", "      \
    \  var best = (0, \"\")\n        for (word <- words) {\n            var uniqueChars\
    \ = Set[Char]()\n            for (c <- word) uniqueChars += c\n            if\
    \ (uniqueChars.size > best._1) best = (uniqueChars.size, word)\n            else\
    \ if (uniqueChars.size == best._1 && word < best._2) best = (uniqueChars.size,\
    \ word)\n        }\n        best._2", '        words.maxBy(s => s.toSet.size)',
  "        // code here\n        \"\"", '      words.foldLeft(("", 0))((res, item)
    => if (item.distinct.length > res._2) (item, item.distinct.length) else res)._1',
  "      var max = 0\n      var ret = words(0)\n      for (word <- words) {\n    \
    \    val h = new HashSet[Char]\n        var len = 0\n        for (i <- 0 until\
    \ word.length) {\n          if (!h.contains(word(i))) {\n            h += word(i)\n\
    \            len += 1\n          }\n        }\n        if (len > max) {\n    \
    \      max = len\n          ret = word\n        }\n      }\n      ret", '      words.map(x
    => x -> x.toSet.size).sortBy(x => (-x._2, x._1)).head._1', "        var max =\
    \ (0, \"\")\n        words.foreach {word =>\n            val unique = word.toSet.size\n\
    \            if (unique > max._1) max = (unique, word)\n            else if (unique\
    \ == max._1 && word < max._2) max = (unique, word)\n        }\n        max._2",
  "        var max = 0\n        var index = 0\n        for (i <- 0 until words.length)\
    \ {\n            val set = new HashSet[Char]\n            for (c <- words(i))\
    \ {\n                set += c\n            }\n            if (set.size > max)\
    \ {\n                max = set.size\n                index = i\n            }\n\
    \        }\n        words(index)", "        val maxCharLength = words.map(_.toSet.size).max\n\
    \        words.filter(_.toSet.size == maxCharLength).min", "        // Error check.\n\
    \        if (words.length == 0) throw new Exception(\"The list is empty!\")\n\
    \        if (words.length == 1) return words(0)\n        // Collect the number\
    \ of unique characters.\n        var numOfUniqueChars = new Array[Int](words.length)\n\
    \        for (i <- 0 until words.length) {\n            var chars = Set[Char]()\n\
    \            for (c <- words(i)) {\n                chars += c\n            }\n\
    \            numOfUniqueChars(i) = chars.size\n        }\n        // Find the\
    \ maximum number of unique characters.\n        var maxNumOfUniqueChars = 0\n\
    \        for (i <- 0 until numOfUniqueChars.length) {\n            if (numOfUniqueChars(i)\
    \ > maxNumOfUniqueChars) {\n                maxNumOfUniqueChars = numOfUniqueChars(i)\n\
    \            }\n        }\n        // Return the word with maximum number of unique\
    \ characters.\n        for (i <- 0 until numOfUniqueChars.length) {\n        \
    \    if (numOfUniqueChars(i) == maxNumOfUniqueChars) {\n                return\
    \ words(i)\n            }\n        }\n        // This code should never be executed.\n\
    \        throw new Exception(\"Error occurred!\")", "        val max = words.map(s\
    \ => s.toSet.size).max\n        words.filter(s => s.toSet.size == max).sortWith((a,\
    \ b) => a < b).head", "        var maxWord = \"\"\n        var maxCnt = 0\n  \
    \      for (i <- 0 until words.length) {\n            val word = words(i)\n  \
    \          val cnt = word.toSet.size\n            if (cnt > maxCnt) {\n      \
    \          maxCnt = cnt\n                maxWord = word\n            }\n     \
    \   }\n        maxWord", "        val wordMap = new HashMap[String, Int]()\n \
    \       words.foreach(word => {\n            wordMap.update(word, word.distinct.length)\n\
    \        })\n        val map = wordMap.toSeq.sortBy(word => word._2)\n       \
    \ val max = map.last._2\n        val maxWord = map.filter(word => word._2 == max)\n\
    \        val minWord = maxWord.sortBy(word => word._1).head\n        minWord._1",
  "        var (max, res) = (0, \"\")\n        for (word <- words) {\n           \
    \ val counts = new HashMap[Char, Int]\n            for (c <- word) {\n       \
    \         counts(c) = counts.getOrElse(c, 0) + 1\n            }\n            if\
    \ (counts.size > max) {\n                max = counts.size\n                res\
    \ = word\n            }\n        }\n        res", "        def unique(word : String)\
    \ : Int = word.groupBy(c => c).map(p => p._1).size\n        val m = words.map(word\
    \ => (word, unique(word))).sortWith((a, b) => a._2 > b._2 || (a._2 == b._2 &&\
    \ a._1 < b._1))\n        m(0)._1", "        if (words.length == 0) return null\n\
    \        var longest = words(0)\n        var maxNumUnique = findNumUnique(words(0))\n\
    \        for (word <- words) {\n            val numUnique = findNumUnique(word)\n\
    \            if (numUnique > maxNumUnique) {\n                maxNumUnique = numUnique\n\
    \                longest = word\n            }\n        }\n        longest", " \
    \       val set = new HashSet[Char]\n        words.foldLeft((\"\", Int.MinValue))((cur,\
    \ word) => {\n            set.clear\n            var n = 0\n            for (c\
    \ <- word) {\n                if (!set.contains(c)) {\n                    set\
    \ += c\n                    n += 1\n                }\n            }\n       \
    \     if (n > cur._2) (word, n) else cur\n        })._1", "    \tif (words.length\
    \ == 0) throw new Exception(\"Error: The list is empty!\")\n    \tvar maxWord\
    \ = words(0)\n    \tvar maxChar = words(0).toSet.size\n    \tfor (i <- 0 until\
    \ words.length) {\n    \t\tval c = words(i).toSet.size\n    \t\tif (c > maxChar)\
    \ {\n    \t\t\tmaxChar = c\n    \t\t\tmaxWord = words(i)\n    \t\t}\n    \t}\n\
    \    \tmaxWord", "        var result = \"\"\n        var maximum = 0\n       \
    \ words.foreach(x => {\n            val m = x.groupBy(identity).size\n       \
    \     if (m > maximum) {\n                maximum = m\n                result\
    \ = x\n            }\n        })\n        result", "        val letterCounts =\
    \ words.map {word =>\n            val counts = Array.fill(26)(0)\n           \
    \ for (letter <- word) counts(letter - 'a') += 1\n            counts\n       \
    \ }\n        val distinctCounts = letterCounts.map(_.count(_ > 0))\n        val\
    \ max = distinctCounts.max\n        var maxWord = \"\"\n        var i = 0\n  \
    \      while (maxWord == \"\" && i < words.length) {\n            if (distinctCounts(i)\
    \ == max) maxWord = words(i)\n            i += 1\n        }\n        maxWord",
  "        var maxLength = 0\n        var maxWords = List[String]()\n        for (word\
    \ <- words) {\n            val chars = word.toSet\n            if (chars.size\
    \ > maxLength) {\n                maxLength = chars.size\n                maxWords\
    \ = List(word)\n            } else if (chars.size == maxLength) {\n          \
    \      maxWords = maxWords :+ word\n            }\n        }\n        maxWords.sorted.head",
  '        words.map(w => (w, w.groupBy(ch => ch).size)).sortBy(x => (x._2, x._1)).last._1',
  "        val m = new Array[Int](256)\n        val m2 = new Array[Int](256)\n   \
    \     for (i <- 0 until words.length) {\n            for (j <- 0 until words(i).length)\
    \ {\n                m(words(i)(j)) += 1\n            }\n            for (k <-\
    \ 0 until m.length) {\n                if (m(k) > 0) m2(k) += 1\n            }\n\
    \            for (l <- 0 until m.length) m(l) = 0\n        }\n        val (maxUnique,\
    \ maxUniqueIndex) = m2.zipWithIndex.max\n        words.filter(word => word.length\
    \ == maxUnique).min", "        if (words.isEmpty)\n            throw new Exception(\"\
    Empty list\")\n        var result = words(0)\n        for (word <- words) {\n\
    \            if (result.length > word.length)\n                result = word\n\
    \            else if (result.length == word.length) {\n                var i =\
    \ 0\n                var j = 0\n                while (i < result.length && j\
    \ < word.length) {\n                    if (result(i) < word(j)) {\n         \
    \               j = 0\n                        i += 1\n                    }\n\
    \                    else if (result(i) > word(j)) {\n                       \
    \ result = word\n                        j = 0\n                        i = 0\n\
    \                    }\n                    else {\n                        j\
    \ += 1\n                    }\n                }\n            }\n        }\n \
    \       result", "        var maxChar = 0\n        var maxCharWord = \"\"\n  \
    \      for (word <- words) {\n            val charSet = word.toSet\n         \
    \   if (charSet.size > maxChar) {\n                maxChar = charSet.size\n  \
    \              maxCharWord = word\n            }\n        }\n        maxCharWord",
  "        if (words.length == 0) throw new Exception(\"The input list has to have\
    \ at least one string\")\n        var bestCount = 0\n        var bestWord = \"\
    \"\n        words.foreach(word => {\n            var set = Set[Char]()\n     \
    \       word.foreach(c => set += c)\n            if (set.size > bestCount) {\n\
    \                bestCount = set.size\n                bestWord = word\n     \
    \       }\n        })\n        bestWord", "        words.foldLeft(\"\", 0) { case\
    \ ((word, max), x) =>\n            if (x.distinct.length > max)\n            \
    \    (x, x.distinct.length)\n            else if (x.distinct.length == max)\n\
    \                if (x < word) (x, max) else (word, max)\n            else\n \
    \               (word, max)\n        }._1", '        return ""', '        words.maxBy(word
    => word.toSet.size)', "        var maxWord = \"\"\n        var maxCharSet = Set[Char]()\n\
    \        for (word <- words) {\n            val charSet = word.toSet\n       \
    \     if (charSet.size > maxCharSet.size) {\n                maxWord = word\n\
    \                maxCharSet = charSet\n            }\n        }\n        maxWord",
  "        words.foldLeft((\"\", 0))((acc, word) => {\n            val numChars =\
    \ Set[Char]() ++ word\n            if (numChars.size > acc._2) (word, numChars.size)\n\
    \            else if (numChars.size == acc._2) if (word < acc._1) (word, numChars.size)\
    \ else acc\n            else acc\n        })._1", "        var result = \"\"\n\
    \        var maxCount = 0\n        words.foreach(word => {\n            val set\
    \ = Set[Char]()\n            var count = 0\n            word.foreach(ch => {\n\
    \                if (!set.contains(ch)) {\n                    set += ch\n   \
    \                 count += 1\n                }\n            })\n            if\
    \ (count > maxCount) {\n                maxCount = count\n                result\
    \ = word\n            }\n        })\n        result", '        words.foldLeft(("",Set[Char]()))((s,w)
    => if (w.toSet.size > s._2.size) (w,w.toSet) else if (w.toSet.size == s._2.size
    && w < s._1) (w,w.toSet) else s)._1', "    \tdef hasMoreUniqueChar(w1 : String,\
    \ w2 : String) : Boolean = {\n    \t\tval chSet1 = new HashSet[Char]\n    \t\t\
    val chSet2 = new HashSet[Char]\n    \t\tfor (ch <- w1) chSet1 += ch\n    \t\t\
    for (ch <- w2) chSet2 += ch\n    \t\treturn chSet1.size > chSet2.size\n    \t\
    }\n    \tif (words.size == 1) return words(0)\n    \treturn words.tail.foldLeft(words(0))((w1,\
    \ w2) => {\n    \t\tif (hasMoreUniqueChar(w1, w2)) w1 else w2\n    \t})", '        words.maxBy(w
    => w.toSet.size)', "    \tvar maxChar = ' '\n    \tvar maxWord = \"\"\n    \t\
    for (word <- words) {\n    \t\tvar chars = new HashSet[Char]\n    \t\tfor (char\
    \ <- word) {\n    \t\t\tchars += char\n    \t\t}\n    \t\tif (chars.size > maxChar)\
    \ {\n    \t\t\tmaxChar = chars.size\n    \t\t\tmaxWord = word\n    \t\t}\n   \
    \ \t}\n    \treturn maxWord", "        var m = words.head\n        var maxCount\
    \ = m.distinct.length\n        words.foreach { w =>\n            val count = w.distinct.length\n\
    \            if (count > maxCount) {\n                m = w\n                maxCount\
    \ = count\n            }\n        }\n        m", '        words.maxBy(w => (w.groupBy(c
    => c).size, w))', "        var result = words(0)\n        var freq = mutable.Map[Char,\
    \ Int]()\n        for (ch <- result) {\n            if (freq.contains(ch)) freq(ch)\
    \ += 1 else freq(ch) = 1\n        }\n        for (word <- words) {\n         \
    \   var freq2 = mutable.Map[Char, Int]()\n            for (ch <- word) {\n   \
    \             if (freq2.contains(ch)) freq2(ch) += 1 else freq2(ch) = 1\n    \
    \        }\n            if (freq2.size > freq.size || (freq2.size == freq.size\
    \ && word < result)) {\n                result = word\n                freq =\
    \ freq2\n            }\n        }\n        result", "        var max = \"\"\n\
    \        for (word <- words) {\n            if (word.length > max.length) max\
    \ = word\n            else if (word.length == max.length) max = min(word, max)\n\
    \        }\n        max", "        if (words.isEmpty) return \"\"\n        var\
    \ maxStr = words(0)\n        var maxCount = countUnique(words(0))\n        for\
    \ (i <- 1 until words.length) {\n            val cnt = countUnique(words(i))\n\
    \            if (cnt > maxCount) {\n                maxStr = words(i)\n      \
    \          maxCount = cnt\n            }\n            else if (cnt == maxCount)\
    \ {\n                if (words(i) < maxStr) {\n                    maxStr = words(i)\n\
    \                    maxCount = cnt\n                }\n            }\n      \
    \  }\n        return maxStr", "        var max = 0\n        var maxWord = \"\"\
    \n        words.foreach(w => {\n            val count = w.toList.toSet.size\n\
    \            if (count > max) {\n                max = count\n               \
    \ maxWord = w\n            }\n        })\n        maxWord", "        val map =\
    \ HashMap[String, List[Char]]()\n        words.foreach(word => map += (word ->\
    \ word.toSet.toList))\n        val maxWord = words.filter(word => map(word).length\
    \ == map.values.maxBy(_.length).length).sorted.head\n        return maxWord",
  "        // Implement this placeholder.\n        return \"\"", '        words.map(word
    => (word, word.toSet.size)).maxBy(_._2)._1', "        val result = words.map(x\
    \ => (x, x.groupBy(x => x).map(x => x._1).size)).toList.sortBy(x => (x._2, x._1))\n\
    \        result.last._1", "        var max = \"\";\n        for (word <- words)\
    \ {\n            if (word > max) max = word;\n        }\n        return max;",
  '        words.filter((x) => x.distinct.length == words.map((y) => y.distinct.length).max).head',
  '        words.maxBy(_.distinct.length)', "        var max = \"\"\n        for (word\
    \ <- words) {\n            if (uniqueCharNum(word) > uniqueCharNum(max)) {\n \
    \               max = word\n            }\n        }\n        max", "        var\
    \ max = words(0)\n        var maxlength = words(0).toSet.size\n        for (word\
    \ <- words) {\n            if (word.toSet.size > maxlength) {\n              \
    \  max = word\n                maxlength = word.toSet.size\n            }\n  \
    \      }\n        return max", "        var ans = \"\"\n        var cnt = -1\n\
    \        for (w <- words) {\n            val cur = w.toSet.size\n            if\
    \ (cur > cnt) {\n                ans = w\n                cnt = cur\n        \
    \    }\n        }\n        ans", "        val m = words.map(w => (w, w.toSet.size)).toList.sortWith((x,\
    \ y) => x._2 > y._2 || (x._2 == y._2 && x._1 < y._1))\n        m.head._1", '        words.maxBy(w
    => w.distinct.length)', "        def findMaxHelper(words : List[String], currentMax\
    \ : String, acc : String) : String = {\n            if (words.isEmpty) acc\n \
    \           else {\n                val count = words.head.toSet.size\n      \
    \          if (count > currentMax.toSet.size) findMaxHelper(words.tail, words.head,\
    \ words.head)\n                else if (count == currentMax.toSet.size) findMaxHelper(words.tail,\
    \ currentMax, acc)\n                else findMaxHelper(words.tail, currentMax,\
    \ acc)\n            }\n        }\n        findMaxHelper(words, \"\", \"\")", " \
    \       val word = words.maxBy(x => x.toSet.size)\n        word", "      var maxLength\
    \ = 0\n      var result = \"\"\n      for (w <- words) {\n        val l = w.toSet.size\n\
    \        if (l > maxLength) {\n          maxLength = l\n          result = w\n\
    \        }\n      }\n      result", '        return "string"', '        words.maxBy(x
    => (x.toSet).size)', "        var maxWord = \"\"\n        var maxCount = 0\n \
    \       for (w <- words) {\n            val count = countUnique(w)\n         \
    \   if (count > maxCount) {\n                maxCount = count\n              \
    \  maxWord = w\n            }\n        }\n        maxWord", '        words.foldLeft(words.head)((max,
    word) => if (word.distinct.length > max.distinct.length) word else max)', "  \
    \      var max = (0, words(0))\n        for (word <- words) {\n            val\
    \ newMax = word match {\n                case word if word.distinct.length > max._1\
    \ => (word.distinct.length, word)\n                case word if word.distinct.length\
    \ == max._1 && word < max._2 => (word.distinct.length, word)\n               \
    \ case _ => max\n            }\n            max = newMax\n        }\n        max._2",
  '        words.filter(_.size > 0).maxBy(x => (x.size, x))', '      words.sortWith((a,
    b) => (a.length > b.length) || (a.length == b.length && a.compareTo(b) < 0)).head',
  "        val uniqueCharactersCount = words.map(x => (x, x.toSet.size))\n       \
    \ uniqueCharactersCount.maxBy(_._2)._1", "        var maxWord = \"\"\n       \
    \ var maxCount = 0\n        for (word <- words) {\n            val count = word.toSet.size\n\
    \            if (count > maxCount) {\n                maxCount = count\n     \
    \           maxWord = word\n            }\n        }\n        maxWord", "    \
    \    val hm = new HashMap[String, Int]()\n        for (word <- words) {\n    \
    \        val set = new HashSet[Char]()\n            for (c <- word) set += c\n\
    \            hm += (word -> set.size)\n        }\n        var min = Integer.MAX_VALUE\n\
    \        var ans = \"\"\n        for ((word, count) <- hm) {\n            if (count\
    \ < min) {\n                min = count\n                ans = word\n        \
    \    }\n        }\n        ans", "        var maxWord = words(0)\n        var\
    \ maxCharCount = 0\n        for (word <- words) {\n            val charCount =\
    \ word.distinct.length\n            if (charCount > maxCharCount) {\n        \
    \        maxCharCount = charCount\n                maxWord = word\n          \
    \  }\n        }\n        maxWord", "        def findMaxRec(words : List[String],\
    \ max : (String, Int)) : String = {\n            if (words.isEmpty) max._1\n \
    \           else {\n                val count = words.head.toCharArray.toSet.size\n\
    \                if (count > max._2) findMaxRec(words.tail, (words.head, count))\n\
    \                else if (count == max._2) findMaxRec(words.tail, (min(words.head,\
    \ max._1), count))\n                else findMaxRec(words.tail, max)\n       \
    \     }\n        }\n        findMaxRec(words, (\"\", 0))", "        val maxWord\
    \ = words.maxBy(word => word.toSet.size)\n        val maxCount = maxWord.toSet.size\n\
    \        words.filter(word => word.toSet.size == maxCount).sortWith((w1, w2) =>\
    \ w1 < w2).head", "        var maxWord = \"\"\n        var maxCount = 0\n    \
    \    for (word <- words) {\n            var count = 0\n            for (i <- 0\
    \ until word.length) {\n                if (word.lastIndexOf(word(i)) == i) count\
    \ += 1\n            }\n            if (count > maxCount) {\n                maxCount\
    \ = count\n                maxWord = word\n            }\n        }\n        maxWord",
  "        val distinctMap = words.map { w =>\n            w -> w.toSet.size\n   \
    \     }.toMap\n        val mx = distinctMap.values.max\n        distinctMap.filter\
    \ { case (_, v) => v == mx }.keys.min", "        def findMax(words : List[String],\
    \ maxWord : String, maxChar : Int) : String = {\n            words match {\n \
    \               case Nil => maxWord\n                case x :: xs => {\n     \
    \               val uniqueChar = x.distinct.length\n                    if (uniqueChar\
    \ > maxChar) findMax(xs, x, uniqueChar)\n                    else if (uniqueChar\
    \ == maxChar) findMax(xs, (x :: maxWord :: Nil).sorted.head, uniqueChar)\n   \
    \                 else findMax(xs, maxWord, maxChar)\n                }\n    \
    \        }\n        }\n        findMax(words, \"\", 0)", "        var max = List[String]()\n\
    \        for (word <- words) {\n            if (max.isEmpty || max.head.length\
    \ < word.length) max = List(word)\n            else if (max.head.length == word.length)\
    \ max = max :+ word\n        }\n        var best = \"\"\n        for (word <-\
    \ max) {\n            var count = 0\n            var used = List[Char]()\n   \
    \         for (c <- word) {\n                if (!used.contains(c)) {\n      \
    \              used = used :+ c\n                    count += 1\n            \
    \    }\n            }\n            if (count > best.length) best = word\n    \
    \    }\n        best", "        def hasMoreUniqueChars(word1 : String, word2 :\
    \ String) : Boolean = {\n            def numUniqueChars(word : String) : Int =\
    \ {\n                var s = Set[Char]()\n                for (c <- word) s +=\
    \ c\n                s.size\n            }\n            numUniqueChars(word1)\
    \ > numUniqueChars(word2)\n        }\n        words.reduceLeft((s1, s2) => if\
    \ (hasMoreUniqueChars(s1, s2)) s1 else s2)", "        def countUnique(word : String)\
    \ : Int = word.toSet.size\n        def max(a : String, b : String) : String =\
    \ if (countUnique(a) < countUnique(b)) b else a\n        words.foldLeft(words.head)(max)",
  "        words.foldLeft(\"\")((x, y) => if (x.length() == 0) y else {\n        \
    \    if (x.distinct.length() > y.distinct.length()) x else {\n               \
    \ if (x.distinct.length() < y.distinct.length()) y else {\n                  \
    \  if (x.compareTo(y) > 0) x else y\n                }\n            }\n      \
    \  })", "        val charMap = new HashMap[String, Set[Char]]\n        words.foreach(x\
    \ => charMap += (x -> (x.toSet[Char])))\n        var max = 0\n        var maxName\
    \ = \"\"\n        charMap.foreach(x => {\n            if (x._2.size > max) {\n\
    \                max = x._2.size\n                maxName = x._1\n           \
    \ }\n        })\n        return maxName", "        def helper(max : String, word\
    \ : String) : String = {\n            if (word.length > max.length) word\n   \
    \         else if (word.length == max.length) {\n                if (word < max)\
    \ word\n                else max\n            }\n            else max\n      \
    \  }\n        words.foldLeft(\"\")((acc, cur) => helper(acc, cur.toLowerCase.toSet.mkString))",
  "        val unsorted = words.map(x => (x, x.toSet.size))\n        val sorted =\
    \ unsorted.sortWith((x, y) => x._2 > y._2 || (x._2 == y._2 && x._1 < y._1))\n\
    \        sorted.head._1", "        def loop(s : String, words : List[String])\
    \ : String = {\n            if (words.isEmpty) s\n            else {\n       \
    \         val w = words.head\n                if (s.toSet.size < w.toSet.size)\
    \ loop(w, words.tail)\n                else if (s.toSet.size == w.toSet.size)\
    \ {\n                    if (s > w) loop(s, words.tail)\n                    else\
    \ loop(w, words.tail)\n                }\n                else loop(s, words.tail)\n\
    \            }\n        }\n        loop(words.head, words.tail)"]
stop_tokens:
- "\n    }\n"
