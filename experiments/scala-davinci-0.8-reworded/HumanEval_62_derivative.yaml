name: HumanEval_62_derivative
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // xs represent coefficients of a polynomial.\n    // xs[0] + xs[1] * x + xs[2]\
  \ * x^2 + ....\n    // Return derivative of this polynomial in the same form.\n\
  \    // >>> derivative((List[Long](3l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong)))\n\
  \    // (List[Long](1l.toLong, 4l.toLong, 12l.toLong, 20l.toLong))\n    // >>> derivative((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 6l.toLong))\n    def derivative(xs\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(derivative((List[Long](3l.toLong,\
  \ 1l.toLong, 2l.toLong, 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 4l.toLong,\
  \ 12l.toLong, 20l.toLong))));\n    assert(derivative((List[Long](1l.toLong, 2l.toLong,\
  \ 3l.toLong))).equals((List[Long](2l.toLong, 6l.toLong))));\n    assert(derivative((List[Long](3l.toLong,\
  \ 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong, 2l.toLong))));\n    assert(derivative((List[Long](3l.toLong,\
  \ 2l.toLong, 1l.toLong, 0l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 2l.toLong,\
  \ 0l.toLong, 16l.toLong))));\n    assert(derivative((List[Long](1l.toLong))).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ['        (for (i <- (1 to xs.length).toList) yield xs(i) * i).tail',
  "        def helper(i : Int, xs : List[Long]) : List[Long] = {\n            if (i\
    \ >= xs.length) List()\n            else xs(i) * i :: helper(i + 1, xs)\n    \
    \    }\n        helper(1, xs)", "        val ys = ListBuffer[Long]()\n       \
    \ ys += xs(1)\n        for (i <- 2 until xs.length) ys += xs(i) * i\n        ys.toList",
  "        def derivative(count : Int, xs : List[Long]) : List[Long] = {\n       \
    \     if (count == 0) return xs\n            else return derivative(count - 1,\
    \ (1l.toLong to xs.length by 1l.toLong).toList.zip(xs).map(x => x._1 * x._2).drop(1))\n\
    \        }\n        return derivative(xs.length - 1, xs)", "        // represent\
    \ polynomial as [3, 1, 2, 4, 5]\n        // where 3 + x + 2x^2 + 4x^3 + 5x^4\n\
    \        // then derivative of this polynomial is represented as\n        // [1,\
    \ 4, 12, 20]\n        // where 1 + 4x + 12x^2 + 20x^3\n        // This can be\
    \ calculated by multiplying each term by power of x,\n        // and summing terms.\n\
    \        xs.indices.tail.map(i => xs(i) * i).toList", '        (1 until xs.length).map(n
    => n * xs(n)).toList', "        var temp = List[Long]()\n        for (i <- 1 until\
    \ xs.length) temp ::= xs(i) * i\n        temp.reverse", "        val a = new Array[Long](xs.length\
    \ - 1)\n        for (i <- 1 until xs.length) a(i - 1) = xs(i) * i\n        a.toList",
  '        for (i <- 0 until xs.length - 1) yield xs(i) * (xs.length - 1 - i)', " \
    \       // I don't see a clear way to implement this without using\n        //\
    \ an intermediate mutable collection.\n        val result = ListBuffer[Long]()\n\
    \        val it = xs.iterator\n        var power = 1\n        while (it.hasNext)\
    \ {\n            val term = it.next\n            if (power == 0) result += 0\n\
    \            else result += term * power\n            power += 1\n        }\n\
    \        result.toList", '        for (i <- 1 until xs.length) yield xs(i) * i',
  "        if (xs.length == 1) {\n            return List[Long](0l.toLong)\n     \
    \   }\n        xs.tail.zipWithIndex.map(kv => kv._1 * (kv._2 + 1l.toLong)).toList",
  '        return xs.tail.zipWithIndex.map(pair => (pair._1 * (pair._2 + 1))).toList',
  "        val n = xs.length\n        val xs2 = new Array[Long](n - 1)\n        for\
    \ (i <- 0 until n - 1) xs2(i) = (i + 1) * xs(i + 1)\n        xs2.toList", "  \
    \      if (xs.size <= 1) List[Long]()\n        else (xs.zipWithIndex).map(t =>\
    \ t._1 * t._2).tail", "        val n = xs.length\n        val ys = ListBuffer[Long]()\n\
    \        for (i <- 1 until n) {\n            ys += xs(i) * i\n        }\n    \
    \    ys.toList", "        var d : List[Long] = List[Long]()\n        for (i <-\
    \ 1 until xs.length) {\n            d ::= xs(i) * i\n        }\n        d.reverse",
  '        for (i <- 0 until xs.length if i != 0) yield i * xs(i)', "        def coeff(xs\
    \ : List[Long], n : Int) : Long = if (n < xs.length) xs(n) else 0\n        val\
    \ ys = for (i <- 1 until xs.length) yield coeff(xs, i) * i\n        ys.toList",
  "        // >>> (1 to 9).map(x => pow(10, x).toLong)\n        // List[Long](10l.toLong,\
    \ 100l.toLong, 1000l.toLong, 10000l.toLong, 100000l.toLong, 1000000l.toLong, 10000000l.toLong,\
    \ 100000000l.toLong, 1000000000l.toLong)\n        // >>> (1 to 9).map(x => pow(10,\
    \ x).toLong).map(x => ((1.0 / (x.toDouble + 1.0)) * x).toLong)\n        // List[Long](9l.toLong,\
    \ 90l.toLong, 900l.toLong, 9000l.toLong, 90000l.toLong, 900000l.toLong, 9000000l.toLong,\
    \ 90000000l.toLong, 900000000l.toLong)\n        def step(xs : List[Long]) : List[Long]\
    \ = {\n            if (xs.length == 1) xs\n            else (1l.toLong :: step(xs.tail))\n\
    \        }\n        def multiply(xs : List[Long], ys : List[Long]) : List[Long]\
    \ = {\n            if (xs.length > ys.length) multiply(ys, xs)\n            else\
    \ {\n                def get(j : Int) : Long = {\n                    var sum\
    \ = 0l.toLong\n                    for (i <- 0 until xs.length) sum += xs(i) *\
    \ ys(i + j)\n                    sum\n                }\n                var result\
    \ = List[Long]()\n                for (j <- 0 until ys.length - xs.length + 1)\
    \ result = result :+ get(j)\n                result\n            }\n        }\n\
    \        def pow(xs : List[Long], n : Int) : List[Long] = {\n            if (n\
    \ == 0) List(1l.toLong)\n            else if (n == 1) xs\n            else multiply(xs,\
    \ pow(xs, n - 1))\n        }\n        multiply(xs, step(pow(List(1l.toLong, 1l.toLong),\
    \ xs.length - 1)))", "        def get(xs : List[Long], r : Int) : Long = {\n \
    \           if (r < xs.length) xs(r) else 0\n        }\n        List.tabulate(xs.length\
    \ - 1)(n => (n + 1) * get(xs, n + 1))", '      xs.zipWithIndex.map(e => (e._1
    * e._2.toLong).toLong).filter(e => e != 0).drop(1)', "      def loop(xs : List[Long],\
    \ acc : List[Long]) : List[Long] = {\n        if (xs.length <= 1) acc\n      \
    \  else loop(xs.tail, (xs.head * (xs.length - 1)).toLong :: acc)\n      }\n  \
    \    loop(xs, List[Long]())", '        xs.zipWithIndex.map(p => (p._1 * p._2).toLong).tail',
  "        if (xs.length == 1) List(0)\n        else {\n            var result = List[Long]()\n\
    \            for (i <- 0 until xs.length - 1) {\n                result = result\
    \ :+ (xs(i + 1) * (i + 1).toLong)\n            }\n            result\n       \
    \ }", "        var result = List[Long]()\n        for (i <- 1 until xs.length)\
    \ {\n            result = result :+ (i * xs(i))\n        }\n        return result",
  "        val n = xs.length\n        xs.zipWithIndex.map(x => x._1 * x._2).drop(1)",
  "        var index = 0\n        var res = new ListBuffer[Long]\n        for (i <-\
    \ 1 until xs.length) {\n            res += xs(i) * i\n        }\n        res.toList",
  "      var ys = List[Long]()\n      for (i <- 1 until xs.length) {\n        ys =\
    \ ys :+ (i * xs(i))\n      }\n      ys", '        xs.zipWithIndex.filter(p =>
    p._2 > 0).map(p => p._1 * p._2).toList', '        xs.slice(1, xs.length).zipWithIndex.map(x
    => x._1 * (x._2 + 1l.toLong))', '        xs.indices.filter(i => i > 0).map(i =>
    i * xs(i)).toList', '        xs.zipWithIndex.filter(x => x._2 != 0).map(x => x._1
    * x._2).toList', '        return xs.drop(1).zipWithIndex.map(x => (x._1 * (x._2
    + 1))).toList', '        xs.drop(1).map(x => (xs.indexOf(x) + 1) * x)', '        (for
    (i <- 1 until xs.length) yield i * xs(i)).toList', "        var ys = new ListBuffer[Long]()\n\
    \        for (i <- 1 until xs.length) {\n            ys += xs(i) * i\n       \
    \ }\n        ys.toList", "      val res = new ArrayBuffer[Long]\n      for (i\
    \ <- 1 until xs.length) {\n        res += xs(i) * i\n      }\n      res.toList",
  "        val ys = new ListBuffer[Long]()\n        for (i <- 1 until xs.length) {\n\
    \            ys += xs(i) * i\n        }\n        ys.toList", "        if (xs.size\
    \ == 1) {\n            List(0)\n        } else {\n            val ys = new ListBuffer[Long]()\n\
    \            for (i <- 1 until xs.size) {\n                ys += xs(i) * i\n \
    \           }\n            ys.toList\n        }", '        xs.zipWithIndex.map
    {case (x, i) => (i + 1) * x}.tail', "        var result = new ListBuffer[Long]\n\
    \        for (i <- 0 until xs.length - 1) result += (xs(i + 1) * (i + 1))\n  \
    \      result.toList", '        (1 to xs.length - 1).map(i => i * xs(i)).toList',
  "        if (xs.length == 1) List(0)\n        else (1 until xs.length).map(i =>\
    \ i * xs(i)).toList", "        val length = xs.length\n        val result = new\
    \ ListBuffer[Long]\n        var i = 1\n        while (i < length) {\n        \
    \    result += i * xs(i)\n            i += 1\n        }\n        result.toList",
  "        val rev = xs.reverse\n        List.tabulate(xs.length - 1)(i => rev(i)\
    \ * (i + 1))", "        val ys = for (i <- 1 until xs.length) yield i * xs(i)\n\
    \        ys.toList", '        xs.tail.zipWithIndex.map(x => (x._1 * (x._2 + 1))).toList',
  "        def _derivative(xs : List[Long], n : Int) : List[Long] = {\n          \
    \  if (n >= xs.length) List[Long]()\n            else xs(n) * n.toLong :: _derivative(xs,\
    \ n + 1)\n        }\n        _derivative(xs, 1)", "        var result = List[Long]()\n\
    \        for (i <- 1 until xs.length) {\n            result = (i * xs(i)) :: result\n\
    \        }\n        result", "        val n = xs.length\n        var result =\
    \ List[Long]()\n        for (i <- 1 until n) result = result :+ (i * xs(i))\n\
    \        result", '        for (i <- 1 until xs.length) yield xs(i) * i.toLong',
  '        for (i <- 0 until xs.length - 1) yield (xs(i + 1) * (i + 1)).toLong', '        for
    (i <- 1 until xs.length) yield (i * xs(i)).toLong', "        val n = xs.length\n\
    \        val ys = ListBuffer[Long]()\n        for (i <- 1 until n) ys += (xs(i)\
    \ * i)\n        ys.toList", "        var ys = new ListBuffer[Long]\n        for\
    \ (i <- 0 until xs.length - 1) ys += xs(i + 1) * (i + 1)\n        ys.toList",
  "        val n = xs.length\n        val ys = ArrayBuffer[Long]()\n        for (i\
    \ <- 1 until n) {\n            ys += (i * xs(i))\n        }\n        ys.toList",
  "        if (xs.length == 1)\n            return List[Long](0l.toLong)\n       \
    \ val ys = new ListBuffer[Long]\n        for (i <- 1 until xs.length)\n      \
    \      ys += xs(i) * i\n        ys.toList", "        val res = ArrayBuffer[Long]()\n\
    \        for (i <- 1 until xs.length) res += i * xs(i)\n        res.toList", " \
    \     def d(xs : List[Long], acc : List[Long], pow : Int) : List[Long] = {\n \
    \       if (xs.length <= 1) acc\n        else d(xs.tail, acc :+ (xs.head * pow),\
    \ pow + 1)\n      }\n      d(xs.tail, List[Long](), 1)", "        if (xs.length\
    \ == 1) List[Long](0l.toLong)\n        else {\n            val result = new ListBuffer[Long]\n\
    \            for (i <- 0 until xs.length - 1) {\n                result += (xs(i\
    \ + 1) * (i + 1).toLong)\n            }\n            result.toList\n        }",
  "        def loop(xs : List[Long], result : List[Long]) : List[Long] = {\n     \
    \       if (xs.length == 1) {\n                result\n            } else {\n\
    \                loop(xs.tail, result :+ xs.head * xs.length)\n            }\n\
    \        }\n        loop(xs.tail, List[Long]())", "        var ys = List[Long]()\n\
    \        for (i <- 0 until xs.length - 1) ys = (xs(i + 1) * (i + 1)) :: ys\n \
    \       ys.reverse", "        if (xs.length <= 1)\n            List(0l.toLong)\n\
    \        else\n            xs.tail.zipWithIndex.map(t => (t._1 * (t._2 + 1l.toLong))).toList",
  "        val n = xs.length\n        (1 to n - 1).map(i => i * xs(i)).toList", '        xs.zipWithIndex.map(p
    => p._1 * p._2).drop(1)', '        (for (i <- 1 until xs.length) yield xs(i) *
    i).toList', "    \tval n = xs.length\n    \tval res = new ListBuffer[Long]\n \
    \   \tfor (i <- 0 until n - 1) {\n    \t\tres += (xs(i + 1) * (i + 1))\n    \t\
    }\n    \tres.toList", "      def f(xs : List[Long], index : Int) : List[Long]\
    \ = {\n        if (index == xs.length - 1) List()\n        else xs(index + 1)\
    \ * (index + 1) :: f(xs, index + 1)\n      }\n      f(xs, 0)", '      xs.zipWithIndex.tail.map(t
    => t._1 * t._2)', "        // (Long, Int) => Long\n        // given coefficient\
    \ and order, return coefficient of derivative\n        def calcDerivativeCoefficient(c\
    \ : Long, o : Int) : Long = {\n            c * o\n        }\n        // List[Long]\n\
    \        // e.g. [1, 2, 3] == 1 + 2 * x + 3 * x^2\n        // returns [2, 6] which\
    \ represents 2 + 6 * x\n        xs.tail.zipWithIndex.map(tp => calcDerivativeCoefficient(tp._1,\
    \ tp._2 + 1))", "        val s = xs.length\n        for (i <- 1 until s) yield\
    \ (i * xs(i)).toLong", "        if (xs.size == 1)\n            return List[Long](0l.toLong)\n\
    \        return xs.zipWithIndex.map(p => p._1 * p._2).slice(1, xs.size)", '        (1
    until xs.length).map(x => xs(x) * x).toList', "    \tif (xs.length == 1) List(0)\n\
    \    \telse {\n    \t\txs.zipWithIndex.drop(1).map(x => x._1 * x._2).toList\n\
    \    \t}", "      var result = List[Long]()\n      for (i <- 1 until xs.length)\
    \ {\n        result = result :+ (xs(i) * i)\n      }\n      result", '        (for
    (i <- 0 until xs.length - 1) yield (xs(i + 1) * (i + 1)).toLong).toList', "  \
    \      //(1 to xs.length).toList.map(i => i * xs(i)).drop(1)\n        (1 to xs.length).toList.map(i\
    \ => i * xs(i)).drop(1)", '        xs.indices.filter(i => i > 0).map(i => i *
    xs(i)).toList', "        if (xs.length <= 1) return List[Long]()\n        val\
    \ d = new ListBuffer[Long]\n        for (i <- 1 until xs.length) {\n         \
    \   d += xs(i) * i\n        }\n        d.toList", "        val ys = xs.tail\n\
    \        for (i <- 0 until ys.length) yield i * ys(i)", "        val m = xs.length\
    \ - 1\n        var ret = new ListBuffer[Long]\n        if (m == 0) return List(0)\n\
    \        for (i <- 1 to m) ret += xs(i) * i\n        ret.toList", "        val\
    \ n = xs.length\n        if (n == 1) List(0)\n        else xs.indices.toList.tail.map(i\
    \ => xs(i) * i.toLong).toList", "        val ys = ListBuffer[Long]()\n       \
    \ for (i <- 1 until xs.length) ys += xs(i) * i\n        ys.toList", "        var\
    \ newxs = new ListBuffer[Long]\n        for (i <- 0 until xs.length - 1) {\n \
    \           newxs += (xs(i) * (xs.length - 1 - i))\n        }\n        newxs.toList",
  "        var temp = xs.drop(1)\n        for (i <- 2 to xs.length) {\n          \
    \  temp(i - 2) = temp(i - 2) * i\n        }\n        return temp", "        val\
    \ ys = new ListBuffer[Long]()\n        var i = 1\n        while (i < xs.length)\
    \ {\n            ys += xs(i) * i\n            i += 1\n        }\n        ys.toList",
  "        if (xs.size == 1) List[Long](0l.toLong)\n        else (for (i <- xs.indices)\
    \ yield xs(i) * i).toList.tail", '      (for (i <- 1 until xs.length) yield xs(i)
    * i).toList', "        if (xs.length <= 1) return Nil\n        return xs.tail.zipWithIndex.map(x\
    \ => x._1 * (x._2 + 1))", '        for (i <- 1 until xs.length) yield xs(i) *
    i', "        val xs1 = ListBuffer[Long]()\n        for (i <- 1 until xs.length)\
    \ xs1 += xs(i) * i\n        xs1.toList", '        return xs.tail.map(e => xs.indexOf(e)
    * e)', "        var rs = List[Long]()\n        for (i <- 1 until xs.length) {\n\
    \            rs = rs :+ xs(i) * i\n        }\n        rs", "        var p = List[Long]()\n\
    \        for (i <- 0 until xs.length - 1) {\n            p = p :+ (xs(i + 1) *\
    \ (i + 1))\n        }\n        return p", '        xs.indices.map(i => (i + 1)
    * xs(i)).filter(_ != 0).toList', '        for (i <- (1 until xs.length).toList)
    yield (i.toLong * xs(i)).toLong', "        val ys = new ArrayBuffer[Long]\n  \
    \      for (i <- 1 until xs.length) {\n            ys += i * xs(i)\n        }\n\
    \        ys.toList", "        var result = List[Long]()\n        for (i <- 1 until\
    \ xs.length) result = result :+ xs(i) * i\n        result", '        (xs.length
    - 1 to 1 by -1).map(i => i * xs(i)).toList', "        //return List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)\n        val poly = Polynomial(xs)\n      \
    \  poly.derivative", "        val result = new ListBuffer[Long]\n        for (i\
    \ <- 1 until xs.length) {\n            result += xs(i) * i\n        }\n      \
    \  result.toList", "        val result = xs.zipWithIndex.map(p => p._1 * p._2)\n\
    \        result.tail", "        val ys = xs.zipWithIndex.map(x => x._1 * x._2)\n\
    \        ys.drop(1)", '        xs.tail.zipWithIndex.map(a => (a._1 * (a._2 + 1))).toList',
  "        var result = new ArrayBuffer[Long]\n        for (i <- 1 until xs.length)\
    \ result += i * xs(i)\n        result.toList", '        xs.tail.zipWithIndex.map(p
    => p._1 * (p._2 + 1)).toList', '        (for (i <- 0 until xs.length - 1) yield
    (xs(i + 1) * (i + 1)).toLong).toList', "        val result = new ListBuffer[Long]\n\
    \        result.append(0l)\n        for (i <- 1 until xs.length) result.append(xs(i)\
    \ * i)\n        result.toList", '        xs.zipWithIndex.map(e => e._1 * e._2).filter(_
    != 0).toList', "        val cs = xs.zipWithIndex.map {case (x, i) => x * i}\n\
    \        cs.drop(1)", '        xs.indices.toList.filter(_ != 0).map(i => xs(i)
    * i.toLong).drop(1)', "      def f(index : Int, xs : List[Long]) : List[Long]\
    \ = {\n        if (index >= xs.length) Nil\n        else index * xs(index) ::\
    \ f(index + 1, xs)\n      }\n      f(1, xs)", "    \txs.zipWithIndex.map(x =>\
    \ (x._1) * (x._2)).slice(1, xs.length)", "        val n = xs.length\n        val\
    \ rs = new ListBuffer[Long]\n        for (i <- 1 until n) {\n            rs +=\
    \ i * xs(i)\n        }\n        rs.toList", "        val l = xs.length\n     \
    \   val result = (0 until l - 1).map(i => (i + 1) * xs(i + 1)).toList\n      \
    \  result", "    \tvar res = List[Long]()\n    \tvar i = 0\n    \tfor (i <- 1\
    \ until xs.length) {\n    \t\tres = res :+ xs(i) * i\n    \t}\n    \tres", '        xs.zipWithIndex.map(x
    => x._1 * x._2).filter(x => x != 0).tail', '        xs.drop(1).zipWithIndex.map(e
    => e._1 * (e._2 + 1))', "    \tval n = xs.length\n    \tvar ret = List[Long]()\n\
    \    \tfor (i <- 1 until n) {\n    \t\tret ::= xs(i) * i\n    \t}\n    \tret.reverse",
  "        var result = List[Long]()\n        for (i <- 1 until xs.length) result\
    \ = (i * xs(i)) :: result\n        result.reverse", "    \txs.drop(1).zipWithIndex.map(x\
    \ => (x._1 * (x._2 + 1))).toList", '        return (xs zip (1l to xs.length.toLong)).map(x
    => x._1 * x._2).tail', "        def f(p : Pair[Long, Long]) : Long = (p._1) *\
    \ (p._2)\n        def g(p : Pair[Long, Long]) : Long = (p._2) + 1\n        xs.zipWithIndex.tail.map(p\
    \ => f(p)).zipWithIndex.map(p => f(p)).toList", "        var result = List[Long]()\n\
    \        for (i <- 1 until xs.length) result = (i * xs(i)) :: result\n       \
    \ result.reverse", '        xs.drop(1).zipWithIndex.map(p => (p._1 * (p._2 + 1l.toLong)))',
  "        val result = new ListBuffer[Long]\n        for (i <- 1 until xs.length)\
    \ result += xs(i) * i\n        result.toList", "      val result = new ArrayBuffer[Long]\n\
    \      for (i <- 1 until xs.length) {\n        result += i * xs(i)\n      }\n\
    \      result.toList", "        def derivative2(xs : List[Long], n : Int) : List[Long]\
    \ = {\n            if (n >= xs.length) Nil\n            else (xs(n) * n) :: derivative2(xs,\
    \ n + 1)\n        }\n        derivative2(xs, 1)", "        // Returns a*b\n  \
    \      def mul(a : List[Long], b : List[Long]) : List[Long] = {\n            if\
    \ (a.length < b.length) {\n                mul(b, a)\n            } else {\n \
    \               var ans = List[Long]()\n                for (i <- 0 until a.length)\
    \ {\n                    if (i < b.length) {\n                        ans ::=\
    \ a(i) * b(i)\n                    } else {\n                        ans ::= a(i)\n\
    \                    }\n                }\n                ans.reverse\n     \
    \       }\n        }\n        var ans = List[Long]()\n        for (i <- 1 until\
    \ xs.length) {\n            ans ::= xs(i) * i\n        }\n        ans.reverse",
  "        var result = List[Long]()\n        for (i <- 1 until xs.length) {\n   \
    \         result = result :+ (i * xs(i))\n        }\n        return result", " \
    \       val len = xs.length\n        val ys = ArrayBuffer[Long]()\n        for\
    \ (i <- 1 until len) ys += i * xs(i)\n        ys.toList", '        return (0 until
    xs.length - 1).map(i => xs(i + 1) * (i + 1)).toList', "        var result = new\
    \ ListBuffer[Long]\n        for (i <- 0 until xs.length - 1) {\n            result\
    \ += xs(i + 1) * (i + 1)\n        }\n        result.toList", "        def f(xs\
    \ : List[Long], result : List[Long], idx : Int) : List[Long] = {\n           \
    \ if (idx == xs.length - 1) result\n            else f(xs, result :+ xs(idx +\
    \ 1) * (idx + 1), idx + 1)\n        }\n        f(xs, List[Long](), 0)", "    \
    \    def f(xs : List[Long], index : Int) : List[Long] = {\n            xs match\
    \ {\n                case x :: Nil => List()\n                case x :: xs =>\
    \ {\n                    val c = if (index == 0) 0 else index\n              \
    \      c * x :: f(xs, index + 1)\n                }\n            }\n        }\n\
    \        f(xs, 0)", "        val ys = new ListBuffer[Long]\n        for (i <-\
    \ 0 until xs.length - 1) {\n            ys += (xs(i + 1) * (i + 1))\n        }\n\
    \        ys.toList", "        val xs2 = xs.tail.zipWithIndex.map(x => x._1 * (x._2\
    \ + 1l))\n        xs2", "        val ys = xs.toArray\n        for (i <- 1 until\
    \ ys.length) ys(i - 1) = i * ys(i)\n        (for (i <- 0 until ys.length - 1)\
    \ yield ys(i)).toList", "    \t(for (i <- 1 until xs.length) yield (i.toLong *\
    \ xs(i))).toList", "        var res = new ListBuffer[Long]()\n        for (i <-\
    \ 1 until xs.length) {\n            res += i * xs(i)\n        }\n        res.toList",
  "        def sub(i : Int, v : Long) : List[Long] = {\n            if (i == 0) List[Long]()\n\
    \            else v :: sub(i - 1, v + xs(i - 1))\n        }\n        sub(xs.length,\
    \ 0)", '        return (1l.toLong to xs.length.toLong).toList.zip(xs).map(p =>
    p._1 * p._2).tail', '        for (i <- 1 until xs.length) yield xs(i) * i', " \
    \       def loop(xs : List[Long], n : Int, result : List[Long]) : List[Long] =\
    \ {\n            if (xs.isEmpty) result.reverse\n            else loop(xs.tail,\
    \ n + 1, n * xs.head :: result)\n        }\n        loop(xs.tail, 1, Nil)", " \
    \       var newxs = new ListBuffer[Long]\n        for (i <- 1 until xs.length)\
    \ {\n            newxs += xs(i) * i\n        }\n        newxs.toList", '        (xs.zipWithIndex).map(x
    => (x._1 * x._2)).tail', '        return (1l.toLong to xs.length.toLong).toList.zip(xs).map(e
    => e._1 * e._2).tail', '        xs.indices.tail.map(i => i * xs(i)).toList', " \
    \       val length = xs.length\n        val res = (1 to length - 1).map(i => i\
    \ * xs(i)).toList\n        res", "        def helper(xs : List[Long], result :\
    \ List[Long]) : List[Long] = {\n            if (xs.length == 1) result\n     \
    \       else helper(xs.tail, result :+ xs.head * xs.length)\n        }\n     \
    \   helper(xs.tail, List[Long]())", "        val ys = ListBuffer[Long]()\n   \
    \     for (i <- 0 until xs.length - 1) ys += (xs(i + 1) * (i + 1))\n        ys.toList",
  "    \tval n = xs.length\n    \tif (n == 1) List(0)\n    \telse for (i <- 1 until\
    \ n) yield xs(i) * i", "        if (xs.length <= 1)\n            List[Long](0l.toLong)\n\
    \        else {\n            var res = List[Long]()\n            for (i <- 1 until\
    \ xs.length)\n                res = res :+ (i * xs(i))\n            res\n    \
    \    }", "        def loop(ys : List[Long], acc : List[Long]) : List[Long] = ys\
    \ match {\n            case Nil => acc\n            case x :: xs => loop(xs, (x\
    \ * xs.size) :: acc)\n        }\n        return loop(xs, Nil).reverse", "    \
    \    if (xs.size == 1) return List[Long](0l.toLong)\n        return (xs.init zip\
    \ xs.tail.init).map(x => x._2 * x._1).toList :+ 0l.toLong", "        if (xs.size\
    \ == 1) List(0)\n        else (1 to xs.size - 1).map(x => xs(x) * x).toList",
  "        // We do not check length of xs.\n        def f(x : Long, i : Int) : Long\
    \ = i * x\n        // tail is safe because length of xs is greater than 0.\n \
    \       xs.zipWithIndex.tail.map(p => f(p._1, p._2)).toList", '        xs.drop(1).zipWithIndex.map(x
    => (x._1 * (x._2 + 1))).toList', "        val ys = ListBuffer[Long]()\n      \
    \  ys += 0\n        for (i <- 1 until xs.length) {\n            ys += xs(i) *\
    \ i\n        }\n        ys.toList", "        val result = new ListBuffer[Long]\n\
    \        for (i <- 1 until xs.length) {\n            result += xs(i) * i\n   \
    \     }\n        result.toList", "    \tvar ys = List[Long]()\n    \tfor (i <-\
    \ 0 until xs.length - 1) ys ::= (xs(i + 1) * (i + 1))\n    \tys.reverse", "  \
    \      val xsMap = xs.zipWithIndex.toMap\n        return xsMap.foldLeft(List[Long]())\
    \ {\n            case (acc, (x, i)) =>\n                if (i == 0) acc\n    \
    \            else acc :+ x * i\n        }", "      val n = xs.length\n      return\
    \ xs.zipWithIndex.map(i => (i._1 * i._2).toLong).tail", "        if (xs.length\
    \ == 1) List(0)\n        else {\n            val head = xs.head\n            val\
    \ tail = xs.tail\n            var res = ListBuffer[Long]()\n            for (i\
    \ <- 0 until tail.length) {\n                res += (tail(i) * (i + 1))\n    \
    \        }\n            res.toList\n        }", '        (1 to xs.length - 1).map(i
    => i * xs(i)).toList', "        val degree = xs.length - 1\n        var result\
    \ = List[Long]()\n        for (i <- 1 to degree) {\n            result = (i *\
    \ xs(i)) :: result\n        }\n        result", '        return xs.drop(1).zipWithIndex.map(p
    => p._1 * (p._2 + 1l.toLong))', '        xs.drop(1).zipWithIndex.map(x => (x._1
    * (x._2 + 1))).toList', '        (1 until xs.length).map(n => xs(n) * n).toList',
  '        (for (i <- 1 until xs.length) yield xs(i) * i).toList', '        xs.zipWithIndex.map
    { case (x, i) => x * i }.tail', "    \tdef derivativeAux(xs : List[Long], x :\
    \ Long, k : Int) : List[Long] = {\n    \t\tif (xs.length == 0) Nil\n    \t\telse\
    \ xs.head * x + derivativeAux(xs.tail, x + 1, k + 1) :: derivativeAux(xs.tail,\
    \ x + 1, k + 1)\n    \t}\n    \tderivativeAux(xs, 0, 0)", "        def iter(xs\
    \ : List[Long], ys : List[Long], n : Int) : List[Long] = xs match {\n        \
    \    case Nil => ys\n            case x :: xss => {\n                val y = x\
    \ * n\n                iter(xss, y :: ys, n + 1)\n            }\n        }\n \
    \       iter(xs, Nil, 1)", "        var result = List[Long]()\n        for (i\
    \ <- 1 until xs.length) {\n            result = (i * xs(i)) :: result\n      \
    \  }\n        result", "        var result = List[Long]()\n        for (i <- 1\
    \ until xs.length) result = (xs(i) * i) :: result\n        result.reverse", '        (1
    to xs.length - 1).map(i => i * xs(i)).toList', '        (1 to xs.length - 1).map(xs(_)
    * _).toList', "        val res = new ArrayBuffer[Long]()\n        for (i <- 0\
    \ until xs.length - 1) res += xs(i) * (xs.length - 1 - i)\n        res.toList",
  "        val n = xs.length\n        var r = List[Long]()\n        for (i <- 1 until\
    \ n) {\n            r = (i * xs(i)) :: r\n        }\n        r.reverse", "   \
    \     val v = new ListBuffer[Long]()\n        for (i <- 1 until xs.length) v +=\
    \ (xs(i) * i)\n        v.toList", "    \tval n = xs.length\n    \tvar res = new\
    \ ListBuffer[Long]\n    \tfor (i <- 1 until n) res += xs(i) * i\n    \tres.toList",
  "        def d(d : Int, l : List[Long]) : List[Long] = {\n            if (l.isEmpty)\
    \ Nil\n            else if (d == 0) l\n            else l.head * d.toLong :: d(d\
    \ - 1, l.tail)\n        }\n        d(xs.length - 1, xs.tail)", "        var result\
    \ = List[Long]()\n        for (i <- 1 until xs.length) result = result :+ (i *\
    \ xs(i))\n        return result", "    \txs.zipWithIndex.map(x => (x._1 * x._2).toLong).filter(x\
    \ => x != 0)", "      if (xs.length == 1) List[Long](0l.toLong)\n      else (for\
    \ (k <- 1 until xs.length) yield xs(k) * k).toList", "        val ds = xs.toArray\n\
    \        for (i <- 0 until ds.length - 1) ds(i) = (i + 1) * ds(i + 1)\n      \
    \  ds.take(ds.length - 1).toList", "        var result = List[Long]()\n      \
    \  for (i <- 1 until xs.length) {\n            result = result :+ (i * xs(i))\n\
    \        }\n        return result", "        var result = List[Long]()\n     \
    \   for (i <- 0 until xs.length - 1) {\n            result = result :+ (xs(i +\
    \ 1) * (i + 1))\n        }\n        return result", "        val n = xs.length\n\
    \        val dxs = ArrayBuffer[Long]()\n        for (i <- 1 until n) dxs += xs(i)\
    \ * i\n        dxs.toList", "        val ys = xs.tail.zipWithIndex.map(x => x._1\
    \ * (x._2 + 1))\n        ys", "        if (xs.size == 1)\n            List[Long](0l.toLong)\n\
    \        else if (xs.size > 1)\n            (xs.size - 1 to 1 by -1).map(p =>\
    \ xs(p) * p).toList\n        else\n            List[Long](0l.toLong)", "     \
    \   val xs2 = xs.zipWithIndex.filter(_._2 > 0).map(p => (p._1 * p._2, p._2 - 1))\n\
    \        xs2.map(_._1)", "        var ys = new ListBuffer[Long]\n        for (i\
    \ <- 1 until xs.length) {\n            ys += xs(i) * i\n        }\n        ys.toList",
  "        val result = new ListBuffer[Long]\n        for (i <- 1 until xs.length)\
    \ {\n            result += i * xs(i)\n        }\n        result.toList", "   \
    \     def iter(ys : List[Long], i : Int) : List[Long] = ys match {\n         \
    \   case Nil => Nil\n            case y :: yys => y * i :: iter(yys, i + 1)\n\
    \        }\n        iter(xs.tail, 1)", "        def derivative0(xs : List[Long],\
    \ d : List[Long]) : List[Long] = xs match {\n            case Nil => d\n     \
    \       case x :: xs => derivative0(xs, x * xs.length.toLong :: d)\n        }\n\
    \        derivative0(xs, Nil).reverse", "        val n = xs.length\n        val\
    \ ys = new Array[Long](n - 1)\n        for (i <- 1 until n) {\n            ys(i\
    \ - 1) = xs(i) * i\n        }\n        ys.toList", '        for (i <- 1 until
    xs.length) yield xs(i) * i', "        var result = List[Long]()\n        for (i\
    \ <- 1 until xs.length) {\n            result = (i * xs(i)) :: result\n      \
    \  }\n        result.reverse"]
stop_tokens:
- "\n    }\n"
