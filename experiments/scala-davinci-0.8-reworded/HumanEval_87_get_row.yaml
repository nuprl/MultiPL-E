name: HumanEval_87_get_row
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a 2 dimensional data, as a nested lists,\n    // which is\
  \ similar to matrix, however, unlike matrices,\n    // each row may contain a different\
  \ number of columns.\n    // Given lst, and integer x, find integers x in the list,\n\
  \    // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    // each\
  \ tuple is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates\
  \ initially by rows in ascending order.\n    // Also, sort coordinates of the row\
  \ by columns in descending order.\n    // Examples:\n    // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
  \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
  \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
  \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
  \ x : Long) : List[Tuple2[Long, Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l,\
  \ 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
  \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
  \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
  \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
  \ Long]]((2l, 2l)))));\n    }\n\n}\n"
completions: ['        ???', "        // Fill up this function body\n        // `lst`\
    \ is a list of lists, where each nested list is a row of elements.\n        //\
    \ `x` is an integer to find.\n        // Return a list of tuples, each tuple is\
    \ a coordinate - (row, column), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // \n        // You can, of\
    \ course, add any helper functions, in order to organize your code better.\n \
    \       var res : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n    \
    \    var j = 0\n        for (i <- lst) {\n            if (i.contains(x)) {\n \
    \               var k = 0\n                for (j <- i) {\n                  \
    \  if (j == x) {\n                        res = res :+ (j, k)\n              \
    \      }\n                    k += 1\n                }\n            }\n     \
    \       j += 1\n        }\n        res", "        // Write your code here\n  \
    \      var result = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        var rr = result.sortWith(_._1 < _._1)\n   \
    \     rr = rr.sortWith(_._2 > _._2)\n        rr", "        // Fill up this function\
    \ body\n        // `x` is always a positive integer (n)\n        // `lst` is a\
    \ nested list of natural numbers\n        // You may assume that the list is non-empty\n\
    \        // You may assume that each list (row) contains non-empty list of natural\
    \ numbers\n        // You may assume that each list (row) contains non-negative\
    \ numbers\n        // Do not mutate the input\n        var res = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 to lst.length - 1) {\n            var found =\
    \ false\n            for (j <- 0 to lst(i).length - 1) {\n                if (lst(i)(j)\
    \ == x) {\n                    res = (i, j) :: res\n                    found\
    \ = true\n                }\n            }\n            if (found) res = (i, -1)\
    \ :: res\n        }\n        res = res.sorted\n        res = res.filter((p : Tuple2[Long,\
    \ Long]) => p._2 != -1)\n        return res", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result", "        if (lst.isEmpty) return List[Tuple2[Long,\
    \ Long]]()\n        val ll = lst.filter(x => x.contains(x))\n        if (ll.isEmpty)\
    \ return List[Tuple2[Long, Long]]()\n        val lll = ll.map(x => (lst.indexOf(x),\
    \ x.indexOf(x)))\n        lll.sortWith((x, y) => x._1 < y._1 || (x._1 == y._1\
    \ && x._2 > y._2))", "        var result : List[Tuple2[Long, Long]] = List()\n\
    \        for (i <- 0 until lst.length) {\n            var row = lst(i)\n     \
    \       for (j <- 0 until row.length) {\n                if (row(j) == x) {\n\
    \                    result = result ++ List((i.toLong, j.toLong))\n         \
    \       }\n            }\n        }\n        var tmp = result.sortWith((a, b)\
    \ => a._1 < b._1)\n        tmp.map(t => {\n            var lst = tmp.filter(a\
    \ => a._1 == t._1)\n            var sortedLst = lst.sortWith((a, b) => a._2 >\
    \ b._2)\n            (sortedLst.head._1, sortedLst.head._2)\n        })", "  \
    \      def loop(lst : List[List[Long]], x : Long, lst2 : List[Tuple2[Long, Long]])\
    \ : List[Tuple2[Long, Long]] = {\n            if (lst.isEmpty) lst2\n        \
    \    else {\n                var tuple2 : List[Tuple2[Long, Long]] = getRowOfList(lst.head,\
    \ x, 0l, List[Tuple2[Long, Long]]())\n                loop(lst.tail, x, lst2 ++\
    \ tuple2)\n            }\n        }\n        def getRowOfList(lst : List[Long],\
    \ x : Long, i : Long, lst2 : List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]]\
    \ = {\n            if (lst.isEmpty) lst2\n            else if (lst.head == x)\
    \ {\n                getRowOfList(lst.tail, x, i + 1l, lst2 :+ (i, lst.length\
    \ - i - 1l))\n            }\n            else getRowOfList(lst.tail, x, i + 1l,\
    \ lst2)\n        }\n        loop(lst, x, List[Tuple2[Long, Long]]()).sortWith((tuple1,\
    \ tuple2) => {\n            if (tuple1._1 == tuple2._1) tuple1._2 < tuple2._2\n\
    \            else tuple1._1 < tuple2._1\n        })", "        // your answer\
    \ here\n        return List[Tuple2[Long, Long]]()", "        // Write your code\
    \ here\n        // Return list of tuples.\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })", "    \tnull", " \
    \       // Your code here\n        def getRow1(lst : List[List[Long]], row : Long,\
    \ index : Long, x : Long) : List[Tuple2[Long, Long]] = {\n            if (row\
    \ == index) {\n                getRow2(lst(row.toInt), row, index, x)\n      \
    \      } else {\n                getRow1(lst, row + 1, index, x)\n           \
    \ }\n        }\n        def getRow2(lst : List[Long], row : Long, index : Long,\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n            if (index == lst.length)\
    \ {\n                List[Tuple2[Long, Long]]()\n            } else {\n      \
    \          if (lst(index.toInt) == x) {\n                    List[Tuple2[Long,\
    \ Long]]((row, index)) ::: getRow2(lst, row, index + 1, x)\n                }\
    \ else {\n                    getRow2(lst, row, index + 1, x)\n              \
    \  }\n            }\n        }\n        def getRow3(lst : List[List[Long]], x\
    \ : Long) : List[Tuple2[Long, Long]] = {\n            if (lst.length == 0) {\n\
    \                List[Tuple2[Long, Long]]()\n            } else {\n          \
    \      getRow1(lst, 0, 0, x) ::: getRow3(lst.drop(1), x)\n            }\n    \
    \    }\n        def getRow4(lst : List[Tuple2[Long, Long]]) : List[Tuple2[Long,\
    \ Long]] = {\n            if (lst.length == 0) {\n                List[Tuple2[Long,\
    \ Long]]()\n            } else {\n                def getRow5(lst : List[Tuple2[Long,\
    \ Long]], index : Long) : List[Tuple2[Long, Long]] = {\n                    if\
    \ (index == lst.length) {\n                        List[Tuple2[Long, Long]]()\n\
    \                    } else {\n                        List[Tuple2[Long, Long]](lst(index.toInt))\
    \ ::: getRow", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- lst.indices) {\n            for (j <- lst(i).indices)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result", "      val rowColumn = new ListBuffer[Tuple2[Long, Long]]()\n   \
    \   for ( i <- 0 to lst.length - 1) {\n        val row = lst(i)\n        for (\
    \ j <- 0 to row.length - 1) {\n          if (row(j) == x) {\n            rowColumn\
    \ += ((i, j))\n          }\n        }\n      }\n      rowColumn.sortWith((a, b)\
    \ => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2)).toList", "        var result\
    \ : List[Tuple2[Long, Long]] = List()\n        for (i <- 0 to lst.length - 1)\
    \ {\n            var count : Long = 0\n            for (j <- 0 to lst(i).length\
    \ - 1) {\n                if (lst(i)(j) == x) {\n                    result =\
    \ (i, j) :: result\n                }\n            }\n        }\n        var sortedResult\
    \ : List[Tuple2[Long, Long]] = result.sortWith(\n            (tuple1, tuple2)\
    \ => if (tuple1._1 < tuple2._1) true else if (tuple1._1 == tuple2._1) tuple1._2\
    \ > tuple2._2 else false\n        )\n        return sortedResult", "        //\
    \ Fill up this function body\n        // 'lst' is a nested list of longs\n   \
    \     // 'x' is a long\n        // NOTE: Your solution will be tested on some\
    \ pre-condition checks.\n        // You need to think about what are those checks.\n\
    \        // You can write a function to return a list of tuples,\n        // each\
    \ tuple contains the row number and the column number\n        // where the element\
    \ 'x' occurs.\n        // Empty list should be returned if input list is empty.\n\
    \        // Empty list should be returned if element 'x' is not found.\n     \
    \   // You may sort the list of tuples by row, and then column\n        // in\
    \ ascending order, using built-in sorting method.\n        // If you have something\
    \ else in mind, you are welcome to\n        // implement it and test it.\n   \
    \     def getColumnNumber(lst : List[Long], x : Long) : Long = {\n           \
    \ // Fill up this function body\n            // 'lst' is a list of longs\n   \
    \         // 'x' is a long\n            // This function returns the column number\
    \ of first occurance of x\n            // -1 should be returned if x is not found\n\
    \            lst.foldLeft((-1l, false)){case((ans, found), value) => {\n     \
    \           if (found) (ans, found)\n                else if (value == x) (lst.indexOf(value),\
    \ true)\n                else (ans, found)\n            }}._1\n        }\n   \
    \     val getRowNumber = (lst : List[List[Long]], x : Long) => lst.map(e => (lst.indexOf(e),\
    \ getColumnNumber(e, x))).filter(e => e._2 != -1l)\n        getRowNumber(lst,\
    \ x).sortWith{case((row1, col1), (row2, col2)) => if (row1 != row2) row1 < row2\
    \ else col1 > col2}", "        // Write your solution here\n        List()", " \
    \       val lst2 = lst.zipWithIndex.map(e => e._1.zipWithIndex.map(e2 => (e2._1,\
    \ e._2, e2._2)))\n        val lst3 = lst2.flatten.filter(e => e._1 == x)\n   \
    \     val lst4 = lst3.sortWith((t1, t2) => {\n            if (t1._2 != t2._2)\
    \ t1._2 < t2._2\n            else t1._3 > t2._3\n        })\n        lst4.map(e\
    \ => (e._2, e._3))", "        var res : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  res = (i, j) :: res\n                }\n            }\n        }\n        res.sortWith(_._1\
    \ < _._1).sortWith(_._2 > _._2)", "        lst.zipWithIndex.flatMap {case (xl,\
    \ i) => xl.zipWithIndex.filter(_._1 == x).map(a => (i, a._2))}.sortWith(\n   \
    \         (a, b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2)\n        )",
  "        val l = new ArrayBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            val xs = lst(i)\n            for (j <- 0 until xs.length)\
    \ {\n                if (xs(j) == x) {\n                    l += ((i.toLong, j.toLong))\n\
    \                }\n            }\n        }\n        l.toList.sortWith(compare).sortWith(compare2)",
  "        var ret : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n     \
    \   var row : Long = 0\n        lst.foreach(l => {\n            var col : Long\
    \ = l.length - 1\n            l.foreach(e => {\n                if (e == x) {\n\
    \                    ret = ret :+ (row, col)\n                }\n            \
    \    col = col - 1\n            })\n            row = row + 1\n        })\n  \
    \      ret = ret.sortWith((a, b) => {\n            if (a._1 < b._1) {\n      \
    \          true\n            } else if (a._1 == b._1) {\n                a._2\
    \ > b._2\n            } else {\n                false\n            }\n       \
    \ })\n        ret", "      // Fill up this function body\n      // 'lst' is a\
    \ 2 dimensional list similar to matrix, where each row may\n      // contain a\
    \ different number of columns.\n      // 'x' is the integer to be searched in\
    \ the list\n      // return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \      // each tuple is a coordinate - (row, columns), starting with 0.\n    \
    \  // Sort coordinates initially by rows in ascending order.\n      // Also, sort\
    \ coordinates of the row by columns in descending order.\n      val res = new\
    \ ListBuffer[Tuple2[Long, Long]]()\n      for (i <- 0 to lst.length - 1) {\n \
    \       val row = lst(i)\n        var j = 0\n        while (j < row.length) {\n\
    \          if (row(j) == x) {\n            res += ((i, j))\n          }\n    \
    \      j += 1\n        }\n      }\n      res.toList.sortWith((x, y) => (x._1 <\
    \ y._1) || (x._1 == y._1 && x._2 > y._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) {\n       \
    \             result = (i, j) :: result\n                }\n            }\n  \
    \      }\n        result.sorted", '        // Your code goes here...', "     \
    \   var ret : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for\
    \ (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n\
    \                if (lst(i)(j) == x) {\n                    ret = (i, j) :: ret\n\
    \                }\n            }\n        }\n        ret", "        // The main\
    \ point is to use tuples and sortBy instead of Lists and\n        // sort in which\
    \ we have to write all the routines by ourselves.\n        // The following code\
    \ is a bit tricky but you should understand it.\n        // If you have any questions,\
    \ please let me know.\n        lst.zipWithIndex.flatMap(tuple => {tuple._1.zipWithIndex.map(tuple\
    \ => {(tuple._1, tuple._2, tuple._1 == x)})}).filter(tuple => {tuple._3}).map(tuple\
    \ => {(tuple._1, tuple._2)}).sortBy(tuple => {(tuple._1, -tuple._2)}).reverse",
  "        val r = new scala.util.Random\n        val l = for (i <- 0 until lst.length;\
    \ j <- 0 until lst(i).length) yield (lst(i)(j), i, j)\n        l.filter(_._1 ==\
    \ x).map(e => (e._2, e._3)).sortWith((t1, t2) => if (t1._1 == t2._1) t1._2 > t2._2\
    \ else t1._1 < t2._1).toList", "        var ans = new ListBuffer[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  ans += Tuple2(i.toLong, j.toLong)\n                }\n            }\n     \
    \   }\n        ans.toList.sortWith((a, b) => {\n            if (a._1 < b._1) {\n\
    \                true\n            } else if (a._1 == b._1) {\n              \
    \  a._2 > b._2\n            } else {\n                false\n            }\n \
    \       })", "        val inds = new ArrayBuffer[Tuple2[Long, Long]]\n       \
    \ for (i <- 0 until lst.length) {\n            val indsInRow = lst(i).zipWithIndex.filter(_._1\
    \ == x).map(_._2).map(j => (i.toLong, j.toLong))\n            inds ++= indsInRow\n\
    \        }\n        inds.sortWith((a, b) => if (a._1 != b._1) a._1 < b._1 else\
    \ a._2 > b._2).toList", "        var res = (List[Tuple2[Long, Long]]())\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    res = res :+ (Tuple2(i.toLong,\
    \ j.toLong))\n                }\n            }\n        }\n        res", "   \
    \     var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n   \
    \     var y : Long = 0\n        for (row <- lst) {\n            var z : Long =\
    \ 0\n            for (col <- row) {\n                if (col == x) {\n       \
    \             result = result :+ (y, z)\n                }\n                z\
    \ += 1\n            }\n            y += 1\n        }\n        result.sortWith((t1,\
    \ t2) => {t1._1 < t2._1 || (t1._1 == t2._1 && t1._2 > t2._2)})", "    \tval all\
    \ = for {\n    \t\t(row, row_index) <- lst.zipWithIndex\n    \t\t(elem, elem_index)\
    \ <- row.zipWithIndex\n    \t\tif (elem == x)\n    \t} yield (row_index, elem_index)\n\
    \    \tall.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = Tuple2(i.toLong,\
    \ j.toLong) :: result\n                }\n            }\n        }\n        val\
    \ res = result.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))\n\
    \        return res", "        def helper(lst : List[List[Long]], x : Long, i\
    \ : Long, j : Long, res : List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]]\
    \ = {\n            if (i >= lst.length) res\n            else {\n            \
    \    val row = lst(i.toInt)\n                var k = 0\n                while\
    \ (k < row.length && row(k) != x) k += 1\n                if (k < row.length)\
    \ helper(lst, x, i + 1, 0, (i, k) :: res)\n                else helper(lst, x,\
    \ i + 1, 0, res)\n            }\n        }\n        helper(lst, x, 0, 0, List[Tuple2[Long,\
    \ Long]]()).sortWith((a, b) => {\n            if (a._1 < b._1) true\n        \
    \    else if (a._1 > b._1) false\n            else if (a._2 > b._2) true\n   \
    \         else false\n        })", '        lst.zipWithIndex.flatMap(t => t._1.zipWithIndex.filter(t2
    => t2._1 == x).map(t2 => (t._2, t2._2))).sortWith((t1, t2) => if (t1._1 == t2._1)
    t1._2 > t2._2 else t1._1 < t2._1)', "        // Your Code Here\n        List[Tuple2[Long,\
    \ Long]]()", "        var result : List[Tuple2[Long, Long]] = List()\n       \
    \ for (i <- 0 to lst.length - 1) {\n            for (j <- 0 to lst(i).length -\
    \ 1) {\n                if (lst(i)(j) == x) {\n                    result = Tuple2(i.toLong,\
    \ j.toLong) :: result\n                }\n            }\n        }\n        result.sortWith((t1,\
    \ t2) => (t1._1 < t2._1 || (t1._1 == t2._1 && t1._2 > t2._2)))", "        val\
    \ arr = new ArrayBuffer[Tuple2[Long, Long]]\n        for (x <- 0 until lst.length)\
    \ {\n            val y = lst(x).indexOf(x)\n            if (y != -1) arr += new\
    \ Tuple2(x, y)\n        }\n        arr.sortWith(SortUtil.tuple2Comparator).toList",
  "        def getRowAux(lst : List[List[Long]], x : Long, row : Long, col : Long,\
    \ acc : List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]] = {\n           \
    \ if (lst.length == 0) acc\n            else if (lst.head.length == 0) getRowAux(lst.tail,\
    \ x, row + 1, 0, acc)\n            else if (lst.head.head == x) getRowAux(lst.tail,\
    \ x, row + 1, 0, (row, col) :: acc)\n            else getRowAux(lst.tail, x, row,\
    \ col + 1, acc)\n        }\n        getRowAux(lst, x, 0, 0, List[Tuple2[Long,\
    \ Long]]()).sortWith((a, b) => a._1 > b._1 || (a._1 == b._1 && a._2 < b._2))",
  "        var out : List[Tuple2[Long, Long]] = List()\n        for (i <- 0 to lst.length\
    \ - 1) {\n            var indx : List[Long] = lst(i).zipWithIndex.map(x => if\
    \ (x._1 == x) x._2 else -1l).filter(x => x != -1l)\n            if (indx.length\
    \ > 0)\n                for (j <- 0 to indx.length - 1) {\n                  \
    \  out = out :+ (i.toLong, indx(j))\n                }\n        }\n        return\
    \ out.sortWith((x, y) => x._1 < y._1 || (x._1 == y._1 && x._2 > y._2))", "   \
    \     val res = ListBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            val l = lst(i)\n            for (j <- 0 until l.length) {\n \
    \               if (l(j) == x) {\n                    res += Tuple2(i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        res.toList.sortWith(compare)",
  "        // Your code here\n        List[Tuple2[Long, Long]]()", "        // This\
    \ way seemed clearer for me personally\n        // val rows = lst.zipWithIndex.map\
    \ { case (l, i) => l.zipWithIndex.map { case (e, j) => (e, (i, j)) } }\n     \
    \   // val (xs, xss) = rows.partition(_.exists(_._1 == x))\n        // xs.flatten.filter(_._1\
    \ == x).map(_._2).sorted\n        // This way is shorter and more scala'ish\n\
    \        lst.zipWithIndex.flatMap(r => r._1.zipWithIndex.filter(_._1 == x).map(e\
    \ => (e._2, r._2))).sorted", "        var indices = List[Tuple2[Long, Long]]()\n\
    \        for (row <- 0 until lst.length) {\n            var col = lst(row).indexOf(x)\n\
    \            while (col != -1) {\n                indices = (row, col) :: indices\n\
    \                col = lst(row).indexOf(x, col + 1)\n            }\n        }\n\
    \        indices.sortWith((u, v) => (u._1 < v._1) || (u._1 == v._1 && u._2 > v._2))",
  "        val coords = lst.zipWithIndex.flatMap(t => t._1.zipWithIndex.filter(t2\
    \ => t2._1 == x).map(t2 => (t._2, t2._2)))\n        val sorted = coords.sortWith((t1,\
    \ t2) => t1._1 < t2._1 || (t1._1 == t2._1 && t1._2 > t2._2))\n        sorted",
  "      // Fill up this function body\n      // 'lst' is a two dimensional list,\
    \ similar to matrix\n      // 'x' is the integer to be searched in the list\n\
    \      // 'return' a list of tuples, each tuple is a coordinate,\n      // (row,\
    \ column) in ascending order of row and descending order of column.\n      //\
    \ If the integer x is not found in the list, return empty list.\n      var i :\
    \ Long = 0\n      var j : Long = 0\n      var newLst : List[Tuple2[Long, Long]]\
    \ = List()\n      for (i <- 0 to lst.length - 1) {\n        var xList : List[Long]\
    \ = lst(i.toInt).distinct\n        for (j <- 0 to xList.length - 1) {\n      \
    \    if (xList(j.toInt) == x) {\n            newLst = newLst ++ List((i, j))\n\
    \          }\n        }\n      }\n      if (newLst.isEmpty) {\n        return\
    \ newLst\n      }\n      else {\n        return newLst.sortWith(_._1 < _._1).sortWith(_._2\
    \ > _._2)\n      }", "        // Using nested lists and tuple2, the following\
    \ time and space complexity\n        // is achieved:\n        // Space complexity:\
    \ O(x) -> O(n) -> O(n)\n        // Time complexity: O(a*b) -> O(m*n) -> O(m*n)\n\
    \        var result = List[Tuple2[Long, Long]]()\n        for (a <- 0 until lst.length)\
    \ {\n            for (b <- 0 until lst(a).length) {\n                if (lst(a)(b)\
    \ == x) {\n                    result ::= Tuple2(a.toLong, b.toLong)\n       \
    \         }\n            }\n        }\n        // Sort the result according to\
    \ the row in ascending order\n        // Also, sort coordinates of the row by\
    \ columns in descending order.\n        // Sorting algorithm: insertion sort\n\
    \        for (i <- 1 until result.length) {\n            val key = result(i)\n\
    \            var j = i - 1\n            while (j >= 0 && (result(j)._1 > key._1\
    \ || (result(j)._1 == key._1 && result(j)._2 < key._2))) {\n                result(j\
    \ + 1) = result(j)\n                j -= 1\n            }\n            result(j\
    \ + 1) = key\n        }\n        result", "        if (lst.isEmpty) return List[Tuple2[Long,\
    \ Long]]()\n        // (y, x, value)\n        val tuples = for {\n           \
    \ (y, row) <- lst.zipWithIndex\n            (x, value) <- row.zipWithIndex\n \
    \           if (value == x)\n        } yield (y, x, value)\n        val map =\
    \ Map[Long, List[Tuple3[Long, Long, Long]]]()\n        for (tuple <- tuples) {\n\
    \            if (map.contains(tuple._1)) {\n                map(tuple._1) = map(tuple._1)\
    \ :+ tuple\n            } else {\n                map(tuple._1) = List[Tuple3[Long,\
    \ Long, Long]](tuple)\n            }\n        }\n        val sortedRows = map.toList.sortBy(_._1)\n\
    \        sortedRows.map(a => a._2.sortBy(_._2)(Ordering[Long].reverse)).flatten.map(a\
    \ => (a._1, a._2))", "        var result : List[Tuple2[Long, Long]] = List()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = (i, j)\
    \ :: result\n                }\n            }\n        }\n        result", " \
    \     // Fill up this function body\n      // You may also define new functions\n\
    \      // Try to avoid mutating the lst\n      lst.zipWithIndex.foldLeft(List[Tuple2[Long,\
    \ Long]]())((l, e) => l ++ e._1.zipWithIndex.foldLeft(List[Tuple2[Long, Long]]())((l,\
    \ e) => if (e._1 == x) l :+ (e._2, e._1) else l)).sortWith((a, b) => if (a._1\
    \ < b._1) true else if (a._1 == b._1) a._2 > b._2 else false)", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = (i, j) :: result\n\
    \                }\n            }\n        }\n        result.sortWith((t1, t2)\
    \ => (t1._1 < t2._1) || (t1._1 == t2._1 && t1._2 > t2._2))", "        var ret\
    \ = List[Tuple2[Long, Long]]()\n        lst.zipWithIndex.foreach(t => {\n    \
    \        val lst = t._1\n            val index = t._2\n            lst.zipWithIndex.foreach(t\
    \ => {\n                val value = t._1\n                val subIndex = t._2\n\
    \                if (value == x) ret = ret ::: List[Tuple2[Long, Long]]((index,\
    \ subIndex))\n            })\n        })\n        ret.sortWith((t1, t2) => t1._1\
    \ < t2._1 || (t1._1 == t2._1 && t1._2 > t2._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        var i : Long = 0l\n        var\
    \ j : Long = 0l\n        for (i <- 0l until lst.length) {\n            for (j\
    \ <- 0l until lst(i.toInt).length) {\n                if (lst(i.toInt)(j.toInt)\
    \ == x) {\n                    result = result :+ (i, j)\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => (a._1 < b._1) ||\
    \ (a._1 == b._1 && a._2 > b._2))", "        var res : List[Tuple2[Long, Long]]\
    \ = List()\n        var cnt : Long = 0\n        for (i <- 0 to lst.length - 1)\
    \ {\n            var curr : Long = 0\n            for (j <- 0 to lst(i).length\
    \ - 1) {\n                if (lst(i)(j) == x) {\n                    res = (cnt,\
    \ curr) :: res\n                }\n                curr += 1\n            }\n\
    \            cnt += 1\n        }\n        var sorted = res.sorted(new Ordering[Tuple2[Long,\
    \ Long]]() {\n            override def compare(x : Tuple2[Long, Long], y : Tuple2[Long,\
    \ Long]) = x._1.compare(y._1)\n        })\n        sorted.reverse", "        var\
    \ result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        var\
    \ map : Map[Long, List[Tuple2[Long, Long]]] = Map[Long, List[Tuple2[Long, Long]]]()\n\
    \        val N = lst.length\n        for (i <- 0 until N) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) {\n       \
    \             result = Tuple2(i, j) :: result\n                }\n           \
    \ }\n        }\n        var row = 0l\n        for (p <- result) {\n          \
    \  if (map.contains(p._1)) {\n                map(p._1) = Tuple2(p._1, p._2) ::\
    \ map(p._1)\n            } else {\n                map(p._1) = List[Tuple2[Long,\
    \ Long]](Tuple2(p._1, p._2))\n            }\n        }\n        var result2 :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (p <- map)\
    \ {\n            p._2.sortWith((a, b) => a._2 > b._2)\n            result2 = result2\
    \ ::: p._2\n        }\n        result2", '        lst.foldLeft(List[Tuple2[Long,
    Long]]())((acc, row) => acc ::: row.zipWithIndex.filter(_._1 == x).map(t => (lst.indexOf(row),
    t._2)).reverse)', "        val result : ListBuffer[Tuple2[Long, Long]] = ListBuffer()\n\
    \        for (i <- 0 until lst.length) {\n            var j = 0\n            for\
    \ (y <- lst(i)) {\n                if (y == x) {\n                    result +=\
    \ ((i.toLong, j.toLong))\n                }\n                j += 1\n        \
    \    }\n        }\n        (result.toList.sortWith((a, b) => (a._1 == b._1 &&\
    \ a._2 > b._2) || a._1 < b._1))", '        null', "        def getRow(lst : List[List[Long]],\
    \ x : Long, y : Long, result : List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]]\
    \ = {\n            lst match {\n                case List() => result\n      \
    \          case hd :: tl => {\n                    val index = hd.indexOf(x)\n\
    \                    if (index != -1) {\n                        val tmp = result\
    \ :+ (y, index.toLong)\n                        getRow(tl, x, y + 1, tmp)\n  \
    \                  } else getRow(tl, x, y + 1, result)\n                }\n  \
    \          }\n        }\n        val row = getRow(lst, x, 0, List())\n       \
    \ row.sortWith((x, y) => x._1 < y._1 || (x._1 == y._1 && x._2 > y._2))", "   \
    \     var result : List[Tuple2[Long, Long]] = Nil\n        for (i <- 0 until lst.length)\
    \ {\n            var index : Long = -1\n            var row : List[Long] = lst(i)\n\
    \            for (j <- 0 until row.length) {\n                if (row(j) == x)\
    \ {\n                    index = j\n                    break\n              \
    \  }\n            }\n            if (index != -1) {\n                result =\
    \ (i, index) :: result\n            }\n        }\n        result", "        val\
    \ r = new ListBuffer[Tuple2[Long, Long]]\n        for (i <- 0 until lst.length)\
    \ {\n            val j = lst(i).indexOf(x)\n            if (j != -1) r += ((i.toLong,\
    \ j.toLong))\n        }\n        r.toList.sortWith((e1, e2) => e1._1 < e2._1 ||\
    \ (e1._1 == e2._1 && e1._2 > e2._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (rowIndex <- 0 until lst.length)\
    \ {\n            val row = lst(rowIndex)\n            for (columnIndex <- 0 until\
    \ row.length) {\n                if (row(columnIndex) == x) {\n              \
    \      result = Tuple2(rowIndex, columnIndex) :: result\n                }\n \
    \           }\n        }\n        result.sortWith(compare)", "    \tif (lst.isEmpty)\
    \ return List()\n    \tvar list = new ListBuffer[Tuple2[Long, Long]]()\n    \t\
    val n = lst.length\n    \tfor (i <- 0 until n) {\n    \t\tval m = lst(i).length\n\
    \    \t\tfor (j <- 0 until m) {\n    \t\t\tif (lst(i)(j) == x) list += ((i, j))\n\
    \    \t\t}\n    \t}\n    \tlist.toList.sortWith((x1, x2) => if (x1._1 < x2._1)\
    \ true else if (x1._1 == x2._1) x1._2 > x2._2 else false)", "        val output\
    \ = ListBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            val row = lst(i)\n            for (j <- 0 until row.length) {\n \
    \               if (row(j) == x) {\n                    output += Tuple2(i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        // return output.toList.sortWith((x,\
    \ y) => {if (x._1 == y._1) x._2 > y._2 else x._1 < y._1})\n        return output.toList.sortWith((x,\
    \ y) => x._1 < y._1 || (x._1 == y._1 && x._2 > y._2))", "        var m = lst.zipWithIndex.map(p\
    \ => p._1.zipWithIndex.map(q => q._1 -> (p._2 -> q._2))).flatten.toMap\n     \
    \   m.filter(_._1 == x).toList.map(p => p._2).sortWith(_._1 < _._1).sortWith(_._2\
    \ > _._2)", "        // Your code goes here\n        def helper(lst : List[List[Long]],\
    \ x : Long, row : Long, col : Long, init : List[Tuple2[Long, Long]]) : List[Tuple2[Long,\
    \ Long]] = {\n            lst match {\n                case Nil => init\n    \
    \            case h :: t => {\n                    if (h.contains(x)) {\n    \
    \                    val xs = h.zipWithIndex.filter(p => p._1 == x).map(p => (row,\
    \ p._2))\n                        helper(t, x, row + 1, col, init ++ xs)\n   \
    \                 } else {\n                        helper(t, x, row + 1, col,\
    \ init)\n                    }\n                }\n            }\n        }\n\
    \        val result = helper(lst, x, 0, 0, List[Tuple2[Long, Long]]())\n     \
    \   result.sortWith((t1, t2) => {\n            if (t1._1 < t2._1) true\n     \
    \       else if (t1._1 > t2._1) false\n            else if (t1._2 > t2._2) true\n\
    \            else false\n        })", '        lst.zipWithIndex.map(e => (e._1,
    e._2)).flatMap(e => e._1.zipWithIndex.map(z => (z._1, z._2, e._2))).filter(e =>
    e._1 == x).map(e => (e._3, e._2)).sortWith((e1, e2) => e1._1 < e2._1 || (e1._1
    == e2._1 && e1._2 > e2._2))', "        val lst2 = lst.zipWithIndex.filter(x =>\
    \ x._1.contains(x)).map(x => x._1.zipWithIndex.filter(y => y._1 == x).map(y =>\
    \ (x._2, y._2))).flatten\n        lst2.sortWith((x, y) => if (x._1 == y._1) x._2\
    \ > y._2 else x._1 < y._1)", "        var lstX = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 to lst.length - 1) {\n            for (j <- 0 to lst(i).length\
    \ - 1) {\n                if (lst(i)(j) == x) {\n                    lstX = (i,\
    \ j) :: lstX\n                }\n            }\n        }\n        val lstY =\
    \ lstX.sortWith(((x, y) => x._1 > y._1))\n        val lstZ = lstY.sortWith(((x,\
    \ y) => x._2 < y._2))\n        return lstZ", "      // Fill up this function body\n\
    \      // 'lst' contains x and is sorted by rows in ascending order\n      //\
    \ and columns in descending order\n      // 'x' is the number to search for\n\
    \      var result : List[Tuple2[Long, Long]] = List()\n      var rownum : Long\
    \ = 0\n      for (item : List[Long] <- lst) {\n        // println(item.mkString(\"\
    ,\"))\n        var colnum : Long = 0\n        for (x2 : Long <- item) {\n    \
    \      if (x2 == x) {\n            result = result :+ (rownum, colnum)\n     \
    \     }\n          colnum += 1\n        }\n        rownum += 1\n      }\n    \
    \  // println(result.mkString(\",\"))\n      result", "        var list = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  list = (i, j) :: list\n                }\n            }\n        }\n      \
    \  list", '        lst.zipWithIndex.flatMap(t => t._1.zipWithIndex.filter(t2 =>
    t2._1 == x).map(t2 => (t._2.toLong, t2._2.toLong))).sortWith((a, b) => if (a._1
    == b._1) a._2 > b._2 else a._1 < b._1)', "        var rows : List[Tuple2[Long,\
    \ Long]] = Nil\n        for (i <- 0 until lst.length) {\n            val row :\
    \ List[Long] = lst(i)\n            for (j <- 0 until row.length) {\n         \
    \       if (row(j) == x) {\n                    rows = Tuple2(i.toLong, j.toLong)\
    \ :: rows\n                }\n            }\n        }\n        return rows.sortWith((t1,\
    \ t2) => if (t1._1 < t2._1) true else if (t1._1 == t2._1) t1._2 > t2._2 else false)",
  "        var result : List[Tuple2[Long, Long]] = List()\n        var x_count = 0\n\
    \        for (row <- lst.indices) {\n            for (col <- lst(row).indices)\
    \ {\n                if (lst(row)(col) == x) {\n                    result = (row,\
    \ col) :: result\n                    x_count += 1\n                }\n      \
    \      }\n        }\n        if (x_count == 0) return result\n        var sorted_result\
    \ = result.sortWith((t1, t2) => {\n            if (t1._1 == t2._1) {\n       \
    \         t1._2 > t2._2\n            } else {\n                t1._1 < t2._1\n\
    \            }\n        })\n        sorted_result", "        if (lst.length ==\
    \ 0) return List()\n        lst.zipWithIndex.flatMap {case (row, rowIndex) =>\n\
    \            row.zipWithIndex.filter {case (element, elementIndex) =>\n      \
    \          element == x\n            }.map {case (element, elementIndex) =>\n\
    \                (rowIndex, elementIndex)\n            }\n        }.sortWith {case\
    \ (tuple1, tuple2) =>\n            if (tuple1._1 == tuple2._1) tuple1._2 > tuple2._2\n\
    \            else tuple1._1 < tuple2._1\n        }", "        var rows = new ArrayBuffer[Tuple2[Long,\
    \ Long]]\n        var columns = new ArrayBuffer[Tuple2[Long, Long]]\n        var\
    \ temp = new ArrayBuffer[Tuple2[Long, Long]]\n        var row = 0\n        var\
    \ column = 0\n        for (element <- lst) {\n            column = 0\n       \
    \     for (e <- element) {\n                if (e == x) {\n                  \
    \  rows += ((row, column))\n                }\n                column += 1\n \
    \           }\n            row += 1\n        }\n        rows = rows.sortWith((x,\
    \ y) => (x._1 < y._1) || (x._1 == y._1 && x._2 > y._2))\n        var current =\
    \ 0\n        for (element <- rows) {\n            if (element._1 == current) {\n\
    \                columns += element\n            } else {\n                temp\
    \ ++= columns.sortWith((x, y) => (x._1 < y._1) || (x._1 == y._1 && x._2 > y._2))\n\
    \                columns.clear\n                columns += element\n         \
    \       current = element._1\n            }\n        }\n        temp ++= columns.sortWith((x,\
    \ y) => (x._1 < y._1) || (x._1 == y._1 && x._2 > y._2))\n        temp.toList",
  "        var m = ArrayBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            var t = lst(i).zipWithIndex.filter(y => y._1 == x)\n        \
    \    t.foreach(y => m += ((i.toLong, y._2.toLong)))\n        }\n        val a\
    \ = m.sortWith((x, y) => if (x._1 == y._1) x._2 > y._2 else x._1 < y._1)\n   \
    \     a.toList", "        // Your code here\n        var ans = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  ans ::= Tuple2(i.toLong, j.toLong)\n                }\n            }\n    \
    \    }\n        ans.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 >\
    \ b._2))", "        def f(lst : List[List[Long]], i : Long, j : Long, result :\
    \ List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]] = {\n            if (i\
    \ >= lst.length) result\n            else if (j >= lst(i.toInt).length) f(lst,\
    \ i + 1, 0, result)\n            else if (lst(i.toInt)(j.toInt) == x) f(lst, i,\
    \ j + 1, result ::: List((i, j)))\n            else f(lst, i, j + 1, result)\n\
    \        }\n        f(lst, 0, 0, List[Tuple2[Long, Long]]())", "        var result\
    \ : List[Tuple2[Long, Long]] = Nil\n        var row : Long = 0l\n        for (list\
    \ <- lst) {\n            var column : Long = 0l\n            for (item <- list)\
    \ {\n                if (item == x) {\n                    result = (row, column)\
    \ :: result\n                }\n                column += 1l\n            }\n\
    \            row += 1l\n        }\n        result.sortWith((e1, e2) => if (e1._1\
    \ != e2._1) e1._1 < e2._1 else e1._2 > e2._2)", "        var l : List[Tuple2[Long,\
    \ Long]] = Nil\n        for(i <- lst.indices) {\n            for(j <- lst(i).indices)\
    \ {\n                if(lst(i)(j) == x) l = (i.toLong, j.toLong) :: l\n      \
    \      }\n        }\n        return l.sortWith((l1, l2) => l1._1 < l2._1 || (l1._1\
    \ == l2._1 && l1._2 > l2._2))", "        var result : List[Tuple2[Long, Long]]\
    \ = List()\n        var y = 0\n        for (i <- lst) {\n            var x = 0\n\
    \            for (j <- i) {\n                if (j == x) {\n                 \
    \   result = result ::: List((y, x))\n                }\n                x +=\
    \ 1\n            }\n            y += 1\n        }\n        var lst1 = lst.zipWithIndex.map\
    \ { case (row, i) => row.zipWithIndex.map { case (elem, j) => (elem, (i, j)) }\
    \ }\n        var lst2 = lst1.flatMap(e => e).filter(e => e._1 == x).sortBy(e =>\
    \ (e._2._1, -e._2._2))\n        result", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (row <- 0 to lst.length - 1)\
    \ {\n            for (col <- 0 to lst(row).length - 1) {\n                if (lst(row)(col)\
    \ == x) {\n                    result = result ::: List((row.toLong, col.toLong))\n\
    \                }\n            }\n        }\n        result.sortWith((e1, e2)\
    \ => e1._1 < e2._1 || (e1._1 == e2._1 && e1._2 > e2._2))", "        // fill the\
    \ code\n        null", "        // This is the recursive helper function to get\
    \ row of list.\n        def getRowHelper(lst : List[List[Long]], x : Long, row\
    \ : Long, col : Long, acc : List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]]\
    \ = {\n            // This is the base case of recursion, if it reaches the end\
    \ of the list,\n            // simply return the accumulator.\n            if\
    \ (lst.length == 0) return acc\n            // This is the recursive case, first,\
    \ get the first row in the list.\n            val (head, tail) = (lst.head, lst.tail)\n\
    \            // Get the index of the first occurrence of x in the row,\n     \
    \       // if it doesn't exist, simply -1.\n            val index = head.indexOf(x)\n\
    \            // If it doesn't exist, simply recursively get the row of the rest\
    \ of the list.\n            if (index == -1) return getRowHelper(tail, x, row\
    \ + 1, 0, acc)\n            // Otherwise, add the tuple, (row, index) to the accumulator.\n\
    \            val newAcc = acc :+ (row, index)\n            // Then, recursively\
    \ get the row of the rest of the list.\n            getRowHelper(tail, x, row\
    \ + 1, 0, newAcc)\n        }\n        // Get the row by calling the helper function.\n\
    \        val row = getRowHelper(lst, x, 0, 0, List[Tuple2[Long, Long]]())\n  \
    \      // Then, sort the row, initially by rows in ascending order,\n        //\
    \ then by columns in descending order.\n        row.sortWith((a, b) => {\n   \
    \         if (a._1 < b._1) true\n            else if (a._1 > b._1) false\n   \
    \         else a._2 > b._2\n        })", "        // Implement this method.\n\
    \        return List()", "      var result : List[Tuple2[Long, Long]] = Nil\n\
    \      for (i <- 0 until lst.length) {\n        for (j <- 0 until lst(i).length)\
    \ {\n          if (lst(i)(j) == x) result = (i, j) :: result\n        }\n    \
    \  }\n      result.sortWith(_._1 < _._1).sortWith(_._2 > _._2)", "        val\
    \ rowLength = lst.length\n        var map = List[Tuple2[Long, Long]]()\n     \
    \   for (i <- 0 until rowLength) {\n            val lst_0 = lst(i)\n         \
    \   val colLength = lst_0.length\n            for (j <- 0 until colLength) {\n\
    \                val lst_0_0 = lst_0(j)\n                if (lst_0_0 == x) {\n\
    \                    map = Tuple2(i.toLong, j.toLong) :: map\n               \
    \ }\n            }\n        }\n        map.sortWith((a, b) => (a._1 < b._1) ||\
    \ (a._1 == b._1 && a._2 > b._2))", "        // preprocess the list to get a mapping\
    \ between value and coordinate\n        // key: value\n        // value: (row,\
    \ column)\n        val map = Map[Long, List[Tuple2[Long, Long]]]()\n        var\
    \ row = 0\n        var column = 0\n        for (list <- lst) {\n            column\
    \ = 0\n            for (elem <- list) {\n                if (map.contains(elem))\
    \ {\n                    map(elem) = map(elem) ::: List[Tuple2[Long, Long]]((row,\
    \ column))\n                } else {\n                    map += (elem -> List[Tuple2[Long,\
    \ Long]]((row, column)))\n                }\n                column += 1\n   \
    \         }\n            row += 1\n        }\n        //println(map)\n       \
    \ // get the x's coordinate\n        var coordList = map(x)\n        //println(coordList)\n\
    \        // sort the coordinate\n        coordList = coordList.sortWith((x, y)\
    \ => x._1 < y._1 || (x._1 == y._1 && x._2 > y._2))\n        //println(coordList)\n\
    \        return coordList", "        var map = Map[Long, List[Tuple2[Long, Long]]]()\n\
    \        val rows = lst.length\n        for (i <- 0 until rows) {\n          \
    \  val cols = lst(i).length\n            for (j <- 0 until cols) {\n         \
    \       if (lst(i)(j) == x) {\n                    if (map.contains(i)) {\n  \
    \                      map(i) = (i, j) :: map(i)\n                    } else {\n\
    \                        map(i) = List((i, j))\n                    }\n      \
    \          }\n            }\n        }\n        var lstx = List[Tuple2[Long, Long]]()\n\
    \        map.keys.toList.sorted.foreach(key => {\n            map(key).sortWith((t1,\
    \ t2) => t1._2 < t2._2).foreach(t => lstx = t :: lstx)\n        })\n        lstx",
  "      // Your code here\n      (List[Tuple2[Long, Long]]())", "        var res\
    \ : List[Tuple2[Long, Long]] = Nil\n        for (i <- 0 to lst.length - 1) {\n\
    \            var col : Long = 0\n            for (j <- 0 to lst(i).length - 1)\
    \ {\n                if (lst(i)(j) == x) {\n                    res = res :+ (i,\
    \ col)\n                }\n                col += 1\n            }\n        }\n\
    \        return res.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 >\
    \ b._2))", "      var coordinates : List[Tuple2[Long, Long]] = List()\n      for\
    \ (row <- 0 to lst.length - 1) {\n        for (column <- 0 to lst(row).length\
    \ - 1) {\n          if (lst(row)(column) == x) {\n            coordinates = (row,\
    \ column) :: coordinates\n          }\n        }\n      }\n      coordinates.sortWith(sortByRowAndColumn)",
  "        var tup : List[Tuple2[Long, Long]] = List()\n        for (row <- lst.indices;\
    \ col <- lst(row).indices) {\n            if (lst(row)(col) == x) {\n        \
    \        tup ::= (row.toLong, col.toLong)\n            }\n        }\n        tup.sorted(new\
    \ Ordering[Tuple2[Long, Long]]() {\n            override def compare(a : Tuple2[Long,\
    \ Long], b : Tuple2[Long, Long]) : Int = {\n                if (a._1 == b._1)\
    \ {\n                    b._2.compare(a._2)\n                } else {\n      \
    \              a._1.compare(b._1)\n                }\n            }\n        })",
  "        val result = new ListBuffer[Tuple2[Long, Long]]\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result += Tuple2(i.toLong, j.toLong)\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ a._1 == b._1 && a._2 > b._2 || a._1 < b._1).toList", "        if (lst.length\
    \ == 0) {\n            return List[Tuple2[Long, Long]]()\n        }\n        val\
    \ row : ArrayBuffer[Tuple2[Long, Long]] = ArrayBuffer[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    row += ((i.toLong,\
    \ j.toLong))\n                }\n            }\n        }\n        return row.toList.sortWith((a,\
    \ b) => {if (a._1 == b._1) {a._2 > b._2} else {a._1 < b._1}})", "        if (lst.isEmpty)\
    \ {\n            List[Tuple2[Long, Long]]()\n        } else {\n            val\
    \ row = lst.head\n            val rest = lst.tail\n            val rowTuples =\
    \ for {i <- 0 until row.length if (row(i) == x)} yield {\n                (0,\
    \ i)\n            }\n            rowTuples.toList ++ getRow(rest, x).map(e =>\
    \ (e._1 + 1, e._2))\n        }", "        // Fill up this function body\n    \
    \    // 'lst' is a nested list similar to a matrix\n        // 'x' is a value\
    \ to be found in the nested list\n        // returns a list of tuples that stores\
    \ the location of each occurrence of 'x' in the nested list\n        // The tuples\
    \ follow the following rules:\n        // Each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort the tuples initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        var output = List[Tuple2[Long, Long]]()\n        // logic goes\
    \ here\n        for (row <- 0 until lst.length) {\n            var col = lst(row).length\
    \ - 1\n            var first = false\n            while (col >= 0) {\n       \
    \         if (lst(row)(col) == x) {\n                    if (output.isEmpty ||\
    \ output.last._1 != row) {\n                        output = output :+ (row, col)\n\
    \                    } else {\n                        var temp = output.last\n\
    \                        output = output.dropRight(1)\n                      \
    \  output = output :+ (temp._1, temp._2) :+ (row, col)\n                    }\n\
    \                }\n                col -= 1\n            }\n        }\n     \
    \   output", "        def getListOfColumns(x : Long, listOfList : List[List[Long]])\
    \ : List[Tuple2[Long, Long]] = {\n            def getColumns(x : Long, list :\
    \ List[Long], row : Long, column : Long) : List[Tuple2[Long, Long]] = {\n    \
    \            if (list.isEmpty) Nil\n                else if (list.head == x) {\n\
    \                    (row, column) :: getColumns(x, list.tail, row, column + 1)\n\
    \                }\n                else getColumns(x, list.tail, row, column\
    \ + 1)\n            }\n            if (listOfList.isEmpty) Nil\n            else\
    \ getColumns(x, listOfList.head, 0, 0) ::: getListOfColumns(x, listOfList.tail)\n\
    \        }\n        val tuples = getListOfColumns(x, lst)\n        val map = new\
    \ HashMap[Long, List[Tuple2[Long, Long]]]\n        for (tuple <- tuples) {\n \
    \           val row = tuple._1\n            val column = tuple._2\n          \
    \  if (map.contains(row)) {\n                val oldList = map(row)\n        \
    \        map(row) = (row, column) :: oldList\n            }\n            else\
    \ map(row) = List((row, column))\n        }\n        val keys = map.keys.toList.sorted\n\
    \        val result = new ListBuffer[Tuple2[Long, Long]]\n        for (key <-\
    \ keys) {\n            val list = map(key)\n            val sortedList = list.sortWith((a,\
    \ b) => {\n                a._2 > b._2\n            })\n            result ++=\
    \ sortedList\n        }\n        result.toList", "        // YOUR CODE GOES HERE\n\
    \        (0 until lst.length).toList.flatMap(i => {\n            (0 until lst(i.toInt).length).toList.map(j\
    \ => {\n                if (lst(i.toInt)(j.toInt) == x) {\n                  \
    \  (i.toLong, j.toLong)\n                } else {\n                    (0l, 0l)\n\
    \                }\n            }).filter(t => {\n                t._1 != 0l ||\
    \ t._2 != 0l\n            })\n        }).sorted(new Ordering[Tuple2[Long, Long]]\
    \ {\n            def compare(a : Tuple2[Long, Long], b : Tuple2[Long, Long]) =\
    \ {\n                if (a._1 < b._1) {\n                    -1\n            \
    \    } else if (a._1 > b._1) {\n                    1\n                } else\
    \ {\n                    if (a._2 > b._2) {\n                        -1\n    \
    \                } else if (a._2 < b._2) {\n                        1\n      \
    \              } else {\n                        0\n                    }\n  \
    \              }\n            }\n        })", "        // The key idea is to sort\
    \ each row by columns in descending order,\n        // this is because, by doing\
    \ this, the program need not to iterate\n        // all the columns in the row\
    \ to check whether x is in the row.\n        // Once the first entry is greater\
    \ than x, then we know that x is\n        // not in the row.\n        val lstmap\
    \ = lst.map(x => x.sortWith(_ > _))\n        val lstb = lstmap.map(x => x.foldLeft(true,\
    \ (0l, 0l))((y, z) => (z > x(0), (y._2._1 + 1l, y._2._2 + (if (z == x(0)) 1l else\
    \ 0l))))._2)\n        val lstb1 = lstb.zipWithIndex.filter(x => x._1._2 > 0l).sortWith((x,\
    \ y) => (x._1._1 > y._1._1) || (x._1._1 == y._1._1 && x._2 < y._2))\n        lstb1.flatMap(x\
    \ => for (i <- 1 to x._1._2.toInt) yield (x._2.toLong, x._1._1.toLong - i.toLong\
    \ + 1l)).toList", '        lst.zipWithIndex.map{ case (l, i) => l.zipWithIndex.map{
    case (v, j) => Tuple2(i, j) }.filter{ case (y, z) => z == x } }.flatMap{ x =>
    x }', '        null', "        val r : ListBuffer[Tuple2[Long, Long]] = new ListBuffer[Tuple2[Long,\
    \ Long]]\n        for (y <- 0 until lst.length) {\n            val y1 : Long =\
    \ y\n            val t : List[Long] = lst(y.toInt)\n            for (z <- 0 until\
    \ t.length) {\n                val z1 : Long = z\n                if (t(z.toInt)\
    \ == x) {\n                    r += new Tuple2(y1, z1)\n                }\n  \
    \          }\n        }\n        r.sortWith(_._1 < _._1).map(e => {val t : List[Long]\
    \ = lst(e._1.toInt); new Tuple2(e._1, t.length - e._2 - 1)}).toList", "      \
    \  val lst2 = lst.zipWithIndex.flatMap(tup => tup._1.zipWithIndex.map(tup2 =>\
    \ (tup._2, tup2._2, tup2._1)))\n        lst2.filter(tup => tup._3 == x).sortBy(tup\
    \ => (tup._1, -tup._2)).map(tup => (tup._1, tup._2))", "        def compare(a\
    \ : Tuple2[Long, Long], b : Tuple2[Long, Long]) : Boolean = {\n            val\
    \ c = a._1.compare(b._1)\n            if (c == 0) {\n                return a._2.compare(b._2)\
    \ > 0\n            }\n            return c < 0\n        }\n        def find(row\
    \ : Long, col : Long, lst : List[List[Long]]) : List[Tuple2[Long, Long]] = {\n\
    \            if (row == lst.length) {\n                return List[Tuple2[Long,\
    \ Long]]()\n            }\n            if (col == lst(row.toInt).length) {\n \
    \               return find(row + 1, 0, lst)\n            }\n            val c\
    \ = lst(row.toInt)(col.toInt).compare(x)\n            if (c == 0) {\n        \
    \        return (row, col) :: find(row, col + 1, lst)\n            }\n       \
    \     if (c > 0) {\n                return find(row, col + 1, lst)\n         \
    \   }\n            return find(row + 1, 0, lst)\n        }\n        return find(0,\
    \ 0, lst).sortWith(compare)", "        lst.foldLeft(List[Tuple2[Long, Long]]())((acc,\
    \ row) =>\n            row.zipWithIndex.foldLeft(acc)((acc2, t) => if (t._1 ==\
    \ x) (acc2 :+ (lst.indexOf(row), t._2)) else acc2)\n        ).sortWith((x, y)\
    \ => if (x._1 == y._1) x._2 > y._2 else x._1 < y._1)", "        // Fill up this\
    \ function body\n        // `x` is an integer which you have to find in the `lst`\n\
    \        // Write a return statement with appropriate list of tuples\n       \
    \ // containing row number, and column number of `x`\n        var column = 0\n\
    \        var row = 0\n        var tuple = ListBuffer[Tuple2[Long, Long]]()\n \
    \       for (i <- lst) {\n            row += 1\n            for (j <- i) {\n \
    \               column += 1\n                if (j == x) {\n                 \
    \   tuple += ((row, column))\n                }\n            }\n            column\
    \ = 0\n        }\n        tuple.toList", "        val mutable = ArrayBuffer[Tuple2[Long,\
    \ Long]]()\n        for ((row, rowIndex) <- lst.zipWithIndex) {\n            for\
    \ ((elem, colIndex) <- row.zipWithIndex) {\n                if (elem == x) mutable\
    \ += Tuple2(rowIndex.toLong, colIndex.toLong)\n            }\n        }\n    \
    \    val result = mutable.toList\n        result.sortWith((a, b) => {\n      \
    \      if (a._1 != b._1) a._1 < b._1\n            else a._2 > b._2\n        })",
  "        var result : List[Tuple2[Long, Long]] = Nil\n        val temp : List[Tuple2[Long,\
    \ Long]] = lst.zipWithIndex.flatMap{ case (l, i) => l.zipWithIndex.flatMap{ case\
    \ (e, j) => if (e == x) Some((i, j)) else None } }\n        val ys = temp.map(_._1).distinct\n\
    \        for (y <- ys) {\n            result = temp.filter(_._1 == y).sortBy(_._2).reverse\
    \ ::: result\n        }\n        result", "        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) {\n       \
    \             result = result :+ (i.toLong, j.toLong)\n                }\n   \
    \         }\n        }\n        result = result.sortWith((t1, t2) => (t1._1 <\
    \ t2._1) || (t1._1 == t2._1 && t1._2 > t2._2))\n        result", "        return\
    \ lst.zipWithIndex.map{case (col, row) => {\n            col.zipWithIndex.map{case\
    \ (v, col) => {\n                if (v == x) Some((row, col)) else None\n    \
    \        }}.flatten\n        }}.flatten.sortWith((a, b) => {\n            if (a._1\
    \ < b._1) true else if (a._1 > b._1) false else a._2 > b._2\n        })", "  \
    \      val indices = Buffer[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) indices += ((i.toLong, j.toLong))\n            }\n        }\n        indices.sortWith(_._1\
    \ < _._1).sortWith(_._2 > _._2).toList", "      def getCol(lst : List[Long], x\
    \ : Long) : List[Tuple2[Long, Long]] = {\n        var result = new ListBuffer[Tuple2[Long,\
    \ Long]]()\n        var index = 0l\n        lst.foreach(element => {\n       \
    \   if (element == x) {\n            result += Tuple2(index, element)\n      \
    \    }\n          index += 1\n        })\n        result.toList\n      }\n   \
    \   var result = new ListBuffer[Tuple2[Long, Long]]()\n      var index = 0l\n\
    \      lst.foreach(element => {\n        var colIndex = 0l\n        element.foreach(element1\
    \ => {\n          if (element1 == x) {\n            result += Tuple2(index, colIndex)\n\
    \          }\n          colIndex += 1\n        })\n        index += 1\n      })\n\
    \      result.toList.sortWith(_._1 < _._1).sortWith(_._2 > _._2)", '        lst.zipWithIndex.flatMap(p
    => p._1.zipWithIndex.filter(q => q._1 == x).map(q => (p._2, q._2))).sorted', " \
    \       var res : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n    \
    \    var row : Long = 0\n        for (i <- lst) {\n            var col : Long\
    \ = 0\n            for (j <- i) {\n                if (j == x) {\n           \
    \         res = res :+ (row, col)\n                }\n                col += 1\n\
    \            }\n            row += 1\n        }\n        return res.sortWith(sortTuple)",
  "        if (lst.isEmpty) Nil\n        else {\n            var row : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n            var rowIdx : Long = 0\n   \
    \         for (rowList <- lst) {\n                var colIdx : Long = 0\n    \
    \            for (element <- rowList) {\n                    if (element == x)\
    \ row = row :+ (rowIdx, colIdx)\n                    colIdx += 1\n           \
    \     }\n                rowIdx += 1\n            }\n            row.sortWith(_._1\
    \ < _._1).map(t => (t._1, lst(t._1.toInt).length - t._2.toInt - 1))\n        }",
  "        val rows = lst.zipWithIndex.toList\n        val cols = rows.map(row =>\
    \ row._1.zipWithIndex.toList)\n        val matches = cols.map(row => row.filter(column\
    \ => column._1 == x))\n        val columns = matches.map(matchRow => matchRow.map(matchCol\
    \ => matchCol._2))\n        val rowsAndColumns = columns.zipWithIndex.map(row\
    \ => row._1.map(col => (row._2, col)))\n        val rowTuples = rowsAndColumns.map(row\
    \ => row.toList)\n        val sortedRowTuples = rowTuples.map(row => row.sortWith((x,\
    \ y) => (x._2 > y._2)))\n        val tuples = sortedRowTuples.map(row => row.toList)\n\
    \        val flatTuples = tuples.flatten\n        flatTuples.sortWith((x, y) =>\
    \ (x._1 < y._1))", "        val res = ListBuffer[Tuple2[Long, Long]]()\n     \
    \   for (i <- 0 until lst.length) {\n            val row = lst(i)\n          \
    \  for (j <- 0 until row.length) {\n                if (row(j) == x) res += Tuple2(i.toLong,\
    \ j.toLong)\n            }\n        }\n        res.sortWith((t1, t2) => t1._1\
    \ < t2._1 || (t1._1 == t2._1 && t1._2 > t2._2)).toList", "        var list : List[Tuple2[Long,\
    \ Long]] = List()\n        var i = 0\n        for (row <- lst) {\n           \
    \ var j = 0\n            for (col <- row) {\n                if (col == x) list\
    \ = list :+ (i, j)\n                j += 1\n            }\n            i += 1\n\
    \        }\n        list.sortWith((x, y) => { if (x._1 < y._1) true else if (x._1\
    \ == y._1) x._2 > y._2 else false })", "        val table : HashMap[Long, HashMap[Long,\
    \ Tuple2[Long, Long]]] = new HashMap[Long, HashMap[Long, Tuple2[Long, Long]]]()\n\
    \        val coordinates : HashMap[Long, Tuple2[Long, Long]] = new HashMap[Long,\
    \ Tuple2[Long, Long]]()\n        var index : Long = 0\n        for (row <- lst)\
    \ {\n            var i : Long = 0\n            var map : HashMap[Long, Tuple2[Long,\
    \ Long]] = new HashMap[Long, Tuple2[Long, Long]]()\n            for (item <- row)\
    \ {\n                if (item == x) {\n                    map.put(index, (index,\
    \ i))\n                    coordinates.put(index, (index, i))\n              \
    \      index += 1\n                }\n                i += 1\n            }\n\
    \            table.put(index, map)\n        }\n        // Dump\n        // System.out.println(table.keys.toString)\n\
    \        // for (row <- table.values) {\n        //     System.out.println(row.keys.toString)\n\
    \        //     for (item <- row.values) {\n        //         System.out.println(item.toString)\n\
    \        //     }\n        // }\n        // System.out.println(coordinates.keys.toString)\n\
    \        // for (item <- coordinates.values) {\n        //     System.out.println(item.toString)\n\
    \        // }\n        return coordinates.values.toList.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function\
    \ body\n        // `lst` is a nested list which is similar to a matrix\n     \
    \   // `x` is an integer which is present in `lst`\n        // return list of\
    \ tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var coordinates = ArrayBuffer[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 to lst.length - 1) {\n            for (j <- 0 to lst(i).length\
    \ - 1) {\n                if (lst(i)(j) == x) {\n                    coordinates\
    \ += Tuple2(i.toLong, j.toLong)\n                }\n            }\n        }\n\
    \        return coordinates.toList.sortWith(_._1 < _._1).sortWith(_._2 > _._2)",
  "        // Write your code here\n        List[Tuple2[Long, Long]]()", "       \
    \ // We use reverse on the list because we want to find the rows in ascending\
    \ order\n        // and the columns in descending order\n        val lstRev =\
    \ lst.reverse\n        var res = List[Tuple2[Long, Long]]()\n        for (i <-\
    \ 0 until lstRev.length) {\n            // We iterate over the list from left\
    \ to right, from top to bottom\n            // to find the first instance of x\n\
    \            // val row = lstRev(i)\n            var c = 0\n            for (j\
    \ <- 0 until lstRev(i).length) {\n                if (lstRev(i)(j) == x) {\n \
    \                   res = (i, j) :: res\n                    c += 1\n        \
    \        }\n            }\n            if (c == 0) {\n                // We do\
    \ this because we want the list to be sorted by the rows in ascending order\n\
    \                // and the columns in descending order\n                // If\
    \ the number of instances of x in the rows is 0,\n                // then add\
    \ a tuple with the row with the columns being -1\n                res = (i, -1)\
    \ :: res\n            }\n        }\n        res", '        lst.zipWithIndex.map({case
    (row, rowNum) => row.zipWithIndex.filter({case (num, colNum) => num == x}).map({case
    (num, colNum) => (rowNum, colNum)})}).flatten.sortWith({case ((r1, c1), (r2, c2))
    => r1 < r2 || (r1 == r2 && c1 > c2)})', "        var tuples = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- lst.indices) {\n            for (j <- lst(i).indices)\
    \ {\n                if (lst(i)(j) == x) {\n                    tuples = tuples\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   tuples.sortWith((i, j) => i._1 < j._1 || (i._1 == j._1 && i._2 > j._2))",
  "        // Write your code here\n        var result : List[Tuple2[Long, Long]]\
    \ = List()\n        var i : Long = 0\n        for (row <- lst) {\n           \
    \ var j : Long = 0\n            for (col <- row) {\n                if (col ==\
    \ x) {\n                    result = result :+ (i, j)\n                }\n   \
    \             j += 1\n            }\n            i += 1\n        }\n        result.sortWith((x,\
    \ y) => (x._1 < y._1) || (x._1 == y._1 && x._2 > y._2))", "        var res = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 to lst.length - 1) {\n            for (j <- 0\
    \ to lst(i).length - 1) {\n                if (lst(i)(j) == x) {\n           \
    \         res = res ++ List((i.toLong, j.toLong))\n                }\n       \
    \     }\n        }\n        res = res.sortWith((t1, t2) => {\n            if (t1._1\
    \ == t2._1) t1._2 > t2._2 else t1._1 < t2._1\n        })\n        res", "    \
    \    var r = List[Tuple2[Long, Long]]()\n        val y = lst.zipWithIndex.map(x\
    \ => x._1.zipWithIndex.filter(y => y._1 == x._2))\n        r = y.map(x => x.map(y\
    \ => (x._2, y._2))).flatten\n        r.reverse", "        def getRowRec(data :\
    \ List[List[Long]], x : Long, acc : List[Tuple2[Long, Long]]) : List[Tuple2[Long,\
    \ Long]] = {\n            if (data.isEmpty) acc\n            else {\n        \
    \        val rowIndex = lst.indexOf(data.head)\n                val columnIndices\
    \ = data.head.indices.filter(data.head(_) == x)\n                val newTuples\
    \ = columnIndices.map(t => (rowIndex.toLong, t.toLong))\n                getRowRec(data.tail,\
    \ x, acc ++ newTuples)\n            }\n        }\n        val rows = getRowRec(lst,\
    \ x, List[Tuple2[Long, Long]]())\n        // Convert to tuple of tuples\n    \
    \    rows.sortWith((a, b) => a._1 < b._1)", "        def convert(lists : List[List[Long]])\
    \ : List[Tuple2[Long, Long]] = {\n            val n = lists.length\n         \
    \   var result = List[Tuple2[Long, Long]]()\n            for (i <- 0 until n)\
    \ {\n                val current = lists(i)\n                val m = current.length\n\
    \                for (j <- 0 until m) {\n                    if (current(j) ==\
    \ x) {\n                        result = Tuple2(i.toLong, j.toLong) :: result\n\
    \                    }\n                }\n            }\n            result\n\
    \        }\n        val result = convert(lst)\n        result.sortWith((a, b)\
    \ => {\n            val rowDiff = a._1 - b._1\n            if (rowDiff != 0) rowDiff\
    \ < 0 else b._2 - a._2 < 0\n        })", "        val sorted = new ListBuffer[Tuple2[Long,\
    \ Long]]\n        for (i <- 0 until lst.length) {\n            val y = lst(i).indexOf(x)\n\
    \            if (y != -1) sorted += Tuple2(i.toLong, y.toLong)\n        }\n  \
    \      //println(sorted)\n        val sortedByRow = sorted.sortWith((a, b) =>\
    \ a._1 < b._1)\n        //println(sortedByRow)\n        val sortedByColumn = sortedByRow.sortWith((a,\
    \ b) => (a._1 == b._1 && a._2 > b._2) || a._1 < b._1)\n        //println(sortedByColumn)\n\
    \        sortedByColumn.toList", "        // Fill up this function body\n    \
    \    // 'lst' a nested list of integers (similar to matrix)\n        // 'x' is\
    \ an integer to be found in the list\n        val dummy = (Long.MaxValue, Long.MaxValue)\n\
    \        val ans = lst.map(e => e.map(f => (e.indexOf(f), f)))\n        val ans2\
    \ = ans.map(f => f.filter(e => e._2 == x))\n        val ans3 = ans2.filter(e =>\
    \ e.size > 0)\n        val ans4 = ans3.map(e => e.map(f => (ans3.indexOf(e), f._1)))\n\
    \        val ans5 = ans4.map(e => e.sortWith(_._2 > _._2))\n        val ans6 =\
    \ ans5.flatten.sortWith(_._1 < _._1)\n        ans6", "        (for(i <- 0 until\
    \ lst.length) yield {\n            for(j <- 0 until lst(i).length) yield {\n \
    \               if(lst(i)(j) == x) {\n                    (i.toLong, j.toLong)\n\
    \                } else {\n                    (null, null)\n                }\n\
    \            }\n        }).filter(y => y.length > 0).flatten.filter(z => z._1\
    \ != null).sortWith((x, y) => x._1 < y._1 || (x._1 == y._1 && x._2 > y._2))",
  "        val row = ListBuffer[Tuple2[Long, Long]]()\n        var rowNum = 0l\n \
    \       lst.foreach {row =>\n            var colNum = 0l\n            row.foreach\
    \ {col =>\n                if (col == x) row += new Tuple2(rowNum, colNum)\n \
    \               colNum += 1\n            }\n            rowNum += 1\n        }\n\
    \        val rowSorted = row.toList.sortWith((x, y) => x._1 < y._1)\n        rowSorted.map\
    \ {tuple => \n            val (rowNum, colNum) = tuple\n            val rowOfTuple\
    \ = rowSorted.filter {x => x._1 == rowNum}\n            val sortedRow = rowOfTuple.sortWith((x,\
    \ y) => x._2 > y._2)\n            val colOfTuple = sortedRow.indexOf(tuple)\n\
    \            new Tuple2(rowNum, colOfTuple)\n        }", "        var res : List[Tuple2[Long,\
    \ Long]] = Nil\n        for (i <- 0 to lst.length - 1) {\n            var currList\
    \ = lst(i)\n            for (j <- 0 to currList.length - 1) {\n              \
    \  if (currList(j) == x) {\n                    res = (i, j) :: res\n        \
    \        }\n            }\n        }\n        res", "        val ys = ListBuffer[Tuple2[Long,\
    \ Long]]()\n        var i = 0\n        while (i < lst.length) {\n            var\
    \ j = 0\n            while (j < lst(i).length) {\n                if (lst(i)(j)\
    \ == x) ys += ((i, j))\n                j += 1\n            }\n            i +=\
    \ 1\n        }\n        // Order row in ascending order then column in descending\
    \ order\n        ys.toList.sortWith(\n            (tupleA, tupleB) => tupleA._1\
    \ < tupleB._1 || (tupleA._1 == tupleB._1 && tupleA._2 > tupleB._2)\n        )",
  "        // Write your code here\n        null", '        lst.zipWithIndex.flatMap(e
    => e._1.zipWithIndex.filter(t => t._1 == x).map(t => (e._2, t._2))).sorted', " \
    \       // your code goes here\n        List()", "        def getRow0(lst : List[List[Long]],\
    \ x : Long, row : Long, col : Long, acc : List[Tuple2[Long, Long]]) : List[Tuple2[Long,\
    \ Long]] = {\n            lst match {\n                case Nil => acc\n     \
    \           case (List()) :: xs => getRow0(xs, x, row + 1, 0, acc)\n         \
    \       case (x0 :: xs0) :: xs => if (x0 == x) getRow0(xs, x, row + 1, 0, (row,\
    \ col) :: acc) else getRow0(xs, x, row, col + 1, acc)\n            }\n       \
    \ }\n        getRow0(lst, x, 0, 0, Nil).sortWith((a, b) => (a._1 < b._1) || (a._1\
    \ == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        var rowNum : Long = 0l\n        for (l <-\
    \ lst) {\n            var colNum : Long = 0l\n            for (e <- l) {\n   \
    \             if (e == x) {\n                    result = result ::: List[Tuple2[Long,\
    \ Long]]((rowNum, colNum))\n                }\n                colNum += 1l\n\
    \            }\n            rowNum += 1l\n        }\n        var resultTemp =\
    \ result.sorted(new Ordering[Tuple2[Long, Long]] {\n            def compare(x:\
    \ (Long, Long), y: (Long, Long)) = {\n                if (x._1 > y._1) {\n   \
    \                 1\n                } else if (x._1 < y._1) {\n             \
    \       -1\n                } else {\n                    0\n                }\n\
    \            }\n        })\n        var resultTemp1 = resultTemp.groupBy(x =>\
    \ x._1)\n        var resultTemp2 = resultTemp1.map(x => x._2.sorted(new Ordering[Tuple2[Long,\
    \ Long]] {\n            def compare(x: (Long, Long), y: (Long, Long)) = {\n  \
    \              if (x._2 < y._2) {\n                    1\n                } else\
    \ if (x._2 > y._2) {\n                    -1\n                } else {\n     \
    \               0\n                }\n            }\n        }))\n        var\
    \ resultTemp3 = resultTemp2.toList.sortBy(x => x(0)._1)\n        var resultTemp4\
    \ = resultTemp3.flatten\n        resultTemp4", "        // Write your solution\
    \ here\n        if (lst.isEmpty)\n            return List()\n        // Convert\
    \ 2 dimensional list to sequence\n        var result : List[Tuple2[Long, Long]]\
    \ = List()\n        var y = 0\n        for (row <- lst) {\n            var z =\
    \ 0\n            for (elem <- row) {\n                if (elem == x)\n       \
    \             result ::= (y, z)\n                z += 1\n            }\n     \
    \       y += 1\n        }\n        result.sortWith((a, b) => if (a._1 == b._1)\
    \ a._2 > b._2 else a._1 < b._1)", "        // your code here\n        List[Tuple2[Long,\
    \ Long]]()", "        val rows = lst.zipWithIndex.map(row => (row._1.indexOf(x),\
    \ row._2)).filter(row => row._1 != -1).map(row => (row._2, row._1))\n        val\
    \ sorted = rows.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))\n\
    \        sorted", "        // your code here\n        null", "        val lstSet\
    \ = lst.toSet\n        val lstLen = lst.length\n        val res : ListBuffer[Tuple2[Long,\
    \ Long]] = ListBuffer()\n        val resRow : ListBuffer[Tuple2[Long, Long]] =\
    \ ListBuffer()\n        val resCol : ListBuffer[Tuple2[Long, Long]] = ListBuffer()\n\
    \        val resRowCol : ListBuffer[Tuple2[Long, Long]] = ListBuffer()\n     \
    \   var i = 0l\n        var j = 0l\n        while (i < lstLen) {\n           \
    \ val list = lst(i.toInt)\n            val listLen = list.length\n           \
    \ j = 0l\n            while (j < listLen) {\n                if (list(j.toInt)\
    \ == x) {\n                    res += Tuple2(i, j)\n                }\n      \
    \          j += 1l\n            }\n            i += 1l\n        }\n        i =\
    \ 0l\n        while (i < lstLen) {\n            val list = lst(i.toInt)\n    \
    \        val listLen = list.length\n            j = 0l\n            while (j <\
    \ listLen) {\n                if (list(j.toInt) == x) {\n                    resRow\
    \ += Tuple2(i, j)\n                }\n                j += 1l\n            }\n\
    \            i += 1l\n        }\n        val resRowSorted = resRow.sortWith((a,\
    \ b) => {\n            if (a._1 > b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                if (a._2 > b._2) {\n             \
    \       true\n                } else {\n                    false\n          \
    \      }\n            } else {\n                false\n            }\n       \
    \ })\n        resRowCol ++= resRowSorted\n        var prevRow = -1l\n        i\
    \ = 0l\n        while (i < resRowSorted.length) {\n            val tuple = resRowSorted(i.toInt)\n\
    \            if (tuple._1 == prevRow) {\n                resRowCol -= tuple\n\
    \            }\n            prevRow = tuple._1\n            i += 1l\n        }\n\
    \        i", "        // Write your code here\n        if (lst.length == 0) return\
    \ List[Tuple2[Long, Long]]()\n        var coordinateList = new ListBuffer[Tuple2[Long,\
    \ Long]]()\n        var countList = new ListBuffer[Long]()\n        var result\
    \ = new ListBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    coordinateList += Tuple2(i.toLong, j.toLong)\n\
    \                    countList += i.toLong\n                }\n            }\n\
    \        }\n        countList = countList.distinct\n        for (i <- 0 until\
    \ countList.length) {\n            var addList = new ListBuffer[Tuple2[Long, Long]]()\n\
    \            for (j <- 0 until coordinateList.length) {\n                if (coordinateList(j)._1\
    \ == countList(i)) {\n                    addList += coordinateList(j)\n     \
    \           }\n            }\n            addList = addList.sortWith((x, y) =>\
    \ x._2 > y._2)\n            for (j <- 0 until addList.length) {\n            \
    \    result += addList(j)\n            }\n        }\n        result.toList", " \
    \       def get(lst : List[List[Long]], x : Long, row : Long, column : Long) :\
    \ List[Tuple2[Long, Long]] = {\n            lst match {\n                case\
    \ Nil => List[Tuple2[Long, Long]]()\n                case h :: t => {\n      \
    \              val col = h.indexOf(x)\n                    if (col == -1) get(t,\
    \ x, row + 1, 0)\n                    else Tuple2(row, column + col) :: get(t,\
    \ x, row + 1, 0)\n                }\n            }\n        }\n        val ret\
    \ = get(lst, x, 0, 0)\n        ret.sortWith((x1, x2) => x1._1 == x2._1 && x1._2\
    \ > x2._2 || x1._1 < x2._1)", "        def helper(lst : List[List[Long]], row\
    \ : Long, col : Long, x : Long, res : List[Tuple2[Long, Long]]) : List[Tuple2[Long,\
    \ Long]] = {\n            if (lst.length == 0) res\n            else {\n     \
    \           if (lst.head.length == 0) helper(lst.tail, row + 1, 0, x, res)\n \
    \               else {\n                    if (lst.head.head == x) helper(lst.tail,\
    \ row + 1, 0, x, (row, col) :: res)\n                    else helper(lst.tail,\
    \ row + 1, 0, x, res)\n                }\n            }\n        }\n        helper(lst,\
    \ 0, 0, x, List()).sortWith((x, y) => x._1 > y._1 || (x._1 == y._1 && x._2 < y._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      var i : Long = 0\n        for (row <- lst) {\n            var j : Long\
    \ = 0\n            for (item <- row) {\n                if (item == x) {\n   \
    \                 result = result :+ (i, j)\n                }\n             \
    \   j += 1\n            }\n            i += 1\n        }\n        result.sortWith((left,\
    \ right) => {\n            if (left._1 < right._1) {\n                true\n \
    \           } else if (left._1 == right._1) {\n                left._2 > right._2\n\
    \            } else {\n                false\n            }\n        })", "  \
    \      val result = ArrayBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            val row = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result += Tuple2(i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.toList.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        lst.zipWithIndex.map\
    \ { case (row, rowIndex) =>\n            val index = row.indexOf(x)\n        \
    \    if (index != -1) {\n                Some((rowIndex, index))\n           \
    \ } else {\n                None\n            }\n        }.flatten.sortWith {\
    \ case ((row1, column1), (row2, column2)) =>\n            if (row1 == row2) {\n\
    \                column1 > column2\n            } else {\n                row1\
    \ < row2\n            }\n        }", "        if (lst.isEmpty) return Nil\n  \
    \      //println(lst)\n        var result = List[Tuple2[Long, Long]]()\n     \
    \   for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) result = result ::: List[Tuple2[Long,\
    \ Long]]((i.toLong, j.toLong))\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // This function\
    \ will be the fun one here, once that's done the rest is not too difficult.\n\
    \        var ans = new ListBuffer[Tuple2[Long, Long]]()\n        def helper(lst\
    \ : List[List[Long]], x : Long, row : Long, offset : Long) : Unit = {\n      \
    \      lst match {\n                case Nil => {\n                    // We've\
    \ hit the end, we're done\n                }\n                case _ => {\n  \
    \                  // First we need to find the index of x in the current row,\
    \ if it exists\n                    val index = lst.head.indexOf(x)\n        \
    \            // If it exists, we'll add the tuple (row, index + offset) to the\
    \ list.\n                    if (index != -1) ans += Tuple2(row, index + offset)\n\
    \                    // Then we recurse with the new row and new offset.\n   \
    \                 helper(lst.tail, x, row + 1, offset + lst.head.length)\n   \
    \             }\n            }\n        }\n        helper(lst, x, 0, 0)\n    \
    \    return ans.toList.sortWith((t1, t2) => {\n            // First we sort by\
    \ the first elements of the tuples, the rows\n            if (t1._1 != t2._1)\
    \ t1._1 < t2._1\n            // Then we sort by the second element, the column,\
    \ in descending order\n            else t1._2 > t2._2\n        })", "    \tvar\
    \ a = new ArrayBuffer[Tuple2[Long, Long]]()\n    \tfor (i <- 0 until lst.length)\
    \ {\n    \t\tfor (j <- 0 until lst(i).length) {\n    \t\t\tif (lst(i)(j) == x)\
    \ a += ((i.toLong, j.toLong))\n    \t\t}\n    \t}\n    \tvar b = a.toList\n  \
    \  \tif (b.length == 0) return b\n    \tb = b.sortWith(_._1 < _._1)\n    \tvar\
    \ start = 0\n    \tvar end = 0\n    \tfor (i <- 0 until b.length) {\n    \t\t\
    if (b(i)._1 == b(start)._1) end = i\n    \t\telse {\n    \t\t\tb = (b.slice(0,\
    \ start) ::: b.slice(start, end + 1).sortWith(_._2 > _._2) ::: b.slice(end + 1,\
    \ b.length))\n    \t\t\tstart = i\n    \t\t\tend = i\n    \t\t}\n    \t}\n   \
    \ \tb = (b.slice(0, start) ::: b.slice(start, end + 1).sortWith(_._2 > _._2) :::\
    \ b.slice(end + 1, b.length))\n    \treturn b", "        val pairList = ArrayBuffer[Tuple2[Long,\
    \ Long]]()\n        var i = 0;\n        lst.foreach(r => {\n            var j\
    \ = 0;\n            r.foreach(c => {\n                if (c == x) {\n        \
    \            pairList += Tuple2(i, j)\n                }\n                j +=\
    \ 1\n            })\n            i += 1\n        })\n        val rowColPairList\
    \ = ArrayBuffer[Tuple2[Long, Long]]()\n        pairList.groupBy(_._1).toList.sortBy(_._1).foreach(row\
    \ => {\n            val ys = row._2.map(_._2).toList.sortWith(_ > _)\n       \
    \     ys.foreach(y => {\n                rowColPairList += Tuple2(row._1, y)\n\
    \            })\n        })\n        rowColPairList.toList", "        // You need\
    \ to return tuple of size 2.\n        // You need to return this in the same order\
    \ as above.\n        // Iterate over the list, and for each element x,\n     \
    \   // If you find element x, return (row, column) as Tuple2.\n        // First\
    \ return is (0, 0) and second return is (0, 1)\n        // and so on.\n      \
    \  var l : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        var\
    \ c : Long = 0\n        for (i <- lst) {\n            var lc : Long = c\n    \
    \        var c2 : Long = 0\n            for (j <- i) {\n                if (j\
    \ == x) {\n                    l = l :+ (lc, c2)\n                }\n        \
    \        c2 = c2 + 1\n            }\n            c = c + 1\n        }\n      \
    \  return l.sortWith((x, y) => x._1 < y._1 || (x._1 == y._1 && x._2 > y._2))",
  "        def take(lst : List[List[Long]], i : Long, j : Long, x : Long) : List[Tuple2[Long,\
    \ Long]] = lst match {\n            case List() => List()\n            case y::ys\
    \ => {\n                if (y.contains(x)) {\n                    (i, y.indexOf(x))\
    \ :: take(ys, i + 1, j, x)\n                } else {\n                    take(ys,\
    \ i + 1, j, x)\n                }\n            }\n        }\n        take(lst,\
    \ 0, 0, x).sortWith((a, b) => {\n            if (a._1 == b._1) {\n           \
    \     a._2 > b._2\n            } else {\n                a._1 < b._1\n       \
    \     }\n        })", "        // Fill up this function body\n        // 'lst'\
    \ is a nested list of integers\n        // 'x' is integer that needs to be searched\
    \ in the list.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      // Note:\n        // 1. Empty list must be returned when no integer x is\
    \ found in the list.\n        // 2. If more than one integer x is found, all of\
    \ them should be returned.\n        // 3. When there are multiple integers x in\
    \ the same row, list should\n        //    have tuples sorted in descending order\
    \ of columns.\n        // 4. When there are multiple integers x in different rows,\
    \ list should\n        //    have tuples sorted in ascending order of rows.\n\
    \        // Hint: If there are multiple integers x in the same row,\n        //\
    \       use scala.math.Ordering[Long] to sort the tuple by columns.\n        //\
    \ Hint: If there are multiple integers x in different rows,\n        //      \
    \ use scala.math.Ordering[Tuple2[Long, Long]] to sort tuples\n        //     \
    \  by rows and columns.\n        // You can use the following implicit to get\
    \ Ordering[Long]\n        //     implicit val longOrd = scala.math.Ordering.Long\n\
    \        // You can use the following implicit to get Ordering[Tuple2[Long, Long]]\n\
    \        //     implicit val tupleOrd = scala.math.Ordering.Tuple2[Long, Long]\n\
    \        def findPositions(row: Int, x: Long, lst: List[List[Long]]): List[Tuple2[Long,\
    \ Long]] = lst match {\n            case Nil => Nil\n            case head ::\
    \ tail => {\n                val found = head.zipWithIndex.filter(_._1 == x)\n\
    \                if (found.isEmpty) findPositions(row + 1, x, tail)\n        \
    \        else {\n                    val result = found.map(x => (row, x._2))\n\
    \                    result ::: findPos", "        // your solution goes here\n\
    \        var tuples = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            var row = lst(i)\n            for (j <- 0 until row.length) {\n\
    \                if (row(j) == x) {\n                    tuples = tuples :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        tuples.sortWith(_._1\
    \ < _._1)\n        tuples.sortWith(_._2 > _._2)\n        tuples", "        //\
    \ Fill up this function body\n        // `lst` is a nested lists, each row may\
    \ contain a different number of columns\n        // You need to extract all x,\
    \ and return list of tuples, [(x1, y1), (x2, y2) ...]\n        // sort coordinates\
    \ initially by rows in ascending order\n        // also, sort coordinates of the\
    \ row by columns in descending order\n        if (lst.isEmpty) return List[Tuple2[Long,\
    \ Long]]()\n        var ans : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) ans = ans :+ (i.toLong, j.toLong)\n \
    \           }\n        }\n        ans = ans.sortWith((a, b) => (a._1 < b._1 ||\
    \ (a._1 == b._1 && a._2 > b._2)))\n        ans", "        var coordinateList =\
    \ new ListBuffer[Tuple2[Long, Long]]()\n        for (row <- 0 until lst.length)\
    \ {\n            for (column <- 0 until lst(row).length) {\n                if\
    \ (lst(row)(column) == x) {\n                    coordinateList += Tuple2(row.toLong,\
    \ column.toLong)\n                }\n            }\n        }\n        return\
    \ coordinateList.toList.sortWith((x, y) => x._1 < y._1 || (x._1 == y._1 && x._2\
    \ > y._2))", "        // Fill up this function body\n        // If you need additional\
    \ classes, you can define them here\n        // You can also use regular expressions\
    \ and other Scala standard library classes\n        null", "      // Fill up this\
    \ function body\n      // Tip: you could use \"filter\" and \"zipWithIndex\" functions\n\
    \      val result = new ArrayBuffer[Tuple2[Long, Long]]()\n      lst.zipWithIndex.foreach(l\
    \ => l._1.zipWithIndex.filter(r => r._1 == x).foreach(r => result += Tuple2(l._2,\
    \ r._2)))\n      result.sortWith((e, f) => e._1 < f._1 || (e._1 == f._1 && e._2\
    \ > f._2)).toList", "        // First we need to split lst into a list of rows\n\
    \        // Where each row is a list of elements.\n        // The getRow method\
    \ returns a list of tuples\n        // Where each tuple has two elements (x, y)\n\
    \        // Where x represents row number and y column number.\n        // On\
    \ the very beginning we sort rows by the number of elements in a row\n       \
    \ // In descending order.\n        // Next we sort each row by elements in a row\
    \ in descending order.\n        // Finally we sort each row by elements in a row\
    \ in ascending order.\n        lst.sortWith((l, r) => l.length < r.length).map(x\
    \ => x.sortWith((l, r) => l > r)).map(x => x.sortWith((l, r) => l < r))\n    \
    \    var result : List[Tuple2[Long, Long]] = List()\n        for (row <- 0 to\
    \ lst.length - 1) {\n            for (column <- 0 to lst(row).length - 1) {\n\
    \                if (lst(row)(column) == x) {\n                    result = result\
    \ :+ (row.toLong, column.toLong)\n                }\n            }\n        }\n\
    \        result", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            var row : List[Long]\
    \ = lst(i)\n            for (j <- 0 until row.length) {\n                if (row(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith(_._1 < _._1)\n        result.sortWith(_._2\
    \ > _._2)\n        result", "        val r = ListBuffer[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) r += ((i.toLong, j.toLong))\n       \
    \     }\n        }\n        r.sortWith((x, y) => if (x._1 != y._1) x._1 < y._1\
    \ else x._2 > y._2).toList", "        // Fill up this function body\n        //\
    \ 'lst' is a 2 dimensional list, similar to a matrix,\n        // 'x' is a value,\
    \ which you have to search in 'lst'.\n        // You have to return the coordinates\
    \ of 'x' in the form of tuples.\n        // The coordinates must be in the form\
    \ of (row, column),\n        // where row is the index of the row, where x is\
    \ present in the list,\n        // and column is the index of x in the list.\n\
    \        // You should first sort the coordinates in increasing order by row.\n\
    \        // For row = 0, sort in increasing order of columns.\n        // For\
    \ row = 1, sort in decreasing order of columns.\n        // For row = 2, sort\
    \ in increasing order of columns.\n        // And so on.\n        // Also, in\
    \ the case of row = 0, column = 0, if x is not present in the row,\n        //\
    \ then you should return (-1l, -1l).\n        // For example, in the case of row\
    \ = 0, column = 0,\n        // if x is not present in the row, then return (-1l,\
    \ -1l)\n        // If the data is empty, then return an empty list.\n        //\
    \ No need to sort the output, the function body will automatically sort the output.\n\
    \        // The output should be in the form of a list.\n        // Hint: You\
    \ can convert a list to a tuple using toTuple2 method.\n        // For example,\n\
    \        // val lst = List(1, 2, 3)\n        // lst.toTuple2()\n        // will\
    \ return (1, List(2, 3))\n        // val lst = List(1, 2, 3)\n        // lst.toTuple2()._2\n\
    \        // will return List(2, 3)\n        // For example,\n        // >>> val\
    \ lst = List(1, 2, 3)\n        // >>> lst.toTuple2()\n        // (1,List(2, 3))\n\
    \        // >>> lst.toTuple2()._2\n        // List(2, 3)\n        // Similarly,\n\
    \        // You can convert a tuple to a list using toList method.\n        //\
    \ For", "        (for (i <- 0 until lst.length) yield\n            for (j <- 0\
    \ until lst(i).length if lst(i)(j) == x) yield (i, j)).toList.flatten.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result\
    \ : List[Tuple2[Long, Long]] = List()\n        for (i <- 0 until lst.length) {\n\
    \            val subList = lst(i)\n            for (j <- 0 until subList.length)\
    \ {\n                if (subList(j) == x) {\n                    result = result\
    \ ::: List((i.toLong, j.toLong))\n                }\n            }\n        }\n\
    \        var sortedResult = result.sortWith((a, b) => (a._1 < b._1 || (a._1 ==\
    \ b._1 && a._2 > b._2)))\n        sortedResult", "        def loop(y : Long, lst\
    \ : List[List[Long]], temp : List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]]\
    \ = {\n            lst match {\n                case Nil => temp\n           \
    \     case h :: t => loop(y + 1, t, getElement(x, y, h, temp))\n            }\n\
    \        }\n        loop(0, lst, List[Tuple2[Long, Long]]())", "      var result\
    \ = List[Tuple2[Long, Long]]()\n      for (i <- 0 to lst.length - 1) {\n     \
    \     for (j <- 0 to lst(i).length - 1) {\n              if (lst(i)(j) == x) {\n\
    \                  result = result :+ (i.toLong, j.toLong)\n              }\n\
    \          }\n      }\n      result.sortWith(_._1 < _._1).map(e => (e._1, e._2)).sortWith(_._2\
    \ > _._2)", "        var res = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    res = res :+ Tuple2(i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        res.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n    \
    \        } else {\n                a._1 < b._1\n            }\n        })", '        return
    (lst.foldLeft(List[Tuple2[Long, Long]]())((acc, l) => acc ::: (l.foldLeft(List[Tuple2[Long,
    Long]]())((acc1, l1) => acc1 ::: (if (l1 == x) List((acc.length, l.length - acc1.length
    - 1)) else List()))))).sortWith((a, b) => if (a._1 == b._1) a._2 > b._2 else a._1
    < b._1)', "        def getRowRec(lst : List[List[Long]], x : Long, i : Long, j\
    \ : Long, \n            lstResult : List[Tuple2[Long, Long]]) : List[Tuple2[Long,\
    \ Long]] = {\n            if (lst.isEmpty) {\n                if (lstResult.isEmpty)\n\
    \                    lstResult\n                else\n                    lstResult.sortWith(_._1\
    \ < _._1)\n            }\n            else {\n                val result = getRowRec(lst.tail,\
    \ x, i + 1, 0,\n                    if (lst.head.contains(x))\n              \
    \          lstResult ::: List[Tuple2[Long, Long]]((i, j + lst.head.indexOf(x)))\n\
    \                    else\n                        lstResult)\n              \
    \  result\n            }\n        }\n        val result = getRowRec(lst, x, 0,\
    \ 0, List[Tuple2[Long, Long]]())\n        result", "        var res = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  res = res :+ (i.toLong, j.toLong)\n                }\n            }\n     \
    \   }\n        res", "        if (lst.isEmpty) return List[Tuple2[Long, Long]]()\n\
    \        var ans = List[Tuple2[Long, Long]]()\n        var row = 0l\n        var\
    \ col = 0l\n        for (row <- 0l until lst.length) {\n            col = 0l\n\
    \            for (col <- 0l until lst(row.toInt).length) {\n                if\
    \ (lst(row.toInt)(col.toInt) == x) {\n                    ans = (row, col) ::\
    \ ans\n                }\n            }\n        }\n        return ans.sortWith((a,\
    \ b) => (a._1 == b._1 && a._2 > b._2) || a._1 < b._1)", "        val y : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        return y", "        def helper(row\
    \ : Long, col : Long, result : List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]]\
    \ = {\n            //println(\"row: \" + row + \" col: \" + col + \" result: \"\
    \ + result)\n            if (row >= lst.length) result.reverse\n            else\
    \ if (col >= lst(row.toInt).length) helper(row + 1, 0, result)\n            else\
    \ if (lst(row.toInt)(col.toInt) == x) helper(row, col + 1, (row, col) :: result)\n\
    \            else helper(row, col + 1, result)\n        }\n        val sorted\
    \ = helper(0, 0, List[Tuple2[Long, Long]]()).sortWith((tuple1, tuple2) => {\n\
    \            if (tuple1._1 != tuple2._1) tuple1._1 < tuple2._1\n            else\
    \ tuple1._2 > tuple2._2\n        })\n        sorted", "        // Your solution\
    \ here\n        var res = List[Tuple2[Long, Long]]()\n        for (i <- 0 to lst.length\
    \ - 1) {\n            val row = lst(i)\n            for (j <- 0 to row.length\
    \ - 1) {\n                if (row(j) == x) res = (i, j) :: res\n            }\n\
    \        }\n        res.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 && a._2\
    \ > b._2))", "        var xs = List[Tuple2[Long, Long]]()\n        var row = 0l\n\
    \        for (l <- lst) {\n            var col = 0l\n            for (x1 <- l)\
    \ {\n                if (x1 == x) xs = (row, col) :: xs\n                col +=\
    \ 1\n            }\n            row += 1\n        }\n        xs.sortWith((e1,\
    \ e2) => if (e1._1 == e2._1) e1._2 > e2._2 else e1._1 < e2._1)", "        var\
    \ ret = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            val index = lst(i).indexOf(x)\n            if (index != -1) ret =\
    \ (i, index) :: ret\n        }\n        return ret.sortWith((e1, e2) => e1._1\
    \ < e2._1)", "        // Fill up this function body\n        // 'lst' is a nested\
    \ list, similar to a matrix.\n        // For example:\n        // lst = List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))\n        // lst.length\
    \ gives you number of rows\n        // lst(i).length gives you number of columns\
    \ of ith row\n        // Each row contains a list of values. You need to find\n\
    \        // column number and row number of 'x' in nested list 'lst'\n       \
    \ // and return a list of tuples that contains\n        // row number, column\
    \ number and value of 'x' in the list.\n        // Since tuples have 2 values,\
    \ use Tuple2[Long, Long]\n        // If a particular 'x' is not found in the list,\n\
    \        // return an empty list.\n        // For example:\n        // lst = List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))\n        // x = 1\n\
    \        // Then, getRow(lst, x) should return\n        // List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l))\n        //", "      // Create\
    \ a Map[Int, mutable.Set[Int]]\n      val lstMap = lst.foldLeft(Map[Int, mutable.Set[Int]]())((acc,\
    \ cur) => {\n        val curSet = acc.getOrElse(cur.count(_ == x), mutable.Set[Int]())\n\
    \        curSet.add(lst.indexOf(cur))\n        acc + (cur.count(_ == x) -> curSet)\n\
    \      })\n      // Return sorted tuples\n      lstMap.toList.sortBy(_._1).flatMap(x\
    \ => x._2.toList.sortBy(x => -x).map(x => (x, lst.indexOf(lst(x).filter(_ == x)))))",
  "        var arr = ArrayBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            var lst1 = lst(i)\n            for (j <- 0 until\
    \ lst1.length) {\n                if (lst1(j) == x) {\n                    arr\
    \ += Tuple2(i.toLong, j.toLong)\n                }\n            }\n        }\n\
    \        return arr.toList.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        // Create a list of rows, which contains all columns,\
    \ with coordinate\n        val rows = ListBuffer[Tuple2[Long, List[Tuple2[Long,\
    \ Long]]]]()\n        for (j <- 0 until lst.length) {\n            val row = ListBuffer[Tuple2[Long,\
    \ Long]]()\n            for (i <- 0 until lst(j).length) {\n                if\
    \ (lst(j)(i) == x) {\n                    row += ((i.toLong, j.toLong))\n    \
    \            }\n            }\n            rows += ((j.toLong, row.toList))\n\
    \        }\n        // Sort by rows in ascending order\n        val srows = rows.toList.sortWith((a,\
    \ b) => {\n            a._1 < b._1\n        })\n        // Sort columns in descending\
    \ order\n        val res = ListBuffer[Tuple2[Long, Long]]()\n        for (row\
    \ <- srows) {\n            val columns = row._2.sortWith((a, b) => {\n       \
    \         a._1 > b._1\n            })\n            for (column <- columns) {\n\
    \                res += column\n            }\n        }\n        res.toList",
  "      // Insert your code here\n      null", "        // Fill up this function\
    \ body\n        // `lst` input contains rows and columns with integer data.\n\
    \        // `x` is the element to be searched in the list `lst`.\n        // You\
    \ have to return a list of tuples `(x1, y1), (x2, y2) ...`\n        // Each tuple\
    \ is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        lst.map(x => x.zipWithIndex.filter(y\
    \ => y._1 == x)).zipWithIndex.flatMap(x => x._1.map(y => (x._2, y._2))).sortBy(y\
    \ => (y._1, -y._2))", "        if (lst.isEmpty) {\n            List[Tuple2[Long,\
    \ Long]]()\n        } else {\n            var result = List[Tuple2[Long, Long]]()\n\
    \            for (i <- 0 to lst.length - 1) {\n                val row = lst(i)\n\
    \                if (row.isEmpty) {\n                    result = result :+ (i,\
    \ 0)\n                } else {\n                    for (j <- 0 to row.length\
    \ - 1) {\n                        if (row(j) == x) {\n                       \
    \     result = result :+ (i, j)\n                        }\n                 \
    \   }\n                }\n            }\n            result.sortWith(\n      \
    \          (x, y) => {\n                    if (x._1 == y._1) {\n            \
    \            x._2 > y._2\n                    } else {\n                     \
    \   x._1 < y._1\n                    }\n                }\n            )\n   \
    \     }", "        var coordinates = List[Tuple2[Long, Long]]()\n        var i\
    \ = 0\n        for (row <- lst) {\n            if (row.isEmpty) {\n          \
    \      i += 1\n                continue\n            }\n            val j = row.indexOf(x)\n\
    \            if (j == -1) {\n                i += 1\n                continue\n\
    \            }\n            coordinates = (i, j) :: coordinates\n            i\
    \ += 1\n        }\n        coordinates", "        val row = lst.zipWithIndex.map(x\
    \ => x._1.zipWithIndex.map(y => (x._2, y._2))).flatten.filter(z => lst(z._1.toInt)(z._2.toInt)\
    \ == x).sortWith((t1, t2) => {\n            if (t1._1 != t2._1) t1._1 < t2._1\
    \ else t1._2 > t2._2\n        })\n        //row.foreach(println)\n        row",
  "        lst.zipWithIndex.flatMap{\n            case (row, idx) => row.zipWithIndex.flatMap{\n\
    \                case (column, jdx) => if (column == x) Some((idx, jdx)) else\
    \ None\n            }\n        }.sorted", "        val arr = ArrayBuffer[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) arr += Tuple2(i.toLong,\
    \ j.toLong)\n            }\n        }\n        arr.sortWith((x, y) => if (x._1\
    \ == y._1) x._2 > y._2 else x._1 < y._1).toList", "        // 1. Find all integers\
    \ `x` in the list `lst`.\n        // 2. Return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // 3. Sort coordinates initially by rows in ascending\
    \ order.\n        // 4. Also, sort coordinates of the row by columns in descending\
    \ order.\n        var length = lst.length\n        var ans : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (j <- 0 until length) {\n \
    \           val lsti = lst(j)\n            var lstiLength = lsti.length\n    \
    \        for (k <- 0 until lstiLength) {\n                val lstj = lsti(k)\n\
    \                if (lstj == x) {\n                    ans = ans ::: List[Tuple2[Long,\
    \ Long]]((j.toLong, k.toLong))\n                }\n            }\n        }\n\
    \        // Sort by rows in ascending order.\n        ans = ans.sortWith((f, s)\
    \ => {\n            if (f._1 > s._1) {\n                true\n            } else\
    \ if (f._1 == s._1) {\n                if (f._2 > s._2) {\n                  \
    \  true\n                } else {\n                    false\n               \
    \ }\n            } else {\n                false\n            }\n        })\n\
    \        ans", "        var l = List[Tuple2[Long, Long]]()\n        for (i <-\
    \ 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n    \
    \            if (lst(i)(j) == x) {\n                    l = (i, j) :: l\n    \
    \            }\n            }\n        }\n        l", "        lst.zipWithIndex.flatMap(\n\
    \            {\n                case (row, i) =>\n                    row.zipWithIndex.filter(\n\
    \                        {\n                            case (item, j) =>\n  \
    \                              if (item == x) true else false\n              \
    \          }\n                    ).map(\n                        {\n        \
    \                    case (item, j) =>\n                                (i.toLong,\
    \ j.toLong)\n                        }\n                    )\n            }\n\
    \        ).sorted", "        // Write your code here\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = (i, j) :: result\n                }\n            }\n        }\n  \
    \      result.sortWith((a, b) => {\n            if (a._1 == b._1) a._2 > b._2\n\
    \            else a._1 < b._1\n        })", '        return lst.zipWithIndex.map(a
    => a._1.zipWithIndex.filter(b => b._1 == x).map(c => (a._2, c._2))).filter(a =>
    a.length > 0).flatten.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2
    > b._2))']
stop_tokens:
- "\n    }\n"
