name: HumanEval_0_has_close_elements
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Check if in given list of numbers, are any two numbers closer to each other\
  \ than\n    // given threshold.\n    // >>> hasCloseElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat)), (0.5f))\n    // (false)\n    // >>> hasCloseElements((List[Float](1.0f.toFloat,\
  \ 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))\n\
  \    // (true)\n    def hasCloseElements(numbers : List[Float], threshold : Float)\
  \ : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(hasCloseElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.3f))\
  \ == (true));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.05f)) == (false));\n\
  \    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat,\
  \ 4.0f.toFloat, 5.0f.toFloat)), (0.95f)) == (true));\n    assert(hasCloseElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.8f)) == (false));\n\
  \    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
  \ 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.1f)) == (true));\n    assert(hasCloseElements((List[Float](1.1f.toFloat,\
  \ 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (1.0f)) == (true));\n\
  \    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat,\
  \ 4.1f.toFloat, 5.1f.toFloat)), (0.5f)) == (false));\n    }\n\n}\n"
completions: ["        var diffs = new ArrayBuffer[Float]()\n        for (num1 <-\
    \ numbers) {\n            for (num2 <- numbers) {\n                if (num1 !=\
    \ num2) {\n                    diffs += abs(num1 - num2)\n                }\n\
    \            }\n        }\n        diffs.contains(threshold)", "        require(numbers.length\
    \ > 1)\n        numbers.length == 2 && Math.abs(numbers(0) - numbers(1)) <= threshold\
    \ ||\n        numbers.length > 2 &&\n            (Math.abs(numbers(0) - numbers(1))\
    \ <= threshold ||\n            Math.abs(numbers(0) - numbers(2)) <= threshold\
    \ ||\n            Math.abs(numbers(1) - numbers(2)) <= threshold ||\n        \
    \    hasCloseElements(numbers.slice(1, numbers.length), threshold))", "      \
    \  var cmp : Float = 0.0f\n        for (i <- 0 until numbers.length - 1) {\n \
    \           for (j <- i + 1 until numbers.length) {\n                cmp = abs(numbers(i)\
    \ - numbers(j))\n                if (cmp < threshold) return true\n          \
    \  }\n        }\n        return false", "        // >>> hasCloseElements((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat)), (0.5f))\n        // (false)\n        def innerLoop(numbers\
    \ : List[Float], threshold : Float, result : Boolean) : Boolean = {\n        \
    \    if (numbers.length < 2) result else {\n                if (abs(numbers(0)\
    \ - numbers(1)) < threshold)\n                    innerLoop(numbers.tail, threshold,\
    \ true)\n                else\n                    innerLoop(numbers.tail, threshold,\
    \ result)\n            }\n        }\n        innerLoop(numbers, threshold, false)",
  "        // >>> numbers\n        // (List[Float](1.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))\n        // >>> threshold\n     \
    \   // (0.3f)\n        // >>> [x for x in combinations(numbers, 2)]\n        //\
    \ [(1.0f.toFloat, 2.8f.toFloat), (1.0f.toFloat, 3.0f.toFloat), (1.0f.toFloat,\
    \ 4.0f.toFloat), (1.0f.toFloat, 5.0f.toFloat), (1.0f.toFloat, 2.0f.toFloat), (2.8f.toFloat,\
    \ 3.0f.toFloat), (2.8f.toFloat, 4.0f.toFloat), (2.8f.toFloat, 5.0f.toFloat), (2.8f.toFloat,\
    \ 2.0f.toFloat), (3.0f.toFloat, 4.0f.toFloat), (3.0f.toFloat, 5.0f.toFloat), (3.0f.toFloat,\
    \ 2.0f.toFloat), (4.0f.toFloat, 5.0f.toFloat), (4.0f.toFloat, 2.0f.toFloat), (5.0f.toFloat,\
    \ 2.0f.toFloat)]\n        // >>> [abs(x[0] - x[1]) for x in combinations(numbers,\
    \ 2)]\n        // [(1.8f.toFloat), (2.0f.toFloat), (3.0f.toFloat), (4.0f.toFloat),\
    \ (3.0f.toFloat), (0.2f.toFloat), (1.2f.toFloat), (2.2f.toFloat), (1.8f.toFloat),\
    \ (1.0f.toFloat), (2.0f.toFloat), (1.0f.toFloat), (2.0f.toFloat), (2.0f.toFloat)]\n\
    \        // >>> [(abs(x", '        return false', "        def inner(flag : Boolean,\
    \ input : List[Float]) : Boolean = {\n            if (input.isEmpty) flag\n  \
    \          else {\n                var min = input.tail.foldLeft(input.head)((acc,\
    \ elem) => { if (abs(acc - elem) < threshold) acc else elem })\n             \
    \   inner(min != input.head, input.tail)\n            }\n        }\n        inner(false,\
    \ numbers)", "        for(i <- 0 until numbers.length - 1; j <- i + 1 until numbers.length)\
    \ {\n            if (abs(numbers(i) - numbers(j)) < threshold) {\n           \
    \     return true\n            }\n        }\n        return false", '        numbers.sorted.sliding(2).map(p
    => abs(p(0) - p(1))).exists(_ < threshold)', "        val index = TreeMap(numbers.map(num\
    \ => (num, num)): _*)\n        var index_i = index.iterator\n        var (prev_element,\
    \ prev_key) = index_i.next\n        while (index_i.hasNext) {\n            val\
    \ (next_element, next_key) = index_i.next\n            if (next_key - prev_key\
    \ < threshold) return true\n            prev_element = next_element\n        \
    \    prev_key = next_key\n        }\n        return false", '        numbers.zip(numbers.tail).map(x
    => abs(x._1 - x._2)).exists(x => x < threshold)', "        require(threshold >\
    \ 0.0f)\n        require(numbers.length > 1)\n        val sortedNumbers = numbers.sorted\n\
    \        var hasCloseElements: Boolean = false\n        var i: Int = 0\n     \
    \   while ((!hasCloseElements) && (i < (sortedNumbers.length - 1))) {\n      \
    \      if ((sortedNumbers(i + 1) - sortedNumbers(i)) < threshold) {\n        \
    \        hasCloseElements = true\n            }\n            i = i + 1\n     \
    \   }\n        hasCloseElements", '      numbers.sorted.zip(numbers.sorted.tail).exists(pair
    => pair._2 - pair._1 < threshold)', "\t\tdef closestElements(l : List[Float])\
    \ : List[Float] = {\n\t\t\tdef rec(l : List[Float], m : Map[Float, Float]) : List[Float]\
    \ = l match {\n\t\t\t\tcase x :: xs => {\n\t\t\t\t\tval mapped = m + (x -> (m.getOrElse(x,\
    \ 0.0f) + 1.0f))\n\t\t\t\t\trec(xs, mapped)\n\t\t\t\t}\n\t\t\t\tcase _ => m.toList\n\
    \t\t\t}\n\t\t\trec(l, Map[Float, Float]())\n\t\t}\n\t\tdef hasCloseElements0(m\
    \ : List[(Float, Float)], threshold : Float) : Boolean = m match {\n\t\t\tcase\
    \ x :: xs => {\n\t\t\t\tif (xs.size == 0) false\n\t\t\t\telse {\n\t\t\t\t\tval\
    \ next = xs.head\n\t\t\t\t\tif (next._1 < x._1 + threshold) true\n\t\t\t\t\telse\
    \ hasCloseElements0(xs, threshold)\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase _ => false\n\
    \t\t}\n\t\thasCloseElements0(closestElements(numbers).sortWith((a, b) => a._1\
    \ < b._1), threshold)", "        var hasCloseElements : Boolean = false\n    \
    \    var checkedElements : List[Float] = Nil\n        numbers.foreach((number\
    \ : Float) => {\n            checkedElements.foreach((checkedElement : Float)\
    \ => {\n                val distance : Float = abs(number - checkedElement)\n\
    \                if (distance < threshold) {\n                    hasCloseElements\
    \ = true\n                }\n            })\n            checkedElements = (number\
    \ :: checkedElements)\n        })\n        return hasCloseElements", '        numbers.combinations(2).exists(numbers
    => abs(numbers(0) - numbers(1)) < threshold)', "      if (numbers.length == 0)\
    \ {\n        return false\n      }\n      var sortedNumbers = numbers.sorted\n\
    \      for (i <- 0 until sortedNumbers.length - 1) {\n        if (sortedNumbers(i\
    \ + 1) - sortedNumbers(i) < threshold) {\n          return true\n        }\n \
    \     }\n      return false", "        for (i <- 0 until numbers.length) {\n \
    \           for (j <- 0 until numbers.length) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < threshold) {\n                    return true\n            \
    \    }\n            }\n        }\n        return false", '        numbers.combinations(2).exists(p
    => abs(p(0) - p(1)) < threshold)', "        var count = 0\n        while (count\
    \ < numbers.length) {\n            var count2 = count + 1\n            while (count2\
    \ < numbers.length) {\n                if (abs(numbers(count) - numbers(count2))\
    \ < threshold) return true\n                count2 += 1\n            }\n     \
    \       count += 1\n        }\n        return false", "        if(numbers.length\
    \ < 2) return false\n        val itr = numbers.sorted.iterator\n        var lastNumber\
    \ = itr.next\n        while(itr.hasNext) {\n            val number = itr.next\n\
    \            if(abs(number - lastNumber) < threshold) return true\n          \
    \  lastNumber = number\n        }\n        return false", "        if (numbers.length\
    \ <= 1) {\n            false\n        } else {\n            numbers.combinations(2).map({nums\
    \ => abs(nums(0) - nums(1))}).min <= threshold\n        }", "        val sortedNumbers\
    \ = numbers.sorted\n        var prevItem : Float = 0\n        var found = false\n\
    \        for (currentItem <- sortedNumbers) {\n            if (prevItem != 0)\
    \ {\n                if (abs(currentItem - prevItem) < threshold) {\n        \
    \            found = true\n                    break\n                }\n    \
    \        }\n            prevItem = currentItem\n        }\n        found", " \
    \       // Fill this in.\n        var result = false\n        for (i <- numbers.indices)\n\
    \            for (j <- i+1 until numbers.length)\n                if (abs(numbers(i)\
    \ - numbers(j)) < threshold) {\n                    result = true\n          \
    \          println(s\"${numbers(i)} ${numbers(j)}\")\n                }\n    \
    \    result", "        // >>> hasCloseElementsHelper((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat)), (0.5f))\n        // >>> hasCloseElementsHelper((List[Float](1.0f.toFloat,\
    \ 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))\n\
    \        def hasCloseElementsHelper(numbers : List[Float], threshold : Float)\
    \ : Boolean = {\n            if (numbers.isEmpty) {\n                false\n \
    \           } else {\n                val lst = numbers.tail\n               \
    \ lst.exists(((x : Float) => abs(x - numbers.head) < threshold)) || hasCloseElementsHelper(lst,\
    \ threshold)\n            }\n        }\n        numbers.nonEmpty && hasCloseElementsHelper(numbers,\
    \ threshold)", "        val sortedNumbers = numbers.sorted\n        for (i <-\
    \ 0 until sortedNumbers.length - 1) {\n            if (abs(sortedNumbers(i) -\
    \ sortedNumbers(i + 1)) < threshold) {\n                return true\n        \
    \    }\n        }\n        return false", "        for (i <- numbers.indices)\
    \ {\n            for (j <- i+1 until numbers.length) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < threshold) return true\n            }\n        }\n        return\
    \ false", "        // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat)), (0.5f))\n        // (false)\n        // >>> hasCloseElements((List[Float](1.0f.toFloat,\
    \ 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))\n\
    \        // (true)\n        val s = scala.collection.mutable.Set[Float]()\n  \
    \      numbers.foreach((number : Float) => {\n            val keys = s.keys\n\
    \            keys.foreach((key : Float) => {\n                if ((abs(number\
    \ - key) < threshold)) {\n                    return true\n                }\n\
    \            })\n            s.add(number)\n        })\n        return false",
  "        var hasClose = false\n        var i = 0\n        while (i < numbers.length\
    \ - 1) {\n            var j = i + 1\n            while (j < numbers.length) {\n\
    \                val diff = abs(numbers(i) - numbers(j))\n                if (diff\
    \ < threshold) {\n                    hasClose = true\n                    return\
    \ hasClose\n                }\n                j = j + 1\n            }\n    \
    \        i = i + 1\n        }\n        return hasClose", "        if (numbers.length\
    \ == 0) return false\n        var sort : List[Float] = numbers.sortWith(_ < _)\n\
    \        for (i <- 0 until sort.length - 1) {\n            if (abs(sort(i) - sort(i\
    \ + 1)) < threshold) return true\n        }\n        return false", "        val\
    \ sortedNumbers = numbers.sorted\n        for (i <- 0 until sortedNumbers.length\
    \ - 1) {\n            if (abs(sortedNumbers(i) - sortedNumbers(i + 1)) < threshold)\
    \ {\n                return true\n            }\n        }\n        return false",
  "        for (i <- 0 until numbers.length) {\n            for (j <- i + 1 until\
    \ numbers.length) {\n                if (abs(numbers(i) - numbers(j)) < threshold)\
    \ return true\n            }\n        }\n        return false", "        val sorted\
    \ = numbers.sorted\n        var prev = sorted.head\n        for (i <- sorted.tail)\
    \ {\n            if (abs(i - prev) < threshold) return true\n            prev\
    \ = i\n        }\n        return false", "        var has = false\n        if\
    \ (numbers.length > 1) {\n            var i = 0\n            var j = 1\n     \
    \       while (j < numbers.length && !has) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < threshold) {\n                    has = true\n             \
    \   }\n                i += 1\n                j += 1\n            }\n       \
    \ }\n        has", "        var sorted = numbers.sorted\n        for (i <- 0 until\
    \ sorted.length - 1) if (abs(sorted(i) - sorted(i + 1)) < threshold) return true\n\
    \        return false", '        return false', "        if (numbers.length ==\
    \ 0) {\n            false\n        } else {\n            val (min, max) = (numbers.min,\
    \ numbers.max)\n            if (max - min <= threshold) {\n                true\n\
    \            } else {\n                var minDiff : Float = Float.MaxValue\n\
    \                for (i <- 0 until numbers.length) {\n                    for\
    \ (j <- i + 1 until numbers.length) {\n                        minDiff = min(minDiff,\
    \ abs(numbers(i) - numbers(j)))\n                    }\n                }\n  \
    \              if (minDiff <= threshold) {\n                    true\n       \
    \         } else {\n                    false\n                }\n           \
    \ }\n        }", "        var result : Boolean = false\n        for (i <- numbers.indices)\
    \ {\n            for (j <- numbers.indices) {\n                if (i != j) {\n\
    \                    if (abs(numbers(i) - numbers(j)) < threshold) {\n       \
    \                 result = true\n                    }\n                }\n  \
    \          }\n        }\n        return result", "        // Preprocess input\n\
    \        val numbers = _numbers.sorted\n        // Initialize result\n       \
    \ var result = false\n        // Iterate over numbers and check if they are close\
    \ to each other\n        var i = 0\n        while ((i < numbers.length)) {\n \
    \           {\n                var j = 0\n                while ((j < numbers.length))\
    \ {\n                    {\n                        if (((i != j) && ((abs((numbers(i)\
    \ - numbers(j))) < threshold)))) {\n                            result = true\n\
    \                        }\n                    }\n                    ({\n  \
    \                      j += 1; j - 1\n                    })\n               \
    \ }\n            }\n            ({\n                i += 1; i - 1\n          \
    \  })\n        }\n        // Return result\n        result", "        var isFound\
    \ : Boolean = false\n        for (i <- 0 until numbers.length - 1) {\n       \
    \     for (j <- i + 1 until numbers.length) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < threshold) {\n                    isFound = true\n         \
    \       }\n            }\n        }\n        isFound", "        if (numbers.length\
    \ == 1) return false\n        else if (numbers.length == 2) abs(numbers(0) - numbers(1))\
    \ <= threshold\n        else if (abs(numbers(0) - numbers(1)) <= threshold) true\n\
    \        else hasCloseElements(numbers.tail, threshold)", "        var hasElements\
    \ = false\n        for (i <- 0 until numbers.length) {\n            for (j <-\
    \ i + 1 until numbers.length) {\n                if (abs(numbers(i) - numbers(j))\
    \ < threshold) {\n                    hasElements = true\n                }\n\
    \            }\n        }\n        hasElements", "        require(numbers.size\
    \ > 1)\n        if(numbers.size == 2) {\n            return abs(numbers(0) - numbers(1))\
    \ < threshold\n        }\n        val sortedNumbers = numbers.sorted\n       \
    \ for(i <- 1 until sortedNumbers.size) {\n            if(abs(sortedNumbers(i)\
    \ - sortedNumbers(i - 1)) < threshold) {\n                return true\n      \
    \      }\n        }\n        return false", '        numbers.sorted.zip(numbers.sorted.tail).exists(x
    => x._2 - x._1 < threshold)', "        var sortedNumbers = numbers.sorted\n  \
    \      for (i <- 0 until sortedNumbers.length - 1) {\n            if (abs(sortedNumbers(i)\
    \ - sortedNumbers(i + 1)) < threshold) {\n                return true\n      \
    \      }\n        }\n        return false", "        def innerHasCloseElements(numbers\
    \ : List[Float], threshold : Float, index : Int) : Boolean = {\n            if\
    \ (index >= numbers.length) false\n            else {\n                val current\
    \ : Float = numbers(index)\n                if (numbers.tail.exists((n : Float)\
    \ => abs(n - current) < threshold)) true\n                else innerHasCloseElements(numbers,\
    \ threshold, index + 1)\n            }\n        }\n        innerHasCloseElements(numbers,\
    \ threshold, 0)", "        def hasCloseElementsIter(numbers : List[Float], threshold\
    \ : Float, minDiff : Float) : Boolean = numbers match {\n            case List()\
    \ => false\n            case x :: Nil => false\n            case x :: xs => {\n\
    \                val diff = xs.map(y => abs(x - y)).min\n                if (diff\
    \ < threshold) {\n                    true\n                } else {\n       \
    \             hasCloseElementsIter(xs, threshold, diff)\n                }\n \
    \           }\n        }\n        hasCloseElementsIter(numbers.sorted, threshold,\
    \ Float.MaxValue)", "        var result : Boolean = false\n        val len : Int\
    \ = numbers.length\n        if (len > 1) {\n            var last : Float = numbers(0)\n\
    \            for (i <- 1 until len) {\n                if (abs(last - numbers(i))\
    \ < threshold) {\n                    result = true\n                    return\
    \ result\n                }\n                last = numbers(i)\n            }\n\
    \        }\n        return result", '        numbers.sortWith(_ < _).zip(numbers.sortWith(_
    < _).tail).map(item => item._2 - item._1).filter(a => a < threshold).length >
    0', "        def diff(e1 : Float, e2 : Float) : Float = abs(e1 - e2)\n       \
    \ def helper(list : List[Float]) : Boolean = list match {\n            case Nil\
    \ => false\n            case x :: Nil => false\n            case x :: xs => (diff(x,\
    \ xs.head) < threshold) || helper(xs)\n        }\n        helper(numbers)", " \
    \       // Sort the numbers. Then, the closest numbers will be next to each other.\n\
    \        val sortedNumbers = numbers.sorted\n        // The start index is at\
    \ 1, because we need at least two numbers to check.\n        for (i <- 1 until\
    \ sortedNumbers.length) {\n            // Check if the absolute difference between\
    \ two numbers is less than threshold.\n            if (Math.abs(sortedNumbers(i)\
    \ - sortedNumbers(i - 1)) < threshold) return true\n        }\n        return\
    \ false", "        // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat)), (0.5f))\n        // (false)\n        // >>> hasCloseElements((List[Float](1.0f.toFloat,\
    \ 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))\n\
    \        // (true)\n        if (numbers.size == 0) {\n            false\n    \
    \    } else {\n            val tail = numbers.tail\n            if (tail.size\
    \ == 0) {\n                false\n            } else {\n                val head\
    \ = numbers.head\n                val tailHead = tail.head\n                if\
    \ (abs(head - tailHead) <= threshold) {\n                    true\n          \
    \      } else {\n                    hasCloseElements(tail, threshold)\n     \
    \           }\n            }\n        }", "        val sortedNumbers = numbers.sorted\n\
    \        val sortedPairs = sortedNumbers.tails.filter(_.nonEmpty).filter(_.length\
    \ >= 2).map(_.toList).toList\n        sortedPairs.map(pair => pair.tail.head -\
    \ pair.head).foldLeft(threshold)((acc, currentValue) => acc min currentValue)\
    \ < threshold", "        for (i <- 0 until numbers.length) {\n            for\
    \ (j <- i + 1 until numbers.length) {\n                if (abs(numbers(i) - numbers(j))\
    \ < threshold) return true\n            }\n        }\n        return false", " \
    \       val sortedNumbers = numbers.sorted\n        for (i <- 0 until sortedNumbers.length\
    \ - 1) {\n            if (sortedNumbers(i + 1) - sortedNumbers(i) < threshold)\
    \ {\n                return true\n            }\n        }\n        return false",
  "        def func(numbers : List[Float], currentNumber : Float, currentClosest :\
    \ Float) : Boolean = {\n            if (numbers.isEmpty) return false\n      \
    \      else {\n                val nextNumber = numbers.head\n               \
    \ if (abs(currentNumber - nextNumber) < currentClosest) return true\n        \
    \        else func(numbers.tail, nextNumber, min(currentClosest, abs(currentNumber\
    \ - nextNumber)))\n            }\n        }\n        if (numbers.isEmpty) return\
    \ false\n        else func(numbers.tail, numbers.head, threshold)", '        return
    false', "        // >>> 2.8 - 2.0\n        // (0.7999999999999998)\n        //\
    \ |x - y| = a, |y - z| = b, |x - z| = c\n        // let d = b + c - a\n      \
    \  // d > 0\n        var pairs = List[(Float, Float)]()\n        val n = numbers.length\n\
    \        for (i <- 0 until n - 1) {\n            for (j <- i + 1 until n) {\n\
    \                pairs = pairs :+ (numbers(i), numbers(j))\n            }\n  \
    \      }\n        pairs.exists(pair => abs(pair._1 - pair._2) < threshold)", " \
    \       if (numbers.length < 2) {\n            return false\n        }\n     \
    \   var cache = new HashMap[Float, Int]()\n        cache(numbers(0)) = 1\n   \
    \     for (i <- 1 until numbers.length) {\n            var found = false\n   \
    \         var pos = 0\n            while (!found && pos < i) {\n             \
    \   if (abs(numbers(i) - numbers(pos)) < threshold) {\n                    found\
    \ = true\n                }\n                pos += 1\n            }\n       \
    \     if (found) {\n                return true\n            }\n        }\n  \
    \      return false", "        def loop(n : Int, v : Float, s : Float) : Boolean\
    \ = {\n            if (n == numbers.length) {\n                false\n       \
    \     } else {\n                if (abs(numbers(n) - v) < threshold) {\n     \
    \               true\n                } else {\n                    loop(n + 1,\
    \ v, s)\n                }\n            }\n        }\n        var r = false\n\
    \        var i = 0\n        while (i < numbers.length && !r) {\n            r\
    \ = loop(i + 1, numbers(i), threshold)\n            i = i + 1\n        }\n   \
    \     r", "        var result : Boolean = false\n        for(i <- 1 until numbers.length)\
    \ {\n            for(j <- 0 until i) {\n                if(abs(numbers(i) - numbers(j))\
    \ < threshold) {\n                    result = true\n                }\n     \
    \       }\n        }\n        return result", "        var hasCloseElements =\
    \ false\n        var count = 0\n        var i = 0\n        while((count < 2) &&\
    \ (i < numbers.length)) {\n            var j = i + 1\n            while((count\
    \ < 2) && (j < numbers.length)) {\n                val distance = abs(numbers(i)\
    \ - numbers(j))\n                if(distance < threshold) {\n                \
    \    count = count + 1\n                }\n                j = j + 1\n       \
    \     }\n            i = i + 1\n        }\n        if(count > 1) {\n         \
    \   hasCloseElements = true\n        }\n        hasCloseElements", "        def\
    \ check(a : Float, b : Float) : Boolean = ((a - b).abs < threshold)\n        def\
    \ helper(numbers : List[Float]) : Boolean = {\n            if(numbers.length <\
    \ 2) false\n            else {\n                val first :: second :: remaining\
    \ = numbers\n                if(check(first, second)) true\n                else\
    \ helper(second :: remaining)\n            }\n        }\n        if(numbers.length\
    \ < 2) false\n        else {\n            val first :: second :: remaining = numbers\n\
    \            if(check(first, second)) true\n            else helper(second ::\
    \ remaining)\n        }", "        def hasCloserElements(numbers : List[Float],\
    \ index : Int, threshold : Float) : Boolean = {\n            if (index == 0) {\n\
    \                return false\n            }\n            else {\n           \
    \     val distance = (numbers(index) - numbers(index - 1)).abs\n             \
    \   if (distance < threshold) {\n                    return true\n           \
    \     }\n                else {\n                    return hasCloserElements(numbers,\
    \ index - 1, threshold)\n                }\n            }\n        }\n       \
    \ return hasCloserElements(numbers.sorted, numbers.length - 1, threshold)", " \
    \       numbers.sortInPlaceWith((n1 : Float, n2 : Float) => (n1 < n2));\n    \
    \    var diff: Float = 0.0f;\n        for (i <- Range(0, numbers.length - 1))\
    \ {\n            diff = numbers(i + 1) - numbers(i);\n            if (diff < threshold)\
    \ {\n                return true;\n            }\n        }\n        return false;",
  "        // I would have done this iteratively but for some reason it was really\
    \ slow.\n        // This is not really a fast solution, but it's a bit faster\
    \ than the iterative solution.\n        // However, because the number of comparisons\
    \ are O(n * (n - 1)) this is not optimal.\n        //\n        // The optimal\
    \ solution is to use a sorted list and then eliminate the number of comparisons\n\
    \        // by checking if the next number is too far away from the current number\
    \ to be\n        // any closer to the next number.\n        // This is something\
    \ that I'll do later.\n        val distances = (for (i <- numbers; j <- numbers)\
    \ yield abs(i - j)).toList\n        val distancesWithThreshold = distances.filter(x\
    \ => (x > 0 && x < threshold))\n        distancesWithThreshold.size > 0", "  \
    \      var has = false\n        for(i <- 0 until numbers.length - 1) {\n     \
    \       if (numbers(i) > threshold) {\n                val diff = abs(numbers(i)\
    \ - numbers(i + 1))\n                if (diff <= threshold) {\n              \
    \      has = true\n                }\n            }\n        }\n        has",
  "        // >>> isClose((1.0f.toFloat, 2.0f.toFloat), (0.5f))\n        // (false)\n\
    \        // >>> isClose((2.0f.toFloat, 2.3f.toFloat), (0.3f))\n        // (true)\n\
    \        def isClose(pair : (Float, Float), threshold : Float) : Boolean = {\n\
    \            val (a, b) = pair\n            abs(a - b) < threshold\n        }\n\
    \        def hasCloseElementsHelper(numbers : List[Float], pairs : Set[(Float,\
    \ Float)]) : Boolean = {\n            numbers match {\n                case Nil\
    \ => false\n                case List(x) => false\n                case x :: xs\
    \ => {\n                    for (pair <- pairs) {\n                        if\
    \ (isClose(pair, threshold)) {\n                            return true\n    \
    \                    }\n                    }\n                    hasCloseElementsHelper(xs,\
    \ pairs + Tuple2(x, xs.head))\n                }\n            }\n        }\n \
    \       hasCloseElementsHelper(numbers, Set[(Float, Float)]())", "        if (numbers.length\
    \ <= 1) return false\n        else {\n            var lastValue : Float = numbers(0)\n\
    \            for (number <- numbers.slice(1, numbers.length)) {\n            \
    \    if (abs(number - lastValue) < threshold) return true\n                lastValue\
    \ = number\n            }\n            return false\n        }", "        val\
    \ l = numbers.length\n        for (i <- 0 until l) {\n            for (j <- i\
    \ + 1 until l) {\n                if (abs(numbers(i) - numbers(j)) < threshold)\
    \ return true\n            }\n        }\n        return false", "        val diff\
    \ = (a : Float, b : Float) => abs(a - b)\n        for (i <- numbers) {\n     \
    \       for (j <- numbers) {\n                if (diff(i, j) < threshold) {\n\
    \                    return true\n                }\n            }\n        }\n\
    \        return false", "        val numbers2 = (numbers, numbers.tail).zipped.map(\
    \ _ - _)\n        return numbers2.filter( e => e <= threshold && e >= (threshold\
    \ * -1) ).size > 0", "        val distances = numbers.sortWith((n1, n2) => (n1\
    \ < n2)).sliding(2).toList.map(pair => (pair(1) - pair(0)))\n        distances.filter(d\
    \ => (d < threshold)).size > 0", "        val sorted = numbers.sorted\n      \
    \  val diffs = sorted.zip(sorted.tail).map(p => abs(p._1 - p._2))\n        val\
    \ min = diffs.min\n        min < threshold", "        if (numbers.size == 0) {\n\
    \            false\n        } else {\n            val sortedNumbers = numbers.sorted\n\
    \            var i = 0\n            var j = 1\n            while (j < sortedNumbers.size)\
    \ {\n                while (sortedNumbers(j) - sortedNumbers(i) > threshold) {\n\
    \                    i += 1\n                }\n                if (sortedNumbers(j)\
    \ - sortedNumbers(i) <= threshold) {\n                    return true\n      \
    \          }\n                j += 1\n            }\n            false\n     \
    \   }", '        numbers.sortWith((a, b) => a < b).sliding(2).exists(list => abs(list(0)
    - list(1)) < threshold)', "        for (i <- 0 until numbers.length - 1) {\n \
    \           for (j <- i + 1 until numbers.length) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < threshold) {\n                    return true\n            \
    \    }\n            }\n        }\n        return false", "        var result :\
    \ Boolean = false\n        for (i <- 0 until numbers.length - 1) {\n         \
    \   for (j <- i + 1 until numbers.length) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < threshold) {\n                    result = true\n          \
    \      }\n            }\n        }\n        return result", "        if (numbers.length\
    \ <= 1) return false\n        var result = false\n        var prev = numbers(0)\n\
    \        var i = 1\n        while(i < numbers.length) {\n            if (abs(numbers(i)\
    \ - prev) < threshold) {\n                result = true\n                i = numbers.length\n\
    \            }\n            prev = numbers(i)\n            i += 1\n        }\n\
    \        return result", "        for (i <- 0 until numbers.length; j <- i + 1\
    \ until numbers.length) {\n            if (abs(numbers(i) - numbers(j)) < threshold)\
    \ {\n                return true\n            }\n        }\n        return false",
  "        val pairs = numbers.combinations(2)\n        pairs.find(pair => abs(pair(0)\
    \ - pair(1)) < threshold) match {\n            case Some(pair) => true\n     \
    \       case None => false\n        }", '        return false', '        numbers.map(x
    => abs(x - (numbers.filter(y => y > x).min))).min < threshold', "        var result\
    \ : Boolean = false\n        for (i <- 0 until numbers.length - 1)\n         \
    \   if (abs(numbers(i) - numbers(i + 1)) < threshold) result = true\n        result",
  "        // >>> Solution\n        // ~ for i in range(len(numbers))\n        for\
    \ (i <- 0 to numbers.length - 1) {\n            // ~ for j in range(i+1, len(numbers))\n\
    \            for (j <- i + 1 to numbers.length - 1) {\n                // ~ if\
    \ abs(numbers[i] - numbers[j]) < threshold:\n                if (abs(numbers(i)\
    \ - numbers(j)) < threshold) {\n                    // ~ return true\n       \
    \             return true\n                }\n            }\n        }\n     \
    \   // ~ return false\n        return false\n        // <<< Solution", "     \
    \   numbers.sortWith((a, b) => a < b).sliding(2).exists({\n            case (x1)\
    \ :: (x2) :: Nil => abs(x1 - x2) < threshold\n            case _ => false\n  \
    \      })", "        // Will contain all elements in numbers, sorted ascending.\n\
    \        var sortedNumbers = numbers.sorted\n        // Last checked index.\n\
    \        var lastIndex = 0\n        // Iterate over sorted numbers.\n        for\
    \ (number <- sortedNumbers) {\n            // Find index of next element with\
    \ value larger than number + threshold.\n            var i = sortedNumbers.indexWhere((a\
    \ : Float) => (a >= (number + threshold)), lastIndex)\n            // No next\
    \ element found.\n            if (i == -1) {\n                // Stop looking\
    \ for close elements.\n                return false\n            }\n         \
    \   // Move last checked index to where the next element was found.\n        \
    \    lastIndex = i\n        }\n        // True if we found two close elements.\n\
    \        return true", "        var hasClose : Boolean = false\n        if (numbers.length\
    \ < 2) {\n            hasClose = false\n        } else {\n            var orderedNumbers\
    \ : List[Float] = numbers.sorted\n            var i : Int = 0\n            while\
    \ (i < orderedNumbers.length - 1) {\n                if ((orderedNumbers(i) -\
    \ orderedNumbers(i + 1)).abs < threshold) {\n                    hasClose = true\n\
    \                    i = orderedNumbers.length\n                }\n          \
    \      i = i + 1\n            }\n        }\n        hasClose", '        ???',
  "        var nums = numbers.sortWith((a, b) => a < b)\n        for (i <- 0 until\
    \ nums.length - 1) {\n            val delta = abs(nums(i) - nums(i + 1))\n   \
    \         if (delta < threshold) return true\n        }\n        return false",
  '        numbers.map(Number(_)).combinations(2).map((pair : List[Number]) => abs(pair(0).value
    - pair(1).value)).min < threshold', '        null', "        val arr = numbers.sorted\n\
    \        var prev = arr(0)\n        for (n <- arr.tail) {\n            if (n -\
    \ prev < threshold) return true\n            prev = n\n        }\n        return\
    \ false", "        for (i <- 0 until numbers.length - 1) {\n            if (numbers(i)\
    \ > numbers(i + 1)) return false\n            if (abs(numbers(i) - numbers(i +\
    \ 1)) < threshold) return true\n        }\n        return false", "        val\
    \ n = numbers.size\n        for (i <- 0 until n; j <- i + 1 until n) {\n     \
    \       if (abs(numbers(i) - numbers(j)) < threshold) return true\n        }\n\
    \        return false", "        var closest : Float = Float.MaxValue\n      \
    \  for(i <- 0 until numbers.length - 1) {\n            for(j <- i + 1 until numbers.length)\
    \ {\n                closest = min(closest, abs(numbers(i) - numbers(j)))\n  \
    \          }\n        }\n        return (closest < threshold)", "        var result\
    \ : Boolean = false\n        for (i <- numbers.indices) {\n            for (j\
    \ <- (i + 1) until numbers.length) {\n                if (abs(numbers(i) - numbers(j))\
    \ < threshold) {\n                    result = true\n                }\n     \
    \       }\n        }\n        return result", "        val sortedNumbers = numbers.sorted\n\
    \        sortedNumbers.sliding(2).foldLeft(false)((acc, n) =>\n            if\
    \ (acc) true\n            else if (n.length == 2) (n(1) - n(0)) < threshold\n\
    \            else false\n        )", "        var i = 0\n        while(i < numbers.length)\
    \ {\n            var j = i + 1\n            while(j < numbers.length) {\n    \
    \            if(abs(numbers(i) - numbers(j)) < threshold) {\n                \
    \    return true\n                }\n                j += 1\n            }\n \
    \           i += 1\n        }\n        return false", "        var sortedNumbers\
    \ = numbers.sorted\n        //println(sortedNumbers)\n        var result = false\n\
    \        for (i <- 0 until sortedNumbers.length - 1) {\n            if (sortedNumbers(i\
    \ + 1) - sortedNumbers(i) < threshold) {\n                result = true\n    \
    \            break\n            }\n        }\n        result", "        val sortedNumbers\
    \ = numbers.sorted\n        var i = 0\n        var j = i + 1\n        while(j\
    \ < sortedNumbers.length) {\n            if(abs(sortedNumbers(i) - sortedNumbers(j))\
    \ < threshold) return true\n            i += 1\n            j += 1\n        }\n\
    \        return false", "        numbers.sortInPlaceWith((_ : Float) < (_ : Float))\n\
    \        for (i <- 0 until numbers.length - 1) {\n            if (numbers(i +\
    \ 1) - numbers(i) < threshold) {\n                return true\n            }\n\
    \        }\n        return false", "        numbers.sortInPlaceWith((_ - _).abs\
    \ < threshold)\n        var result = false\n        for (i <- numbers.indices)\
    \ {\n            result = result || numbers.indexOf(numbers(i), i + 1) != -1\n\
    \        }\n        result", "      var result = false\n      for (i <- numbers)\
    \ {\n        for (j <- numbers) {\n          if (abs(i - j) < threshold) {\n \
    \           result = true\n          }\n        }\n      }\n      return result",
  "        // The algorithm is as follows:\n        //\n        // 1. Find the max\
    \ and min number in the list.\n        // 2. From min to max, check if there are\
    \ two numbers in the given list closer to each other\n        //    than threshold.\n\
    \        //\n        // Implementation:\n        //\n        // 1. Get min and\
    \ max.\n        // 2. For each number in the list, add it to a histogram with\
    \ a bin of size\n        //    threshold.\n        // 3. For each histogram bin,\
    \ check if it contains more than 1 element.\n        // 4. If there are more than\
    \ one element in a bin, it means two elements are\n        //    closer to each\
    \ other than threshold.\n        val min = numbers.min\n        val max = numbers.max\n\
    \        val numBins = ceil((max - min) / threshold).toInt\n        val histogram\
    \ = Array.fill[ArrayBuffer[Float]](numBins)(new ArrayBuffer[Float])\n        for\
    \ (n <- numbers) {\n            val bin = floor((n - min) / threshold).toInt\n\
    \            histogram(bin) += n\n        }\n        histogram.foldLeft(false)((acc,\
    \ el) => acc || (el.length > 1))", "        def pairwise(numbers : List[Float])\
    \ : List[(Float, Float)] = numbers match {\n            case Nil => Nil\n    \
    \        case (x :: xs) => xs.map((x, _)) ::: pairwise(xs)\n        }\n      \
    \  pairwise(numbers).filter(p => abs(p._1 - p._2) < threshold).size > 0", '        numbers.combinations(2).exists(x
    => abs(x(0) - x(1)) < threshold)', "        // >>>\n        var i = 0\n      \
    \  var j = 0\n        for (i <- 0 to numbers.length - 1) {\n            for (j\
    \ <- 0 to numbers.length - 1) {\n                if (abs(numbers(i) - numbers(j))\
    \ < threshold) {\n                    return true\n                }\n       \
    \     }\n        }\n        return false\n        // <<<", "        // >>> numbers.sort((a\
    \ : Float, b : Float) => (a.compareTo(b)))\n        // (List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n   \
    \     // >>> numbers.sorted\n        // (List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n        // >>> numbers.sortBy((f\
    \ : Float) => (f))\n        // (List[Float](1.0f.toFloat, 2.0f.toFloat, 2.8f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n        var sortedNumbers : List[Float]\
    \ = numbers.sorted\n        // >>> sortedNumbers.zipWithIndex\n        // (List[(Float,\
    \ Int)]((1.0f.toFloat, 0), (2.0f.toFloat, 1), (2.8f.toFloat, 2), (3.0f.toFloat,\
    \ 3), (4.0f.toFloat, 4), (5.0f.toFloat, 5)))\n        // >>> sortedNumbers.zipWithIndex.map((t\
    \ : (Float, Int)) => (abs(t._1 - (sortedNumbers(t._2 + 1) : Float))))\n      \
    \  // (List[Float](1.0f.toFloat, 0.8f.toFloat, 0.2f.toFloat, 1.0f.toFloat, 1.0f.toFloat))\n\
    \        var result : Boolean = sortedNumbers.zipWithIndex.map((t : (Float, Int))\
    \ => (abs(t._1 - (sortedNumbers(t._2 + 1) : Float)))).exists((f : Float) => (f\
    \ < threshold))\n        // >>> (0.5f <= 0.3f)\n        // (false)\n        //\
    \ >>> (1.0f <= 0.3f)\n        // (false)", "        // Empty list\n        if\
    \ (numbers.length == 0) return false\n        var prev : Float = numbers(0)\n\
    \        for (num <- numbers) {\n            if (abs(num - prev) < threshold)\
    \ return true\n            prev = num\n        }\n        return false", "   \
    \     (numbers, threshold) match {\n            case (((x : Float) :: (xs : List[Float])),\
    \ (thr : Float)) =>\n                xs.map((y : Float) => abs(x - y)).min < thr\n\
    \            case _ =>\n                false\n        }", "        for (i <-\
    \ 0 until numbers.length) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                if (abs(numbers(i) - numbers(j)) < threshold) return true\n\
    \            }\n        }\n        return false", '        numbers.sorted.sliding(2).exists(n
    => abs(n(0) - n(1)) < threshold)', "        for (i <- 0 until numbers.length -\
    \ 1) {\n            for (j <- i + 1 until numbers.length) {\n                if\
    \ (abs(numbers(i) - numbers(j)) < threshold) {\n                    return true\n\
    \                }\n            }\n        }\n        return false", "       \
    \ if (numbers.size <= 1) false\n        else {\n            val sortedList = numbers.sorted\n\
    \            var first = sortedList.head\n            var second = sortedList.tail.head\n\
    \            var diff = abs(first - second)\n            for (num <- sortedList.tail.tail)\
    \ {\n                if (diff < threshold) return true\n                else {\n\
    \                    first = second\n                    second = num\n      \
    \              diff = abs(first - second)\n                }\n            }\n\
    \            false\n        }", "        var result : Boolean = false\n      \
    \  var head : Float = 0.0f\n        var tail : List[Float] = Nil\n        head\
    \ = numbers.head\n        tail = numbers.tail\n        while ((!result) && (!tail.isEmpty))\
    \ {\n            result = abs(head - tail.head) < threshold\n            head\
    \ = tail.head\n            tail = tail.tail\n        }\n        result", "   \
    \     var result : Boolean = false\n        var i : Int = 0\n        while ((i\
    \ < numbers.length) && (!result)) {\n            var j : Int = i + 1\n       \
    \     while ((j < numbers.length) && (!result)) {\n                result = ((abs(numbers(i))\
    \ - abs(numbers(j))) < threshold)\n                j = j + 1\n            }\n\
    \            i = i + 1\n        }\n        return result", "        if (numbers.length\
    \ == 0) false\n        else {\n            var minimum = Float.MaxValue\n    \
    \        for (i <- 0 until numbers.length) {\n                for (j <- i + 1\
    \ until numbers.length) {\n                    minimum = min(minimum, abs(numbers(i)\
    \ - numbers(j)))\n                }\n            }\n            if (minimum <=\
    \ threshold) true\n            else false\n        }", "        val sorted = numbers.sorted\n\
    \        var hasClose = false\n        for (i <- 1 until sorted.length) {\n  \
    \          if (abs(sorted(i) - sorted(i - 1)) < threshold) {\n               \
    \ hasClose = true\n            }\n        }\n        hasClose", "        var i\
    \ = 0\n        while (i < numbers.length) {\n            var j = i + 1\n     \
    \       while (j < numbers.length) {\n                if (numbers(i) - numbers(j)\
    \ > threshold && numbers(j) - numbers(i) > threshold) {\n                    return\
    \ false\n                }\n                j = j + 1\n            }\n       \
    \     i = i + 1\n        }\n        return true", "        var sortedNumbers =\
    \ numbers.sorted\n        var i = 0\n        while(i < sortedNumbers.length -\
    \ 1) {\n            if (sortedNumbers(i + 1) - sortedNumbers(i) < threshold) return\
    \ true\n            i += 1\n        }\n        return false", "        var firstElem\
    \ : Float = numbers.head\n        for (n <- numbers.tail) {\n            if (abs(n\
    \ - firstElem) < threshold) {\n                return true\n            }\n  \
    \          firstElem = n\n        }\n        return false", "        var minDiff\
    \ = threshold\n        var start = 0\n        var end = 1\n        while (end\
    \ < numbers.length) {\n            val diff = abs(numbers(start) - numbers(end))\n\
    \            if (diff < minDiff) {\n                minDiff = diff\n         \
    \   }\n            start += 1\n            end += 1\n        }\n        return\
    \ minDiff == threshold", "        var i = 0\n        var j = 1\n        var k\
    \ = 0\n        var elem = true\n        while(i < numbers.length && j < numbers.length\
    \ && elem) {\n            if (abs(numbers(i) - numbers(j)) <= threshold) {\n \
    \               elem = false\n            }\n            else {\n            \
    \    k = j\n                while(k < numbers.length && elem) {\n            \
    \        if (abs(numbers(i) - numbers(k)) <= threshold) {\n                  \
    \      elem = false\n                    }\n                    k += 1\n     \
    \           }\n            }\n            i += 1\n            j += 1\n       \
    \ }\n        elem", "        var this_num : Float = 0.0f\n        var next_num\
    \ : Float = 0.0f\n        var found : Boolean = false\n        for (pair <- numbers.sliding(2))\
    \ {\n            this_num = pair(0)\n            next_num = pair(1)\n        \
    \    if ((abs(this_num - next_num)) < threshold) {\n                found = true\n\
    \            }\n        }\n        return found", "        var i = 0\n       \
    \ var f = 0\n        while(i < numbers.length) {\n            while(f < numbers.length)\
    \ {\n                if(i != f) {\n                    if(abs(numbers(i) - numbers(f))\
    \ < threshold) {\n                        return true\n                    }\n\
    \                }\n                f = f + 1\n            }\n            i =\
    \ i + 1\n        }\n        return false", "        // a < b <=> not (a >= b)\n\
    \        numbers.combinations(2).find(pair => (pair(0) - pair(1)).abs <= threshold)\
    \ match {\n            case Some(pair) => true\n            case None => false\n\
    \        }", "        if (numbers.length <= 1) false\n        else {\n       \
    \     var i = 0\n            var j = 1\n            while(j < numbers.length)\
    \ {\n                if (abs(numbers(i) - numbers(j)) < threshold) return true\n\
    \                i += 1\n                j += 1\n            }\n            false\n\
    \        }", "        var result : Boolean = false\n        if (numbers.size >\
    \ 0) {\n            val sNumbers = numbers.sorted\n            var last : Float\
    \ = sNumbers(0)\n            var i : Int = 1\n            while ((i < sNumbers.size)\
    \ && (!result)) {\n                val current : Float = sNumbers(i)\n       \
    \         result = (abs(current - last) < threshold)\n                last = current\n\
    \                i = i + 1\n            }\n        }\n        result", "     \
    \   // >>> hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat)),\
    \ (0.5f))\n        // (false)\n        // >>> hasCloseElements((List[Float](1.0f.toFloat,\
    \ 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))\n\
    \        // (true)\n        def hasCloseElements(numbers : List[Float], threshold\
    \ : Float) : Boolean = {\n            val sorted = numbers.sorted\n          \
    \  // println(sorted)\n            for (i <- 0 until sorted.length - 1) {\n  \
    \              if (abs(sorted(i) - sorted(i + 1)) < threshold) {\n           \
    \         return true\n                }\n            }\n            return false\n\
    \        }\n        return hasCloseElements(numbers, threshold)", "        var\
    \ hasClosest : Boolean = false\n        for (i <- 0 until numbers.length) {\n\
    \            for (j <- i+1 until numbers.length) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < threshold) {\n                    hasClosest = true\n      \
    \          }\n            }\n        }\n        return hasClosest", "        def\
    \ loop(numbers : List[Float], threshold : Float, result : Boolean) : Boolean =\
    \ {\n            numbers match {\n                case Nil => result\n       \
    \         case head :: tail => {\n                    val min = tail.reduce((x,\
    \ y) => min(x, y))\n                    if (abs(head - min) <= threshold)\n  \
    \                      true\n                    else\n                      \
    \  loop(tail, threshold, result)\n                }\n            }\n        }\n\
    \        loop(numbers, threshold, false)", "        def distance(tuple : (Float,\
    \ Float)) : Float = abs(tuple._1 - tuple._2)\n        val distances = numbers.zip(numbers.tail).map(tuple\
    \ => distance(tuple))\n        distances.exists(distance => distance < threshold)",
  "        var l : List[Float] = numbers.sorted\n        var has : Boolean = false\n\
    \        for (i <- 0 until (l.length - 1)) {\n            val diff : Float = abs(l(i)\
    \ - l(i + 1))\n            if (diff < threshold) {\n                has = true\n\
    \            }\n        }\n        return has", "        // >>> List(1.2f, 3.4f,\
    \ 5.6f).foldLeft((List[Float](), 0.0f.toFloat))((a, b) => (a._1 ++ List(a._2 +\
    \ b), b))\n        // ((List(1.2f, 4.6f, 10.2f), 5.6f))\n        // >>> List(1.2f,\
    \ 3.4f, 5.6f).foldLeft((List[Float](), 0.0f.toFloat))((a, b) => (a._1 ++ List(a._2\
    \ + b), b))._1\n        // (List(1.2f, 4.6f, 10.2f))\n        val cumulatives\
    \ = numbers.foldLeft((List[Float](), 0.0f.toFloat))((a, b) => (a._1 ++ List(a._2\
    \ + b), b))._1\n        // >>> List(1.2f, 4.6f, 10.2f).foldLeft((List[Boolean](),\
    \ 0.0f.toFloat))((a, b) => (a._1 ++ List(b < a._2 + threshold), b))\n        //\
    \ ((List(false, false, false), 10.2f))\n        // >>> List(1.2f, 4.6f, 10.2f).foldLeft((List[Boolean](),\
    \ 0.0f.toFloat))((a, b) => (a._1 ++ List(b < a._2 + threshold), b))._1\n     \
    \   // (List(false, false, false))\n        val results = cumulatives.foldLeft((List[Boolean](),\
    \ 0.0f.toFloat))((a, b) => (a._1 ++ List(b < a._2 + threshold), b))._1\n     \
    \   // >>> List(false, false, false).exists((a) => a)\n        // (false)\n  \
    \      // >>> List(false, false, true).exists((a) => a)\n        // (true)\n \
    \       results.exists((a) => a)", '        return false', "        // >>> hasCloseElements(List(1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat), 0.5f)\n        // res0: Boolean = false\n     \
    \   // >>> hasCloseElements(List(1.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat,\
    \ 5.0f.toFloat, 2.0f.toFloat), 0.3f)\n        // res1: Boolean = true\n      \
    \  // >>> hasCloseElements(List(1.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat,\
    \ 5.0f.toFloat, 2.0f.toFloat), 0.7f)\n        // res2: Boolean = false\n     \
    \   //\n        //\n        // >>> hasCloseElements(List(1.0f.toFloat, 2.8f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat), 0.7f)\n        // res0:\
    \ Boolean = false\n        //\n        //\n        // >>> hasCloseElements(List(1.0f.toFloat,\
    \ 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat), 0.7f)\n\
    \        // res0: Boolean = false\n        //\n        //\n        // >>> hasCloseElements(List(1.0f.toFloat,\
    \ 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat), 0.7f)\n\
    \        // res0: Boolean = false\n        //\n        //\n        // >>> hasCloseElements(List(1.0f.toFloat,\
    \ 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat), 0.7f)\n\
    \        // res0: Boolean = false\n", "        var prev : Float = numbers(0)\n\
    \        var hasCloseElements : Boolean = false\n        for (i <- 1 until numbers.length)\
    \ {\n            if (abs(numbers(i) - prev) < threshold) hasCloseElements = true\n\
    \            prev = numbers(i)\n        }\n        hasCloseElements", "      \
    \  val sorted = numbers.sorted\n        if (sorted.length == 0) return false\n\
    \        var minDiff = scala.Float.MaxValue\n        for (i <- 0 until sorted.length\
    \ - 1) {\n            val cur = sorted(i)\n            val next = sorted(i + 1)\n\
    \            val diff = abs(cur - next)\n            if (diff < minDiff) minDiff\
    \ = diff\n        }\n        return minDiff < threshold", '        //TODO: Your
    code goes here.', "        var hasCloseElements : Boolean = false\n        for(x\
    \ <- numbers) {\n            for(y <- numbers) {\n                if(Math.abs(x\
    \ - y) < threshold) {\n                    hasCloseElements = true\n         \
    \       }\n            }\n        }\n        return hasCloseElements", "     \
    \   val sortedNumbers = numbers.sorted\n        for (i <- 0 until sortedNumbers.length-1)\
    \ {\n            if (abs(sortedNumbers(i) - sortedNumbers(i+1)) < threshold) {\n\
    \                return true\n            }\n        }\n        return false",
  "        // >>> numbers.sorted\n        // (List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n        for (i <-\
    \ 0 until numbers.length - 1) {\n            if (numbers(i + 1) - numbers(i) <\
    \ threshold) {\n                return true\n            }\n        }\n      \
    \  return false", "        var i = 0\n        while (i < numbers.length) {\n \
    \           var j = i + 1\n            while (j < numbers.length) {\n        \
    \        if (abs(numbers(i) - numbers(j)) < threshold) {\n                   \
    \ return true\n                }\n                j += 1\n            }\n    \
    \        i += 1\n        }\n        return false", "        def aux(last : Float,\
    \ numbers : List[Float]) : Boolean = {\n            if (numbers.isEmpty) false\n\
    \            else {\n                val diff = numbers.head - last\n        \
    \        if (diff < threshold) true\n                else aux(numbers.head, numbers.tail)\n\
    \            }\n        }\n        if (numbers.length < 2) false\n        else\
    \ aux(numbers.head, numbers.tail)", "        var n = numbers.length\n        var\
    \ flag = false\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ n) {\n                if (i != j) {\n                    val diff = numbers(i)\
    \ - numbers(j)\n                    if (diff < 0) {\n                        if\
    \ (-diff < threshold) {\n                            flag = true\n           \
    \             }\n                    } else {\n                        if (diff\
    \ < threshold) {\n                            flag = true\n                  \
    \      }\n                    }\n                }\n            }\n        }\n\
    \        return flag", "        val l = numbers.sorted\n        var m = Map[Int,\
    \ Int]()\n        for (i <- 0 until l.length - 1) {\n            if (abs(l(i)\
    \ - l(i + 1)) < threshold) return true\n        }\n        return false", '        false',
  "        // >>> remove = (i, list) -> (list.slice(0, i) + list.slice(i + 1, list.length))\n\
    \        // >>> for (i, n1) in enumerate(numbers)\n        //         for (n2)\
    \ in remove(i, numbers)\n        //             if (n1 - n2).abs() < threshold\n\
    \        //                 return true\n        //     return false\n       \
    \ def remove(i : Int, list : List[Float]) : List[Float] = list.slice(0, i) :::\
    \ list.slice(i + 1, list.length)\n        for (i <- (0 to numbers.length - 1))\
    \ {\n            for (n2 <- remove(i, numbers)) {\n                if (abs(numbers(i)\
    \ - n2) < threshold) return true\n            }\n        }\n        return false",
  "        // >>> numbers.sorted\n        // (List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n        val sortedNumbers\
    \ = numbers.sorted\n        // >>> sortedNumbers.zip(sortedNumbers.tail)\n   \
    \     // (List[(Float, Float)]((1.0f.toFloat, 2.0f.toFloat), (2.0f.toFloat, 2.8f.toFloat),\
    \ (2.8f.toFloat, 3.0f.toFloat), (3.0f.toFloat, 4.0f.toFloat), (4.0f.toFloat, 5.0f.toFloat)))\n\
    \        val pairs = sortedNumbers.zip(sortedNumbers.tail)\n        // >>> pairs.map(x\
    \ => (x._1 - x._2).abs)\n        // (List[Float](1.0f.toFloat, 0.8f.toFloat, 0.19999999999999996f.toFloat,\
    \ 1.0f.toFloat, 1.0f.toFloat))\n        val absDiffs = pairs.map(x => (x._1 -\
    \ x._2).abs)\n        // >>> absDiffs.exists(x => x < threshold)\n        // (true)\n\
    \        absDiffs.exists(x => x < threshold)", "        if (numbers.length < 2)\
    \ return false\n        var i = 0\n        while (i < numbers.length - 1) {\n\
    \            if (abs(numbers(i) - numbers(i + 1)) < threshold) return true\n \
    \           i += 1\n        }\n        return false", "        // Initialize list\
    \ of tuples (previous number and next number) with values such that\n        //\
    \ they are always farther apart than given threshold\n        var tuples = (List[(Float,\
    \ Float)]((1.0f.toFloat, 1.0f.toFloat))).to[ArrayBuffer]\n        // Iterate over\
    \ list of given numbers and store in tuples values of tuples in which\n      \
    \  // difference between two given numbers is less than given threshold\n    \
    \    numbers.foreach(x => {\n            tuples = tuples.filter(t => {\n     \
    \           abs(t._1 - x) > threshold && abs(t._2 - x) > threshold\n         \
    \   })\n            tuples.foreach(t => {\n                if (abs(t._1 - x) <=\
    \ threshold) tuples += ((x, t._2))\n                if (abs(t._2 - x) <= threshold)\
    \ tuples += ((t._1, x))\n            })\n        })\n        // If there are no\
    \ such tuples, then list of given numbers does not contain any\n        // numbers\
    \ closer to each other than given threshold\n        tuples.size == 1", '        numbers.sortWith(_
    < _).sliding(2).map((p : List[Float]) => abs(p(0) - p(1))).min < threshold', '        return
    hasCloseElementsTail(numbers, threshold, 0)', "        var flag = false\n    \
    \    numbers.foreach(x => if (numbers.exists(y => abs(x - y) < threshold && x\
    \ != y)) {flag = true; return flag})\n        return flag", "        if (numbers.length\
    \ < 2) return false\n        var previous_num = numbers(0)\n        for (num <-\
    \ numbers.slice(1, numbers.length)) {\n            if (abs(num - previous_num)\
    \ < threshold) return true\n            previous_num = num\n        }\n      \
    \  return false", "        if (numbers.length <= 1) return false\n        var\
    \ max = numbers(0)\n        var min = numbers(0)\n        for (n <- numbers) {\n\
    \            if (n > max) max = n\n            if (n < min) min = n\n        }\n\
    \        if (max - min <= threshold) return true\n        val buckets = Buffer[Float]()\n\
    \        var idx = 0\n        while (idx < numbers.length) {\n            buckets\
    \ += (0.0f)\n            idx += 1\n        }\n        val rate = 1.0f / threshold\n\
    \        idx = 0\n        while (idx < numbers.length) {\n            val number\
    \ = numbers(idx)\n            val bucket = floor((number - min) * rate).toInt\n\
    \            if (bucket < buckets.length) buckets(bucket) = 1.0f\n           \
    \ idx += 1\n        }\n        idx = 0\n        while (idx < buckets.length) {\n\
    \            if (buckets(idx) == 1.0f) {\n                if (idx > 0 && buckets(idx\
    \ - 1) == 1.0f) return true\n                if (idx < buckets.length - 1 && buckets(idx\
    \ + 1) == 1.0f) return true\n            }\n            idx += 1\n        }\n\
    \        return false", "        if (numbers.length < 2) return false\n      \
    \  var sortedNums = numbers.sorted\n        var prev = sortedNums(0)\n       \
    \ var i = 1\n        while (i < sortedNums.length) {\n            var curr = sortedNums(i)\n\
    \            if (curr - prev < threshold) return true\n            prev = curr\n\
    \            i += 1\n        }\n        return false", "        // >>>\n     \
    \   // >>>\n        val sortedNumbers = numbers.sorted\n        var i = 0\n  \
    \      while(i < sortedNumbers.length - 1) {\n            val a = sortedNumbers(i)\n\
    \            val b = sortedNumbers(i + 1)\n            if(b - a < threshold) return\
    \ true\n            i += 1\n        }\n        false\n        // <<<", "     \
    \   var hasCloserElements = false\n        for (i <- 0 until numbers.length) {\n\
    \            for (j <- 0 until numbers.length) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < threshold) hasCloserElements = true\n            }\n       \
    \ }\n        hasCloserElements", "        var i = 0\n        while (i < numbers.length)\
    \ {\n            var j = i + 1\n            while (j < numbers.length) {\n   \
    \             if (abs(numbers(i) - numbers(j)) < threshold) {\n              \
    \      return true\n                }\n                j += 1\n            }\n\
    \            i += 1\n        }\n        return false", "        if (numbers.length\
    \ < 2) return false\n        for (i <- 0 until numbers.length - 1) {\n       \
    \     val n1 = numbers(i)\n            for (j <- i + 1 until numbers.length) {\n\
    \                val n2 = numbers(j)\n                if (abs(n1 - n2) < threshold)\
    \ return true\n            }\n        }\n        return false", "        def hasCloseElementsRecursive(numbers\
    \ : List[Float], prev_num : Float, threshold : Float) : Boolean = {\n        \
    \    if (numbers.isEmpty) {\n                false\n            } else {\n   \
    \             if (abs(numbers.head - prev_num) < threshold) {\n              \
    \      true\n                } else {\n                    hasCloseElementsRecursive(numbers.tail,\
    \ numbers.head, threshold)\n                }\n            }\n        }\n    \
    \    if (numbers.length == 1) {\n            false\n        } else {\n       \
    \     hasCloseElementsRecursive(numbers.tail, numbers.head, threshold)\n     \
    \   }", "        var flag = false\n        for (i <- 0 until numbers.length -\
    \ 1) {\n            if (abs(numbers(i) - numbers(i + 1)) < threshold) {\n    \
    \            flag = true\n            }\n        }\n        flag", "        for\
    \ (i <- 0 until numbers.length; j <- 0 until numbers.length) {\n            if\
    \ (i != j && abs(numbers(i) - numbers(j)) < threshold) {\n                return\
    \ true\n            }\n        }\n        return false", "        // >>> import\
    \ scala.math._\n        // >>> abs(2.8f - 1.0f) < 0.3f\n        // (true)\n  \
    \      // >>> abs(2.8f - 2.0f) < 0.3f\n        // (true)\n        // >>> abs(2.8f\
    \ - 3.0f) < 0.3f\n        // (false)\n        numbers.exists((a : Float) => numbers.exists((b\
    \ : Float) => abs(a - b) < threshold && a != b))", "        var i = 0\n      \
    \  var r = false\n        while ((i < (numbers.length - 1)) && !r) {\n       \
    \     r = (abs((numbers(i) - numbers(i + 1))) < threshold)\n            i = i\
    \ + 1\n        }\n        r", '        numbers.zip(numbers.tail).map(x => abs(x._1
    - x._2)).filter(x => x < threshold).length > 0', "        var result : Boolean\
    \ = false\n        for (i <- 0 until numbers.length - 1) {\n            for (j\
    \ <- i + 1 until numbers.length) {\n                if (abs(numbers(i) - numbers(j))\
    \ < threshold) {\n                    result = true\n                }\n     \
    \       }\n        }\n        return result", "        for(i <- 0 until numbers.length\
    \ - 1) {\n            for(j <- i + 1 until numbers.length) {\n               \
    \ if(abs(numbers(i) - numbers(j)) < threshold) return true\n            }\n  \
    \      }\n        return false", "        val numbers_sorted = numbers.sorted\n\
    \        var previous : Float = 0.0f\n        var first : Boolean = true\n   \
    \     var result : Boolean = false\n        for (value <- numbers_sorted) {\n\
    \            if (first) {\n                first = false\n            } else {\n\
    \                if (abs(value - previous) < threshold) {\n                  \
    \  result = true\n                }\n            }\n            previous = value\n\
    \        }\n        return result", "        (for (i <- numbers.indices)\n   \
    \     yield abs(numbers(i) - numbers((i + 1) % numbers.length))).min < threshold",
  "        var has : Boolean = false\n        for (i <- numbers.indices) {\n     \
    \       for (j <- (i + 1) until numbers.length) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < threshold) {\n                    has = true\n             \
    \   }\n            }\n        }\n        has", "        if (numbers.length < 2)\
    \ return false\n        for (i <- 0 until numbers.length - 1) {\n            for\
    \ (j <- i + 1 until numbers.length) {\n                if (abs(numbers(i) - numbers(j))\
    \ < threshold) return true\n            }\n        }\n        return false", " \
    \       var hasCloseElements : Boolean = false\n        if (numbers.length ==\
    \ 1) {\n            hasCloseElements = false\n        } else {\n            val\
    \ sortedNumbers : List[Float] = numbers.sorted\n            var lowestNumber :\
    \ Float = sortedNumbers(0)\n            for (number <- sortedNumbers) {\n    \
    \            if (abs(number - lowestNumber) < threshold) {\n                 \
    \   hasCloseElements = true\n                }\n                lowestNumber =\
    \ number\n            }\n        }\n        hasCloseElements", "        if (numbers.length\
    \ < 2) false\n        else {\n            val closeElements: Boolean = numbers.map(x\
    \ => x * (1 + threshold)).map(x => abs(x - numbers.head)).filter(x => x <= threshold).size\
    \ > 1\n            val closeElementsExcludingHead: Boolean = hasCloseElements(numbers.tail,\
    \ threshold)\n            closeElements || closeElementsExcludingHead\n      \
    \  }", "        var sorted = numbers.sorted\n        for (i <- 0 until sorted.length\
    \ - 1) {\n            if (sorted(i + 1) - sorted(i) < threshold) return true\n\
    \        }\n        return false", "        var result : Boolean = false\n   \
    \     // >>> elementCloseTo(0.1f, 0.3f, 0.2f)\n        // (true)\n        // >>>\
    \ elementCloseTo(0.1f, 0.3f, 0.4f)\n        // (false)\n        def elementCloseTo(x\
    \ : Float, y : Float, threshold : Float) : Boolean = {\n            var result\
    \ : Boolean = false\n            var x1 : Float = x\n            var y1 : Float\
    \ = y\n            if (x1 == y1) {\n                result = false\n         \
    \   } else {\n                if (x1 > y1) {\n                    x1 = y1\n  \
    \                  y1 = x\n                }\n                if ((y1 - x1) <\
    \ threshold) {\n                    result = true\n                } else {\n\
    \                    result = false\n                }\n            }\n      \
    \      result\n        }\n        var nums1 : List[Float] = numbers\n        var\
    \ nums2 : List[Float] = numbers\n        while ((!result) && (nums1.tail != Nil))\
    \ {\n            nums2 = nums1.tail\n            while ((!result) && (nums2.tail\
    \ != Nil)) {\n                if (elementCloseTo(nums1.head, nums2.head, threshold))\
    \ {\n                    result = true\n                }\n                nums2\
    \ = nums2.tail\n            }\n            nums1 = nums1.tail\n        }\n   \
    \     result", "        // >>> numbers.sorted\n        // (List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n   \
    \     // >>> List[Float](0.0f.toFloat, 1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat)\n        // (List[Float](0.0f.toFloat, 1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n        // >>> map(List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat), (f :\
    \ Float) => (f + 1.0f))\n        // (List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat, 6.0f.toFloat))\n        // >>> map(List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat), (f :\
    \ Float) => (f - 1.0f))\n        // (List[Float](-1.0f.toFloat, 0.0f.toFloat,\
    \ 1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))\n        // >>> flatMap(List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat), (f :\
    \ Float) => (List[Float]((f + 1.0f), (", "        val elementsSet = scala.collection.mutable.Set[Float]()\n\
    \        for (i <- 0 until numbers.length) {\n            val element = numbers(i)\n\
    \            if (elementsSet.contains(element)) {\n                return true\n\
    \            }\n            elementsSet.add(element)\n            if (element\
    \ - threshold >= 0) {\n                elementsSet.add(element - threshold)\n\
    \            }\n            if (element + threshold <= 1) {\n                elementsSet.add(element\
    \ + threshold)\n            }\n        }\n        return false", "        def\
    \ check(numbers : List[Float], prevDist : Float) : Boolean = {\n            numbers\
    \ match {\n                case Nil => false\n                case x :: xs =>\
    \ {\n                    if (xs.isEmpty) {\n                        false\n  \
    \                  } else {\n                        val dist = abs(x - xs.head)\n\
    \                        if (dist < threshold) {\n                           \
    \ true\n                        } else {\n                            check(xs,\
    \ dist)\n                        }\n                    }\n                }\n\
    \            }\n        }\n        check(numbers.sorted, numbers.max)", '        numbers.combinations(2).exists(pair
    => (abs(pair(0) - pair(1)) < threshold))', '        numbers.sortWith(_ < _).sliding(2).map(x
    => abs(x(0) - x(1))).filter(_ < threshold).size > 0', "        var result : Boolean\
    \ = false\n        for (i <- 0 until numbers.length - 1) {\n            for (j\
    \ <- i + 1 until numbers.length) {\n                if (abs(numbers(i) - numbers(j))\
    \ < threshold) {\n                    result = true\n                }\n     \
    \       }\n        }\n        return result", "        var alreadySeen = ListBuffer[Float]()\n\
    \        for (number <- numbers) {\n            if (alreadySeen.size == 0) alreadySeen\
    \ += number\n            else {\n                var smallestDiff = abs(number\
    \ - alreadySeen(0))\n                for (alreadySeenNumber <- alreadySeen) {\n\
    \                    if (abs(number - alreadySeenNumber) < smallestDiff) {\n \
    \                       smallestDiff = abs(number - alreadySeenNumber)\n     \
    \               }\n                }\n                if (smallestDiff < threshold)\
    \ return true\n                else alreadySeen += number\n            }\n   \
    \     }\n        return false", "        if (numbers.size <= 1) {\n          \
    \  return false\n        }\n        for (i <- 0 until numbers.size - 1) {\n  \
    \          for (j <- i + 1 until numbers.size) {\n                if (abs(numbers(i)\
    \ - numbers(j)) < threshold) {\n                    return true\n            \
    \    }\n            }\n        }\n        return false", "        var sortedNums\
    \ = (numbers.sorted)\n        for(i <- 1 until sortedNums.length) {\n        \
    \    if((sortedNums(i) - sortedNums(i - 1)) < threshold) {\n                return\
    \ true\n            }\n        }\n        return false", "        var nums = numbers\n\
    \        var i = 0\n        for (i <- 0 to nums.length - 2) {\n            var\
    \ j = i + 1\n            for (j <- i + 1 to nums.length - 1) {\n             \
    \   if (abs(nums(i) - nums(j)) < threshold) {\n                    return true\n\
    \                }\n            }\n        }\n        return false", "       \
    \ // Implementation goes here\n        return (false)", "        if (numbers.length\
    \ == 1) {\n            false\n        } else {\n            def helper(numbers\
    \ : List[Float], prev : Float, threshold : Float) : Boolean = {\n            \
    \    if (numbers.length == 0) {\n                    false\n                }\
    \ else {\n                    if (abs(numbers.head - prev) < threshold) {\n  \
    \                      true\n                    } else {\n                  \
    \      helper(numbers.tail, numbers.head, threshold)\n                    }\n\
    \                }\n            }\n            helper(numbers.tail, numbers.head,\
    \ threshold)\n        }", "        // TODO\n        false", "        // Implement\
    \ this function to return the correct output.\n        val abs_numbers = numbers.sortWith(_.abs\
    \ < _.abs)\n        for (i <- 0 until abs_numbers.length-1) {\n            if\
    \ (abs_numbers(i+1) - abs_numbers(i) < threshold) {\n                return true\n\
    \            }\n        }\n        return false", "        var temp : Float =\
    \ 0.0f\n        var counter : Int = 0\n        if (numbers.length == 1) {\n  \
    \          return false\n        }\n        while (counter < numbers.length) {\n\
    \            if (counter == 0) {\n                temp = numbers(counter)\n  \
    \          } else {\n                if (abs(numbers(counter) - temp) < threshold)\
    \ {\n                    return true\n                }\n                temp\
    \ = numbers(counter)\n            }\n            counter += 1\n        }\n   \
    \     return false", "        if (numbers.length == 0) {\n            return false\n\
    \        }\n        var numbersSorted = numbers.sorted\n        var minimumDistance\
    \ = abs(numbersSorted(0) - numbersSorted(1))\n        for (i <- 1 to numbersSorted.length\
    \ - 2) {\n            var distance = abs(numbersSorted(i) - numbersSorted(i +\
    \ 1))\n            if (distance < minimumDistance) {\n                minimumDistance\
    \ = distance\n            }\n        }\n        return minimumDistance < threshold",
  "        if(numbers.length <= 1) {\n            return false\n        }\n      \
    \  val sortedNumbers = numbers.sorted\n        for( i <- 1 until sortedNumbers.length)\
    \ {\n            if(sortedNumbers(i) - sortedNumbers(i - 1) < threshold) {\n \
    \               return true\n            }\n        }\n        return false",
  "        // >>> checkResult = (hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat)), (0.5f)))\n        // >>> checkResult\n        // (false)\n \
    \       // >>> checkResult = (hasCloseElements((List[Float](1.0f.toFloat, 2.8f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f)))\n       \
    \ // >>> checkResult\n        // (true)\n        var hasCloseElements : Boolean\
    \ = false\n        // >>> numbers = (List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat))\n\
    \        // >>> numbers\n        // (List(1.0, 2.0, 3.0))\n        // >>> numbers\
    \ = (List[Float](1.0f.toFloat, 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat,\
    \ 2.0f.toFloat))\n        // >>> numbers\n        // (List(1.0, 2.8, 3.0, 4.0,\
    \ 5.0, 2.0))\n        // >>> threshold = (0.5f)\n        // >>> threshold\n  \
    \      // (0.5)\n        // >>> threshold = (0.3f)\n        // >>> threshold\n\
    \        // (0.3)\n        // >>> numbers.length\n        // (3)\n        // >>>\
    \ numbers.length\n        // (6)\n        var x : Int = 0\n        while (x <\
    \ numbers.length) {\n            // >>> x\n            // (0)\n            //\
    \ >>> x\n            // (0)\n            // >>> numbers.length\n            //\
    \ (3)\n            // >>> numbers.length\n            // (6)\n            var\
    \ y : Int = x + 1\n            while (y < numbers.length) {\n                //\
    \ >>> y\n                // (1)\n                // >>> y\n                //\
    \ (1)\n                // >>> y\n                // (2)\n                // >>>\
    \ y\n                // (2", "        // >>> numbers.toVector.sorted\n       \
    \ // (Vector(1.0, 2.0, 2.8, 3.0, 4.0, 5.0))\n        // >>> numbers.toVector.sorted.sliding(2).toList\n\
    \        // (List((1.0, 2.0), (2.0, 2.8), (2.8, 3.0), (3.0, 4.0), (4.0, 5.0)))\n\
    \        // >>> numbers.toVector.sorted.sliding(2).toList.map((t) => abs(t(0)\
    \ - t(1)))\n        // (List(1.0, 0.8, 0.2, 1.0, 1.0))\n        // >>> numbers.toVector.sorted.sliding(2).toList.map((t)\
    \ => abs(t(0) - t(1))).filter((distance) => distance < threshold)\n        //\
    \ (List(0.8, 0.2))\n        numbers.toVector.sorted.sliding(2).toList.map((t)\
    \ => abs(t(0) - t(1))).filter((distance) => distance < threshold).length > 0",
  "        var hasCloseElements : Boolean = false\n        for (i <- 0 until numbers.length)\
    \ {\n            for (j <- 0 until numbers.length) {\n                if (i !=\
    \ j) {\n                    if (abs(numbers(i) - numbers(j)) < threshold) {\n\
    \                        hasCloseElements = true\n                    }\n    \
    \            }\n            }\n        }\n        return hasCloseElements", '        return
    numbers.sortWith(_ < _).zip(numbers.sortWith(_ < _).tail).map(p => p._2 - p._1).min
    < threshold', "        def helper(list : List[Float], minDistance : Float) : Boolean\
    \ = {\n            if (list.length <= 1) false\n            else {\n         \
    \       val distance = abs(list.head - list.tail.head)\n                if (distance\
    \ < minDistance) true\n                else helper(list.tail, minDistance)\n \
    \           }\n        }\n        helper(numbers.sorted, threshold)"]
stop_tokens:
- "\n    }\n"
