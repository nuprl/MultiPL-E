name: HumanEval_147_get_max_triples
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a positive integer n. You have to create an integer list a\
  \ of length n.\n    // For each i (1 \u2264 i \u2264 n), the value of a[i] = i *\
  \ i - i + 1.\n    // Return the number of triples (a[i], a[j], a[k]) of a where\
  \ i < j < k, \n    // and a[i] + a[j] + a[k] is a multiple of 3.\n    // Example\
  \ :\n    // >>> getMaxTriples((5l))\n    // (1l)\n    // Explanation: \n    // a\
  \ = [1, 3, 7, 13, 21]\n    // The only valid triple is (1, 7, 13).\n    def getMaxTriples(n\
  \ : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getMaxTriples((5l))\
  \ == (1l));\n    assert(getMaxTriples((6l)) == (4l));\n    assert(getMaxTriples((10l))\
  \ == (36l));\n    assert(getMaxTriples((100l)) == (53361l));\n    }\n\n}\n"
completions: ["        // Write your code here\n        if (n < 3) return 0\n    \
    \    n - n / 3", "        // We don't even need to put it in a set. We just need\
    \ to find a fast way of\n        // counting the number of multiples of 3 in the\
    \ range.\n        val nums = (0l to n).map(x => x * x - x + 1)\n        val multiplesOf3\
    \ = (1l to n / 3).map(x => x * 3).toSet\n        // Now just count the number\
    \ of triples in nums\n        var count = 0l\n        for (i <- 0 to n.toInt -\
    \ 3) {\n            for (j <- i + 1 to n.toInt - 2) {\n                for (k\
    \ <- j + 1 to n.toInt - 1) {\n                    if (multiplesOf3.contains(nums(i)\
    \ + nums(j) + nums(k))) count += 1\n                }\n            }\n       \
    \ }\n        return count", "        // Define a function to generate the sequence\n\
    \        val seq = Array.tabulate(n.toInt)(i => i * i - i + 1)\n        // Define\
    \ a function to check if the sum of any three numbers is a multiple of 3\n   \
    \     def isMultiple3(a : Int, b : Int, c : Int) : Boolean = (a + b + c) % 3 ==\
    \ 0\n        // Filter the list to check whether the triplets satisfy the condition.\n\
    \        seq.combinations(3).map(x => (x(0), x(1), x(2))).filter(x => isMultiple3(x._1,\
    \ x._2, x._3)).size", "        val m = n % 3\n        val pairs = (0 to 2) flatMap\
    \ { x => \n        \t(0 to 2) map { y => (x, y) }\n        } filter { case (x,\
    \ y) => (x + y) % 3 == m }\n        val f = (0 to 2) flatMap { x => \n       \
    \ \t(0 to 2) map { y => (x, y) }\n        } filter { case (x, y) => (x + y) %\
    \ 3 == 0 }\n        var result = (n / 3) * (n / 3) * (n / 3)\n        result +=\
    \ (n / 3) * (n / 3) * (n % 3)\n        result += pairs.length * (n / 3) * (n /\
    \ 3)\n        result += f.length * (n / 3) * (n % 3)\n        result", "     \
    \   // Trying to find an expression for ai: a[i] = i * i - i + 1.\n        //\
    \ In other words, a[i] = i^2 - i + 1.\n        // So we have a[i] + a[j] + a[k]\
    \ = i^2 - i + 1 + j^2 - j + 1 + k^2 - k + 1.\n        // a[i] + a[j] + a[k] =\
    \ i^2 + j^2 + k^2 - i - j - k + 3.\n        // Now, we want to make sure that\
    \ i < j < k.\n        // So, we have i < j < k < n.\n        // Since we are looking\
    \ for the maximum number of valid triples, \n        // let's go ahead and generate\
    \ all possible valid triples from 1 to n, \n        // and see how many of them\
    \ are divisible by 3.\n        def getAllTriples(n : Long) : List[List[Long]]\
    \ = {\n            def getAllTriplesFrom(i : Long, n : Long) : List[List[Long]]\
    \ = {\n                if (i == n) List(List(i))\n                else getAllTriplesFrom(i\
    \ + 1, n).flatMap(l => (i :: l) :: List())\n            }\n            getAllTriplesFrom(1,\
    \ n)\n        }\n        val triples = getAllTriples(n)\n        println(triples)\n\
    \        def isDivisibleBy3(triple : List[Long]) : Boolean = {\n            val\
    \ tripleSum = triple.map(x => x * x - x + 1).reduce(_ + _)\n            tripleSum\
    \ % 3 == 0\n        }\n        triples.filter(isDivisibleBy3(_)).length", "  \
    \      /**\n         * See this for explanation: http://www.mathblog.dk/project-euler-178/\n\
    \         * d_1 = (2 * 3) + 1 = 7\n         * d_2 = (2 * 3 * 5) + 1 = 31\n   \
    \      * d_3 = (2 * 3 * 5 * 7) + 1 = 215\n         * d_4 = (2 * 3 * 5 * 7 * 11)\
    \ + 1 = 1771\n         * d_5 = (2 * 3 * 5 * 7 * 11 * 13) + 1 = 16687\n       \
    \  * d_6 = (2 * 3 * 5 * 7 * 11 * 13 * 17) + 1 = 179653\n         * d_7 = (2 *\
    \ 3 * 5 * 7 * 11 * 13 * 17 * 19) + 1 = 2052725\n         * d_8 = (2 * 3 * 5 *\
    \ 7 * 11 * 13 * 17 * 19 * 23) + 1 = 24050127\n         * d_9 = (2 * 3 * 5 * 7\
    \ * 11 * 13 * 17 * 19 * 23 * 29) + 1 = 29176533\n         * d_10 = (2 * 3 * 5\
    \ * 7 * 11 * 13 * 17 * 19 * 23 * 29 * 31) + 1 = 35655813\n         * So this sequence\
    \ is defined by:\n         * d_n = (2 * 3 * 5 * ... * p_n) + 1\n         * where\
    \ p_n is the nth prime\n         * prime_n can be calculated using a prime sieve\n\
    \         * then d_n can be calculated using the formula above\n         * then\
    \ the formula for total number of triples a[i], a[j], a[k]\n         * where i\
    \ < j < k, a[i] + a[j] + a[k] is a multiple of 3 is:\n         * d_n * (d_n -\
    \ 1) * (d_n - 2) / (3 * 2 * 1)\n         * Then return that number.\n        \
    \ */\n        val primes = sieve(n.toInt)\n        //println(primes)\n       \
    \ var result = 1\n        for (i <- 0 until primes.length) {\n            result\
    \ *= (primes(i) +", "        var a = new Array[Long](n.toInt)\n        var res\
    \ = 0l\n        var sum = 0l\n        var i = 0\n        while (i < n) {\n   \
    \         a(i) = i * i - i + 1\n            i += 1\n        }\n        i = 0\n\
    \        while (i < n - 2) {\n            var j = i + 1\n            while (j\
    \ < n - 1) {\n                var k = j + 1\n                while (k < n) {\n\
    \                    sum = a(i) + a(j) + a(k)\n                    if (sum % 3\
    \ == 0) res += 1\n                    k += 1\n                }\n            \
    \    j += 1\n            }\n            i += 1\n        }\n        res", "   \
    \   var count = 0\n      val c = Array.ofDim[Int](3)\n      for (i <- 0 until\
    \ n.toInt) c(i * i - i + 1 % 3) += 1\n      count += c(0) * (c(0) - 1) * (c(0)\
    \ - 2) / 6\n      count += c(1) * (c(1) - 1) * (c(2)) / 2\n      count += c(2)\
    \ * (c(2) - 1) * (c(1)) / 2\n      count += c(0) * (c(0) - 1) * (c(2)) / 2\n \
    \     count += c(0) * (c(1)) * (c(2))\n      count", "    \tval a = new Array[Long](n.toInt)\n\
    \    \tfor (i <- 1 to n.toInt) {\n    \t\ta(i - 1) = (i * i - i + 1)\n    \t}\n\
    \    \tvar counter = 0\n    \tfor (i <- 0 to n.toInt - 3) {\n    \t\tfor (j <-\
    \ i + 1 to n.toInt - 2) {\n    \t\t\tfor (k <- j + 1 to n.toInt - 1) {\n    \t\
    \t\t\tif ((a(i) + a(j) + a(k)) % 3 == 0) {\n    \t\t\t\t\tcounter += 1\n    \t\
    \t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tcounter", '        (1l to n).map(x
    => x * x - x + 1).groupBy(x => x % 3).map(x => x._2.combinations(3).filter(y =>
    y.sum % 3 == 0).size).sum', "        var result = 0l\n        var i = 0l\n   \
    \     var j = 0l\n        var k = 0l\n        var a = 0l\n        var b = 0l\n\
    \        var c = 0l\n        while (i < n) {\n            j = i + 1\n        \
    \    while (j < n) {\n                k = j + 1\n                while (k < n)\
    \ {\n                    a = (i * i) - i + 1\n                    b = (j * j)\
    \ - j + 1\n                    c = (k * k) - k + 1\n                    if ((a\
    \ + b + c) % 3 == 0) {\n                        result += 1\n                \
    \    }\n                    k += 1\n                }\n                j += 1\n\
    \            }\n            i += 1\n        }\n        result", "        val l\
    \ = new ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            l\
    \ += i.toLong * i.toLong - i.toLong + 1\n        }\n        var count = 0\n  \
    \      for (i <- 0 until l.length - 2) {\n            for (j <- i + 1 until l.length\
    \ - 1) {\n                for (k <- j + 1 until l.length) {\n                \
    \    if ((l(i) + l(j) + l(k)) % 3 == 0) {\n                        count += 1\n\
    \                    }\n                }\n            }\n        }\n        count",
  "        // Your code goes here.\n        val cache = HashMap[(Long, Long), Long]()\n\
    \        def f(n : Long, count : Long) : Long = {\n            if (n <= 0) count\n\
    \            else {\n                if (cache.contains((n, count))) cache((n,\
    \ count))\n                else {\n                    val value = f(n - 1, count\
    \ + (if (n % 3 == 0) 1 else 0))\n                    cache((n, count)) = value\n\
    \                    value\n                }\n            }\n        }\n    \
    \    f(n, 0)", "        val maxV = n * n - n + 1\n        val s = n / 3 - 1\n\
    \        val e = n - 2\n        val a = (1l to n) map {x => x * x - x + 1}\n \
    \       val map = a.zipWithIndex.toMap\n        val m = HashMap[Long, Long]()\n\
    \        for (i <- s to e) {\n            for (j <- i + 1 to e) {\n          \
    \      val ab = a(i) + a(j)\n                val c = (3 - ab % 3) % 3\n      \
    \          val abc = ab + c\n                val x = if (m.contains(abc)) m(abc)\
    \ else 0\n                m(abc) = x + 1\n            }\n        }\n        if\
    \ (m.contains(maxV)) m(maxV) else 0", "        if (n < 3) 0 else {\n         \
    \   val m = n.toInt - 2\n            val d = new Array[Long](m)\n            for\
    \ (i <- 0 until m) d(i) = (i + 2L) * (i + 2L) - (i + 2L) + 1\n            var\
    \ c = 0L\n            for (i <- 0 until m) {\n                for (j <- i + 1\
    \ until m) {\n                    val s = d(i) + d(j)\n                    if\
    \ (s % 3 == 0) {\n                        for (k <- j + 1 until m) {\n       \
    \                     if (s + d(k) % 3 == 0) c += 1\n                        }\n\
    \                    }\n                }\n            }\n            c\n    \
    \    }", "        val a = new Array[Long](n.toInt)\n        for (i <- 1 to n.toInt)\
    \ {\n            a(i - 1) = i * i - i + 1\n        }\n        var count = 0l\n\
    \        for (i <- 0 to n.toInt - 3) {\n            for (j <- i + 1 to n.toInt\
    \ - 2) {\n                for (k <- j + 1 to n.toInt - 1) {\n                \
    \    if ((a(i) + a(j) + a(k)) % 3 == 0) count += 1\n                }\n      \
    \      }\n        }\n        count", "        val isDivisibleByThree = (x : Long)\
    \ => x % 3 == 0\n        // new Array[Long](n.toInt)\n        val a = new mutable.ArrayBuffer[Long]()\n\
    \        //create array a\n        for (i <- 1 to n.toInt) {\n            val\
    \ b = i * i - i + 1\n            a += b\n        }\n        var count = 0\n  \
    \      //iterate through array\n        for (i <- 0 to a.length - 3) {\n     \
    \       for (j <- i + 1 to a.length - 2) {\n                for (k <- j + 1 to\
    \ a.length - 1) {\n                    val total = a(i) + a(j) + a(k)\n      \
    \              if (isDivisibleByThree(total)) {\n                        count\
    \ += 1\n                    }\n                }\n            }\n        }\n \
    \       count", "        val a = (0l to n - 1).map(i => i * i - i + 1l).toArray\n\
    \        var count = 0l\n        for (i <- 0 to n - 3) {\n            val x =\
    \ a(i)\n            val j = i + 1\n            val k = n - 1\n            while\
    \ (j < k) {\n                val y = a(j)\n                val z = a(k)\n    \
    \            if (x + y + z == 0) count += k - j\n                k -= 1\n    \
    \        }\n        }\n        count", '        return n / 3', "        var m\
    \ = 0l\n        for (i <- 1 to n.toInt - 2) {\n            for (j <- i + 1 to\
    \ n.toInt - 1) {\n                for (k <- j + 1 to n.toInt) {\n            \
    \        if ((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0) m += 1\n\
    \                }\n            }\n        }\n        m", "        val triangles\
    \ = {\n            val a = new Array[Long](n.toInt)\n            var i = 0\n \
    \           while (i < n) {\n                a(i) = i * i - i + 1\n          \
    \      i += 1\n            }\n            a\n        }\n        var result = 0l\n\
    \        for (i <- 0 until n.toInt - 2) {\n            for (j <- i + 1 until n.toInt\
    \ - 1) {\n                for (k <- j + 1 until n.toInt) {\n                 \
    \   if ((triangles(i) + triangles(j) + triangles(k)) % 3 == 0) {\n           \
    \             result += 1\n                    }\n                }\n        \
    \    }\n        }\n        result", "        var result = 0l\n        for (i <-\
    \ 0 until n.toInt) {\n            val si = i * i - i + 1\n            for (j <-\
    \ i + 1 until n.toInt) {\n                val sj = j * j - j + 1\n           \
    \     if ((si + sj) % 3 == 0) {\n                    for (k <- j + 1 until n.toInt)\
    \ {\n                        val sk = k * k - k + 1\n                        if\
    \ ((si + sj + sk) % 3 == 0) result += 1\n                    }\n             \
    \   }\n            }\n        }\n        result", "        var count = 0l\n  \
    \      for (i <- 1 to n.toInt - 2) {\n            for (j <- i + 1 to n.toInt -\
    \ 1) {\n                val sum = j * j - j + 1 + i * i - i + 1\n            \
    \    val max = min(n, 3 * sum)\n                val k = ceil(sqrt(max + 1) - 1)\n\
    \                count += max(0, k - j)\n            }\n        }\n        count",
  '        n * (n - 1) * (n - 2) / 6', "        val a = (for (i <- 1 to n.toInt) yield\
    \ i * i - i + 1).toList\n        for (i <- 0 to n.toInt - 3; j <- i + 1 to n.toInt\
    \ - 2; k <- j + 1 to n.toInt - 1; if a(i) + a(j) + a(k) % 3 == 0) yield (i, j,\
    \ k)", "        val a = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt)\
    \ a(i) = i * i - i + 1\n        val sum = (0l to n - 1).foldLeft(0l)((acc, k)\
    \ => acc + a(k.toInt))\n        val res = (0l to n - 3).foldLeft(0l)((acc, i)\
    \ => acc + (i + 1l to n - 2).foldLeft(0l)((acc, j) => acc + (j + 1l to n - 1).foldLeft(0l)((acc,\
    \ k) => if ((a(i.toInt) + a(j.toInt) + a(k.toInt)) % 3 == 0) acc + 1 else acc)))\n\
    \        res", "        // Good luck!\n        def count(n : Long) : Long = {\n\
    \            val set = HashSet[Long]()\n            for (i <- 1l to n) {\n   \
    \             set += (i * i - i + 1)\n            }\n            val a = set.toArray\n\
    \            var cnt = 0l\n            for (i <- 0 until a.length - 2) {\n   \
    \             for (j <- i + 1 until a.length - 1) {\n                    for (k\
    \ <- j + 1 until a.length) {\n                        if ((a(i) + a(j) + a(k))\
    \ % 3 == 0) cnt += 1\n                    }\n                }\n            }\n\
    \            cnt\n        }\n        def count2(n : Long) : Long = {\n       \
    \     var ans = 0l\n            var m = 1l\n            while (m * m <= n) {\n\
    \                val a = m * m - m + 1\n                val b = m * m + m + 1\n\
    \                val c = m * m + 3 * m + 1\n                val d = m * m + 5\
    \ * m + 2\n                if (d <= n) ans += 1\n                if (a % 3 ==\
    \ 0) ans += 1\n                if (b % 3 == 0) ans += 1\n                if (c\
    \ % 3 == 0) ans += 1\n                if (d % 3 == 0) ans += 1\n             \
    \   m += 1\n            }\n            ans\n        }\n        count2(n)", " \
    \       // https://math.stackexchange.com/questions/1039219/number-of-triples-such-that-i-j-k-and-x-x-x-0-mod-3\n\
    \        // http://www.mkyong.com/java/java-calculate-permutation-and-combination/\n\
    \        // https://en.wikipedia.org/wiki/Combination\n        // http://mathforum.org/library/drmath/view/55843.html\n\
    \        // https://en.wikipedia.org/wiki/Multinomial_theorem\n        // https://books.google.com/books?id=9d8jOiD34v0C&pg=PA43&lpg=PA43&dq=multinomial+theorem+bijective&source=bl&ots=TqT3NpnZnU&sig=sz_Ue7V9dC6e1Kjm_DZgHdYfDpY&hl=en&sa=X&ved=0ahUKEwjyl8OZhJjQAhVJZD4KHW5xD94Q6AEIOTAF#v=onepage&q=multinomial%20theorem%20bijective&f=false\n\
    \        // https://math.stackexchange.com/questions/173832/sum-of-multinomial-coefficients-with-equal-exponents\n\
    \        // https://www.quora.com/How-can-I-prove-1-x-x-x-x-n-x-x-k-1-n-k\n  \
    \      val s = n * (n + 1) / 2\n        var c = 0\n        for (a <- 1 to 3) {\n\
    \            if ((s - a) % 3 == 0) {\n                val i = (s - a) / 3 - 1\n\
    \                if (i > 0) {\n                    c += (n - 1)\n            \
    \        if (i <= n - 2) c += 1\n                }\n            }\n        }\n\
    \        c", '        return 0', "        // we only need to consider all a[i]\
    \ < a[j] < a[k]\n        // where i < j < k\n        // a[i] + a[j] + a[k] is\
    \ a multiple of 3\n        // (a[i] + a[j] + a[k]) % 3 == 0\n        // a[i] +\
    \ a[j] is a multiple of 3\n        // a[i] % 3 + a[j] % 3 = 3\n        // a[i]\
    \ % 3 + a[j] % 3 = 0\n        // a[i] % 3 = a[j] % 3 \n        // a[i] % 3 = 0\
    \ and a[j] % 3 = 0\n        // Since (x + y) mod 3 = (x mod 3 + y mod 3) mod 3\n\
    \        // a[i] + a[j] mod 3 = a[i] mod 3 + a[j] mod 3 mod 3\n        // a[i]\
    \ + a[j] mod 3 = a[i] mod 3 + a[j] mod 3\n        // a[i] + a[j] mod 3 = 0\n \
    \       // a[i] mod 3 = - a[j] mod 3\n        // a[i] mod 3 = 0 and a[j] mod 3\
    \ = 0\n        // a[i] = 3 * x\n        // a[j] = 3 * y\n        // a[i] < a[j]\n\
    \        // 3 * x < 3 * y\n        // x < y\n        // a[k] < a[j]\n        //\
    \ 3 * z < 3 * y\n        // z < y\n        // x < z\n        // since a[k] = k\
    \ * k - k + 1\n        // k * k - k + 1 < 3 * y\n        // k * k - k < 3 * y\
    \ - 1\n        // k * k - k < 3 * y\n        // y < k * k - k + 1\n        //\
    \ y < k * k - k + 1 - y\n        // y < k * k - 2 * k + 1\n        // y < k *\
    \ (k - 2) + 1\n        // y < k * (k - 2) + 1 - y\n       ", "        // for all\
    \ i, j, k such that i < j < k, \n        // a[i] + a[j] + a[k] = i*i - i + 1 +\
    \ j*j - j + 1 + k*k - k + 1\n        //                   = i*i + j*j + k*k +\
    \ 3(i + j + k) - (i + j + k) + 3\n        //                   = i*i + j*j + k*k\
    \ + 3(i + j + k) - (i + j + k) + 3\n        //                   = i*i + j*j +\
    \ k*k + 3(i + j + k)\n        // then to be a multiple of 3, we must have \n \
    \       //  i*i + j*j + k*k = 3*x, x = (i + j + k)/3\n        //  \n        //\
    \ \n        // Let's start by getting all unique triplets (x, y, z) for which\n\
    \        // x^2 + y^2 + z^2 = 3*x and x < y < z.\n        // Let's start by solving\
    \ the following equation for z in terms of x and y:\n        // z^2 = 3*x - x^2\
    \ - y^2\n        // z = +-(sqrt(3*x - x^2 - y^2))\n        // \n        // Now,\
    \ notice that if we have a triplet (x, y, z), then the triplet (x, y + 1, z) is\
    \ also valid.\n        // So we can just iterate through all y starting from 2\
    \ and find all valid values of z for that y.\n        // \n        // Finally,\
    \ let's impose the condition x < y < z.\n        // Let's solve the following\
    \ equation for x in terms of y and z:\n        // x^2 = 3*x - y^2 - z^2\n    \
    \    // x = (y^2 + z^2) / (3 - 1)\n        // \n        // Finally, let's impose\
    \ the condition x < y < z.\n        // Notice that for a value of y, we can generate\
    \ all valid x for that value of y.\n        // Also, for a value of z, we", " \
    \       val size = n.toInt\n        val a = new Array[Long](size)\n        val\
    \ b = new Array[Long](size)\n        val c = new Array[Long](size)\n        val\
    \ d = new Array[Long](size)\n        val e = new Array[Long](size)\n        val\
    \ f = new Array[Long](size)\n        val g = new Array[Long](size)\n        val\
    \ h = new Array[Long](size)\n        val i = new Array[Long](size)\n        val\
    \ j = new Array[Long](size)\n        val k = new Array[Long](size)\n        for\
    \ (x <- 0 until size) {\n            a(x) = x + 1\n            b(x) = (x + 1)\
    \ * (x + 1)\n            c(x) = (x + 1) * (x + 1) - (x + 1)\n            d(x)\
    \ = (x + 1) * (x + 1) - (x + 1) + 1\n            e(x) = (x + 1) * (x + 1) - (x\
    \ + 1) + 2\n            f(x) = (x + 1) * (x + 1) - (x + 1) + 3\n            g(x)\
    \ = (x + 1) * (x + 1) - (x + 1) + 4\n            h(x) = (x + 1) * (x + 1) - (x\
    \ + 1) + 5\n            i(x) = (x + 1) * (x + 1) - (x + 1) + 6\n            j(x)\
    \ = (x + 1) * (x + 1) - (x + 1) + 7\n            k(x) = (x + 1) * (x + 1) - (x\
    \ + 1) + 8\n        }\n        (1 to size).map(x => d(x - 1) + e(x - 1) + f(x\
    \ - 1)).filter(x => x % 3 == 0).length", "        // The first n - 1 values are\
    \ always evenly divisible by 3. \n        // The last value can be at most 1 less\
    \ than a multiple of 3.\n        // Therefore, the number of valid triples is:\n\
    \        // (n - 1) choose 2 + (n - 2) choose 2 + ... + (n - 1) / 3 choose 2\n\
    \        // = (n - 1) * (n - 2) / 2 * (n - 1) / 3\n        if (n < 3) 0\n    \
    \    else (n - 1) * (n - 2) / 2 * (n - 1) / 3", "\t\tvar lst = ListBuffer[Long]()\n\
    \t\tfor (i <- 1l to n) lst += i * i - i + 1\n\t\tvar sum = 0l\n\t\tfor (i <- 0\
    \ until lst.length; j <- i + 1 until lst.length; k <- j + 1 until lst.length)\n\
    \t\t\tif ((lst(i) + lst(j) + lst(k)) % 3 == 0) sum += 1\n\t\tsum", "        if\
    \ (n <= 0) return 0\n        // The value of a[i] = i * i - i + 1.\n        val\
    \ prefixSum = Array.fill(n.toInt + 1)(0)\n        for (i <- 1 to n.toInt) {\n\
    \            prefixSum(i) = prefixSum(i - 1) + i * i - i + 1\n        }\n    \
    \    // If a[i] + a[j] + a[k] is a multiple of 3,\n        // a[i] + a[j] + a[k]\
    \ = (a[i] + a[j]) + a[k] = prefixSum[j] - prefixSum[i - 1] + a[k]\n        //\
    \ 3 | (prefixSum[j] - prefixSum[i - 1] + a[k])\n        // 3 | (prefixSum[j] -\
    \ prefixSum[i - 1])\n        // 3 | (prefixSum[j] - prefixSum[i - 1] - a[k])\n\
    \        // This can be solved by double pointer.\n        // Be sure that i <\
    \ j < k.\n        var maxTriples = 0\n        for (i <- 1 to n.toInt - 2) {\n\
    \            for (j <- i + 1 to n.toInt - 1) {\n                if ((prefixSum(j)\
    \ - prefixSum(i - 1)) % 3 == 0) {\n                    maxTriples += 1\n     \
    \           }\n            }\n        }\n        maxTriples", "        var sum\
    \ = 0L\n        var total = 0L\n        var remainder = 0L\n        for (i <-\
    \ 1 to n.toInt) {\n            remainder = i * i - i + 1\n            sum += remainder\n\
    \            if (sum % 3 == 0) total += 1\n        }\n        total", "      \
    \  def gcd(a : Long, b : Long) : Long = {\n            if (b == 0) a else gcd(b,\
    \ a % b)\n        }\n        val k = (1L to n).foldLeft(1L)((b, a) => gcd(b, a))\n\
    \        (k % 3) match {\n            case 0 => (n / k) * (n / k)\n          \
    \  case 1 => (n / k) * ((n / k) + 1) / 2\n            case 2 => ((n / k) + 1)\
    \ * ((n / k) + 1) / 2\n        }", "        val nn = n.toInt\n        val a =\
    \ new Array[Int](nn)\n        for (i <- 1 to nn) {\n            a(i - 1) = i *\
    \ i - i + 1\n        }\n        var ans = 0\n        for (i <- 0 until nn) {\n\
    \            for (j <- i + 1 until nn) {\n                for (k <- j + 1 until\
    \ nn) {\n                    if ((a(i) + a(j) + a(k)) % 3 == 0) ans += 1\n   \
    \             }\n            }\n        }\n        ans", "        def isTriple(i\
    \ : Long, j : Long, k : Long) : Boolean = \n            (i * i - i + 1 + j * j\
    \ - j + 1 + k * k - k + 1) % 3 == 0 && i < j && j < k\n        var res = 0l\n\
    \        for (i <- 1l to n) {\n            var cnt = 0l\n            for (j <-\
    \ i + 1l to n) {\n                for (k <- j + 1l to n) {\n                 \
    \   if (isTriple(i, j, k)) {\n                        // println(s\"$i, $j, $k\"\
    )\n                        cnt += 1\n                    }\n                }\n\
    \            }\n            res = max(res, cnt)\n        }\n        res", "  \
    \      var counter = 0\n        for (i <- 1l to n) {\n            for (j <- (i\
    \ + 1) to n) {\n                for (k <- (j + 1) to n) {\n                  \
    \  if ((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0) {\n         \
    \               counter += 1\n                    }\n                }\n     \
    \       }\n        }\n        counter", "        val oneThird = n/3\n        val\
    \ twoThird = 2*n/3\n        val sumOneThird = (1l + oneThird)*oneThird/2\n   \
    \     val sumTwoThird = (oneThird + 1l + twoThird)*(twoThird - oneThird)/2\n \
    \       val sumThird = (twoThird + 1l + n)*(n - twoThird)/2\n        sumOneThird*sumTwoThird\
    \ + sumOneThird*sumThird + sumTwoThird*sumThird", "      //this function is just\
    \ so I can easily get the integer part of a division.\n      def myFloor(a : Double,\
    \ b : Double) : Double = {\n        val quotient = a / b\n        if(quotient\
    \ < 0)\n          (quotient - 1).toInt\n        else\n          quotient.toInt\n\
    \      }\n      def sumThirds(a : Long, b : Long, c : Long) : Long = {\n     \
    \   if(a % 3 == 0)\n          1\n        else if((a + b) % 3 == 0)\n         \
    \ 1\n        else if((a + c) % 3 == 0)\n          1\n        else if((b + c) %\
    \ 3 == 0)\n          1\n        else if((a + b + c) % 3 == 0)\n          1\n \
    \       else\n          0\n      }\n      //these are the helper functions to\
    \ get x and y values\n      def getY(a : Long, x : Long) : Long = {\n        myFloor((-3\
    \ * a + x * x + x) / 2.0, x)\n      }\n      def getX(a : Long, y : Long) : Long\
    \ = {\n        ((-3 * a + y * y + y) / 2).toInt\n      }\n      //the amount of\
    \ numbers that are multiplied by the number of numbers less than them to form\
    \ a multiple of 3\n      var c = 0\n      //iterate through all numbers from 1\
    \ to n\n      for(a <- 1l to n) {\n        //the third number is the smallest\
    \ number that can be combined with a and b to create a multiple of 3\n       \
    \ //so find the smallest such number, and iterate up to n.\n        val x : Long\
    \ = myFloor(sqrt(3 * a), 1)\n        //find the integer part of the y value\n\
    \        val y : Long = getY(a, x)\n        //add the number of multiples of 3\
    \ there are in the range [x, n]\n        c += ((n - x) / 3 + 1) * sumThirds(a,\
    \ x, y)\n      }\n      //return the counts\n      c", "        // We look at\
    \ all pairs of indices, \n        // and see how many pairs of indices can we\
    \ add to i and j to make the triple valid.\n        // If we have n integers,\
    \ and we fix a pair of indices, there are n - 3 choose 3\n        // ways to do\
    \ that.\n        // However, for some pairs of indices, we can have more than\
    \ one valid triple.\n        // For example, the pair (1, 3) is valid for the\
    \ triple (1, 3, 7), and\n        // it is also valid for the triple (1, 3, 13).\n\
    \        // Therefore, we look at pairs of indices, and see how many pairs of\
    \ indices\n        // can we add to them.\n        val isValid = Array.fill(n.toInt)(true)\n\
    \        val pairs = ArrayBuffer[Tuple2[Int, Int]]()\n        for (i <- 0 until\
    \ n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                if\
    \ ((i * i - i + 1 + j * j - j + 1) % 3 == 0) {\n                    pairs += ((i,\
    \ j))\n                    isValid(i) = false\n                    isValid(j)\
    \ = false\n                }\n            }\n        }\n        val validTriples\
    \ = ArrayBuffer[Tuple3[Int, Int, Int]]()\n        for (i <- 0 until n.toInt) {\n\
    \            if (isValid(i)) {\n                for (pair <- pairs) {\n      \
    \              if ((i * i - i + 1 + pair._1 * pair._1 - pair._1 + 1 + pair._2\
    \ * pair._2 - pair._2 + 1) % 3 == 0) {\n                        validTriples +=\
    \ ((i, pair._1, pair._2))\n                    }\n                }\n        \
    \    }\n        }\n        val results = ArrayBuffer[Tuple3[Int, Int, Int]]()\n\
    \        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt)\
    \ {\n                for (k <- j + 1 until n.toInt) {\n                    if\
    \ ((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0) {", "        val\
    \ a = (1l to n).map(x => x * x - x + 1).toList\n        val c = ArrayBuffer[(Long,\
    \ Long, Long)]()\n        for (i <- 0 until a.length - 2) {\n            for (j\
    \ <- i + 1 until a.length - 1) {\n                for (k <- j + 1 until a.length)\
    \ {\n                    if ((a(i) + a(j) + a(k)) % 3 == 0) c += ((a(i), a(j),\
    \ a(k)))\n                }\n            }\n        }\n        c.length", "  \
    \      var count = 0l\n        val a = Array.tabulate(n.toInt)(i => i * i - i\
    \ + 1)\n        for (i <- 0 until n.toInt) {\n            for (j <- i + 1 until\
    \ n.toInt) {\n                for (k <- j + 1 until n.toInt) {\n             \
    \       if ((a(i) + a(j) + a(k)) % 3 == 0) {\n                        count +=\
    \ 1\n                    }\n                }\n            }\n        }\n    \
    \    count", "        // The idea here is that we want to find triples where the\
    \ sum is\n        // equal to 3(n - 1) + 1.\n        // Which means that we must\
    \ find triples where we have\n        // the sum of the first element plus the\
    \ sum of the last elements\n        // equal to 3(n - 1) + 1 - the first element.\n\
    \        // So we can use a greedy algorithm to find the number of pairs\n   \
    \     // whose sum is divisible by 3.\n        // See the following for more:\n\
    \        // https://math.stackexchange.com/questions/2052179/how-to-find-all-possible-triples-in-an-array-whose-sum-is-divisible-by-3\n\
    \        // I will call the sum of the last elements x, and each triple\n    \
    \    // is of the form (a, b, x - a - b) where a < b and a, b, x mod 3 = 0.\n\
    \        // The sum of the last elements is determined by the last element.\n\
    \        // For example, if n = 4, then the last element is (n - 1)^2 - (n - 1)\
    \ + 1\n        // = 3, and the sum of the last elements is x = (3, 7, 13).\n \
    \       // So we can find the number of triples by calling getMaxTriples(n - 1)\n\
    \        // and then greedily finding the number of valid triples with the last\n\
    \        // element x.\n        // let m = n - 1\n        // a = [1, 3, 7, 13,\
    \ 21]\n        // let m = 4\n        // x = 21\n        // sum of the last elements\
    \ = 3 + 7 + 13 = 23\n        // the sum of the three elements = 23 - (1 + 3 +\
    \ 7) = 12\n        //\n        // a = [1, 3, 7, 13]\n        // let m = 3\n  \
    \      // x = 13\n        // sum of the last elements = 3 + 7 = 10\n        //\
    \ the sum of the three elements = 10 - (1 + 3) = 6\n        // the sum of the\
    \ three elements = 10 - (1 + 7) = 2\n        //\n        // a = [1, 3]\n     \
    \   // let m =", "        val a = 1L\n        val b = (n * n - n + 1L)\n     \
    \   val c = (n * n + n + 1L)\n        (n * (n - 1) * (n - 2) / 6) - ((b - a) *\
    \ (c - b) / 3)", "        val squares = new Array[Long](n.toInt)\n        for\
    \ (i <- 1 to n.toInt) squares(i - 1) = i * i\n        val evens = new Array[Long]((n\
    \ - 1).toInt)\n        val odds = new Array[Long]((n - 1).toInt)\n        for\
    \ (i <- 1 to n.toInt) {\n            if (i % 2 == 0) evens(i - 2) = squares(i\
    \ - 1) - i + 1\n            else odds(i - 2) = squares(i - 1) - i + 1\n      \
    \  }\n        // n is odd, n / 2 is even, n / 2 + 1 is odd\n        var result\
    \ = evens.filter(x => x % 3 == 0).sum\n        result += odds.filter(x => x %\
    \ 3 == 0).sum\n        val evenSize = evens.length\n        val oddSize = odds.length\n\
    \        if (evenSize >= 2) {\n            for (i <- 0 until evenSize - 1) {\n\
    \                val t = evens(i)\n                val target = 3 - t % 3\n  \
    \              result += bSearch(evens, i + 1, evenSize - 1, target - t)\n   \
    \         }\n        }\n        if (oddSize >= 2) {\n            for (i <- 0 until\
    \ oddSize - 1) {\n                val t = odds(i)\n                val target\
    \ = 3 - t % 3\n                result += bSearch(odds, i + 1, oddSize - 1, target\
    \ - t)\n            }\n        }\n        if (evenSize >= 1 && oddSize >= 1) {\n\
    \            for (i <- 0 until evenSize) {\n                val t = evens(i)\n\
    \                val target = 3 - t % 3\n                result += bSearch(odds,\
    \ 0, oddSize - 1, target - t)\n            }\n        }\n        result", "  \
    \      var arr = new Array[Long](n.toInt);\n        var count = 0L;\n        for\
    \ (i <- 0 until n.toInt) {\n            arr(i) = (i + 1L) * (i + 1L) - (i + 1L)\
    \ + 1L;\n            // println(arr(i));\n        }\n        for (i <- 0 until\
    \ n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n                for\
    \ (k <- j + 1 until n.toInt) {\n                    if ((arr(i) + arr(j) + arr(k))\
    \ % 3 == 0) {\n                        count += 1;\n                    }\n  \
    \              }\n            }\n        }\n        return count;", "        //\
    \ for i, j, k, if \n        // \ti = 0, i^2 - i + 1 = 1\n        // \tj = 1, j^2\
    \ - j + 1 = 3\n        // \tk = 2, k^2 - k + 1 = 7\n        // then (1, 3, 7)\
    \ will always be a possible triplet\n        // we can see that j = i + 1 and\
    \ k = j + 1 will always be a valid triplet\n        // by getting all possible\
    \ a[i], we can see that there are only 2 possible a[i]\n        // the first a[i]\
    \ is 1, and the last a[i] is i^2 - i + 1 where i^2 - i + 1 is divisible by 3\n\
    \        // say i^2 - i + 1 = 3l, then i = 2, 3 - 2 + 1 = 2\n        // say i^2\
    \ - i + 1 = 6l, then i = 3, 9 - 3 + 1 = 7\n        // say i^2 - i + 1 = 9l, then\
    \ i = 4, 16 - 4 + 1 = 13\n        // say i^2 - i + 1 = 12l, then i = 5, 25 - 5\
    \ + 1 = 21\n        // say i^2 - i + 1 = 15l, then i = 6, 36 - 6 + 1 = 31\n  \
    \      // say i^2 - i + 1 = 18l, then i = 7, 49 - 7 + 1 = 43\n        // say i^2\
    \ - i + 1 = 21l, then i = 8, 64 - 8 + 1 = 57\n        // say i^2 - i + 1 = 24l,\
    \ then i = 9, 81 - 9 + 1 = 73\n        // say i^2 - i + 1 = 27l, then i = 10,\
    \ 100 - 10 + 1 = 91\n        // so there are 10 possible values of i that is divisible\
    \ by 3\n        // they are (2, 3, 4, 5, 6, 7, 8, 9, 10, 11)\n        // thus\
    \ the answer is 10 * 8 / 2 = 40\n        val answer = (1 to (n.toInt - 2)).filter(i\
    \ => (i * i - i + 1) % 3 == 0).length\n        answer.", "        val v : Array[Long]\
    \ = new Array[Long](n.toInt + 1)\n        v(1) = 1\n        for (i <- 2 to n.toInt)\
    \ v(i) = i * i - i + 1\n        (1 until n.toInt - 1).map(i => {\n           \
    \ var s = 0\n            for (j <- i + 1 until n.toInt) {\n                val\
    \ x = v(i) + v(j)\n                val b = BinarySearch.lowerBound(v, j + 1, n.toInt,\
    \ x)\n                s += b - j - 1\n            }\n            s\n        }).sum",
  "        val a = Array.fill(n.toInt)(0)\n        for (i <- 1 to n.toInt) {\n   \
    \         a(i - 1) = i * i - i + 1\n        }\n        var max = Long.MinValue\n\
    \        for (i <- 1 to n.toInt) {\n            for (j <- i + 1 to n.toInt) {\n\
    \                for (k <- j + 1 to n.toInt) {\n                    if ((a(i -\
    \ 1) + a(j - 1) + a(k - 1)) % 3 == 0) {\n                        max = max max\
    \ (a(i - 1) + a(j - 1) + a(k - 1))\n                    }\n                }\n\
    \            }\n        }\n        return max", '        return 0l', "       \
    \ // We have\n        // a[i] = i * i - i + 1\n        // a[i] + a[j] + a[k] =\
    \ i * i - i + 1 + j * j - j + 1 + k * k - k + 1\n        // = (i + j + k) * (i\
    \ + j + k) - (i + j + k) + 3\n        // Since (i + j + k) * (i + j + k) is a\
    \ multiple of 3, \n        // (i + j + k) * (i + j + k) - (i + j + k) is also\
    \ a multiple of 3\n        // Therefore, a[i] + a[j] + a[k] is a multiple of 3\
    \ if and only if (i + j + k) is a multiple of 3\n        // or in other words,\
    \ we want a[i] + a[j] + a[k] to be a multiple of 3.\n        // That means, we\
    \ want k to be a multiple of 3 - (i + j) mod 3.\n        // If the number of such\
    \ k is at least 2, then we have a possible valid triple.\n        // We have to\
    \ find all i and j where i < j and (i + j) mod 3 is a constant c.\n        //\
    \ Let's find all such i and j for a fixed c first.\n        // We have (i + j)\
    \ mod 3 = c.\n        // Since 0 \u2264 i < j < n, we have 0 \u2264 j < n and\
    \ i = c - j mod 3.\n        // Since i < j, we have c - j mod 3 < j.\n       \
    \ // In particular, we have j > c - j mod 3.\n        // That means, we have\n\
    \        // j mod 3 \u2265 c\n        // and\n        // j mod 3 \u2264 c + 2\n\
    \        // Therefore, j mod 3 = c or j mod 3 = c + 1 or j mod 3 = c + 2.\n  \
    \      // If j mod 3 = c + 2, then\n        // j = 3 * x + c + 2\n        // where\
    \ x is a positive integer.\n        // Therefore, we have\n        // i = c -\
    \ j mod 3 = c - (c + 2) mod 3 = c - 2 mod 3", "        // a[i] = i * i - i + 1\n\
    \        // a[i] + a[j] + a[k] = 3 * i * i - 3 * i + 1 + 3 * j * j - 3 * j + 1\
    \ + 3 * k * k - 3 * k + 1\n        // = 3 * (i^2 + j^2 + k^2) - 3 * (i + j + k)\
    \ + 3\n        // = 3 * (i^2 + j^2 + k^2) - 3 * (i + j + k) + 3\n        // =\
    \ 3 * (i + j + k) (i + j + k - 1)\n        // a[i] + a[j] + a[k] is a multiple\
    \ of 3 iff (i + j + k) is a multiple of 3, \n        // which can be satisfied\
    \ only if all of i, j, k are identical, \n        // and thus j = k = i, making\
    \ the value of the triple 1.\n        // Thus, return n - 1 for n > 2.\n     \
    \   if (n > 2) n - 1 else n", "        var a = new Array[Long](n.toInt)\n    \
    \    var count = 0l\n        for (i <- 1 to n.toInt) {\n            a(i - 1) =\
    \ (i * i - i + 1) % 3\n            //println(a(i - 1))\n        }\n        for\
    \ (i <- 0 to n.toInt - 3) {\n            if (a(i) == 0) count += 1\n         \
    \   for (j <- i + 1 to n.toInt - 2) {\n                if (a(i) + a(j) == 3) count\
    \ += 1\n                for (k <- j + 1 to n.toInt - 1) {\n                  \
    \  if (a(i) + a(j) + a(k) == 0) count += 1\n                }\n            }\n\
    \        }\n        return count", "        // Make a list of length n.\n    \
    \    val list = List.fill(n.toInt)(1)\n        // Fill the list with values of\
    \ ai.\n        var list2 = list.zipWithIndex.map(p => p._1 * p._2 * p._2)\n  \
    \      list2 = list2.zipWithIndex.map(p => p._1 + p._2)\n        // Filter for\
    \ all possible triplets, only retain those that are multiples of 3.\n        val\
    \ triplets = list2.combinations(3).toList.filter(l => l.sum % 3 == 0)\n      \
    \  // Return the number of triplets.\n        triplets.length", "        val a\
    \ = new Array[Long](n.toInt + 1)\n        for (i <- 1 to n.toInt) {\n        \
    \    a(i) = i * i - i + 1\n        }\n        a(1) = -1\n        a(0) = -1\n \
    \       var total = 0l\n        for (i <- 1 to n.toInt - 2) {\n            for\
    \ (j <- i + 1 to n.toInt - 1) {\n                for (k <- j + 1 to n.toInt) {\n\
    \                    if ((a(i) + a(j) + a(k)) % 3 == 0) total += 1\n         \
    \       }\n            }\n        }\n        total", "        val a = Array.fill(n.toInt)(0)\n\
    \        for (i <- 1 to n.toInt) {\n            a(i - 1) = i * i - i + 1\n   \
    \     }\n        var count = 0\n        for (i <- 0 to n.toInt - 3) {\n      \
    \      for (j <- i + 1 to n.toInt - 2) {\n                for (k <- j + 1 to n.toInt\
    \ - 1) {\n                    if ((a(i) + a(j) + a(k)) % 3 == 0) count += 1\n\
    \                }\n            }\n        }\n        count", "        val modulo\
    \ = 3l\n        val moduloNeg = modulo - 1l\n        val indices = (1l to n).toList\n\
    \        val s = new Solver()\n        val a = indices.map(i => i * i - i + 1l)\n\
    \        s.solve(n, modulo, moduloNeg, a)", "        var result = 0l\n       \
    \ var result2 = 0l\n        var a = new Array[Long](n.toInt)\n        for (i <-\
    \ 1 to n.toInt) {\n            a(i - 1) = i * i - i + 1\n            //println(a(i\
    \ - 1))\n        }\n        for (i <- 0 to n.toInt - 3) {\n            for (j\
    \ <- i + 1 to n.toInt - 2) {\n                for (k <- j + 1 to n.toInt - 1)\
    \ {\n                    if ((a(i) + a(j) + a(k)) % 3 == 0) {\n              \
    \          //println(a(i) + \" \" + a(j) + \" \" + a(k))\n                   \
    \     result += 1\n                    }\n                }\n            }\n \
    \       }\n        result", "        // Given a list of triples, return whether\
    \ the triple is valid.\n        def isValid(triple : (Long, Long, Long)) : Boolean\
    \ = {\n            val (a, b, c) = triple\n            a + b + c % 3 == 0\n  \
    \      }\n        // Given a pair and a list of values, return the list of all\
    \ triples that can be made \n        // with the pair and a value.\n        def\
    \ appendAll(pair : (Long, Long), vals : ArrayBuffer[Long]) : ArrayBuffer[(Long,\
    \ Long, Long)] = {\n            var buffer = ArrayBuffer[(Long, Long, Long)]()\n\
    \            for (v <- vals) {\n                buffer += (pair._1, pair._2, v)\n\
    \            }\n            buffer\n        }\n        // Given a list of triples,\
    \ create a list of all valid triples.\n        def filterValid(triples : ArrayBuffer[(Long,\
    \ Long, Long)]) : ArrayBuffer[(Long, Long, Long)] = {\n            var buffer\
    \ = ArrayBuffer[(Long, Long, Long)]()\n            for (triple <- triples) {\n\
    \                if (isValid(triple)) {\n                    buffer += triple\n\
    \                }\n            }\n            buffer\n        }\n        // Given\
    \ two lists of values, create a list of all pairs of the two lists.\n        def\
    \ combineLists(l1 : ArrayBuffer[Long], l2 : ArrayBuffer[Long]) : ArrayBuffer[(Long,\
    \ Long)] = {\n            var buffer = ArrayBuffer[(Long, Long)]()\n         \
    \   for (v1 <- l1) {\n                for (v2 <- l2) {\n                    buffer\
    \ += (v1, v2)\n                }\n            }\n            buffer\n        }\n\
    \        // Given a list of pairs, create a list of all pairs that are valid.\n\
    \        def filterValidPairs(pairs : ArrayBuffer[(Long, Long)]) : ArrayBuffer[(Long,\
    \ Long)] = {\n            var buffer = ArrayBuffer[(Long, Long)]()\n         \
    \   for (pair <- pairs) {\n                if (pair._1 < pair._2) {\n        \
    \            buffer += pair\n                }\n            }\n            buffer\n\
    \        }\n        // Given a list of values", "        val mod3 = scala.collection.mutable.Map[Long,\
    \ Long]()\n        for (i <- (1 to n.toInt).reverse) {\n            val rem =\
    \ ((i * i - i + 1) % 3 + 3) % 3\n            mod3.put(rem, mod3.getOrElse(rem,\
    \ 0l) + 1)\n        }\n        var ret = mod3.getOrElse(0, 0l) * (mod3.getOrElse(0,\
    \ 0l) - 1) * (mod3.getOrElse(0, 0l) - 2) / 6\n        ret += mod3.getOrElse(1,\
    \ 0l) * mod3.getOrElse(2, 0l) * (mod3.getOrElse(1, 0l) - 1) / 2\n        ret +=\
    \ mod3.getOrElse(1, 0l) * mod3.getOrElse(2, 0l) * (mod3.getOrElse(2, 0l) - 1)\
    \ / 2\n        ret", "        val sum = n*(n+1)/2\n        sum - sum % 3", " \
    \       val a = (1 to n.toInt).map(i => i * i - i + 1).toList\n        val m =\
    \ a.toArray\n        val sum = m.indices.map(i => m.indices.drop(i + 1).map(j\
    \ => m.indices.drop(j + 1).map(k => (i, j, k)))).flatten.flatten.filter(\n   \
    \         p => (m(p._1) + m(p._2) + m(p._3)) % 3 == 0\n        ).size\n      \
    \  sum", "        if (n < 3) 0l\n        else {\n            val a = Array.fill(n.toInt)(0l)\n\
    \            for (i <- 0 until n.toInt) {\n                a(i) = i * i - i +\
    \ 1\n            }\n            val count = Array.fill(n.toInt)(0l)\n        \
    \    for (i <- n.toInt - 1 to 2 by -1) {\n                for (j <- i - 1 to 1\
    \ by -1) {\n                    for (k <- j - 1 to 0 by -1) {\n              \
    \          if ((a(i) + a(j) + a(k)) % 3 == 0) count(i) += 1\n                \
    \    }\n                }\n            }\n            count.max\n        }", " \
    \       val arr = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt)\
    \ arr(i) = i * i - i + 1\n        var res = 0l\n        for (i <- 0 until n.toInt)\
    \ {\n            for (j <- i + 1 until n.toInt) {\n                for (k <- j\
    \ + 1 until n.toInt) {\n                    if ((arr(i) + arr(j) + arr(k)) % 3\
    \ == 0) res += 1\n                }\n            }\n        }\n        res", " \
    \       var count = 0l\n        var ret = 0l\n        for (i <- 1l to n) {\n \
    \           var a1 = i * i - i + 1\n            if (a1 % 3 == 0) count += 1\n\
    \            var a2 = (i + 1) * (i + 1) - (i + 1) + 1\n            if (a2 % 3\
    \ == 0) count += 1\n            var a3 = (i + 2) * (i + 2) - (i + 2) + 1\n   \
    \         if (a3 % 3 == 0) count += 1\n            ret += count\n            count\
    \ -= 3\n        }\n        ret", "        if (n < 3) {\n            return 0\n\
    \        }\n        if (n == 3) {\n            return 1\n        }\n        if\
    \ (n == 4) {\n            return 3\n        }\n        val k = ceil(sqrt(n)).toLong\n\
    \        var result = (k - 2l) * (k - 1l) / 2l\n        result += getMaxTriples(n\
    \ - k)\n        return result", "        // Define the possible values for a[i],\
    \ a[j], a[k].\n        // Let d[i] = i * i - i + 1\n        // Since 1 \u2264\
    \ i \u2264 n, we get 1 \u2264 d[i] \u2264 n * n - n + 1.\n        // Suppose d[i]\
    \ + d[j] + d[k] \u2261 0 (mod 3)\n        // Since 0 \u2264 d[i] \u2264 n * n\
    \ - n + 1, d[i] % 3 = 0, 1, or 2.\n        // d[i] % 3 = 0: d[j] % 3 = 1, d[k]\
    \ % 3 = 2\n        // d[i] % 3 = 1: d[j] % 3 = 2, d[k] % 3 = 0\n        // d[i]\
    \ % 3 = 2: d[j] % 3 = 0, d[k] % 3 = 1\n        // Assume 1 \u2264 i < j < k \u2264\
    \ n\n        // If d[i] % 3 = 0, d[i + 1] % 3 = 1, d[i + 2] % 3 = 2, ..., d[k\
    \ - 2] % 3 = 2, d[k - 1] % 3 = 0, d[k] % 3 = 1.\n        // If d[i] % 3 = 1, d[i\
    \ + 1] % 3 = 2, d[i + 2] % 3 = 0, ..., d[k - 2] % 3 = 0, d[k - 1] % 3 = 1, d[k]\
    \ % 3 = 2.\n        // If d[i] % 3 = 2, d[i + 1] % 3 = 0, d[i + 2] % 3 = 1, ...,\
    \ d[k - 2] % 3 = 1, d[k - 1] % 3 = 2, d[k] % 3 = 0.\n        // Assume 1 \u2264\
    \ i < j < k \u2264 n\n        // If i = 1, k = n, and d[i] % 3 = 0, d[j] % 3 =\
    \ 1, d[k] % 3 = 2, then the triple (d[i], d[j], d[k]) is valid.\n        // If\
    \ i = 1, k = n, and", "        var res = 0\n        for (i <- 0 until n.toInt)\
    \ for (j <- i + 1 until n.toInt) for (k <- j + 1 until n.toInt) {\n          \
    \  if ((1l + (i + 1) * (i + 1) - (i + 1) + 1 + (j + 1) * (j + 1) - (j + 1) + 1\
    \ + (k + 1) * (k + 1) - (k + 1) + 1) % 3 == 0) res += 1\n        }\n        res",
  "        def createSequence(n : Long) : List[Long] = {\n            val b = new\
    \ ListBuffer[Long]\n            for (i <- 1l to n) {\n                b += i *\
    \ i - i + 1\n            }\n            b.toList\n        }\n        def sum3(i\
    \ : Long, j : Long, k : Long) : Boolean = {\n            (i + j + k) % 3 == 0\n\
    \        }\n        def count(tuple : (List[Long], Long)) : Long = {\n       \
    \     val (list, k) = tuple\n            val (head, tail) = list.splitAt(k.toInt)\n\
    \            val triplets = for (i <- head; j <- tail if sum3(i, j, head(k.toInt\
    \ - 1))) yield (i, j, head(k.toInt - 1))\n            triplets.size\n        }\n\
    \        val list = createSequence(n)\n        val m = (for (i <- 1l to n) yield\
    \ count((list, i))).max\n        m", "        val a = (1l to n).map(x => x * x\
    \ - x + 1l).toArray\n        var dp = new Array[Long](3)\n        for (i <- a.indices)\
    \ {\n            val b = new Array[Long](3)\n            for (j <- 0 until 3)\
    \ b(j) = dp(j)\n            for (j <- 0 until 3) {\n                if (a(i) %\
    \ 3 == j) b(j) += dp(3 - j)\n                else b(j) += dp(j)\n            }\n\
    \            dp = b\n        }\n        return dp(0)", "        def quadratic(a\
    \ : Long, b : Long, c : Long) : Long = (-b + sqrt(b * b - 4 * a * c)) / (2 * a)\n\
    \        val m = quadratic(1l, 1l, -6l * n)\n        (0l until floor(m).toLong).map(i\
    \ => 6l * n - 3l * i * i - 3l * i - 1l).filter(x => x % 3l == 0l).size", "   \
    \ \tvar map = new HashMap[Long, Long]()\n    \tvar triples = 0l\n    \tvar total\
    \ = 0l\n    \tfor (i <- 1l to n) {\n    \t\tval a = i * i - i + 1\n    \t\tfor\
    \ (j <- i + 1l to n) {\n    \t\t\tval b = j * j - j + 1\n    \t\t\tval x = (a\
    \ + b) % 3\n    \t\t\tmap(x) = map.getOrElse(x, 0l) + 1\n    \t\t}\n    \t\tfor\
    \ (k <- i + 1l to n) {\n    \t\t\tval b = k * k - k + 1\n    \t\t\tval x = (a\
    \ + b) % 3\n    \t\t\ttotal += map.getOrElse(x, 0l)\n    \t\t}\n    \t}\n    \t\
    total", "        val a = Array.tabulate(n.toInt)(i => i * i - i + 1)\n       \
    \ // for each pair i, j calculate the number of k's satisfying the criteria.\n\
    \        val count = Array.fill(n.toInt, n.toInt)(0)\n        for (i <- 0 until\
    \ n.toInt; j <- i + 1 until n.toInt) {\n            var k = j + 1\n          \
    \  while (k < n.toInt && (a(i) + a(j) + a(k)) % 3 == 0) {\n                count(i)(j)\
    \ += 1\n                k += 1\n            }\n        }\n        var result =\
    \ 0l\n        for (i <- 0 until n.toInt; j <- i + 1 until n.toInt) {\n       \
    \     result += count(i)(j)\n        }\n        result", "        val al = new\
    \ ArrayBuffer[Long]()\n        for (i <- 1l to n) {\n            al += i * i -\
    \ i + 1\n        }\n        var count = 0l\n        for (i <- 0 until al.length\
    \ - 2) {\n            for (j <- i + 1 until al.length - 1) {\n               \
    \ for (k <- j + 1 until al.length) {\n                    if ((al(i) + al(j) +\
    \ al(k)) % 3 == 0) count += 1\n                }\n            }\n        }\n \
    \       count", "        val a = Array.fill(n.toInt)(0l)\n        for (i <- 0\
    \ until n.toInt) a(i) = i * i - i + 1\n        var ans = 0l\n        for (i <-\
    \ 0 until n.toInt)\n        \tfor (j <- i + 1 until n.toInt)\n        \t\tfor\
    \ (k <- j + 1 until n.toInt)\n        \t\t\tif ((a(i) + a(j) + a(k)) % 3 == 0)\
    \ ans += 1\n        ans", "        val m = if (n % 3 == 0) {\n            n /\
    \ 3\n        } else {\n            n / 3 + 1\n        }\n        val v = if (n\
    \ % 3 == 0) {\n            n / 3 * 2\n        } else {\n            n / 3 * 2\
    \ + 1\n        }\n        m * v", "        var count = 0l\n        var sum = 0l\n\
    \        val a = (1 to n.toInt).map(i => i * i - i + 1).toList\n        for (i\
    \ <- 0 to a.length - 3) {\n            for (j <- i + 1 to a.length - 2) {\n  \
    \              for (k <- j + 1 to a.length - 1) {\n                    sum = a(i)\
    \ + a(j) + a(k)\n                    if (sum % 3 == 0) count += 1\n          \
    \      }\n            }\n        }\n        count", '        ???', "        //\
    \ Define the function.\n        def f(i : Long) : Long = i * i - i + 1\n     \
    \   // Generate the list.\n        val l = for(i <- 1l to n) yield f(i)\n    \
    \    // For each index i, find the number of elements from i + 1 to n that\n \
    \       // have the same remainder modulo 3.\n        var result = 0l\n      \
    \  for(i <- 0l until n) {\n            val remainder = l(i.toInt) % 3\n      \
    \      var count = 0l\n            for(j <- i + 1l until n) {\n              \
    \  if(l(j.toInt) % 3 == remainder) count += 1\n            }\n            result\
    \ += count * (count + 1) / 2\n        }\n        result", '        (1l)', "  \
    \      if (n < 3) return 0\n        var cnt = 0\n        var two = (1 to n.toInt).map(i\
    \ => i * i - i + 1).filter(i => i % 3 == 2).toList\n        var one = (1 to n.toInt).map(i\
    \ => i * i - i + 1).filter(i => i % 3 == 1).toList\n        var zero = (1 to n.toInt).map(i\
    \ => i * i - i + 1).filter(i => i % 3 == 0).toList\n        var map = scala.collection.mutable.Map[Int,\
    \ Int]()\n        var a = ArrayBuffer(one, two, zero)\n        for (i <- a) {\n\
    \            var l = i.length\n            for (j <- 0 until l) {\n          \
    \      for (k <- j + 1 until l) {\n                    var sum = i(j) + i(k)\n\
    \                    var v = map.getOrElse(sum, 0)\n                    map.put(sum,\
    \ v + 1)\n                }\n            }\n        }\n        for (i <- map)\
    \ {\n            cnt += i._2\n        }\n        return cnt", "        // Fill\
    \ in the code here.\n        0", "        val (a, b, c) = (n / 3 - 1, n / 3, (n\
    \ + 2) / 3)\n        // From the equation, there are only three type of triple.\n\
    \        return a * b * c", "        var c = 0l\n        for (i <- 1l to n) {\n\
    \            for (j <- i+1l to n) {\n                for (k <- j+1l to n) {\n\
    \                    if ((i*i - i + 1) + (j*j - j + 1) + (k*k - k + 1) % 3 ==\
    \ 0) {\n                        c += 1\n                    }\n              \
    \  }\n            }\n        }\n        return c", "        var count = 0\n  \
    \      val squares = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            squares(i) = i.toLong * i.toLong - i.toLong + 1\n        }\n\
    \        for (i <- 0 until n.toInt - 2) {\n            for (j <- i + 1 until n.toInt\
    \ - 1) {\n                for (k <- j + 1 until n.toInt) {\n                 \
    \   if ((squares(i) + squares(j) + squares(k)) % 3 == 0) count += 1\n        \
    \        }\n            }\n        }\n        count", "        // val a = (1l\
    \ to n).map(i => i * i - i + 1).toArray\n        // return (for {\n        //\
    \     i <- 0l until n - 2\n        //     j <- i + 1l until n - 1\n        //\
    \     k <- j + 1l until n\n        //     if (a(i.toInt) + a(j.toInt) + a(k.toInt))\
    \ % 3 == 0\n        // } yield ((i, j, k), a(i.toInt) + a(j.toInt) + a(k.toInt))).size\n\
    \        val a = (1l to n).map(i => i * i - i + 1).toArray\n        val set =\
    \ for {\n            i <- 0l until n - 2\n            j <- i + 1l until n - 1\n\
    \            k <- j + 1l until n\n            if (a(i.toInt) + a(j.toInt) + a(k.toInt))\
    \ % 3 == 0\n        } yield (i, j, k)\n        return set.size", "        val\
    \ factors = new Array[Int]((n + 1).toInt)\n        var i = 1\n        while (i\
    \ <= n) {\n            factors(i) = i * i - i + 1\n            i += 1\n      \
    \  }\n        // 1, 3, 7, 13, 21, 31, 43, 57, 73, 91, 111, 133, 157, 183, 211,\
    \ 241, 273, 307, 343, 381, 421, 463, 507, 553, 601, 651, 703, 757, 813, 871, 931,\
    \ 993, 1057, 1123, 1191, 1261, 1333, 1407, 1483, 1561, 1641, 1723, 1807, 1891,\
    \ 1987, 2085, 2185, 2287, 2391, 2497, 2605, 2715, 2827, 2941, 3057, 3175, 3295,\
    \ 3417, 3541, 3667, 3795, 3925, 4057, 4191, 4327, 4465, 4605, 4747, 4891, 5037,\
    \ 5185, 5335, 5487, 5641, 5797, 5955, 6115, 6277, 6441, 6607, 6775, 6945, 7117,\
    \ 7291, 7467, 7645, 7825, 8007, 8191, 8377, 8565, 8755, 8947, 9141, 9337, 9535,\
    \ 9735, 9937, 10141, 10347, 10555, 10765, 10977, 11191, 11407, 11625, 11845, 12067,\
    \ 12291, 12517, 12745, 12975, 13207, 13441, 13677, 13915, 14155, 14397, 14641,\
    \ 14887, 15135, 15385, 15637, 15891, 16147, 16405, 16665, 16927, 17191, 17457,\
    \ 17725, 17995, 18267, 18541, 18817, 19095, 19374, 19655, 19938, 20223, 20510,\
    \ 20799, 21089, 21381, 21675, 21971, 22269, 22569, 22871, 23175, 23481, 23789,\
    \ 24099, 24411, 24725, 25041, 25359, 25679,", "        var sum : Long = 0\n  \
    \      var count : Long = 0\n        for (i <- 1l to n - 2) {\n            sum\
    \ += i\n            if (sum % 3 == 0) count += (n - i - 1)\n        }\n      \
    \  count", "        var ans = 0l\n        for (i <- 1l to n) {\n            for\
    \ (j <- i + 1l to n) {\n                for (k <- j + 1l to n) {\n           \
    \         if ((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0) {\n  \
    \                      ans += 1\n                    }\n                }\n  \
    \          }\n        }\n        ans", "        var prev1 = 1l\n        var prev2\
    \ = 3l\n        var prev3 = 7l\n        var ans = 0l\n        for (i <- 4l to\
    \ n) {\n            val temp = 6l * i - 9l\n            if (temp % 3 == 0) ans\
    \ += 1\n            prev1 = prev2\n            prev2 = prev3\n            prev3\
    \ = temp\n        }\n        ans", "        var result = 0l\n        for (i <-\
    \ 0l until n) {\n            val ai = i * i - i + 1\n            for (j <- i +\
    \ 1l until n) {\n                val aj = j * j - j + 1\n                if ((ai\
    \ + aj) % 3 == 0) {\n                    result += (n - j)\n                }\n\
    \            }\n        }\n        result", "        val a = Array.fill(n.toInt)(1)\n\
    \        for (i <- 0 until n.toInt) a(i) = i * i - i + 1\n        var res = 0l\n\
    \        for (i <- 0 until n.toInt - 2)\n            for (j <- i + 1 until n.toInt\
    \ - 1)\n                for (k <- j + 1 until n.toInt)\n                    if\
    \ ((a(i) + a(j) + a(k)) % 3 == 0) res += 1\n        res", "        // Simulation\n\
    \        val a = (1 to n.toInt).map(i => i * i - i + 1).toList\n        a.combinations(3).count(x\
    \ => (x(0) + x(1) + x(2)) % 3 == 0)", "        // This is a naive solution to\
    \ the problem. We can do better.\n        var total = 0l\n        for (i <- 1\
    \ to n.toInt) {\n            for (j <- i + 1 to n.toInt) {\n                for\
    \ (k <- j + 1 to n.toInt) {\n                    if ((i * i - i + 1 + j * j -\
    \ j + 1 + k * k - k + 1) % 3 == 0) {\n                        total += 1\n   \
    \                 }\n                }\n            }\n        }\n        total",
  "        val max = (n * (n - 1) * (n - 2)) / 6\n        val tris = Map[Long, Long]()\n\
    \        for (i <- 1l to n - 1l) {\n            for (j <- i + 1l to n) {\n   \
    \             val s = i * i - i + 1 + j * j - j + 1\n                if (s % 3\
    \ == 0) {\n                    if (tris.contains(s)) tris(s) += 1\n          \
    \          else tris(s) = 1\n                }\n            }\n        }\n   \
    \     return max - tris.values.map(v => (v * (v - 1)) / 2).sum", "        var\
    \ count = 0l\n        for (i <- 1l to n) {\n            val result = i * i - i\
    \ + 1\n            val resultRemainder = result % 3\n            if (resultRemainder\
    \ == 0) count += 1\n        }\n        count", "        // n is even\n       \
    \ if (n % 2 == 0) (n / 2l) * (n / 2l)\n        // n is odd\n        else (n /\
    \ 2l) * (n / 2l + 1l)", "        def find(l : Long) : Boolean = (1l to n).exists(m\
    \ => ((m * m - m + 1) == l))\n        val arr = ArrayBuffer[Long]()\n        (1l\
    \ to n).foreach(m => {\n            val l = m * m - m + 1\n            if (find(l))\
    \ arr += l\n        })\n        println(arr)\n        arr.combinations(3).filter(a\
    \ => (a(0) + a(1) + a(2)) % 3 == 0).size", "        var t = 0\n        for (i\
    \ <- 1 to n.toInt) {\n            for (j <- i + 1 to n.toInt) {\n            \
    \    val ai = i * i - i + 1\n                val aj = j * j - j + 1\n        \
    \        if ((ai + aj) % 3 == 0) {\n                    for (k <- j + 1 to n.toInt)\
    \ {\n                        val ak = k * k - k + 1\n                        if\
    \ ((ai + aj + ak) % 3 == 0) {\n                            t += 1\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n        t", "        // binomial coefficients\n        def bcs(n : Long,\
    \ k : Long) : Long = {\n            if (k > n) 0l\n            else if (k == 0l\
    \ || k == n) 1l\n            else bcs(n - 1, k - 1) + bcs(n - 1, k)\n        }\n\
    \        // this is a binomial coefficient problem\n        // you have to figure\
    \ out how many possibilities you have in summing up:\n        // a[i] + a[j] +\
    \ a[k]\n        // a[i] + a[j] + a[k] + a[l]\n        // .. a[i] + a[j] + a[k]\
    \ + a[l] + a[m]\n        // so that each case is a multiple of 3\n        // for\
    \ each case, a[i] + a[j] + a[k] is a multiple of 3, \n        // then a[i] + a[j]\
    \ is either 1 or 2, and a[k] is either 0 or 1\n        // which means you have\
    \ the following cases:\n        // a[i] + a[j] + a[k] is a multiple of 3 => a[i]\
    \ + a[j] = 1 and a[k] = 0\n        // a[i] + a[j] + a[k] is a multiple of 3 =>\
    \ a[i] + a[j] = 2 and a[k] = 1\n        // the cases are exhaustive\n        //\
    \ now, the number of triples will be 2^n (because a[i] and a[j] can be anything)\
    \ \n        // * binomial coefficient (n, 2) (because a[i] and a[j] are fixed\
    \ to 2 out of n, and a[k] is fixed to 1 out of n) \n        // * 2 (because a[i]\
    \ + a[j] = 1 and a[k] = 0, and a[i] + a[j] = 2 and a[k] = 1)\n        // and do\
    \ the same, you have to compute the number of quadruples, etc\n        // and\
    \ then, the answer will be:\n        // (2^n * C(n, 2) * 2) - (", "        val\
    \ sum = n.toInt * (n.toInt + 1) / 2\n        if (sum % 3 == 0)\n        \tif (n.toInt\
    \ % 3 == 0)\n        \t\t(n.toInt - 1) * (n.toInt - 2) / 6\n        \telse if\
    \ (n.toInt % 3 == 1)\n        \t\tn.toInt * (n.toInt - 1) / 2\n        \telse\n\
    \        \t\t(n.toInt - 1) * (n.toInt - 2) / 2\n        else if (sum % 3 == 1)\n\
    \        \tif (n.toInt % 3 == 0)\n        \t\t(n.toInt - 1) * (n.toInt - 2) /\
    \ 2\n        \telse if (n.toInt % 3 == 1)\n        \t\t(n.toInt - 1) * (n.toInt\
    \ - 2) / 6\n        \telse\n        \t\tn.toInt * (n.toInt - 1) / 2\n        else\n\
    \        \tif (n.toInt % 3 == 0)\n        \t\tn.toInt * (n.toInt - 1) / 2\n  \
    \      \telse if (n.toInt % 3 == 1)\n        \t\t(n.toInt - 1) * (n.toInt - 2)\
    \ / 2\n        \telse\n        \t\t(n.toInt - 1) * (n.toInt - 2) / 6", "     \
    \   val a = (1l to n).map(x => x * x - x + 1).toList\n        var count = 0l\n\
    \        for (i <- 0 to a.length - 3) {\n            for (j <- i + 1 to a.length\
    \ - 2) {\n                for (k <- j + 1 to a.length - 1) {\n               \
    \     if ((a(i) + a(j) + a(k)) % 3 == 0) {\n                        count += 1\n\
    \                    }\n                }\n            }\n        }\n        count",
  "        val a = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) a(i)\
    \ = i * i - i + 1\n        var count = 0l\n        for (i <- 0 until n.toInt -\
    \ 2) {\n            for (j <- i + 1 until n.toInt - 1) {\n                for\
    \ (k <- j + 1 until n.toInt) {\n                    if ((a(i) + a(j) + a(k)) %\
    \ 3 == 0) count += 1\n                }\n            }\n        }\n        count",
  "        val a = Array.ofDim[Long](n.toInt, n.toInt)\n        for (i <- 1 to n.toInt)\
    \ {\n            for (j <- 1 to n.toInt) {\n                if (j <= i) a(i -\
    \ 1)(j - 1) = i * i - i + 1\n                else a(i - 1)(j - 1) = a(i - 1)(j\
    \ - 2) + 2 * j - 2\n            }\n        }\n        var count = 0\n        for\
    \ (i <- 0 to n.toInt - 3) {\n            for (j <- i + 1 to n.toInt - 2) {\n \
    \               for (k <- j + 1 to n.toInt - 1) {\n                    if ((a(i)(j)\
    \ + a(i)(k) + a(j)(k)) % 3 == 0) count += 1\n                }\n            }\n\
    \        }\n        count", "        // The sum of the first N odd numbers is\
    \ always N squared.\n        val max = n*n\n        var n3 = 0l\n        // This\
    \ is the list of squares\n        var squares = new ArrayBuffer[Long]()\n    \
    \    for (i <- 1l to max) {\n            val q = i*i\n            if (q > max)\
    \ break\n            squares += q\n        }\n        // This is the list of squares\
    \ of odds\n        var oddsquares = new ArrayBuffer[Long]()\n        for (i <-\
    \ 1l to max by 2) {\n            val q = i*i\n            if (q > max) break\n\
    \            oddsquares += q\n        }\n        for (i <- 0 to squares.length\
    \ - 3) {\n            for (j <- i + 1 to squares.length - 2) {\n             \
    \   val sum = squares(i) + squares(j)\n                // Pick all possible squares\
    \ of odds\n                for (k <- 0 to oddsquares.length - 1) {\n         \
    \           if (sum + oddsquares(k) > max) break\n                    if ((sum\
    \ + oddsquares(k)) % 3 == 0) n3 += 1\n                }\n            }\n     \
    \   }\n        n3", "        // your code here\n        var a = ArrayBuffer[Long]()\n\
    \        for (i <- 1l to n) a += i * i - i + 1\n        var count = 0l\n     \
    \   for (i <- 1l to n - 2)\n        for (j <- i + 1l to n - 1)\n        for (k\
    \ <- j + 1l to n) {\n            val t = a(i.toInt - 1) + a(j.toInt - 1) + a(k.toInt\
    \ - 1)\n            if (t % 3 == 0) count += 1\n        }\n        count", " \
    \       val a = new Array[Long](n.toInt)\n        for (i <- 1 to n.toInt) {\n\
    \            a(i - 1) = i * i - i + 1\n        }\n        // a.foreach(println)\n\
    \        var sum = 0l\n        for (i <- 0 to a.length - 3) {\n            for\
    \ (j <- i + 1 to a.length - 2) {\n                for (k <- j + 1 to a.length\
    \ - 1) {\n                    if ((a(i) + a(j) + a(k)) % 3 == 0) sum += 1\n  \
    \              }\n            }\n        }\n        return sum", "        // Assumptions:\
    \ n >= 3.\n        // We use a triplet (a, b, c) to represent a set of three numbers\
    \ a, b, c where a < b < c.\n        // We want to find the number of triplets\
    \ (a, b, c) that satisfy a + b + c % 3 == 0.\n        // We can separate this\
    \ into two parts: triplets where the sum is % 3 == 0 and triplets where the sum\
    \ is % 3 == 1.\n        // Let's consider the case where the sum is % 3 == 0 first.\n\
    \        // We can create a triplet by picking a, then b, then c.\n        //\
    \ b has to satisfy (a % 3 + b % 3) % 3 == 0, so b % 3 == 0 if a % 3 == 0 and b\
    \ % 3 == 1 if a % 3 == 1.\n        // a has to satisfy (a % 3 + b % 3 + c % 3)\
    \ % 3 == 0, so c % 3 == 0.\n        // We are picking a, b, and c independently,\
    \ so (b - a - 1) * (c - b - 1) is the number of triplets we can construct.\n \
    \       // This can be done in O(1) time since (b - a - 1) and (c - b - 1) are\
    \ constants.\n        // We now want to count the number of triplets where the\
    \ sum is % 3 == 1.\n        // We can do the same thing as before, but now a and\
    \ b need to satisfy a % 3 == 1 and b % 3 == 2.\n        // This can be done in\
    \ O(1) time.\n        val count0 = (n - 1) * (n - 2) * (n - 3) / 6\n        val\
    \ count1 = (n - 2) * (n - 3) * (n - 4) / 6\n        count0 + count1", '        (1l
    to n).toList.map(i => (i * i - i + 1)).combinations(3).toList.filter(a => (a(0)
    + a(1) + a(2)) % 3 == 0).length', "        var t = 0l\n        var v = 1l\n  \
    \      for (i <- 1l to n) {\n            t += (n - i) * (i - 1)\n            v\
    \ += 2\n        }\n        t", "        // This problem is not very difficult,\
    \ but it is very slow (n^3).\n        // For example, if n = 10^9, the result\
    \ can be obtained in 1 second, but if n = 10^10, it will take 10 minutes.\n  \
    \      // By the way, this question is very similar to the question of how many\
    \ integer triples (x, y, z) satisfy x < y < z and x + y + z = n.\n        // As\
    \ long as it is known that the required number of triples is n(n-1) * (n-2) /\
    \ 6.\n        // As long as x + y + z is divisible by 3, there must be one i such\
    \ that x + y + z - i * 3 is divisible by 3.\n        // That is, the number of\
    \ triples (x, y, z) satisfying x < y < z and x + y + z is divisible by 3 is equal\
    \ to\n        // the number of triples (x, y, z) satisfying x < y < z and x +\
    \ y + z - 1 is divisible by 3 plus\n        // the number of triples (x, y, z)\
    \ satisfying x < y < z and x + y + z - 2 is divisible by 3.\n        // That is\
    \ to say, the number of triples (x, y, z) satisfying x < y < z and x + y + z is\
    \ divisible by 3 is\n        // equal to the number of triples (x, y, z) satisfying\
    \ x < y < z and x + y + z is divisible by 3 plus \n        // the number of triples\
    \ (x, y, z) satisfying x < y < z and x + y + z - 1 is divisible by 3 plus\n  \
    \      // the number of triples (x, y, z) satisfying x < y < z and x + y + z -\
    \ 2 is divisible by 3.\n        // In this way, the problem can be reduced to\
    \ the problem of calculating the number of triples satisfying x < y < z and x\
    \ + y + z = n,\n        // and the problem is reduced from O(n^3) to O(n).\n \
    \       val m = (n + 1) * n / 2\n        val s = m / 3\n        var result = 0\n\
    \        for (i", "        // Define the given input(s)\n        val a = getSequence(n)\n\
    \        // Define the wanted output(s)\n        val result =\n            //\
    \ Pick two elements from a\n            for (i <- a; j <- a) yield (i, j)\n  \
    \          // Filter only valid triples: i < j\n            .filter(x => x._1\
    \ < x._2)\n            // Pick one element from a\n            .flatMap(x => a.map(k\
    \ => (x._1, x._2, k)))\n            // Filter only valid triples: j < k\n    \
    \        .filter(x => x._2 < x._3)\n            // Filter only valid triples:\
    \ a[i] + a[j] + a[k] is a multiple of 3\n            .filter(x => (x._1 + x._2\
    \ + x._3) % 3 == 0)\n        // Return the result(s)\n        result.length",
  '        ???', "        // \"a\" is a sorted list of numbers, such that each number\
    \ is a multiple of 3.\n        // Therefore, we only need to count the number\
    \ of triples where all numbers are multiples of 3.\n        // For example:\n\
    \        // [1, 3, 6, 9, 12, 18, 21, 24, 27, 33, 36, 39, 42, 48, 51, 54, 57, 63,\
    \ 66, 69, 72, 78, 81, 84, 87, 93, 96, 99]\n        // We will only count triples\
    \ where all numbers are multiples of 3.\n        // [3, 6, 9, 12, 18, 21, 24,\
    \ 27, 33, 36, 39, 42, 48, 51, 54, 57, 63, 66, 69, 72, 78, 81, 84, 87, 93, 96,\
    \ 99]\n        // We only need to find the total number of triples where all numbers\
    \ are multiples of 3.\n        // We can find the index of the last element <\
    \ L, where L = N / 3.\n        // We can then count the number of triples with\
    \ exactly 3 elements, which are multiples of 3.\n        // We can then count\
    \ the number of triples with exactly 4 elements, which are multiples of 3.\n \
    \       // Etc.\n        // In order to count the number of triples with 3 elements,\
    \ we need to find the index of the last element < L - 1,\n        // and then\
    \ the index of the last element < L - 2.\n        // We then find the number of\
    \ triples with these indices.\n        // We do the same thing for 4 elements,\
    \ and so on.\n        // If we look at the 0-based indices, the problem reduces\
    \ to a simpler problem:\n        // Given indices I, J, K, count the number of\
    \ triples (X, Y, Z) such that\n        // I <= X < Y < Z <= K\n        // where\
    \ I = 0, J = 1, and K = 2.\n        // When J = 2, the problem reduces to a simpler\
    \ problem:\n        // Given indices I, J, count the number of triples (X, Y)\
    \ such that\n        // I <= X < Y <= J\n        // We do this with dynamic programming.\n\
    \        val a = Array.fill(n.to", "        // a[i] = i * i - i + 1\n        //\
    \ a[i] + a[j] + a[k] = 3 * (i * i - i + 1) + 3 * (j * j - j + 1) + 3 * (k * k\
    \ - k + 1)\n        //                     = 3 * ((i * i - i + 1) + (j * j - j\
    \ + 1) + (k * k - k + 1))\n        //                     = 3 * ((i * i - i +\
    \ 1) + (j * j - j + 1) + (k * k - k + 1))\n        //                     = 3\
    \ * ((i + j + k) * (i + j + k) - (i + j + k) + 3)\n        //                \
    \     = 3 * ((i + j + k) * (i + j + k) - (i + j + k) + 3)\n        //        \
    \             = 3 * ((i + j + k) * (i + j + k) - i - j - k + 3)\n        //  \
    \                   = 3 * ((i + j + k) * (i + j + k) - i - j - k + 3)\n      \
    \  // (i + j + k) * (i + j + k) - i - j - k + 3\n        //  i * i + j * j + k\
    \ * k + 3 * i * j + 3 * i * k + 3 * j * k\n        //  i * i + j * j + k * k +\
    \ 3 * i * j + 3 * i * k + 3 * j * k\n        //  a[i] + a[j] + a[k] = a[i] + a[j]\
    \ + a[k]\n        val arr = Array.ofDim[Int]((n * n + 3) / 3)\n        for (i\
    \ <- 1 to n.toInt) {\n            for (j <- 1 to n.toInt) {\n                for\
    \ (k <- 1 to n.toInt) {\n                    val x = i * i + j * j + k * k + 3\
    \ * i * j + 3 * i * k + 3 * j * k\n                    if (x > 0 && x <= n * n)\
    \ arr(x) += 1\n", "        val a = Array.tabulate(n.toInt)(x => x * x - x + 1)\n\
    \        var c = 0\n        for (i <- 0 until n.toInt - 2) {\n            for\
    \ (j <- i + 1 until n.toInt - 1) {\n                for (k <- j + 1 until n.toInt)\
    \ {\n                    if ((a(i) + a(j) + a(k)) % 3 == 0) c += 1\n         \
    \       }\n            }\n        }\n        c", "        // (i, j, k) with (i\
    \ + j + k) % 3 == 0\n        // \n        // (i, j, k) with 1 <= i < j < k <=\
    \ n\n        // 0 <= i + j + k <= 3n\n        // 0 <= i + j < 2n, 2 <= i + j <\
    \ 3n\n        // 0 <= i + k < 2n, 2 <= i + k < 3n\n        // 0 <= j + k < 2n,\
    \ 2 <= j + k < 3n\n        val s : Long = 3 * n;\n        val arr = new Array[Int](s.toInt);\n\
    \        for (i <- 1 to n.toInt) {\n            val curr : Long = i * i - i +\
    \ 1;\n            for (j <- 1 to n.toInt) {\n                val sum : Long =\
    \ curr + j * j - j + 1;\n                if (sum <= s) arr(sum.toInt) += 1;\n\
    \            }\n        }\n        var result : Long = 0;\n        for (i <- 1\
    \ to n.toInt) {\n            val curr : Long = i * i - i + 1;\n            for\
    \ (j <- i + 1 to n.toInt) {\n                val sum : Long = curr + j * j - j\
    \ + 1;\n                if (sum <= s) result += arr(sum.toInt);\n            }\n\
    \        }\n        result", "        var arr = new Array[Int](n.toInt)\n    \
    \    for (i <- 0 until n.toInt) {\n            arr(i) = i * i - i + 1\n      \
    \  }\n        var l = new ArrayBuffer[Int]\n        var s = new ArrayBuffer[Int]\n\
    \        var count = 0l\n        for (a <- arr) {\n            if (a % 3 == 0)\
    \ {\n                l += a\n            } else if (a % 3 == 1) {\n          \
    \      s += a\n            } else {\n                count += l.length\n     \
    \       }\n        }\n        var sp = 0\n        for (a <- s) {\n           \
    \ while (sp < l.length && l(sp) < a) {\n                sp += 1\n            }\n\
    \            count += l.length - sp\n        }\n        return count", "     \
    \   var a = Array.tabulate(n.toInt)(x => (x + 1) * (x + 1) - (x + 1) + 1)\n  \
    \      var res = 0\n        var j = 0\n        var k = 0\n        while (j < n\
    \ - 1) {\n            while (k < n) {\n                if (a(j) + a(k) < a(n.toInt\
    \ - 1)) k += 1\n                else {\n                    if ((a(j) + a(k))\
    \ % 3 == 0) res += 1\n                    k += 1\n                }\n        \
    \    }\n            j += 1\n            k = j + 1\n        }\n        res", " \
    \       var ans = 0l\n        for (i <- 1 to n.toInt - 2) {\n            for (j\
    \ <- i + 1 to n.toInt - 1) {\n                for (k <- j + 1 to n.toInt) {\n\
    \                    if ((i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 ==\
    \ 0) {\n                        ans += 1\n                    }\n            \
    \    }\n            }\n        }\n        ans", "      var count = 0\n      for\
    \ (i <- 1 to n.toInt - 2) {\n        for (j <- i + 1 to n.toInt - 1) {\n     \
    \     for (k <- j + 1 to n.toInt) {\n            if ((i * i - i + 1 + j * j -\
    \ j + 1 + k * k - k + 1) % 3 == 0) {\n              count += 1\n            }\n\
    \          }\n        }\n      }\n      count", "    \tval a = new Array[Long](n.toInt)\n\
    \    \tfor (i <- 0 until n.toInt) {\n    \t\ta(i) = i * i - i + 1\n    \t}\n \
    \   \ta.combinations(3).map {c => \n    \t\tif ((c(0) + c(1) + c(2)) % 3 == 0)\
    \ 1 else 0\n    \t}.sum", "        var a = new Array[Long](n.toInt)\n        for\
    \ (i <- 1 to n.toInt) a(i - 1) = i * i - i + 1\n        var cnt = 0l\n       \
    \ for (i <- 0 to n.toInt - 3)\n            for (j <- i + 1 to n.toInt - 2)\n \
    \               for (k <- j + 1 to n.toInt - 1) if ((a(i) + a(j) + a(k)) % 3 ==\
    \ 0) cnt += 1\n        cnt", "        var a = new Array[Long](n.toInt)\n     \
    \   var count = 0\n        for (i <- 0 until n.toInt) {\n            a(i) = i\
    \ * i - i + 1\n            for (j <- 0 until i) {\n                for (k <- 0\
    \ until j) {\n                    if ((a(i) + a(j) + a(k)) % 3 == 0) {\n     \
    \                   count += 1\n                    }\n                }\n   \
    \         }\n        }\n        return count", "    \t(n * (n - 1) * (n - 2) /\
    \ 6)", "        val table = scala.collection.mutable.HashMap[Long, ArrayBuffer[Long]]()\n\
    \        var count = 0l\n        for (i <- 1l to n) {\n            val a = (i\
    \ * i - i + 1) % 3\n            if (table.contains(a)) {\n                val\
    \ buffer = table(a)\n                for (b <- buffer) count += (i - b)\n    \
    \            buffer += i\n            } else {\n                table += a ->\
    \ ArrayBuffer(i)\n            }\n        }\n        count", '        (1l to n).map(x
    => x*x - x + 1).foldLeft(0)((x,y) => x + y)', "        val sieve = new Sieve(n);\n\
    \        val primes = sieve.getPrimes(2, n.toInt);\n        val hash = new HashMap[Long,\
    \ Long]();\n        val sum = (1 to primes.length).foldLeft(0) {(acc, i) =>\n\
    \            var sum = 0;\n            for (j <- i + 1 to primes.length) {\n \
    \               sum += primes(j - 1);\n                if (sum <= n) {\n     \
    \               hash(sum) = hash.getOrElse(sum, 0) + 1;\n                }\n \
    \           }\n            acc\n        }\n        var result = 0;\n        for\
    \ (i <- 1 to primes.length) {\n            for (j <- i + 1 to primes.length) {\n\
    \                for (k <- j + 1 to primes.length) {\n                    val\
    \ a = primes(i - 1);\n                    val b = primes(j - 1);\n           \
    \         val c = primes(k - 1);\n                    if ((a + b + c) % 3 == 0)\
    \ {\n                        result += hash.getOrElse(a + b + c, 0);\n       \
    \             }\n                }\n            }\n        }\n        result",
  "        val a = ListBuffer[Long]()\n        for (i <- 1l to n) a += i * i - i +\
    \ 1\n        val m = new Array[Int](3)\n        for (i <- 0 until 3) m(i) = a.count(_\
    \ % 3 == i)\n        println(m.mkString(\" \"))\n        val res = m(0) * (m(0)\
    \ - 1) * (m(0) - 2) / 6 + m(1) * (m(1) - 1) * (m(2)) / 2 + m(2) * (m(2) - 1) *\
    \ (m(1)) / 2\n        res", "        //val t = (1l to n).map(x => x * x - x +\
    \ 1l).toArray\n        val t = Array.tabulate(n.toInt)(x => (x + 1l) * (x + 1l)\
    \ - (x + 1l) + 1l)\n        var c = 0l\n        for (i <- 0 to t.length - 1) {\n\
    \            for (j <- i + 1 to t.length - 1) {\n                for (k <- j +\
    \ 1 to t.length - 1) {\n                    val x = (t(i) + t(j) + t(k)) % 3\n\
    \                    if (x == 0) c += 1\n                }\n            }\n  \
    \      }\n        c", "    \t(1l to n - 2).foldLeft(0l)((acc, i) => acc + (1l\
    \ to n - i - 1).filter(j => (i + j) % 3 == 0).length)", "        if (n == 0) 0\n\
    \        else {\n            // If a[i] + a[j] + a[k] is a multiple of 3 then\
    \ the sum of the remainders when each of\n            // a[i], a[j], a[k] is divided\
    \ by 3 must also be a multiple of 3.\n            // The remainder when a[i] is\
    \ divided by 3 is given by (i * i - i + 1) % 3 = ((i - 1) % 3)^2\n           \
    \ // Similarly, the remainder when a[j] is divided by 3 is given by (j * j - j\
    \ + 1) % 3 = ((j - 1) % 3)^2\n            // Using this fact we can conclude that\
    \ the sum of the remainders when i, j, k is divided by 3\n            // is a\
    \ multiple of 3 if and only if ((i - 1) % 3)^2 + ((j - 1) % 3)^2 + ((k - 1) %\
    \ 3)^2 = 0\n            // The set of values of (i - 1) % 3 is {0, 1, 2} and the\
    \ set of values of (i - 1)^2 % 3 is {0, 1}\n            // Hence the only possible\
    \ value of the sum of the remainders when i, j, k is divided by 3\n          \
    \  // is 0, 1, 2, 3.\n            // Note that a[i] + a[j] + a[k] is not necessarily\
    \ a multiple of 3 if the sum of the remainders\n            // when i, j, k is\
    \ divided by 3 is 0, 2, or 3.\n            // If the sum of the remainders when\
    \ i, j, k is divided by 3 is 2 or 3, then at least one of i, j, k is\n       \
    \     // divisible by 3, therefore a[i] + a[j] + a[k] is divisible by 3.\n   \
    \         // If the sum of the remainders when i, j, k is divided by 3 is 0, then\
    \ all of i, j, k are\n            // divisible by 3, therefore a[i] + a[j] + a[k]\
    \ is divisible by 3.\n            // Hence the count of valid triples is given\
    \ by the number of triples where the", "        var a = new Array[Long](n.toInt)\n\
    \        for (i <- 1 to n.toInt) a(i - 1) = i * i - i + 1\n        var count =\
    \ 0\n        for (i <- 0 to n.toInt - 3) {\n            for (j <- i + 1 to n.toInt\
    \ - 2) {\n                if ((a(i) + a(j)) % 3 == 0) {\n                    var\
    \ k = j + 1\n                    while (k < n.toInt && (a(i) + a(j) + a(k)) %\
    \ 3 == 0) {\n                        count += 1\n                        k +=\
    \ 1\n                    }\n                }\n            }\n        }\n    \
    \    count", '        return 0', '        0l', "        // First approach:\n \
    \       // The array has a pattern:\n        // [1, 3, 7, 13, 21]\n        //\
    \ If a sum of a triple is divisible by 3, then the sum of the indices is also\
    \ divisible by 3.\n        // To count the number of triples, just find all possible\
    \ combinations.\n        // val sum = (1 to n.toInt).map(i => i * i - i + 1).groupBy(i\
    \ => i).map(e => e._2.length).sum\n        // (sum / 6l)\n        // Second approach:\n\
    \        // The sum of the indices is always a multiple of 3\n        // so, if\
    \ the array has n numbers, then the number of triples is\n        // (n choose\
    \ 3) * 2.\n        val sum = n * (n - 1) * (n - 2) / 6l\n        // (sum / 6l)\n\
    \        sum", "        // If n is odd, then no triples will contain an odd number,\
    \ \n        // so we only need to care about the even numbers.\n        // a[i]\
    \ + a[j] + a[k] is always multiple of 3, where k > j > i\n        // a[i] + a[j]\
    \ is always multiple of 3, where k > j > i\n        // a[i] is always even, where\
    \ k > j > i\n        // If a[i] + a[j] + a[k] is multiple of 3, then a[i] + a[j]\
    \ is also multiple of 3\n        // So we only need to check the pairs of even\
    \ numbers.\n        // a[i] + a[j] is always multiple of 3, where i < j\n    \
    \    // From i = 1 to i = n - 1, a[i] = i * i - i + 1 = (i - 1) * i + 1\n    \
    \    // a[i] is always even, where i < j\n        // So, a[i] will be a multiple\
    \ of 3 where a[i] % 3 = 1\n        // Therefore, for each a[i] = i * i - i + 1\
    \ = (i - 1) * i + 1 where a[i] % 3 = 1, \n        // (a[i], a[j], a[k]) is a valid\
    \ triple where k > j > i.\n        // We need to find the number of all integers\
    \ that are less than a[i] and are multiples of 3.\n        // The number of all\
    \ numbers that are multiples of 3 and less than a[i] = a[i] / 3, if a[i] % 3 =\
    \ 1\n        // The number of all numbers that are multiples of 3 and less than\
    \ a[i] = a[i] / 3 - 1, if a[i] % 3 = 2\n        val triples = new Array[Long](3)\n\
    \        for (i <- 1 to n.toInt) {\n            triples(i % 3) += (i * i - i +\
    \ 1) / 3\n        }\n        triples(1) - triples(2)", "        val possibleValues\
    \ = n.toInt\n        val a = new Array[Long](possibleValues)\n        for (i <-\
    \ 1 to possibleValues) {\n            a(i - 1) = (i * i - i + 1) % 3\n       \
    \ }\n        var result = 0l\n        var countOf0s = 0\n        var countOf1s\
    \ = 0\n        var countOf2s = 0\n        for (i <- 0 until possibleValues) {\n\
    \            if (a(i) == 0) countOf0s += 1\n            else if (a(i) == 1) countOf1s\
    \ += 1\n            else countOf2s += 1\n        }\n        result += countOf0s\
    \ * (countOf0s - 1) * (countOf0s - 2) / 6\n        result += countOf1s * (countOf1s\
    \ - 1) * (countOf1s - 2) / 6\n        result += countOf2s * (countOf2s - 1) *\
    \ (countOf2s - 2) / 6\n        result += countOf0s * countOf1s * countOf2s\n \
    \       result", "        val mod : Long = n % 3\n        if (mod == 0) {\n  \
    \          val ans : Long = n * (n - 1) * (n - 2) / 6\n            return ans\n\
    \        }\n        if (mod == 1) {\n            val ans : Long = (n - 1) * (n\
    \ - 2) * (n - 3) / 6\n            return ans\n        }\n        val ans : Long\
    \ = (n - 1) * (n - 2) * (n - 4) / 6\n        return ans", "        // The formula\
    \ for the sum of arithmetic progression is given by:\n        // S_n = (a_1 +\
    \ a_n) * n / 2\n        // a_1 = first term\n        // a_n = last term\n    \
    \    // n = number of terms\n        // S_n = sum of terms\n        // So, the\
    \ number of terms in the arithmetic progression, n is given by:\n        // n\
    \ = 2 * S_n / (a_1 + a_n)\n        // So, the number of triples is:\n        //\
    \ n * (n - 1) * (n - 2) / 6\n        // Which is equivalent to:\n        // n\
    \ * (n - 1) * (n - 2) / (n * (n - 1) / 2)\n        // So, the number of triples\
    \ is:\n        // (n - 2) / 3\n        val firstTerm = 1l\n        val lastTerm\
    \ = (n * n - n + 1)\n        val sum = (firstTerm + lastTerm) * n / 2\n      \
    \  val numOfTerms = 2 * sum / (firstTerm + lastTerm)\n        (numOfTerms - 2)\
    \ / 3", "        var triplets = 0l\n        val s = new Array[Long](n.toInt +\
    \ 1)\n        for (i <- 1 to n.toInt) s(i) = i * i - i + 1\n        for (i <-\
    \ 1 to n.toInt - 2) {\n            var j = i + 1\n            while (j <= n.toInt\
    \ - 1) {\n                var sum = s(i) + s(j)\n                var k = j + 1\n\
    \                while (k <= n.toInt && sum + s(k) <= s(n.toInt)) {\n        \
    \            if ((sum + s(k)) % 3 == 0) triplets += 1\n                    k +=\
    \ 1\n                }\n                j += 1\n            }\n        }\n   \
    \     triplets", "        // Write your code here\n        return 0l", "     \
    \   val a = new Array[Long](n.toInt)\n        for (i <- 1 to n.toInt) {\n    \
    \        a(i - 1) = i * i - i + 1\n        }\n        var c = 0l\n        for\
    \ (i <- 0 to n.toInt - 3) {\n            for (j <- i + 1 to n.toInt - 2) {\n \
    \               for (k <- j + 1 to n.toInt - 1) {\n                    if ((a(i)\
    \ + a(j) + a(k)) % 3 == 0) {\n                        c += 1\n               \
    \     }\n                }\n            }\n        }\n        c", "        //\
    \ See discussions in https://codeforces.com/blog/entry/12348\n        // 1. For\
    \ 0 \u2264 i \u2264 n, b[i] = the number of a[j]s that make a[i] + a[j] divisible\
    \ by 3.\n        //    Since a[i] + a[j] = i\xB2 - i + 1 + j\xB2 - j + 1 = (i\
    \ + j)\xB2 - (i + j) + 2, \n        //    so a[i] + a[j] is divisible by 3 iff\
    \ i + j is divisible by 3.\n        //    Thus b[i] = (1 + 2 * (n - 1) / 3) when\
    \ i is divisible by 3, and\n        //               (2 * (n - 1) / 3) otherwise.\n\
    \        // 2. The number of valid triples is sum(b[i] * b[j]) for 1 \u2264 i\
    \ < j \u2264 n.\n        //    So the answer is 2 * n * (n - 1) / 3 - n * (n -\
    \ 1) / 2 + n.\n        // For example:\n        // a = [1, 3, 7, 13, 21]\n   \
    \     // b = [2, 4, 3, 3, 2]\n        // sum(b[i] * b[j]) = \n        //     b[1]\
    \ * b[2] + b[1] * b[3] + b[1] * b[4] + b[1] * b[5] +\n        //     b[2] * b[3]\
    \ + b[2] * b[4] + b[2] * b[5] +\n        //     b[3] * b[4] + b[3] * b[5] +\n\
    \        //     b[4] * b[5] =\n        //     2 * 4 + 2 * 3 + 2 * 3 + 2 * 2 +\n\
    \        //     4 * 3 + 4 * 3 + 4 * 2 +\n        //     3 * 3 + 3 * 2 +\n    \
    \    //     3 * 2 =\n        //     16 + 12 + 12 + 4 +\n        //     12 + 12\
    \ + 8 +\n        //     9 + 6 +\n        //     6 =", "        val a = new Array[Long](n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            a(i) = i * i - i + 1\n    \
    \    }\n        println(a.toList)\n        var ans = 0l\n        for (i <- 0 until\
    \ n.toInt - 2) {\n            for (j <- i + 1 until n.toInt - 1) {\n         \
    \       for (k <- j + 1 until n.toInt) {\n                    if ((a(i) + a(j)\
    \ + a(k)) % 3 == 0) ans += 1\n                }\n            }\n        }\n  \
    \      ans", '        ???', "        // Let S be the sum of the all the elements\
    \ in the list a, \n        // then the number of tuples (a[i], a[j], a[k]) where\
    \ a[i] + a[j] + a[k] is a multiple of 3\n        // is approximately S / 3.\n\
    \        // The approximation is a rough estimate as we will see later.\n    \
    \    // A list of squares will have a sum approximately equal to \n        //\
    \ S = n * (n + 1) * (2n + 1) / 6, which is n^3 / 3.\n        // 3 * S / n^3 is\
    \ the approximation.\n        // The problem is to find all tuples for which the\
    \ sum is a multiple of 3, \n        // but is not an exact multiple of 3.\n  \
    \      // Such a triple is of the form (x * x - x + 1, x * x + 1, y * y + y +\
    \ 1), where x and y are\n        // both non-zero integers.\n        // Because\
    \ x * x - x + 1 + x * x + 1 + y * y + y + 1 = 3 * x * x + 3 * y * y + 4 * x +\
    \ 4 * y + 3\n        // = 3 * (x * x + y * y + x + y) + 1, the sum is a multiple\
    \ of 3 only if 3 divides x * x + y * y + x + y,\n        // and x * x + y * y\
    \ + x + y is not divisible by 3.\n        // From these observations, we can see\
    \ that the problem is equivalent to finding the number of\n        // pairs (x,\
    \ y) of non-zero integers such that x * x + y * y + x + y is not divisible by\
    \ 3, but\n        // 3 divides x * x + y * y + x + y.\n        // We use a quadratic\
    \ equation to solve this.\n        // In particular, if we want to find the number\
    \ of triples for some n, then we need to find the number\n        // of pairs\
    \ (x, y) of non-zero integers, such that 3 divides x * x + y * y + x + y, but\
    \ x * x + y * y + x + y\n        // is not divisible by 3.\n        // For the\
    \ pair", "    \tvar total = 0l\n    \tfor (i <- 1l to n - 2) {\n    \t\tfor (j\
    \ <- i + 1l to n - 1) {\n    \t\t\tfor (k <- j + 1l to n) {\n    \t\t\t\tif ((i\
    \ * i - i + 1) + (j * j - j + 1) + (k * k - k + 1) % 3 == 0) total += 1\n    \t\
    \t\t}\n    \t\t}\n    \t}\n    \ttotal", "        val m = min(9l, n)\n       \
    \ if (n % 3 == 0) m * m\n        else if (n % 3 == 1) (m - 2) * (m - 2)\n    \
    \    else (m - 4) * (m - 4)", "        val a = Array.fill(n.toInt)(0)\n      \
    \  var total = 0\n        for (i <- 1 to n.toInt) {\n            a(i - 1) = i\
    \ * i - i + 1\n            for (j <- i + 1 to n.toInt) {\n                for\
    \ (k <- j + 1 to n.toInt) {\n                    if ((a(i - 1) + a(j - 1) + a(k\
    \ - 1)) % 3 == 0) {\n                        total += 1\n                    }\n\
    \                }\n            }\n        }\n        total", "        val a =\
    \ new Array[Long](n.toInt)\n        for (i <- 1 to n.toInt) {\n            a(i\
    \ - 1) = (i * i - i + 1).toLong\n        }\n        var count = 0\n        for\
    \ (i <- 0 to n.toInt - 3) {\n            for (j <- i + 1 to n.toInt - 2) {\n \
    \               for (k <- j + 1 to n.toInt - 1) {\n                    if ((a(i)\
    \ + a(j) + a(k)) % 3 == 0) count += 1\n                }\n            }\n    \
    \    }\n        count", "        var sum = 0l\n        var arr = ArrayBuffer[Long]()\n\
    \        for (i <- 1l to n) {\n            var temp = (i * i) - i + 1\n      \
    \      sum += temp\n            arr += temp\n        }\n        var result = 0l\n\
    \        for (i <- 0l until n - 2) {\n            for (j <- i + 1l until n - 1)\
    \ {\n                if ((sum - arr(i.toInt) - arr(j.toInt)) % 3 == 0) result\
    \ += 1\n            }\n        }\n        result", "        val a = Array.tabulate(n.toInt)(i\
    \ => i * i - i + 1)\n        a.map(x => (x, (1 to n.toInt).filter(y => x + y *\
    \ y - y + 1 < a(n.toInt - 1)).count(y => (x + y * y - y + 1) % 3 == 0))).map(x\
    \ => x._2 * (x._2 - 1) / 2).sum", "        var s = new Array[Int](3)\n       \
    \ var k = 1\n        var p = 0\n        while (k <= n) {\n            s(p) = (k\
    \ * k - k + 1) % 3\n            k += 1\n            p = (p + 1) % 3\n        }\n\
    \        var c = 0l\n        if (s(0) == 0) c += 1\n        if (s(1) == 0) c +=\
    \ 1\n        if (s(2) == 0) c += 1\n        c += s(0) * (s(0) - 1) / 2\n     \
    \   c += s(1) * (s(1) - 1) / 2\n        c += s(2) * (s(2) - 1) / 2\n        c\
    \ += s(0) * s(1) * s(2)\n        c", "        var count = 0l\n        for (j <-\
    \ 1 to n.toInt - 2) {\n            for (k <- j + 1 to n.toInt - 1) {\n       \
    \         val sum = j * j - j + 1 + k * k - k + 1\n                if (sum % 3\
    \ == 0) count += n.toInt - k\n            }\n        }\n        count", "    \
    \    val c = new Array[Long](3)\n        val a = new Array[Long](n.toInt)\n  \
    \      for (i <- 0 until n.toInt) a(i) = i * i - i + 1\n        for (i <- 0 until\
    \ n.toInt) c(a(i).toInt % 3) += 1\n        val result = c(0) * (c(0) - 1) * (c(0)\
    \ - 2) / 6\n        result + c(1) * c(2) * (c(1) - 1) / 2 + c(2) * c(1) * (c(2)\
    \ - 1) / 2\n        result.toLong", "        val b = Buffer[Long]()\n        for\
    \ (i <- 1l to n) {\n            b += i * i - i + 1\n        }\n        b.sorted.filter(x\
    \ => (x * 3) % 2 == 0).size", "        // First, we build a list with n elements:\
    \ a[i] = i * i - i + 1\n        // Then, we build a list with all the possible\
    \ sums of three indices of the first list.\n        // Finally, we count the number\
    \ of sums that are multiples of 3, and output the result.\n        //\n      \
    \  // To build the list of sums, we iterate over all possible pairs (i, j) of\
    \ indices, and then \n        // we look for all indices k that satisfy the inequality\
    \ k > i and k > j. This is necessary to \n        // prevent double counting the\
    \ triples (i, j, k) and (k, i, j).\n        val l = ArrayBuffer[Long]()\n    \
    \    for (i <- 0l until n) l += i * i - i + 1\n        val sums = ArrayBuffer[Long]()\n\
    \        for (i <- 0l until n) for (j <- i + 1l until n) {\n            for (k\
    \ <- j + 1l until n) {\n                sums += l(i.toInt) + l(j.toInt) + l(k.toInt)\n\
    \            }\n        }\n        // Filter out the sums that are multiple of\
    \ 3, and count them.\n        sums.filter(_ % 3 == 0).length", "        val l\
    \ = (n + 1) / 2\n        val u = n - l\n        val ln = (l + 1) * l / 2\n   \
    \     val un = (u + 1) * u / 2\n        ln * u + un * l", '        return 0l',
  "        //2 - 15 : List[Long] = List(3, 5, 11, 21, 39, 69, 121, 203, 323, 489,\
    \ 711, 979, 1281, 1611, 1973)\n        //15 - 25 : List[Long] = List(2043, 2431,\
    \ 2839, 3267, 3711, 4171, 4647, 5139, 5647, 6171, 6711, 7267, 7839, 8427, 9029,\
    \ 9647)\n        //25 - 30 : List[Long] = List(10281, 10921, 11577, 12247, 12931,\
    \ 13629, 14341, 15067, 15807, 16561, 17331, 18111, 18907, 19717, 20541, 21379,\
    \ 22231, 23097, 23977, 24871, 25779, 26701, 27637, 28587, 29551, 30529, 31521)\n\
    \        //The following is a brute force approach, which will not work for large\
    \ n.\n        // var max = 0\n        // val a = Array.fill(n.toInt)(0)\n    \
    \    // for (i <- 0 until n.toInt) a(i) = i * i - i + 1\n        // for (i <-\
    \ 0 until n.toInt) {\n        //     for (j <- i + 1 until n.toInt) {\n      \
    \  //         for (k <- j + 1 until n.toInt) {\n        //             if ((a(i)\
    \ + a(j) + a(k)) % 3 == 0) max += 1\n        //         }\n        //     }\n\
    \        // }\n        // max\n        //The following approach is optimal:\n\
    \        //The sum of three numbers modulo 3 is equal to the sum of each modulo\
    \ 3.\n        //  mod3 = 0 : 0, 3, 6, 9, ...\n        //  mod3 = 1 : 1, 4, 7,\
    \ 10, ...\n        //  mod3 = 2 : 2, 5, 8, 11, ...\n        //The number of mod3\
    \ = 0 elements is 1 + (n - 1) / 3,\n        //  the number of mod3 = 1 elements\
    \ is 1 + (n - 1) / 3,\n        //  the number of mod3 =", "    \tval modulo :\
    \ Long = 1000000007l\n    \tval answers : Array[Long] = Array.fill(3)(0l)\n  \
    \  \tvar combinatorics : List[List[Long]] = List()\n    \tfor (i <- 1l to n -\
    \ 2l) {\n    \t\tvar count : Long = 0l\n    \t\tvar j : Long = 1l\n    \t\twhile\
    \ (j <= i) {\n    \t\t\tcount += 1l\n    \t\t\tj += 1l\n    \t\t}\n    \t\tj =\
    \ i + 1l\n    \t\twhile (j <= n - 1l) {\n    \t\t\tcount += 1l\n    \t\t\tj +=\
    \ 1l\n    \t\t}\n    \t\tcombinatorics ::= List(i, count)\n    \t}\n    \tfor\
    \ (List(i, count) <- combinatorics) {\n    \t\tval div : Long = i / 3l\n    \t\
    \tval mod : Long = i % 3l\n    \t\tanswers(mod.toInt) += count\n    \t\tif (mod\
    \ == 0l) answers(0) -= div\n    \t\telse answers(3 - mod.toInt) -= div\n    \t\
    }\n    \tval answer : Long = (answers(0) * (answers(0) - 1l) * (answers(0) - 2l)\
    \ / 6l + \n    \t\tanswers(1) * (answers(1) - 1l) * answers(2) / 2l + answers(2)\
    \ * (answers(2) - 1l) * answers(1) / 2l) % modulo\n    \tanswer", "        val\
    \ a = new Array[Long](n.toInt)\n        for (i <- 1 to n.toInt) {\n          \
    \  a(i - 1) = i * i - i + 1\n        }\n        var cnt = 0l\n        for (i <-\
    \ 0 to n.toInt - 3) {\n            for (j <- i + 1 to n.toInt - 2) {\n       \
    \         for (k <- j + 1 to n.toInt - 1) {\n                    if ((a(i) + a(j)\
    \ + a(k)) % 3 == 0) cnt += 1\n                }\n            }\n        }\n  \
    \      cnt", '        return 0;', "        val modulo = 3\n        val a = new\
    \ Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) a(i) = i * i - i +\
    \ 1\n        val sums = new Array[Long](modulo)\n        for (i <- 0 until n.toInt)\
    \ sums(a(i).toInt % modulo) += 1\n        val b = sums(0) * sums(0) - sums(0)\n\
    \        val c = sums(1) * sums(2) - sums(1) - sums(2)\n        return b + c",
  "        val a = Array.fill(n.toInt)(1l)\n        for (i <- 1 until n.toInt) {\n\
    \            a(i) = i * i - i + 1\n        }\n        var count = 0l\n       \
    \ for (i <- 0 until n.toInt - 2) {\n            for (j <- i + 1 until n.toInt\
    \ - 1) {\n                for (k <- j + 1 until n.toInt) {\n                 \
    \   if ((a(i) + a(j) + a(k)) % 3 == 0) {\n                        count += 1\n\
    \                    }\n                }\n            }\n        }\n        count",
  "        (1l to n).foldLeft(0l)((acc, x) => {\n            val a = x * x - x + 1\n\
    \            acc + (1l to x - 1).count((y) => {\n                (y * y - y +\
    \ 1 + a) % 3 == 0 && (n - y) % 3 == 0\n            })\n        })", "        val\
    \ a = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) a(i) = i *\
    \ i - i + 1\n        val b = new Array[Array[Long]](3)\n        for (i <- 0 until\
    \ 3) b(i) = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt) b(a(i).toInt\
    \ % 3)(i) = a(i)\n        var total = 0l\n        for (i <- 0 until 3) {\n   \
    \         var current = 0l\n            for (j <- 0 until n.toInt) {\n       \
    \         current += b(i)(j)\n                total += current\n            }\n\
    \        }\n        total", "        var count = 0l\n        var list = List[Int]()\n\
    \        for (i <- 1 to n.toInt) {\n            list = (i * i - i + 1) :: list\n\
    \        }\n        for (i <- 0 to n.toInt - 3) {\n            for (j <- i + 1\
    \ to n.toInt - 2) {\n                for (k <- j + 1 to n.toInt - 1) {\n     \
    \               if ((list(i) + list(j) + list(k)) % 3 == 0) {\n              \
    \          count += 1\n                    }\n                }\n            }\n\
    \        }\n        return count", "        val a = new Array[Long](n.toInt +\
    \ 1)\n        for (i <- 1 to n.toInt) a(i) = i * i - i + 1\n        var count\
    \ = 0l\n        for (i <- 1 to n.toInt - 2) {\n            for (j <- i + 1 to\
    \ n.toInt - 1) {\n                for (k <- j + 1 to n.toInt) {\n            \
    \        if ((a(i) + a(j) + a(k)) % 3 == 0) count += 1\n                }\n  \
    \          }\n        }\n        count", '        n.toLong - (n - 1) / 3 - (n
    - 1) / 2', "        // My Solution\n        val lst = (1l to n).map(x => x * x\
    \ - x + 1).toList\n        val triples = for {i <- 0 to lst.length - 3; j <- i\
    \ + 1 to lst.length - 2; k <- j + 1 to lst.length - 1} yield (lst(i), lst(j),\
    \ lst(k))\n        triples.filter(x => (x._1 + x._2 + x._3) % 3 == 0).length.toLong",
  "        // We use the fact that i < j < k, \n        // and a[i] + a[j] + a[k]\
    \ is a multiple of 3 iff a[i] + a[j] + a[k] == a[i] + a[j] + a[i + 1]\n      \
    \  // We also use the fact that i < j < k iff j - i > 1 and k - j > 1\n      \
    \  // Then we have that the number of triples is\n        // n(n - 1)(n - 2) -\
    \ (n - 1)(n - 2)(n - 3) + (n - 2)(n - 3)(n - 4)\n        // = n(n - 1)(n - 2)\
    \ - (n - 1)(n - 2)(n - 3)\n        val mod = 1000000007l\n        def getMaxTriplesHelper(n\
    \ : Long, acc : Long) : Long = {\n            if (n == 1) acc\n            else\
    \ getMaxTriplesHelper(n - 1, (acc + n * (n - 1) * (n - 2)) % mod)\n        }\n\
    \        getMaxTriplesHelper(n, 0)", "\t\t// Your Code Here\n\t\t0l", "      \
    \  var res = 0l\n        val a = Array.fill(n.toInt)(0l)\n        for (i <- 0\
    \ until n.toInt) a(i) = i * i - i + 1\n        for (i <- 0 until n.toInt - 2)\n\
    \            for (j <- i + 1 until n.toInt - 1)\n                for (k <- j +\
    \ 1 until n.toInt)\n                    if ((a(i) + a(j) + a(k)) % 3 == 0) res\
    \ += 1\n        res", "        val a = new Array[Long](n.toInt)\n        var i\
    \ = 0\n        for (i <- 0 until n.toInt) {\n            a(i) = i * i - i + 1\n\
    \        }\n        var count = 0\n        for (i <- 0 until n.toInt) {\n    \
    \        for (j <- i + 1 until n.toInt) {\n                for (k <- j + 1 until\
    \ n.toInt) {\n                    if ((a(i) + a(j) + a(k)) % 3 == 0) {\n     \
    \                   count += 1\n                    }\n                }\n   \
    \         }\n        }\n        count", "    \tval a = new Array[Long](n.toInt\
    \ + 1)\n    \tval b = new Array[Long](n.toInt + 1)\n    \tval c = new Array[Long](n.toInt\
    \ + 1)\n    \tfor (i <- 1 to n.toInt) {\n    \t\ta(i) = (i * i - i + 1) % 3\n\
    \    \t\tb(i) = (b(i - 1) + a(i)) % 3\n    \t\tc(i) = (c(i - 1) + (if (b(i) ==\
    \ 0) 1 else 0))\n    \t}\n    \tvar result = 0l\n    \tfor (i <- 1 to n.toInt)\
    \ {\n    \t\tresult += (if (a(i) == 0) c(i - 1) else 0)\n    \t}\n    \tresult",
  "        val k = n / 3\n        k * (k + 1) / 2", "    \t// the sum of 1,3,5,...,(2n-1)\
    \ is 3n(n-1)/2\n    \t// the sum of n, n+2, n+4, ..., 2n-2 is n(n-1)\n    \t//\
    \ therefore a[i] + a[j] + a[k] must be a multiple of 3\n    \t// iff i, j, k must\
    \ be all even or all odd\n    \tvar pairs = ArrayBuffer[Int]()\n    \tvar cur\
    \ = 1\n    \twhile (cur <= n) {\n    \t\tif (cur % 2 == 0) pairs += cur\n    \t\
    \tcur += 1\n    \t}\n    \tval res = ((pairs.length - 1) * pairs.length) / 2\n\
    \    \tres", "        // 2 0 1 5 4\n        val a = (1 to n.toInt).map(x => ((x\
    \ * x) - x + 1) % 3).toList\n        // 1 0 0 1 0\n        val d = Array.fill(3)(0)\n\
    \        for (x <- a) d(x) += 1\n        // List(1, 0, 0, 1, 0)\n        val t\
    \ = for (x <- d) yield ((2 * x * (x - 1)) / 2)\n        // List(1, 0, 0, 1, 0)\n\
    \        (t(0) * t(1) * t(2)) + (t(0) * t(3) * t(3)) + (t(2) * t(1) * t(3))",
  '        return 0l', "    \tval list = for (i <- 1l to n) yield i * i - i + 1\n\
    \    \tval count = for (i <- 0 until list.length; j <- (i + 1) until list.length;\
    \ k <- (j + 1) until list.length) yield if ((list(i) + list(j) + list(k)) % 3\
    \ == 0) 1 else 0\n    \tcount.sum", "        val a = Array.tabulate(n.toInt)(x\
    \ => x * x - x + 1)\n        var max = 0l\n        for (i <- 0 until n.toInt -\
    \ 2) {\n            for (j <- i + 1 until n.toInt - 1) {\n                if ((a(i)\
    \ + a(j)) % 3 == 0) {\n                    for (k <- j + 1 until n.toInt) {\n\
    \                        if ((a(i) + a(j) + a(k)) % 3 == 0) max += 1\n       \
    \             }\n                }\n            }\n        }\n        max", " \
    \       val a = Array.tabulate(n.toInt)(i => i * i - i + 1)\n        return a.combinations(3).map(c\
    \ => c.sum).count(_ % 3 == 0)", '        return 0l', "        val mod3 = n % 3\n\
    \        val m = if (mod3 == 0) n / 3 else (n - mod3) / 3\n        return m *\
    \ (m + 1) / 2", "    \tval m = new Array[Long](n.toInt)\n    \tfor (i <- 1 to\
    \ n.toInt) {\n    \t\tm(i - 1) = i * i - i + 1\n    \t}\n    \tval s = new Array[Long](3)\n\
    \    \tvar r = 0\n    \tfor (i <- 0 to n.toInt - 3) {\n    \t\tfor (j <- i + 1\
    \ to n.toInt - 2) {\n    \t\t\tfor (k <- j + 1 to n.toInt - 1) {\n    \t\t\t\t\
    s(0) = m(i)\n    \t\t\t\ts(1) = m(j)\n    \t\t\t\ts(2) = m(k)\n    \t\t\t\tif\
    \ (s.sum % 3 == 0) r += 1\n    \t\t\t}\n    \t\t}\n    \t}\n    \tr", "      \
    \  val a = new Array[Long](n.toInt)\n        for (i <- 1 to n.toInt) a(i - 1)\
    \ = i * i - i + 1\n        var r = 0l\n        for (i <- 0 to n.toInt - 3) {\n\
    \            val sum = a(i)\n            for (j <- i + 1 to n.toInt - 2) {\n \
    \               if ((sum + a(j)) % 3 == 0) {\n                    for (k <- j\
    \ + 1 to n.toInt - 1) {\n                        if ((sum + a(j) + a(k)) % 3 ==\
    \ 0) r += 1\n                    }\n                }\n            }\n       \
    \ }\n        r", "        var result = 0l\n        val mod3 = (1l to n).map {_\
    \ * _ - _ + 1}.filter {_ % 3 == 0}.groupBy {_ % 3}\n        val lst1 = mod3.getOrElse(1,\
    \ List())\n        val lst2 = mod3.getOrElse(2, List())\n        if (lst1.size\
    \ >= 2) {\n            result += lst1.combinations(2).count {p => p(0) + p(1)\
    \ + lst2.find{p(0) + p(1) + _ == 0}.getOrElse(0) == 0}\n        }\n        if\
    \ (lst2.size >= 2) {\n            result += lst2.combinations(2).count {p => p(0)\
    \ + p(1) + lst1.find{p(0) + p(1) + _ == 0}.getOrElse(0) == 0}\n        }\n   \
    \     if (lst1.size >= 1 && lst2.size >= 1) {\n            result += lst1.map\
    \ {i => lst2.count {j => j + i + lst1.find{i + j + _ == 0}.getOrElse(0) == 0}}.sum\n\
    \        }\n        result", "        val a = new Array[Long](n.toInt)\n     \
    \   var cnt = 0\n        for (i <- 0 until n.toInt) {\n            a(i) = i *\
    \ i - i + 1\n            for (j <- i + 1 until n.toInt) {\n                for\
    \ (k <- j + 1 until n.toInt) {\n                    if ((a(i) + a(j) + a(k)) %\
    \ 3 == 0) cnt += 1\n                }\n            }\n        }\n        cnt",
  "        // Your code goes here\n        return 0l", "        // We have to find\
    \ the number of triplets (i, j, k) that satisfy the\n        // following conditions:\n\
    \        // 1. 1 \u2264 i < j < k \u2264 n\n        // 2. a[i] + a[j] + a[k] \u2261\
    \ 0 (mod 3)\n        // 3. 1 \u2264 a[i] < a[j] < a[k] \u2264 n\xB2.\n       \
    \ // According to the given conditions, we have that\n        // a[i] = i * i\
    \ - i + 1,\n        // so we have that\n        // a[i] \u2264 n\xB2,\n      \
    \  // a[i] = i * i - i + 1 = (i - 1) * i + 1.\n        // Since a[i] > a[i - 1],\
    \ then\n        // i > 1 + a[i - 1].\n        // So we have that\n        // a[i]\
    \ = (i - 1) * i + 1 > a[i - 1] + 1\n        // (i - 1) * i > a[i - 1]\n      \
    \  // i * i - i > a[i - 1] - i\n        // i * i > a[i - 1]\n        // (i - 1)\xB2\
    \ + (i - 1) + 1 > a[i - 1]\n        // (i - 1)\xB2 + i > a[i - 1]\n        //\
    \ i\xB2 - 2i + 1 + i > a[i - 1]\n        // i\xB2 - i > a[i - 1]\n        // i\
    \ * i - i > a[i - 1]\n        // a[i] = i * i - i + 1 > a[i - 1] + 1\n       \
    \ // a[i] > a[i - 1] + 1\n        // a[i] - a[i - 1] > 1\n        // a[i] - 1\
    \ > a[i - 1]\n        // Now we can form the inequality\n        // a[i] + a[j]\
    \ + a[k] > a[i - 1] + a[j - 1] + a[k - 1] + 3\n        // a[i] + a[j] + a[k] >\
    \ (a[i - 1] + a[", "        // O(n^3) - time, O(1) - space\n        var cnt =\
    \ 0l\n        var i = 1l\n        while (i <= n) {\n            var j = i + 1\n\
    \            while (j <= n) {\n                var k = j + 1\n               \
    \ while (k <= n) {\n                    if ((i * i - i + 1 + j * j - j + 1 + k\
    \ * k - k + 1) % 3 == 0) cnt += 1\n                    k += 1\n              \
    \  }\n                j += 1\n            }\n            i += 1\n        }\n \
    \       cnt", "        val a = (1l to n).map(x => x * x - x + 1).toList\n    \
    \    return (for (i <- 1l to n; j <- i + 1l to n; k <- j + 1l to n) yield (a(i.toInt\
    \ - 1) + a(j.toInt - 1) + a(k.toInt - 1))).count(_ % 3 == 0)", "        val upperBound\
    \ : Long = n * n - n + 1\n        val dp : Array[Long] = new Array[Long](upperBound.toInt\
    \ + 1)\n        for (i <- 1 to n.toInt) {\n            val v : Long = i * i -\
    \ i + 1\n            for (d <- 1 to v) {\n                if (v + d <= upperBound)\
    \ dp(v.toInt) += 1\n                if (v - d >= 1) dp(v.toInt) += 1\n       \
    \     }\n        }\n        var result : Long = 0\n        for (i <- 1 to n.toInt)\
    \ {\n            val v : Long = i * i - i + 1\n            for (j <- i + 1 to\
    \ n.toInt) {\n                val w : Long = j * j - j + 1\n                if\
    \ ((v + w) % 3 == 0) {\n                    result += dp(w.toInt)\n          \
    \      }\n            }\n        }\n        result", "        // 1 \u2264 n \u2264\
    \ 10^12\n        // 1 \u2264 a[i] \u2264 10^18\n        // 3 * 10^12 * 10^18 *\
    \ 3 * 10^18 * 3 * 10^18 * 3 * 10^18 * 3 * 10^18 * 3 * 10^18 * 2 * 10^18 * 2 *\
    \ 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18\
    \ * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2\
    \ * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18\
    \ * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2\
    \ * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18\
    \ * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2\
    \ * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18\
    \ * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2\
    \ * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18\
    \ * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2\
    \ * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18 * 2 * 10^18\
    \ * 2 * 10^18 * 2 *", "        // We have to find for each i and j, how many valid\
    \ k, \n        // such that i < j < k, and a[i] + a[j] + a[k] is a multiple of\
    \ 3.\n        // We can use cumulative sum for this purpose.\n        // Let us\
    \ suppose that we have computed for each i and j, the number of valid k.\n   \
    \     // For each new j, we have to find the number of valid k.\n        // We\
    \ can use the fact that a[i] + a[j] + a[k] = 3 * k - (i + j).\n        // So,\
    \ for each j, we will find the index i < j, \n        // such that a[i] + a[j]\
    \ + a[k] = 3 * k - (i + j) is a multiple of 3.\n        // In this way, we will\
    \ find the number of valid k.\n        // \n        // \n        // Let us find\
    \ how many times a number i appear in the array a,\n        // such that a[i]\
    \ + a[j] + a[k] = 3 * k - (i + j) is a multiple of 3.\n        val a = Array.fill(n.toInt)((1,\
    \ 0l))\n        for (i <- 1 until n.toInt) {\n            a(i) = (i * i - i +\
    \ 1, a(i - 1)._2 + i * i - i + 1)\n        }\n        var ans = 0l\n        for\
    \ (j <- 2 until n.toInt) {\n            val x = 3 * j - a(j)._2\n            var\
    \ l = 0\n            var r = j - 1\n            while (l <= r) {\n           \
    \     val mid = (l + r) / 2\n                if (x < a(mid)._2) r = mid - 1\n\
    \                else if (x > a(mid)._2) l = mid + 1\n                else {\n\
    \                    l = mid\n                    break\n                }\n \
    \           }\n            ans += l\n        }\n        ans"]
stop_tokens:
- "\n    }\n"
