language: scala
name: HumanEval_73_smallest_change
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // We use a dynamic programming approach. Let arr = (x1,\
    \ x2, ..., xn) be the list of numbers.\n        // Let dp(i, j) = the number of\
    \ changes needed to make the sublist (xi, xi+1, ..., xj)\n        // a palindrome.\
    \ Then\n        // dp(i, j) = min(dp(i+1, j), dp(i, j-1)) + 1 if xi != xj, 0 if\
    \ xi == xj.\n        val n = arr.length\n        val dp = Array.ofDim[Long](n,\
    \ n)\n        for (i <- 0 until n; j <- 0 until n) {\n            dp(i)(j) = -1\n\
    \        }\n        def smallestChangeHelper(i : Int, j : Int) : Long = {\n  \
    \          if (dp(i)(j) != -1) dp(i)(j)\n            else if (i > j) 0\n     \
    \       else if (i == j) 0\n            else if (i + 1 == j) if (arr(i) == arr(j))\
    \ 0 else 1\n            else {\n                val res = min(smallestChangeHelper(i\
    \ + 1, j), smallestChangeHelper(i, j - 1)) + 1\n                dp(i)(j) = res\n\
    \                res\n            }\n        }\n        smallestChangeHelper(0,\
    \ n - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqelc8tuh.scala:38)\n\tat Problem.main(tmpqelc8tuh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length % 2 == 0) {\n            val (firstHalf,\
    \ secondHalf) = arr.splitAt(arr.length / 2)\n            val changes = firstHalf.zip(secondHalf.reverse).map(a\
    \ => abs(a._1 - a._2))\n            changes.sum\n        } else {\n          \
    \  val (firstHalf, secondHalf) = arr.splitAt(arr.length / 2)\n            val\
    \ changes = firstHalf.zip(secondHalf.tail.reverse).map(a => abs(a._1 - a._2))\n\
    \            changes.sum\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3totmhpw.scala:26)\n\tat Problem.main(tmp3totmhpw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var count = 0\n        val arrLength = arr.length\n    \
    \    val midPoint = floor(arrLength / 2.0).toInt\n        for (i <- 0 until midPoint)\
    \ {\n            if (arr(i) != arr(arrLength - 1 - i)) count += 1\n        }\n\
    \        return count\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010076
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var cnt = 0l.toLong\n        var list = arr\n        var\
    \ list2 = arr.reverse\n        for (i <- 0 until (arr.length / 2)) {\n       \
    \     if (list(i) != list2(i)) cnt += 1\n        }\n        return cnt\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        var dp = Array.ofDim[Long](n,\
    \ n)\n        for (len <- 2 to n) {\n            for (start <- 0 to n - len) {\n\
    \                val end = start + len - 1\n                if (arr(start) ==\
    \ arr(end)) dp(start)(end) = dp(start + 1)(end - 1)\n                else dp(start)(end)\
    \ = min(dp(start + 1)(end), dp(start)(end - 1)) + 1\n            }\n        }\n\
    \        return dp(0)(n - 1)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe5j_nifj.scala:27)\n\tat Problem.main(tmpe5j_nifj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val a = Array.ofDim[Long](n\
    \ + 1, n + 1)\n        for (i <- 0 to n) {\n            a(i)(i) = 0\n        }\n\
    \        for (i <- 2 to n) {\n            for (j <- 0 to n - i) {\n          \
    \      val k = j + i - 1\n                a(j)(k) = a(j + 1)(k) + 1\n        \
    \        if (arr(j) == arr(k)) {\n                    a(j)(k) = min(a(j)(k), a(j\
    \ + 1)(k - 1))\n                }\n                for (m <- j + 1 to k - 1) {\n\
    \                    if (arr(m) == arr(k)) {\n                        a(j)(k)\
    \ = min(a(j)(k), a(j)(m - 1) + a(m + 1)(k - 1))\n                    }\n     \
    \           }\n            }\n        }\n        a(0)(n - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp852cvmrd.scala:37)\n\tat Problem.main(tmp852cvmrd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val l = arr.length\n        if (l <= 1) 0\n        else\
    \ {\n            val m = l / 2\n            var minc = m\n            for (i <-\
    \ 0 until l / 2) {\n                var inc = 0\n                for (j <- 0 until\
    \ m) {\n                    if (arr(i + j) != arr(l - 1 - i - j)) inc += 1\n \
    \               }\n                if (inc < minc) minc = inc\n            }\n\
    \            return minc\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzvabn0yl.scala:32)\n\tat Problem.main(tmpzvabn0yl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        ???\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.smallestChange(tmph_tavk_f.scala:15)\n\tat Problem$.main(tmph_tavk_f.scala:18)\n\
    \tat Problem.main(tmph_tavk_f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010076
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val dp = Array.ofDim[Long](n\
    \ + 1, n + 1)\n        def solve(start : Int, end : Int) : Long = {\n        \
    \    if (start > end) return 0l\n            if (dp(start)(end) != 0) return dp(start)(end)\n\
    \            if (start == end) dp(start)(end) = 0l\n            else if (start\
    \ + 1 == end) dp(start)(end) = (if (arr(start) == arr(end)) 0l else 1l)\n    \
    \        else {\n                val prev = solve(start + 1, end - 1)\n      \
    \          if (arr(start) == arr(end)) dp(start)(end) = prev\n               \
    \ else dp(start)(end) = 1l + prev\n            }\n            dp(start)(end)\n\
    \        }\n        solve(0, n - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val L = Array.ofDim[Long](n,\
    \ n)\n        for (i <- 0 until n) {\n            L(i)(i) = 0\n        }\n   \
    \     for (cl <- 2 to n) {\n            for (i <- 0 to n - cl) {\n           \
    \     val j = i + cl - 1\n                if (arr(i) == arr(j)) L(i)(j) = L(i\
    \ + 1)(j - 1)\n                else L(i)(j) = min(L(i)(j - 1), L(i + 1)(j)) +\
    \ 1\n            }\n        }\n        L(0)(n - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptv91nj94.scala:30)\n\tat Problem.main(tmptv91nj94.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010076
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val dp = Array.ofDim[Long](arr.length, arr.length)\n   \
    \     // For each interval\n        (0 until arr.length).foreach(l => (0 until\
    \ arr.length - l).foreach(r => {\n            val dist = (r to r + l).map(i =>\
    \ arr(i)).toSet.size\n            if (l == 0) dp(r)(r) = dist\n            else\
    \ if (l == 1) dp(r)(r + 1) = dist + (if (arr(r) == arr(r + 1)) -1 else 0)\n  \
    \          else dp(r)(r + l) = min(dp(r)(r + l - 1) + dist, dp(r + 1)(r + l) +\
    \ dist)\n        }))\n        dp(0)(arr.length - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnbgxccuo.scala:26)\n\tat Problem.main(tmpnbgxccuo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val buf = arr.to[ListBuffer]\n        val len = buf.length\n\
    \        var cnt = 0l\n        for (i <- 0 until len / 2) {\n            if (buf(i)\
    \ != buf(len - 1 - i)) {\n                cnt += 1\n            }\n        }\n\
    \        cnt\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E056] Syntax Error: /tmp/tmpdqi541t9.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mbuf\e[0m = arr.to[\e[35mListBuffer\e\
    [0m]\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m         \
    \       Missing type parameter for collection.mutable.ListBuffer\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpdqi541t9.scala:19:20 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (buf(i) != buf(len - \e[31m1\e\
    [0m - i)) {\n\e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m\
    \ Found:    (i : Int)\n\e[31m   |\e[0m Required: scala.collection.Factory[Long,\
    \ collection.mutable.ListBuffer]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        var dp = Array.ofDim[Long](len\
    \ + 1, len + 1)\n        // Initialization\n        for (i <- 0 to len) dp(i)(0)\
    \ = dp(0)(i) = 0\n        // Recursion\n        for (i <- 1 to len) {\n      \
    \      for (j <- 1 to len) {\n                if (arr(i - 1) == arr(len - j))\
    \ dp(i)(j) = dp(i - 1)(j - 1)\n                else dp(i)(j) = 1 + min(dp(i -\
    \ 1)(j), dp(i)(j - 1))\n            }\n        }\n        dp(len)(len)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf6ox1e6y.scala:18:39\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m to len) dp(i)(\e[31m0\e[0m) = dp(\e[31m0\e[0m)(i) = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       Found:    Unit\n\e[31m \
    \  |\e[0m                                       Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010076
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val size = arr.size\n        val dp = Array.ofDim[Long](size,\
    \ size)\n        for (i <- 0 until size) dp(i)(i) = 0\n        for (i <- size\
    \ - 1 to 0 by -1; j <- i + 1 until size) dp(i)(j) = min(abs(arr(i) - arr(j)) +\
    \ dp(i + 1)(j - 1), abs(arr(i) - arr(i + 1)) + dp(i + 2)(j))\n        dp(0)(size\
    \ - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 8 out of bounds for length\
    \ 8\n\tat Problem$.smallestChange$$anonfun$2$$anonfun$1(tmpls_0p774.scala:18)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange$$anonfun$2(tmpls_0p774.scala:18)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange(tmpls_0p774.scala:18)\n\
    \tat Problem$.main(tmpls_0p774.scala:22)\n\tat Problem.main(tmpls_0p774.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val l = arr.length\n        if (l % 2 == 0) {\n        \
    \    // even\n            var left = 0\n            var right = l - 1\n      \
    \      var count = 0l\n            while (left < right) {\n                if\
    \ (arr(left) != arr(right)) {\n                    count += 1\n              \
    \  }\n                left += 1\n                right -= 1\n            }\n \
    \           count\n        } else {\n            // odd\n            var left\
    \ = 0\n            var right = l - 1\n            var count = 0l\n           \
    \ while (left < right) {\n                if (arr(left) != arr(right)) {\n   \
    \                 count += 1\n                }\n                left += 1\n \
    \               right -= 1\n            }\n            count\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010076
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def smallestChange0(arr : List[Long], beg : Int, end : Int)\
    \ : Long = {\n            if (beg > end) return 0\n            if (beg == end)\
    \ return 0\n            val arr1 = arr.slice(beg, end + 1)\n            val arr2\
    \ = arr1.reverse\n            if (arr1 == arr2) return 0\n            else {\n\
    \                val min0 = min(smallestChange0(arr, beg + 1, end), smallestChange0(arr,\
    \ beg, end - 1))\n                val min1 = 1 + min(smallestChange0(arr, beg\
    \ + 1, end), smallestChange0(arr, beg, end - 1))\n                min(min0, min1)\n\
    \            }\n        }\n        smallestChange0(arr, 0, arr.length - 1)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvcort1a2.scala:30)\n\tat Problem.main(tmpvcort1a2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def smallestChange(arr : List[Long], start : Int, end :\
    \ Int) : Long = {\n            if (start >= end) 0\n            else {\n     \
    \           if (arr(start) == arr(end)) smallestChange(arr, start + 1, end - 1)\n\
    \                else min(smallestChange(arr, start + 1, end), smallestChange(arr,\
    \ start, end - 1)) + 1\n            }\n        }\n        smallestChange(arr,\
    \ 0, arr.length - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp747n_zqj.scala:25)\n\tat Problem.main(tmp747n_zqj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010076
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arrrev = arr.reverse\n        var cost = 0l\n      \
    \  for (i <- 0 until arr.length) {\n            val j = arr.length - 1 - i\n \
    \           if (arr(i) != arrrev(j)) {\n                cost += 1\n          \
    \  }\n        }\n        cost\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjiwdie2p.scala:26)\n\tat Problem.main(tmpjiwdie2p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010076
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.size\n        val dp = Array.ofDim[Long](m,\
    \ m)\n        for (i <- 0 until m) dp(i)(i) = 0\n        for (l <- 2 to m) {\n\
    \            for (i <- 0 to m - l) {\n                val j = i + l - 1\n    \
    \            dp(i)(j) =\n                    if (arr(i) == arr(j)) dp(i + 1)(j\
    \ - 1)\n                    else 1 + dp(i + 1)(j).min(dp(i)(j - 1))\n        \
    \    }\n        }\n        dp(0)(m - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm2ycc3gu.scala:29)\n\tat Problem.main(tmpm2ycc3gu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = Array.ofDim[Long](n,\
    \ n)\n        for (len <- 1 to n) {\n            for (i <- 0 to n - len) {\n \
    \               val j = i + len - 1\n                m(i)(j) = min(m(i + 1)(j),\
    \ m(i)(j - 1)) + abs(arr(i) - arr(j))\n            }\n        }\n        m(0)(n\
    \ - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 8\n\tat Problem$.smallestChange$$anonfun$1$$anonfun$1(tmp122x7w1g.scala:20)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange$$anonfun$1(tmp122x7w1g.scala:21)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange(tmp122x7w1g.scala:22)\n\
    \tat Problem$.main(tmp122x7w1g.scala:26)\n\tat Problem.main(tmp122x7w1g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var a = arr.toArray\n        val n = a.length\n        var\
    \ dp = Array.ofDim[Long](n, n)\n        for (diff <- 0 until n) {\n          \
    \  for (i <- 0 until n - diff) {\n                val j = i + diff\n         \
    \       if (i == j) dp(i)(j) = 0\n                else if (i + 1 == j) dp(i)(j)\
    \ = if (a(i) == a(j)) 0 else 1\n                else {\n                    dp(i)(j)\
    \ = dp(i + 1)(j - 1) + (if (a(i) == a(j)) 0 else 2)\n                    for (k\
    \ <- i + 1 until j) dp(i)(j) = min(dp(i)(j), dp(i)(k) + dp(k + 1)(j))\n      \
    \          }\n            }\n        }\n        return dp(0)(n - 1)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxf1avdlf.scala:32)\n\tat Problem.main(tmpxf1avdlf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        var ans = Long.MaxValue\n  \
    \      for (c <- 0 until n) {\n            var cur = 0l\n            for (i <-\
    \ 0 until n) {\n                if (i == c) cur += 0\n                else cur\
    \ += abs(arr(i) - arr(c))\n            }\n            ans = min(ans, cur)\n  \
    \      }\n        ans\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkj6e8xq_.scala:28)\n\tat Problem.main(tmpkj6e8xq_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010076
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val a = arr.toArray\n      \
    \  val dp = Array.ofDim[Long](n, n)\n        for (i <- 0 until n) {\n        \
    \    dp(i)(i) = 0\n            if (i + 1 < n) {\n                dp(i)(i + 1)\
    \ = abs(a(i) - a(i + 1))\n            }\n        }\n        for (s <- 2 until\
    \ n) {\n            for (i <- 0 until n) {\n                val j = i + s\n  \
    \              if (j < n) {\n                    val diff = abs(a(i) - a(j))\n\
    \                    dp(i)(j) = min(dp(i + 1)(j - 1) + diff, min(dp(i + 1)(j)\
    \ + abs(a(i) - a(i + 1)), dp(i)(j - 1) + abs(a(j) - a(j - 1))))\n            \
    \    }\n            }\n        }\n        dp(0)(n - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbiec88w_.scala:36)\n\tat Problem.main(tmpbiec88w_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val lengths = ListBuffer[Int]()\n        for (i <- arr.indices)\
    \ {\n            var length = 0\n            val (left, right) = arr.splitAt(i)\n\
    \            length += left.reverse.zip(right).filter(x => x._1 != x._2).length\n\
    \            val (leftRight, rightRight) = arr.splitAt(i + 1)\n            length\
    \ += leftRight.reverse.zip(rightRight).filter(x => x._1 != x._2).length\n    \
    \        lengths += length\n        }\n        lengths.min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgyjvdwub.scala:27)\n\tat Problem.main(tmpgyjvdwub.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        // M(i, j) = the minimum number\
    \ of elements that need to be changed in order to make the array from index i\
    \ to index j (inclusive) a palindrome.\n        val M = Array.ofDim[Long](n, n)\n\
    \        // arr(i).toString().length() = the minimum number of digits required\
    \ to represent arr(i) as a decimal integer\n        val digits = Array.ofDim[Int](n)\n\
    \        for (i <- 0 until n) {\n            digits(i) = arr(i).toString().length()\n\
    \            M(i)(i) = 0\n        }\n        for (k <- 1 until n) {\n        \
    \    for (i <- 0 until n - k) {\n                val j = i + k\n             \
    \   if (i == j - 1) {\n                    M(i)(j) = min(digits(i), digits(j))\n\
    \                } else {\n                    val inner = M(i + 1)(j - 1)\n \
    \                   M(i)(j) = min(digits(i) + inner, digits(j) + inner)\n    \
    \            }\n            }\n        }\n        M(0)(n - 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6bz0a64h.scala:39)\n\tat Problem.main(tmp6bz0a64h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val dp = Array.ofDim[Long](arr.length, arr.length)\n   \
    \     for (l <- 1 to arr.length) {\n            for (i <- 0 to arr.length - l)\
    \ {\n                val j = i + l - 1\n                if (i == j) dp(i)(j) =\
    \ 0\n                else if (arr(i) == arr(j)) dp(i)(j) = dp(i + 1)(j - 1)\n\
    \                else dp(i)(j) = min(dp(i + 1)(j), dp(i)(j - 1)) + 1\n       \
    \     }\n        }\n        dp(0)(arr.length - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmporj07hxd.scala:27)\n\tat Problem.main(tmporj07hxd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010086
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // @TODO: Write Code Here\n        return 0\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv57iv2xe.scala:19)\n\tat Problem.main(tmpv57iv2xe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010086
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val dp = Array.ofDim[Long](n,\
    \ n)\n        for (len <- 1 to n) {\n            for (i <- 0 to n - len) {\n \
    \               val j = i + len - 1\n                dp(i)(j) = if (i == j) 0\
    \ else 1 + min(dp(i + 1)(j), dp(i)(j - 1))\n                if (arr(i) == arr(j))\
    \ dp(i)(j) = min(dp(i)(j), dp(i + 1)(j - 1))\n            }\n        }\n     \
    \   dp(0)(n - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 8\n\tat Problem$.smallestChange$$anonfun$1$$anonfun$1(tmpvgm5_6t6.scala:21)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange$$anonfun$1(tmpvgm5_6t6.scala:22)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange(tmpvgm5_6t6.scala:23)\n\
    \tat Problem$.main(tmpvgm5_6t6.scala:27)\n\tat Problem.main(tmpvgm5_6t6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length <= 1) return 0l\n        val rarr = arr.reverse\n\
    \        var sum = 0l\n        for (i <- 0 until arr.length / 2) sum += abs(arr(i)\
    \ - rarr(i))\n        return sum\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7au0ebw7.scala:22)\n\tat Problem.main(tmp7au0ebw7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr1 = arr.toArray\n        var total = 0l\n       \
    \ for (i <- 0 until arr1.length/2) {\n            total += abs(arr1(i) - arr1(arr1.length\
    \ - 1 - i))\n        }\n        total\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp58iokarf.scala:23)\n\tat Problem.main(tmp58iokarf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      val n = arr.length\n      val dp = Array.ofDim[Long](n, n)\n\
    \      for (i <- 0 until n) dp(i)(i) = 0\n      for (len <- 2 to n) {\n      \
    \  for (i <- 0 until n - len + 1) {\n          val j = i + len - 1\n         \
    \ dp(i)(j) = (i, j) match {\n            case (i, j) if i + 1 == j => min(arr(i),\
    \ arr(j))\n            case (i, j) if i + 2 == j => max(arr(i), arr(j))\n    \
    \        case (i, j) => max(arr(i) + min(dp(i + 2)(j), dp(i + 1)(j - 1)), arr(j)\
    \ + min(dp(i + 1)(j - 1), dp(i)(j - 2)))\n          }\n        }\n      }\n  \
    \    dp(0)(n - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgtrld26q.scala:31)\n\tat Problem.main(tmpgtrld26q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010088
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      var numChanges = 0l\n      for (i <- 0 to arr.length / 2)\
    \ {\n        if (arr(i) != arr(arr.length - 1 - i)) numChanges += 1\n      }\n\
    \      numChanges\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxi8p5k97.scala:22)\n\tat Problem.main(tmpxi8p5k97.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      val n = arr.length\n      var dp = Array.ofDim[Long](n, n)\n\
    \      for (i <- (0 until n).reverse) {\n        for (j <- i until n) {\n    \
    \      if (i == j) dp(i)(j) = 0\n          else {\n            dp(i)(j) = dp(i\
    \ + 1)(j - 1) + (if (arr(i) == arr(j)) 0 else 2)\n          }\n        }\n   \
    \   }\n      dp(0)(n - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu4a700__.scala:28)\n\tat Problem.main(tmpu4a700__.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010088
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val dp = Array.ofDim[Long](arr.length, arr.length)\n   \
    \     // base cases\n        for (i <- 0 until arr.length) {\n            dp(i)(i)\
    \ = 0\n            if (i < arr.length - 1) dp(i)(i + 1) = abs(arr(i) - arr(i +\
    \ 1))\n        }\n        // go through all lengths\n        for (l <- 2 until\
    \ arr.length) {\n            // go through all i,j for that length\n         \
    \   for (i <- 0 until arr.length - l) {\n                val j = i + l\n     \
    \           dp(i)(j) = min(dp(i + 1)(j) + abs(arr(i) - arr(i + 1)), dp(i)(j -\
    \ 1) + abs(arr(j) - arr(j - 1)))\n            }\n        }\n        dp(0)(arr.length\
    \ - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq_mol7wj.scala:32)\n\tat Problem.main(tmpq_mol7wj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length == 0) return 0l\n        val reversedArray\
    \ = arr.reverse\n        val n = arr.length\n        var leftIndex = 0\n     \
    \   var rightIndex = 0\n        var count = 0l\n        while (leftIndex < n &&\
    \ rightIndex < n) {\n            if (arr(leftIndex) == reversedArray(rightIndex))\
    \ {\n                leftIndex += 1\n                rightIndex += 1\n       \
    \     } else {\n                count += 1\n                if (arr(leftIndex)\
    \ > reversedArray(rightIndex)) {\n                    leftIndex += 1\n       \
    \         } else {\n                    rightIndex += 1\n                }\n \
    \           }\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5k0e9yf9.scala:37)\n\tat Problem.main(tmp5k0e9yf9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var list = arr.toArray.zipWithIndex\n        var sum = 0\n\
    \        for (i <- 0 until (arr.length + 1) / 2) {\n            if (arr(i) !=\
    \ arr(arr.length - 1 - i)) {\n                sum += 1\n            }\n      \
    \  }\n        return sum\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010088
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n\t\tval n = arr.length\n\t\tvar m = new Array[Long](n + 1)\n\t\t\
    for (i <- 1 to n) {\n\t\t\tvar r = 0l\n\t\t\tvar l = i - 1\n\t\t\twhile (l >=\
    \ 0) {\n\t\t\t\tval t = m(l) + abs(arr(l) - arr(r))\n\t\t\t\tif (l == 0) m(i)\
    \ = t\n\t\t\t\telse m(l) = min(m(l), t)\n\t\t\t\tl -= 1\n\t\t\t\tr += 1\n\t\t\t\
    }\n\t\t}\n\t\tm(n)\n\t}\n}\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4w6hr2p1.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    eof expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp4w6hr2p1.scala:21:32 --------------------\e[0m\e[0m\n\e[31m21 |\e[0m\t\
    \t\t\t\e[33mval\e[0m \e[36mt\e[0m = m(l) + abs(arr(l) - arr(r))\n\e[31m\e[31m\
    \   |\e[0m\t\t\t\t                                ^\e[0m\n\e[31m   |\e[0m\t\t\t\
    \t                                Found:    (r : Long)\n\e[31m   |\e[0m\t\t\t\t\
    \                                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010086
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def swap(arr : List[Long], i : Int, j : Int) : List[Long]\
    \ = {\n            if (i == j) arr\n            else {\n                val temp\
    \ = arr(i)\n                arr(i) = arr(j)\n                arr(j) = temp\n \
    \               arr\n            }\n        }\n        def helper(arr : List[Long],\
    \ i : Int, j : Int, steps : Long) : Long = {\n            if (i >= j) steps\n\
    \            else {\n                if (arr(i) != arr(j)) {\n               \
    \     val index = arr.indexOf(arr(j), i)\n                    if (index != -1)\
    \ helper(swap(arr, i, index), i + 1, j - 1, steps + 1)\n                    else\
    \ -1\n                }\n                else helper(arr, i + 1, j - 1, steps)\n\
    \            }\n        }\n        helper(arr, 0, arr.length - 1, 0)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0okowm0m.scala:19:16 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                arr(i) = arr(j)\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0okowm0m.scala:20:16\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m                arr(j) =\
    \ temp\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        0\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp88bcqc9o.scala:18)\n\tat Problem.main(tmp88bcqc9o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val (first, second) = arr.splitAt(arr.length / 2)\n    \
    \    var answer = 0L\n        if (arr.length % 2 == 0) {\n            for (i <-\
    \ 0 until first.length) answer += abs(first(i) - second(first.length - 1 - i))\n\
    \        } else {\n            for (i <- 0 until first.length) answer += abs(first(i)\
    \ - second(first.length - i))\n        }\n        answer\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vdqlkoq.scala:25)\n\tat Problem.main(tmp1vdqlkoq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010088
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        var result = 0l\n        var\
    \ i = 0\n        while (i < n / 2) {\n            result += abs(arr(i) - arr(n\
    \ - 1 - i))\n            i += 1\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz1h0jpd1.scala:25)\n\tat Problem.main(tmpz1h0jpd1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      arr.length\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3_c8ft__.scala:18)\n\tat Problem.main(tmp3_c8ft__.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010088
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Fill up this function body\n        // You can add another\
    \ function as well, if required\n        var size = arr.size\n        var sum1\
    \ = 0l\n        var sum2 = 0l\n        for (i <- 0 until (size + 1) / 2) {\n \
    \           sum1 += arr(i)\n            sum2 += arr(size - 1 - i)\n        }\n\
    \        if (sum1 < sum2) {\n            var res = 0l\n            for (i <- 0\
    \ until (size + 1) / 2) {\n                res += arr(size - 1 - i) - arr(i)\n\
    \            }\n            res\n        } else {\n            var res = 0l\n\
    \            for (i <- 0 until (size + 1) / 2) {\n                res += arr(i)\
    \ - arr(size - 1 - i)\n            }\n            res\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx2syv5l1.scala:39)\n\tat Problem.main(tmpx2syv5l1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010088
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        var ans = 0l\n        for (i\
    \ <- 0 until n / 2) {\n            ans += (abs(arr(i) - arr(n - i - 1)) + 1) /\
    \ 2\n        }\n        ans\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8ykq55b5.scala:23)\n\tat Problem.main(tmp8ykq55b5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010088
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def sub(arr : List[Long], count : Long) : Long = {\n   \
    \         if (arr.length <= 1) count\n            else if (arr.head == arr.last)\
    \ sub(arr.slice(1, arr.length - 1), count)\n            else {\n             \
    \   val max = arr.max\n                val min = arr.min\n                val\
    \ maxChange = sub(arr.updated(arr.indexOf(max), min), count + 1)\n           \
    \     val minChange = sub(arr.updated(arr.indexOf(min), max), count + 1)\n   \
    \             min(maxChange, minChange)\n            }\n        }\n        sub(arr,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmphrexk7ti.scala:23:16 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                min(maxChange, minChange)\n\e[31m\e[31m\
    \   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m                \e[33mvalue\e\
    [0m \e[35mmin\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010085
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val L = Array.ofDim[Long](n,\
    \ n)\n        var i = 0\n        while (i < n) {\n            var j = 0\n    \
    \        while (j < n) {\n                if (i == j) L(i)(j) = 0\n          \
    \      else if (i + 1 == j) L(i)(j) = abs(arr(i) - arr(j))\n                else\
    \ if (i + 2 == j) L(i)(j) = (L(i)(i + 1) + abs(arr(i) - arr(j))) min (L(i + 1)(j)\
    \ + abs(arr(i + 1) - arr(j)))\n                else {\n                    L(i)(j)\
    \ = Long.MaxValue\n                    var k = i\n                    while (k\
    \ < j) {\n                        L(i)(j) = L(i)(j) min (L(i)(k) + L(k + 1)(j)\
    \ + abs(arr(k) - arr(j)))\n                        k += 1\n                  \
    \  }\n                }\n                j += 1\n            }\n            i\
    \ += 1\n        }\n        L(0)(n - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4z7s489i.scala:41)\n\tat Problem.main(tmp4z7s489i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010088
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Algorithm:\n        // 1. Get the length of the list\n\
    \        // 2. Check the middle and then go from there\n        // 3. If the values\
    \ are the same, then keep going\n        // 4. If the values are not the same,\
    \ then we return the smaller of the two.\n        // 5. Get the length of the\
    \ reverse of the list.\n        // >>> smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n      \
    \  // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong)))\n        // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong)))\n        // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong)))\n\
    \        val length = arr.length\n        def loop(curr : Long, acc : Long) :\
    \ Long = {\n            if (curr == length) acc\n            else {\n        \
    \        val sum = abs(arr(curr.toInt) - arr(length - 1 - curr.toInt))\n     \
    \           loop(curr + 1, acc + sum)\n            }\n        }\n        loop(0,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9iljlztc.scala:36)\n\tat Problem.main(tmp9iljlztc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        ???\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.smallestChange(tmph_tavk_f.scala:15)\n\tat Problem$.main(tmph_tavk_f.scala:18)\n\
    \tat Problem.main(tmph_tavk_f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010076
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def helper(l : Long, r : Long, acc : Long) : Long = {\n\
    \            if (l >= r) acc\n            else {\n                if (arr(l.toInt)\
    \ == arr(r.toInt)) helper(l + 1, r - 1, acc)\n                else {\n       \
    \             min(helper(l + 1, r, acc + 1), helper(l, r - 1, acc + 1))\n    \
    \            }\n            }\n        }\n        helper(0, arr.length - 1, 0)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv19iwaqq.scala:27)\n\tat Problem.main(tmpv19iwaqq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var min = Long.MaxValue\n        for (i <- 0 until arr.length)\
    \ {\n            var a = arr.slice(0, i)\n            var b = arr.slice(i + 1,\
    \ arr.length)\n            min = min min a.count(_ == arr(i)) + b.count(_ == arr(i))\n\
    \        }\n        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoof8uxm4.scala:24)\n\tat Problem.main(tmpoof8uxm4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010098
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        null\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1d21ommb.scala:15:8\
    \ ---------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[31mnull\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^\e[0m\n\e[31m   |\e[0m        Found:    Null\n\e\
    [31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010093
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val l = arr.length\n        val matrix = Array.ofDim[Long](l\
    \ + 1, l + 1)\n        for (i <- 0 to l) {\n            matrix(i)(i) = 0\n   \
    \     }\n        for (s <- 1 to l) {\n            for (i <- 0 to l - s) {\n  \
    \              val j = i + s\n                if (i + 1 == j) {\n            \
    \        matrix(i)(j) = if (arr(i) == arr(j - 1)) 0 else 1\n                }\
    \ else {\n                    matrix(i)(j) = min(matrix(i + 1)(j) + 1, matrix(i)(j\
    \ - 1) + 1)\n                    if (arr(i) == arr(j - 1)) {\n               \
    \         matrix(i)(j) = min(matrix(i)(j), matrix(i + 1)(j - 1))\n           \
    \         }\n                }\n            }\n        }\n        matrix(0)(l)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0ipk3nud.scala:36)\n\tat Problem.main(tmp0ipk3nud.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010098
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def loop(arr : List[Long], front : Int, back : Int, count\
    \ : Long) : Long = {\n            if (front >= back) return count\n          \
    \  if (arr(front) == arr(back)) return loop(arr, front + 1, back - 1, count)\n\
    \            else {\n                val change1 = loop(arr, front + 1, back,\
    \ count + 1)\n                val change2 = loop(arr, front, back - 1, count +\
    \ 1)\n                if (change1 < change2) change1 else change2\n          \
    \  }\n        }\n        loop(arr, 0, arr.length - 1, 0)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxczqtiqm.scala:27)\n\tat Problem.main(tmpxczqtiqm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010097
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.map(x => Long.MaxValue)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp8ykqxtj.scala:15:15\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.map(\e[36mx\e[0m\
    \ => Long.MaxValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def findSmallestChange(arr : List[Long], prefix : List[Long],\
    \ suffix : List[Long]) : Long = {\n            if (prefix.length == 0) return\
    \ suffix.length\n            if (suffix.length == 0) return prefix.length\n  \
    \          if (prefix.head == suffix.head) return findSmallestChange(arr, prefix.tail,\
    \ suffix.tail)\n            findSmallestChange(arr, prefix.tail, suffix) min findSmallestChange(arr,\
    \ prefix, suffix.tail)\n        }\n        findSmallestChange(arr, arr, arr.reverse)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpte_nsh6p.scala:24)\n\tat Problem.main(tmpte_nsh6p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010098
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length == 0) return 0\n        if (arr.length ==\
    \ 1) return 0\n        if (arr.length == 2) return if (arr(0) == arr(1)) 0 else\
    \ 1\n        if (arr.length == 3) return if (arr(0) == arr(2)) 0 else 1\n    \
    \    // Dynamic programming:\n        // Let the list be:\n        // (..., x_n,\
    \ x_{n+1}, ..., x_{n+m}, ...)\n        // Let A_i be the minimum number of elements\
    \ that need to be changed to make the sublist (x_n, ..., x_{n+i})\n        //\
    \ palindromic.\n        // If x_n == x_{n+m}, then A_m = A_{m-2}.\n        //\
    \ Otherwise,\n        // A_m = min(A_{m-1}, A_{m-2}) + 1\n        // The answer\
    \ is A_{n+m}\n        val A = new Array[Long](arr.length)\n        A(0) = 0\n\
    \        A(1) = if (arr(0) == arr(1)) 0 else 1\n        for (i <- 2 to arr.length\
    \ - 1) {\n            if (arr(i - 1) == arr(i)) A(i) = A(i - 2)\n            else\
    \ A(i) = min(A(i - 1), A(i - 2)) + 1\n        }\n        A(arr.length - 1)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppqu8toso.scala:39)\n\tat Problem.main(tmppqu8toso.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010099
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def recurse(i : Int, j : Int, cache : Array[Array[Long]])\
    \ : Long = {\n            if (i > j) 0\n            else if (cache(i)(j) != -1)\
    \ cache(i)(j)\n            else if (i == j) recurse(i + 1, j - 1, cache)\n   \
    \         else if (arr(i) == arr(j)) recurse(i + 1, j - 1, cache)\n          \
    \  else {\n                val a = recurse(i + 1, j, cache)\n                val\
    \ b = recurse(i, j - 1, cache)\n                val result = 1 + min(a, b)\n \
    \               cache(i)(j) = result\n                result\n            }\n\
    \        }\n        val cache = Array.fill(arr.length, arr.length)(-1)\n     \
    \   recurse(0, arr.length - 1, cache)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyyjes5b8.scala:29:35\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        recurse(\e[31m0\e[0m,\
    \ arr.length - \e[31m1\e[0m, cache)\n\e[31m\e[31m   |\e[0m                   \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \  Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mcache\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e\
    [0m\e[1m\e[31m \e[0mArray[Array[\e[1m\e[31mInt\e[0m]]\e[1m\e[31m)\e[0m\n\e[31m\
    \   |\e[0m                                   Required: Array[Array[\e[1m\e[32mLong\e\
    [0m]]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.reverse.zip(arr).filter(p => p._1 != p._2).size.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd8hv8up6.scala:18)\n\tat Problem.main(tmpd8hv8up6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010098
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var left : Long = -1l\n        var right : Long = -1l\n\
    \        var min = Long.MaxValue\n        var leftPtr = 0\n        var rightPtr\
    \ = arr.length - 1\n        while (leftPtr < rightPtr) {\n            if (arr(leftPtr)\
    \ < arr(rightPtr)) {\n                right = right + 1\n                leftPtr\
    \ = leftPtr + 1\n            } else if (arr(leftPtr) > arr(rightPtr)) {\n    \
    \            left = left + 1\n                rightPtr = rightPtr - 1\n      \
    \      } else {\n                leftPtr = leftPtr + 1\n                rightPtr\
    \ = rightPtr - 1\n            }\n        }\n        if (right == -1l) {\n    \
    \        left\n        } else if (left == -1l) {\n            right\n        }\
    \ else {\n            min = min min (left min right)\n            min\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpplk76sp7.scala:42)\n\tat Problem.main(tmpplk76sp7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010099
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var (l, r) = (0, arr.length - 1)\n        var ans = 0\n\
    \        while (l < r) {\n            val (nl, nr) = (arr(l), arr(r))\n      \
    \      if (nl == nr) {\n                l += 1\n                r -= 1\n     \
    \       } else if (nl < nr) {\n                l += 1\n                ans +=\
    \ 1\n            } else {\n                r -= 1\n                ans += 1\n\
    \            }\n        }\n        ans\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_d6vkcvb.scala:33)\n\tat Problem.main(tmp_d6vkcvb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010099
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val reversed = arr.toArray.reverse\n        val n = arr.length\n\
    \        val dp = Array.ofDim[Long](n + 1, n + 1)\n        for (i <- 1 to n) {\n\
    \            for (j <- 1 to n) {\n                if (arr(i - 1) == reversed(j\
    \ - 1)) dp(i)(j) = dp(i - 1)(j - 1) + 1\n                else dp(i)(j) = max(dp(i\
    \ - 1)(j), dp(i)(j - 1))\n            }\n        }\n        n - dp(n)(n)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4aliw7yx.scala:27)\n\tat Problem.main(tmp4aliw7yx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010099
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // working backward from the end, at each element is the\
    \ minimum number of elements that\n        // need to be changed to make the rest\
    \ of the list palindromic\n        // if the number of elements is odd, the mid\
    \ element can stay the same (1)\n        // if the number of elements is even,\
    \ the two mid elements need to match (0)\n        def dp(arr : List[Long], l :\
    \ List[Long]) : List[Long] = {\n            if (arr.isEmpty) l\n            else\
    \ if (arr.length == 1) dp(arr.tail, 1l::l)\n            else if (arr.length ==\
    \ 2) dp(arr.tail, min(arr.head, arr.tail.head)::l)\n            else if (arr.length\
    \ == 3) dp(arr.tail, min(arr.head, arr.tail.head, arr.tail.tail.head)::l)\n  \
    \          else {\n                if (arr.length % 2 == 0) {\n              \
    \      val a = arr.head\n                    val b = arr.tail.head\n         \
    \           val c = arr.tail.tail.head\n                    val d = arr.tail.tail.tail.head\n\
    \                    val e = arr.tail.tail.tail.tail.head\n                  \
    \  val minif = min(a, b, c, d, e)\n                    if (a == minif && b ==\
    \ minif && c == minif && d == minif && e == minif) dp(arr.tail, 0l::l)\n     \
    \               else dp(arr.tail, minif::l)\n                }\n             \
    \   else {\n                    val a = arr.head\n                    val b =\
    \ arr.tail.head\n                    val c = arr.tail.tail.head\n            \
    \        val d = arr.tail.tail.tail.head\n                    val minif = min(a,\
    \ b, c, d)\n                    if (a == minif && b == minif && c == minif &&\
    \ d == minif) dp(arr.tail, 0l::l)\n                    else dp(arr.tail, minif::l)\n\
    \                }\n            }\n        }\n        val result = dp(arr, List())\n\
    \        result.head\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpzntgji2a.scala:23:51 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (arr.length\
    \ == \e[31m3\e[0m) dp(arr.tail, min(arr.head, arr.tail.head, arr.tail.tail.head)::l)\n\
    \e[31m\e[31m   |\e[0m                                                   ^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((arr.head : => Long), (List[Long]#head\
    \ : => Long), (List[Long]#head : => Long))\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpzntgji2a.scala:31:32 -----------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                    \e[33mval\e[0m \e[36mminif\e[0m = min(a, b, c, d,\
    \ e)\n\e[31m\e[31m   |\e[0m                                ^^^\e[0m\n\e[31m  \
    \ |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m\
    \ in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e\
    [31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\
    \e[31m   |\e[0mmatch arguments ((a : Long), (b : Long), (c : Long), (d : Long),\
    \ (e : Long))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpzntgji2a.scala:40:32\
    \ -----------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                   \
    \ \e[33mval\e[0m \e[36mminif\e[0m = min(a, b, c, d)\n\e[31m\e[31m   |\e[0m   \
    \                             ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((a : Long),\
    \ (b : Long), (c : Long), (d : Long))\n3 errors found\n"
  stdout: ''
  timestamp: 1660010095
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val minChanges = Array.ofDim[Long](n,\
    \ n)\n        for (l <- 0 until n) {\n            for (i <- 0 until n) {\n   \
    \             val j = i + l\n                if (j >= n) {\n                 \
    \   // Out of bounds\n                    continue\n                }\n      \
    \          if (i == j) {\n                    // Single letter is always a palindrome\n\
    \                    minChanges(i)(j) = 0\n                } else if (i + 1 ==\
    \ j) {\n                    // Two letters must match\n                    minChanges(i)(j)\
    \ = arr(i) match {\n                        case v : Long if (v == arr(j)) =>\
    \ 0\n                        case _ => 1\n                    }\n            \
    \    } else {\n                    // More than two letters\n                \
    \    if (arr(i) == arr(j)) {\n                        // Matching letters, so\
    \ no changes needed\n                        minChanges(i)(j) = minChanges(i +\
    \ 1)(j - 1)\n                    } else {\n                        // Non-matching\
    \ letters, so we have to check which of the two is the smallest\n            \
    \            minChanges(i)(j) = min(minChanges(i + 1)(j), minChanges(i)(j - 1))\
    \ + 1\n                    }\n                }\n            }\n        }\n  \
    \      minChanges(0)(n - 1)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnk1wryji.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    continue\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ continue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010095
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def m(arr : List[Long], pos : Long) : Long = {\n       \
    \     if (pos >= arr.length) 0\n            else min(m(arr, pos + 1), 1 + m(arr,\
    \ pos + 2))\n        }\n        m(arr, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbmzmij3m.scala:22)\n\tat Problem.main(tmpbmzmij3m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010098
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var count = 0l\n        var a = arr\n        var b = arr.reverse\n\
    \        while (a.length != 0) {\n            if (a.head != b.head) count += 1\n\
    \            a = a.tail\n            b = b.tail\n        }\n        count\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa2722pyz.scala:26)\n\tat Problem.main(tmpa2722pyz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010099
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val p = Array.ofDim[Long](n,\
    \ n)\n        for (i <- 0 until n) {\n            p(i)(i) = arr(i)\n        }\n\
    \        for (k <- 1 until n) {\n            for (i <- 0 until n - k) {\n    \
    \            p(i)(i + k) = p(i)(i + k - 1) ^ p(i + 1)(i + k)\n            }\n\
    \        }\n        val dp = Array.ofDim[Long](n, n)\n        for (i <- 0 until\
    \ n) {\n            dp(i)(i) = 0\n        }\n        for (k <- 1 until n) {\n\
    \            for (i <- 0 until n - k) {\n                var min = k\n       \
    \         for (j <- 0 until k) {\n                    min = min min (dp(i)(i +\
    \ j) + dp(i + j + 1)(i + k))\n                }\n                dp(i)(i + k)\
    \ = min + (p(i)(i + k) != 0).toLong\n            }\n        }\n        dp(0)(n\
    \ - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkhsz5621.scala:33:35\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m                    min = min\
    \ min (dp(i)(i + j) + dp(i + j + \e[31m1\e[0m)(i + k))\n\e[31m\e[31m   |\e[0m\
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                   Found:    Long\n\e[31m   |\e\
    [0m                                   Required: Int\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpkhsz5621.scala:35:56 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                dp(i)(i + k) = min + (p(i)(i + k) !=\
    \ \e[31m0\e[0m).toLong\n\e[31m\e[31m   |\e[0m                                \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member\
    \ of Boolean, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010098
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val dp = Array.ofDim[Long](n,\
    \ n)\n        def recurse(i : Int, j : Int) : Long = {\n            if (i >= j)\
    \ 0l\n            else if (dp(i)(j) > 0) dp(i)(j)\n            else {\n      \
    \          if (arr(i) == arr(j)) dp(i)(j) = recurse(i + 1, j - 1)\n          \
    \      else dp(i)(j) = 1 + min(recurse(i + 1, j), recurse(i, j - 1))\n       \
    \     }\n            dp(i)(j)\n        }\n        recurse(0, n - 1)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsi3uh9_m.scala:29)\n\tat Problem.main(tmpsi3uh9_m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010099
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      val n = arr.length\n      val m = HashMap[(Int, Int), Long]()\n\
    \      def dp(i : Int, j : Int) : Long = {\n        if (m.contains((i, j))) m((i,\
    \ j))\n        else {\n          if (i == j) m((i, j)) = 0\n          else if\
    \ (i == j - 1) m((i, j)) = if (arr(i) == arr(j)) 0 else 1\n          else {\n\
    \            if (arr(i) == arr(j)) m((i, j)) = dp(i + 1, j - 1)\n            else\
    \ m((i, j)) = 1 + min(dp(i + 1, j), dp(i, j - 1))\n          }\n          m((i,\
    \ j))\n        }\n      }\n      dp(0, n - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph3xhcpo7.scala:32)\n\tat Problem.main(tmph3xhcpo7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010099
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n\t\tval a = arr.toArray\n\t\tvar count = 0l\n\t\tfor (i <- 0 until\
    \ a.length / 2) {\n\t\t\tif (a(i) != a(a.length - 1 - i)) count += 1\n\t\t}\n\t\
    \tcount\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp_9q707ab.scala:21:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 2 tabs\n\e[31m   |\e[0m   Latest indent   :\
    \ 4 spaces\n1 error found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var count = 0l\n        for (i <- 0 to arr.length / 2) {\n\
    \            if (arr(i) != arr(arr.length - 1 - i)) {\n                count +=\
    \ 1\n            }\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmjmv6u_e.scala:24)\n\tat Problem.main(tmpmjmv6u_e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010099
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val (len, pal) = palindromeEnds(arr)\n        var rev =\
    \ arr.reverse\n        val (lenR, palR) = palindromeEnds(rev)\n        if (len\
    \ >= lenR) len else lenR\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7mi6au2u.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m (len, pal) = palindromeEnds(arr)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         Not found: palindromeEnds\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp7mi6au2u.scala:15:13 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m (len, pal) = palindromeEnds(arr)\n\
    \e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e[0m             Recursive\
    \ \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp7mi6au2u.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m (len, pal) = palindromeEnds(arr)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp7mi6au2u.scala:17:27 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m (lenR, palR) = palindromeEnds(rev)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                           Not found: palindromeEnds\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7mi6au2u.scala:17:13 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m (lenR, palR) = palindromeEnds(rev)\n\
    \e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e[0m             Recursive\
    \ \e[33mvalue\e[0m \e[35m$2$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp7mi6au2u.scala:17:19 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m (lenR, palR) = palindromeEnds(rev)\n\
    \e[31"
  stdout: ''
  timestamp: 1660010099
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def smallestChange(arr : List[Long], l : Long, r : Long,\
    \ count : Long) : Long = {\n            if (l == r) count\n            else if\
    \ (l == r - 1) {\n                if (arr(l.toInt) == arr(r.toInt)) count\n  \
    \              else count + 1\n            }\n            else {\n           \
    \     if (arr(l.toInt) == arr(r.toInt)) smallestChange(arr, l + 1, r - 1, count)\n\
    \                else List(smallestChange(arr, l + 1, r, count + 1), smallestChange(arr,\
    \ l, r - 1, count + 1)).min\n            }\n        }\n        smallestChange(arr,\
    \ 0, arr.length - 1, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmflfhkd6.scala:29)\n\tat Problem.main(tmpmflfhkd6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def change(arr : List[Long], i : Int, k : Int) : Long =\
    \ {\n            if (i >= k) {\n                return 0l\n            }\n   \
    \         val minChange = min(change(arr, i + 1, k), change(arr, i, k - 1))\n\
    \            val minChange = min(minChange, change(arr, i + 1, k - 1))\n     \
    \       arr(i) = arr(k)\n            val maxChange = max(change(arr, i + 1, k),\
    \ change(arr, i, k - 1))\n            val maxChange = max(maxChange, change(arr,\
    \ i + 1, k - 1))\n            return minChange\n        }\n        change(arr,\
    \ 0, arr.length - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_t9o6oga.scala:20:16 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mminChange\e[0m = min(minChange,\
    \ change(arr, i + \e[31m1\e[0m, k - \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mminChange is already defined as \e[33mvalue\e[0m \e[35mminChange\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_t9o6oga.scala:23:16 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            \e[33mval\e[0m \e[36mmaxChange\e[0m = max(maxChange, change(arr,\
    \ i + \e[31m1\e[0m, k - \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxChange is already defined as \e[33mvalue\e[0m \e[35mmaxChange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp_t9o6oga.scala:21:12 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m            arr(i) = arr(k)\n\e[31m\e[31m   |\e[0m            ^^^\e\
    [0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did you mean\
    \ arr.updated?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010105
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = n/2\n        var cost\
    \ = 0l\n        for (i <- 0 until m) {\n            val j = n - i - 1\n      \
    \      if (arr(i) != arr(j)) {\n                cost += abs(arr(i) - arr(j))\n\
    \            }\n        }\n        cost\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc03jjdqd.scala:27)\n\tat Problem.main(tmpc03jjdqd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.size == 0) return 0l\n        val length = arr.size\n\
    \        val count = Array.ofDim[Long](length, length)\n        for (k <- 0 until\
    \ length) {\n            for (i <- 0 until length - k) {\n                val\
    \ j = i + k\n                if (i == j) count(i)(j) = 0\n                else\
    \ if (i + 1 == j) count(i)(j) = if (arr(i) == arr(j)) 0 else 1\n             \
    \   else {\n                    val first = count(i + 1)(j)\n                \
    \    val second = count(i)(j - 1)\n                    count(i)(j) = min(first,\
    \ second) + (if (arr(i) == arr(j)) 0 else 1)\n                }\n            }\n\
    \        }\n        count(0)(length - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuhp8klk1.scala:33)\n\tat Problem.main(tmpuhp8klk1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010108
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var change = 0l\n        val mid = arr.length / 2\n    \
    \    for (i <- 0 until mid) change += abs(arr(i) - arr(arr.length - 1 - i))\n\
    \        change\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwg67yfdq.scala:21)\n\tat Problem.main(tmpwg67yfdq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010108
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var first = true\n        var left = 0\n        var right\
    \ = arr.length - 1\n        var count = 0l\n        while (left < right) {\n \
    \           if (arr(left) != arr(right)) {\n                if (first) {\n   \
    \                 if (arr(left) != arr(right - 1)) {\n                       \
    \ count += abs(arr(left) - arr(right))\n                        right -= 1\n \
    \                   } else {\n                        count += abs(arr(left) -\
    \ arr(right - 1))\n                        right -= 2\n                    }\n\
    \                    first = false\n                } else {\n               \
    \     count += abs(arr(left) - arr(right))\n                    right -= 1\n \
    \               }\n            }\n            left += 1\n        }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprc69e54k.scala:40)\n\tat Problem.main(tmprc69e54k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010108
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val a = Array.ofDim[Long](arr.length, arr.length)\n    \
    \    for (i <- 0 until arr.length) {\n            for (j <- 0 until arr.length)\
    \ {\n                if (i > j) a(i)(j) = 0\n                else if (i == j)\
    \ a(i)(j) = 1\n                else a(i)(j) = Long.MaxValue\n            }\n \
    \       }\n        for (gap <- 1 until arr.length) {\n            for (i <- 0\
    \ until arr.length - gap) {\n                val j = i + gap\n               \
    \ if (arr(i) == arr(j)) a(i)(j) = a(i + 1)(j - 1)\n                else a(i)(j)\
    \ = min(a(i + 1)(j), a(i)(j - 1)) + 1\n            }\n        }\n        a(0)(arr.length\
    \ - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbzbgg9va.scala:33)\n\tat Problem.main(tmpbzbgg9va.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010109
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        // a[i][j] is the number of\
    \ elements that need to be changed to make the subarray arr[i..j] palindromic\n\
    \        // it is obtained from a[i+1][j-1] (which is the number of elements that\
    \ need to be changed to make the subarray arr[i+1..j-1] palindromic)\n       \
    \ // and the number of elements that need to be changed to make arr[i] equal to\
    \ arr[j] (which is 1 if arr[i] != arr[j])\n        val a = Array.ofDim[Long](n,\
    \ n)\n        for (i <- n - 1 to 0 by -1) {\n            a(i)(i) = 0\n       \
    \     for (j <- i + 1 until n) {\n                if (arr(i) == arr(j)) a(i)(j)\
    \ = a(i + 1)(j - 1)\n                else a(i)(j) = min(a(i + 1)(j), a(i)(j -\
    \ 1)) + 1\n            }\n        }\n        return a(0)(n - 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprc4f2sc1.scala:30)\n\tat Problem.main(tmprc4f2sc1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010109
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def f(arr : List[Long], i : Int, j : Int, cnt : Long) :\
    \ Long = {\n            if (i >= j) return cnt\n            if (arr(i) == arr(j))\
    \ f(arr, i + 1, j - 1, cnt)\n            else {\n                val n1 = f(arr,\
    \ i + 1, j, cnt + 1)\n                val n2 = f(arr, i, j - 1, cnt + 1)\n   \
    \             if (n1 < n2) n1 else n2\n            }\n        }\n        f(arr,\
    \ 0, arr.length - 1, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcqiefig1.scala:27)\n\tat Problem.main(tmpcqiefig1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010108
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var diffs = List[Long]()\n        for (i <- 0 until arr.length\
    \ / 2) diffs = abs(arr(i) - arr(arr.length - 1 - i)) :: diffs\n        diffs.foldLeft(0l)((a,\
    \ b) => a + b)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi808mqju.scala:20)\n\tat Problem.main(tmpi808mqju.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010109
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        null\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1d21ommb.scala:15:8\
    \ ---------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[31mnull\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^\e[0m\n\e[31m   |\e[0m        Found:    Null\n\e\
    [31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010093
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.size match {\n            case 0 => 0\n            case\
    \ 1 => 0\n            case 2 => if (arr(0) == arr(1)) 0 else 1\n            case\
    \ _ => {\n                val n = arr.size\n                var m = Array.ofDim[Long](n,\
    \ n)\n                for (i <- 0 until n) m(i)(i) = 0\n                for (l\
    \ <- 2 to n) {\n                    for (i <- 0 to n - l) {\n                \
    \        val j = i + l - 1\n                        if (arr(i) == arr(j)) m(i)(j)\
    \ = m(i + 1)(j - 1)\n                        else m(i)(j) = min(m(i + 1)(j), m(i)(j\
    \ - 1)) + 1\n                    }\n                }\n                m(0)(n\
    \ - 1)\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgd_6i5nb.scala:35)\n\tat Problem.main(tmpgd_6i5nb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010109
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        var A = new Array[Array[Long]](n)\n\
    \        for (i <- 0 until n) A(i) = new Array[Long](n)\n        var B = new Array[Array[Long]](n)\n\
    \        for (i <- 0 until n) B(i) = new Array[Long](n)\n        for (i <- 0 until\
    \ n) A(i)(i) = 0\n        for (i <- 0 until n) B(i)(i) = 0\n        for (k <-\
    \ 1 until n) {\n            for (i <- 0 until n - k) {\n                val j\
    \ = i + k\n                A(i)(j) = (if (arr(i) == arr(j)) A(i + 1)(j - 1) else\
    \ (A(i + 1)(j - 1) + 1))\n                if (i == j - 1) B(i)(j) = A(i)(j)\n\
    \                else B(i)(j) = min(A(i)(j), B(i + 1)(j) + 1, B(i)(j - 1) + 1)\n\
    \            }\n        }\n        B(0)(n - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmput1fpvht.scala:27:31 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33melse\e[0m B(i)(j) = min(A(i)(j),\
    \ B(i + \e[31m1\e[0m)(j) + \e[31m1\e[0m, B(i)(j - \e[31m1\e[0m) + \e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                               ^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Long, Long, Long)\n1 error found\n"
  stdout: ''
  timestamp: 1660010106
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var result = 0l\n        var front = 0\n        var back\
    \ = arr.length - 1\n        while (front < back) {\n            if (arr(front)\
    \ != arr(back)) {\n                result += 1\n            }\n            front\
    \ += 1\n            back -= 1\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010109
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.length match {\n            case length if length <=\
    \ 1 => 0l\n            case length if length % 2 == 0 => {\n                var\
    \ cnt = 0l\n                val halfLength = length / 2\n                for (i\
    \ <- 0 until halfLength) {\n                    if (arr(i) != arr(length - 1 -\
    \ i)) cnt += 1\n                }\n                cnt\n            }\n      \
    \      case length if length % 2 == 1 => {\n                var cnt = 0l\n   \
    \             val halfLength = length / 2\n                val middleValue = arr(halfLength)\n\
    \                for (i <- 0 until halfLength) {\n                    if (arr(i)\
    \ != arr(length - 1 - i)) cnt += 1\n                }\n                for (i\
    \ <- 0 until halfLength) {\n                    if (arr(i) != middleValue && arr(length\
    \ - 1 - i) != middleValue) cnt += 1\n                }\n                cnt\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr5448w_p.scala:41)\n\tat Problem.main(tmpr5448w_p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010110
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var counter = 0\n        for (i <- 0 until arr.length /\
    \ 2) {\n            if (arr(i) != arr(arr.length - 1 - i)) counter += 1\n    \
    \    }\n        counter\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010110
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val n2 = n / 2\n        val\
    \ (a, b) = arr.splitAt(n2)\n        val ap = a.reverse\n        if (n % 2 == 0)\
    \ {\n            var count = 0l\n            for (i <- 0 until n2) {\n       \
    \         if (ap(i) != b(i)) count += 1\n            }\n            count\n  \
    \      } else {\n            var count = 0l\n            for (i <- 0 until n2)\
    \ {\n                if (ap(i) != b(i)) count += 1\n            }\n          \
    \  count + 1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_qrpiep1.scala:35)\n\tat Problem.main(tmp_qrpiep1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010110
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Calculate the number of changes to the first half of\
    \ the list\n        val mid = (arr.length + 1) / 2 - 1\n        val left = arr.slice(0,\
    \ mid + 1)\n        val right = arr.slice(mid + 1, arr.length).reverse\n     \
    \   val changes = left.indices.foldLeft(0l.toLong) {(z, i) =>\n            if\
    \ (left(i) != right(i)) z + 1 else z\n        }\n        // Add the size of the\
    \ second half of the list\n        changes + (arr.length / 2)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpab_78uja.scala:26)\n\tat Problem.main(tmpab_78uja.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010110
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        def smallestChange(l : Int,\
    \ r : Int) : Long = {\n            if (l >= r) 0\n            else if (arr(l)\
    \ == arr(r)) smallestChange(l + 1, r - 1)\n            else 1 + min(smallestChange(l\
    \ + 1, r), smallestChange(l, r - 1))\n        }\n        smallestChange(0, len\
    \ - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfprwfqze.scala:24)\n\tat Problem.main(tmpfprwfqze.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010110
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val mid = (len - 1) / 2\n\
    \        def trychange(front : List[Long], middle : Long, back : List[Long]) :\
    \ Long = {\n            if (front.isEmpty) return 0\n            if (front.head\
    \ != back.head) {\n                if (front.head != middle) return 1\n      \
    \          else return trychange(front.tail, middle, back.tail)\n            }\n\
    \            else {\n                val t = trychange(front.tail, middle, back.tail)\n\
    \                if (t == -1) return -1\n                else return t + 1\n \
    \           }\n        }\n        if (len == 1) return 0\n        if (len % 2\
    \ == 0) {\n            val res = trychange(arr.take(mid), 0, arr.drop(mid).reverse)\n\
    \            if (res == -1) return -1\n            else return len - 1 - res\n\
    \        }\n        else {\n            val res = trychange(arr.take(mid), arr(mid),\
    \ arr.drop(mid + 1).reverse)\n            if (res == -1) return -1\n         \
    \   else return len - res\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb6ms_m8j.scala:42)\n\tat Problem.main(tmpb6ms_m8j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010110
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.length match {\n            case 1 => 0\n          \
    \  case 2 => if (arr(0) == arr(1)) 0 else 1\n            case 3 => {\n       \
    \         var min = 0\n                for (i <- 0 to 1) {\n                 \
    \   if (arr(i) != arr(2)) min += 1\n                }\n                min\n \
    \           }\n            case _ => {\n                var left = 0\n       \
    \         var right = arr.length - 1\n                var min = 0\n          \
    \      while (left < right) {\n                    if (arr(left) != arr(right))\
    \ min += 1\n                    left += 1\n                    right -= 1\n  \
    \              }\n                min\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpatdtb2te.scala:41)\n\tat Problem.main(tmpatdtb2te.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010110
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        //E.g. arr = [1, 2, 3, 4, 3, 2, 2]\n        val hash = new\
    \ HashMap[Long, List[Long]]()\n        for (i <- arr.indices) {\n            if\
    \ (hash.contains(arr(i))) {\n                hash(arr(i)) = hash(arr(i)) :+ i.toLong\n\
    \            } else {\n                hash += (arr(i) -> List(i.toLong))\n  \
    \          }\n        }\n        val freq = new HashMap[Long, Long]()\n      \
    \  for (i <- arr.indices) {\n            if (freq.contains(arr(i))) {\n      \
    \          freq(arr(i)) += 1\n            } else {\n                freq += (arr(i)\
    \ -> 1)\n            }\n        }\n        val distinct = hash.keys.toList.sorted\n\
    \        // distinct = [1, 2, 3, 4]\n        var result = 0l\n        for (k <-\
    \ distinct) {\n            if (freq(k) % 2 == 1) {\n                result +=\
    \ freq(k) - 1\n                // result = 1\n            } else {\n         \
    \       result += freq(k)\n                // result = 7\n            }\n    \
    \    }\n        var min = Long.MaxValue\n        for (k <- distinct) {\n     \
    \       val mid = freq(k) / 2\n            if (freq(k) % 2 == 1) {\n         \
    \       val pos = hash(k)(mid)\n                // pos = 1\n                var\
    \ l = 0l\n                for (i <- pos.toInt to 0 by -1) {\n                \
    \    // i = 1, 0\n                    if (arr(i) == k) {\n                   \
    \     l += 1\n                    } else {\n                        break\n  \
    \                  }\n                }\n                var r = 0l\n        \
    \        for (i <- pos.toInt to arr.length - 1) {\n                    // i =\
    \ 1, 2, 3, 4, 5, 6\n                    if (arr(i) == k) {\n                 \
    \       r += 1\n                    } else {\n                        break\n\
    \                    }\n                }\n                min = min min (l +\
    \ r - 1)\n                // min = 2\n           \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk9dkqt2r.scala:84:0 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk9dkqt2r.scala:48:34\
    \ --------------------\e[0m\e[0m\n\e[31m48 |\e[0m                \e[33mval\e[0m\
    \ \e[36mpos\e[0m = hash(k)(mid)\n\e[31m\e[31m   |\e[0m                       \
    \           ^^^\e[0m\n\e[31m   |\e[0m                                  Found:\
    \    (mid : Long)\n\e[31m   |\e[0m                                  Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk9dkqt2r.scala:56:24\
    \ ------------------------\e[0m\e[0m\n\e[31m56 |\e[0m                        break\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpk9dkqt2r.scala:65:24 ------------------------\e[0m\e\
    [0m\n\e[31m65 |\e[0m                        break\n\e[31m\e[31m   |\e[0m     \
    \                   ^^^^^\e[0m\n\e[31m   |\e[0m                        Not found:\
    \ break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpk9dkqt2r.scala:72:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m72 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660010110
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var ans = 0l\n        var neg = false\n        var neg_count\
    \ = 0\n        var prev = 0l\n        val map = new HashMap[Long, Int]\n     \
    \   arr.foreach(x => {\n            if (x < 0) {\n                neg = true\n\
    \                neg_count += 1\n            }\n            if (map.contains(x))\
    \ map(x) += 1\n            else map += (x -> 1)\n        })\n        if (neg)\
    \ {\n            if (neg_count % 2 == 0) {\n                map.foreach(x => {\n\
    \                    val i = x._1\n                    val count = x._2\n    \
    \                ans += abs(i - prev) * count\n                    prev = i\n\
    \                })\n            } else {\n                if (map.contains(0l))\
    \ {\n                    map.foreach(x => {\n                        val i = x._1\n\
    \                        val count = x._2\n                        ans += abs(i\
    \ - prev) * count\n                        prev = i\n                    })\n\
    \                } else {\n                    map.filter(x => x._1 > 0).foreach(x\
    \ => {\n                        val i = x._1\n                        val count\
    \ = x._2\n                        ans += abs(i - prev) * count\n             \
    \           prev = i\n                    })\n                    map.filter(x\
    \ => x._1 < 0).foreach(x => {\n                        val i = x._1\n        \
    \                val count = x._2\n                        ans += abs(i - prev)\
    \ * count\n                        prev = i\n                    })\n        \
    \        }\n            }\n        } else {\n            map.foreach(x => {\n\
    \                val i = x._1\n                val count = x._2\n            \
    \    ans += abs(i - prev) * count\n                prev = i\n            })\n\
    \        }\n        ans\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmporxjnbid.scala:70)\n\tat Problem.main(tmporxjnbid.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010111
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        ???\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.smallestChange(tmph_tavk_f.scala:15)\n\tat Problem$.main(tmph_tavk_f.scala:18)\n\
    \tat Problem.main(tmph_tavk_f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010076
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def recurse(arr : List[Long], left : Int, right : Int, minChanges\
    \ : Long) : Long = {\n            if (left >= right) minChanges\n            else\
    \ if (arr(left) == arr(right)) recurse(arr, left + 1, right - 1, minChanges)\n\
    \            else recurse(arr, left + 1, right, minChanges + 1)\n        }\n \
    \       recurse(arr, 0, arr.length - 1, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9vzhl7rq.scala:23)\n\tat Problem.main(tmp9vzhl7rq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010110
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def helper(diff : Long, pairs : List[(Long, Long)]) : Long\
    \ = {\n            pairs match {\n                case Nil => diff\n         \
    \       case p :: ps => {\n                    val d = abs(p._1 - p._2)\n    \
    \                helper(max(diff, d), ps)\n                }\n            }\n\
    \        }\n        val l = arr.length\n        val pairs = (0 until l / 2).map(i\
    \ => {\n            val j = l - i - 1\n            (arr(i), arr(j))\n        }).toList\n\
    \        helper(0, pairs)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi1yf0lqx.scala:32)\n\tat Problem.main(tmpi1yf0lqx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // We first find the maximum palindromic subsequence using\
    \ dynamic programming.\n        // Then we change n - length of the palindromic\
    \ subsequence to get the answer.\n        // The runtime is O(n^2).\n        var\
    \ table = HashMap[(Int, Int), Int]()\n        for (i <- 0 until arr.length) {\n\
    \            table((i, i)) = 1\n        }\n        for (i <- 0 until arr.length)\
    \ {\n            for (j <- i + 1 until arr.length) {\n                if (arr(i)\
    \ == arr(j)) {\n                    table((i, j)) = table((i + 1, j - 1)) + 2\n\
    \                } else {\n                    table((i, j)) = max(table((i +\
    \ 1, j)), table((i, j - 1)))\n                }\n            }\n        }\n  \
    \      (arr.length - table((0, arr.length - 1))).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: key not found: (1,2)\n\tat scala.collection.MapOps.default(Map.scala:274)\n\
    \tat scala.collection.MapOps.default$(Map.scala:273)\n\tat scala.collection.AbstractMap.default(Map.scala:405)\n\
    \tat scala.collection.mutable.HashMap.apply(HashMap.scala:425)\n\tat Problem$.smallestChange$$anonfun$2$$anonfun$1(tmp7__5tv6e.scala:27)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange$$anonfun$2(tmp7__5tv6e.scala:29)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange(tmp7__5tv6e.scala:30)\n\
    \tat Problem$.main(tmp7__5tv6e.scala:34)\n\tat Problem.main(tmp7__5tv6e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGeneri"
  stdout: ''
  timestamp: 1660010118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        var dp = Array.ofDim[Long](n,\
    \ n)\n        for (l <- 1 to n) {\n            for (i <- 0 to n - l) {\n     \
    \           val j = i + l - 1\n                if (i == j) dp(i)(j) = 0\n    \
    \            else if (i + 1 == j) dp(i)(j) = if (arr(i) == arr(j)) 0 else 1\n\
    \                else dp(i)(j) = min(dp(i + 1)(j), dp(i)(j - 1)) + if (arr(i)\
    \ == arr(j)) 0 else 1\n            }\n        }\n        return dp(0)(n - 1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpuarpxsvi.scala:22:66 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33melse\e[0m dp(i)(j) = min(dp(i +\
    \ \e[31m1\e[0m)(j), dp(i)(j - \e[31m1\e[0m)) + \e[33mif\e[0m (arr(i) == arr(j))\
    \ \e[31m0\e[0m \e[33melse\e[0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m           \
    \                                                       ^^\e[0m\n\e[31m   |\e\
    [0m                                        expression expected but \e[31mif\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010113
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        // a[i][j] represents the smallest\
    \ number of changes to make arr[i..j] a palindrome\n        val a = Array.ofDim[Long](n,\
    \ n)\n        // a[i][j] = 0 if i >= j\n        for (i <- 0 until n) a(i)(i) =\
    \ 0\n        // a[i][j] = a[i+1][j-1] if arr[i] == arr[j]\n        for (i <- 0\
    \ until n - 1) {\n            a(i)(i + 1) = if (arr(i) == arr(i + 1)) 0 else 1\n\
    \        }\n        // a[i][j] = min(a[i+1][j], a[i][j-1]) + 1 if arr[i] != arr[j]\n\
    \        for (d <- 2 until n) {\n            for (i <- 0 until n - d) {\n    \
    \            val j = i + d\n                a(i)(j) = if (arr(i) == arr(j)) a(i\
    \ + 1)(j - 1) else min(a(i + 1)(j), a(i)(j - 1)) + 1\n            }\n        }\n\
    \        a(0)(n - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ctrd70e.scala:34)\n\tat Problem.main(tmp6ctrd70e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010119
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def helper(front : List[Long], back : List[Long], count\
    \ : Long) : Long = (front, back) match {\n            case (Nil, Nil) => count\n\
    \            case (h1 :: t1, h2 :: t2) => helper(t1, t2, count + (if (h1 == h2)\
    \ 0 else 1))\n        }\n        helper(arr, arr.reverse, 0)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6_bmgmrj.scala:22)\n\tat Problem.main(tmp6_bmgmrj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010119
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        return 0l\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxjflj74i.scala:18)\n\tat Problem.main(tmpxjflj74i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length == 0) 0l\n        else {\n            val\
    \ half = arr.length / 2\n            val left = arr.slice(0, half)\n         \
    \   val leftCount = left.groupBy(identity).mapValues(_.size)\n            val\
    \ right = arr.slice(half + arr.length % 2, arr.length)\n            val rightCount\
    \ = right.groupBy(identity).mapValues(_.size)\n            var unique = 0l\n \
    \           leftCount.foreach(entry => {\n                val value = entry._1\n\
    \                val left = entry._2\n                val right = rightCount.getOrElse(value,\
    \ 0)\n                unique += abs(left - right)\n            })\n          \
    \  unique\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx04haiop.scala:34)\n\tat Problem.main(tmpx04haiop.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010119
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      if (arr.size == 0) return 0l\n      if (arr.size == 1) return\
    \ 0l\n      if (arr.size == 2) return 0l\n      if (arr.size == 3) return 0l\n\
    \      val mid = arr.size / 2\n      // println(mid)\n      var count = 0l\n \
    \     for (i <- 0 until mid) {\n        if (arr(i) != arr(arr.size - 1 - i)) count\
    \ += 1\n      }\n      if (count <= 1) return count\n      // println(count)\n\
    \      val firstHalf = arr.slice(0, mid)\n      val secondHalf = arr.slice(mid\
    \ + 1, arr.size)\n      firstHalf.length match {\n        case m : Int if (m ==\
    \ 0) => 0l\n        case m : Int if (m == 1) => 1l\n        case m : Int if (m\
    \ == 2) => 1l\n        case m : Int if (m == 3) => 1l\n        case m : Int if\
    \ (m == 4) => {\n          val temp = firstHalf.slice(0, m - 1)\n          //\
    \ println(temp)\n          smallestChange(temp) + smallestChange(secondHalf)\n\
    \        }\n        case m : Int if (m == 5) => {\n          val temp = firstHalf.slice(0,\
    \ m - 1)\n          // println(temp)\n          smallestChange(temp) + smallestChange(secondHalf)\n\
    \        }\n        case m : Int if (m == 6) => {\n          val temp = firstHalf.slice(0,\
    \ m - 1)\n          // println(temp)\n          smallestChange(temp) + smallestChange(secondHalf)\n\
    \        }\n        case m : Int if (m == 7) => {\n          val temp = firstHalf.slice(0,\
    \ m - 1)\n          // println(temp)\n          smallestChange(temp) + smallestChange(secondHalf)\n\
    \        }\n        case m : Int if (m == 8) => {\n          val temp = firstHalf.slice(0,\
    \ m - 1)\n          // println(temp)\n          smallestChange(temp) + smallestChange(secondHalf)\n\
    \        }\n        case m : Int if (m == 9) =>\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqmd9nce9.scala:73:0 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqmd9nce9.scala:72:1\
    \ ---------------------\e[0m\e[0m\n\e[31m72 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpqmd9nce9.scala:61:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m61 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var result = 0l.toLong\n        var start = 0\n        var\
    \ end = arr.length - 1\n        while (start < end) {\n            if (arr(start)\
    \ != arr(end)) {\n                result += abs(arr(start) - arr(end))\n     \
    \       }\n            start += 1\n            end -= 1\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbu8a8u0q.scala:28)\n\tat Problem.main(tmpbu8a8u0q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010119
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val table = new HashMap[(Int, Int), Long]\n        def search(arr\
    \ : List[Long], start : Int, end : Int) : Long = {\n            if (start > end)\
    \ 0\n            else if (start == end) 0\n            else if (table.contains((start,\
    \ end))) table((start, end))\n            else {\n                if (arr(start)\
    \ == arr(end)) search(arr, start + 1, end - 1)\n                else {\n     \
    \               val r1 = search(arr, start + 1, end)\n                    val\
    \ r2 = search(arr, start, end - 1)\n                    table((start, end)) =\
    \ min(r1, r2) + 1\n                    table((start, end))\n                }\n\
    \            }\n        }\n        search(arr, 0, arr.length - 1)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4_4ps99_.scala:33)\n\tat Problem.main(tmp4_4ps99_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010120
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val dp = Array.ofDim[Long](n,\
    \ n)\n        for (step <- 1 to n - 1) {\n            for (i <- 0 to n - step\
    \ - 1) {\n                val j = i + step\n                if (step == 1) dp(i)(j)\
    \ = if (arr(i) == arr(j)) 0 else 1\n                else dp(i)(j) = min(dp(i +\
    \ 1)(j) + 1, dp(i)(j - 1) + 1)\n                if (arr(i) == arr(j)) dp(i)(j)\
    \ = min(dp(i)(j), dp(i + 1)(j - 1))\n            }\n        }\n        dp(0)(n\
    \ - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzlxlecj_.scala:28)\n\tat Problem.main(tmpzlxlecj_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010120
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val dp = Array.ofDim[Long](arr.length + 1, arr.length +\
    \ 1)\n        for (i <- 0 to arr.length) dp(i)(i) = 0\n        for (s <- 1 to\
    \ arr.length) {\n            for (i <- 0 to arr.length - s) {\n              \
    \  val j = i + s\n                dp(i)(j) = min(dp(i + 1)(j) + 1, dp(i)(j - 1)\
    \ + 1)\n                if (arr(i) == arr(j - 1)) dp(i)(j) = min(dp(i)(j), dp(i\
    \ + 1)(j - 1))\n            }\n        }\n        dp(0)(arr.length)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp73ftb2_u.scala:27)\n\tat Problem.main(tmp73ftb2_u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val l = arr.length\n        val memo = Array.ofDim[Long](l,\
    \ l)\n        def helper(i : Int, j : Int) : Long = {\n            if (memo(i)(j)\
    \ == 0) {\n                if (i == j) memo(i)(j) = 0\n                else if\
    \ (i + 1 == j) memo(i)(j) = abs(arr(i) - arr(j))\n                else {\n   \
    \                 val a = abs(arr(i) - arr(j))\n                    val b = helper(i\
    \ + 1, j)\n                    val c = helper(i, j - 1)\n                    memo(i)(j)\
    \ = a + min(b, c)\n                }\n            }\n            memo(i)(j)\n\
    \        }\n        helper(0, l - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptf3rwaon.scala:33)\n\tat Problem.main(tmptf3rwaon.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010120
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length == 0) 0\n        else {\n            val\
    \ p = palindrome(arr)\n            val q = arr.reverse\n            val (n, _)\
    \ = longestCommonSubsequence(p, q)\n            arr.length - n\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcrbfg7r7.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mp\e[0m = palindrome(arr)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                Not found: palindrome\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpcrbfg7r7.scala:19:25 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m            \e[33mval\e[0m (n, _) = longestCommonSubsequence(p,\
    \ q)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: longestCommonSubsequence\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcrbfg7r7.scala:19:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e\
    [0m (n, _) = longestCommonSubsequence(p, q)\n\e[31m\e[31m   |\e[0m           \
    \           ^\e[0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e\
    [0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010117
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def smallestChange0(arr : List[Long], left : Int, right\
    \ : Int) : Long = {\n            if (left > right) return 0l\n            if (left\
    \ == right) return 0l\n            min(arr(left) - arr(left + 1) + smallestChange0(arr,\
    \ left + 1, right),\n                arr(right) - arr(right - 1) + smallestChange0(arr,\
    \ left, right - 1))\n        }\n        smallestChange0(arr, 0, arr.length - 1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcsr2wq6w.scala:24)\n\tat Problem.main(tmpcsr2wq6w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010120
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Remove a element from the end to the beginning\n    \
    \    // Return the minimum difference between the two halves\n        def removeLoop(arr\
    \ : List[Long], low : Long, high : Long) : Long = {\n            if (low >= high)\
    \ 0l\n            else min(abs(arr(low.toInt) - arr(high.toInt)) + removeLoop(arr,\
    \ low + 1, high - 1), removeLoop(arr, low + 1, high))\n        }\n        removeLoop(arr,\
    \ 0, arr.length - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiob5yg6t.scala:24)\n\tat Problem.main(tmpiob5yg6t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010120
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val cache = HashMap[(Int, Int), Int]()\n        def helper(l\
    \ : Int, r : Int) : Int = {\n            if (cache.contains((l, r))) cache((l,\
    \ r))\n            else {\n                if (l >= r) 0\n                else\
    \ {\n                    val min = min(arr(l).toInt, arr(r).toInt)\n         \
    \           cache += ((l, r) -> (min + helper(l + 1, r - 1)))\n              \
    \      cache((l, r))\n                }\n            }\n        }\n        helper(0,\
    \ arr.length - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbpk3eg6i.scala:21:30 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    \e[33mval\e[0m \e[36mmin\e[0m = min(arr(l).toInt,\
    \ arr(r).toInt)\n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e\
    [31m   |\e[0m                              Recursive \e[33mvalue\e[0m \e[35mmin\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def recurse(arr : List[Long], left : Int, right : Int, palindromeLength\
    \ : Array[Array[Int]], count : Long) : Long = {\n            if (left > right)\
    \ count\n            else if (left == right) recurse(arr, left + 1, right - 1,\
    \ palindromeLength, count)\n            else if (left == right - 1) {\n      \
    \          if (arr(left) == arr(right)) {\n                    palindromeLength(left)(right)\
    \ = 2\n                    recurse(arr, left + 1, right - 1, palindromeLength,\
    \ count)\n                }\n                else {\n                    palindromeLength(left)(right)\
    \ = 1\n                    recurse(arr, left + 1, right - 1, palindromeLength,\
    \ count + 1)\n                }\n            }\n            else {\n         \
    \       if (arr(left) == arr(right)) {\n                    palindromeLength(left)(right)\
    \ = palindromeLength(left + 1)(right - 1) + 2\n                    recurse(arr,\
    \ left + 1, right - 1, palindromeLength, count)\n                }\n         \
    \       else {\n                    palindromeLength(left)(right) = max(palindromeLength(left\
    \ + 1)(right), palindromeLength(left)(right - 1))\n                    recurse(arr,\
    \ left + 1, right - 1, palindromeLength, count + 1)\n                }\n     \
    \       }\n        }\n        val palindromeLength = Array.ofDim[Int](arr.length,\
    \ arr.length)\n        recurse(arr, 0, arr.length - 1, palindromeLength, 0)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def findMinChange(left : Int, right : Int, changes : Long)\
    \ : Long = {\n            if (left >= right) changes\n            else if (arr(left)\
    \ == arr(right)) findMinChange(left + 1, right - 1, changes)\n            else\
    \ {\n                val leftChange = findMinChange(left + 1, right, changes +\
    \ 1)\n                val rightChange = findMinChange(left, right - 1, changes\
    \ + 1)\n                if (leftChange < rightChange) leftChange else rightChange\n\
    \            }\n        }\n        findMinChange(0, arr.length - 1, 0)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkfr_9zns.scala:27)\n\tat Problem.main(tmpkfr_9zns.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = Array.ofDim[Long](n,\
    \ n)\n        for (l <- 2 to n) {\n            for (i <- 0 to n - l) {\n     \
    \           val j = i + l - 1\n                m(i)(j) = min(\n              \
    \      m(i + 1)(j) + abs(arr(i) - arr(i + 1)),\n                    m(i)(j - 1)\
    \ + abs(arr(j) - arr(j - 1))\n                )\n            }\n        }\n  \
    \      m(0)(n - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbe3a0h3v.scala:29)\n\tat Problem.main(tmpbe3a0h3v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010122
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val l = arr.length\n        val m : Array[Array[Long]] =\
    \ Array.ofDim[Long](l, l)\n        for (i <- 0 until l; j <- i until l) {\n  \
    \          if (i == j) m(i)(j) = 0\n            else if (i == j - 1) m(i)(j) =\
    \ abs(arr(i) - arr(j))\n            else m(i)(j) = min(m(i)(j - 1), m(i + 1)(j))\
    \ + abs(arr(i) - arr(j))\n        }\n        m(0)(l - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_g8a1hlu.scala:25)\n\tat Problem.main(tmp_g8a1hlu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010122
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n\tval buffer = ArrayBuffer[Long]()\n\tvar result = 0l\n\tif (arr.length\
    \ == 1) return 0l\n\tif (arr.length == 2) return if (arr(0) == arr(1)) 0l else\
    \ 1l\n\tif (arr.length % 2 == 0) {\n\t    val mid = arr.length / 2\n\t    for\
    \ (i <- 0 until mid) {\n\t\tbuffer += (arr(i) - arr(arr.length - 1 - i)).abs\n\
    \t    }\n\t    result = buffer.filter(x => x != 0).min\n\t} else {\n\t    val\
    \ mid = arr.length / 2\n\t    for (i <- 0 until mid) {\n\t\tbuffer += (arr(i)\
    \ - arr(arr.length - 1 - i)).abs\n\t    }\n\t    result = buffer.filter(x => x\
    \ != 0).min\n\t}\n\treturn result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpmxo7tv4w.scala:23:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m\t    }\n\e[31m\e[31m   |\e[0m\t    ^\e[0m\n\e[31m  \
    \ |\e[0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\
    \e[31m   |\e[0m   Previous indent : 2 tabs\n\e[31m   |\e[0m   Latest indent  \
    \ : 1 tab, 4 spaces\n\e[31m\e[31m-- Error: /tmp/tmpmxo7tv4w.scala:29:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m\t    }\n\e[31m\e[31m   |\e[0m\t    ^\e[0m\n\e[31m  \
    \ |\e[0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\
    \e[31m   |\e[0m   Previous indent : 2 tabs\n\e[31m   |\e[0m   Latest indent  \
    \ : 1 tab, 4 spaces\n\e[31m\e[31m-- Error: /tmp/tmpmxo7tv4w.scala:33:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab\n\e[31m   |\e[0m   Latest indent   : 4\
    \ spaces\n3 errors found\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def recurse(list : List[Long], changes : Long) : Long =\
    \ {\n            if (list.length == 0) changes\n            else {\n         \
    \       val mid = list.length / 2\n                if (list.length % 2 == 0) {\n\
    \                    val left = list.slice(0, mid)\n                    val right\
    \ = list.slice(mid, list.length).reverse\n                    recurse(left.tail,\
    \ changes + abs(left.head - right.head))\n                } else {\n         \
    \           val left = list.slice(0, mid)\n                    val right = list.slice(mid\
    \ + 1, list.length).reverse\n                    recurse(left.tail, changes +\
    \ abs(left.head - right.head))\n                }\n            }\n        }\n\
    \        recurse(arr, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxu3meij9.scala:33)\n\tat Problem.main(tmpxu3meij9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010122
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val dp = Array.ofDim[Long](n,\
    \ n)\n        for (l <- 2 to n) {\n            for (i <- 0 to n - l) {\n     \
    \           val j = i + l - 1\n                dp(i)(j) = dp(i + 1)(j - 1) + abs(arr(i)\
    \ - arr(j))\n                if (l % 2 == 0) {\n                    dp(i)(j) =\
    \ min(dp(i)(j), dp(i + 2)(j) + abs(arr(i) - arr(i + 1)))\n                   \
    \ dp(i)(j) = min(dp(i)(j), dp(i)(j - 2) + abs(arr(j) - arr(j - 1)))\n        \
    \        }\n            }\n        }\n        dp(0)(n - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 8\n\tat Problem$.smallestChange$$anonfun$1$$anonfun$1(tmpneph8akf.scala:23)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange$$anonfun$1(tmpneph8akf.scala:25)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange(tmpneph8akf.scala:26)\n\
    \tat Problem$.main(tmpneph8akf.scala:30)\n\tat Problem.main(tmpneph8akf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010124
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        if (n == 0) return 0\n     \
    \   val front = new Array[Int](n)\n        val back = new Array[Int](n)\n    \
    \    front(0) = 0\n        for (i <- 1 until n) {\n            front(i) = (front(i\
    \ - 1) + (if (arr(i) == arr(i - 1)) 0 else 1))\n        }\n        back(n - 1)\
    \ = 0\n        for (i <- (n - 2) to 0 by -1) {\n            back(i) = (back(i\
    \ + 1) + (if (arr(i) == arr(i + 1)) 0 else 1))\n        }\n        var min = 1000000\n\
    \        for (i <- 0 until n) {\n            val change = front(i) + back(i)\n\
    \            if (change < min) min = change\n        }\n        return min\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpupvqw5i2.scala:35)\n\tat Problem.main(tmpupvqw5i2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val length = arr.length\n        val table = Array.ofDim[Long](length,\
    \ length)\n        for (i <- 1 until length) {\n            table(i)(i) = 0\n\
    \            table(i)(i - 1) = 0\n        }\n        for (size <- 2 until length)\
    \ {\n            for (i <- 0 until length - size) {\n                val j = i\
    \ + size\n                table(i)(j) = min(table(i + 1)(j) + 1, table(i)(j -\
    \ 1) + 1)\n                table(i)(j) = min(table(i)(j), table(i + 1)(j - 1)\
    \ + (if (arr(i) == arr(j)) 0 else 1))\n            }\n        }\n        table(0)(length\
    \ - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy5c3n645.scala:31)\n\tat Problem.main(tmpy5c3n645.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val middle = arr.length / 2\n        val left = arr.slice(0,\
    \ middle)\n        val right = arr.slice(middle + arr.length % 2, arr.length)\n\
    \        val l = left.size\n        val r = right.size\n        val memo = Map[(Int,\
    \ Int), Long]()\n        def recurse(i : Int, j : Int) : Long = {\n          \
    \  if (i == l || j == r) 1l.toLong\n            else if (memo.contains((i, j)))\
    \ memo((i, j))\n            else {\n                var min = Long.MaxValue\n\
    \                if (left(i) == right(j)) min = recurse(i + 1, j + 1)\n      \
    \          else {\n                    val list = List(recurse(i + 1, j), recurse(i,\
    \ j + 1), recurse(i + 1, j + 1))\n                    min = list.min\n       \
    \         }\n                memo((i, j)) = min\n                min\n       \
    \     }\n        }\n        recurse(0, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp24xz91d1.scala:38)\n\tat Problem.main(tmp24xz91d1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var k = 0l\n        var f = 0l\n        while (f != arr.length)\
    \ {\n            if (arr(f.toInt) != arr(arr.length - 1 - f.toInt)) k += 1\n \
    \           f += 1\n        }\n        if (k == 0) return 0\n        if (k ==\
    \ 2) return 1\n        k / 2 + 1\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzysybnbb.scala:26)\n\tat Problem.main(tmpzysybnbb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010129
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val L = Array.ofDim[Long](n\
    \ + 1, n + 1)\n        for (i <- 0 to n) {\n            L(i)(i) = 0\n        }\n\
    \        for (cl <- 2 to n) {\n            for (i <- 0 to n - cl) {\n        \
    \        val j = i + cl - 1\n                if (arr(i) == arr(j)) L(i)(j) = L(i\
    \ + 1)(j - 1)\n                else L(i)(j) = 1 + min(L(i)(j - 1), L(i + 1)(j))\n\
    \            }\n        }\n        L(0)(n - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqg571_z6.scala:30)\n\tat Problem.main(tmpqg571_z6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010129
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // >>> small = (1, arr)\n        val small = (1l, arr)\n\
    \        // >>> big = (2, arr)\n        val big = (2l, arr)\n        // >>> sort\
    \ = True\n        val sort = true\n        // >>> for i in range(len(arr) // 2):\n\
    \        //     if arr[i] != arr[-i - 1]:\n        //         sort = False\n \
    \       //         break\n        for (i <- 0 to arr.length - 1) {\n         \
    \   if (arr(i) != arr(arr.length - i - 1)) {\n                sort = false\n \
    \               // >>> break\n                break\n            }\n        }\n\
    \        // >>> if sort:\n        //     return 0\n        if (sort) 0l\n    \
    \    // >>> for i in range(len(arr) // 2):\n        //     if arr[i] == arr[-i\
    \ - 1]:\n        //         small = (min(small[0], big[0]), small[1][:-1])\n \
    \       //         big = (big[0], big[1][:-1])\n        //     else:\n       \
    \ //         small = (small[0], small[1][:-1])\n        //         big = (min(small[0]\
    \ + 1, big[0]), big[1][:-1])\n        //     if len(small[1]) == 1:\n        //\
    \         break\n        for (i <- 0 to arr.length - 1) {\n            if (arr(i)\
    \ == arr(arr.length - i - 1)) {\n                small = (min(small._1, big._1),\
    \ small._2.slice(0, small._2.length - 1))\n                big = (big._1, big._2.slice(0,\
    \ big._2.length - 1))\n            } else {\n                small = (small._1,\
    \ small._2.slice(0, small._2.length - 1))\n                big = (min(small._1\
    \ + 1, big._1), big._2.slice(0, big._2.length - 1))\n            }\n         \
    \   if (small._2.length == 1) {\n                // >>> break\n              \
    \  break\n            }\n        }\n        // >>> return small\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpk78265z1.scala:27:21 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                sort = \e[31mfalse\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val sort\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk78265z1.scala:29:16\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpk78265z1.scala:46:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m46 |\e[0m                small\
    \ = (min(small._1, big._1), small._2.slice(\e[31m0\e[0m, small._2.length - \e\
    [31m1\e[0m))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val small\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpk78265z1.scala:47:20 -----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                big = (big._1, big._2.slice(\e[31m0\e\
    [0m, big._2.length - \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val big\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpk78265z1.scala:49:22 -----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m                small = (small._1, small._2.slice(\e\
    [31m0\e[0m, small._2.length - \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m          \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Reassignment to val small\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpk78265z1.s"
  stdout: ''
  timestamp: 1660010125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // What is the recursive structure\n        // The list\
    \ is either 1 element or 2 elements, return 0\n        // The list has more than\
    \ two elements, it is going to be in one of\n        // two forms:\n        //\
    \ 1. arr(0) != arr(arr.length - 1)\n        //    1.1 remove arr(0) and check\
    \ the rest of the list\n        //    1.2 remove arr(arr.length - 1) and check\
    \ the rest of the list\n        // 2. arr(0) == arr(arr.length - 1)\n        //\
    \    2.1 check the rest of the list\n        // What are the end cases?\n    \
    \    // The list is either 1 element or 2 elements, return 0\n        def f(arr\
    \ : List[Long]) : Long = {\n            if (arr.length <= 2) return 0\n      \
    \      if (arr(0) != arr(arr.length - 1)) {\n                min(f(arr.tail),\
    \ f(arr.init)) + 1\n            } else {\n                f(arr.init.tail)\n \
    \           }\n        }\n        f(arr)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7jpeuf94.scala:37)\n\tat Problem.main(tmp7jpeuf94.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010129
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        return 0l\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxjflj74i.scala:18)\n\tat Problem.main(tmpxjflj74i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val l = arr.length\n        val dp = Array.ofDim[Long](l,\
    \ l)\n        for (d <- 0 until l) {\n            for (i <- 0 until l - d) {\n\
    \                val j = i + d\n                if (i == j) dp(i)(j) = 0\n   \
    \             else if (i + 1 == j) dp(i)(j) = if (arr(i) == arr(j)) 0 else 1\n\
    \                else dp(i)(j) = min(dp(i + 1)(j) + 1, dp(i)(j - 1) + 1)\n   \
    \         }\n        }\n        dp(0)(l - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp15s7vzlh.scala:28)\n\tat Problem.main(tmp15s7vzlh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010130
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def getMinor(arr : List[Long]) : List[Long] = {\n      \
    \      if (arr.size == 1) return List[Long]()\n            if (arr.size == 2)\
    \ return List[Long](arr(0))\n            else return List[Long](arr(0)) ::: getMinor(arr.slice(1,\
    \ arr.size - 1)) ::: List[Long](arr(arr.size - 1))\n        }\n        if (arr.size\
    \ == 1) return 0\n        if (arr.size == 2) return 0\n        if (arr.size ==\
    \ 3) return 1\n        var mm = 0l\n        val range = 1 to (arr.size - 1)\n\
    \        for (i <- range) {\n            val l = arr.slice(0, i)\n           \
    \ val r = arr.slice(i, arr.size)\n            val minorLeft = getMinor(l)\n  \
    \          val minorRight = getMinor(r)\n            val diff = minorLeft.zip(minorRight).map(x\
    \ => abs(x._1 - x._2)).sum\n            if (mm == 0) mm = diff\n            else\
    \ if (diff < mm) mm = diff\n        }\n        return mm\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcnv1yn_h.scala:37)\n\tat Problem.main(tmpcnv1yn_h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010131
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        // dp[i][j] = minimum changes\
    \ necessary to make the sequence from a(i) to a(j) palindromic\n        val dp\
    \ = Array.ofDim[Long](n, n)\n        // compute dp values\n        // dp[i][j]\
    \ = 0 if i == j\n        // dp[i][j] = dp[i + 1][j - 1] if a(i) == a(j)\n    \
    \    // dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]) if a(i) != a(j)\n     \
    \   // dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]) for 0 <= k < j - i\n\
    \        for (diff <- 1 until n) {\n            for (i <- 0 until n - diff) {\n\
    \                val j = i + diff\n                if (arr(i) == arr(j)) dp(i)(j)\
    \ = dp(i + 1)(j - 1)\n                else dp(i)(j) = 1 + min(dp(i + 1)(j), dp(i)(j\
    \ - 1))\n                for (k <- i until j) {\n                    dp(i)(j)\
    \ = min(dp(i)(j), dp(i)(k) + dp(k + 1)(j))\n                }\n            }\n\
    \        }\n        // answer is dp[0][n - 1]\n        dp(0)(n - 1)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9b1qfa4d.scala:37)\n\tat Problem.main(tmp9b1qfa4d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010130
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      def helper(arr : List[Long], i : Int, j : Int, m : Int) :\
    \ Long = {\n        if (j < m) 0l\n        else if (i >= m) arr(j) - arr(m - i\
    \ - 1)\n        else {\n          val x = helper(arr, i + 1, j - 1, m)\n     \
    \     val y = helper(arr, i, j - 1, m)\n          val z = helper(arr, i + 1, j,\
    \ m)\n          min(min(x, y), z)\n        }\n      }\n      val m = arr.length\
    \ / 2\n      helper(arr, 0, arr.length - 1, m)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.helper$1(tmpdiks66_8.scala:17)\n\tat Problem$.helper$1(tmpdiks66_8.scala:21)\n\
    \tat Problem$.helper$1(tmpdiks66_8.scala:19)\n\tat Problem$.helper$1(tmpdiks66_8.scala:19)\n\
    \tat Problem$.helper$1(tmpdiks66_8.scala:19)\n\tat Problem$.smallestChange(tmpdiks66_8.scala:26)\n\
    \tat Problem$.main(tmpdiks66_8.scala:29)\n\tat Problem.main(tmpdiks66_8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010130
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        //val palindrome = new HashMap[List[Long], Long]()\n   \
    \     def smallestChange0(arr : List[Long]) : Long = {\n            if (arr.length\
    \ <= 1) {\n                return 0l.toLong\n            }\n            if (arr.length\
    \ == 2) {\n                return (arr(0) != arr(1)).toLong\n            }\n \
    \           /*if (palindrome.contains(arr)) {\n                return palindrome(arr)\n\
    \            }*/\n            //println(arr)\n            val left = arr.init\n\
    \            val right = arr.tail\n            val r1 = (arr(0) != arr(arr.length\
    \ - 1)).toLong + smallestChange0(left) + smallestChange0(right)\n            val\
    \ r2 = smallestChange0(left) + 1l.toLong\n            val r3 = smallestChange0(right)\
    \ + 1l.toLong\n            val result = List(r1, r2, r3).min\n            //palindrome(arr)\
    \ = result\n            result\n        }\n        smallestChange0(arr)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1yj9mtfi.scala:21:42 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mreturn\e[0m (arr(\e[31m0\e[0m)\
    \ != arr(\e[31m1\e[0m)).toLong\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of Boolean, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp1yj9mtfi.scala:29:53 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mr1\e[0m = (arr(\e[31m0\e\
    [0m) != arr(arr.length - \e[31m1\e[0m)).toLong + smallestChange0(left) + smallestChange0(right)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of Boolean, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010130
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val arrReverse = arr.reverse\n\
    \        val dp = Array.ofDim[Long](n + 1, n + 1)\n        for (i <- 0 to n) {\n\
    \            for (j <- 0 to n) {\n                if (i == 0 || j == 0) dp(i)(j)\
    \ = 0\n                else if (arr(i - 1) == arrReverse(j - 1)) dp(i)(j) = dp(i\
    \ - 1)(j - 1) + 1\n                else dp(i)(j) = max(dp(i - 1)(j), dp(i)(j -\
    \ 1))\n            }\n        }\n        n - dp(n)(n)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsd3_f2c_.scala:28)\n\tat Problem.main(tmpsd3_f2c_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010131
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Fill Up this function body\n        // `arr` is of type\
    \ List[Long]\n        // `return` of type Long\n        if (arr.length == 0) return\
    \ 0\n        if (arr.length == 1) return 1\n        if (arr.length == 2) return\
    \ if (arr(0) == arr(1)) 0 else 1\n        if (arr.length == 3) return if (arr(0)\
    \ == arr(2)) 0 else 2\n        // println(arr.mkString(\",\"))\n        def solve(left\
    \ : Int, right : Int) : Long = {\n            // println(left, right)\n      \
    \      if (left == right) return 0\n            if (left + 1 == right) return\
    \ if (arr(left) == arr(right)) 0 else 1\n            if (left + 2 == right) return\
    \ if (arr(left) == arr(right)) 0 else if (arr(left) == arr(right - 1) || arr(left\
    \ + 1) == arr(right)) 1 else 2\n            if (arr(left) == arr(right)) solve(left\
    \ + 1, right - 1)\n            else min(solve(left + 1, right), solve(left, right\
    \ - 1)) + 1\n        }\n        solve(0, arr.length - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyvc8br6n.scala:34)\n\tat Problem.main(tmpyvc8br6n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010131
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var arr2 = arr\n        if (arr.length == 0) return 0l\n\
    \        if (arr.length == 1) return 0l\n        if (arr.length == 2) return 1l\n\
    \        if (arr.length == 3) return 1l\n        var max = 0l\n        for (i\
    \ <- 0 until arr.length) {\n            if (arr(i) > max) max = arr(i)\n     \
    \   }\n        var right = max\n        var left = 0l\n        var leftDiff =\
    \ 0l\n        var rightDiff = 0l\n        while (right - left > 2) {\n       \
    \     if (arr(leftDiff.toInt) == arr(rightDiff.toInt)) {\n                left\
    \ = arr(leftDiff.toInt)\n                right = arr(rightDiff.toInt)\n      \
    \          leftDiff += 1\n                rightDiff -= 1\n            }\n    \
    \        else if (arr(leftDiff.toInt) < arr(rightDiff.toInt)) {\n            \
    \    left = arr(leftDiff.toInt)\n                leftDiff += 1\n            }\n\
    \            else {\n                right = arr(rightDiff.toInt)\n          \
    \      rightDiff -= 1\n            }\n        }\n        if (right == left) {\n\
    \            if (right - 1 == arr(rightDiff.toInt)) {\n                return\
    \ leftDiff + rightDiff + 2\n            }\n            else {\n              \
    \  return leftDiff + rightDiff + 1\n            }\n        }\n        return -1l\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.smallestChange(tmpcxgj_gu1.scala:45)\n\tat Problem$.main(tmpcxgj_gu1.scala:55)\n\
    \tat Problem.main(tmpcxgj_gu1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010131
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      // Make DP of palindromes, where DP[i][j] is true if i - j\
    \ is a palindrome\n      val DP = Array.ofDim[Boolean](arr.length, arr.length)\n\
    \      // Fill DP\n      for (i <- 0 until arr.length) {\n        DP(i)(i) = true\n\
    \        DP(i)(i + 1) = arr(i) == arr(i + 1)\n      }\n      // DP function\n\
    \      def DPF(i : Int, j : Int) : Boolean = {\n        DP(i)(j) = if (i == j)\
    \ true else if (i + 1 == j) arr(i) == arr(j) else arr(i) == arr(j) && DPF(i +\
    \ 1, j - 1)\n        DP(i)(j)\n      }\n      // Fill DP\n      for (i <- 0 until\
    \ arr.length) {\n        for (j <- 0 until arr.length) {\n          if (i + j\
    \ + 1 < arr.length) DPF(i, i + j + 1)\n        }\n      }\n      // Fill DP(2)\n\
    \      val DP2 = Array.ofDim[Long](arr.length, arr.length)\n      for (i <- 0\
    \ until arr.length) {\n        DP2(i)(i) = 0\n        DP2(i)(i + 1) = if (DP(i)(i\
    \ + 1)) 0 else 1\n      }\n      // Function for DP(2)\n      def DPF2(i : Int,\
    \ j : Int) : Long = {\n        DP2(i)(j) = if (i == j) 0 else {\n          val\
    \ x = min(DPF2(i + 1, j) + 1, DPF2(i, j - 1) + 1)\n          if (DP(i)(j)) min(x,\
    \ DPF2(i + 1, j - 1)) else x\n        }\n        DP2(i)(j)\n      }\n      //\
    \ Fill DP(2)\n      for (i <- 0 until arr.length) {\n        for (j <- 0 until\
    \ arr.length) {\n          if (i + j + 1 < arr.length) DPF2(i\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptck702g8.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptck702g8.scala:64:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m64 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- Error: /tmp/tmptck702g8.scala:50:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m50 |\e[0m       \
    \   \e[33mif\e[0m (i + j + \e[31m1\e[0m < arr.length) DPF2(i\n\e[31m\e[31m   |\e\
    [0m                                      ^^^^^^\e[0m\n\e[31m   |\e[0m missing\
    \ argument for parameter j of \e[33mmethod\e[0m \e[35mDPF2\e[0m: (i: Int, j: Int):\
    \ Long\n\e[33m\e[33m-- Warning: /tmp/tmptck702g8.scala:52:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m52 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010129
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // This can be optimised using dynamic programming\n   \
    \     // Every palindrome has a 'centre' where either 0 elements or 2 elements\
    \ are to the left of the 'centre'.\n        // It is possible to compute the number\
    \ of elements that need to be changed by working outwards from the centre.\n \
    \       // This can be done in O(n^2) time. However, this solution has been a\
    \ bit lazy and done in O(n^3) instead.\n        // There will be 2n - 1 centres\
    \ to check.\n        // For each centre:\n        // Work outwards to find the\
    \ number of elements that need to be changed.\n        // Record the minimum number\
    \ of elements that need to be changed.\n        var minCost = Int.MaxValue\n \
    \       for (centre <- 0 to arr.length - 1) {\n            var cost = 0\n    \
    \        for (left <- centre - 1 to 0 by -1) {\n                if (arr(left)\
    \ != arr(centre - left)) cost += 1\n            }\n            for (right <- centre\
    \ + 1 to arr.length - 1) {\n                if (arr(right) != arr(2 * centre -\
    \ right)) cost += 1\n            }\n            if (cost < minCost) minCost =\
    \ cost\n        }\n        for (centre <- 0 to arr.length - 2) {\n           \
    \ var cost = 0\n            for (left <- centre to 0 by -1) {\n              \
    \  if (arr(left) != arr(centre - left)) cost += 1\n            }\n           \
    \ for (right <- centre + 1 to arr.length - 1) {\n                if (arr(right)\
    \ != arr(2 * centre + 1 - right)) cost += 1\n            }\n            if (cost\
    \ < minCost) minCost = cost\n        }\n        minCost.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.smallestChange$$anonfun$1$$anonfun$2(tmp1s13d203.scala:30)\n\tat\
    \ scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\t\
    at scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange$$anonfun$1(tmp1s13d203.scala:31)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.smallestChange(tmp1s13d203.scala:33)\n\
    \tat Problem$.main(tmp1s13d203.scala:47)\n\tat Problem.main(tmp1s13d203.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.too"
  stdout: ''
  timestamp: 1660010132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.size <= 1) return 0\n        val palindrome = Array.ofDim[Long](arr.size,\
    \ arr.size)\n        for (gap <- 0 to arr.size - 1) {\n            for (left <-\
    \ 0 to arr.size - gap - 1) {\n                val right = left + gap\n       \
    \         if (gap == 0) palindrome(left)(right) = 0\n                else if (gap\
    \ == 1) palindrome(left)(right) = 1 - (arr(left) == arr(right))\n            \
    \    else {\n                    val diff = arr(left) - arr(right)\n         \
    \           palindrome(left)(right) = min(palindrome(left + 1)(right) + 1, palindrome(left)(right\
    \ - 1) + 1)\n                    if (diff == 0) palindrome(left)(right) = min(palindrome(left)(right),\
    \ palindrome(left + 1)(right - 1))\n                    else palindrome(left)(right)\
    \ = min(palindrome(left)(right), palindrome(left + 1)(right - 1) + 1)\n      \
    \          }\n            }\n        }\n        palindrome(0)(arr.size - 1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpg481len4.scala:21:63 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (gap ==\
    \ \e[31m1\e[0m) palindrome(left)(right) = \e[31m1\e[0m - (arr(left) == arr(right))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^^^\e[0m\n\e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x:\
    \ Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\
    \e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e\
    [0m match arguments (Boolean)\n1 error found\n"
  stdout: ''
  timestamp: 1660010129
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def inner(arr : List[Long], count : Long) : Long = {\n \
    \           if (arr.length <= 1) count\n            else if (arr.head == arr.last)\
    \ inner(arr.drop(1).dropRight(1), count)\n            else inner(arr.drop(1),\
    \ count + 1)\n        }\n        inner(arr, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4aq9f30s.scala:23)\n\tat Problem.main(tmp4aq9f30s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010132
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def helper(l : List[Long], r : List[Long], result : Long)\
    \ : Long = {\n            if (l.length == 0) result\n            else if (l.head\
    \ == r.head) helper(l.tail, r.tail, result)\n            else if (l.length ==\
    \ 1) result + 1\n            else {\n                val minimum1 = helper(l.tail,\
    \ r.tail, result + 1)\n                val minimum2 = helper(l.tail, r.init, result\
    \ + 1)\n                min(minimum1, minimum2)\n            }\n        }\n  \
    \      if (arr.length == 0) 0\n        else helper(arr, arr.reverse, 0)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm6fxjyrr.scala:29)\n\tat Problem.main(tmpm6fxjyrr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val size = arr.size\n        def max(a : Int, b : Int) :\
    \ Int = if (a > b) a else b\n        def helper(i : Int, j : Int) : Long = {\n\
    \            if (i == j) 0\n            else if (i + 1 == j) {\n             \
    \   if (arr(i) == arr(j)) 0\n                else 1\n            }\n         \
    \   else {\n                if (arr(i) == arr(j)) helper(i + 1, j - 1)\n     \
    \           else 1 + max(helper(i + 1, j), helper(i, j - 1))\n            }\n\
    \        }\n        helper(0, size - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpquxx1ugh.scala:25:35\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                \e[33melse\e\
    [0m \e[31m1\e[0m + max(helper(i + \e[31m1\e[0m, j), helper(i, j - \e[31m1\e[0m))\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Found:    Long\n\e[31m   |\e[0m       \
    \                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpquxx1ugh.scala:25:53 --------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                \e[33melse\e[0m \e[31m1\e[0m + max(helper(i\
    \ + \e[31m1\e[0m, j), helper(i, j - \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m    \
    \                                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                               Found:    Long\n\e[31m   |\e\
    [0m                                               Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def reverse(arr : List[Long]) : List[Long] = {\n       \
    \     if (arr.length == 0) arr\n            else reverse(arr.tail) :+ arr.head\n\
    \        }\n        def recur(arr : List[Long], reverseArr : List[Long], min :\
    \ Long) : Long = {\n            if (arr.length == 0) min\n            else if\
    \ (arr.head == reverseArr.head) recur(arr.tail, reverseArr.tail, min)\n      \
    \      else {\n                val m1 = recur(arr.tail, reverseArr.tail, min +\
    \ abs(arr.head - reverseArr.head))\n                val m2 = recur(arr.tail, reverseArr,\
    \ min + 1)\n                val m3 = recur(arr, reverseArr.tail, min + 1)\n  \
    \              min(min(m1, m2), m3)\n            }\n        }\n        recur(arr,\
    \ reverse(arr), arr.length)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpqofelgu5.scala:26:16 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                min(min(m1, m2), m3)\n\e[31m\e[31m  \
    \ |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m                \e[33mparameter\e\
    [0m \e[35mmin\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E050] Type Error: /tmp/tmpqofelgu5.scala:26:20 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                min(min(m1, m2), m3)\n\e[31m\e[31m  \
    \ |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m                    \e[33mparameter\e\
    [0m \e[35mmin\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010130
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val lengths = Array.ofDim[Long](n,\
    \ n)\n        val deltas = Array.ofDim[Long](n, n)\n        for (i <- 0 until\
    \ n) lengths(i)(i) = 1\n        for (i <- 0 until n - 1) {\n            lengths(i)(i\
    \ + 1) = 2\n            deltas(i)(i + 1) = abs(arr(i) - arr(i + 1))\n        }\n\
    \        for (l <- 3 to n) {\n            for (i <- 0 to n - l) {\n          \
    \      val j = i + l - 1\n                lengths(i)(j) = lengths(i + 1)(j - 1)\
    \ + 2\n                deltas(i)(j) = deltas(i + 1)(j - 1) + abs(arr(i) - arr(j))\n\
    \            }\n        }\n        val min = new Array[Long](n)\n        for (i\
    \ <- 0 until n) {\n            min(i) = Long.MaxValue\n            for (j <- 0\
    \ to i) {\n                val delta = deltas(j)(i) + 2 * (n - lengths(j)(i))\n\
    \                if (delta < min(i)) min(i) = delta\n            }\n        }\n\
    \        min(n - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpujr1go4q.scala:41)\n\tat Problem.main(tmpujr1go4q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val a = Array[Long](2l, 4l, 6l, 8l, 10l, 12l, 14l, 16l,\
    \ 18l, 20l, 22l, 24l, 26l, 28l, 30l, 32l, 34l, 36l, 38l, 40l, 42l, 44l, 46l, 48l,\
    \ 50l, 52l, 54l, 56l, 58l, 60l, 62l, 64l, 66l, 68l, 70l, 72l, 74l, 76l, 78l, 80l,\
    \ 82l, 84l, 86l, 88l, 90l, 92l, 94l, 96l, 98l, 100l, 102l, 104l, 106l, 108l, 110l,\
    \ 112l, 114l, 116l, 118l, 120l, 122l, 124l, 126l, 128l, 130l, 132l, 134l, 136l,\
    \ 138l, 140l, 142l, 144l, 146l, 148l, 150l, 152l, 154l, 156l, 158l, 160l, 162l,\
    \ 164l, 166l, 168l, 170l, 172l, 174l, 176l, 178l, 180l, 182l, 184l, 186l, 188l,\
    \ 190l, 192l, 194l, 196l, 198l, 200l, 202l, 204l, 206l, 208l, 210l, 212l, 214l,\
    \ 216l, 218l, 220l, 222l, 224l, 226l, 228l, 230l, 232l, 234l, 236l, 238l, 240l,\
    \ 242l, 244l, 246l, 248l, 250l, 252l, 254l, 256l, 258l, 260l, 262l, 264l, 266l,\
    \ 268l, 270l, 272l, 274l, 276l, 278l, 280l, 282l, 284l, 286l, 288l, 290l, 292l,\
    \ 294l, 296l, 298l, 300l, 302l, 304l, 306l, 308l, 310l, 312l, 314l, 316l, 318l,\
    \ 320l, 322l, 324l, 326l, 328l, 330l, 332l, 334l, 336l\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyrf12ef0.scala:16:4 ----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpyrf12ef0.scala:16:5 ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010134
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.indices.map(i => if (arr(i) != arr(arr.length - 1 -\
    \ i)) 1 else 0).sum / 2\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010139
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val dp = Array.ofDim[Long](n,\
    \ n)\n        for (d <- 0 until n) {\n            for (i <- 0 until n - d) {\n\
    \                val j = i + d\n                if (i == j) dp(i)(j) = 0\n   \
    \             else if (i + 1 == j) dp(i)(j) = (arr(i) - arr(j)).abs\n        \
    \        else {\n                    dp(i)(j) = min(dp(i + 1)(j) + (arr(i) - arr(i\
    \ + 1)).abs, dp(i)(j - 1) + (arr(j) - arr(j - 1)).abs)\n                }\n  \
    \          }\n        }\n        dp(0)(n - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcq6ojz40.scala:30)\n\tat Problem.main(tmpcq6ojz40.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010140
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length % 2 == 0) {\n            var start = 0\n\
    \            var end = arr.length - 1\n            var change : Long = 0\n   \
    \         while (start < end) {\n                if (arr(start) != arr(end)) change\
    \ += 1\n                start += 1\n                end -= 1\n            }\n\
    \            change\n        } else {\n            var start = 0\n           \
    \ var end = arr.length - 1\n            var change : Long = 0\n            while\
    \ (start < end) {\n                if (arr(start) != arr(end)) change += 1\n \
    \               start += 1\n                end -= 1\n            }\n        \
    \    change\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010139
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var l = arr.length\n        var count = 0l\n        for\
    \ (i <- 0 until l/2) {\n            if (arr(i) != arr(l - i - 1)) count += 1\n\
    \        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010140
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var array = arr.toArray\n        var count = 0l\n      \
    \  for (i <- 0 to array.length / 2) {\n            if (array(i) != array(array.length\
    \ - 1 - i)) {\n                count += 1\n            }\n        }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplrtdi3r3.scala:25)\n\tat Problem.main(tmplrtdi3r3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010141
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def recurse(a : List[Long], b : List[Long], c : Long) :\
    \ Long = {\n            //println(\"a = \" + a)\n            //println(\"b = \"\
    \ + b)\n            //println(\"c = \" + c)\n            (a, b) match {\n    \
    \            case (a :: as, b :: bs) => if (a == b) recurse(as, bs, c) else if\
    \ (c < 0) -1 else recurse(as, bs, c - 1)\n                case (a :: as, b) =>\
    \ if (c < 0) -1 else recurse(as, b, c - 1)\n                case (a, b :: bs)\
    \ => if (c < 0) -1 else recurse(a, bs, c - 1)\n                case (a, b) =>\
    \ c\n            }\n        }\n        if (arr.length == 0) 0 else recurse(arr,\
    \ arr.reverse, Long.MaxValue)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6rbbvgo4.scala:29)\n\tat Problem.main(tmp6rbbvgo4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010140
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var minCost = 0l\n        var originalList = arr\n     \
    \   var reverseList = originalList.reverse\n        for (i <- 0 until originalList.length)\
    \ {\n            if (originalList(i) != reverseList(i)) {\n                minCost\
    \ += 1\n            }\n        }\n        if (minCost == 0) {\n            return\
    \ 0\n        }\n        minCost /= 2\n        minCost\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010140
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // This can be done in O(n).\n        // If you change one\
    \ element, in order to make it palindromic, you need to change (at least)\n  \
    \      // floor(n / 2) elements, where n is the size of the list.\n        //\
    \ In other words, we can recursively check if the first element should be changed\
    \ to the last,\n        // then check if the second element should be changed\
    \ to the second last, and so on.\n        // The floor(n / 2)th element is the\
    \ middle element if n is odd; the list is palindromic.\n        // The (floor(n\
    \ / 2) - 1)th element is the middle element if n is even; the list is palindromic.\n\
    \        // Otherwise, we need to change the first element to the last element\
    \ and then recursively check\n        // the (arr.tail.init, 0) list.\n      \
    \  // We repeat this process with the (arr.tail, 1) list, the (arr.init, 1) list,\
    \ the (arr.tail.init, 0) list,\n        // and so on.\n        // If any of these\
    \ is smaller than the other, then the other three must be smaller than it, since\n\
    \        // the middle element of (arr.tail.init, 0) is one step closer to the\
    \ middle element of (arr, 0) than\n        // the middle element of (arr.tail,\
    \ 1) is.\n        // If (arr.tail.init, 0) is palindromic, then the middle element\
    \ of (arr.tail.init, 0) must be\n        // equal to the middle element of (arr,\
    \ 0) and the other elements do not matter.\n        // So we check (arr.tail.init,\
    \ 0) as our first step.\n        // TODO: can this be done in O(n / 2) time?\n\
    \        val n = arr.length\n        val palindromic = (arr.head == arr.last)\n\
    \        // If arr.tail.init is palindromic, then our answer is 0; the list is\
    \ already palindromic.\n        // Otherwise, our answer is the smaller of the\
    \ two possible answers.\n        if (palindromic) {\n            0\n        }\
    \ else {\n            min(smallest\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1687rk5d.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1687rk5d.scala:54:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m54 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp1687rk5d.scala:40:16 ------------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m            min(smallest\n\e[31m\e[31m   |\e[0m               \
    \ ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: smallest\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1687rk5d.scala:53:1 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmp1687rk5d.scala:42:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m42 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010139
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        null\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1d21ommb.scala:15:8\
    \ ---------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[31mnull\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^\e[0m\n\e[31m   |\e[0m        Found:    Null\n\e\
    [31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010093
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val dp = Array.ofDim[Long](arr.length, arr.length)\n   \
    \     for (i <- 0 until arr.length; j <- 0 until arr.length) {\n            dp(i)(j)\
    \ = -1l\n        }\n        def f(start : Int, end : Int) : Long = {\n       \
    \     if (dp(start)(end) != -1l) return dp(start)(end)\n            val res =\
    \ if (start >= end) 0 else {\n                if (arr(start) == arr(end)) f(start\
    \ + 1, end - 1)\n                else {\n                    min(f(start + 1,\
    \ end), f(start, end - 1)) + 1\n                }\n            }\n           \
    \ dp(start)(end) = res\n            res\n        }\n        f(0, arr.length -\
    \ 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu0pn1eww.scala:33)\n\tat Problem.main(tmpu0pn1eww.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010142
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def inner(arr : List[Long], value : Long) : Long = {\n \
    \           arr match {\n                case x :: xs =>\n                   \
    \ if (x == value) inner(xs, value + 1)\n                    else inner(xs, value)\n\
    \                case Nil =>\n                    value - 1\n            }\n \
    \       }\n        val sorted = arr.sorted\n        inner(sorted, sorted.head)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnbilh8yd.scala:28)\n\tat Problem.main(tmpnbilh8yd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010142
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def findSmallestChange(arr : List[Long], i : Int, j : Int,\
    \ count : Long) : Long = {\n            if (i >= j) count\n            else if\
    \ (arr(i) == arr(j)) findSmallestChange(arr, i + 1, j - 1, count)\n          \
    \  else {\n                val min1 = findSmallestChange(arr, i + 1, j, count\
    \ + 1)\n                val min2 = findSmallestChange(arr, i, j - 1, count + 1)\n\
    \                if (min1 < min2) min1 else min2\n            }\n        }\n \
    \       findSmallestChange(arr, 0, arr.length - 1, 0)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpndz2n5up.scala:27)\n\tat Problem.main(tmpndz2n5up.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010141
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.length match {\n            case 0 => 0\n          \
    \  case 1 => 0\n            case 2 => if (arr(0) == arr(1)) 0 else 1\n       \
    \     case _ =>\n                val mid = arr.length / 2\n                if\
    \ (arr.length % 2 == 0) {\n                    val first = arr.slice(0, mid)\n\
    \                    val second = arr.slice(mid, arr.length).reverse\n       \
    \             val firstLongestPalindrome = longestPalindromeAtIndex(first, 0)\n\
    \                    val secondLongestPalindrome = longestPalindromeAtIndex(second,\
    \ 0)\n                    val min1 = arr.length - firstLongestPalindrome - secondLongestPalindrome\n\
    \                    val firstLongestPalindrome2 = longestPalindromeAtIndex(first,\
    \ mid - 1)\n                    val secondLongestPalindrome2 = longestPalindromeAtIndex(second,\
    \ mid - 1)\n                    val min2 = arr.length - firstLongestPalindrome2\
    \ - secondLongestPalindrome2\n                    min(min1, min2)\n          \
    \      } else {\n                    val first = arr.slice(0, mid)\n         \
    \           val second = arr.slice(mid + 1, arr.length).reverse\n            \
    \        val firstLongestPalindrome = longestPalindromeAtIndex(first, 0)\n   \
    \                 val secondLongestPalindrome = longestPalindromeAtIndex(second,\
    \ 0)\n                    val min1 = arr.length - firstLongestPalindrome - secondLongestPalindrome\n\
    \                    val firstLongestPalindrome2 = longestPalindromeAtIndex(first,\
    \ mid)\n                    val secondLongestPalindrome2 = longestPalindromeAtIndex(second,\
    \ mid)\n                    val min2 = arr.length - firstLongestPalindrome2 -\
    \ secondLongestPalindrome2\n                    min(min1, min2)\n            \
    \    }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rox9hvh.scala:24:49 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    \e[33mval\e[0m \e[36mfirstLongestPalindrome\e\
    [0m = longestPalindromeAtIndex(first, \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                                              ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                     Not found: longestPalindromeAtIndex\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rox9hvh.scala:25:50\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    \e[33mval\e\
    [0m \e[36msecondLongestPalindrome\e[0m = longestPalindromeAtIndex(second, \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                                  ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Not found: longestPalindromeAtIndex\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rox9hvh.scala:27:50\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    \e[33mval\e\
    [0m \e[36mfirstLongestPalindrome2\e[0m = longestPalindromeAtIndex(first, mid -\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                  Not found: longestPalindromeAtIndex\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6rox9hvh.scala:28:51 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    \e[33mval\e[0m \e[36msecondLongestPalindrome2\e\
    [0m = longestPalindromeAtIndex(second, mid - \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Not found: longestPalindromeAtIndex\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rox9hvh."
  stdout: ''
  timestamp: 1660010137
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length;\n        var f = new Array[Array[Long]](n);\n\
    \        for (i <- 0 until n) {\n            f(i) = new Array[Long](n);\n    \
    \        for (j <- 0 until n) f(i)(j) = -1;\n        }\n        def go(i : Int,\
    \ j : Int) : Long = {\n            if (f(i)(j) != -1) return f(i)(j);\n      \
    \      var result = Long.MaxValue;\n            if (i == j) result = 0;\n    \
    \        else if (i > j) result = 0;\n            else if (i + 1 == j) result\
    \ = if (arr(i) == arr(j)) 0 else 1;\n            else {\n                if (arr(i)\
    \ == arr(j)) result = go(i + 1, j - 1);\n                else result = 1 + min(go(i\
    \ + 1, j), go(i, j - 1));\n            }\n            f(i)(j) = result;\n    \
    \        result;\n        }\n        go(0, n - 1);\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp42guwgzy.scala:37)\n\tat Problem.main(tmp42guwgzy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010142
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length % 2 == 0) {\n            val arr1 = arr.slice(0,\
    \ arr.length / 2)\n            val arr2 = arr.slice(arr.length / 2, arr.length).reverse\n\
    \            val diff = (arr1, arr2).zipped.map(_ - _).map(x => abs(x)).sum\n\
    \            diff / 2\n        } else {\n            val arr1 = arr.slice(0, arr.length\
    \ / 2)\n            val arr2 = arr.slice(arr.length / 2 + 1, arr.length).reverse\n\
    \            val diff = (arr1, arr2).zipped.map(_ - _).map(x => abs(x)).sum\n\
    \            diff / 2\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz71zuy6b.scala:28)\n\tat Problem.main(tmpz71zuy6b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010142
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def loop(arr : List[Long], acc : Long) : Long = {\n    \
    \        if (arr.length < 2) {\n                acc\n            } else {\n  \
    \              if (arr.head == arr.last) {\n                    loop(arr.tail.init,\
    \ acc)\n                } else {\n                    loop(arr.tail.init, acc\
    \ + 1)\n                }\n            }\n        }\n        loop(arr, 0)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010142
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def getChangeForSubArray(arr : List[Long], left : Int, right\
    \ : Int) : Long = {\n            var lCount = 0\n            var rCount = 0\n\
    \            while (left >= 0 && right < arr.length && arr(left) == arr(right))\
    \ {\n                left -= 1\n                right += 1\n            }\n  \
    \          if (left < 0) lCount = right - 1\n            else if (right >= arr.length)\
    \ rCount = arr.length - left - 1\n            else {\n                lCount =\
    \ (right - left - 1) / 2\n                rCount = right - left - 1 - lCount\n\
    \            }\n            lCount + rCount\n        }\n        val changes =\
    \ Array.fill(arr.length)(0l)\n        for (i <- 1 until arr.length) {\n      \
    \      changes(i) = min(changes(i - 1) + 1, getChangeForSubArray(arr, i - 1, i))\n\
    \        }\n        changes(arr.length - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdo3ckmot.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                left -= \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                value -=\
    \ is not a member of Int - did you mean left.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpdo3ckmot.scala:20:22 ------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m                right += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m         \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not a member\
    \ of Int - did you mean right.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010142
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var ans = 0l.toLong\n        var l = 0\n        var r =\
    \ arr.length - 1\n        while (l < r) {\n            val n1 = arr(l)\n     \
    \       val n2 = arr(r)\n            if (n1 != n2) {\n                ans += 1\n\
    \            }\n            l += 1\n            r -= 1\n        }\n        ans\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010143
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val s = Array.ofDim[Long](n\
    \ + 1, n + 1)\n        for (i <- 0 to n) {\n            s(i)(i) = 0\n        }\n\
    \        for (i <- n - 1 to 0 by -1) {\n            for (j <- i + 1 to n) {\n\
    \                val k = j - i - 1\n                s(i)(j) = min(s(i + 1)(j)\
    \ + abs(arr(i) - arr(i + k)), s(i)(j - 1) + abs(arr(j - 1) - arr(i + k)))\n  \
    \          }\n        }\n        val mid = n / 2\n        s(0)(n) - s(0)(mid)\
    \ - s(mid + 1)(n)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6qwry8mo.scala:30)\n\tat Problem.main(tmp6qwry8mo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010143
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arrLen = arr.length\n        var dp = Array.ofDim[Long](arrLen,\
    \ arrLen)\n        for (i <- 0 until arrLen) {\n            dp(i)(i) = 0\n   \
    \     }\n        for (l <- 2 to arrLen) {\n            for (i <- 0 to arrLen -\
    \ l) {\n                val j = i + l - 1\n                if (arr(i) == arr(j))\
    \ dp(i)(j) = dp(i + 1)(j - 1)\n                else dp(i)(j) = 1 + min(dp(i +\
    \ 1)(j), dp(i)(j - 1))\n            }\n        }\n        dp(0)(arrLen - 1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpswugkfc3.scala:30)\n\tat Problem.main(tmpswugkfc3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010143
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Create a palindrome made up of the lowest valued elements.\n\
    \        // For example, the list (5, 4, 7, 9, 6) will be changed into (4, 4,\
    \ 7, 6, 6).\n        // The list (5, 4, 7, 9, 6) will be changed into (4, 4, 7,\
    \ 6, 6).\n        // The list (1, 2, 3, 4, 3, 2, 2) will be changed into (1, 2,\
    \ 2, 2, 2, 2, 2).\n        // The list (1, 2, 3, 2, 1) will be changed into (1,\
    \ 2, 2, 2, 1).\n        // The palindrome is guaranteed to be length >= 3.\n \
    \       val palindrome = arr.sorted.zipWithIndex.filter(_._2 < arr.length / 2).map(x\
    \ => x._1) ++ arr.sorted.reverse.zipWithIndex.filter(_._2 < arr.length / 2).map(x\
    \ => x._1)\n        // The number of changes is the number of indices that are\
    \ not equal between the\n        // original array and the palindrome array.\n\
    \        (0l /: (arr.zip(palindrome).filter(x => x._1 != x._2)))((total, next)\
    \ => total + 1l)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn9u1ddy8.scala:28)\n\tat Problem.main(tmpn9u1ddy8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010144
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val sum = Array.ofDim[Long](n,\
    \ n)\n        val min = Array.ofDim[Long](n, n)\n        for (i <- 0 until n)\
    \ {\n            sum(i)(i) = arr(i)\n            min(i)(i) = 0\n        }\n  \
    \      for (i <- 0 until n - 1) {\n            sum(i)(i + 1) = arr(i) + arr(i\
    \ + 1)\n            min(i)(i + 1) = sum(i)(i + 1) - max(arr(i), arr(i + 1))\n\
    \        }\n        for (k <- 2 until n) {\n            for (i <- 0 until n -\
    \ k) {\n                sum(i)(i + k) = sum(i)(i + k - 1) + arr(i + k)\n     \
    \           min(i)(i + k) = min(i)(i + k - 1) + sum(i)(i + k) - arr(i + k) * 2\n\
    \                for (j <- i until i + k) {\n                    min(i)(i + k)\
    \ = min(i)(i + k) - max(arr(j), sum(i)(i + k) - arr(j))\n                }\n \
    \           }\n        }\n        min(0)(n - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj6gxlmzq.scala:38)\n\tat Problem.main(tmpj6gxlmzq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010144
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      // >>> (1, 2, 3, 4, 3, 2, 2)\n      // >>> (1, 2, 3, 4, 2,\
    \ 2)\n      // >>> (1, 2, 3, 2, 2)\n      // >>> (1, 2, 2, 2)\n      // >>> (1,\
    \ 2, 2)\n      // >>> (1, 2)\n      // >>> (1)\n      // >>> ()\n      // >>>\n\
    \      // >>> (1, 2, 3, 4, 3, 2, 2)\n      // >>> (1, 2, 3, 3, 2, 2)\n      //\
    \ >>> (1, 2, 3, 2, 2)\n      // >>> (1, 2, 2, 2)\n      // >>> (1, 2, 2)\n   \
    \   // >>> (1, 2)\n      // >>> (1)\n      // >>> ()\n      // >>>\n      // >>>\
    \ (1, 2, 3, 4, 3, 2, 2)\n      // >>> (1, 2, 3, 2, 2)\n      // >>> (1, 2, 2,\
    \ 2)\n      // >>> (1, 2, 2)\n      // >>> (1, 2)\n      // >>> (1)\n      //\
    \ >>> ()\n      // >>>\n      // >>> (1, 2, 3, 4, 3, 2, 2)\n      // >>> (1, 2,\
    \ 3, 2, 2)\n      // >>> (1, 2, 2, 2)\n      // >>> (1, 2, 2)\n      // >>> (1,\
    \ 2)\n      // >>> (1)\n      // >>> ()\n      // >>>\n      // >>> (1, 2, 3,\
    \ 4, 3, 2, 2)\n      // >>> (1, 2, 3, 2, 2)\n      // >>> (1, 2, 2, 2)\n     \
    \ // >>> (1, 2, 2)\n      // >>> (1, 2)\n      // >>> (1)\n      // >>> ()\n \
    \     // >>>\n      // >>> (1, 2, 3, 4, 3, 2, 2)\n      // >>> (1, 2, 3, 2, 2)\n\
    \      // >>> (1, 2, 2, 2)\n      // >>> (1, 2, 2)\n      // >>> (\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdxa99pcb.scala:14:50\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m    \e[33mdef\e[0m \e[36msmallestChange\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mLong\e[0m = {\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0m                                                  Found:    Unit\n\
    \e[31m   |\e[0m                                                  Required: Long\n\
    \e[31m15 |\e[0m      \e[34m// >>> (1, 2, 3, 4, 3, 2, 2)\e[0m\n\e[31m16 |\e[0m\
    \      \e[34m// >>> (1, 2, 3, 4, 2, 2)\e[0m\n\e[31m17 |\e[0m      \e[34m// >>>\
    \ (1, 2, 3, 2, 2)\e[0m\n\e[31m18 |\e[0m      \e[34m// >>> (1, 2, 2, 2)\e[0m\n\e\
    [31m19 |\e[0m      \e[34m// >>> (1, 2, 2)\e[0m\n\e[31m20 |\e[0m      \e[34m//\
    \ >>> (1, 2)\e[0m\n\e[31m21 |\e[0m      \e[34m// >>> (1)\e[0m\n\e[31m22 |\e[0m\
    \      \e[34m// >>> ()\e[0m\n\e[31m23 |\e[0m      \e[34m// >>>\e[0m\n\e[31m24\
    \ |\e[0m      \e[34m// >>> (1, 2, 3, 4, 3, 2, 2)\e[0m\n\e[31m25 |\e[0m      \e\
    [34m// >>> (1, 2, 3, 3, 2, 2)\e[0m\n\e[31m26 |\e[0m      \e[34m// >>> (1, 2, 3,\
    \ 2, 2)\e[0m\n\e[31m27 |\e[0m      \e[34m// >>> (1, 2, 2, 2)\e[0m\n\e[31m28 |\e\
    [0m      \e[34m// >>> (1, 2, 2)\e[0m\n\e[31m29 |\e[0m      \e[34m// >>> (1, 2)\e\
    [0m\n\e[31m30 |\e[0m      \e[34m// >>> (1)\e[0m\n\e[31m31 |\e[0m      \e[34m//\
    \ >>> ()\e[0m\n\e[31m32 |\e[0m      \e[34m// >>>\e[0m\n\e[31m33 |\e[0m      \e\
    [34m// >>> (1, 2, 3, 4, 3, 2, 2)\e[0m\n\e[31m34 |\e[0m      \e[34m// >>> (1, 2,\
    \ 3, 2, 2)\e[0m\n\e[31m35 |\e[0m      \e[34m// >>> (1, 2, 2, 2)\e[0m\n\e[31m36\
    \ |\e[0m      \e[34m// >>> (1, 2, 2)\e[0m\n\e[31m37 |\e[0m      \e[34m// >>> (1,\
    \ 2)\e[0m\n\e[31m38 |\e[0m      \e[34m// >>> (1)\e[0m\n\e[31m39 |\e[0m      \e\
    [34m// >>> ()\e[0m\n\e[31m40 |\e[0m      \e[34m// >>>\e[0m\n\e[31m41 |\e[0m  \
    \    \e[34m// >>> (1, 2, 3, 4, 3, 2, 2)\e[0m\n\e[31m42 |\e[0m      \e[34m// >>>\
    \ (1, 2, 3, 2, 2)\e[0m\n\e[31m43 |\e[0m      \e[34m// >>> (1, 2, 2, 2)\e[0m\n\e\
    [31m44 |\e[0m      \e[34m// >>> (1, 2, 2)\e[0m\n\e[31m45 |\e[0m      \e[34m//\
    \ >>> (1, 2)\e[0m\n\e[31m46 |\e[0m      \e[34m// >>> (1)\e[0m\n\e[31m47 |\e[0m\
    \      \e[34m// >>> ()\e[0m\n\e[31m48 |\e[0m      \e[34m// >>>\e[0m\n\e[31m49\
    \ |\e[0m      \e[34m// >>> (1, 2, 3, 4, 3, 2, 2)\e[0m\n\e[31m50 |\e[0m  "
  stdout: ''
  timestamp: 1660010143
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def helper(arr : List[Long], first : Long, last : Long,\
    \ count : Long) : Long = {\n            if (first > last) count\n            else\
    \ if (arr(first.toInt) == arr(last.toInt)) helper(arr, first + 1, last - 1, count)\n\
    \            else if (arr(first.toInt) > arr(last.toInt)) helper(arr, first, last\
    \ - 1, count + 1)\n            else helper(arr, first + 1, last, count + 1)\n\
    \        }\n        helper(arr, 0, arr.length - 1, 0)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9x6zgn8_.scala:24)\n\tat Problem.main(tmp9x6zgn8_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010148
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var minimum = Long.MaxValue\n        def helper(lst : List[Long],\
    \ count : Long) : Long = {\n            if (lst.length == 0) minimum = min(minimum,\
    \ count)\n            else if (lst.length == 1) minimum = min(minimum, count)\n\
    \            else if (lst.length == 2) {\n                if (lst(0) == lst(1))\
    \ minimum = min(minimum, count)\n                else minimum = min(minimum, count\
    \ + 1)\n            }\n            else {\n                val first = lst.head\n\
    \                val middle = lst.length / 2\n                val last = lst.last\n\
    \                if (first == last) helper(lst.slice(1, middle) ++ lst.slice(middle\
    \ + 1, lst.length - 1), count)\n                else {\n                    helper(lst.slice(1,\
    \ middle) ++ lst.slice(middle + 1, lst.length - 1), count + 1)\n             \
    \       helper(lst.slice(0, middle) ++ lst.slice(middle + 1, lst.length), count\
    \ + 1)\n                }\n            }\n            minimum\n        }\n   \
    \     helper(arr, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpohh0839y.scala:38)\n\tat Problem.main(tmpohh0839y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.foldLeft(ArrayBuffer[Long]())((z, i) => {\n        \
    \    if (z.length == 0) z += i\n            else if (z.last != i) z += i\n   \
    \         else z.trimEnd(1)\n            z\n        }).length\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpef6hb622.scala:23)\n\tat Problem.main(tmpef6hb622.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010150
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var palindrome = arr\n        //println(palindrome)\n  \
    \      while (!isPalindrome(palindrome)) {\n            palindrome = palindrome.drop(1)\n\
    \            //println(palindrome)\n        }\n        (arr.length - palindrome.length).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1233w6bw.scala:17:16 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mwhile\e[0m (!isPalindrome(palindrome))\
    \ {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \               Not found: isPalindrome\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010144
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Write your code here\n        0l\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgi1cpixd.scala:19)\n\tat Problem.main(tmpgi1cpixd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010150
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length % 2 == 0) {\n            arr.grouped(2).map(x\
    \ => x.head - x.last).foldLeft(0l.toLong)((x, y) => x + abs(y))\n        } else\
    \ {\n            (arr.grouped(2).map(x => if (x.length == 2) x.head - x.last else\
    \ abs(x.head)).foldLeft(0l.toLong)((x, y) => x + y))\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqyumsz2v.scala:22)\n\tat Problem.main(tmpqyumsz2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010150
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length == 0) 0l\n        else {\n            var\
    \ result = 0l\n            var counter = 0\n            while (counter < arr.length\
    \ / 2) {\n                if (arr(counter) != arr(arr.length - 1 - counter)) result\
    \ += 1\n                counter += 1\n            }\n            result\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        var x = new Array[Long](n+1)\n\
    \        x(0) = 0\n        for (i <- 1 to n) {\n            x(i) = x(i-1) + arr(i-1)\n\
    \        }\n        var result = Long.MaxValue\n        for (i <- 0 to n) {\n\
    \            result = min(result, x(i) + x(n) - x(i) - x(n-i))\n        }\n  \
    \      result\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf7qz8o0p.scala:28)\n\tat Problem.main(tmpf7qz8o0p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010150
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      val longestPalindrome = new LongestPalindrome(arr)\n     \
    \ arr.length - longestPalindrome.subsequences.maxBy(_.length).length\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkeglh7gt.scala:15:34 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m      \e[33mval\e[0m \e[36mlongestPalindrome\e[0m = \e\
    [33mnew\e[0m \e[35mLongestPalindrome\e[0m(arr)\n\e[31m\e[31m   |\e[0m        \
    \                          ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                       Not found: type LongestPalindrome\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010146
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def main(arr : List[Long], count : Long) : Long = {\n  \
    \          if (arr.size == 1) count\n            else {\n                if (arr.head\
    \ != arr.last) main(arr.drop(1).dropRight(1), count + 1)\n                else\
    \ main(arr.drop(1).dropRight(1), count)\n            }\n        }\n        main(arr,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.main$1(tmpoaftl0vp.scala:18)\n\
    \tat Problem$.smallestChange(tmpoaftl0vp.scala:22)\n\tat Problem$.main(tmpoaftl0vp.scala:25)\n\
    \tat Problem.main(tmpoaftl0vp.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        // dp(i)(j) represents the minimum\
    \ number of changes required to make\n        // arr(i) to arr(j) palindromic.\n\
    \        val dp = Array.ofDim[Long](n, n)\n        for (k <- 1 to n - 1) {\n \
    \           for (i <- 0 to n - k - 1) {\n                val j = i + k\n     \
    \           dp(i)(j) = min(dp(i + 1)(j), dp(i)(j - 1)) + 1\n                if\
    \ (arr(i) == arr(j)) dp(i)(j) = min(dp(i)(j), dp(i + 1)(j - 1))\n            }\n\
    \        }\n        dp(0)(n - 1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn8cyy0dk.scala:29)\n\tat Problem.main(tmpn8cyy0dk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010153
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val a = arr.toArray\n        val n = a.length\n        val\
    \ dp = Array.ofDim[Long](n, n)\n        for (j <- 0 until n) {\n            for\
    \ (i <- j - 1 to 0 by -1) {\n                val c = if (a(i) == a(j)) dp(i +\
    \ 1)(j - 1) else 1 + min(dp(i + 1)(j), dp(i)(j - 1))\n                dp(i)(j)\
    \ = c\n            }\n        }\n        dp(0)(n - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr0j1dr94.scala:27)\n\tat Problem.main(tmpr0j1dr94.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length <= 1) return 0l\n        val center = (arr.length\
    \ + 1) / 2\n        val centerOdd = arr.length % 2 != 0\n        var v = 0l\n\
    \        if (centerOdd) {\n            for (i <- 0 until center) {\n         \
    \       if (arr(i) != arr(arr.length - 1 - i)) v += 1\n            }\n       \
    \ } else {\n            for (i <- 0 until center) {\n                if (arr(i)\
    \ != arr(arr.length - 1 - i)) v += 1\n            }\n        }\n        v\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010153
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val mid = arr.length / 2\n        var count = 0l\n     \
    \   for (i <- 0 until mid) {\n            count += abs(arr(i) - arr(arr.length\
    \ - 1 - i))\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqh8yok_m.scala:23)\n\tat Problem.main(tmpqh8yok_m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010154
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr.length match {\n            case 0 => 0\n          \
    \  case 1 => 0\n            case 2 => abs(arr(0) - arr(1))\n            case _\
    \ => (arr.length - 1) / 2 match {\n                case 0 => abs(arr(0) - arr(1))\n\
    \                case x => abs(arr(0) - arr(1)) + abs(arr(x) - arr(x + 1)) + smallestChange(arr.slice(1,\
    \ x) ++ arr.slice(x + 2, arr.length))\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppkjxjmgj.scala:26)\n\tat Problem.main(tmppkjxjmgj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010153
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val length = arr.length; val half = length / 2\n       \
    \ var current = 0l\n        for (i <- 0 until half) {\n            val x = abs(arr(i)\
    \ - arr(length - 1 - i))\n            current += x\n        }\n        current\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxzt3ko4t.scala:24)\n\tat Problem.main(tmpxzt3ko4t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010153
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def recurse(list : List[Long], l : Long, r : Long, cache\
    \ : HashMap[(List[Long], Long, Long), Long]) : Long = {\n            if (l ==\
    \ r) return 0\n            if (l == r - 1) return if (list(l.toInt) == list(r.toInt))\
    \ 0 else 1\n            if (cache.contains((list, l, r))) return cache((list,\
    \ l, r))\n            val min = if (list(l.toInt) == list(r.toInt)) recurse(list,\
    \ l + 1, r - 1, cache) else 1 + min(recurse(list, l + 1, r, cache), recurse(list,\
    \ l, r - 1, cache))\n            cache((list, l, r)) = min\n            min\n\
    \        }\n        recurse(arr, 0, arr.length - 1, new HashMap[(List[Long], Long,\
    \ Long), Long])\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx1cluh4b.scala:19:102 --------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mmin\e[0m = \e[33mif\e\
    [0m (list(l.toInt) == list(r.toInt)) recurse(list, l + \e[31m1\e[0m, r - \e[31m1\e\
    [0m, cache) \e[33melse\e[0m \e[31m1\e[0m + min(recurse(list, l + \e[31m1\e[0m,\
    \ r, cache), recurse(list, l, r - \e[31m1\e[0m, cache))\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \               Recursive \e[33mvalue\e[0m \e[35mmin\e[0m needs type\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010150
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var res = Long.MaxValue\n        for (i <- 0 until arr.length)\
    \ {\n            val shift = if (i == 0) 0 else arr(i - 1)\n            val steps\
    \ = 2l.toLong * (i) + (arr.length - i - 1) - shift\n            res = min(res,\
    \ steps)\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb31wzv7p.scala:24)\n\tat Problem.main(tmpb31wzv7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010153
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr2 = arr.toArray\n        val N = arr.length\n   \
    \     var i = 0\n        var j = N - 1\n        var count = 0\n        while (i\
    \ < j) {\n            if (arr2(i) != arr2(j)) {\n                count += 1\n\
    \            }\n            i += 1\n            j -= 1\n        }\n        return\
    \ count\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010153
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n      val len = arr.length\n      var count = 0l\n      for (i <-\
    \ 0 until len / 2) {\n        if (arr(i) != arr(len - 1 - i)) count += 1\n   \
    \   }\n      count\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010153
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length <= 1) return 0l\n        val (a, b) = arr.splitAt(arr.length\
    \ / 2)\n        if (arr.length % 2 == 0) {\n            val (d1, d2) = a.zip(b.reverse).unzip\n\
    \            d1.map(abs(_)).sum + d2.map(abs(_)).sum\n        } else {\n     \
    \       val (d1, d2) = a.zip(b.tail.reverse).unzip\n            d1.map(abs(_)).sum\
    \ + d2.map(abs(_)).sum\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp79u3ybe0.scala:26)\n\tat Problem.main(tmp79u3ybe0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010154
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        // change(i, j) : minimum number\
    \ of changes to make arr(i) ... arr(j) palindromic\n        val change = Array.ofDim[Long](n,\
    \ n)\n        // palindrome length (i, j)\n        // val pal = Array.ofDim[Long](n,\
    \ n)\n        for (d <- 1 until n) {\n            for (i <- 0 until n - d) {\n\
    \                val j = i + d\n                val numChanges = change(i + 1)(j\
    \ - 1) + (if (arr(i) == arr(j)) 0 else 2)\n                val numChanges2 = change(i)(j\
    \ - 1) + 1\n                val numChanges3 = change(i + 1)(j) + 1\n         \
    \       change(i)(j) = min(numChanges, min(numChanges2, numChanges3))\n      \
    \      }\n        }\n        change(0)(n - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_f0pudoi.scala:32)\n\tat Problem.main(tmp_f0pudoi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010155
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        arr match {\n            case List() => 0l\n           \
    \ case head :: tail => {\n                val list = tail.reverse\n          \
    \      val (num1, num2) = findMin(head, list)\n                num1 + num2\n \
    \           }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzgfk1jtp.scala:19:35 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mval\e[0m (num1, num2) = findMin(head,\
    \ list)\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                   Not found: findMin\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzgfk1jtp.scala:19:21 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mval\e[0m (num1, num2) = findMin(head,\
    \ list)\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m   \
    \                  Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzgfk1jtp.scala:19:27 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mval\e[0m (num1, num2) = findMin(head,\
    \ list)\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e\
    [0m                           Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val array1 = arr.slice(0, n\
    \ / 2)\n        val array2 = if (n % 2 == 0) arr.slice(n / 2, n) else arr.slice(n\
    \ / 2 + 1, n)\n        array1.zip(array2.reverse).map(x => abs(x._1 - x._2)).sum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4yoansy7.scala:21)\n\tat Problem.main(tmp4yoansy7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010155
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var a = arr.toArray\n        var change = 0l\n        for\
    \ (i <- 0 until (a.length / 2)) {\n            if (a(i) != a(a.length - 1 - i))\
    \ change += 1\n        }\n        change\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010155
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        if (arr.length <= 1) 0l\n        else {\n            var\
    \ minChanges = Long.MaxValue\n            val palindromic = (l : List[Long]) =>\
    \ l.zip(l.reverse).foldLeft(true)((acc, x) => acc && x._1 == x._2)\n         \
    \   val palindromicBit = (l : Array[Boolean]) => l.zip(l.reverse).foldLeft(true)((acc,\
    \ x) => acc && x._1 == x._2)\n            val change = (l : List[Long]) => l.map(x\
    \ => x % 2 == 0)\n            val changeBit = (l : Array[Boolean]) => l.map(x\
    \ => x ^ (x && x))\n            for (sublistStart <- 0 to arr.length - 1) {\n\
    \                for (sublistEnd <- sublistStart + 1 to arr.length) {\n      \
    \              val sublist = arr.slice(sublistStart, sublistEnd)\n           \
    \         if (palindromic(sublist)) {\n                        val changes = change(sublist)\n\
    \                        if (changes.count(x => x) < minChanges) minChanges =\
    \ changes.count(x => x)\n                    }\n                }\n          \
    \  }\n            minChanges\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp285behj4.scala:35)\n\tat Problem.main(tmp285behj4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010156
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        var l = arr.length\n        var sum = 0l\n        for (i\
    \ <- 0 until l / 2) {\n            sum += abs(arr(i) - arr(l - i - 1))\n     \
    \   }\n        sum\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9tsozldc.scala:23)\n\tat Problem.main(tmp9tsozldc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010156
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def loop(l : Long, a : List[Long]) : Long = {\n        \
    \    if (a.size < 2) {\n                l\n            } else {\n            \
    \    if (a.head != a.last) {\n                    loop(l + 1, a.tail.init)\n \
    \               } else {\n                    loop(l, a.tail.init)\n         \
    \       }\n            }\n        }\n        loop(0, arr)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010156
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Define N and prepare DP.\n        val N = arr.length\n\
    \        val dp = Array.ofDim[Long](N, N)\n        // Outer loop through the number\
    \ of elements to consider.\n        for (len <- 1 to N) {\n            // Inner\
    \ loop through starting positions.\n            for (start <- 0 to N - len) {\n\
    \                val end = start + len - 1\n                // If single element,\
    \ then value is 0.\n                if (len == 1) dp(start)(end) = 0\n       \
    \         // If two elements, then value is one if the elements are not equal.\n\
    \                else if (len == 2) dp(start)(end) = if (arr(start) == arr(end))\
    \ 0 else 1\n                // If more than two elements, then we can either change\
    \ the first\n                // element to match the last element and remove both\
    \ elements from\n                // the list, or do the same for the second and\
    \ second to last elements.\n                else dp(start)(end) = min(dp(start\
    \ + 1)(end) + (if (arr(start) == arr(end)) 0 else 1), dp(start)(end - 1) + (if\
    \ (arr(start) == arr(end)) 0 else 1))\n            }\n        }\n        // Return\
    \ the cost of a palindrome using all elements.\n        dp(0)(N - 1)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw6_bo235.scala:37)\n\tat Problem.main(tmpw6_bo235.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010157
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        def loop(arr : List[Long], count : Long) : Long = {\n  \
    \          if (arr.length <= 1) return count\n            if (arr.head == arr.last)\
    \ loop(arr.drop(1).dropRight(1), count)\n            else loop(arr.drop(1).dropRight(1),\
    \ count + 1)\n        }\n        loop(arr, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010156
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        // Given a list of integers A, perform B operations. In\
    \ each operation, choose one of the elements of A and increment it by 1. Determine\
    \ the minimum and maximum values that the list may have after performing B operations.\n\
    \        // For example:\n        // >>> x = (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong))\n        // (1l,2l,3l)\n        // >>> getMinMax(x, 3l)\n      \
    \  // (4l, 7l)\n        // >>> getMinMax(x, 2l)\n        // (3l, 6l)\n       \
    \ // >>> getMinMax(x, 1l)\n        // (2l, 5l)\n        // >>> getMinMax(x, 0l)\n\
    \        // (1l, 4l)\n        def getMinMax(arr : List[Long], numOps : Long) :\
    \ (Long, Long) = {\n            val min = (List[Long](arr.max, arr.min)).min\n\
    \            (min, min + arr.length + numOps)\n        }\n        // Given a list\
    \ of integers, determine if the list can be made palindromic.\n        // For\
    \ example:\n        // >>> isPalindromic((List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 4l.toLong, 3l.toLong, 1l.toLong, 1l.toLong)))\n        // (true)\n\
    \        // >>> isPalindromic((List[Long](1l.toLong, 1l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 1l.toLong, 1l.toLong)))\n        // (true)\n        // >>> isPalindromic((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 1l.toLong, 1l.toLong)))\n      \
    \  // (false)\n        def isPalindromic(arr : List[Long]) : Boolean = {\n   \
    \         val halfIdx = (arr.length + 1) / 2\n            arr.take(halfId\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaxu8sbxl.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaxu8sbxl.scala:55:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m55 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpaxu8sbxl.scala:41:21 ------------------------\e[0m\e[0m\n\
    \e[31m41 |\e[0m            arr.take(halfId\n\e[31m\e[31m   |\e[0m            \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: halfId\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaxu8sbxl.scala:54:1\
    \ ---------------------\e[0m\e[0m\n\e[31m54 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpaxu8sbxl.scala:43:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m43 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660010156
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val center = arr.length / 2\n        // For even elements\n\
    \        if (arr.length % 2 == 0) {\n            var count = 0l\n            for\
    \ (i <- 0 until center) {\n                if (arr(i) != arr(arr.length - 1 -\
    \ i)) count += 1\n            }\n            count\n        }\n        // For\
    \ odd elements\n        else {\n            var count = 0l\n            for (i\
    \ <- 0 until center) {\n                if (arr(i) != arr(arr.length - 1 - i))\
    \ count += 1\n            }\n            count\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010157
