name: HumanEval_73_smallest_change
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a list arr of integers, find the minimum number of elements that\n\
  \    // need to be changed to make the list palindromic. A palindromic list is a\
  \ list that\n    // is read the same backwards and forwards. In one change, you\
  \ can change one element to any other element.\n    // For example:\n    // >>>\
  \ smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong,\
  \ 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    // (1l)\n\
  \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
  \ 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
  \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
  \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
  \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
  \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
  \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) == (1l));\n\
  \    }\n\n}\n"
completions: ["        // We use a dynamic programming approach. Let arr = (x1, x2,\
    \ ..., xn) be the list of numbers.\n        // Let dp(i, j) = the number of changes\
    \ needed to make the sublist (xi, xi+1, ..., xj)\n        // a palindrome. Then\n\
    \        // dp(i, j) = min(dp(i+1, j), dp(i, j-1)) + 1 if xi != xj, 0 if xi ==\
    \ xj.\n        val n = arr.length\n        val dp = Array.ofDim[Long](n, n)\n\
    \        for (i <- 0 until n; j <- 0 until n) {\n            dp(i)(j) = -1\n \
    \       }\n        def smallestChangeHelper(i : Int, j : Int) : Long = {\n   \
    \         if (dp(i)(j) != -1) dp(i)(j)\n            else if (i > j) 0\n      \
    \      else if (i == j) 0\n            else if (i + 1 == j) if (arr(i) == arr(j))\
    \ 0 else 1\n            else {\n                val res = min(smallestChangeHelper(i\
    \ + 1, j), smallestChangeHelper(i, j - 1)) + 1\n                dp(i)(j) = res\n\
    \                res\n            }\n        }\n        smallestChangeHelper(0,\
    \ n - 1)", "        if (arr.length % 2 == 0) {\n            val (firstHalf, secondHalf)\
    \ = arr.splitAt(arr.length / 2)\n            val changes = firstHalf.zip(secondHalf.reverse).map(a\
    \ => abs(a._1 - a._2))\n            changes.sum\n        } else {\n          \
    \  val (firstHalf, secondHalf) = arr.splitAt(arr.length / 2)\n            val\
    \ changes = firstHalf.zip(secondHalf.tail.reverse).map(a => abs(a._1 - a._2))\n\
    \            changes.sum\n        }", "        var count = 0\n        val arrLength\
    \ = arr.length\n        val midPoint = floor(arrLength / 2.0).toInt\n        for\
    \ (i <- 0 until midPoint) {\n            if (arr(i) != arr(arrLength - 1 - i))\
    \ count += 1\n        }\n        return count", "        var cnt = 0l.toLong\n\
    \        var list = arr\n        var list2 = arr.reverse\n        for (i <- 0\
    \ until (arr.length / 2)) {\n            if (list(i) != list2(i)) cnt += 1\n \
    \       }\n        return cnt", "        val n = arr.length\n        var dp =\
    \ Array.ofDim[Long](n, n)\n        for (len <- 2 to n) {\n            for (start\
    \ <- 0 to n - len) {\n                val end = start + len - 1\n            \
    \    if (arr(start) == arr(end)) dp(start)(end) = dp(start + 1)(end - 1)\n   \
    \             else dp(start)(end) = min(dp(start + 1)(end), dp(start)(end - 1))\
    \ + 1\n            }\n        }\n        return dp(0)(n - 1)", "        val n\
    \ = arr.length\n        val a = Array.ofDim[Long](n + 1, n + 1)\n        for (i\
    \ <- 0 to n) {\n            a(i)(i) = 0\n        }\n        for (i <- 2 to n)\
    \ {\n            for (j <- 0 to n - i) {\n                val k = j + i - 1\n\
    \                a(j)(k) = a(j + 1)(k) + 1\n                if (arr(j) == arr(k))\
    \ {\n                    a(j)(k) = min(a(j)(k), a(j + 1)(k - 1))\n           \
    \     }\n                for (m <- j + 1 to k - 1) {\n                    if (arr(m)\
    \ == arr(k)) {\n                        a(j)(k) = min(a(j)(k), a(j)(m - 1) + a(m\
    \ + 1)(k - 1))\n                    }\n                }\n            }\n    \
    \    }\n        a(0)(n - 1)", "        val l = arr.length\n        if (l <= 1)\
    \ 0\n        else {\n            val m = l / 2\n            var minc = m\n   \
    \         for (i <- 0 until l / 2) {\n                var inc = 0\n          \
    \      for (j <- 0 until m) {\n                    if (arr(i + j) != arr(l - 1\
    \ - i - j)) inc += 1\n                }\n                if (inc < minc) minc\
    \ = inc\n            }\n            return minc\n        }", '        ???', " \
    \       val n = arr.length\n        val dp = Array.ofDim[Long](n + 1, n + 1)\n\
    \        def solve(start : Int, end : Int) : Long = {\n            if (start >\
    \ end) return 0l\n            if (dp(start)(end) != 0) return dp(start)(end)\n\
    \            if (start == end) dp(start)(end) = 0l\n            else if (start\
    \ + 1 == end) dp(start)(end) = (if (arr(start) == arr(end)) 0l else 1l)\n    \
    \        else {\n                val prev = solve(start + 1, end - 1)\n      \
    \          if (arr(start) == arr(end)) dp(start)(end) = prev\n               \
    \ else dp(start)(end) = 1l + prev\n            }\n            dp(start)(end)\n\
    \        }\n        solve(0, n - 1)", "        val n = arr.length\n        val\
    \ L = Array.ofDim[Long](n, n)\n        for (i <- 0 until n) {\n            L(i)(i)\
    \ = 0\n        }\n        for (cl <- 2 to n) {\n            for (i <- 0 to n -\
    \ cl) {\n                val j = i + cl - 1\n                if (arr(i) == arr(j))\
    \ L(i)(j) = L(i + 1)(j - 1)\n                else L(i)(j) = min(L(i)(j - 1), L(i\
    \ + 1)(j)) + 1\n            }\n        }\n        L(0)(n - 1)", "        val dp\
    \ = Array.ofDim[Long](arr.length, arr.length)\n        // For each interval\n\
    \        (0 until arr.length).foreach(l => (0 until arr.length - l).foreach(r\
    \ => {\n            val dist = (r to r + l).map(i => arr(i)).toSet.size\n    \
    \        if (l == 0) dp(r)(r) = dist\n            else if (l == 1) dp(r)(r + 1)\
    \ = dist + (if (arr(r) == arr(r + 1)) -1 else 0)\n            else dp(r)(r + l)\
    \ = min(dp(r)(r + l - 1) + dist, dp(r + 1)(r + l) + dist)\n        }))\n     \
    \   dp(0)(arr.length - 1)", "        val buf = arr.to[ListBuffer]\n        val\
    \ len = buf.length\n        var cnt = 0l\n        for (i <- 0 until len / 2) {\n\
    \            if (buf(i) != buf(len - 1 - i)) {\n                cnt += 1\n   \
    \         }\n        }\n        cnt", "        val len = arr.length\n        var\
    \ dp = Array.ofDim[Long](len + 1, len + 1)\n        // Initialization\n      \
    \  for (i <- 0 to len) dp(i)(0) = dp(0)(i) = 0\n        // Recursion\n       \
    \ for (i <- 1 to len) {\n            for (j <- 1 to len) {\n                if\
    \ (arr(i - 1) == arr(len - j)) dp(i)(j) = dp(i - 1)(j - 1)\n                else\
    \ dp(i)(j) = 1 + min(dp(i - 1)(j), dp(i)(j - 1))\n            }\n        }\n \
    \       dp(len)(len)", "        val size = arr.size\n        val dp = Array.ofDim[Long](size,\
    \ size)\n        for (i <- 0 until size) dp(i)(i) = 0\n        for (i <- size\
    \ - 1 to 0 by -1; j <- i + 1 until size) dp(i)(j) = min(abs(arr(i) - arr(j)) +\
    \ dp(i + 1)(j - 1), abs(arr(i) - arr(i + 1)) + dp(i + 2)(j))\n        dp(0)(size\
    \ - 1)", "        val l = arr.length\n        if (l % 2 == 0) {\n            //\
    \ even\n            var left = 0\n            var right = l - 1\n            var\
    \ count = 0l\n            while (left < right) {\n                if (arr(left)\
    \ != arr(right)) {\n                    count += 1\n                }\n      \
    \          left += 1\n                right -= 1\n            }\n            count\n\
    \        } else {\n            // odd\n            var left = 0\n            var\
    \ right = l - 1\n            var count = 0l\n            while (left < right)\
    \ {\n                if (arr(left) != arr(right)) {\n                    count\
    \ += 1\n                }\n                left += 1\n                right -=\
    \ 1\n            }\n            count\n        }", "        def smallestChange0(arr\
    \ : List[Long], beg : Int, end : Int) : Long = {\n            if (beg > end) return\
    \ 0\n            if (beg == end) return 0\n            val arr1 = arr.slice(beg,\
    \ end + 1)\n            val arr2 = arr1.reverse\n            if (arr1 == arr2)\
    \ return 0\n            else {\n                val min0 = min(smallestChange0(arr,\
    \ beg + 1, end), smallestChange0(arr, beg, end - 1))\n                val min1\
    \ = 1 + min(smallestChange0(arr, beg + 1, end), smallestChange0(arr, beg, end\
    \ - 1))\n                min(min0, min1)\n            }\n        }\n        smallestChange0(arr,\
    \ 0, arr.length - 1)", "        def smallestChange(arr : List[Long], start : Int,\
    \ end : Int) : Long = {\n            if (start >= end) 0\n            else {\n\
    \                if (arr(start) == arr(end)) smallestChange(arr, start + 1, end\
    \ - 1)\n                else min(smallestChange(arr, start + 1, end), smallestChange(arr,\
    \ start, end - 1)) + 1\n            }\n        }\n        smallestChange(arr,\
    \ 0, arr.length - 1)", "        val arrrev = arr.reverse\n        var cost = 0l\n\
    \        for (i <- 0 until arr.length) {\n            val j = arr.length - 1 -\
    \ i\n            if (arr(i) != arrrev(j)) {\n                cost += 1\n     \
    \       }\n        }\n        cost", "        val m = arr.size\n        val dp\
    \ = Array.ofDim[Long](m, m)\n        for (i <- 0 until m) dp(i)(i) = 0\n     \
    \   for (l <- 2 to m) {\n            for (i <- 0 to m - l) {\n               \
    \ val j = i + l - 1\n                dp(i)(j) =\n                    if (arr(i)\
    \ == arr(j)) dp(i + 1)(j - 1)\n                    else 1 + dp(i + 1)(j).min(dp(i)(j\
    \ - 1))\n            }\n        }\n        dp(0)(m - 1)", "        val n = arr.length\n\
    \        val m = Array.ofDim[Long](n, n)\n        for (len <- 1 to n) {\n    \
    \        for (i <- 0 to n - len) {\n                val j = i + len - 1\n    \
    \            m(i)(j) = min(m(i + 1)(j), m(i)(j - 1)) + abs(arr(i) - arr(j))\n\
    \            }\n        }\n        m(0)(n - 1)", "        var a = arr.toArray\n\
    \        val n = a.length\n        var dp = Array.ofDim[Long](n, n)\n        for\
    \ (diff <- 0 until n) {\n            for (i <- 0 until n - diff) {\n         \
    \       val j = i + diff\n                if (i == j) dp(i)(j) = 0\n         \
    \       else if (i + 1 == j) dp(i)(j) = if (a(i) == a(j)) 0 else 1\n         \
    \       else {\n                    dp(i)(j) = dp(i + 1)(j - 1) + (if (a(i) ==\
    \ a(j)) 0 else 2)\n                    for (k <- i + 1 until j) dp(i)(j) = min(dp(i)(j),\
    \ dp(i)(k) + dp(k + 1)(j))\n                }\n            }\n        }\n    \
    \    return dp(0)(n - 1)", "        val n = arr.length\n        var ans = Long.MaxValue\n\
    \        for (c <- 0 until n) {\n            var cur = 0l\n            for (i\
    \ <- 0 until n) {\n                if (i == c) cur += 0\n                else\
    \ cur += abs(arr(i) - arr(c))\n            }\n            ans = min(ans, cur)\n\
    \        }\n        ans", "        val n = arr.length\n        val a = arr.toArray\n\
    \        val dp = Array.ofDim[Long](n, n)\n        for (i <- 0 until n) {\n  \
    \          dp(i)(i) = 0\n            if (i + 1 < n) {\n                dp(i)(i\
    \ + 1) = abs(a(i) - a(i + 1))\n            }\n        }\n        for (s <- 2 until\
    \ n) {\n            for (i <- 0 until n) {\n                val j = i + s\n  \
    \              if (j < n) {\n                    val diff = abs(a(i) - a(j))\n\
    \                    dp(i)(j) = min(dp(i + 1)(j - 1) + diff, min(dp(i + 1)(j)\
    \ + abs(a(i) - a(i + 1)), dp(i)(j - 1) + abs(a(j) - a(j - 1))))\n            \
    \    }\n            }\n        }\n        dp(0)(n - 1)", "        val lengths\
    \ = ListBuffer[Int]()\n        for (i <- arr.indices) {\n            var length\
    \ = 0\n            val (left, right) = arr.splitAt(i)\n            length += left.reverse.zip(right).filter(x\
    \ => x._1 != x._2).length\n            val (leftRight, rightRight) = arr.splitAt(i\
    \ + 1)\n            length += leftRight.reverse.zip(rightRight).filter(x => x._1\
    \ != x._2).length\n            lengths += length\n        }\n        lengths.min",
  "        val n = arr.length\n        // M(i, j) = the minimum number of elements\
    \ that need to be changed in order to make the array from index i to index j (inclusive)\
    \ a palindrome.\n        val M = Array.ofDim[Long](n, n)\n        // arr(i).toString().length()\
    \ = the minimum number of digits required to represent arr(i) as a decimal integer\n\
    \        val digits = Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n  \
    \          digits(i) = arr(i).toString().length()\n            M(i)(i) = 0\n \
    \       }\n        for (k <- 1 until n) {\n            for (i <- 0 until n - k)\
    \ {\n                val j = i + k\n                if (i == j - 1) {\n      \
    \              M(i)(j) = min(digits(i), digits(j))\n                } else {\n\
    \                    val inner = M(i + 1)(j - 1)\n                    M(i)(j)\
    \ = min(digits(i) + inner, digits(j) + inner)\n                }\n           \
    \ }\n        }\n        M(0)(n - 1)", "        val dp = Array.ofDim[Long](arr.length,\
    \ arr.length)\n        for (l <- 1 to arr.length) {\n            for (i <- 0 to\
    \ arr.length - l) {\n                val j = i + l - 1\n                if (i\
    \ == j) dp(i)(j) = 0\n                else if (arr(i) == arr(j)) dp(i)(j) = dp(i\
    \ + 1)(j - 1)\n                else dp(i)(j) = min(dp(i + 1)(j), dp(i)(j - 1))\
    \ + 1\n            }\n        }\n        dp(0)(arr.length - 1)", "        // @TODO:\
    \ Write Code Here\n        return 0", "        val n = arr.length\n        val\
    \ dp = Array.ofDim[Long](n, n)\n        for (len <- 1 to n) {\n            for\
    \ (i <- 0 to n - len) {\n                val j = i + len - 1\n               \
    \ dp(i)(j) = if (i == j) 0 else 1 + min(dp(i + 1)(j), dp(i)(j - 1))\n        \
    \        if (arr(i) == arr(j)) dp(i)(j) = min(dp(i)(j), dp(i + 1)(j - 1))\n  \
    \          }\n        }\n        dp(0)(n - 1)", "        if (arr.length <= 1)\
    \ return 0l\n        val rarr = arr.reverse\n        var sum = 0l\n        for\
    \ (i <- 0 until arr.length / 2) sum += abs(arr(i) - rarr(i))\n        return sum",
  "        val arr1 = arr.toArray\n        var total = 0l\n        for (i <- 0 until\
    \ arr1.length/2) {\n            total += abs(arr1(i) - arr1(arr1.length - 1 -\
    \ i))\n        }\n        total", "      val n = arr.length\n      val dp = Array.ofDim[Long](n,\
    \ n)\n      for (i <- 0 until n) dp(i)(i) = 0\n      for (len <- 2 to n) {\n \
    \       for (i <- 0 until n - len + 1) {\n          val j = i + len - 1\n    \
    \      dp(i)(j) = (i, j) match {\n            case (i, j) if i + 1 == j => min(arr(i),\
    \ arr(j))\n            case (i, j) if i + 2 == j => max(arr(i), arr(j))\n    \
    \        case (i, j) => max(arr(i) + min(dp(i + 2)(j), dp(i + 1)(j - 1)), arr(j)\
    \ + min(dp(i + 1)(j - 1), dp(i)(j - 2)))\n          }\n        }\n      }\n  \
    \    dp(0)(n - 1)", "      var numChanges = 0l\n      for (i <- 0 to arr.length\
    \ / 2) {\n        if (arr(i) != arr(arr.length - 1 - i)) numChanges += 1\n   \
    \   }\n      numChanges", "      val n = arr.length\n      var dp = Array.ofDim[Long](n,\
    \ n)\n      for (i <- (0 until n).reverse) {\n        for (j <- i until n) {\n\
    \          if (i == j) dp(i)(j) = 0\n          else {\n            dp(i)(j) =\
    \ dp(i + 1)(j - 1) + (if (arr(i) == arr(j)) 0 else 2)\n          }\n        }\n\
    \      }\n      dp(0)(n - 1)", "        val dp = Array.ofDim[Long](arr.length,\
    \ arr.length)\n        // base cases\n        for (i <- 0 until arr.length) {\n\
    \            dp(i)(i) = 0\n            if (i < arr.length - 1) dp(i)(i + 1) =\
    \ abs(arr(i) - arr(i + 1))\n        }\n        // go through all lengths\n   \
    \     for (l <- 2 until arr.length) {\n            // go through all i,j for that\
    \ length\n            for (i <- 0 until arr.length - l) {\n                val\
    \ j = i + l\n                dp(i)(j) = min(dp(i + 1)(j) + abs(arr(i) - arr(i\
    \ + 1)), dp(i)(j - 1) + abs(arr(j) - arr(j - 1)))\n            }\n        }\n\
    \        dp(0)(arr.length - 1)", "        if (arr.length == 0) return 0l\n   \
    \     val reversedArray = arr.reverse\n        val n = arr.length\n        var\
    \ leftIndex = 0\n        var rightIndex = 0\n        var count = 0l\n        while\
    \ (leftIndex < n && rightIndex < n) {\n            if (arr(leftIndex) == reversedArray(rightIndex))\
    \ {\n                leftIndex += 1\n                rightIndex += 1\n       \
    \     } else {\n                count += 1\n                if (arr(leftIndex)\
    \ > reversedArray(rightIndex)) {\n                    leftIndex += 1\n       \
    \         } else {\n                    rightIndex += 1\n                }\n \
    \           }\n        }\n        count", "        var list = arr.toArray.zipWithIndex\n\
    \        var sum = 0\n        for (i <- 0 until (arr.length + 1) / 2) {\n    \
    \        if (arr(i) != arr(arr.length - 1 - i)) {\n                sum += 1\n\
    \            }\n        }\n        return sum", "\t\tval n = arr.length\n\t\t\
    var m = new Array[Long](n + 1)\n\t\tfor (i <- 1 to n) {\n\t\t\tvar r = 0l\n\t\t\
    \tvar l = i - 1\n\t\t\twhile (l >= 0) {\n\t\t\t\tval t = m(l) + abs(arr(l) - arr(r))\n\
    \t\t\t\tif (l == 0) m(i) = t\n\t\t\t\telse m(l) = min(m(l), t)\n\t\t\t\tl -= 1\n\
    \t\t\t\tr += 1\n\t\t\t}\n\t\t}\n\t\tm(n)\n\t}\n}", "        def swap(arr : List[Long],\
    \ i : Int, j : Int) : List[Long] = {\n            if (i == j) arr\n          \
    \  else {\n                val temp = arr(i)\n                arr(i) = arr(j)\n\
    \                arr(j) = temp\n                arr\n            }\n        }\n\
    \        def helper(arr : List[Long], i : Int, j : Int, steps : Long) : Long =\
    \ {\n            if (i >= j) steps\n            else {\n                if (arr(i)\
    \ != arr(j)) {\n                    val index = arr.indexOf(arr(j), i)\n     \
    \               if (index != -1) helper(swap(arr, i, index), i + 1, j - 1, steps\
    \ + 1)\n                    else -1\n                }\n                else helper(arr,\
    \ i + 1, j - 1, steps)\n            }\n        }\n        helper(arr, 0, arr.length\
    \ - 1, 0)", '        0', "        val (first, second) = arr.splitAt(arr.length\
    \ / 2)\n        var answer = 0L\n        if (arr.length % 2 == 0) {\n        \
    \    for (i <- 0 until first.length) answer += abs(first(i) - second(first.length\
    \ - 1 - i))\n        } else {\n            for (i <- 0 until first.length) answer\
    \ += abs(first(i) - second(first.length - i))\n        }\n        answer", " \
    \       val n = arr.length\n        var result = 0l\n        var i = 0\n     \
    \   while (i < n / 2) {\n            result += abs(arr(i) - arr(n - 1 - i))\n\
    \            i += 1\n        }\n        result", '      arr.length', "       \
    \ // Fill up this function body\n        // You can add another function as well,\
    \ if required\n        var size = arr.size\n        var sum1 = 0l\n        var\
    \ sum2 = 0l\n        for (i <- 0 until (size + 1) / 2) {\n            sum1 +=\
    \ arr(i)\n            sum2 += arr(size - 1 - i)\n        }\n        if (sum1 <\
    \ sum2) {\n            var res = 0l\n            for (i <- 0 until (size + 1)\
    \ / 2) {\n                res += arr(size - 1 - i) - arr(i)\n            }\n \
    \           res\n        } else {\n            var res = 0l\n            for (i\
    \ <- 0 until (size + 1) / 2) {\n                res += arr(i) - arr(size - 1 -\
    \ i)\n            }\n            res\n        }", "        val n = arr.length\n\
    \        var ans = 0l\n        for (i <- 0 until n / 2) {\n            ans +=\
    \ (abs(arr(i) - arr(n - i - 1)) + 1) / 2\n        }\n        ans", "        def\
    \ sub(arr : List[Long], count : Long) : Long = {\n            if (arr.length <=\
    \ 1) count\n            else if (arr.head == arr.last) sub(arr.slice(1, arr.length\
    \ - 1), count)\n            else {\n                val max = arr.max\n      \
    \          val min = arr.min\n                val maxChange = sub(arr.updated(arr.indexOf(max),\
    \ min), count + 1)\n                val minChange = sub(arr.updated(arr.indexOf(min),\
    \ max), count + 1)\n                min(maxChange, minChange)\n            }\n\
    \        }\n        sub(arr, 0)", "        val n = arr.length\n        val L =\
    \ Array.ofDim[Long](n, n)\n        var i = 0\n        while (i < n) {\n      \
    \      var j = 0\n            while (j < n) {\n                if (i == j) L(i)(j)\
    \ = 0\n                else if (i + 1 == j) L(i)(j) = abs(arr(i) - arr(j))\n \
    \               else if (i + 2 == j) L(i)(j) = (L(i)(i + 1) + abs(arr(i) - arr(j)))\
    \ min (L(i + 1)(j) + abs(arr(i + 1) - arr(j)))\n                else {\n     \
    \               L(i)(j) = Long.MaxValue\n                    var k = i\n     \
    \               while (k < j) {\n                        L(i)(j) = L(i)(j) min\
    \ (L(i)(k) + L(k + 1)(j) + abs(arr(k) - arr(j)))\n                        k +=\
    \ 1\n                    }\n                }\n                j += 1\n      \
    \      }\n            i += 1\n        }\n        L(0)(n - 1)", "        // Algorithm:\n\
    \        // 1. Get the length of the list\n        // 2. Check the middle and\
    \ then go from there\n        // 3. If the values are the same, then keep going\n\
    \        // 4. If the values are not the same, then we return the smaller of the\
    \ two.\n        // 5. Get the length of the reverse of the list.\n        // >>>\
    \ smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong,\
    \ 7l.toLong, 9l.toLong, 6l.toLong)))\n        // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n      \
    \  // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 1l.toLong)))\n        // >>> smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong)))\n      \
    \  val length = arr.length\n        def loop(curr : Long, acc : Long) : Long =\
    \ {\n            if (curr == length) acc\n            else {\n               \
    \ val sum = abs(arr(curr.toInt) - arr(length - 1 - curr.toInt))\n            \
    \    loop(curr + 1, acc + sum)\n            }\n        }\n        loop(0, 0)",
  '        ???', "        def helper(l : Long, r : Long, acc : Long) : Long = {\n\
    \            if (l >= r) acc\n            else {\n                if (arr(l.toInt)\
    \ == arr(r.toInt)) helper(l + 1, r - 1, acc)\n                else {\n       \
    \             min(helper(l + 1, r, acc + 1), helper(l, r - 1, acc + 1))\n    \
    \            }\n            }\n        }\n        helper(0, arr.length - 1, 0)",
  "        var min = Long.MaxValue\n        for (i <- 0 until arr.length) {\n    \
    \        var a = arr.slice(0, i)\n            var b = arr.slice(i + 1, arr.length)\n\
    \            min = min min a.count(_ == arr(i)) + b.count(_ == arr(i))\n     \
    \   }\n        min", '        null', "        val l = arr.length\n        val\
    \ matrix = Array.ofDim[Long](l + 1, l + 1)\n        for (i <- 0 to l) {\n    \
    \        matrix(i)(i) = 0\n        }\n        for (s <- 1 to l) {\n          \
    \  for (i <- 0 to l - s) {\n                val j = i + s\n                if\
    \ (i + 1 == j) {\n                    matrix(i)(j) = if (arr(i) == arr(j - 1))\
    \ 0 else 1\n                } else {\n                    matrix(i)(j) = min(matrix(i\
    \ + 1)(j) + 1, matrix(i)(j - 1) + 1)\n                    if (arr(i) == arr(j\
    \ - 1)) {\n                        matrix(i)(j) = min(matrix(i)(j), matrix(i +\
    \ 1)(j - 1))\n                    }\n                }\n            }\n      \
    \  }\n        matrix(0)(l)", "        def loop(arr : List[Long], front : Int,\
    \ back : Int, count : Long) : Long = {\n            if (front >= back) return\
    \ count\n            if (arr(front) == arr(back)) return loop(arr, front + 1,\
    \ back - 1, count)\n            else {\n                val change1 = loop(arr,\
    \ front + 1, back, count + 1)\n                val change2 = loop(arr, front,\
    \ back - 1, count + 1)\n                if (change1 < change2) change1 else change2\n\
    \            }\n        }\n        loop(arr, 0, arr.length - 1, 0)", '        arr.map(x
    => Long.MaxValue)', "        def findSmallestChange(arr : List[Long], prefix :\
    \ List[Long], suffix : List[Long]) : Long = {\n            if (prefix.length ==\
    \ 0) return suffix.length\n            if (suffix.length == 0) return prefix.length\n\
    \            if (prefix.head == suffix.head) return findSmallestChange(arr, prefix.tail,\
    \ suffix.tail)\n            findSmallestChange(arr, prefix.tail, suffix) min findSmallestChange(arr,\
    \ prefix, suffix.tail)\n        }\n        findSmallestChange(arr, arr, arr.reverse)",
  "        if (arr.length == 0) return 0\n        if (arr.length == 1) return 0\n\
    \        if (arr.length == 2) return if (arr(0) == arr(1)) 0 else 1\n        if\
    \ (arr.length == 3) return if (arr(0) == arr(2)) 0 else 1\n        // Dynamic\
    \ programming:\n        // Let the list be:\n        // (..., x_n, x_{n+1}, ...,\
    \ x_{n+m}, ...)\n        // Let A_i be the minimum number of elements that need\
    \ to be changed to make the sublist (x_n, ..., x_{n+i})\n        // palindromic.\n\
    \        // If x_n == x_{n+m}, then A_m = A_{m-2}.\n        // Otherwise,\n  \
    \      // A_m = min(A_{m-1}, A_{m-2}) + 1\n        // The answer is A_{n+m}\n\
    \        val A = new Array[Long](arr.length)\n        A(0) = 0\n        A(1) =\
    \ if (arr(0) == arr(1)) 0 else 1\n        for (i <- 2 to arr.length - 1) {\n \
    \           if (arr(i - 1) == arr(i)) A(i) = A(i - 2)\n            else A(i) =\
    \ min(A(i - 1), A(i - 2)) + 1\n        }\n        A(arr.length - 1)", "      \
    \  def recurse(i : Int, j : Int, cache : Array[Array[Long]]) : Long = {\n    \
    \        if (i > j) 0\n            else if (cache(i)(j) != -1) cache(i)(j)\n \
    \           else if (i == j) recurse(i + 1, j - 1, cache)\n            else if\
    \ (arr(i) == arr(j)) recurse(i + 1, j - 1, cache)\n            else {\n      \
    \          val a = recurse(i + 1, j, cache)\n                val b = recurse(i,\
    \ j - 1, cache)\n                val result = 1 + min(a, b)\n                cache(i)(j)\
    \ = result\n                result\n            }\n        }\n        val cache\
    \ = Array.fill(arr.length, arr.length)(-1)\n        recurse(0, arr.length - 1,\
    \ cache)", '        arr.reverse.zip(arr).filter(p => p._1 != p._2).size.toLong',
  "        var left : Long = -1l\n        var right : Long = -1l\n        var min\
    \ = Long.MaxValue\n        var leftPtr = 0\n        var rightPtr = arr.length\
    \ - 1\n        while (leftPtr < rightPtr) {\n            if (arr(leftPtr) < arr(rightPtr))\
    \ {\n                right = right + 1\n                leftPtr = leftPtr + 1\n\
    \            } else if (arr(leftPtr) > arr(rightPtr)) {\n                left\
    \ = left + 1\n                rightPtr = rightPtr - 1\n            } else {\n\
    \                leftPtr = leftPtr + 1\n                rightPtr = rightPtr -\
    \ 1\n            }\n        }\n        if (right == -1l) {\n            left\n\
    \        } else if (left == -1l) {\n            right\n        } else {\n    \
    \        min = min min (left min right)\n            min\n        }", "      \
    \  var (l, r) = (0, arr.length - 1)\n        var ans = 0\n        while (l < r)\
    \ {\n            val (nl, nr) = (arr(l), arr(r))\n            if (nl == nr) {\n\
    \                l += 1\n                r -= 1\n            } else if (nl < nr)\
    \ {\n                l += 1\n                ans += 1\n            } else {\n\
    \                r -= 1\n                ans += 1\n            }\n        }\n\
    \        ans", "        val reversed = arr.toArray.reverse\n        val n = arr.length\n\
    \        val dp = Array.ofDim[Long](n + 1, n + 1)\n        for (i <- 1 to n) {\n\
    \            for (j <- 1 to n) {\n                if (arr(i - 1) == reversed(j\
    \ - 1)) dp(i)(j) = dp(i - 1)(j - 1) + 1\n                else dp(i)(j) = max(dp(i\
    \ - 1)(j), dp(i)(j - 1))\n            }\n        }\n        n - dp(n)(n)", " \
    \       // working backward from the end, at each element is the minimum number\
    \ of elements that\n        // need to be changed to make the rest of the list\
    \ palindromic\n        // if the number of elements is odd, the mid element can\
    \ stay the same (1)\n        // if the number of elements is even, the two mid\
    \ elements need to match (0)\n        def dp(arr : List[Long], l : List[Long])\
    \ : List[Long] = {\n            if (arr.isEmpty) l\n            else if (arr.length\
    \ == 1) dp(arr.tail, 1l::l)\n            else if (arr.length == 2) dp(arr.tail,\
    \ min(arr.head, arr.tail.head)::l)\n            else if (arr.length == 3) dp(arr.tail,\
    \ min(arr.head, arr.tail.head, arr.tail.tail.head)::l)\n            else {\n \
    \               if (arr.length % 2 == 0) {\n                    val a = arr.head\n\
    \                    val b = arr.tail.head\n                    val c = arr.tail.tail.head\n\
    \                    val d = arr.tail.tail.tail.head\n                    val\
    \ e = arr.tail.tail.tail.tail.head\n                    val minif = min(a, b,\
    \ c, d, e)\n                    if (a == minif && b == minif && c == minif &&\
    \ d == minif && e == minif) dp(arr.tail, 0l::l)\n                    else dp(arr.tail,\
    \ minif::l)\n                }\n                else {\n                    val\
    \ a = arr.head\n                    val b = arr.tail.head\n                  \
    \  val c = arr.tail.tail.head\n                    val d = arr.tail.tail.tail.head\n\
    \                    val minif = min(a, b, c, d)\n                    if (a ==\
    \ minif && b == minif && c == minif && d == minif) dp(arr.tail, 0l::l)\n     \
    \               else dp(arr.tail, minif::l)\n                }\n            }\n\
    \        }\n        val result = dp(arr, List())\n        result.head", "    \
    \    val n = arr.length\n        val minChanges = Array.ofDim[Long](n, n)\n  \
    \      for (l <- 0 until n) {\n            for (i <- 0 until n) {\n          \
    \      val j = i + l\n                if (j >= n) {\n                    // Out\
    \ of bounds\n                    continue\n                }\n               \
    \ if (i == j) {\n                    // Single letter is always a palindrome\n\
    \                    minChanges(i)(j) = 0\n                } else if (i + 1 ==\
    \ j) {\n                    // Two letters must match\n                    minChanges(i)(j)\
    \ = arr(i) match {\n                        case v : Long if (v == arr(j)) =>\
    \ 0\n                        case _ => 1\n                    }\n            \
    \    } else {\n                    // More than two letters\n                \
    \    if (arr(i) == arr(j)) {\n                        // Matching letters, so\
    \ no changes needed\n                        minChanges(i)(j) = minChanges(i +\
    \ 1)(j - 1)\n                    } else {\n                        // Non-matching\
    \ letters, so we have to check which of the two is the smallest\n            \
    \            minChanges(i)(j) = min(minChanges(i + 1)(j), minChanges(i)(j - 1))\
    \ + 1\n                    }\n                }\n            }\n        }\n  \
    \      minChanges(0)(n - 1)", "        def m(arr : List[Long], pos : Long) : Long\
    \ = {\n            if (pos >= arr.length) 0\n            else min(m(arr, pos +\
    \ 1), 1 + m(arr, pos + 2))\n        }\n        m(arr, 0)", "        var count\
    \ = 0l\n        var a = arr\n        var b = arr.reverse\n        while (a.length\
    \ != 0) {\n            if (a.head != b.head) count += 1\n            a = a.tail\n\
    \            b = b.tail\n        }\n        count", "        val n = arr.length\n\
    \        val p = Array.ofDim[Long](n, n)\n        for (i <- 0 until n) {\n   \
    \         p(i)(i) = arr(i)\n        }\n        for (k <- 1 until n) {\n      \
    \      for (i <- 0 until n - k) {\n                p(i)(i + k) = p(i)(i + k -\
    \ 1) ^ p(i + 1)(i + k)\n            }\n        }\n        val dp = Array.ofDim[Long](n,\
    \ n)\n        for (i <- 0 until n) {\n            dp(i)(i) = 0\n        }\n  \
    \      for (k <- 1 until n) {\n            for (i <- 0 until n - k) {\n      \
    \          var min = k\n                for (j <- 0 until k) {\n             \
    \       min = min min (dp(i)(i + j) + dp(i + j + 1)(i + k))\n                }\n\
    \                dp(i)(i + k) = min + (p(i)(i + k) != 0).toLong\n            }\n\
    \        }\n        dp(0)(n - 1)", "        val n = arr.length\n        val dp\
    \ = Array.ofDim[Long](n, n)\n        def recurse(i : Int, j : Int) : Long = {\n\
    \            if (i >= j) 0l\n            else if (dp(i)(j) > 0) dp(i)(j)\n   \
    \         else {\n                if (arr(i) == arr(j)) dp(i)(j) = recurse(i +\
    \ 1, j - 1)\n                else dp(i)(j) = 1 + min(recurse(i + 1, j), recurse(i,\
    \ j - 1))\n            }\n            dp(i)(j)\n        }\n        recurse(0,\
    \ n - 1)", "      val n = arr.length\n      val m = HashMap[(Int, Int), Long]()\n\
    \      def dp(i : Int, j : Int) : Long = {\n        if (m.contains((i, j))) m((i,\
    \ j))\n        else {\n          if (i == j) m((i, j)) = 0\n          else if\
    \ (i == j - 1) m((i, j)) = if (arr(i) == arr(j)) 0 else 1\n          else {\n\
    \            if (arr(i) == arr(j)) m((i, j)) = dp(i + 1, j - 1)\n            else\
    \ m((i, j)) = 1 + min(dp(i + 1, j), dp(i, j - 1))\n          }\n          m((i,\
    \ j))\n        }\n      }\n      dp(0, n - 1)", "\t\tval a = arr.toArray\n\t\t\
    var count = 0l\n\t\tfor (i <- 0 until a.length / 2) {\n\t\t\tif (a(i) != a(a.length\
    \ - 1 - i)) count += 1\n\t\t}\n\t\tcount", "        var count = 0l\n        for\
    \ (i <- 0 to arr.length / 2) {\n            if (arr(i) != arr(arr.length - 1 -\
    \ i)) {\n                count += 1\n            }\n        }\n        count",
  "        val (len, pal) = palindromeEnds(arr)\n        var rev = arr.reverse\n \
    \       val (lenR, palR) = palindromeEnds(rev)\n        if (len >= lenR) len else\
    \ lenR", "        def smallestChange(arr : List[Long], l : Long, r : Long, count\
    \ : Long) : Long = {\n            if (l == r) count\n            else if (l ==\
    \ r - 1) {\n                if (arr(l.toInt) == arr(r.toInt)) count\n        \
    \        else count + 1\n            }\n            else {\n                if\
    \ (arr(l.toInt) == arr(r.toInt)) smallestChange(arr, l + 1, r - 1, count)\n  \
    \              else List(smallestChange(arr, l + 1, r, count + 1), smallestChange(arr,\
    \ l, r - 1, count + 1)).min\n            }\n        }\n        smallestChange(arr,\
    \ 0, arr.length - 1, 0)", "        def change(arr : List[Long], i : Int, k : Int)\
    \ : Long = {\n            if (i >= k) {\n                return 0l\n         \
    \   }\n            val minChange = min(change(arr, i + 1, k), change(arr, i, k\
    \ - 1))\n            val minChange = min(minChange, change(arr, i + 1, k - 1))\n\
    \            arr(i) = arr(k)\n            val maxChange = max(change(arr, i +\
    \ 1, k), change(arr, i, k - 1))\n            val maxChange = max(maxChange, change(arr,\
    \ i + 1, k - 1))\n            return minChange\n        }\n        change(arr,\
    \ 0, arr.length - 1)", "        val n = arr.length\n        val m = n/2\n    \
    \    var cost = 0l\n        for (i <- 0 until m) {\n            val j = n - i\
    \ - 1\n            if (arr(i) != arr(j)) {\n                cost += abs(arr(i)\
    \ - arr(j))\n            }\n        }\n        cost", "        if (arr.size ==\
    \ 0) return 0l\n        val length = arr.size\n        val count = Array.ofDim[Long](length,\
    \ length)\n        for (k <- 0 until length) {\n            for (i <- 0 until\
    \ length - k) {\n                val j = i + k\n                if (i == j) count(i)(j)\
    \ = 0\n                else if (i + 1 == j) count(i)(j) = if (arr(i) == arr(j))\
    \ 0 else 1\n                else {\n                    val first = count(i +\
    \ 1)(j)\n                    val second = count(i)(j - 1)\n                  \
    \  count(i)(j) = min(first, second) + (if (arr(i) == arr(j)) 0 else 1)\n     \
    \           }\n            }\n        }\n        count(0)(length - 1)", "    \
    \    var change = 0l\n        val mid = arr.length / 2\n        for (i <- 0 until\
    \ mid) change += abs(arr(i) - arr(arr.length - 1 - i))\n        change", "   \
    \     var first = true\n        var left = 0\n        var right = arr.length -\
    \ 1\n        var count = 0l\n        while (left < right) {\n            if (arr(left)\
    \ != arr(right)) {\n                if (first) {\n                    if (arr(left)\
    \ != arr(right - 1)) {\n                        count += abs(arr(left) - arr(right))\n\
    \                        right -= 1\n                    } else {\n          \
    \              count += abs(arr(left) - arr(right - 1))\n                    \
    \    right -= 2\n                    }\n                    first = false\n  \
    \              } else {\n                    count += abs(arr(left) - arr(right))\n\
    \                    right -= 1\n                }\n            }\n          \
    \  left += 1\n        }\n        count", "        val a = Array.ofDim[Long](arr.length,\
    \ arr.length)\n        for (i <- 0 until arr.length) {\n            for (j <-\
    \ 0 until arr.length) {\n                if (i > j) a(i)(j) = 0\n            \
    \    else if (i == j) a(i)(j) = 1\n                else a(i)(j) = Long.MaxValue\n\
    \            }\n        }\n        for (gap <- 1 until arr.length) {\n       \
    \     for (i <- 0 until arr.length - gap) {\n                val j = i + gap\n\
    \                if (arr(i) == arr(j)) a(i)(j) = a(i + 1)(j - 1)\n           \
    \     else a(i)(j) = min(a(i + 1)(j), a(i)(j - 1)) + 1\n            }\n      \
    \  }\n        a(0)(arr.length - 1)", "        val n = arr.length\n        // a[i][j]\
    \ is the number of elements that need to be changed to make the subarray arr[i..j]\
    \ palindromic\n        // it is obtained from a[i+1][j-1] (which is the number\
    \ of elements that need to be changed to make the subarray arr[i+1..j-1] palindromic)\n\
    \        // and the number of elements that need to be changed to make arr[i]\
    \ equal to arr[j] (which is 1 if arr[i] != arr[j])\n        val a = Array.ofDim[Long](n,\
    \ n)\n        for (i <- n - 1 to 0 by -1) {\n            a(i)(i) = 0\n       \
    \     for (j <- i + 1 until n) {\n                if (arr(i) == arr(j)) a(i)(j)\
    \ = a(i + 1)(j - 1)\n                else a(i)(j) = min(a(i + 1)(j), a(i)(j -\
    \ 1)) + 1\n            }\n        }\n        return a(0)(n - 1)", "        def\
    \ f(arr : List[Long], i : Int, j : Int, cnt : Long) : Long = {\n            if\
    \ (i >= j) return cnt\n            if (arr(i) == arr(j)) f(arr, i + 1, j - 1,\
    \ cnt)\n            else {\n                val n1 = f(arr, i + 1, j, cnt + 1)\n\
    \                val n2 = f(arr, i, j - 1, cnt + 1)\n                if (n1 <\
    \ n2) n1 else n2\n            }\n        }\n        f(arr, 0, arr.length - 1,\
    \ 0)", "        var diffs = List[Long]()\n        for (i <- 0 until arr.length\
    \ / 2) diffs = abs(arr(i) - arr(arr.length - 1 - i)) :: diffs\n        diffs.foldLeft(0l)((a,\
    \ b) => a + b)", '        null', "        arr.size match {\n            case 0\
    \ => 0\n            case 1 => 0\n            case 2 => if (arr(0) == arr(1)) 0\
    \ else 1\n            case _ => {\n                val n = arr.size\n        \
    \        var m = Array.ofDim[Long](n, n)\n                for (i <- 0 until n)\
    \ m(i)(i) = 0\n                for (l <- 2 to n) {\n                    for (i\
    \ <- 0 to n - l) {\n                        val j = i + l - 1\n              \
    \          if (arr(i) == arr(j)) m(i)(j) = m(i + 1)(j - 1)\n                 \
    \       else m(i)(j) = min(m(i + 1)(j), m(i)(j - 1)) + 1\n                   \
    \ }\n                }\n                m(0)(n - 1)\n            }\n        }",
  "        val n = arr.length\n        var A = new Array[Array[Long]](n)\n       \
    \ for (i <- 0 until n) A(i) = new Array[Long](n)\n        var B = new Array[Array[Long]](n)\n\
    \        for (i <- 0 until n) B(i) = new Array[Long](n)\n        for (i <- 0 until\
    \ n) A(i)(i) = 0\n        for (i <- 0 until n) B(i)(i) = 0\n        for (k <-\
    \ 1 until n) {\n            for (i <- 0 until n - k) {\n                val j\
    \ = i + k\n                A(i)(j) = (if (arr(i) == arr(j)) A(i + 1)(j - 1) else\
    \ (A(i + 1)(j - 1) + 1))\n                if (i == j - 1) B(i)(j) = A(i)(j)\n\
    \                else B(i)(j) = min(A(i)(j), B(i + 1)(j) + 1, B(i)(j - 1) + 1)\n\
    \            }\n        }\n        B(0)(n - 1)", "        var result = 0l\n  \
    \      var front = 0\n        var back = arr.length - 1\n        while (front\
    \ < back) {\n            if (arr(front) != arr(back)) {\n                result\
    \ += 1\n            }\n            front += 1\n            back -= 1\n       \
    \ }\n        result", "        arr.length match {\n            case length if\
    \ length <= 1 => 0l\n            case length if length % 2 == 0 => {\n       \
    \         var cnt = 0l\n                val halfLength = length / 2\n        \
    \        for (i <- 0 until halfLength) {\n                    if (arr(i) != arr(length\
    \ - 1 - i)) cnt += 1\n                }\n                cnt\n            }\n\
    \            case length if length % 2 == 1 => {\n                var cnt = 0l\n\
    \                val halfLength = length / 2\n                val middleValue\
    \ = arr(halfLength)\n                for (i <- 0 until halfLength) {\n       \
    \             if (arr(i) != arr(length - 1 - i)) cnt += 1\n                }\n\
    \                for (i <- 0 until halfLength) {\n                    if (arr(i)\
    \ != middleValue && arr(length - 1 - i) != middleValue) cnt += 1\n           \
    \     }\n                cnt\n            }\n        }", "        var counter\
    \ = 0\n        for (i <- 0 until arr.length / 2) {\n            if (arr(i) !=\
    \ arr(arr.length - 1 - i)) counter += 1\n        }\n        counter", "      \
    \  val n = arr.length\n        val n2 = n / 2\n        val (a, b) = arr.splitAt(n2)\n\
    \        val ap = a.reverse\n        if (n % 2 == 0) {\n            var count\
    \ = 0l\n            for (i <- 0 until n2) {\n                if (ap(i) != b(i))\
    \ count += 1\n            }\n            count\n        } else {\n           \
    \ var count = 0l\n            for (i <- 0 until n2) {\n                if (ap(i)\
    \ != b(i)) count += 1\n            }\n            count + 1\n        }", "   \
    \     // Calculate the number of changes to the first half of the list\n     \
    \   val mid = (arr.length + 1) / 2 - 1\n        val left = arr.slice(0, mid +\
    \ 1)\n        val right = arr.slice(mid + 1, arr.length).reverse\n        val\
    \ changes = left.indices.foldLeft(0l.toLong) {(z, i) =>\n            if (left(i)\
    \ != right(i)) z + 1 else z\n        }\n        // Add the size of the second\
    \ half of the list\n        changes + (arr.length / 2)", "        val len = arr.length\n\
    \        def smallestChange(l : Int, r : Int) : Long = {\n            if (l >=\
    \ r) 0\n            else if (arr(l) == arr(r)) smallestChange(l + 1, r - 1)\n\
    \            else 1 + min(smallestChange(l + 1, r), smallestChange(l, r - 1))\n\
    \        }\n        smallestChange(0, len - 1)", "        val len = arr.length\n\
    \        val mid = (len - 1) / 2\n        def trychange(front : List[Long], middle\
    \ : Long, back : List[Long]) : Long = {\n            if (front.isEmpty) return\
    \ 0\n            if (front.head != back.head) {\n                if (front.head\
    \ != middle) return 1\n                else return trychange(front.tail, middle,\
    \ back.tail)\n            }\n            else {\n                val t = trychange(front.tail,\
    \ middle, back.tail)\n                if (t == -1) return -1\n               \
    \ else return t + 1\n            }\n        }\n        if (len == 1) return 0\n\
    \        if (len % 2 == 0) {\n            val res = trychange(arr.take(mid), 0,\
    \ arr.drop(mid).reverse)\n            if (res == -1) return -1\n            else\
    \ return len - 1 - res\n        }\n        else {\n            val res = trychange(arr.take(mid),\
    \ arr(mid), arr.drop(mid + 1).reverse)\n            if (res == -1) return -1\n\
    \            else return len - res\n        }", "        arr.length match {\n\
    \            case 1 => 0\n            case 2 => if (arr(0) == arr(1)) 0 else 1\n\
    \            case 3 => {\n                var min = 0\n                for (i\
    \ <- 0 to 1) {\n                    if (arr(i) != arr(2)) min += 1\n         \
    \       }\n                min\n            }\n            case _ => {\n     \
    \           var left = 0\n                var right = arr.length - 1\n       \
    \         var min = 0\n                while (left < right) {\n              \
    \      if (arr(left) != arr(right)) min += 1\n                    left += 1\n\
    \                    right -= 1\n                }\n                min\n    \
    \        }\n        }", "        //E.g. arr = [1, 2, 3, 4, 3, 2, 2]\n        val\
    \ hash = new HashMap[Long, List[Long]]()\n        for (i <- arr.indices) {\n \
    \           if (hash.contains(arr(i))) {\n                hash(arr(i)) = hash(arr(i))\
    \ :+ i.toLong\n            } else {\n                hash += (arr(i) -> List(i.toLong))\n\
    \            }\n        }\n        val freq = new HashMap[Long, Long]()\n    \
    \    for (i <- arr.indices) {\n            if (freq.contains(arr(i))) {\n    \
    \            freq(arr(i)) += 1\n            } else {\n                freq +=\
    \ (arr(i) -> 1)\n            }\n        }\n        val distinct = hash.keys.toList.sorted\n\
    \        // distinct = [1, 2, 3, 4]\n        var result = 0l\n        for (k <-\
    \ distinct) {\n            if (freq(k) % 2 == 1) {\n                result +=\
    \ freq(k) - 1\n                // result = 1\n            } else {\n         \
    \       result += freq(k)\n                // result = 7\n            }\n    \
    \    }\n        var min = Long.MaxValue\n        for (k <- distinct) {\n     \
    \       val mid = freq(k) / 2\n            if (freq(k) % 2 == 1) {\n         \
    \       val pos = hash(k)(mid)\n                // pos = 1\n                var\
    \ l = 0l\n                for (i <- pos.toInt to 0 by -1) {\n                \
    \    // i = 1, 0\n                    if (arr(i) == k) {\n                   \
    \     l += 1\n                    } else {\n                        break\n  \
    \                  }\n                }\n                var r = 0l\n        \
    \        for (i <- pos.toInt to arr.length - 1) {\n                    // i =\
    \ 1, 2, 3, 4, 5, 6\n                    if (arr(i) == k) {\n                 \
    \       r += 1\n                    } else {\n                        break\n\
    \                    }\n                }\n                min = min min (l +\
    \ r - 1)\n                // min = 2\n           ", "        var ans = 0l\n  \
    \      var neg = false\n        var neg_count = 0\n        var prev = 0l\n   \
    \     val map = new HashMap[Long, Int]\n        arr.foreach(x => {\n         \
    \   if (x < 0) {\n                neg = true\n                neg_count += 1\n\
    \            }\n            if (map.contains(x)) map(x) += 1\n            else\
    \ map += (x -> 1)\n        })\n        if (neg) {\n            if (neg_count %\
    \ 2 == 0) {\n                map.foreach(x => {\n                    val i = x._1\n\
    \                    val count = x._2\n                    ans += abs(i - prev)\
    \ * count\n                    prev = i\n                })\n            } else\
    \ {\n                if (map.contains(0l)) {\n                    map.foreach(x\
    \ => {\n                        val i = x._1\n                        val count\
    \ = x._2\n                        ans += abs(i - prev) * count\n             \
    \           prev = i\n                    })\n                } else {\n     \
    \               map.filter(x => x._1 > 0).foreach(x => {\n                   \
    \     val i = x._1\n                        val count = x._2\n               \
    \         ans += abs(i - prev) * count\n                        prev = i\n   \
    \                 })\n                    map.filter(x => x._1 < 0).foreach(x\
    \ => {\n                        val i = x._1\n                        val count\
    \ = x._2\n                        ans += abs(i - prev) * count\n             \
    \           prev = i\n                    })\n                }\n            }\n\
    \        } else {\n            map.foreach(x => {\n                val i = x._1\n\
    \                val count = x._2\n                ans += abs(i - prev) * count\n\
    \                prev = i\n            })\n        }\n        ans", '        ???',
  "        def recurse(arr : List[Long], left : Int, right : Int, minChanges : Long)\
    \ : Long = {\n            if (left >= right) minChanges\n            else if (arr(left)\
    \ == arr(right)) recurse(arr, left + 1, right - 1, minChanges)\n            else\
    \ recurse(arr, left + 1, right, minChanges + 1)\n        }\n        recurse(arr,\
    \ 0, arr.length - 1, 0)", "        def helper(diff : Long, pairs : List[(Long,\
    \ Long)]) : Long = {\n            pairs match {\n                case Nil => diff\n\
    \                case p :: ps => {\n                    val d = abs(p._1 - p._2)\n\
    \                    helper(max(diff, d), ps)\n                }\n           \
    \ }\n        }\n        val l = arr.length\n        val pairs = (0 until l / 2).map(i\
    \ => {\n            val j = l - i - 1\n            (arr(i), arr(j))\n        }).toList\n\
    \        helper(0, pairs)", "        // We first find the maximum palindromic\
    \ subsequence using dynamic programming.\n        // Then we change n - length\
    \ of the palindromic subsequence to get the answer.\n        // The runtime is\
    \ O(n^2).\n        var table = HashMap[(Int, Int), Int]()\n        for (i <- 0\
    \ until arr.length) {\n            table((i, i)) = 1\n        }\n        for (i\
    \ <- 0 until arr.length) {\n            for (j <- i + 1 until arr.length) {\n\
    \                if (arr(i) == arr(j)) {\n                    table((i, j)) =\
    \ table((i + 1, j - 1)) + 2\n                } else {\n                    table((i,\
    \ j)) = max(table((i + 1, j)), table((i, j - 1)))\n                }\n       \
    \     }\n        }\n        (arr.length - table((0, arr.length - 1))).toLong",
  "        val n = arr.length\n        var dp = Array.ofDim[Long](n, n)\n        for\
    \ (l <- 1 to n) {\n            for (i <- 0 to n - l) {\n                val j\
    \ = i + l - 1\n                if (i == j) dp(i)(j) = 0\n                else\
    \ if (i + 1 == j) dp(i)(j) = if (arr(i) == arr(j)) 0 else 1\n                else\
    \ dp(i)(j) = min(dp(i + 1)(j), dp(i)(j - 1)) + if (arr(i) == arr(j)) 0 else 1\n\
    \            }\n        }\n        return dp(0)(n - 1)", "        val n = arr.length\n\
    \        // a[i][j] represents the smallest number of changes to make arr[i..j]\
    \ a palindrome\n        val a = Array.ofDim[Long](n, n)\n        // a[i][j] =\
    \ 0 if i >= j\n        for (i <- 0 until n) a(i)(i) = 0\n        // a[i][j] =\
    \ a[i+1][j-1] if arr[i] == arr[j]\n        for (i <- 0 until n - 1) {\n      \
    \      a(i)(i + 1) = if (arr(i) == arr(i + 1)) 0 else 1\n        }\n        //\
    \ a[i][j] = min(a[i+1][j], a[i][j-1]) + 1 if arr[i] != arr[j]\n        for (d\
    \ <- 2 until n) {\n            for (i <- 0 until n - d) {\n                val\
    \ j = i + d\n                a(i)(j) = if (arr(i) == arr(j)) a(i + 1)(j - 1) else\
    \ min(a(i + 1)(j), a(i)(j - 1)) + 1\n            }\n        }\n        a(0)(n\
    \ - 1)", "        def helper(front : List[Long], back : List[Long], count : Long)\
    \ : Long = (front, back) match {\n            case (Nil, Nil) => count\n     \
    \       case (h1 :: t1, h2 :: t2) => helper(t1, t2, count + (if (h1 == h2) 0 else\
    \ 1))\n        }\n        helper(arr, arr.reverse, 0)", '        return 0l', " \
    \       if (arr.length == 0) 0l\n        else {\n            val half = arr.length\
    \ / 2\n            val left = arr.slice(0, half)\n            val leftCount =\
    \ left.groupBy(identity).mapValues(_.size)\n            val right = arr.slice(half\
    \ + arr.length % 2, arr.length)\n            val rightCount = right.groupBy(identity).mapValues(_.size)\n\
    \            var unique = 0l\n            leftCount.foreach(entry => {\n     \
    \           val value = entry._1\n                val left = entry._2\n      \
    \          val right = rightCount.getOrElse(value, 0)\n                unique\
    \ += abs(left - right)\n            })\n            unique\n        }", "    \
    \  if (arr.size == 0) return 0l\n      if (arr.size == 1) return 0l\n      if\
    \ (arr.size == 2) return 0l\n      if (arr.size == 3) return 0l\n      val mid\
    \ = arr.size / 2\n      // println(mid)\n      var count = 0l\n      for (i <-\
    \ 0 until mid) {\n        if (arr(i) != arr(arr.size - 1 - i)) count += 1\n  \
    \    }\n      if (count <= 1) return count\n      // println(count)\n      val\
    \ firstHalf = arr.slice(0, mid)\n      val secondHalf = arr.slice(mid + 1, arr.size)\n\
    \      firstHalf.length match {\n        case m : Int if (m == 0) => 0l\n    \
    \    case m : Int if (m == 1) => 1l\n        case m : Int if (m == 2) => 1l\n\
    \        case m : Int if (m == 3) => 1l\n        case m : Int if (m == 4) => {\n\
    \          val temp = firstHalf.slice(0, m - 1)\n          // println(temp)\n\
    \          smallestChange(temp) + smallestChange(secondHalf)\n        }\n    \
    \    case m : Int if (m == 5) => {\n          val temp = firstHalf.slice(0, m\
    \ - 1)\n          // println(temp)\n          smallestChange(temp) + smallestChange(secondHalf)\n\
    \        }\n        case m : Int if (m == 6) => {\n          val temp = firstHalf.slice(0,\
    \ m - 1)\n          // println(temp)\n          smallestChange(temp) + smallestChange(secondHalf)\n\
    \        }\n        case m : Int if (m == 7) => {\n          val temp = firstHalf.slice(0,\
    \ m - 1)\n          // println(temp)\n          smallestChange(temp) + smallestChange(secondHalf)\n\
    \        }\n        case m : Int if (m == 8) => {\n          val temp = firstHalf.slice(0,\
    \ m - 1)\n          // println(temp)\n          smallestChange(temp) + smallestChange(secondHalf)\n\
    \        }\n        case m : Int if (m == 9) =>", "        var result = 0l.toLong\n\
    \        var start = 0\n        var end = arr.length - 1\n        while (start\
    \ < end) {\n            if (arr(start) != arr(end)) {\n                result\
    \ += abs(arr(start) - arr(end))\n            }\n            start += 1\n     \
    \       end -= 1\n        }\n        result", "        val table = new HashMap[(Int,\
    \ Int), Long]\n        def search(arr : List[Long], start : Int, end : Int) :\
    \ Long = {\n            if (start > end) 0\n            else if (start == end)\
    \ 0\n            else if (table.contains((start, end))) table((start, end))\n\
    \            else {\n                if (arr(start) == arr(end)) search(arr, start\
    \ + 1, end - 1)\n                else {\n                    val r1 = search(arr,\
    \ start + 1, end)\n                    val r2 = search(arr, start, end - 1)\n\
    \                    table((start, end)) = min(r1, r2) + 1\n                 \
    \   table((start, end))\n                }\n            }\n        }\n       \
    \ search(arr, 0, arr.length - 1)", "        val n = arr.length\n        val dp\
    \ = Array.ofDim[Long](n, n)\n        for (step <- 1 to n - 1) {\n            for\
    \ (i <- 0 to n - step - 1) {\n                val j = i + step\n             \
    \   if (step == 1) dp(i)(j) = if (arr(i) == arr(j)) 0 else 1\n               \
    \ else dp(i)(j) = min(dp(i + 1)(j) + 1, dp(i)(j - 1) + 1)\n                if\
    \ (arr(i) == arr(j)) dp(i)(j) = min(dp(i)(j), dp(i + 1)(j - 1))\n            }\n\
    \        }\n        dp(0)(n - 1)", "        val dp = Array.ofDim[Long](arr.length\
    \ + 1, arr.length + 1)\n        for (i <- 0 to arr.length) dp(i)(i) = 0\n    \
    \    for (s <- 1 to arr.length) {\n            for (i <- 0 to arr.length - s)\
    \ {\n                val j = i + s\n                dp(i)(j) = min(dp(i + 1)(j)\
    \ + 1, dp(i)(j - 1) + 1)\n                if (arr(i) == arr(j - 1)) dp(i)(j) =\
    \ min(dp(i)(j), dp(i + 1)(j - 1))\n            }\n        }\n        dp(0)(arr.length)",
  "        val l = arr.length\n        val memo = Array.ofDim[Long](l, l)\n      \
    \  def helper(i : Int, j : Int) : Long = {\n            if (memo(i)(j) == 0) {\n\
    \                if (i == j) memo(i)(j) = 0\n                else if (i + 1 ==\
    \ j) memo(i)(j) = abs(arr(i) - arr(j))\n                else {\n             \
    \       val a = abs(arr(i) - arr(j))\n                    val b = helper(i + 1,\
    \ j)\n                    val c = helper(i, j - 1)\n                    memo(i)(j)\
    \ = a + min(b, c)\n                }\n            }\n            memo(i)(j)\n\
    \        }\n        helper(0, l - 1)", "        if (arr.length == 0) 0\n     \
    \   else {\n            val p = palindrome(arr)\n            val q = arr.reverse\n\
    \            val (n, _) = longestCommonSubsequence(p, q)\n            arr.length\
    \ - n\n        }", "        def smallestChange0(arr : List[Long], left : Int,\
    \ right : Int) : Long = {\n            if (left > right) return 0l\n         \
    \   if (left == right) return 0l\n            min(arr(left) - arr(left + 1) +\
    \ smallestChange0(arr, left + 1, right),\n                arr(right) - arr(right\
    \ - 1) + smallestChange0(arr, left, right - 1))\n        }\n        smallestChange0(arr,\
    \ 0, arr.length - 1)", "        // Remove a element from the end to the beginning\n\
    \        // Return the minimum difference between the two halves\n        def\
    \ removeLoop(arr : List[Long], low : Long, high : Long) : Long = {\n         \
    \   if (low >= high) 0l\n            else min(abs(arr(low.toInt) - arr(high.toInt))\
    \ + removeLoop(arr, low + 1, high - 1), removeLoop(arr, low + 1, high))\n    \
    \    }\n        removeLoop(arr, 0, arr.length - 1)", "        val cache = HashMap[(Int,\
    \ Int), Int]()\n        def helper(l : Int, r : Int) : Int = {\n            if\
    \ (cache.contains((l, r))) cache((l, r))\n            else {\n               \
    \ if (l >= r) 0\n                else {\n                    val min = min(arr(l).toInt,\
    \ arr(r).toInt)\n                    cache += ((l, r) -> (min + helper(l + 1,\
    \ r - 1)))\n                    cache((l, r))\n                }\n           \
    \ }\n        }\n        helper(0, arr.length - 1)", "        def recurse(arr :\
    \ List[Long], left : Int, right : Int, palindromeLength : Array[Array[Int]], count\
    \ : Long) : Long = {\n            if (left > right) count\n            else if\
    \ (left == right) recurse(arr, left + 1, right - 1, palindromeLength, count)\n\
    \            else if (left == right - 1) {\n                if (arr(left) == arr(right))\
    \ {\n                    palindromeLength(left)(right) = 2\n                 \
    \   recurse(arr, left + 1, right - 1, palindromeLength, count)\n             \
    \   }\n                else {\n                    palindromeLength(left)(right)\
    \ = 1\n                    recurse(arr, left + 1, right - 1, palindromeLength,\
    \ count + 1)\n                }\n            }\n            else {\n         \
    \       if (arr(left) == arr(right)) {\n                    palindromeLength(left)(right)\
    \ = palindromeLength(left + 1)(right - 1) + 2\n                    recurse(arr,\
    \ left + 1, right - 1, palindromeLength, count)\n                }\n         \
    \       else {\n                    palindromeLength(left)(right) = max(palindromeLength(left\
    \ + 1)(right), palindromeLength(left)(right - 1))\n                    recurse(arr,\
    \ left + 1, right - 1, palindromeLength, count + 1)\n                }\n     \
    \       }\n        }\n        val palindromeLength = Array.ofDim[Int](arr.length,\
    \ arr.length)\n        recurse(arr, 0, arr.length - 1, palindromeLength, 0)",
  "        def findMinChange(left : Int, right : Int, changes : Long) : Long = {\n\
    \            if (left >= right) changes\n            else if (arr(left) == arr(right))\
    \ findMinChange(left + 1, right - 1, changes)\n            else {\n          \
    \      val leftChange = findMinChange(left + 1, right, changes + 1)\n        \
    \        val rightChange = findMinChange(left, right - 1, changes + 1)\n     \
    \           if (leftChange < rightChange) leftChange else rightChange\n      \
    \      }\n        }\n        findMinChange(0, arr.length - 1, 0)", "        val\
    \ n = arr.length\n        val m = Array.ofDim[Long](n, n)\n        for (l <- 2\
    \ to n) {\n            for (i <- 0 to n - l) {\n                val j = i + l\
    \ - 1\n                m(i)(j) = min(\n                    m(i + 1)(j) + abs(arr(i)\
    \ - arr(i + 1)),\n                    m(i)(j - 1) + abs(arr(j) - arr(j - 1))\n\
    \                )\n            }\n        }\n        m(0)(n - 1)", "        val\
    \ l = arr.length\n        val m : Array[Array[Long]] = Array.ofDim[Long](l, l)\n\
    \        for (i <- 0 until l; j <- i until l) {\n            if (i == j) m(i)(j)\
    \ = 0\n            else if (i == j - 1) m(i)(j) = abs(arr(i) - arr(j))\n     \
    \       else m(i)(j) = min(m(i)(j - 1), m(i + 1)(j)) + abs(arr(i) - arr(j))\n\
    \        }\n        m(0)(l - 1)", "\tval buffer = ArrayBuffer[Long]()\n\tvar result\
    \ = 0l\n\tif (arr.length == 1) return 0l\n\tif (arr.length == 2) return if (arr(0)\
    \ == arr(1)) 0l else 1l\n\tif (arr.length % 2 == 0) {\n\t    val mid = arr.length\
    \ / 2\n\t    for (i <- 0 until mid) {\n\t\tbuffer += (arr(i) - arr(arr.length\
    \ - 1 - i)).abs\n\t    }\n\t    result = buffer.filter(x => x != 0).min\n\t} else\
    \ {\n\t    val mid = arr.length / 2\n\t    for (i <- 0 until mid) {\n\t\tbuffer\
    \ += (arr(i) - arr(arr.length - 1 - i)).abs\n\t    }\n\t    result = buffer.filter(x\
    \ => x != 0).min\n\t}\n\treturn result", "        def recurse(list : List[Long],\
    \ changes : Long) : Long = {\n            if (list.length == 0) changes\n    \
    \        else {\n                val mid = list.length / 2\n                if\
    \ (list.length % 2 == 0) {\n                    val left = list.slice(0, mid)\n\
    \                    val right = list.slice(mid, list.length).reverse\n      \
    \              recurse(left.tail, changes + abs(left.head - right.head))\n   \
    \             } else {\n                    val left = list.slice(0, mid)\n  \
    \                  val right = list.slice(mid + 1, list.length).reverse\n    \
    \                recurse(left.tail, changes + abs(left.head - right.head))\n \
    \               }\n            }\n        }\n        recurse(arr, 0)", "     \
    \   val n = arr.length\n        val dp = Array.ofDim[Long](n, n)\n        for\
    \ (l <- 2 to n) {\n            for (i <- 0 to n - l) {\n                val j\
    \ = i + l - 1\n                dp(i)(j) = dp(i + 1)(j - 1) + abs(arr(i) - arr(j))\n\
    \                if (l % 2 == 0) {\n                    dp(i)(j) = min(dp(i)(j),\
    \ dp(i + 2)(j) + abs(arr(i) - arr(i + 1)))\n                    dp(i)(j) = min(dp(i)(j),\
    \ dp(i)(j - 2) + abs(arr(j) - arr(j - 1)))\n                }\n            }\n\
    \        }\n        dp(0)(n - 1)", "        val n = arr.length\n        if (n\
    \ == 0) return 0\n        val front = new Array[Int](n)\n        val back = new\
    \ Array[Int](n)\n        front(0) = 0\n        for (i <- 1 until n) {\n      \
    \      front(i) = (front(i - 1) + (if (arr(i) == arr(i - 1)) 0 else 1))\n    \
    \    }\n        back(n - 1) = 0\n        for (i <- (n - 2) to 0 by -1) {\n   \
    \         back(i) = (back(i + 1) + (if (arr(i) == arr(i + 1)) 0 else 1))\n   \
    \     }\n        var min = 1000000\n        for (i <- 0 until n) {\n         \
    \   val change = front(i) + back(i)\n            if (change < min) min = change\n\
    \        }\n        return min", "        val length = arr.length\n        val\
    \ table = Array.ofDim[Long](length, length)\n        for (i <- 1 until length)\
    \ {\n            table(i)(i) = 0\n            table(i)(i - 1) = 0\n        }\n\
    \        for (size <- 2 until length) {\n            for (i <- 0 until length\
    \ - size) {\n                val j = i + size\n                table(i)(j) = min(table(i\
    \ + 1)(j) + 1, table(i)(j - 1) + 1)\n                table(i)(j) = min(table(i)(j),\
    \ table(i + 1)(j - 1) + (if (arr(i) == arr(j)) 0 else 1))\n            }\n   \
    \     }\n        table(0)(length - 1)", "        val middle = arr.length / 2\n\
    \        val left = arr.slice(0, middle)\n        val right = arr.slice(middle\
    \ + arr.length % 2, arr.length)\n        val l = left.size\n        val r = right.size\n\
    \        val memo = Map[(Int, Int), Long]()\n        def recurse(i : Int, j :\
    \ Int) : Long = {\n            if (i == l || j == r) 1l.toLong\n            else\
    \ if (memo.contains((i, j))) memo((i, j))\n            else {\n              \
    \  var min = Long.MaxValue\n                if (left(i) == right(j)) min = recurse(i\
    \ + 1, j + 1)\n                else {\n                    val list = List(recurse(i\
    \ + 1, j), recurse(i, j + 1), recurse(i + 1, j + 1))\n                    min\
    \ = list.min\n                }\n                memo((i, j)) = min\n        \
    \        min\n            }\n        }\n        recurse(0, 0)", "        var k\
    \ = 0l\n        var f = 0l\n        while (f != arr.length) {\n            if\
    \ (arr(f.toInt) != arr(arr.length - 1 - f.toInt)) k += 1\n            f += 1\n\
    \        }\n        if (k == 0) return 0\n        if (k == 2) return 1\n     \
    \   k / 2 + 1", "        val n = arr.length\n        val L = Array.ofDim[Long](n\
    \ + 1, n + 1)\n        for (i <- 0 to n) {\n            L(i)(i) = 0\n        }\n\
    \        for (cl <- 2 to n) {\n            for (i <- 0 to n - cl) {\n        \
    \        val j = i + cl - 1\n                if (arr(i) == arr(j)) L(i)(j) = L(i\
    \ + 1)(j - 1)\n                else L(i)(j) = 1 + min(L(i)(j - 1), L(i + 1)(j))\n\
    \            }\n        }\n        L(0)(n - 1)", "        // >>> small = (1, arr)\n\
    \        val small = (1l, arr)\n        // >>> big = (2, arr)\n        val big\
    \ = (2l, arr)\n        // >>> sort = True\n        val sort = true\n        //\
    \ >>> for i in range(len(arr) // 2):\n        //     if arr[i] != arr[-i - 1]:\n\
    \        //         sort = False\n        //         break\n        for (i <-\
    \ 0 to arr.length - 1) {\n            if (arr(i) != arr(arr.length - i - 1)) {\n\
    \                sort = false\n                // >>> break\n                break\n\
    \            }\n        }\n        // >>> if sort:\n        //     return 0\n\
    \        if (sort) 0l\n        // >>> for i in range(len(arr) // 2):\n       \
    \ //     if arr[i] == arr[-i - 1]:\n        //         small = (min(small[0],\
    \ big[0]), small[1][:-1])\n        //         big = (big[0], big[1][:-1])\n  \
    \      //     else:\n        //         small = (small[0], small[1][:-1])\n  \
    \      //         big = (min(small[0] + 1, big[0]), big[1][:-1])\n        // \
    \    if len(small[1]) == 1:\n        //         break\n        for (i <- 0 to\
    \ arr.length - 1) {\n            if (arr(i) == arr(arr.length - i - 1)) {\n  \
    \              small = (min(small._1, big._1), small._2.slice(0, small._2.length\
    \ - 1))\n                big = (big._1, big._2.slice(0, big._2.length - 1))\n\
    \            } else {\n                small = (small._1, small._2.slice(0, small._2.length\
    \ - 1))\n                big = (min(small._1 + 1, big._1), big._2.slice(0, big._2.length\
    \ - 1))\n            }\n            if (small._2.length == 1) {\n            \
    \    // >>> break\n                break\n            }\n        }\n        //\
    \ >>> return small", "        // What is the recursive structure\n        // The\
    \ list is either 1 element or 2 elements, return 0\n        // The list has more\
    \ than two elements, it is going to be in one of\n        // two forms:\n    \
    \    // 1. arr(0) != arr(arr.length - 1)\n        //    1.1 remove arr(0) and\
    \ check the rest of the list\n        //    1.2 remove arr(arr.length - 1) and\
    \ check the rest of the list\n        // 2. arr(0) == arr(arr.length - 1)\n  \
    \      //    2.1 check the rest of the list\n        // What are the end cases?\n\
    \        // The list is either 1 element or 2 elements, return 0\n        def\
    \ f(arr : List[Long]) : Long = {\n            if (arr.length <= 2) return 0\n\
    \            if (arr(0) != arr(arr.length - 1)) {\n                min(f(arr.tail),\
    \ f(arr.init)) + 1\n            } else {\n                f(arr.init.tail)\n \
    \           }\n        }\n        f(arr)", '        return 0l', "        val l\
    \ = arr.length\n        val dp = Array.ofDim[Long](l, l)\n        for (d <- 0\
    \ until l) {\n            for (i <- 0 until l - d) {\n                val j =\
    \ i + d\n                if (i == j) dp(i)(j) = 0\n                else if (i\
    \ + 1 == j) dp(i)(j) = if (arr(i) == arr(j)) 0 else 1\n                else dp(i)(j)\
    \ = min(dp(i + 1)(j) + 1, dp(i)(j - 1) + 1)\n            }\n        }\n      \
    \  dp(0)(l - 1)", "        def getMinor(arr : List[Long]) : List[Long] = {\n \
    \           if (arr.size == 1) return List[Long]()\n            if (arr.size ==\
    \ 2) return List[Long](arr(0))\n            else return List[Long](arr(0)) :::\
    \ getMinor(arr.slice(1, arr.size - 1)) ::: List[Long](arr(arr.size - 1))\n   \
    \     }\n        if (arr.size == 1) return 0\n        if (arr.size == 2) return\
    \ 0\n        if (arr.size == 3) return 1\n        var mm = 0l\n        val range\
    \ = 1 to (arr.size - 1)\n        for (i <- range) {\n            val l = arr.slice(0,\
    \ i)\n            val r = arr.slice(i, arr.size)\n            val minorLeft =\
    \ getMinor(l)\n            val minorRight = getMinor(r)\n            val diff\
    \ = minorLeft.zip(minorRight).map(x => abs(x._1 - x._2)).sum\n            if (mm\
    \ == 0) mm = diff\n            else if (diff < mm) mm = diff\n        }\n    \
    \    return mm", "        val n = arr.length\n        // dp[i][j] = minimum changes\
    \ necessary to make the sequence from a(i) to a(j) palindromic\n        val dp\
    \ = Array.ofDim[Long](n, n)\n        // compute dp values\n        // dp[i][j]\
    \ = 0 if i == j\n        // dp[i][j] = dp[i + 1][j - 1] if a(i) == a(j)\n    \
    \    // dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]) if a(i) != a(j)\n     \
    \   // dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]) for 0 <= k < j - i\n\
    \        for (diff <- 1 until n) {\n            for (i <- 0 until n - diff) {\n\
    \                val j = i + diff\n                if (arr(i) == arr(j)) dp(i)(j)\
    \ = dp(i + 1)(j - 1)\n                else dp(i)(j) = 1 + min(dp(i + 1)(j), dp(i)(j\
    \ - 1))\n                for (k <- i until j) {\n                    dp(i)(j)\
    \ = min(dp(i)(j), dp(i)(k) + dp(k + 1)(j))\n                }\n            }\n\
    \        }\n        // answer is dp[0][n - 1]\n        dp(0)(n - 1)", "      def\
    \ helper(arr : List[Long], i : Int, j : Int, m : Int) : Long = {\n        if (j\
    \ < m) 0l\n        else if (i >= m) arr(j) - arr(m - i - 1)\n        else {\n\
    \          val x = helper(arr, i + 1, j - 1, m)\n          val y = helper(arr,\
    \ i, j - 1, m)\n          val z = helper(arr, i + 1, j, m)\n          min(min(x,\
    \ y), z)\n        }\n      }\n      val m = arr.length / 2\n      helper(arr,\
    \ 0, arr.length - 1, m)", "        //val palindrome = new HashMap[List[Long],\
    \ Long]()\n        def smallestChange0(arr : List[Long]) : Long = {\n        \
    \    if (arr.length <= 1) {\n                return 0l.toLong\n            }\n\
    \            if (arr.length == 2) {\n                return (arr(0) != arr(1)).toLong\n\
    \            }\n            /*if (palindrome.contains(arr)) {\n              \
    \  return palindrome(arr)\n            }*/\n            //println(arr)\n     \
    \       val left = arr.init\n            val right = arr.tail\n            val\
    \ r1 = (arr(0) != arr(arr.length - 1)).toLong + smallestChange0(left) + smallestChange0(right)\n\
    \            val r2 = smallestChange0(left) + 1l.toLong\n            val r3 =\
    \ smallestChange0(right) + 1l.toLong\n            val result = List(r1, r2, r3).min\n\
    \            //palindrome(arr) = result\n            result\n        }\n     \
    \   smallestChange0(arr)", "        val n = arr.length\n        val arrReverse\
    \ = arr.reverse\n        val dp = Array.ofDim[Long](n + 1, n + 1)\n        for\
    \ (i <- 0 to n) {\n            for (j <- 0 to n) {\n                if (i == 0\
    \ || j == 0) dp(i)(j) = 0\n                else if (arr(i - 1) == arrReverse(j\
    \ - 1)) dp(i)(j) = dp(i - 1)(j - 1) + 1\n                else dp(i)(j) = max(dp(i\
    \ - 1)(j), dp(i)(j - 1))\n            }\n        }\n        n - dp(n)(n)", " \
    \       // Fill Up this function body\n        // `arr` is of type List[Long]\n\
    \        // `return` of type Long\n        if (arr.length == 0) return 0\n   \
    \     if (arr.length == 1) return 1\n        if (arr.length == 2) return if (arr(0)\
    \ == arr(1)) 0 else 1\n        if (arr.length == 3) return if (arr(0) == arr(2))\
    \ 0 else 2\n        // println(arr.mkString(\",\"))\n        def solve(left :\
    \ Int, right : Int) : Long = {\n            // println(left, right)\n        \
    \    if (left == right) return 0\n            if (left + 1 == right) return if\
    \ (arr(left) == arr(right)) 0 else 1\n            if (left + 2 == right) return\
    \ if (arr(left) == arr(right)) 0 else if (arr(left) == arr(right - 1) || arr(left\
    \ + 1) == arr(right)) 1 else 2\n            if (arr(left) == arr(right)) solve(left\
    \ + 1, right - 1)\n            else min(solve(left + 1, right), solve(left, right\
    \ - 1)) + 1\n        }\n        solve(0, arr.length - 1)", "        var arr2 =\
    \ arr\n        if (arr.length == 0) return 0l\n        if (arr.length == 1) return\
    \ 0l\n        if (arr.length == 2) return 1l\n        if (arr.length == 3) return\
    \ 1l\n        var max = 0l\n        for (i <- 0 until arr.length) {\n        \
    \    if (arr(i) > max) max = arr(i)\n        }\n        var right = max\n    \
    \    var left = 0l\n        var leftDiff = 0l\n        var rightDiff = 0l\n  \
    \      while (right - left > 2) {\n            if (arr(leftDiff.toInt) == arr(rightDiff.toInt))\
    \ {\n                left = arr(leftDiff.toInt)\n                right = arr(rightDiff.toInt)\n\
    \                leftDiff += 1\n                rightDiff -= 1\n            }\n\
    \            else if (arr(leftDiff.toInt) < arr(rightDiff.toInt)) {\n        \
    \        left = arr(leftDiff.toInt)\n                leftDiff += 1\n         \
    \   }\n            else {\n                right = arr(rightDiff.toInt)\n    \
    \            rightDiff -= 1\n            }\n        }\n        if (right == left)\
    \ {\n            if (right - 1 == arr(rightDiff.toInt)) {\n                return\
    \ leftDiff + rightDiff + 2\n            }\n            else {\n              \
    \  return leftDiff + rightDiff + 1\n            }\n        }\n        return -1l",
  "      // Make DP of palindromes, where DP[i][j] is true if i - j is a palindrome\n\
    \      val DP = Array.ofDim[Boolean](arr.length, arr.length)\n      // Fill DP\n\
    \      for (i <- 0 until arr.length) {\n        DP(i)(i) = true\n        DP(i)(i\
    \ + 1) = arr(i) == arr(i + 1)\n      }\n      // DP function\n      def DPF(i\
    \ : Int, j : Int) : Boolean = {\n        DP(i)(j) = if (i == j) true else if (i\
    \ + 1 == j) arr(i) == arr(j) else arr(i) == arr(j) && DPF(i + 1, j - 1)\n    \
    \    DP(i)(j)\n      }\n      // Fill DP\n      for (i <- 0 until arr.length)\
    \ {\n        for (j <- 0 until arr.length) {\n          if (i + j + 1 < arr.length)\
    \ DPF(i, i + j + 1)\n        }\n      }\n      // Fill DP(2)\n      val DP2 =\
    \ Array.ofDim[Long](arr.length, arr.length)\n      for (i <- 0 until arr.length)\
    \ {\n        DP2(i)(i) = 0\n        DP2(i)(i + 1) = if (DP(i)(i + 1)) 0 else 1\n\
    \      }\n      // Function for DP(2)\n      def DPF2(i : Int, j : Int) : Long\
    \ = {\n        DP2(i)(j) = if (i == j) 0 else {\n          val x = min(DPF2(i\
    \ + 1, j) + 1, DPF2(i, j - 1) + 1)\n          if (DP(i)(j)) min(x, DPF2(i + 1,\
    \ j - 1)) else x\n        }\n        DP2(i)(j)\n      }\n      // Fill DP(2)\n\
    \      for (i <- 0 until arr.length) {\n        for (j <- 0 until arr.length)\
    \ {\n          if (i + j + 1 < arr.length) DPF2(i", "        // This can be optimised\
    \ using dynamic programming\n        // Every palindrome has a 'centre' where\
    \ either 0 elements or 2 elements are to the left of the 'centre'.\n        //\
    \ It is possible to compute the number of elements that need to be changed by\
    \ working outwards from the centre.\n        // This can be done in O(n^2) time.\
    \ However, this solution has been a bit lazy and done in O(n^3) instead.\n   \
    \     // There will be 2n - 1 centres to check.\n        // For each centre:\n\
    \        // Work outwards to find the number of elements that need to be changed.\n\
    \        // Record the minimum number of elements that need to be changed.\n \
    \       var minCost = Int.MaxValue\n        for (centre <- 0 to arr.length - 1)\
    \ {\n            var cost = 0\n            for (left <- centre - 1 to 0 by -1)\
    \ {\n                if (arr(left) != arr(centre - left)) cost += 1\n        \
    \    }\n            for (right <- centre + 1 to arr.length - 1) {\n          \
    \      if (arr(right) != arr(2 * centre - right)) cost += 1\n            }\n \
    \           if (cost < minCost) minCost = cost\n        }\n        for (centre\
    \ <- 0 to arr.length - 2) {\n            var cost = 0\n            for (left <-\
    \ centre to 0 by -1) {\n                if (arr(left) != arr(centre - left)) cost\
    \ += 1\n            }\n            for (right <- centre + 1 to arr.length - 1)\
    \ {\n                if (arr(right) != arr(2 * centre + 1 - right)) cost += 1\n\
    \            }\n            if (cost < minCost) minCost = cost\n        }\n  \
    \      minCost.toLong", "        if (arr.size <= 1) return 0\n        val palindrome\
    \ = Array.ofDim[Long](arr.size, arr.size)\n        for (gap <- 0 to arr.size -\
    \ 1) {\n            for (left <- 0 to arr.size - gap - 1) {\n                val\
    \ right = left + gap\n                if (gap == 0) palindrome(left)(right) =\
    \ 0\n                else if (gap == 1) palindrome(left)(right) = 1 - (arr(left)\
    \ == arr(right))\n                else {\n                    val diff = arr(left)\
    \ - arr(right)\n                    palindrome(left)(right) = min(palindrome(left\
    \ + 1)(right) + 1, palindrome(left)(right - 1) + 1)\n                    if (diff\
    \ == 0) palindrome(left)(right) = min(palindrome(left)(right), palindrome(left\
    \ + 1)(right - 1))\n                    else palindrome(left)(right) = min(palindrome(left)(right),\
    \ palindrome(left + 1)(right - 1) + 1)\n                }\n            }\n   \
    \     }\n        palindrome(0)(arr.size - 1)", "        def inner(arr : List[Long],\
    \ count : Long) : Long = {\n            if (arr.length <= 1) count\n         \
    \   else if (arr.head == arr.last) inner(arr.drop(1).dropRight(1), count)\n  \
    \          else inner(arr.drop(1), count + 1)\n        }\n        inner(arr, 0)",
  "        def helper(l : List[Long], r : List[Long], result : Long) : Long = {\n\
    \            if (l.length == 0) result\n            else if (l.head == r.head)\
    \ helper(l.tail, r.tail, result)\n            else if (l.length == 1) result +\
    \ 1\n            else {\n                val minimum1 = helper(l.tail, r.tail,\
    \ result + 1)\n                val minimum2 = helper(l.tail, r.init, result +\
    \ 1)\n                min(minimum1, minimum2)\n            }\n        }\n    \
    \    if (arr.length == 0) 0\n        else helper(arr, arr.reverse, 0)", "    \
    \    val size = arr.size\n        def max(a : Int, b : Int) : Int = if (a > b)\
    \ a else b\n        def helper(i : Int, j : Int) : Long = {\n            if (i\
    \ == j) 0\n            else if (i + 1 == j) {\n                if (arr(i) == arr(j))\
    \ 0\n                else 1\n            }\n            else {\n             \
    \   if (arr(i) == arr(j)) helper(i + 1, j - 1)\n                else 1 + max(helper(i\
    \ + 1, j), helper(i, j - 1))\n            }\n        }\n        helper(0, size\
    \ - 1)", "        def reverse(arr : List[Long]) : List[Long] = {\n           \
    \ if (arr.length == 0) arr\n            else reverse(arr.tail) :+ arr.head\n \
    \       }\n        def recur(arr : List[Long], reverseArr : List[Long], min :\
    \ Long) : Long = {\n            if (arr.length == 0) min\n            else if\
    \ (arr.head == reverseArr.head) recur(arr.tail, reverseArr.tail, min)\n      \
    \      else {\n                val m1 = recur(arr.tail, reverseArr.tail, min +\
    \ abs(arr.head - reverseArr.head))\n                val m2 = recur(arr.tail, reverseArr,\
    \ min + 1)\n                val m3 = recur(arr, reverseArr.tail, min + 1)\n  \
    \              min(min(m1, m2), m3)\n            }\n        }\n        recur(arr,\
    \ reverse(arr), arr.length)", "        val n = arr.length\n        val lengths\
    \ = Array.ofDim[Long](n, n)\n        val deltas = Array.ofDim[Long](n, n)\n  \
    \      for (i <- 0 until n) lengths(i)(i) = 1\n        for (i <- 0 until n - 1)\
    \ {\n            lengths(i)(i + 1) = 2\n            deltas(i)(i + 1) = abs(arr(i)\
    \ - arr(i + 1))\n        }\n        for (l <- 3 to n) {\n            for (i <-\
    \ 0 to n - l) {\n                val j = i + l - 1\n                lengths(i)(j)\
    \ = lengths(i + 1)(j - 1) + 2\n                deltas(i)(j) = deltas(i + 1)(j\
    \ - 1) + abs(arr(i) - arr(j))\n            }\n        }\n        val min = new\
    \ Array[Long](n)\n        for (i <- 0 until n) {\n            min(i) = Long.MaxValue\n\
    \            for (j <- 0 to i) {\n                val delta = deltas(j)(i) + 2\
    \ * (n - lengths(j)(i))\n                if (delta < min(i)) min(i) = delta\n\
    \            }\n        }\n        min(n - 1)", '        val a = Array[Long](2l,
    4l, 6l, 8l, 10l, 12l, 14l, 16l, 18l, 20l, 22l, 24l, 26l, 28l, 30l, 32l, 34l, 36l,
    38l, 40l, 42l, 44l, 46l, 48l, 50l, 52l, 54l, 56l, 58l, 60l, 62l, 64l, 66l, 68l,
    70l, 72l, 74l, 76l, 78l, 80l, 82l, 84l, 86l, 88l, 90l, 92l, 94l, 96l, 98l, 100l,
    102l, 104l, 106l, 108l, 110l, 112l, 114l, 116l, 118l, 120l, 122l, 124l, 126l,
    128l, 130l, 132l, 134l, 136l, 138l, 140l, 142l, 144l, 146l, 148l, 150l, 152l,
    154l, 156l, 158l, 160l, 162l, 164l, 166l, 168l, 170l, 172l, 174l, 176l, 178l,
    180l, 182l, 184l, 186l, 188l, 190l, 192l, 194l, 196l, 198l, 200l, 202l, 204l,
    206l, 208l, 210l, 212l, 214l, 216l, 218l, 220l, 222l, 224l, 226l, 228l, 230l,
    232l, 234l, 236l, 238l, 240l, 242l, 244l, 246l, 248l, 250l, 252l, 254l, 256l,
    258l, 260l, 262l, 264l, 266l, 268l, 270l, 272l, 274l, 276l, 278l, 280l, 282l,
    284l, 286l, 288l, 290l, 292l, 294l, 296l, 298l, 300l, 302l, 304l, 306l, 308l,
    310l, 312l, 314l, 316l, 318l, 320l, 322l, 324l, 326l, 328l, 330l, 332l, 334l,
    336l', '        arr.indices.map(i => if (arr(i) != arr(arr.length - 1 - i)) 1
    else 0).sum / 2', "        val n = arr.length\n        val dp = Array.ofDim[Long](n,\
    \ n)\n        for (d <- 0 until n) {\n            for (i <- 0 until n - d) {\n\
    \                val j = i + d\n                if (i == j) dp(i)(j) = 0\n   \
    \             else if (i + 1 == j) dp(i)(j) = (arr(i) - arr(j)).abs\n        \
    \        else {\n                    dp(i)(j) = min(dp(i + 1)(j) + (arr(i) - arr(i\
    \ + 1)).abs, dp(i)(j - 1) + (arr(j) - arr(j - 1)).abs)\n                }\n  \
    \          }\n        }\n        dp(0)(n - 1)", "        if (arr.length % 2 ==\
    \ 0) {\n            var start = 0\n            var end = arr.length - 1\n    \
    \        var change : Long = 0\n            while (start < end) {\n          \
    \      if (arr(start) != arr(end)) change += 1\n                start += 1\n \
    \               end -= 1\n            }\n            change\n        } else {\n\
    \            var start = 0\n            var end = arr.length - 1\n           \
    \ var change : Long = 0\n            while (start < end) {\n                if\
    \ (arr(start) != arr(end)) change += 1\n                start += 1\n         \
    \       end -= 1\n            }\n            change\n        }", "        var\
    \ l = arr.length\n        var count = 0l\n        for (i <- 0 until l/2) {\n \
    \           if (arr(i) != arr(l - i - 1)) count += 1\n        }\n        count",
  "        var array = arr.toArray\n        var count = 0l\n        for (i <- 0 to\
    \ array.length / 2) {\n            if (array(i) != array(array.length - 1 - i))\
    \ {\n                count += 1\n            }\n        }\n        count", " \
    \       def recurse(a : List[Long], b : List[Long], c : Long) : Long = {\n   \
    \         //println(\"a = \" + a)\n            //println(\"b = \" + b)\n     \
    \       //println(\"c = \" + c)\n            (a, b) match {\n                case\
    \ (a :: as, b :: bs) => if (a == b) recurse(as, bs, c) else if (c < 0) -1 else\
    \ recurse(as, bs, c - 1)\n                case (a :: as, b) => if (c < 0) -1 else\
    \ recurse(as, b, c - 1)\n                case (a, b :: bs) => if (c < 0) -1 else\
    \ recurse(a, bs, c - 1)\n                case (a, b) => c\n            }\n   \
    \     }\n        if (arr.length == 0) 0 else recurse(arr, arr.reverse, Long.MaxValue)",
  "        var minCost = 0l\n        var originalList = arr\n        var reverseList\
    \ = originalList.reverse\n        for (i <- 0 until originalList.length) {\n \
    \           if (originalList(i) != reverseList(i)) {\n                minCost\
    \ += 1\n            }\n        }\n        if (minCost == 0) {\n            return\
    \ 0\n        }\n        minCost /= 2\n        minCost", "        // This can be\
    \ done in O(n).\n        // If you change one element, in order to make it palindromic,\
    \ you need to change (at least)\n        // floor(n / 2) elements, where n is\
    \ the size of the list.\n        // In other words, we can recursively check if\
    \ the first element should be changed to the last,\n        // then check if the\
    \ second element should be changed to the second last, and so on.\n        //\
    \ The floor(n / 2)th element is the middle element if n is odd; the list is palindromic.\n\
    \        // The (floor(n / 2) - 1)th element is the middle element if n is even;\
    \ the list is palindromic.\n        // Otherwise, we need to change the first\
    \ element to the last element and then recursively check\n        // the (arr.tail.init,\
    \ 0) list.\n        // We repeat this process with the (arr.tail, 1) list, the\
    \ (arr.init, 1) list, the (arr.tail.init, 0) list,\n        // and so on.\n  \
    \      // If any of these is smaller than the other, then the other three must\
    \ be smaller than it, since\n        // the middle element of (arr.tail.init,\
    \ 0) is one step closer to the middle element of (arr, 0) than\n        // the\
    \ middle element of (arr.tail, 1) is.\n        // If (arr.tail.init, 0) is palindromic,\
    \ then the middle element of (arr.tail.init, 0) must be\n        // equal to the\
    \ middle element of (arr, 0) and the other elements do not matter.\n        //\
    \ So we check (arr.tail.init, 0) as our first step.\n        // TODO: can this\
    \ be done in O(n / 2) time?\n        val n = arr.length\n        val palindromic\
    \ = (arr.head == arr.last)\n        // If arr.tail.init is palindromic, then our\
    \ answer is 0; the list is already palindromic.\n        // Otherwise, our answer\
    \ is the smaller of the two possible answers.\n        if (palindromic) {\n  \
    \          0\n        } else {\n            min(smallest", '        null', " \
    \       val dp = Array.ofDim[Long](arr.length, arr.length)\n        for (i <-\
    \ 0 until arr.length; j <- 0 until arr.length) {\n            dp(i)(j) = -1l\n\
    \        }\n        def f(start : Int, end : Int) : Long = {\n            if (dp(start)(end)\
    \ != -1l) return dp(start)(end)\n            val res = if (start >= end) 0 else\
    \ {\n                if (arr(start) == arr(end)) f(start + 1, end - 1)\n     \
    \           else {\n                    min(f(start + 1, end), f(start, end -\
    \ 1)) + 1\n                }\n            }\n            dp(start)(end) = res\n\
    \            res\n        }\n        f(0, arr.length - 1)", "        def inner(arr\
    \ : List[Long], value : Long) : Long = {\n            arr match {\n          \
    \      case x :: xs =>\n                    if (x == value) inner(xs, value +\
    \ 1)\n                    else inner(xs, value)\n                case Nil =>\n\
    \                    value - 1\n            }\n        }\n        val sorted =\
    \ arr.sorted\n        inner(sorted, sorted.head)", "        def findSmallestChange(arr\
    \ : List[Long], i : Int, j : Int, count : Long) : Long = {\n            if (i\
    \ >= j) count\n            else if (arr(i) == arr(j)) findSmallestChange(arr,\
    \ i + 1, j - 1, count)\n            else {\n                val min1 = findSmallestChange(arr,\
    \ i + 1, j, count + 1)\n                val min2 = findSmallestChange(arr, i,\
    \ j - 1, count + 1)\n                if (min1 < min2) min1 else min2\n       \
    \     }\n        }\n        findSmallestChange(arr, 0, arr.length - 1, 0)", " \
    \       arr.length match {\n            case 0 => 0\n            case 1 => 0\n\
    \            case 2 => if (arr(0) == arr(1)) 0 else 1\n            case _ =>\n\
    \                val mid = arr.length / 2\n                if (arr.length % 2\
    \ == 0) {\n                    val first = arr.slice(0, mid)\n               \
    \     val second = arr.slice(mid, arr.length).reverse\n                    val\
    \ firstLongestPalindrome = longestPalindromeAtIndex(first, 0)\n              \
    \      val secondLongestPalindrome = longestPalindromeAtIndex(second, 0)\n   \
    \                 val min1 = arr.length - firstLongestPalindrome - secondLongestPalindrome\n\
    \                    val firstLongestPalindrome2 = longestPalindromeAtIndex(first,\
    \ mid - 1)\n                    val secondLongestPalindrome2 = longestPalindromeAtIndex(second,\
    \ mid - 1)\n                    val min2 = arr.length - firstLongestPalindrome2\
    \ - secondLongestPalindrome2\n                    min(min1, min2)\n          \
    \      } else {\n                    val first = arr.slice(0, mid)\n         \
    \           val second = arr.slice(mid + 1, arr.length).reverse\n            \
    \        val firstLongestPalindrome = longestPalindromeAtIndex(first, 0)\n   \
    \                 val secondLongestPalindrome = longestPalindromeAtIndex(second,\
    \ 0)\n                    val min1 = arr.length - firstLongestPalindrome - secondLongestPalindrome\n\
    \                    val firstLongestPalindrome2 = longestPalindromeAtIndex(first,\
    \ mid)\n                    val secondLongestPalindrome2 = longestPalindromeAtIndex(second,\
    \ mid)\n                    val min2 = arr.length - firstLongestPalindrome2 -\
    \ secondLongestPalindrome2\n                    min(min1, min2)\n            \
    \    }\n        }", "        val n = arr.length;\n        var f = new Array[Array[Long]](n);\n\
    \        for (i <- 0 until n) {\n            f(i) = new Array[Long](n);\n    \
    \        for (j <- 0 until n) f(i)(j) = -1;\n        }\n        def go(i : Int,\
    \ j : Int) : Long = {\n            if (f(i)(j) != -1) return f(i)(j);\n      \
    \      var result = Long.MaxValue;\n            if (i == j) result = 0;\n    \
    \        else if (i > j) result = 0;\n            else if (i + 1 == j) result\
    \ = if (arr(i) == arr(j)) 0 else 1;\n            else {\n                if (arr(i)\
    \ == arr(j)) result = go(i + 1, j - 1);\n                else result = 1 + min(go(i\
    \ + 1, j), go(i, j - 1));\n            }\n            f(i)(j) = result;\n    \
    \        result;\n        }\n        go(0, n - 1);", "        if (arr.length %\
    \ 2 == 0) {\n            val arr1 = arr.slice(0, arr.length / 2)\n           \
    \ val arr2 = arr.slice(arr.length / 2, arr.length).reverse\n            val diff\
    \ = (arr1, arr2).zipped.map(_ - _).map(x => abs(x)).sum\n            diff / 2\n\
    \        } else {\n            val arr1 = arr.slice(0, arr.length / 2)\n     \
    \       val arr2 = arr.slice(arr.length / 2 + 1, arr.length).reverse\n       \
    \     val diff = (arr1, arr2).zipped.map(_ - _).map(x => abs(x)).sum\n       \
    \     diff / 2\n        }", "        def loop(arr : List[Long], acc : Long) :\
    \ Long = {\n            if (arr.length < 2) {\n                acc\n         \
    \   } else {\n                if (arr.head == arr.last) {\n                  \
    \  loop(arr.tail.init, acc)\n                } else {\n                    loop(arr.tail.init,\
    \ acc + 1)\n                }\n            }\n        }\n        loop(arr, 0)",
  "        def getChangeForSubArray(arr : List[Long], left : Int, right : Int) : Long\
    \ = {\n            var lCount = 0\n            var rCount = 0\n            while\
    \ (left >= 0 && right < arr.length && arr(left) == arr(right)) {\n           \
    \     left -= 1\n                right += 1\n            }\n            if (left\
    \ < 0) lCount = right - 1\n            else if (right >= arr.length) rCount =\
    \ arr.length - left - 1\n            else {\n                lCount = (right -\
    \ left - 1) / 2\n                rCount = right - left - 1 - lCount\n        \
    \    }\n            lCount + rCount\n        }\n        val changes = Array.fill(arr.length)(0l)\n\
    \        for (i <- 1 until arr.length) {\n            changes(i) = min(changes(i\
    \ - 1) + 1, getChangeForSubArray(arr, i - 1, i))\n        }\n        changes(arr.length\
    \ - 1)", "        var ans = 0l.toLong\n        var l = 0\n        var r = arr.length\
    \ - 1\n        while (l < r) {\n            val n1 = arr(l)\n            val n2\
    \ = arr(r)\n            if (n1 != n2) {\n                ans += 1\n          \
    \  }\n            l += 1\n            r -= 1\n        }\n        ans", "     \
    \   val n = arr.length\n        val s = Array.ofDim[Long](n + 1, n + 1)\n    \
    \    for (i <- 0 to n) {\n            s(i)(i) = 0\n        }\n        for (i <-\
    \ n - 1 to 0 by -1) {\n            for (j <- i + 1 to n) {\n                val\
    \ k = j - i - 1\n                s(i)(j) = min(s(i + 1)(j) + abs(arr(i) - arr(i\
    \ + k)), s(i)(j - 1) + abs(arr(j - 1) - arr(i + k)))\n            }\n        }\n\
    \        val mid = n / 2\n        s(0)(n) - s(0)(mid) - s(mid + 1)(n)", "    \
    \    val arrLen = arr.length\n        var dp = Array.ofDim[Long](arrLen, arrLen)\n\
    \        for (i <- 0 until arrLen) {\n            dp(i)(i) = 0\n        }\n  \
    \      for (l <- 2 to arrLen) {\n            for (i <- 0 to arrLen - l) {\n  \
    \              val j = i + l - 1\n                if (arr(i) == arr(j)) dp(i)(j)\
    \ = dp(i + 1)(j - 1)\n                else dp(i)(j) = 1 + min(dp(i + 1)(j), dp(i)(j\
    \ - 1))\n            }\n        }\n        dp(0)(arrLen - 1)", "        // Create\
    \ a palindrome made up of the lowest valued elements.\n        // For example,\
    \ the list (5, 4, 7, 9, 6) will be changed into (4, 4, 7, 6, 6).\n        // The\
    \ list (5, 4, 7, 9, 6) will be changed into (4, 4, 7, 6, 6).\n        // The list\
    \ (1, 2, 3, 4, 3, 2, 2) will be changed into (1, 2, 2, 2, 2, 2, 2).\n        //\
    \ The list (1, 2, 3, 2, 1) will be changed into (1, 2, 2, 2, 1).\n        // The\
    \ palindrome is guaranteed to be length >= 3.\n        val palindrome = arr.sorted.zipWithIndex.filter(_._2\
    \ < arr.length / 2).map(x => x._1) ++ arr.sorted.reverse.zipWithIndex.filter(_._2\
    \ < arr.length / 2).map(x => x._1)\n        // The number of changes is the number\
    \ of indices that are not equal between the\n        // original array and the\
    \ palindrome array.\n        (0l /: (arr.zip(palindrome).filter(x => x._1 != x._2)))((total,\
    \ next) => total + 1l)", "        val n = arr.length\n        val sum = Array.ofDim[Long](n,\
    \ n)\n        val min = Array.ofDim[Long](n, n)\n        for (i <- 0 until n)\
    \ {\n            sum(i)(i) = arr(i)\n            min(i)(i) = 0\n        }\n  \
    \      for (i <- 0 until n - 1) {\n            sum(i)(i + 1) = arr(i) + arr(i\
    \ + 1)\n            min(i)(i + 1) = sum(i)(i + 1) - max(arr(i), arr(i + 1))\n\
    \        }\n        for (k <- 2 until n) {\n            for (i <- 0 until n -\
    \ k) {\n                sum(i)(i + k) = sum(i)(i + k - 1) + arr(i + k)\n     \
    \           min(i)(i + k) = min(i)(i + k - 1) + sum(i)(i + k) - arr(i + k) * 2\n\
    \                for (j <- i until i + k) {\n                    min(i)(i + k)\
    \ = min(i)(i + k) - max(arr(j), sum(i)(i + k) - arr(j))\n                }\n \
    \           }\n        }\n        min(0)(n - 1)", "      // >>> (1, 2, 3, 4, 3,\
    \ 2, 2)\n      // >>> (1, 2, 3, 4, 2, 2)\n      // >>> (1, 2, 3, 2, 2)\n     \
    \ // >>> (1, 2, 2, 2)\n      // >>> (1, 2, 2)\n      // >>> (1, 2)\n      // >>>\
    \ (1)\n      // >>> ()\n      // >>>\n      // >>> (1, 2, 3, 4, 3, 2, 2)\n   \
    \   // >>> (1, 2, 3, 3, 2, 2)\n      // >>> (1, 2, 3, 2, 2)\n      // >>> (1,\
    \ 2, 2, 2)\n      // >>> (1, 2, 2)\n      // >>> (1, 2)\n      // >>> (1)\n  \
    \    // >>> ()\n      // >>>\n      // >>> (1, 2, 3, 4, 3, 2, 2)\n      // >>>\
    \ (1, 2, 3, 2, 2)\n      // >>> (1, 2, 2, 2)\n      // >>> (1, 2, 2)\n      //\
    \ >>> (1, 2)\n      // >>> (1)\n      // >>> ()\n      // >>>\n      // >>> (1,\
    \ 2, 3, 4, 3, 2, 2)\n      // >>> (1, 2, 3, 2, 2)\n      // >>> (1, 2, 2, 2)\n\
    \      // >>> (1, 2, 2)\n      // >>> (1, 2)\n      // >>> (1)\n      // >>> ()\n\
    \      // >>>\n      // >>> (1, 2, 3, 4, 3, 2, 2)\n      // >>> (1, 2, 3, 2, 2)\n\
    \      // >>> (1, 2, 2, 2)\n      // >>> (1, 2, 2)\n      // >>> (1, 2)\n    \
    \  // >>> (1)\n      // >>> ()\n      // >>>\n      // >>> (1, 2, 3, 4, 3, 2,\
    \ 2)\n      // >>> (1, 2, 3, 2, 2)\n      // >>> (1, 2, 2, 2)\n      // >>> (1,\
    \ 2, 2)\n      // >>> (", "        def helper(arr : List[Long], first : Long,\
    \ last : Long, count : Long) : Long = {\n            if (first > last) count\n\
    \            else if (arr(first.toInt) == arr(last.toInt)) helper(arr, first +\
    \ 1, last - 1, count)\n            else if (arr(first.toInt) > arr(last.toInt))\
    \ helper(arr, first, last - 1, count + 1)\n            else helper(arr, first\
    \ + 1, last, count + 1)\n        }\n        helper(arr, 0, arr.length - 1, 0)",
  "        var minimum = Long.MaxValue\n        def helper(lst : List[Long], count\
    \ : Long) : Long = {\n            if (lst.length == 0) minimum = min(minimum,\
    \ count)\n            else if (lst.length == 1) minimum = min(minimum, count)\n\
    \            else if (lst.length == 2) {\n                if (lst(0) == lst(1))\
    \ minimum = min(minimum, count)\n                else minimum = min(minimum, count\
    \ + 1)\n            }\n            else {\n                val first = lst.head\n\
    \                val middle = lst.length / 2\n                val last = lst.last\n\
    \                if (first == last) helper(lst.slice(1, middle) ++ lst.slice(middle\
    \ + 1, lst.length - 1), count)\n                else {\n                    helper(lst.slice(1,\
    \ middle) ++ lst.slice(middle + 1, lst.length - 1), count + 1)\n             \
    \       helper(lst.slice(0, middle) ++ lst.slice(middle + 1, lst.length), count\
    \ + 1)\n                }\n            }\n            minimum\n        }\n   \
    \     helper(arr, 0)", "        arr.foldLeft(ArrayBuffer[Long]())((z, i) => {\n\
    \            if (z.length == 0) z += i\n            else if (z.last != i) z +=\
    \ i\n            else z.trimEnd(1)\n            z\n        }).length", "     \
    \   var palindrome = arr\n        //println(palindrome)\n        while (!isPalindrome(palindrome))\
    \ {\n            palindrome = palindrome.drop(1)\n            //println(palindrome)\n\
    \        }\n        (arr.length - palindrome.length).toLong", "        // Write\
    \ your code here\n        0l", "        if (arr.length % 2 == 0) {\n         \
    \   arr.grouped(2).map(x => x.head - x.last).foldLeft(0l.toLong)((x, y) => x +\
    \ abs(y))\n        } else {\n            (arr.grouped(2).map(x => if (x.length\
    \ == 2) x.head - x.last else abs(x.head)).foldLeft(0l.toLong)((x, y) => x + y))\n\
    \        }", "        if (arr.length == 0) 0l\n        else {\n            var\
    \ result = 0l\n            var counter = 0\n            while (counter < arr.length\
    \ / 2) {\n                if (arr(counter) != arr(arr.length - 1 - counter)) result\
    \ += 1\n                counter += 1\n            }\n            result\n    \
    \    }", "        val n = arr.length\n        var x = new Array[Long](n+1)\n \
    \       x(0) = 0\n        for (i <- 1 to n) {\n            x(i) = x(i-1) + arr(i-1)\n\
    \        }\n        var result = Long.MaxValue\n        for (i <- 0 to n) {\n\
    \            result = min(result, x(i) + x(n) - x(i) - x(n-i))\n        }\n  \
    \      result", "      val longestPalindrome = new LongestPalindrome(arr)\n  \
    \    arr.length - longestPalindrome.subsequences.maxBy(_.length).length", "  \
    \      def main(arr : List[Long], count : Long) : Long = {\n            if (arr.size\
    \ == 1) count\n            else {\n                if (arr.head != arr.last) main(arr.drop(1).dropRight(1),\
    \ count + 1)\n                else main(arr.drop(1).dropRight(1), count)\n   \
    \         }\n        }\n        main(arr, 0)", "        val n = arr.length\n \
    \       // dp(i)(j) represents the minimum number of changes required to make\n\
    \        // arr(i) to arr(j) palindromic.\n        val dp = Array.ofDim[Long](n,\
    \ n)\n        for (k <- 1 to n - 1) {\n            for (i <- 0 to n - k - 1) {\n\
    \                val j = i + k\n                dp(i)(j) = min(dp(i + 1)(j), dp(i)(j\
    \ - 1)) + 1\n                if (arr(i) == arr(j)) dp(i)(j) = min(dp(i)(j), dp(i\
    \ + 1)(j - 1))\n            }\n        }\n        dp(0)(n - 1)", "        val\
    \ a = arr.toArray\n        val n = a.length\n        val dp = Array.ofDim[Long](n,\
    \ n)\n        for (j <- 0 until n) {\n            for (i <- j - 1 to 0 by -1)\
    \ {\n                val c = if (a(i) == a(j)) dp(i + 1)(j - 1) else 1 + min(dp(i\
    \ + 1)(j), dp(i)(j - 1))\n                dp(i)(j) = c\n            }\n      \
    \  }\n        dp(0)(n - 1)", "        if (arr.length <= 1) return 0l\n       \
    \ val center = (arr.length + 1) / 2\n        val centerOdd = arr.length % 2 !=\
    \ 0\n        var v = 0l\n        if (centerOdd) {\n            for (i <- 0 until\
    \ center) {\n                if (arr(i) != arr(arr.length - 1 - i)) v += 1\n \
    \           }\n        } else {\n            for (i <- 0 until center) {\n   \
    \             if (arr(i) != arr(arr.length - 1 - i)) v += 1\n            }\n \
    \       }\n        v", "        val mid = arr.length / 2\n        var count =\
    \ 0l\n        for (i <- 0 until mid) {\n            count += abs(arr(i) - arr(arr.length\
    \ - 1 - i))\n        }\n        count", "        arr.length match {\n        \
    \    case 0 => 0\n            case 1 => 0\n            case 2 => abs(arr(0) -\
    \ arr(1))\n            case _ => (arr.length - 1) / 2 match {\n              \
    \  case 0 => abs(arr(0) - arr(1))\n                case x => abs(arr(0) - arr(1))\
    \ + abs(arr(x) - arr(x + 1)) + smallestChange(arr.slice(1, x) ++ arr.slice(x +\
    \ 2, arr.length))\n            }\n        }", "        val length = arr.length;\
    \ val half = length / 2\n        var current = 0l\n        for (i <- 0 until half)\
    \ {\n            val x = abs(arr(i) - arr(length - 1 - i))\n            current\
    \ += x\n        }\n        current", "        def recurse(list : List[Long], l\
    \ : Long, r : Long, cache : HashMap[(List[Long], Long, Long), Long]) : Long =\
    \ {\n            if (l == r) return 0\n            if (l == r - 1) return if (list(l.toInt)\
    \ == list(r.toInt)) 0 else 1\n            if (cache.contains((list, l, r))) return\
    \ cache((list, l, r))\n            val min = if (list(l.toInt) == list(r.toInt))\
    \ recurse(list, l + 1, r - 1, cache) else 1 + min(recurse(list, l + 1, r, cache),\
    \ recurse(list, l, r - 1, cache))\n            cache((list, l, r)) = min\n   \
    \         min\n        }\n        recurse(arr, 0, arr.length - 1, new HashMap[(List[Long],\
    \ Long, Long), Long])", "        var res = Long.MaxValue\n        for (i <- 0\
    \ until arr.length) {\n            val shift = if (i == 0) 0 else arr(i - 1)\n\
    \            val steps = 2l.toLong * (i) + (arr.length - i - 1) - shift\n    \
    \        res = min(res, steps)\n        }\n        res", "        val arr2 = arr.toArray\n\
    \        val N = arr.length\n        var i = 0\n        var j = N - 1\n      \
    \  var count = 0\n        while (i < j) {\n            if (arr2(i) != arr2(j))\
    \ {\n                count += 1\n            }\n            i += 1\n         \
    \   j -= 1\n        }\n        return count", "      val len = arr.length\n  \
    \    var count = 0l\n      for (i <- 0 until len / 2) {\n        if (arr(i) !=\
    \ arr(len - 1 - i)) count += 1\n      }\n      count", "        if (arr.length\
    \ <= 1) return 0l\n        val (a, b) = arr.splitAt(arr.length / 2)\n        if\
    \ (arr.length % 2 == 0) {\n            val (d1, d2) = a.zip(b.reverse).unzip\n\
    \            d1.map(abs(_)).sum + d2.map(abs(_)).sum\n        } else {\n     \
    \       val (d1, d2) = a.zip(b.tail.reverse).unzip\n            d1.map(abs(_)).sum\
    \ + d2.map(abs(_)).sum\n        }", "        val n = arr.length\n        // change(i,\
    \ j) : minimum number of changes to make arr(i) ... arr(j) palindromic\n     \
    \   val change = Array.ofDim[Long](n, n)\n        // palindrome length (i, j)\n\
    \        // val pal = Array.ofDim[Long](n, n)\n        for (d <- 1 until n) {\n\
    \            for (i <- 0 until n - d) {\n                val j = i + d\n     \
    \           val numChanges = change(i + 1)(j - 1) + (if (arr(i) == arr(j)) 0 else\
    \ 2)\n                val numChanges2 = change(i)(j - 1) + 1\n               \
    \ val numChanges3 = change(i + 1)(j) + 1\n                change(i)(j) = min(numChanges,\
    \ min(numChanges2, numChanges3))\n            }\n        }\n        change(0)(n\
    \ - 1)", "        arr match {\n            case List() => 0l\n            case\
    \ head :: tail => {\n                val list = tail.reverse\n               \
    \ val (num1, num2) = findMin(head, list)\n                num1 + num2\n      \
    \      }\n        }", "        val n = arr.length\n        val array1 = arr.slice(0,\
    \ n / 2)\n        val array2 = if (n % 2 == 0) arr.slice(n / 2, n) else arr.slice(n\
    \ / 2 + 1, n)\n        array1.zip(array2.reverse).map(x => abs(x._1 - x._2)).sum",
  "        var a = arr.toArray\n        var change = 0l\n        for (i <- 0 until\
    \ (a.length / 2)) {\n            if (a(i) != a(a.length - 1 - i)) change += 1\n\
    \        }\n        change", "        if (arr.length <= 1) 0l\n        else {\n\
    \            var minChanges = Long.MaxValue\n            val palindromic = (l\
    \ : List[Long]) => l.zip(l.reverse).foldLeft(true)((acc, x) => acc && x._1 ==\
    \ x._2)\n            val palindromicBit = (l : Array[Boolean]) => l.zip(l.reverse).foldLeft(true)((acc,\
    \ x) => acc && x._1 == x._2)\n            val change = (l : List[Long]) => l.map(x\
    \ => x % 2 == 0)\n            val changeBit = (l : Array[Boolean]) => l.map(x\
    \ => x ^ (x && x))\n            for (sublistStart <- 0 to arr.length - 1) {\n\
    \                for (sublistEnd <- sublistStart + 1 to arr.length) {\n      \
    \              val sublist = arr.slice(sublistStart, sublistEnd)\n           \
    \         if (palindromic(sublist)) {\n                        val changes = change(sublist)\n\
    \                        if (changes.count(x => x) < minChanges) minChanges =\
    \ changes.count(x => x)\n                    }\n                }\n          \
    \  }\n            minChanges\n        }", "        var l = arr.length\n      \
    \  var sum = 0l\n        for (i <- 0 until l / 2) {\n            sum += abs(arr(i)\
    \ - arr(l - i - 1))\n        }\n        sum", "        def loop(l : Long, a :\
    \ List[Long]) : Long = {\n            if (a.size < 2) {\n                l\n \
    \           } else {\n                if (a.head != a.last) {\n              \
    \      loop(l + 1, a.tail.init)\n                } else {\n                  \
    \  loop(l, a.tail.init)\n                }\n            }\n        }\n       \
    \ loop(0, arr)", "        // Define N and prepare DP.\n        val N = arr.length\n\
    \        val dp = Array.ofDim[Long](N, N)\n        // Outer loop through the number\
    \ of elements to consider.\n        for (len <- 1 to N) {\n            // Inner\
    \ loop through starting positions.\n            for (start <- 0 to N - len) {\n\
    \                val end = start + len - 1\n                // If single element,\
    \ then value is 0.\n                if (len == 1) dp(start)(end) = 0\n       \
    \         // If two elements, then value is one if the elements are not equal.\n\
    \                else if (len == 2) dp(start)(end) = if (arr(start) == arr(end))\
    \ 0 else 1\n                // If more than two elements, then we can either change\
    \ the first\n                // element to match the last element and remove both\
    \ elements from\n                // the list, or do the same for the second and\
    \ second to last elements.\n                else dp(start)(end) = min(dp(start\
    \ + 1)(end) + (if (arr(start) == arr(end)) 0 else 1), dp(start)(end - 1) + (if\
    \ (arr(start) == arr(end)) 0 else 1))\n            }\n        }\n        // Return\
    \ the cost of a palindrome using all elements.\n        dp(0)(N - 1)", "     \
    \   def loop(arr : List[Long], count : Long) : Long = {\n            if (arr.length\
    \ <= 1) return count\n            if (arr.head == arr.last) loop(arr.drop(1).dropRight(1),\
    \ count)\n            else loop(arr.drop(1).dropRight(1), count + 1)\n       \
    \ }\n        loop(arr, 0)", "        // Given a list of integers A, perform B\
    \ operations. In each operation, choose one of the elements of A and increment\
    \ it by 1. Determine the minimum and maximum values that the list may have after\
    \ performing B operations.\n        // For example:\n        // >>> x = (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))\n        // (1l,2l,3l)\n        // >>> getMinMax(x, 3l)\n\
    \        // (4l, 7l)\n        // >>> getMinMax(x, 2l)\n        // (3l, 6l)\n \
    \       // >>> getMinMax(x, 1l)\n        // (2l, 5l)\n        // >>> getMinMax(x,\
    \ 0l)\n        // (1l, 4l)\n        def getMinMax(arr : List[Long], numOps : Long)\
    \ : (Long, Long) = {\n            val min = (List[Long](arr.max, arr.min)).min\n\
    \            (min, min + arr.length + numOps)\n        }\n        // Given a list\
    \ of integers, determine if the list can be made palindromic.\n        // For\
    \ example:\n        // >>> isPalindromic((List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 4l.toLong, 3l.toLong, 1l.toLong, 1l.toLong)))\n        // (true)\n\
    \        // >>> isPalindromic((List[Long](1l.toLong, 1l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 1l.toLong, 1l.toLong)))\n        // (true)\n        // >>> isPalindromic((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 1l.toLong, 1l.toLong)))\n      \
    \  // (false)\n        def isPalindromic(arr : List[Long]) : Boolean = {\n   \
    \         val halfIdx = (arr.length + 1) / 2\n            arr.take(halfId", " \
    \       val center = arr.length / 2\n        // For even elements\n        if\
    \ (arr.length % 2 == 0) {\n            var count = 0l\n            for (i <- 0\
    \ until center) {\n                if (arr(i) != arr(arr.length - 1 - i)) count\
    \ += 1\n            }\n            count\n        }\n        // For odd elements\n\
    \        else {\n            var count = 0l\n            for (i <- 0 until center)\
    \ {\n                if (arr(i) != arr(arr.length - 1 - i)) count += 1\n     \
    \       }\n            count\n        }"]
stop_tokens:
- "\n    }\n"
