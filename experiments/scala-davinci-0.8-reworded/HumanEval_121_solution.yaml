name: HumanEval_121_solution
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a non-empty list of integers, return the sum of all of the odd elements\
  \ that are in even positions.\n    // Examples\n    // >>> solution((List[Long](5l.toLong,\
  \ 8l.toLong, 7l.toLong, 1l.toLong)))\n    // (12l)\n    // >>> solution((List[Long](3l.toLong,\
  \ 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong)))\n    // (9l)\n    // >>> solution((List[Long](30l.toLong,\
  \ 13l.toLong, 24l.toLong, 321l.toLong)))\n    // (0l)\n    def solution(lst : List[Long])\
  \ : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(solution((List[Long](5l.toLong,\
  \ 8l.toLong, 7l.toLong, 1l.toLong))) == (12l));\n    assert(solution((List[Long](3l.toLong,\
  \ 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong))) == (9l));\n    assert(solution((List[Long](30l.toLong,\
  \ 13l.toLong, 24l.toLong, 321l.toLong))) == (0l));\n    assert(solution((List[Long](5l.toLong,\
  \ 9l.toLong))) == (5l));\n    assert(solution((List[Long](2l.toLong, 4l.toLong,\
  \ 8l.toLong))) == (0l));\n    assert(solution((List[Long](30l.toLong, 13l.toLong,\
  \ 23l.toLong, 32l.toLong))) == (23l));\n    assert(solution((List[Long](3l.toLong,\
  \ 13l.toLong, 2l.toLong, 9l.toLong))) == (3l));\n    }\n\n}\n"
completions: ["        var idx = 0\n        var sum = 0l\n        for (elem <- lst)\
    \ {\n            if (idx % 2 == 0 && elem % 2 == 1) {\n                sum +=\
    \ elem\n            }\n            idx += 1\n        }\n        return sum", " \
    \       var total : Long = 0\n        for(i <- 0 until lst.length) {\n       \
    \     if(i % 2 == 0 && lst(i) % 2 == 1) total += lst(i)\n        }\n        return\
    \ total", "        // Since lst is non-empty, all elements in it are odd.\n  \
    \      // We also know that all elements are in even positions because we're given\
    \ a list of integers.\n        // So, we can just sum all elements in lst, which\
    \ will be the answer.\n        // Note: List.sum() method is not used here because\
    \ it converts the type of elements to Int.\n        var sum : Long = 0\n     \
    \   for (num <- lst) {\n            sum += num\n        }\n        return sum",
  "        var sum : Long = 0\n        for (i <- 0 until lst.length) {\n         \
    \   if (i % 2 == 0 && lst(i) % 2 == 1) sum += lst(i)\n        }\n        return\
    \ sum", "        // your solution here\n        0", '        lst.zipWithIndex.filter(x
    => x._2 % 2 == 0 && x._1 % 2 == 1).map(x => x._1).sum', "        // Code here\n\
    \        // lst.zipWithIndex.collect{case (x, y) if (y % 2 == 0 && x % 2 == 1)\
    \ => x}.sum\n        // lst.zipWithIndex.filter(x => x._2 % 2 == 0 && x._1 % 2\
    \ == 1).map(_._1).sum\n        // lst.zipWithIndex.filter(x => x._2 % 2 == 0 &&\
    \ x._1 % 2 == 1).map(x => x._1).sum\n        // lst.zipWithIndex.filter(x => x._2\
    \ % 2 == 0 && x._1 % 2 == 1).map(x => x._1).sum\n        lst.zipWithIndex.filter(x\
    \ => x._2 % 2 == 0 && x._1 % 2 == 1).map(_._1).sum", "        if (lst.isEmpty)\n\
    \            0\n        else if (lst.length == 1)\n            lst.head % 2 match\
    \ {\n                case 0 => 0\n                case 1 => lst.head\n       \
    \     }\n        else {\n            var sum = 0\n            for (i <- Range(0,\
    \ lst.length, 2)) {\n                sum += lst(i) % 2 match {\n             \
    \       case 0 => 0\n                    case 1 => lst(i)\n                }\n\
    \            }\n            sum\n        }", "        var sum = 0l\n        for(i\
    \ <- lst.indices if i % 2 == 0) {\n            if(lst(i) % 2 == 1) sum += lst(i)\n\
    \        }\n        sum", '        lst.zipWithIndex.filter(a => a._2 % 2 == 0
    && a._1 % 2 == 1).foldLeft(0l)((a, b) => a + b._1)', "        val newList = lst.filter(_\
    \ % 2 == 1).zipWithIndex.filter(_._2 % 2 == 0).map(_._1)\n        if (newList.isEmpty)\
    \ 0 else newList.sum", "        // Write your solution here\n        return 0",
  "        // I think that this is not the best solution...\n        // I need to\
    \ do more research for this challenge.\n        lst.filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).sum", "        // The length of the list\n        val len : Long =\
    \ lst.length\n        // The element in the odd position\n        var elem : Long\
    \ = 1\n        // The sum of all of the odd elements that are in even positions\n\
    \        var sum : Long = 0\n        // Iterate through the list\n        while\
    \ (elem < len) {\n            if (lst(elem.toInt) % 2 == 1) sum += lst(elem.toInt)\n\
    \            elem += 2\n        }\n        // Return the sum\n        return sum",
  '        lst.zipWithIndex.map(e => if(e._2 % 2 == 0 && e._1 % 2 == 1) e._1 else
    0).sum', "        var sum : Long = 0\n        for(i <- 0 until lst.length by 2)\
    \ {\n            if(lst(i) % 2 == 1) {\n                sum += lst(i)\n      \
    \      }\n        }\n        return sum", "        var sum = 0L\n        for (i\
    \ <- 1 until lst.length by 2) {\n            if (lst(i) % 2 == 1) {\n        \
    \        sum += lst(i)\n            }\n        }\n        return sum", "     \
    \   var sum : Long = 0\n        for ( i <- lst.indices) {\n            if (i %\
    \ 2 == 0 && lst(i) % 2 != 0) sum += lst(i)\n        }\n        sum", '        lst.zipWithIndex.filter(i
    => i._2 % 2 == 0 && i._1 % 2 == 1).map(i => i._1).sum', "        // Your solution\
    \ goes here\n        (0l)", "        var i = 0\n        var sum = 0l\n       \
    \ for (x <- lst) {\n            if (i % 2 == 0 && x % 2 == 1) {\n            \
    \    sum += x\n            }\n            i += 1\n        }\n        return sum",
  "        // Write your solution here\n        var sum = 0l\n        var count =\
    \ 0\n        for (i <- lst) {\n            if (count % 2 == 0 && i % 2 != 0) {\n\
    \                sum += i\n            }\n            count += 1\n        }\n\
    \        sum", "        // This feels a little like cheating, but I'll let it\
    \ slide for now.\n        // I'm sure you'll find a solution that does not use\
    \ the built-in \"sum\" function.\n        // Also, this will not work for large\
    \ lists, as the built-in \"sum\" function\n        // uses a Long to store the\
    \ intermediate results.\n        lst.zipWithIndex.filter(x => x._2 % 2 == 0 &&\
    \ x._1 % 2 == 1).map(x => x._1).sum", "        // Write your solution here.\n\
    \        var sum = 0l.toLong\n        for (i <- 0 until lst.length by 2) {\n \
    \           if (lst(i) % 2 == 1) {\n                sum += lst(i)\n          \
    \  }\n        }\n        return sum", "        // Your code here!\n        var\
    \ index = 0;\n        var sum = 0L;\n        for (i <- lst){\n            if (index\
    \ % 2 == 0 && i % 2 != 0){\n                sum += i;\n            }\n       \
    \     index += 1;\n        }\n        return sum;", "        // Your solution\n\
    \        var even = true\n        var sum = 0l\n        lst.foreach(x => {\n \
    \           if (even && x % 2 == 1) sum += x\n            even = !even\n     \
    \   })\n        sum", "        // Generate `lst`\n        // var lst : List[Long]\
    \ = List.empty\n        // for (i <- 0 to 1000000) {\n        //     lst = lst\
    \ :+ (scala.util.Random.nextLong % 1000l)\n        // }\n        // lst = lst.map(e\
    \ => e + 1l)\n        // println(lst)\n        // println(\"-------------------\"\
    )\n        // println(\"List.size = \" + lst.size)\n        // println(\"-------------------\"\
    )\n        // println(\"Running example test...\")\n        // println(\"-------------------\"\
    )\n        // println(\"lst.head = \" + lst.head)\n        // println(\"lst.tail\
    \ = \" + lst.tail)\n        // println(\"lst.last = \" + lst.last)\n        //\
    \ println(\"lst.init = \" + lst.init)\n        // println(\"-------------------\"\
    )\n        // println(\"lst.reverse = \" + lst.reverse)\n        // println(\"\
    -------------------\")\n        // println(\"lst.map(_ * 2) = \" + lst.map(_ *\
    \ 2))\n        // println(\"-------------------\")\n        // println(\"lst.map(_\
    \ * 2) = \" + lst.map(_ + \"g\"))\n        // println(\"-------------------\"\
    )\n        // println(\"lst.filter(_ > 5) = \" + lst.filter(_ > 5))\n        //\
    \ println(\"-------------------\")\n        // println(\"lst.reduce(_ + _) = \"\
    \ + lst.reduce(_ + _))\n        // println(\"-------------------\")\n        //\
    \ println(\"lst.partition(_ > 5) = \" + lst.partition(_ > 5))\n        // println(\"\
    -------------------\")\n        // println(\"lst.take(10) = \" + lst.take(10))\n\
    \        // println(\"-------------------\")\n        // println(\"lst.drop(10)\
    \ = \" + lst.drop(10))\n        // println(\"-------------------\")\n        //\
    \ println(\"lst.takeRight(10) = \" + lst.takeRight(10))\n        // println(\"\
    -------------------\")\n        // println(\"lst.dropRight(10", "        def solutionRec(lst\
    \ : List[Long], sum : Long, index : Int) : Long = {\n            if (lst.isEmpty)\
    \ sum\n            else if (index % 2 == 0 && lst.head % 2 == 1) solutionRec(lst.tail,\
    \ sum + lst.head, index + 1)\n            else solutionRec(lst.tail, sum, index\
    \ + 1)\n        }\n        solutionRec(lst, 0, 0)", "        // Your code here\n\
    \        lst.zipWithIndex.filter(el => el._2 % 2 == 0 && el._1 % 2 == 1).map(_._1).sum",
  "        var sum = 0l.toLong\n        for (i <- lst.indices) {\n            if (i\
    \ % 2 == 0 && lst(i) % 2 == 1) sum += lst(i)\n        }\n        sum", "\t   \
    \ // Type 'Long' can be used instead of 'Int' to solve the problem\n\t    var\
    \ sum : Long = 0\n\t    var i : Int = 0\n\t    var lst2 : List[Long] = lst\n\t\
    \    while (i < lst.length) {\n\t        if (i % 2 == 0 && lst(i) % 2 == 1) {\n\
    \t            sum += lst(i)\n\t        }\n\t        i += 1\n\t    }\n\t    return\
    \ sum", "        // Your Code Here\n        var sum = 0\n        for (i <- 1 until\
    \ lst.length by 2) {\n            if (lst(i) % 2 == 1) {\n                sum\
    \ += lst(i)\n            }\n        }\n        sum", '        lst.zipWithIndex.filter(x
    => x._2 % 2 == 0 && x._1 % 2 == 1).map(x => x._1).sum', "        // Write your\
    \ solution here\n        0l", "        // Type your solution here\n        var\
    \ sum : Long = 0\n        for (i <- 0 until lst.length if i % 2 == 0 && lst(i)\
    \ % 2 == 1) sum += lst(i)\n        sum", "        // This is your code\n     \
    \   lst.indices.filter(_ % 2 == 0).map(lst(_)).filter(_ % 2 == 1).sum", "    \
    \    val odds = lst.zipWithIndex.collect { case (x, i) if x % 2 == 1 && i % 2\
    \ == 0 => x }\n        odds.sum", "        var total : Long = 0\n        for (i\
    \ <- 0 until lst.length) {\n            if (i % 2 == 0 && lst(i) % 2 == 1) {\n\
    \                total += lst(i)\n            }\n        }\n        return total",
  "        var res : Long = 0\n        lst.zipWithIndex.foreach(x => if (x._2 % 2\
    \ == 0 && x._1 % 2 == 1) res += x._1)\n        res", "        var sum = 0l\n \
    \       var i = 0\n        while (i < lst.length) {\n            if (i % 2 ==\
    \ 0 && lst(i) % 2 == 1) sum += lst(i)\n            i += 1\n        }\n       \
    \ sum", '        return -1', "        def isEven(x : Long) : Boolean = x % 2 ==\
    \ 0\n        def isOdd(x : Long) : Boolean = x % 2 != 0\n        // Write your\
    \ code here\n        // To print results to the standard output you can use Console.println\n\
    \        // Example:\n        // Console.println(\"Hello world\")\n        var\
    \ sum = 0l.toLong\n        for (i <- lst.indices) {\n            if (isEven(i)\
    \ && isOdd(lst(i))) {\n                sum += lst(i)\n            }\n        }\n\
    \        sum", "        var sum = 0l\n        for (i <- 0 until lst.length) {\n\
    \            val num = lst(i)\n            if (i % 2 == 0 && num % 2 == 1) {\n\
    \                sum += num\n            }\n        }\n        sum", "       \
    \ // Your code here\n        lst.zipWithIndex.map(x => if (x._2 % 2 == 0 && x._1\
    \ % 2 == 1) x._1 else 0l).sum", "        var ret : Long = 0\n        for (i <-\
    \ 0 until lst.length) {\n            if (i % 2 == 0 && lst(i) % 2 == 1) {\n  \
    \              ret += lst(i)\n            }\n        }\n        return ret", " \
    \       // Solution goes here\n        var res = 0L\n        for (i <- 0 until\
    \ lst.length) {\n            if (i % 2 == 0 && lst(i) % 2 == 1) res += lst(i)\n\
    \        }\n        res", "        // Given a non-empty list of integers, return\
    \ the sum of all of the odd elements that are in even positions.\n        // Examples\n\
    \        // >>> solution((List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong)))\n\
    \        // (12l)\n        // >>> solution((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 3l.toLong, 3l.toLong)))\n        // (9l)\n        // >>> solution((List[Long](30l.toLong,\
    \ 13l.toLong, 24l.toLong, 321l.toLong)))\n        // (0l)\n        val result\
    \ = lst.zipWithIndex.map(x => if (x._2 % 2 == 0 && x._1 % 2 == 1) x._1 else 0).sum\n\
    \        result", "        // ***** Please implement this method. *****\n    \
    \    return 0l", "        // Implement this function\n        // Replace the following\
    \ lines with your implementation\n        var sum = 0L\n        for (i <- 0 until\
    \ lst.length by 2) {\n            if (lst(i) % 2 == 1) {\n                sum\
    \ += lst(i)\n            }\n        }\n        sum", "        // Your code here.\n\
    \        var n = 0\n        lst.foreach(x => if (x % 2 == 1) n += x)\n       \
    \ n", "        var sum : Long = 0l.toLong\n        for (i <- 0 until lst.length)\
    \ {\n            if (i % 2 == 0 && lst(i) % 2 == 1) sum += lst(i)\n        }\n\
    \        return sum", '      lst.zipWithIndex.filter(i => i._2 % 2 == 0 && i._1
    % 2 == 1).map(_._1).sum', "        var odd = 0l\n        var m = 1\n        for\
    \ (e <- lst) {\n            if (m % 2 == 0 && e % 2 == 1) odd += e\n         \
    \   m += 1\n        }\n        odd", '        return lst.zipWithIndex.filter(p
    => p._2 % 2 == 0 && p._1 % 2 == 1).map(p => p._1).sum', "        // Write your\
    \ code here\n        // To print results to the standard output you can use print\n\
    \        // Example: print(\"Hello world!\")\n        var odd = 0\n        for(i\
    \ <- 0 until lst.length by 2) {\n            if(lst(i) % 2 == 1) odd += lst(i)\n\
    \        }\n        odd", "        // Input:\n        //   lst - a list of integers\n\
    \        // Output:\n        //   A list of integers, which are the odd elements\
    \ in the even positions\n        lst.zipWithIndex.filter(p => p._2 % 2 == 0 &&\
    \ p._1 % 2 == 1).map(p => p._1).sum", "        // *** PLEASE ADD YOUR CODE HERE\
    \ ***\n        0l", "        // Feel free to add more parameters to the function\
    \ signature.\n        // Implement your solution below.\n        def isOdd(number\
    \ : Long) : Boolean = {\n            if(number % 2 == 0) false\n            else\
    \ true\n        }\n        val list = lst.zipWithIndex.filter(t => isOdd(t._2)).map(t\
    \ => t._1)\n        list.filter(t => isOdd(t)).sum", '        return 0l', '        return
    lst.zipWithIndex.filter((i : (Long, Int)) => i._2 % 2 == 0 && i._1 % 2 == 1).foldLeft(0l)((b
    : Long, a : (Long, Int)) => b + a._1)', "        val filtered = lst.filter((n,\
    \ i) => n % 2 == 1 && i % 2 == 0)\n        filtered.sum", "        //if odd number,\
    \ then add it to sum.\n        //problem here is that it might not be even number,\
    \ we need to find out if the index is even or odd.\n        //generate a counter,\
    \ if count is even and number is odd, then add it to the sum\n        //then increment\
    \ the counter\n        var sum = 0l\n        var count = 0\n        var oddflag\
    \ = 0\n        var evenflag = 0\n        for (i <- lst) {\n            if (i %\
    \ 2 == 0) {\n                evenflag = 1\n            }\n            else {\n\
    \                oddflag = 1\n            }\n        }\n        if (evenflag ==\
    \ 0 || oddflag == 0) {\n            return 0\n        }\n        else {\n    \
    \        for (i <- lst) {\n                if (count % 2 == 0 && i % 2 != 0) {\n\
    \                    sum += i\n                }\n                count += 1\n\
    \            }\n        }\n        return sum", "        // Write your solution\
    \ here\n        return 0", "        // Type your solution here\n        0", " \
    \       // Type your solution here\n        lst.zipWithIndex.filter(x => (x._2\
    \ & 1) == 0 && (x._1 & 1) == 1).map(x => x._1).sum", "      lst.zipWithIndex.foldLeft(0l.toLong){(z,x)\
    \ =>\n        if (x._2 % 2 == 0 && x._1 % 2 != 0) {\n          z + x._1\n    \
    \    } else {\n          z\n        }\n      }", "        if (lst.length % 2 ==\
    \ 0) {\n            lst.reduceLeft(_ + _)\n        } else {\n            lst.reduceLeft(_\
    \ + _) - lst.last\n        }", "        if (lst.isEmpty) 0\n        else if (lst.length\
    \ == 1) 0\n        else if (lst.length == 2) {\n            if (lst(0) % 2 ==\
    \ 0) lst(1)\n            else 0\n        }\n        else if (lst.length == 3)\
    \ {\n            if (lst(0) % 2 == 0) lst(1)\n            else if (lst(1) % 2\
    \ == 0) lst(2)\n            else 0\n        }\n        else {\n            if\
    \ (lst(0) % 2 == 0) lst(1) + solution(lst.drop(2))\n            else solution(lst.drop(1))\n\
    \        }", "      val list = lst.grouped(2).map(x => x(0)).zipWithIndex.filter(_._2\
    \ % 2 == 0).map(_._1).sum\n      list", '        lst.zipWithIndex.filter(_._2
    % 2 == 0).filter(_._1 % 2 == 1).map(_._1).sum', "        // Adding list element\
    \ to be list-indexed.\n        val t = lst.zipWithIndex.toArray\n        // Result\
    \ variable.\n        var res : Long = 0\n        // Iterating over the list.\n\
    \        t.foreach(x => {\n            // If element is odd and its index is even...\n\
    \            if (x._1 % 2 != 0 && x._2 % 2 == 0) {\n                // Add to\
    \ result.\n                res += x._1\n            }\n        })\n        //\
    \ Return result.\n        res", "        // Type your solution here\n        0",
  "        // Type your solution here\n        val a = lst.toArray.zipWithIndex.filter(n\
    \ => n._2 % 2 == 0 && n._1 % 2 == 1).map(n => n._1)\n        a.sum", "       \
    \ val r = for (i <- 0 until lst.length if i % 2 == 0 && lst(i) % 2 == 1) yield\
    \ lst(i)\n        r.sum", "        var sum = 0l\n        for (x <- lst.indices\
    \ if x % 2 == 0 && lst(x) % 2 == 1) sum += lst(x)\n        sum", "        var\
    \ sum : Long = 0\n        var i : Int = 0\n        while (i < lst.length) {\n\
    \            sum += lst(i)\n            i += 2\n        }\n        return sum",
  "        // Write your solution here\n        0l", "        // *** Please provide\
    \ your code here ***\n        def isEven(x: Long): Boolean = x % 2 == 0\n    \
    \    def isOdd(x: Long): Boolean = x % 2 != 0\n        val odds = lst.filter(isOdd)\n\
    \        val evens = lst.filter(isEven)\n        evens.zip(odds).map(x => x._2).sum",
  "        // Your solution goes here\n        lst.zipWithIndex.map(t => if (t._2\
    \ % 2 == 0 && t._1 % 2 == 1) t._1 else 0).reduceLeft(_ + _)", '        lst.zipWithIndex.filter((p)
    => (p._2 % 2) == 0 && (p._1 % 2) == 1).map((p) => p._1).sum', '        lst.zipWithIndex.filter(x
    => x._2 % 2 == 0 && x._1 % 2 == 1).map(x => x._1).sum', "        // Implement\
    \ your solution here\n        val ans = lst.filter(_ % 2 == 1).map(_.toLong).zipWithIndex.filter(_._2\
    \ % 2 == 0).map(_._1).sum\n        ans", "        val result = lst.zipWithIndex.filter(t\
    \ => t._2 % 2 == 0 && t._1 % 2 == 1).map(t => t._1).sum\n        return result",
  "        // use all three values for the for-loop\n        val l : Long = lst.length\n\
    \        // Result\n        var res : Long = 0l\n        // Do we want to use\
    \ i as a loop-counter?\n        var i : Long = 0l\n        // Is this the best\
    \ way to loop?\n        for (i <- 0l to l - 1l) {\n            // Is this the\
    \ best way to access each element?\n            if (i % 2l == 0l) {\n        \
    \        val n : Long = lst(i.toInt)\n                if (n % 2l == 1l) {\n  \
    \                  res = res + n\n                }\n            }\n        }\n\
    \        return res", "        val sum = (\n            for {\n              \
    \  (x, i) <- lst.zipWithIndex\n                if x % 2 != 0 && i % 2 == 0\n \
    \           } yield x\n        ).sum\n        return sum", "        // import\
    \ your list\n        // declare your answer\n        // write your logic\n   \
    \     // return your answer\n        return 0l", "        // Fill up this function\
    \ body\n        // 'lst' contains the list of integers\n        // For example,\
    \ the list `lst` can be `List(1, 2, 3, 4, 5)`\n        // The output should be\
    \ the sum of all of the odd elements that are in even positions.\n        // For\
    \ example, for `List(1, 2, 3, 4, 5)`, the output should be `6`\n        // because\
    \ `2` and `4` are the odd elements in even positions.\n        // For example,\
    \ for `List(1, 4, 6, 8, 10)`, the output should be `4`\n        // because `4`\
    \ is the only odd element in even positions.\n        // For example, for `List(1,\
    \ 3, 5, 7, 9)`, the output should be `0`\n        // because there are no odd\
    \ elements in even positions.\n        // var sum : Long = 0l\n        // for\
    \ (x <- lst) {\n        //     if (x % 2 != 0 && lst.indexOf(x) % 2 == 0) {\n\
    \        //         sum += x\n        //     }\n        // }\n        // sum\n\
    \        (lst zip lst.zipWithIndex)\n            .filter{case (x, (y, i)) => x\
    \ % 2 != 0 && i % 2 == 0}\n            .map{case (x, (y, i)) => x}\n         \
    \   .sum", "        val lst2 = lst.zipWithIndex.filter(x => x._2 % 2 == 0).map(x\
    \ => x._1)\n        lst2.filter(x => x % 2 == 1).sum", "        val indices =\
    \ lst.indices.filter(_ % 2 == 0)\n        indices.map(x => lst(x)).filter(_ %\
    \ 2 == 1).sum", "        // Your Code Here\n        // Do not change the function\
    \ signature\n        var ans = 0\n        for (i <- 1 until lst.length by 2) {\n\
    \            if (lst(i) % 2 == 1) ans += lst(i)\n        }\n        ans", "  \
    \      // Let's first get the odd numbers in even positions,\n        // then\
    \ we will get the sum of them.\n        lst.zipWithIndex.foldLeft(0l)((acc, pair)\
    \ => {\n            if (pair._2 % 2 == 0 && pair._1 % 2 == 1) acc + pair._1\n\
    \            else acc\n        })", "        val evenPositions = lst.zipWithIndex.filter(t\
    \ => t._2 % 2 == 0).map(_._1)\n        val oddElements = evenPositions.filter(_\
    \ % 2 == 1)\n        oddElements.sum", "        // Filter all even positions and\
    \ then filter all odds\n        lst.zipWithIndex.filter(_._2 % 2 == 0).filter(_._1\
    \ % 2 == 1).map(_._1).sum", "        // DO NOT MODIFY\n        val evens = lst.zipWithIndex.filter(_._2\
    \ % 2 == 0)\n        val odds = evens.filter(_._1 % 2 == 1)\n        odds.foldLeft(0l.toLong)((a,b)\
    \ => a + b._1)", "        // Write your solution here\n        return lst.zipWithIndex.map(el\
    \ => if(el._2 % 2 == 0 && el._1 % 2 == 1) el._1 else 0l).sum", "        // Define\
    \ your solution here\n        0l", '        lst.zipWithIndex.filter(x => (x._2
    % 2 == 0 && x._1 % 2 == 1)).map(x => x._1).sum', "        // Compute and return\
    \ the answer\n        var oddsum = 0l\n        for (i <- 0 until lst.length) {\n\
    \            if (i % 2 == 0 && lst(i) % 2 == 1) {\n                oddsum += lst(i)\n\
    \            }\n        }\n        oddsum", "        // Type your solution here\n\
    \        lst.zipWithIndex.filter(t => t._2 % 2 == 0 && t._1 % 2 == 1).map(_._1).sum",
  "        var sum = 0l\n        for (i <- 0 until lst.length) {\n            if (i\
    \ % 2 == 0 && lst(i) % 2 == 1) sum += lst(i)\n        }\n        return sum",
  '        return lst.zipWithIndex.filter(x => x._2 % 2 == 0 && x._1 % 2 == 1).map(x
    => x._1).sum', "        // Naive solution\n        // var ans = 0\n        //\
    \ for (i <- Range(0, lst.length) if i % 2 == 0) {\n        //     ans += lst(i)\
    \ * (i % 2) * (lst(i) % 2)\n        // }\n        // return ans\n        // Generative\
    \ solution\n        return lst.zipWithIndex.filter { case (e, i) => i % 2 == 0\
    \ }.map { case (e, i) => e * (e % 2) }.sum", "      // Given a list\n      //\
    \ \n      // In the list there is a sequence of odd elements.\n      // The odd\
    \ elements are in even positions.\n      // \n      // The function must return\
    \ the sum of the odd elements in the list.\n      lst.zipWithIndex.filter(e =>\
    \ e._2 % 2 == 0 && e._1 % 2 == 1).map(_._1).sum", "        var sum : Long = 0\n\
    \        for (i <- 0 until lst.length) {\n            if (i % 2 == 0 && lst(i)\
    \ % 2 == 1) sum += lst(i)\n        }\n        return sum", "        def solution0(lst\
    \ : List[Long], a : Long, b : Long) : Long = lst match {\n            case Nil\
    \ => a\n            case x :: xs => solution0(xs, a + b * x, 1 - b)\n        }\n\
    \        solution0(lst, 0, 0)", "        // Your code here.\n        return 0",
  "        lst.zipWithIndex.foldLeft(0l)((acc, x) => {\n            val (num, idx)\
    \ = x\n            if (idx % 2 == 0 && num % 2 == 1) {\n                acc +\
    \ num\n            } else {\n                acc\n            }\n        })",
  "\t\tvar sum = 0l.toLong\n\t\tfor (i <- lst.indices) {\n\t\t\tif (i % 2 == 0 &&\
    \ lst(i) % 2 == 1) {\n\t\t\t\tsum += lst(i)\n\t\t\t}\n\t\t}\n\t\tsum", "     \
    \   if (lst.isEmpty) return 0\n        lst.zipWithIndex.filter(x => (x._2 % 2\
    \ == 0) && (x._1 % 2 == 1)).map(x => x._1).sum", "        // Write your solution\
    \ here\n        lst.zipWithIndex.filter(e => e._2 % 2 == 0 && e._1 % 2 == 1).map(_._1).sum",
  "        // lst.zipWithIndex.filter(e => e._2 % 2 == 0 && e._1 % 2 == 1).map(e =>\
    \ e._1).sum\n        lst.filter(_ % 2 == 1).zipWithIndex.filter(_._2 % 2 == 0).map(_._1).sum",
  "        var sum : Long = 0\n        for (i <- 0 until lst.length if i % 2 == 0\
    \ && lst(i) % 2 == 1) {\n            sum += lst(i)\n        }\n        return\
    \ sum", "        // Your Code\n        var res: Long = 0\n        for (i <- 0\
    \ until lst.length by 2) {\n            if (lst(i) % 2 != 0) res += lst(i)\n \
    \       }\n        res", '        return lst.zipWithIndex.foldLeft(0l)((a, x)
    => if (x._2 % 2 == 0 && x._1 % 2 == 1) a + x._1 else a)', "        // result\n\
    \        val result : Long = lst.zipWithIndex.filter(pair => pair._2 % 2 == 0\
    \ && pair._1 % 2 == 1).map(pair => pair._1).sum\n        // return result\n  \
    \      return result", "        var total = 0l\n        var isOdd = false\n  \
    \      for (element <- lst) {\n            if (isOdd) total += element\n     \
    \       isOdd = !isOdd\n        }\n        return total", '        lst.zipWithIndex.filter{case(value,
    index) => index % 2 == 0 && value % 2 == 1}.foldLeft(0l.toLong)((sum, tup) =>
    sum + tup._1)', "        // *********************************************\n  \
    \      // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \        // *********************************************\n        // *********************************************\n\
    \       ", "        // Write your solution here\n        lst.zipWithIndex.filter\
    \ {\n            case (x, y) =>\n                x % 2 == 1 && y % 2 == 0\n  \
    \      }.map(_._1).sum", "        var sum : Long = 0\n        for (i <- lst.indices)\
    \ {\n            if (i % 2 == 0 && lst(i) % 2 == 1) {\n                sum +=\
    \ lst(i)\n            }\n        }\n        return sum", "        var sum = 0l\n\
    \        for (i <- 0 until lst.length) {\n            if (i % 2 == 0 && lst(i)\
    \ % 2 == 1) sum += lst(i)\n        }\n        return sum", '        return lst.filter((x:
    Long) => x % 2 != 0).zipWithIndex.filter((x: (Long, Int)) => x._2 % 2 == 0).map((x:
    (Long, Int)) => x._1).sum', "        val n = lst.length\n        // step is the\
    \ step we will take on the list\n        // For example, if step is 1, we will\
    \ take the first, second, third and so on element\n        // If step is 2, we\
    \ will take the first, third, fifth and so on element\n        // If step is 3,\
    \ we will take the first, fourth, seventh and so on element\n        // If step\
    \ is 4, we will take the first, fifth, ninth and so on element\n        val step\
    \ = 2\n        // The sum of the elements in the list\n        var sum = 0l\n\
    \        for (i <- 0 until n by step) {\n            if (lst(i) % 2 == 1) sum\
    \ += lst(i)\n        }\n        sum", "        // Your code goes here\n      \
    \  var sum = 0l\n        for(i <- lst.indices) {\n            if(i % 2 == 0 &&\
    \ lst(i) % 2 == 1) {\n                sum += lst(i)\n            }\n        }\n\
    \        sum", "        // Iterate through each pair in the list of integers.\n\
    \        // The starting index is one because the first index would be an odd\
    \ element.\n        // If a pair is in an even position and the first integer\
    \ is odd, then add that integer to the sum.\n        var sum : Long = 0\n    \
    \    for (i <- 1 until lst.length by 2) {\n            if (lst(i) % 2 == 0) {\n\
    \                sum += lst(i - 1)\n            }\n        }\n        return sum",
  "        // Given the list, filter out the odd numbers, map them to their indices,\
    \ filter out the odd indices and return\n        // the sum of these values.\n\
    \        lst.filter(_ % 2 == 1).zipWithIndex.filter(_._2 % 2 == 0).map(_._1).sum",
  "        // This stub will be replaced during test execution.\n        // Your solution\
    \ should match the signature of this stub.\n        // See: https://www.scala-lang.org/api/current/scala/collection/immutable/List.html\n\
    \        lst.foldLeft((0l, 0l))((acc, i) => (acc._1 + acc._2, i))._1", "     \
    \   val evenPositions = (1 until lst.length).filter(_ % 2 == 0)\n        val sumOddEvenPositions\
    \ = evenPositions.map(lst(_)).sum\n        return sumOddEvenPositions", "    \
    \    // Write your solution here\n        var sum : Long = 0\n        for(i <-\
    \ 0 until lst.length) {\n            if(i % 2 == 0 && lst(i) % 2 == 1) {\n   \
    \             sum += lst(i)\n            }\n        }\n        return sum", " \
    \       lst.zipWithIndex.foldLeft(0l)((a, b) => b._2 % 2 match {\n           \
    \ case 0 => a + b._1\n            case _ => a\n        })", "        var accum\
    \ = 0l\n        for (i <- 0 until lst.length) {\n            if (i % 2 == 0 &&\
    \ lst(i) % 2 == 1) {\n                accum += lst(i)\n            }\n       \
    \ }\n        accum", '        lst.zipWithIndex.filter(p => p._2 % 2 == 0 && p._1
    % 2 == 1).map(_._1).sum', "        //\n        // Your solution here\n       \
    \ //\n        lst.zipWithIndex.filter( (n) => n._2 % 2 == 0).filter( (n) => n._1\
    \ % 2 == 1).map( (n) => n._1).sum", '        return lst.zipWithIndex.filter(x
    => x._2 % 2 == 0 && x._1 % 2 == 1).map(x => x._1).sum', "        // Given an empty\
    \ list, return zero.\n        if (lst.length == 0) {\n            return 0l\n\
    \        }\n        // Given a non-empty list, call the main recursive logic.\n\
    \        else {\n            // Sum up the odd elements in even positions.\n \
    \           val sum = odd_elements_in_even_positions(lst, 1l)\n            //\
    \ Return the total.\n            return sum\n        }", '        lst.filter((x,
    i) => i % 2 == 0 && x % 2 == 1).sum', "        // if lst is empty return 0\n \
    \       if (lst.isEmpty) 0 else {\n            // else if lst is not empty we\
    \ check if lst(0) is odd and lst.size is even\n            if (lst(0) % 2 != 0\
    \ && lst.size % 2 == 0) {\n                // then we return lst(0) and the recursively\
    \ call solution with the rest of the list\n                lst(0) + solution(lst.tail)\n\
    \            } else {\n                // else we call solution with the rest\
    \ of the list\n                solution(lst.tail)\n            }\n        }",
  "        def f(lst : List[Long], res : Long, i : Int) : Long = {\n            if\
    \ (lst.isEmpty) res\n            else {\n                if (i % 2 == 0 && lst.head\
    \ % 2 == 1) f(lst.tail, res + lst.head, i + 1)\n                else f(lst.tail,\
    \ res, i + 1)\n            }\n        }\n        f(lst, 0, 0)", "        // Given\
    \ (List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong)), we want to return:\n\
    \        // 7l.toLong + 1l.toLong = 8l.toLong\n        // >>> solution((List[Long](3l.toLong,\
    \ 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong)))\n        // (9l)\n        // >>>\
    \ solution((List[Long](30l.toLong, 13l.toLong, 24l.toLong, 321l.toLong)))\n  \
    \      // (0l)\n        lst.zipWithIndex.filter(_._2 % 2 == 1).map(_._1).filter(_\
    \ % 2 == 1).sum", "        val z : Tuple2[Long, Long] = lst.zipWithIndex.filter(t\
    \ => t._2 % 2 == 0).map(t => t._1).foldLeft((0l, 0l))((t : Tuple2[Long, Long],\
    \ i : Long) => if (i % 2 == 1) (t._1 + i, t._2 + 1) else t)\n        z._1", " \
    \       var sum : Long = 0l\n        for (i <- 0 until lst.length if i % 2 ==\
    \ 0) {\n            if (lst(i) % 2 == 1) {\n                sum += lst(i)\n  \
    \          }\n        }\n        return sum", "        var sum = 0l\n        for\
    \ (i <- 1 until lst.length by 2) {\n            val value = lst(i)\n         \
    \   if (value % 2 == 1) {\n                sum += value\n            }\n     \
    \   }\n        sum", "        var sum = 0l.toLong\n        for (i <- 0 until lst.length)\
    \ {\n            if (i % 2 == 0 && lst(i) % 2 == 1) sum += lst(i)\n        }\n\
    \        return sum", "        // Given a list of integers, return the sum of\
    \ all of the odd elements that are in even positions.\n        // Your solution\
    \ must be efficient.\n        lst.zipWithIndex.filter(p => p._2 % 2 == 0 && p._1\
    \ % 2 == 1).map(p => p._1).sum", "        // long sumOdd\n        // try{\n  \
    \      //     sumOdd = (lst.zipWithIndex.filter(x => x._2 % 2 == 0).map(x => x._1).toList.sum)\n\
    \        // } catch {\n        //     case e: Exception => 0\n        // }\n \
    \       // return sumOdd\n        lst.zipWithIndex.filter(x => x._2 % 2 == 0).map(x\
    \ => x._1).toList.sum", "        // Write your solution here\n        var sum\
    \ = 0l\n        for (i <- lst.indices if i % 2 == 0) {\n            if (lst(i)\
    \ % 2 == 1) {\n                sum += lst(i)\n            }\n        }\n     \
    \   sum", "\t// Brute force\n\tvar sum = 0l\n\tfor (i <- 0 until lst.length) {\n\
    \t    if (i % 2 == 0 && lst(i) % 2 == 1) sum += lst(i)\n\t}\n\tsum", "       \
    \ lst.zipWithIndex.foldLeft(0l)((s, l) => {\n            val (value, index) =\
    \ l\n            if (index % 2 == 0 && value % 2 == 1) s + value else s\n    \
    \    })", "        // Type your solution here\n        return lst.filter(_ % 2\
    \ == 1).zipWithIndex.filter(_._2 % 2 == 0).map(_._1).sum", "        // Your code\
    \ here\n        lst.zipWithIndex.filter(x => x._2 % 2 == 0 && x._1 % 2 == 1).map(_._1).sum",
  '        lst.zipWithIndex.filter(a => a._2 % 2 == 0 && a._1 % 2 == 1).foldLeft(0l.toLong)((sum,
    c) => sum + c._1)', "        // Type your solution here\n        null", "    \
    \    if (lst.isEmpty) 0\n        else {\n            val odd = lst.zipWithIndex.filter(p\
    \ => (p._2 % 2 == 0 && p._1 % 2 == 1)).map(_._1)\n            if (odd.isEmpty)\
    \ 0\n            else odd.sum\n        }", "        val solutionList = lst.zipWithIndex.filter(x\
    \ => x._2 % 2 == 0 && x._1 % 2 == 1).map(x => x._1)\n        if (solutionList.length\
    \ > 0) {\n            solutionList.reduce(_ + _)\n        } else {\n         \
    \   0\n        }", "        // See: https://stackoverflow.com/questions/27618776/how-to-add-two-lists-in-scala-in-parallel\n\
    \        val zipped = lst.zipWithIndex\n        zipped.filter(i => (i._2 % 2 ==\
    \ 0)).filter(i => (i._1 % 2 == 1)).map(i => i._1).sum", '        lst.zipWithIndex.filter(x
    => x._2 % 2 == 0 && x._1 % 2 == 1).map(x => x._1).sum', "        // Your Code\
    \ Here\n        var sum = 0l.toLong\n        for(i <- 1 until lst.length by 2)\
    \ {\n            if(lst(i) % 2 == 1) sum += lst(i)\n        }\n        sum", '        lst.zipWithIndex.filter(e
    => (e._2 & 1) == 0 && (e._1 & 1) == 1).map(_._1).sum', '        return -1;', " \
    \       var sum : Long = 0\n        var idx : Int = 0\n        for (elt <- lst)\
    \ {\n            if (idx % 2 == 0 && elt % 2 == 1) {\n                sum += elt\n\
    \            }\n            idx += 1\n        }\n        return sum", "      \
    \  // *** IMPLEMENT ME ***\n        0l", "        // *********************************************\n\
    \        // ADD YOUR CODE HERE\n        // *********************************************\n\
    \        def sumOddPos(lst : List[Long], curr : Long) : Long = {\n           \
    \ lst match {\n                case Nil => curr\n                case x :: xs\
    \ => sumOddPos(xs, curr + x * (if (lst.length % 2 == 0) 1 else 0))\n         \
    \   }\n        }\n        return sumOddPos(lst, 0)", '        return lst.zipWithIndex.filter
    {case (x, i) => x % 2 != 0 && i % 2 == 0}.map(_._1).sum', "        // Type your\
    \ solution here\n        val oddEvens = lst.zipWithIndex.filter{ case (num, index)\
    \ => (num % 2 != 0) && (index % 2 == 0) }\n        oddEvens.foldLeft(0L)( (acc,\
    \ pair) => acc + pair._1 )", '        lst.zipWithIndex.filter(e => e._2 % 2 ==
    0 && e._1 % 2 == 1).foldLeft(0l.toLong)((accum, curr) => accum + curr._1)', '        return
    0l.toLong', "        // import Integer._\n        // return toInt(lst.grouped(2).map(_.sum).sum)\n\
    \        val result = lst.zipWithIndex.filter(x => x._2 % 2 == 0 && x._1 % 2 ==\
    \ 1).map(_._1).sum\n        return result", "      //if (lst.length % 2 == 0)\
    \ {\n        val lst2 = lst.drop(1).zipWithIndex.filter(t => t._2 % 2 == 0).map(t\
    \ => t._1)\n        //lst2.foreach(x => println(x))\n        val ret = lst2.sum\n\
    \        ret\n      //} else {\n      //  val lst2 = lst.zipWithIndex.filter(t\
    \ => t._2 % 2 == 0).map(t => t._1)\n      //  val ret = lst2.sum\n      //  ret\n\
    \      //}", "      // We want the value of the odd elements that are in an even\
    \ position\n      // We could write an if statment, but it is easier to just use\
    \ a filter\n      // so we need to check for odd, and even position\n      //\
    \ An odd position is when the index number is odd % 1 != 0\n      // An even position\
    \ is when the index number is even % 2 == 0\n      // We then need to reduce the\
    \ list to a single number\n      // We need to sum the list\n      // So we need\
    \ a filter and a reduce\n      // We can combine these into a single chain\n \
    \     // We first need to create an index, so we can check for odd and even position\n\
    \      // We can use the zipWithIndex function to create an index\n      // We\
    \ then need to filter for an odd number in an even position\n      // We then\
    \ need to apply reduce to sum up the list\n      // We can create a functional\
    \ for each to handle the sum\n      // We need a reduce\n      // We can create\
    \ an anonymous function to handle the sum\n      // So we need to sum the odd\
    \ numbers that are in an even position\n      // Let's start with the zipWithIndex,\
    \ and create a filter to check the index value\n      // We will then create the\
    \ reduce function\n      // Our filter and reduce functions need to be lambdas\n\
    \      // We need to identify odd and even numbers and positions\n      // We\
    \ can use the modulo operator % to find out if the index and value are odd\n \
    \     // When we have the reduce, let's fill it in\n      // We now have an if\
    \ statement that checks for an odd number in an even position\n      // This will\
    \ return either 0 or the value depending on the conditional\n      // We can now\
    \ use a _ to get the value\n      // We can now delete the if statement and the\
    \ _ \n      // We can now reduce to a single line\n      // We want to handle\
    \ the empty case and return 0\n      // This is a standard case, so let's use\
    \ our standard empty case solution\n      // We want to return 0 if the list is\
    \ empty\n      // This can be done with match\n      // So we need to match the\
    \ list in a pattern match\n      // We want to handle the empty case, so let's\
    \ start there\n      // We can then write the code to handle the non-empty case\n\
    \     ", "        var s = 0l\n        for (i <- 0 until lst.length) {\n      \
    \      if (i % 2 == 0 && lst(i) % 2 == 1) {\n                s += lst(i)\n   \
    \         }\n        }\n        return s", '        lst.zipWithIndex.filter(i
    => i._2 % 2 == 0 && i._1 % 2 == 1).map(i => i._1).sum', "        // This does\
    \ not handle the edge case where there are no odd\n        // numbers in the list\
    \ at all.\n        val res = for ((n, ind) <- lst.zipWithIndex if ind % 2 == 0\
    \ && n % 2 == 1) yield n\n        res.sum", "        // Let's write a test\n \
    \       // >>> solution(List[Long](5l.toLong, 8l.toLong, 7l.toLong, 1l.toLong))\n\
    \        // 12l\n        // >>> solution(List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 3l.toLong, 3l.toLong))\n        // 9l\n        // >>> solution(List[Long](30l.toLong,\
    \ 13l.toLong, 24l.toLong, 321l.toLong))\n        // 0l\n        // Write a small\
    \ function that will tell us if a number is odd\n        def isOdd(n : Long) :\
    \ Boolean = {\n            if (n % 2 == 0) return false\n            else return\
    \ true\n        }\n        // >>> isOdd(4l)\n        // false\n        // >>>\
    \ isOdd(5l)\n        // true\n        // We can use the zipWithIndex function\
    \ on List to generate a new list of tuples, where the first item is the element\
    \ and the second is the index\n        // Let's try this on the first example\n\
    \        // >>> lst.zipWithIndex\n        // List((5,0), (8,1), (7,2), (1,3))\n\
    \        // Now we need to filter this new list to get only the odd elements in\
    \ even positions\n        // We can use filter to get only the odd elements\n\
    \        // >>> lst.zipWithIndex.filter(_._1 % 2 != 0)\n        // List((5,0),\
    \ (7,2), (1,3))\n        // That's pretty much half of it, but how can we get\
    \ only the even positions now?\n        // It turns out the modulus operator is\
    \ our friend again. If we apply it to the index of each tuple, we'll get exactly\
    \ what we want\n        // >>> lst.zipWithIndex.filter(_._1 % 2 != 0).filter(_._2\
    \ % 2 == 0)\n        // List((5,0), (1,3))\n        // All that's left is summing\
    \ the tuple values\n        // >>> lst.zipWithIndex.filter(_._1 % 2 != 0).filter(_._2\
    \ % 2 == 0).map(_._1).sum\n       ", "        var total = 0l\n        var current\
    \ = 0\n        var isOdd = false\n        for (i <- lst) {\n            if (isOdd)\
    \ {\n                total += i\n            }\n            isOdd = !isOdd\n \
    \       }\n        return total", "        // ***** Please implement this method.\
    \ *****\n        (for (i <- lst.indices if i % 2 == 0 if lst(i) % 2 == 1) yield\
    \ lst(i)).sum", "        // Write your code here\n        return 0", "       \
    \ // The number of elements in the list is at least 1\n        // Inductive cases\n\
    \        var sum = 0l\n        for (i <- 0 until lst.length) {\n            if\
    \ (i % 2 == 0 && lst(i) % 2 == 1) sum += lst(i)\n        }\n        return sum",
  '        // *** Please provide your code here ***', "        // Your code goes here.\n\
    \        // Return -1 if your code fails any of the given test cases.\n      \
    \  -1l", '        lst.indices.filter(i => i % 2 == 0).map(i => lst(i)).filter(n
    => n % 2 == 1).sum', "        // Write your solution here\n        val len = lst.length\n\
    \        val res = new Array[Long](len)\n        for (i <- 0 until len) {\n  \
    \          if (i % 2 == 0) {\n                res(i) = lst(i)\n            }\n\
    \        }\n        res.sum", '        lst.zipWithIndex.foldLeft(0l)((a, b) =>
    if (b._2 % 2 == 0 && b._1 % 2 == 1) a + b._1 else a)', "        var sum : Long\
    \ = 0\n        for (i <- 0 until lst.length by 2) {\n            if (lst(i) %\
    \ 2 == 1) {\n                sum += lst(i)\n            }\n        }\n       \
    \ return sum", '        return 0', "        // Good luck!\n        lst.zipWithIndex.filter({case(a,\
    \ b) => (b % 2) == 0 && (a % 2) == 1}).map(_._1).sum", "        // Your solution\
    \ goes here\n        var sum = 0l\n        var count = 0\n        while (count\
    \ < lst.length) {\n            if (count % 2 == 0 && lst(count) % 2 == 1) {\n\
    \                sum += lst(count)\n            }\n            count += 1\n  \
    \      }\n        sum", '        lst.zipWithIndex.filter(a => a._2 % 2 == 0 &&
    a._1 % 2 == 1).map(x => x._1).sum', "        // Type your solution here\n    \
    \    def isEven(i : Int) : Boolean = (i % 2 == 0)\n        def isOdd(i : Int)\
    \ : Boolean = (i % 2 != 0)\n        lst.zipWithIndex.filter((x) => isEven(x._2)).filter((x)\
    \ => isOdd(x._1.toInt)).map((x) => x._1).sum", "        // Reduce the list in\
    \ an accumulator based on an index.\n        // When the index is even, add only\
    \ if the number is odd\n        //lst.zipWithIndex.foldLeft(0l)((acc, x) => if\
    \ (x._2 % 2 == 0 && x._1 % 2 == 1) acc + x._1 else acc)\n        // In case the\
    \ above doesn't work, I'm going to try a slightly different approach.\n      \
    \  // I'm going to filter and fold\n        lst.zipWithIndex.filter(x => x._2\
    \ % 2 == 0 && x._1 % 2 == 1).foldLeft(0l)((acc, x) => acc + x._1)", "        val\
    \ res: Long = lst.zipWithIndex.filter(x => x._2 % 2 == 0 && x._1 % 2 == 1).map(x\
    \ => x._1).sum\n        return res", '        return lst.filter((v, i) => i %
    2 == 0 && v % 2 == 1).sum', "        // Your Code Here\n        lst.filter(_ %\
    \ 2 == 1).filter(_ % 2 == 0).sum", "        var sum = 0l.toLong\n        for (i\
    \ <- 1 until lst.length by 2) {\n            if (lst(i) % 2 == 1) sum += lst(i)\n\
    \        }\n        return sum", '        lst.zipWithIndex.map(x => if (x._2 %
    2 == 0 && x._1 % 2 == 1) x._1 else 0).reduce(_ + _)', "        // Return the sum\
    \ of all of the odd elements that are in even positions.\n        def sum(lst\
    \ : List[Long], index : Int, acc : Long) : Long = {\n            lst match {\n\
    \                case List() => acc\n                case x :: xs => if (index\
    \ % 2 == 0 && x % 2 == 1) sum(xs, index + 1, acc + x) else sum(xs, index + 1,\
    \ acc)\n            }\n        }\n        // Edge case to check if list is empty\n\
    \        lst match {\n            case List() => 0\n            case x :: xs =>\
    \ sum(lst, 0, 0)\n        }", "        // Type your solution here\n        0",
  "        // Your solution here\n        lst.zipWithIndex.foldLeft(0l){(acc, elem)\
    \ => if(elem._2 % 2 == 0 && elem._1 % 2 == 1) acc + elem._1 else acc}", "    \
    \    // Your solution goes here\n        var even = false\n        var sum = 0L\n\
    \        for (i <- lst) {\n            if (even) {\n                if (i % 2\
    \ == 1) {\n                    sum += i\n                }\n            }\n  \
    \          even = !even\n        }\n        sum", "        // Given a list, filter\
    \ all even elements, then select all elements in odd position, then sum all.\n\
    \        // Implement filter()\n        def filter(lst : List[Long], p : Long\
    \ => Boolean) : List[Long] = {\n            lst match {\n                case\
    \ Nil => Nil\n                case h :: t => if (p(h)) h :: filter(t, p) else\
    \ filter(t, p)\n            }\n        }\n        // Implement select()\n    \
    \    def select(lst : List[Long], p : Int => Boolean) : List[Long] = {\n     \
    \       def loop(lst : List[Long], i : Int, p : Int => Boolean) : List[Long] =\
    \ {\n                lst match {\n                    case Nil => Nil\n      \
    \              case h :: t => if (p(i)) h :: loop(t, i + 1, p) else loop(t, i\
    \ + 1, p)\n                }\n            }\n            loop(lst, 0, p)\n   \
    \     }\n        // Implement sum()\n        def sum(lst : List[Long]) : Long\
    \ = {\n            def loop(lst : List[Long], acc : Long) : Long = {\n       \
    \         lst match {\n                    case Nil => acc\n                 \
    \   case h :: t => loop(t, acc + h)\n                }\n            }\n      \
    \      loop(lst, 0)\n        }\n        // Implement even()\n        def even(x\
    \ : Long) : Boolean = (x % 2 == 0)\n        // Implement odd()\n        def odd(x\
    \ : Long) : Boolean = (x % 2 == 1)\n        // Implement odd()\n        def even(x\
    \ : Int) : Boolean = (x % 2 == 0)\n        // Implement odd()\n        def odd(x\
    \ : Int) : Boolean = (x % 2 == 1)\n        // Implement evens()\n        def evens(lst\
    \ : List[Long]) : List[Long] = {\n            filter(lst, even)\n        }\n \
    \       // Implement odds()\n        def odds(lst : List[Long]) : List[Long] =\
    \ {\n            filter(lst, odd)\n        }\n        // Implement pairs()\n \
    \       def pairs(lst : List[Long]) : List", '        lst.zipWithIndex.filter(p
    => p._2 % 2 == 0 && p._1 % 2 == 1).map(_._1).sum']
stop_tokens:
- "\n    }\n"
