name: HumanEval_127_intersection
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given two intervals,\n    // where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n    // The given intervals are\
  \ closed which means that the interval (start, end)\n    // includes both start\
  \ and end.\n    // For each given interval, it is assumed that its start is less\
  \ or equal its end.\n    // Your task is to determine whether the length of intersection\
  \ of these two \n    // intervals is a prime number.\n    // Example, the intersection\
  \ of the intervals (1, 3), (2, 4) is (2, 3)\n    // which its length is 1, which\
  \ not a prime number.\n    // If the length of the intersection is a prime number,\
  \ return \"YES\",\n    // otherwise, return \"NO\".\n    // If the two intervals\
  \ don't intersect, return \"NO\".\n    // [input/output] samples:\n    // >>> intersection(((1l,\
  \ 2l)), ((2l, 3l)))\n    // (\"NO\")\n    // >>> intersection(((-1l, 1l)), ((0l,\
  \ 4l)))\n    // (\"NO\")\n    // >>> intersection(((-3l, -1l)), ((-5l, 5l)))\n \
  \   // (\"YES\")\n    def intersection(interval1 : Tuple2[Long, Long], interval2\
  \ : Tuple2[Long, Long]) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
  \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
  \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
  YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
  \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
  \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
  \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
  NO\")));\n    }\n\n}\n"
completions: ["        val (start1, end1) = interval1\n        val (start2, end2)\
    \ = interval2\n        val start = max(start1, start2)\n        val end = min(end1,\
    \ end2)\n        if (start > end) return \"NO\"\n        val len = end - start\
    \ + 1\n        if (len > 1 && len % 2 == 0) return \"NO\"\n        var limit =\
    \ sqrt(len).toLong\n        while (limit > 1) {\n            if (len % limit ==\
    \ 0) return \"NO\"\n            limit -= 1\n        }\n        \"YES\"", "   \
    \     if (interval1._1 > interval2._2 || interval2._1 > interval1._2) {\n    \
    \        \"NO\"\n        } else {\n            val start = max(interval1._1, interval2._1)\n\
    \            val end = min(interval1._2, interval2._2)\n            if (start\
    \ == end) {\n                if (start <= 2) {\n                    \"YES\"\n\
    \                } else {\n                    \"NO\"\n                }\n   \
    \         } else {\n                if (isPrime(end - start + 1)) {\n        \
    \            \"YES\"\n                } else {\n                    \"NO\"\n \
    \               }\n            }\n        }", "      val start = max(interval1._1,\
    \ interval2._1)\n      val end = min(interval1._2, interval2._2)\n      if (start\
    \ > end) \"NO\"\n      else if (List(2l, 3l, 5l, 7l).contains(end - start + 1))\
    \ \"YES\"\n      else \"NO\"", "        val t = (max(interval1._1, interval2._1),\
    \ min(interval1._2, interval2._2))\n        if (t._1 > t._2) \"NO\"\n        else\
    \ if (t._1 == t._2) {\n            if (BigInt(t._1).isProbablePrime(1)) \"YES\"\
    \n            else \"NO\"\n        }\n        else if (BigInt(t._2 - t._1 + 1).isProbablePrime(1))\
    \ \"YES\"\n        else \"NO\"", "        // the second interval start is less\
    \ than the first interval end, the intersection can exist.\n        // then the\
    \ start of the intersection is the max of the two start, and end of the intersection\
    \ is\n        // the min of the two end.\n        // the length of the intersection\
    \ is the difference between the two ends, if the length is 1, return no,\n   \
    \     // otherwise return yes.\n        // if the second interval start is greater\
    \ than the first interval end, return no.\n        // (start1, end1) = interval1\n\
    \        // (start2, end2) = interval2\n        // if start2 > end1:\n       \
    \ //     return \"NO\"\n        // else:\n        //     length = min(end1, end2)\
    \ - max(start1, start2) + 1\n        //     if length == 1:\n        //      \
    \   return \"NO\"\n        //     else:\n        //         return \"YES\"\n \
    \       val (start1, end1) = interval1\n        val (start2, end2) = interval2\n\
    \        if (start2 > end1) {\n            \"NO\"\n        } else {\n        \
    \    val length = min(end1, end2) - max(start1, start2) + 1\n            if (length\
    \ == 1) {\n                \"NO\"\n            } else {\n                \"YES\"\
    \n            }\n        }", "        val (start1, end1) = interval1\n       \
    \ val (start2, end2) = interval2\n        val a = max(start1, start2)\n      \
    \  val b = min(end1, end2)\n        if (a <= b) {\n            if (isPrime(b -\
    \ a + 1)) {\n                \"YES\"\n            } else {\n                \"\
    NO\"\n            }\n        } else {\n            \"NO\"\n        }", "     \
    \   if (interval1._1 > interval2._2 || interval2._1 > interval1._2) return \"\
    NO\"\n        var start = if (interval1._1 > interval2._1) interval1._1 else interval2._1\n\
    \        var end = if (interval1._2 < interval2._2) interval1._2 else interval2._2\n\
    \        val length = end - start + 1\n        if (length < 2) return \"NO\"\n\
    \        else if (length < 3) return \"YES\"\n        else if (length % 2 == 0)\
    \ return \"NO\"\n        else if (length % 3 == 0) return \"NO\"\n        else\
    \ {\n            var i = 5\n            while (i * i <= length) {\n          \
    \      if (length % i == 0) return \"NO\"\n                if (length % (i + 2)\
    \ == 0) return \"NO\"\n                i += 6\n            }\n            return\
    \ \"YES\"\n        }", "        val start = max(interval1._1, interval2._1)\n\
    \        val end = min(interval1._2, interval2._2)\n        if (start > end) return\
    \ \"NO\"\n        val length = end - start + 1\n        if (length < 2) return\
    \ \"NO\"\n        for (i <- 2l until end) {\n            if (length % i == 0)\
    \ return \"NO\"\n        }\n        \"YES\"", "        // let val be the lower\
    \ bound of the intersection\n        val (low1, high1) = interval1\n        val\
    \ (low2, high2) = interval2\n        val val1 = max(low1, low2)\n        val val2\
    \ = min(high1, high2)\n        val low = min(val1, val2)\n        val high = max(val1,\
    \ val2)\n        if (low > high) return \"NO\"\n        val len = high - low +\
    \ 1\n        val result = isPrime(len)\n        if (result) \"YES\" else \"NO\"",
  "        val (start1, end1) = interval1\n        val (start2, end2) = interval2\n\
    \        val start = max(start1, start2)\n        val end = min(end1, end2)\n\
    \        if (start > end) \"NO\"\n        else if (isPrime(end - start + 1)) \"\
    YES\"\n        else \"NO\"", "        // lets ignore the case when the intervals\
    \ don't intersect\n        var maxStart = max(interval1._1, interval2._1)\n  \
    \      var minEnd = min(interval1._2, interval2._2)\n        var intLength = minEnd\
    \ - maxStart + 1\n        if (intLength < 2) return \"NO\"\n        if (intLength\
    \ == 2) return \"YES\"\n        for (i <- 2 to sqrt(intLength).toInt) {\n    \
    \        if (intLength % i == 0) return \"NO\"\n        }\n        return \"YES\"",
  "        val (start1, end1) = interval1\n        val (start2, end2) = interval2\n\
    \        val (n1, n2) = (max(start1, start2), min(end1, end2))\n        if (n1\
    \ <= n2) {\n            if (isPrime(n2 - n1 + 1)) {\n                \"YES\"\n\
    \            } else {\n                \"NO\"\n            }\n        } else {\n\
    \            \"NO\"\n        }", "        if (interval1._1 > interval2._2 || interval2._1\
    \ > interval1._2) return \"NO\"\n        var max = 0l\n        var min = 0l\n\
    \        if (interval1._1 > interval2._1) max = interval1._1 else max = interval2._1\n\
    \        if (interval1._2 < interval2._2) min = interval1._2 else min = interval2._2\n\
    \        if (max > min) return \"NO\"\n        if (min - max < 2) return \"NO\"\
    \n        val r = (min - max) / 2 + max\n        if (r % 2 == 0) return \"NO\"\
    \n        if (r == 2) return \"YES\"\n        for (i <- 3l to r - 1 by 2) {\n\
    \            if (r % i == 0) return \"NO\"\n        }\n        \"YES\"", "   \
    \     val (a, b) = interval1\n        val (c, d) = interval2\n        val start\
    \ = max(a, c)\n        val end = min(b, d)\n        val length = end - start +\
    \ 1\n        if (length <= 0) {\n            \"NO\"\n        } else {\n      \
    \      if (length == 1) {\n                \"YES\"\n            } else {\n   \
    \             val s = Set(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n                if (s.contains(length))\
    \ {\n                    \"YES\"\n                } else {\n                 \
    \   \"NO\"\n                }\n            }\n        }", "        val (start1,\
    \ end1) = interval1\n        val (start2, end2) = interval2\n        if (start1\
    \ > end1 || start2 > end2) return \"NO\"\n        if (start1 > end2 || start2\
    \ > end1) return \"NO\"\n        val start = max(start1, start2)\n        val\
    \ end = min(end1, end2)\n        val result = end - start + 1\n        if (result\
    \ == 1) return \"NO\"\n        if (result < 4) return \"YES\"\n        if (result\
    \ % 2 == 0) return \"NO\"\n        val d = 2l\n        while (d * d <= result)\
    \ {\n            if (result % d == 0) return \"NO\"\n            d += 1\n    \
    \    }\n        \"YES\"", "        val start = max(interval1._1, interval2._1)\n\
    \        val end = min(interval1._2, interval2._2)\n        if (start > end) {\n\
    \            \"NO\"\n        } else {\n            val distance = end - start\
    \ + 1\n            val isPrime = (2l to sqrt(distance).toLong).forall(i => distance\
    \ % i != 0)\n            if (isPrime) {\n                \"YES\"\n           \
    \ } else {\n                \"NO\"\n            }\n        }", "        val (start1,\
    \ end1) = interval1\n        val (start2, end2) = interval2\n        val start\
    \ = max(start1, start2)\n        val end = min(end1, end2)\n        if (start\
    \ > end) {\n            \"NO\"\n        } else {\n            val length = end\
    \ - start + 1\n            if (length == 1) {\n                \"NO\"\n      \
    \      } else {\n                val prime = (2 to length.toInt).toList.forall(x\
    \ => length % x != 0)\n                if (prime) {\n                    \"YES\"\
    \n                } else {\n                    \"NO\"\n                }\n  \
    \          }\n        }", "        val intersection = List(interval1._1, interval1._2,\
    \ interval2._1, interval2._2).sorted.takeRight(2)\n        intersection match\
    \ {\n            case List(a, b) if a == b => \"NO\"\n            case List(a,\
    \ b) if isPrime(b - a) => \"YES\"\n            case _ => \"NO\"\n        }", " \
    \       val start = max(interval1._1, interval2._1)\n        val end = min(interval1._2,\
    \ interval2._2)\n        val length = end - start + 1\n        if (length > 0)\
    \ isPrime(length).toString\n        else \"NO\"", "        if (interval1._1 >\
    \ interval2._2 || interval2._1 > interval1._2) \"NO\"\n        else {\n      \
    \      if (isPrime(min(interval1._2, interval2._2) - max(interval1._1, interval2._1)\
    \ + 1)) \"YES\"\n            else \"NO\"\n        }", "        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start <= end) {\n            val length = end - start + 1\n            if (isPrime(length))\
    \ \"YES\" else \"NO\"\n        } else \"NO\"", "        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (end1 < start2 || end2 < start1)\
    \ {\n            \"NO\"\n        } else {\n            val intersection = (min(end1,\
    \ end2) - max(start1, start2)) + 1\n            if (intersection <= 1) {\n   \
    \             \"NO\"\n            } else {\n                if (isPrime(intersection))\
    \ {\n                    \"YES\"\n                } else {\n                 \
    \   \"NO\"\n                }\n            }\n        }", "        val start =\
    \ max(interval1._1, interval2._1)\n        val end = min(interval1._2, interval2._2)\n\
    \        var answer = \"NO\"\n        if (start <= end) {\n            val length\
    \ = end - start + 1\n            if (length == 1 || length == 2 || length == 3\
    \ || length == 5 || length == 7) {\n                answer = \"YES\"\n       \
    \     }\n        }\n        answer", "      if (interval1._1 <= interval2._1 &&\
    \ interval2._1 <= interval1._2 && interval1._2 <= interval2._2) {\n        if\
    \ (isPrime(interval2._1 - interval1._1)) return \"YES\"\n        else return \"\
    NO\"\n      }\n      else if (interval2._1 <= interval1._1 && interval1._1 <=\
    \ interval2._2 && interval2._2 <= interval1._2) {\n        if (isPrime(interval1._1\
    \ - interval2._1)) return \"YES\"\n        else return \"NO\"\n      }\n     \
    \ \"NO\"", "        def isPrime(num : Long) : Boolean = {\n            if (num\
    \ <= 1) return false\n            if (num == 2) return true\n            for (i\
    \ <- 2l to num / 2l) {\n                if (num % i == 0) return false\n     \
    \       }\n            return true\n        }\n        var (min, max) = (0l, 0l)\n\
    \        if (interval1._1 < interval2._1) min = interval2._1\n        else min\
    \ = interval1._1\n        if (interval1._2 > interval2._2) max = interval2._2\n\
    \        else max = interval1._2\n        if (min > max) return \"NO\"\n     \
    \   if (isPrime(max - min + 1)) return \"YES\"\n        else return \"NO\"", " \
    \       val List(start1, end1) = List(interval1._1, interval1._2)\n        val\
    \ List(start2, end2) = List(interval2._1, interval2._2)\n        val start = List(start1,\
    \ start2).max\n        val end = List(end1, end2).min\n        val result = end\
    \ - start + 1\n        if (result < 0) \"NO\"\n        else if (result == 0) \"\
    NO\"\n        else if (result == 1) \"YES\"\n        else if (result == 2) \"\
    YES\"\n        else if (result % 2 == 0) \"NO\"\n        else {\n            val\
    \ sqrt_result = sqrt(result)\n            for (i <- 3l to sqrt_result.toLong by\
    \ 2) {\n                if (result % i == 0) return \"NO\"\n            }\n  \
    \          \"YES\"\n        }", "        // Write your code here\n        \"NO\"",
  "        val (start1, end1) = interval1\n        val (start2, end2) = interval2\n\
    \        val start = max(start1, start2)\n        val end = min(end1, end2)\n\
    \        if (start > end) \"NO\"\n        else if (isPrime(end - start + 1)) \"\
    YES\"\n        else \"NO\"", "        val points = ListBuffer[Long]()\n      \
    \  points += interval1._1\n        points += interval1._2\n        points += interval2._1\n\
    \        points += interval2._2\n        points = points.sorted\n        val p1\
    \ = points(1)\n        val p2 = points(2)\n        if (p1 == p2) {\n         \
    \   \"NO\"\n        } else {\n            if (isPrime(p2 - p1)) {\n          \
    \      \"YES\"\n            } else {\n                \"NO\"\n            }\n\
    \        }", "        val i1 = interval1._1\n        val j1 = interval1._2\n \
    \       val i2 = interval2._1\n        val j2 = interval2._2\n        val a =\
    \ max(i1, i2)\n        val b = min(j1, j2)\n        if (a > b) return \"NO\"\n\
    \        if (prime(b - a + 1)) return \"YES\"\n        \"NO\"", "        if (interval1._1\
    \ > interval2._2 || interval2._1 > interval1._2) return \"NO\"\n        val start\
    \ = max(interval1._1, interval2._1)\n        val end = min(interval1._2, interval2._2)\n\
    \        val len = end - start + 1\n        if (len == 0) return \"NO\"\n    \
    \    val sqrt = sqrt(len).toLong\n        for (i <- 2l to sqrt) if (len % i ==\
    \ 0) return \"NO\"\n        \"YES\"", "        if (interval1._1 <= interval2._1\
    \ && interval2._1 <= interval1._2) {\n            if (interval1._2 <= interval2._2)\
    \ {\n                if (BigInt(interval2._1 - interval1._1 + 1).isProbablePrime(3))\
    \ return \"YES\"\n                else return \"NO\"\n            }\n        \
    \    else {\n                if (BigInt(interval1._2 - interval2._1 + 1).isProbablePrime(3))\
    \ return \"YES\"\n                else return \"NO\"\n            }\n        }\n\
    \        else if (interval2._1 <= interval1._1 && interval1._1 <= interval2._2)\
    \ {\n            if (interval2._2 <= interval1._2) {\n                if (BigInt(interval1._1\
    \ - interval2._1 + 1).isProbablePrime(3)) return \"YES\"\n                else\
    \ return \"NO\"\n            }\n            else {\n                if (BigInt(interval2._2\
    \ - interval1._1 + 1).isProbablePrime(3)) return \"YES\"\n                else\
    \ return \"NO\"\n            }\n        }\n        else return \"NO\"", "    \
    \    var intersection = (max(interval1._1, interval2._1), min(interval1._2, interval2._2))\n\
    \        if (intersection._1 > intersection._2) return \"NO\"\n        return\
    \ (intersection._2 - intersection._1 + 1).toString", "        if (interval1._1\
    \ > interval2._2 || interval2._1 > interval1._2) \"NO\"\n        else {\n    \
    \        val left = max(interval1._1, interval2._1)\n            val right = min(interval1._2,\
    \ interval2._2)\n            val len = right - left + 1\n            if (isPrime(len))\
    \ \"YES\" else \"NO\"\n        }", "        if (interval1._1 > interval2._2 ||\
    \ interval2._1 > interval1._2) return \"NO\"\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        val\
    \ intersection = end - start + 1\n        if (intersection <= 1) return \"NO\"\
    \n        val primes = Array(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131,\
    \ 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223,\
    \ 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,\
    \ 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\
    \ 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,\
    \ 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613,\
    \ 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719,\
    \ 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827,\
    \ 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\
    \ 947, 953, 967, 971, 977, 983, 991, 997)\n", "        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) \"NO\"\n        else {\n            val (left,\
    \ right) = (max(interval1._1, interval2._1), min(interval1._2, interval2._2))\n\
    \            val length = right - left + 1\n            if (length < 2) \"NO\"\
    \n            else if (length == 2) \"YES\"\n            else {\n            \
    \    val isPrime = Array.fill(length)(true)\n                var i = 2\n     \
    \           while (i * i <= length) {\n                    if (isPrime(i)) {\n\
    \                        var j = i * i\n                        while (j < length)\
    \ {\n                            isPrime(j) = false\n                        \
    \    j += i\n                        }\n                    }\n              \
    \      i += 1\n                }\n                if (isPrime(length - 1)) \"\
    YES\"\n                else \"NO\"\n            }\n        }", "        val (start1,\
    \ end1) = interval1\n        val (start2, end2) = interval2\n        if (start1\
    \ > end1 || start2 > end2) return \"NO\"\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) return \"NO\"\n \
    \       if (isPrime(end - start + 1)) return \"YES\"\n        return \"NO\"",
  "      val min = max(interval1._1, interval2._1)\n      val max = min(interval1._2,\
    \ interval2._2)\n      if (min > max) \"NO\"\n      else if (min == max) \"YES\"\
    \n      else {\n        var flag = true\n        for (i <- 2 to (min - max).toInt)\
    \ if ((min - max) % i == 0) flag = false\n        if (flag) \"YES\" else \"NO\"\
    \n      }", "        val max = max(interval1._1, interval2._1)\n        val min\
    \ = min(interval1._2, interval2._2)\n        if (max > min) {\n            return\
    \ \"NO\"\n        }\n        val len = min - max + 1\n        if (len == 1) {\n\
    \            return \"NO\"\n        }\n        val primeTest = new ArrayBuffer[Boolean]()\n\
    \        val n = sqrt(len).toInt\n        for (i <- 2 to n) {\n            primeTest\
    \ += (len % i == 0)\n        }\n        if (primeTest.foldLeft(true)(_ && _))\
    \ {\n            return \"NO\"\n        }\n        \"YES\"", "        if (interval1._1\
    \ > interval2._2 || interval2._1 > interval1._2) {\n            \"NO\"\n     \
    \   } else {\n            val start = max(interval1._1, interval2._1)\n      \
    \      val end = min(interval1._2, interval2._2)\n            if (isPrime(end\
    \ - start + 1)) {\n                \"YES\"\n            } else {\n           \
    \     \"NO\"\n            }\n        }", "        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val (b1, b2) = ((start1 <= start2),\
    \ (end1 >= end2))\n        if (b1 && b2) {\n            if (start2 <= end2) {\n\
    \                val diff = end2 - start2 + 1\n                if (isPrime(diff))\
    \ {\n                    \"YES\"\n                } else {\n                 \
    \   \"NO\"\n                }\n            } else {\n                \"NO\"\n\
    \            }\n        } else if (!b1 && !b2) {\n            if (start1 <= end1)\
    \ {\n                val diff = end1 - start1 + 1\n                if (isPrime(diff))\
    \ {\n                    \"YES\"\n                } else {\n                 \
    \   \"NO\"\n                }\n            } else {\n                \"NO\"\n\
    \            }\n        } else if (b1 && !b2) {\n            if (start2 <= end1)\
    \ {\n                val diff = end1 - start2 + 1\n                if (isPrime(diff))\
    \ {\n                    \"YES\"\n                } else {\n                 \
    \   \"NO\"\n                }\n            } else {\n                \"NO\"\n\
    \            }\n        } else {\n            if (start1 <= end2) {\n        \
    \        val diff = end2 - start1 + 1\n                if (isPrime(diff)) {\n\
    \                    \"YES\"\n                } else {\n                    \"\
    NO\"\n                }\n            } else {\n                \"NO\"\n      \
    \      }\n        }", "        var (start1, end1) = interval1\n        var (start2,\
    \ end2) = interval2\n        val minimumStart = max(start1, start2)\n        val\
    \ maximumEnd = min(end1, end2)\n        val length = (maximumEnd - minimumStart)\
    \ + 1\n        return isPrime(length) match {\n            case true => \"YES\"\
    \n            case false => \"NO\"\n        }", "        val (a, b) = interval1\n\
    \        val (c, d) = interval2\n        var intersect = (max(a, c), min(b, d))\n\
    \        if (intersect._1 > intersect._2) return \"NO\"\n        if (isPrime(intersect._2\
    \ - intersect._1 + 1)) return \"YES\"\n        return \"NO\"", "        var s\
    \ = max(interval1._1, interval2._1)\n        var e = min(interval1._2, interval2._2)\n\
    \        if (s >= e) return \"NO\"\n        var len = e - s + 1\n        var i\
    \ = 2l\n        while (i <= sqrt(len)) {\n            if (len % i == 0) return\
    \ \"NO\"\n            i += 1\n        }\n        \"YES\"", "        val (start1,\
    \ end1) = interval1\n        val (start2, end2) = interval2\n        val start\
    \ = max(start1, start2)\n        val end = min(end1, end2)\n        if (start\
    \ <= end) {\n            return (isPrime(end - start + 1)) match {\n         \
    \       case true => \"YES\"\n                case false => \"NO\"\n         \
    \   }\n        }\n        \"NO\"", "        var result = \"NO\"\n        val smaller\
    \ = min(interval1._1, interval2._1)\n        val larger = max(interval1._2, interval2._2)\n\
    \        if (smaller <= larger) {\n            val length = larger - smaller +\
    \ 1\n            if (isPrime(length)) result = \"YES\"\n        }\n        result",
  "        // Determine whether the length of intersection of the two intervals is\
    \ a prime number\n        def isPrime(num : Long) : Boolean = {\n            if\
    \ (num <= 1) return false\n            for (i <- 2l to sqrt(num).toLong) {\n \
    \               if (num % i == 0) return false\n            }\n            return\
    \ true\n        }\n        // Find the interval that represents the intersection\
    \ of the two intervals\n        val (interval1Lower, interval1Upper) = interval1\n\
    \        val (interval2Lower, interval2Upper) = interval2\n        var intersection\
    \ : Tuple2[Long, Long] = (max(interval1Lower, interval2Lower), min(interval1Upper,\
    \ interval2Upper))\n        // If the two intervals don't intersect, return \"\
    NO\"\n        if (intersection._1 > intersection._2) return \"NO\"\n        //\
    \ Otherwise, determine whether the length of the intersection is a prime number\n\
    \        val intersectionLength = intersection._2 - intersection._1 + 1\n    \
    \    return if (isPrime(intersectionLength)) \"YES\" else \"NO\"", '        ???',
  "        def isIntersecting(interval1 : Tuple2[Long, Long], interval2 : Tuple2[Long,\
    \ Long]) : Boolean = {\n            interval1._1 <= interval2._2 && interval2._1\
    \ <= interval1._2\n        }\n        def isPrime(n : Long) : Boolean = {\n  \
    \          if (n <= 3) {\n                n >= 2\n            } else if (n % 2\
    \ == 0 || n % 3 == 0) {\n                false\n            } else {\n       \
    \         def go(i : Long) : Boolean = {\n                    if (i * i > n) {\n\
    \                        true\n                    } else if (n % i == 0 || n\
    \ % (i + 2) == 0) {\n                        false\n                    } else\
    \ {\n                        go(i + 6)\n                    }\n              \
    \  }\n                go(5)\n            }\n        }\n        if (isIntersecting(interval1,\
    \ interval2)) {\n            val intersectingInterval = (min(interval1._2, interval2._2),\
    \ max(interval1._1, interval2._1))\n            if (isPrime(intersectingInterval._1\
    \ - intersectingInterval._2)) {\n                \"YES\"\n            } else {\n\
    \                \"NO\"\n            }\n        } else {\n            \"NO\"\n\
    \        }", "        // Intersection of intervals [a, b] and [c, d] is [max(a,\
    \ c), min(b, d)].\n        // If no such a number exists, the intervals don't\
    \ intersect.\n        val a = interval1._1\n        val b = interval1._2\n   \
    \     val c = interval2._1\n        val d = interval2._2\n        val (start,\
    \ end) = (max(a, c), min(b, d))\n        if (start > end) \"NO\"\n        else\
    \ if (isPrime(end - start + 1)) \"YES\"\n        else \"NO\"", "        if (interval1._1\
    \ <= interval2._1 && interval2._1 <= interval1._2 && interval1._2 <= interval2._2)\
    \ {\n            if (isPrime(interval2._1 - interval1._1)) return \"YES\"\n  \
    \          else return \"NO\"\n        }\n        if (interval2._1 <= interval1._1\
    \ && interval1._1 <= interval2._2 && interval2._2 <= interval1._2) {\n       \
    \     if (isPrime(interval1._1 - interval2._1)) return \"YES\"\n            else\
    \ return \"NO\"\n        }\n        if (interval1._1 <= interval2._1 && interval2._2\
    \ <= interval1._2) {\n            if (isPrime(interval2._2 - interval2._1)) return\
    \ \"YES\"\n            else return \"NO\"\n        }\n        if (interval2._1\
    \ <= interval1._1 && interval1._2 <= interval2._2) {\n            if (isPrime(interval1._2\
    \ - interval1._1)) return \"YES\"\n            else return \"NO\"\n        }\n\
    \        \"NO\"", "        val start = max(interval1._1, interval2._1)\n     \
    \   val end = min(interval1._2, interval2._2)\n        if (start <= end) {\n \
    \           if (start == end) \"YES\"\n            else if (isPrime(end - start\
    \ + 1)) \"YES\"\n            else \"NO\"\n        }\n        else \"NO\"", " \
    \       var start = max(interval1._1, interval2._1)\n        var end = min(interval1._2,\
    \ interval2._2)\n        if (start > end) return \"NO\"\n        var length =\
    \ end - start + 1\n        if (length == 1) return \"NO\"\n        var divisors\
    \ = new ArrayBuffer[Long]()\n        for (i <- 2l to sqrt(length).toLong) {\n\
    \            if (length % i == 0) {\n                divisors += i\n         \
    \       divisors += length / i\n            }\n        }\n        if (divisors.size\
    \ == 0) return \"YES\"\n        else return \"NO\"", "        // Check if intervals\
    \ intersect\n        if ((interval1._1 > interval2._2) || (interval2._1 > interval1._2))\
    \ return \"NO\"\n        val start = max(interval1._1, interval2._1)\n       \
    \ val end = min(interval1._2, interval2._2)\n        val intersectionLength =\
    \ end - start + 1\n        // Make sure the length of the intersection is a positive\
    \ number\n        if (intersectionLength < 1) return \"NO\"\n        // Check\
    \ if the length of the intersection is a prime number\n        if (isPrime(intersectionLength))\
    \ return \"YES\"\n        else return \"NO\"", "        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) {\n            \"NO\"\n        } else {\n  \
    \          var ix = if (interval1._1 > interval2._1) interval1._1 else interval2._1\n\
    \            var ex = if (interval1._2 < interval2._2) interval1._2 else interval2._2\n\
    \            if (ex - ix < 2) {\n                \"NO\"\n            } else {\n\
    \                val list = (ix + 1 until ex).toList\n                if (list.size\
    \ == 1) {\n                    \"YES\"\n                } else {\n           \
    \         list.filter {\n                        i =>\n                      \
    \      list.forall {\n                                _ % i != 0\n           \
    \                 }\n                    }.size == 1 match {\n               \
    \         case true => \"YES\"\n                        case false => \"NO\"\n\
    \                    }\n                }\n            }\n        }", "      \
    \  var start = max(interval1._1, interval2._1)\n        var end = min(interval1._2,\
    \ interval2._2)\n        if (start >= end) return \"NO\"\n        var len = end\
    \ - start + 1\n        var lenSqrt = sqrt(len)\n        for (i <- 2 to lenSqrt.toInt)\
    \ if (len % i == 0) return \"NO\"\n        \"YES\"", "        val minOfStart =\
    \ min(interval1._1, interval2._1)\n        val maxOfEnd = max(interval1._2, interval2._2)\n\
    \        val intersectionLength = abs(minOfStart - maxOfEnd) + 1\n        println(intersectionLength)\n\
    \        if (intersectionLength < 2) return \"NO\"\n        else {\n         \
    \   for (i <- 2l until intersectionLength) {\n                if (intersectionLength\
    \ % i == 0) return \"NO\"\n            }\n            return \"YES\"\n       \
    \ }", "        if (interval1._1 > interval2._2 || interval2._1 > interval1._2)\
    \ {\n            \"NO\"\n        } else {\n            val lower = max(interval1._1,\
    \ interval2._1)\n            val upper = min(interval1._2, interval2._2)\n   \
    \         if (lower > upper) {\n                \"NO\"\n            } else {\n\
    \                val len = upper - lower + 1\n                if (len <= 2) {\n\
    \                    \"NO\"\n                } else {\n                    if\
    \ (len % 2 == 0) {\n                        \"NO\"\n                    } else\
    \ {\n                        for (i <- 2 until sqrt(len).toInt + 1) {\n      \
    \                      if (len % i == 0) {\n                                return\
    \ \"NO\"\n                            }\n                        }\n         \
    \               \"YES\"\n                    }\n                }\n          \
    \  }\n        }", "        // Returns the intersection of the intervals [start1,\
    \ end1] and [start2, end2].\n        // If there is no intersection, returns [0,\
    \ -1].\n        def intersection(start1 : Long, end1 : Long, start2 : Long, end2\
    \ : Long) : Tuple2[Long, Long] = {\n            if (start1 > end2 || start2 >\
    \ end1) (0, -1)\n            else {\n                val start = (start1 max start2)\n\
    \                val end = (end1 min end2)\n                (start, end)\n   \
    \         }\n        }\n        val (start1, end1) = interval1\n        val (start2,\
    \ end2) = interval2\n        val (start, end) = intersection(start1, end1, start2,\
    \ end2)\n        if (start == 0 && end == -1) \"NO\"\n        else if (isPrime(end\
    \ - start + 1)) \"YES\"\n        else \"NO\"", "        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) return \"NO\"\n        val (start, end) = (max(interval1._1,\
    \ interval2._1), min(interval1._2, interval2._2))\n        val length = end -\
    \ start + 1\n        if (length < 2) return \"NO\"\n        if (length == 2) return\
    \ \"YES\"\n        if (length % 2 == 0) return \"NO\"\n        if (length % 3\
    \ == 0) return \"NO\"\n        var i = 5\n        while (i * i <= length) {\n\
    \            if (length % i == 0) return \"NO\"\n            if (length % (i +\
    \ 2) == 0) return \"NO\"\n            i += 6\n        }\n        \"YES\"", " \
    \       def isprime(num : Long) : Boolean = {\n            def helper(num : Long,\
    \ x : Long) : Boolean = {\n                if (x == 1) true\n                else\
    \ if (num % x == 0) false\n                else helper(num, x - 1)\n         \
    \   }\n            helper(num, num - 1)\n        }\n        val value = if (interval1._1\
    \ > interval2._1) (interval1._1, interval2._2) else (interval2._1, interval1._2)\n\
    \        if (value._1 > value._2) \"NO\"\n        else if (isprime(value._2 -\
    \ value._1 + 1)) \"YES\"\n        else \"NO\"", "      val (a, b) = interval1\n\
    \      val (c, d) = interval2\n      val (start, end) = (max(a, c), min(b, d))\n\
    \      if (start > end) {\n        \"NO\"\n      } else {\n        val len = end\
    \ - start + 1\n        if (len < 2) {\n          \"NO\"\n        } else {\n  \
    \        if (len == 2) {\n            \"YES\"\n          } else {\n          \
    \  val arr = (0 until len.toInt).toArray\n            val sq = sqrt(len).toInt\n\
    \            for (i <- 2 to sq) {\n              if (arr(i) == 0) {\n        \
    \        for (j <- 2 * i to arr.length - 1 by i) {\n                  arr(j) =\
    \ 1\n                }\n              }\n            }\n            val result\
    \ = arr.filter(x => x == 0).length\n            if (result == 2) {\n         \
    \     \"YES\"\n            } else {\n              \"NO\"\n            }\n   \
    \       }\n        }\n      }", "        val start = max(interval1._1, interval2._1)\n\
    \        val end = min(interval1._2, interval2._2)\n        if (start > end) {\n\
    \            \"NO\"\n        } else {\n            val len = end - start + 1\n\
    \            val isPrime = (len == 2 || (2l to (len - 1)).forall(x => len % x\
    \ != 0))\n            if (isPrime) \"YES\" else \"NO\"\n        }", "        val\
    \ length = (interval1._1 max interval2._1) - (interval1._2 min interval2._2)\n\
    \        if (length > 0) {\n            if (length == 1 || isPrime(length)) return\
    \ \"YES\"\n        }\n        \"NO\"", "        val (interval1Start, interval1End)\
    \ = interval1\n        val (interval2Start, interval2End) = interval2\n      \
    \  if (interval1Start > interval1End || interval2Start > interval2End) return\
    \ \"NO\"\n        val (intersectionStart, intersectionEnd) = (interval1Start max\
    \ interval2Start, interval1End min interval2End)\n        if (intersectionStart\
    \ > intersectionEnd) return \"NO\"\n        //println(\"(\" + intersectionStart\
    \ + \", \" + intersectionEnd + \")\")\n        val intersectionLength = intersectionEnd\
    \ - intersectionStart + 1\n        return if (intersectionLength.isPrime) \"YES\"\
    \ else \"NO\"", "        // Write your code here!\n        \"\"", "        if\
    \ (interval1._1 > interval2._2 || interval2._1 > interval1._2) {\n           \
    \ \"NO\"\n        } else {\n            val l : Long = List(interval1._1, interval2._1).max\
    \ - List(interval1._1, interval2._1).min\n            if (l % 2 == 0) {\n    \
    \            return \"NO\"\n            }\n            if (l < 2) {\n        \
    \        return \"NO\"\n            }\n            var i : Long = 2\n        \
    \    while (i <= l) {\n                if (l % i == 0) {\n                   \
    \ return \"NO\"\n                }\n                i += 1\n            }\n  \
    \          \"YES\"\n        }", "        val p = interval1._1; val q = interval1._2\n\
    \        val r = interval2._1; val s = interval2._2\n        if (q < r || s <\
    \ p) \"NO\"\n        else {\n            var lo = 0L; var hi = 0L\n          \
    \  if (p <= r) lo = r\n            else lo = p\n            if (q >= s) hi = s\n\
    \            else hi = q\n            val x = hi - lo + 1\n            if (x <=\
    \ 1) \"NO\"\n            else if (List(2, 3, 5, 7).contains(x)) \"YES\"\n    \
    \        else if (x % 2 == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) \"NO\"\
    \n            else \"YES\"\n        }", "        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end1 || start2 >\
    \ end2) return \"NO\"\n        val intersectionStart = max(start1, start2)\n \
    \       val intersectionEnd = min(end1, end2)\n        if (intersectionStart >=\
    \ intersectionEnd) return \"NO\"\n        val intersectionLength = intersectionEnd\
    \ - intersectionStart + 1\n        if (intersectionLength == 2) return \"YES\"\
    \n        else if (intersectionLength <= 0) return \"NO\"\n        if (isPrime(intersectionLength))\
    \ return \"YES\"\n        \"NO\"", "        var start = max(interval1._1, interval2._1)\n\
    \        var end = min(interval1._2, interval2._2)\n        if (start > end) {\n\
    \            return \"NO\"\n        }\n        var result = \"YES\"\n        for\
    \ (i <- Range(2, end - start + 1)) {\n            if ((end - start + 1) % i ==\
    \ 0) {\n                result = \"NO\"\n                return result\n     \
    \       }\n        }\n        return result", "        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val (maxStart, minEnd) = (max(start1,\
    \ start2), min(end1, end2))\n        val result = (minEnd - maxStart + 1).toLong\n\
    \        if (result <= 0) \"NO\"\n        else if (result == 1 || result == 2)\
    \ \"YES\"\n        else if (result % 2 == 0) \"NO\"\n        else {\n        \
    \    for (i <- 3l to sqrt(result).toLong by 2) {\n                if (result %\
    \ i == 0) return \"NO\"\n            }\n            \"YES\"\n        }", "   \
    \     val start = max(interval1._1, interval2._1)\n        val end = min(interval1._2,\
    \ interval2._2)\n        if (start >= end) return \"NO\"\n        if (start ==\
    \ end) return if (isPrime(start)) \"YES\" else \"NO\"\n        if (isPrime(end\
    \ - start + 1)) return \"YES\"\n        if (isPrime(end - start)) return \"YES\"\
    \n        \"NO\"", "        // check if intervals intersect\n        var interval3\
    \ = interval1\n        var interval4 = interval2\n        var intersect = false\n\
    \        if (interval1._1 <= interval2._1) {\n            if (interval1._2 >=\
    \ interval2._1) {\n                intersect = true\n                interval3\
    \ = (interval2._1, min(interval1._2, interval2._2))\n            }\n        }\
    \ else {\n            if (interval2._2 >= interval1._1) {\n                intersect\
    \ = true\n                interval4 = (interval1._1, min(interval1._2, interval2._2))\n\
    \            }\n        }\n        if (intersect) {\n            // verify if\
    \ length of intersection is prime\n            if (isPrime(interval3._2 - interval4._1\
    \ + 1)) {\n                return \"YES\"\n            } else {\n            \
    \    return \"NO\"\n            }\n        } else {\n            return \"NO\"\
    \n        }", "        val (a, b) = interval1\n        val (c, d) = interval2\n\
    \        // Making sure the first interval is always the smallest\n        val\
    \ (start, end) = if (a > c) (c, d) else (a, b)\n        val (x, y) = if (a > c)\
    \ (a, b) else (c, d)\n        if (start >= y || end <= x) return \"NO\"\n    \
    \    val intersection = max(x, start) to min(y, end)\n        if (intersection.length\
    \ <= 1) return \"NO\"\n        for (i <- 2 until intersection.length) if (intersection.length\
    \ % i == 0) return \"NO\"\n        \"YES\"", "        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) return \"NO\"\n        val begin = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        val\
    \ interval = (begin, end)\n        return if (isPrime(interval._2 - interval._1\
    \ + 1)) \"YES\" else \"NO\"", "        val s1 = interval1._1\n        val e1 =\
    \ interval1._2\n        val s2 = interval2._1\n        val e2 = interval2._2\n\
    \        var start = 0l\n        var end = 0l\n        if (s1 > s2) {\n      \
    \      start = s1\n        } else {\n            start = s2\n        }\n     \
    \   if (e1 < e2) {\n            end = e1\n        } else {\n            end =\
    \ e2\n        }\n        if (start <= end) {\n            if (end - start == 1)\
    \ {\n                \"YES\"\n            } else {\n                val s = new\
    \ StringBuilder\n                for (i <- start to end) {\n                 \
    \   s.append(i)\n                }\n                isPrime(s.toString.toLong)\n\
    \            }\n        } else {\n            \"NO\"\n        }", "        //\
    \ start and end points of two intervals\n        val (a, b) = interval1\n    \
    \    val (c, d) = interval2\n        // length of intersection\n        val n\
    \ = (min(b, d) - max(a, c) + 1).toInt\n        if (n <= 0) return \"NO\"\n   \
    \     else {\n            if (Util.isPrime(n)) return \"YES\"\n            else\
    \ return \"NO\"\n        }", "        val (a, b) = interval1\n        val (c,\
    \ d) = interval2\n        val start = max(a, c)\n        val end = min(b, d)\n\
    \        if (start > end) \"NO\"\n        else {\n            val length = end\
    \ - start + 1\n            if (length == 1) \"NO\"\n            else if (length\
    \ == 2) \"YES\"\n            else if (length % 2 == 0) \"NO\"\n            else\
    \ {\n                val sqrt = sqrt(length).toLong\n                var isPrime\
    \ = true\n                for (i <- 2l to sqrt) {\n                    if (length\
    \ % i == 0) {\n                        isPrime = false\n                     \
    \   i = sqrt\n                    }\n                }\n                if (isPrime)\
    \ \"YES\"\n                else \"NO\"\n            }\n        }", "    \tval\
    \ smaller = if (interval1._1 <= interval2._1) interval1 else interval2\n    \t\
    val larger = if (interval1._1 <= interval2._1) interval2 else interval1\n    \t\
    if (smaller._2 < larger._1) return \"NO\"\n    \tval upper = if (smaller._2 <\
    \ larger._2) smaller._2 else larger._2\n    \tval lower = if (smaller._1 < larger._1)\
    \ larger._1 else smaller._1\n    \tif (upper < lower) return \"NO\"\n    \tval\
    \ length = upper - lower + 1\n    \tif (length < 2) return \"NO\"\n    \tif (length\
    \ == 2) return \"YES\"\n    \tif (length % 2 == 0) return \"NO\"\n    \tfor (i\
    \ <- 3l to sqrt(length).toLong by 2) {\n    \t\tif (length % i == 0) return \"\
    NO\"\n    \t}\n    \t\"YES\"", "        var intersections = List[Long]()\n   \
    \     intersections = intersections :+ max(interval1._1, interval2._1)\n     \
    \   intersections = intersections :+ min(interval1._2, interval2._2)\n       \
    \ if (intersections(0) >= intersections(1)) {\n            return \"NO\"\n   \
    \     }\n        val x = intersections(1) - intersections(0)\n        if (x ==\
    \ 1) {\n            return \"NO\"\n        }\n        for (i <- 2l to x/2) {\n\
    \            if (x % i == 0) {\n                return \"NO\"\n            }\n\
    \        }\n        return \"YES\"", "        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) {\n            \"\
    NO\"\n        } else {\n            val length = end - start + 1\n           \
    \ if (length == 1 || length == 2) {\n                \"NO\"\n            } else\
    \ {\n                val isPrime = (2l to sqrt(length).toLong).filter(length %\
    \ _ == 0).isEmpty\n                if (isPrime) {\n                    \"YES\"\
    \n                } else {\n                    \"NO\"\n                }\n  \
    \          }\n        }", "        if (interval1._1 > interval2._2 || interval2._1\
    \ > interval1._2) return \"NO\"\n        val min = max(interval1._1, interval2._1)\n\
    \        val max = min(interval1._2, interval2._2)\n        val diff = max - min\
    \ + 1\n        val primes = ArrayBuffer(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l,\
    \ 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l,\
    \ 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l,\
    \ 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l,\
    \ 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l,\
    \ 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l,\
    \ 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l,\
    \ 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l,\
    \ 569l, 571l, 577l, 587l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l,\
    \ 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l,",
  "        val int1 = interval1._1 to interval1._2\n        val int2 = interval2._1\
    \ to interval2._2\n        val int = int1.intersect(int2)\n        val l = int.length\n\
    \        if (l == 0) return \"NO\"\n        if (l % 2 == 0) return \"NO\"\n  \
    \      if (l == 1) return \"YES\"\n        var p = true\n        for (i <- 3l\
    \ to l by 2) {\n            if (l % i == 0) {\n                p = false\n   \
    \             return \"NO\"\n            }\n        }\n        return \"YES\"",
  "        val start = max(interval1._1, interval2._1)\n        val end = min(interval1._2,\
    \ interval2._2)\n        if (start > end) {\n            \"NO\"\n        } else\
    \ {\n            val diff = end - start + 1\n            if (diff == 1) {\n  \
    \              \"NO\"\n            } else {\n                val r = sqrt(diff).toLong\n\
    \                if (r * r == diff) {\n                    \"NO\"\n          \
    \      } else {\n                    var isPrime = true\n                    var\
    \ i = 3l\n                    while (i <= r) {\n                        if (diff\
    \ % i == 0) {\n                            isPrime = false\n                 \
    \           i = r + 1\n                        }\n                        i +=\
    \ 2\n                    }\n                    if (isPrime) {\n             \
    \           \"YES\"\n                    } else {\n                        \"\
    NO\"\n                    }\n                }\n            }\n        }", " \
    \       // interval1, interval2 are sorted in ascending order\n        // interval1,\
    \ interval2 are closed interval, i.e., [a, b]\n        def intersectionLength(interval1\
    \ : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]) : Long = {\n         \
    \   val (start1, end1) = interval1\n            val (start2, end2) = interval2\n\
    \            // if (start1 > end2 || start2 > end1) 0 else max(start1, start2)\
    \ - min(end1, end2)\n            if (start1 > end2 || start2 > end1) 0 else max(start1,\
    \ start2) - min(end1, end2) + 1\n        }\n        def isPrime(n : Long) : Boolean\
    \ = {\n            if (n < 2) false else if (n == 2) true else if (n % 2 == 0)\
    \ false else !(3l to sqrt(n).toLong by 2l).exists(n % _ == 0)\n        }\n   \
    \     if (intersectionLength(interval1, interval2) > 0) {\n            if (isPrime(intersectionLength(interval1,\
    \ interval2))) \"YES\" else \"NO\"\n        } else \"NO\"", "        def isPrime(n\
    \ : Long) : Boolean = n > 1 && (2l to sqrt(n).toLong).forall(n % _ != 0)\n   \
    \     val start = max(interval1._1, interval2._1)\n        val end = min(interval1._2,\
    \ interval2._2)\n        if (start > end) \"NO\"\n        else if (isPrime(end\
    \ - start + 1)) \"YES\"\n        else \"NO\"", "        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) \"NO\"\n        else {\n            val left\
    \ = max(interval1._1, interval2._1)\n            val right = min(interval1._2,\
    \ interval2._2)\n            val len = right - left + 1\n            if (len <\
    \ 2) \"NO\"\n            else {\n                val sqrt = math.sqrt(len).toLong\n\
    \                val isPrime = (2L to sqrt).find(len % _ == 0) match {\n     \
    \               case Some(i) => false\n                    case None => true\n\
    \                }\n                if (isPrime) \"YES\"\n                else\
    \ \"NO\"\n            }\n        }", "    \tif (interval1._1 <= interval2._1 &&\
    \ interval2._1 <= interval1._2) {\n    \t\tif (interval1._2 <= interval2._2) {\n\
    \    \t\t\tval length = interval1._2 - interval2._1 + 1\n    \t\t\tif (length\
    \ == 2) \"YES\"\n    \t\t\telse if (length % 2 == 0) \"NO\"\n    \t\t\telse {\n\
    \    \t\t\t\tvar flag = true\n    \t\t\t\tfor (i <- 3 to sqrt(length).toInt if\
    \ flag) {\n    \t\t\t\t\tif (length % i == 0) flag = false\n    \t\t\t\t}\n  \
    \  \t\t\t\tif (flag) \"YES\" else \"NO\"\n    \t\t\t}\n    \t\t}\n    \t\telse\
    \ {\n    \t\t\tval length = interval2._2 - interval2._1 + 1\n    \t\t\tif (length\
    \ == 2) \"YES\"\n    \t\t\telse if (length % 2 == 0) \"NO\"\n    \t\t\telse {\n\
    \    \t\t\t\tvar flag = true\n    \t\t\t\tfor (i <- 3 to sqrt(length).toInt if\
    \ flag) {\n    \t\t\t\t\tif (length % i == 0) flag = false\n    \t\t\t\t}\n  \
    \  \t\t\t\tif (flag) \"YES\" else \"NO\"\n    \t\t\t}\n    \t\t}\n    \t}\n  \
    \  \telse if (interval2._1 <= interval1._1 && interval1._1 <= interval2._2) {\n\
    \    \t\tif (interval2._2 <= interval1._2) {\n    \t\t\tval length = interval2._2\
    \ - interval1._1 + 1\n    \t\t\tif (length == 2) \"YES\"\n    \t\t\telse if (length\
    \ % 2 == 0) \"NO\"\n    \t\t\telse {\n    \t\t\t\tvar flag = true\n    \t\t\t\t\
    for (i <- 3 to sqrt(length).toInt if flag) {\n    \t\t\t\t\tif (length % i ==\
    \ 0) flag = false\n    \t\t\t\t}\n    \t\t\t\tif (flag)", "        val start =\
    \ max(interval1._1, interval2._1)\n        val end = min(interval1._2, interval2._2)\n\
    \        if (start > end) return \"NO\"\n        return if (Array(2, 3, 5, 7).contains(end\
    \ - start + 1)) \"YES\" else \"NO\"", "        var len = max(interval1._1, interval2._1)\
    \ - min(interval1._2, interval2._2)\n        if (len < 0) {\n            return\
    \ \"NO\"\n        }\n        for (i <- 2 to sqrt(len).toInt) {\n            if\
    \ (len % i == 0) {\n                return \"NO\"\n            }\n        }\n\
    \        return \"YES\"", "        var (start1, end1) = interval1\n        var\
    \ (start2, end2) = interval2\n        var p = true\n        if (start1 > end1)\
    \ (start1, end1) = (end1, start1)\n        if (start2 > end2) (start2, end2) =\
    \ (end2, start2)\n        var (start, end) = (max(start1, start2), min(end1, end2))\n\
    \        if (start > end) p = false\n        else {\n            for (i <- 2 to\
    \ end.toInt)\n                if (start % i == 0 && end % i == 0) p = false\n\
    \        }\n        if (p) \"YES\" else \"NO\"", "        val s1 = interval1._1\n\
    \        val e1 = interval1._2\n        val s2 = interval2._1\n        val e2\
    \ = interval2._2\n        // return if it intersects\n        def intersects(s1\
    \ : Long, e1 : Long, s2 : Long, e2 : Long) : Boolean = {\n            if (s1 <=\
    \ s2 && s2 <= e1) return true\n            if (s2 <= s1 && s1 <= e2) return true\n\
    \            return false\n        }\n        def isPrime(n : Long) : Boolean\
    \ = {\n            if (n <= 1) return false\n            if (n == 2) return true\n\
    \            if (n % 2 == 0) return false\n            val s = sqrt(n).toLong\n\
    \            var i = 3l\n            while (i <= s) {\n                if (n %\
    \ i == 0) return false\n                i += 2\n            }\n            return\
    \ true\n        }\n        val s = max(s1, s2)\n        val e = min(e1, e2)\n\
    \        if (intersects(s1, e1, s2, e2)) {\n            if (isPrime(e - s + 1))\
    \ return \"YES\"\n            else return \"NO\"\n        }\n        return \"\
    NO\"", "    \tvar start = max(interval1._1, interval2._1)\n    \tvar end = min(interval1._2,\
    \ interval2._2)\n    \tif (start > end) return \"NO\"\n    \tif (end - start ==\
    \ 0) return isPrime(end - start)\n    \tif (end - start == 1) return isPrime(end\
    \ - start + 1)\n    \treturn isPrime(end - start + 2)", "        if (interval1._1\
    \ > interval2._2 || interval2._1 > interval1._2) \"NO\"\n        else {\n    \
    \        val length = List(interval1._1, interval1._2, interval2._1, interval2._2).sorted.slice(1,\
    \ 3).diff(List(interval1._1, interval1._2, interval2._1, interval2._2).sorted.slice(0,\
    \ 2)).reduce(_ - _) + 1\n            if (length == 1) \"NO\"\n            else\
    \ if (length == 2) \"YES\"\n            else {\n                for (i <- 2 to\
    \ sqrt(length).toInt) if (length % i == 0) return \"NO\"\n                \"YES\"\
    \n            }\n        }", "        val (start1, end1) = interval1\n       \
    \ val (start2, end2) = interval2\n        if (end1 < start2 || end2 < start1)\
    \ \"NO\"\n        else {\n            val start = max(start1, start2)\n      \
    \      val end = min(end1, end2)\n            val len = end - start + 1\n    \
    \        val res = len == 1 || len == 2 || len % 2 == 1 && !(3 to sqrt(len).toInt\
    \ by 2).exists(n => len % n == 0)\n            if (res) \"YES\" else \"NO\"\n\
    \        }", "        val (start1, end1) = interval1\n        val (start2, end2)\
    \ = interval2\n        val start = max(start1, start2)\n        val end = min(end1,\
    \ end2)\n        if (start <= end) {\n            if (isPrime(end - start + 1))\
    \ \"YES\" else \"NO\"\n        } else \"NO\"", "        var start : Long = 0\n\
    \        var end : Long = 0\n        if (interval1._1 <= interval2._1) {\n   \
    \         start = interval2._1\n        } else {\n            start = interval1._1\n\
    \        }\n        if (interval1._2 >= interval2._2) {\n            end = interval2._2\n\
    \        } else {\n            end = interval1._2\n        }\n        if (start\
    \ > end) {\n            return \"NO\"\n        }\n        return if (start ==\
    \ end) {\n            \"YES\"\n        } else {\n            val length = (end\
    \ - start) + 1\n            if (isPrime(length)) {\n                \"YES\"\n\
    \            } else {\n                \"NO\"\n            }\n        }", "  \
    \      var start = max(interval1._1, interval2._1)\n        var end = min(interval1._2,\
    \ interval2._2)\n        var length = end - start + 1\n        if (length < 0)\
    \ return \"NO\"\n        val isPrime = Array.fill(length.toInt + 1)(true)\n  \
    \      isPrime(0) = false\n        isPrime(1) = false\n        val sqrt = ceil(sqrt(length)).toInt\n\
    \        for (i <- 2 to sqrt) {\n            if (isPrime(i)) {\n             \
    \   for (j <- i + i to length.toInt by i) isPrime(j) = false\n            }\n\
    \        }\n        if (isPrime(length.toInt)) \"YES\" else \"NO\"", "       \
    \ var (start1, end1) = interval1\n        var (start2, end2) = interval2\n   \
    \     var start = max(start1, start2)\n        var end = min(end1, end2)\n   \
    \     if (start > end) return \"NO\"\n        var result = start to end\n    \
    \    var length = result.length\n        var isPrime = true\n        for (i <-\
    \ 2 to sqrt(length).toInt) {\n            if (length % i == 0) {\n           \
    \     isPrime = false\n                break\n            }\n        }\n     \
    \   if (isPrime) return \"YES\"\n        else return \"NO\"", "        var start\
    \ = max(interval1._1, interval2._1)\n        var end = min(interval1._2, interval2._2)\n\
    \        if (start <= end) return \"NO\"\n        val length = end - start + 1\n\
    \        if (length == 1) return \"NO\"\n        var prime = true\n        for\
    \ (i <- 2l to sqrt(length).toLong) {\n            if (length % i == 0) {\n   \
    \             prime = false\n                break\n            }\n        }\n\
    \        if (prime) return \"YES\"\n        return \"NO\"", "        val (start1,\
    \ end1) = interval1\n        val (start2, end2) = interval2\n        if (start1\
    \ > end1 || start2 > end2) return \"NO\"\n        val s = max(start1, start2)\n\
    \        val e = min(end1, end2)\n        if (s > e) return \"NO\"\n        if\
    \ (isPrime(e - s + 1)) return \"YES\"\n        \"NO\"", "        val (start1,\
    \ end1) = interval1\n        val (start2, end2) = interval2\n        val intersection_start\
    \ = start1 max start2\n        val intersection_end = end1 min end2\n        if\
    \ (intersection_start > intersection_end) \"NO\"\n        else {\n           \
    \ val interval_length = (intersection_end - intersection_start) + 1\n        \
    \    if (Problem.isPrime(interval_length)) \"YES\"\n            else \"NO\"\n\
    \        }", "        val (a, b) = interval1\n        val (c, d) = interval2\n\
    \        val (x, y) = (max(a, c), min(b, d))\n        if (x <= y) {\n        \
    \    if (isPrime(y - x + 1)) return \"YES\"\n            else return \"NO\"\n\
    \        }\n        else return \"NO\"", "        // code here\n        var inter\
    \ = interval1._1.max(interval2._1) to interval1._2.min(interval2._2)\n       \
    \ if (inter.length == 0) return \"NO\"\n        if (inter.length == 1) return\
    \ \"YES\"\n        for (i <- 2 to inter.length - 1) {\n            if (inter.length\
    \ % i == 0) return \"NO\"\n        }\n        \"YES\"", "        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val len =\
    \ end - start + 1\n            if (len == 1) {\n                \"NO\"\n     \
    \       } else {\n                val sq = sqrt(len)\n                val sqr\
    \ = sq.toLong\n                var f = true\n                for (i <- 2l to sqr)\
    \ {\n                    if (len % i == 0) {\n                        f = false\n\
    \                    }\n                }\n                if (f) {\n        \
    \            \"YES\"\n                } else {\n                    \"NO\"\n \
    \               }\n            }\n        }", "        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) {\n            \"NO\"\n        } else {\n  \
    \          val start = List(interval1._1, interval2._1).max\n            val end\
    \ = List(interval1._2, interval2._2).min\n            val interval = (start, end)\n\
    \            val isPrime = interval._2 - interval._1 + 1 match {\n           \
    \     case 0 => true\n                case 1 => true\n                case 2 =>\
    \ true\n                case x if (x % 2 == 0) => false\n                case\
    \ _ => \n                    var i = 3\n                    var sqrt = sqrt(x).toInt\n\
    \                    while (i <= sqrt) {\n                        if (x % i ==\
    \ 0) return false\n                        i += 2\n                    }\n   \
    \                 true\n            }\n            if (isPrime) \"YES\" else \"\
    NO\"\n        }", "      var (a, b) = interval1\n      var (c, d) = interval2\n\
    \      if (b < c || d < a) return \"NO\"\n      val l = b min d - a max c + 1\n\
    \      println(l)\n      if (l > 1 && !(2l to sqrt(l).toLong).exists(x => l %\
    \ x == 0)) return \"YES\"\n      \"NO\"", "        val intersect = (interval1._1\
    \ max interval2._1, interval1._2 min interval2._2)\n        if (intersect._1 >=\
    \ intersect._2) return \"NO\"\n        if (intersect._2 == intersect._1) return\
    \ \"YES\"\n        val length = intersect._2 - intersect._1 + 1\n        def isPrime(n\
    \ : Long) : Boolean = {\n            if (n <= 1) return false\n            var\
    \ i = 2l\n            while (i * i <= n) {\n                if (n % i == 0) return\
    \ false\n                i += 1\n            }\n            return true\n    \
    \    }\n        if (isPrime(length)) return \"YES\"\n        return \"NO\"", " \
    \       var intersect = (min(interval1._2, interval2._2) - max(interval1._1, interval2._1)\
    \ + 1).toLong\n        if (intersect <= 0) return \"NO\"\n        var left = intersect\n\
    \        var i = 2\n        while (i * i <= left) {\n            if (left % i\
    \ == 0) return \"NO\"\n            i += 1\n        }\n        return \"YES\"",
  "        val (start1, end1) = interval1\n        val (start2, end2) = interval2\n\
    \        if (start1 <= start2 && start2 <= end1) {\n            if (end1 >= end2)\
    \ isPrime(end2 - start2 + 1) else isPrime(end1 - start2 + 1)\n        } else if\
    \ (start2 <= start1 && start1 <= end2) {\n            if (end2 >= end1) isPrime(end1\
    \ - start1 + 1) else isPrime(end2 - start1 + 1)\n        } else {\n          \
    \  \"NO\"\n        }", "        //interval1: (1, 2)\n        //interval2: (2,\
    \ 3)\n        val length = min(interval1._2, interval2._2) - max(interval1._1,\
    \ interval2._1) + 1\n        if (length < 1) return \"NO\"\n        val primes\
    \ = Set(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l,\
    \ 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l,\
    \ 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l,\
    \ 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l,\
    \ 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l,\
    \ 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l,\
    \ 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l,\
    \ 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 593l,\
    \ 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l,\
    \ 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739", "        if (interval1._1\
    \ <= interval2._1 && interval2._1 <= interval1._2) {\n            var possibleIntersection\
    \ = if (interval1._2 < interval2._2) (interval2._1, interval1._2) else (interval2._1,\
    \ interval2._2)\n            if (isPrime(possibleIntersection._2 - possibleIntersection._1\
    \ + 1)) return \"YES\"\n        }\n        if (interval2._1 <= interval1._1 &&\
    \ interval1._1 <= interval2._2) {\n            var possibleIntersection = if (interval2._2\
    \ < interval1._2) (interval1._1, interval2._2) else (interval1._1, interval1._2)\n\
    \            if (isPrime(possibleIntersection._2 - possibleIntersection._1 + 1))\
    \ return \"YES\"\n        }\n        return \"NO\"", "        // (1, 3) (2, 4)\
    \ => (2, 3)\n        val st = max(interval1._1, interval2._1)\n        val ed\
    \ = min(interval1._2, interval2._2)\n        if (st >= ed) return \"NO\"\n   \
    \     val l = ed - st + 1\n        val primes = Array(1, 2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,\
    \ 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181,\
    \ 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271,\
    \ 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373,\
    \ 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463,\
    \ 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577,\
    \ 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673,\
    \ 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787,\
    \ 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,\
    \ 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009,\
    \ 1013, 1019, 10", "        // intersection = (max(start1, start2), min(end1,\
    \ end2))\n        if (interval1._1 > interval2._2 || interval2._1 > interval1._2)\
    \ return \"NO\"\n        val start = max(interval1._1, interval2._1)\n       \
    \ val end = min(interval1._2, interval2._2)\n        if (end - start < 1) return\
    \ \"NO\"\n        val result = (2 to (end - start).toInt).forall(n => (end - start)\
    \ % n != 0)\n        if (result) \"YES\" else \"NO\"", "        val (start1, end1)\
    \ = interval1\n        val (start2, end2) = interval2\n        val maximum = max(start1,\
    \ start2)\n        val minimum = min(end1, end2)\n        val length = maximum\
    \ - minimum\n        if (length <= 0) return \"NO\"\n        var flag = true\n\
    \        for (i <- 2l to length - 1l) {\n            if (length % i == 0) flag\
    \ = false\n        }\n        if (flag) return \"YES\"\n        else return \"\
    NO\"", "        val (start1, end1) = interval1\n        val (start2, end2) = interval2\n\
    \        if (end1 < start2 || end2 < start1) \"NO\"\n        else {\n        \
    \    val start = max(start1, start2)\n            val end = min(end1, end2)\n\
    \            val length = end - start + 1\n            if (length <= 1) \"NO\"\
    \n            else if (length == 2) \"YES\"\n            else if (length % 2 ==\
    \ 0) \"NO\"\n            else {\n                val sqrt = scala.math.sqrt(length).toLong\n\
    \                for (i <- 2l to sqrt) {\n                    if (length % i ==\
    \ 0) return \"NO\"\n                }\n                \"YES\"\n            }\n\
    \        }", "        // Write your code here.\n        val (l1, h1) = interval1\n\
    \        val (l2, h2) = interval2\n        if (l1 > h2 || l2 > h1) {\n       \
    \     \"NO\"\n        } else {\n            val l = max(l1, l2)\n            val\
    \ h = min(h1, h2)\n            val length = h - l + 1\n            if (isPrime(length))\
    \ {\n                \"YES\"\n            } else {\n                \"NO\"\n \
    \           }\n        }", "        val isPrime = (x : Long) => x > 1 && (2 to\
    \ sqrt(x).toInt).forall(x % _ != 0)\n        def helper(i1s : Long, i1e : Long,\
    \ i2s : Long, i2e : Long) : String = {\n            if (i1s > i1e || i2s > i2e)\
    \ \"NO\"\n            else if (i1s <= i2s && i2s <= i1e && i1e <= i2e) if (isPrime(i1e\
    \ - i2s + 1)) \"YES\" else \"NO\"\n            else if (i2s <= i1s && i1s <= i2e\
    \ && i2e <= i1e) if (isPrime(i2e - i1s + 1)) \"YES\" else \"NO\"\n           \
    \ else if (i1s <= i2s && i2e <= i1e) if (isPrime(i2e - i2s + 1)) \"YES\" else\
    \ \"NO\"\n            else if (i2s <= i1s && i1e <= i2e) if (isPrime(i1e - i1s\
    \ + 1)) \"YES\" else \"NO\"\n            else if (i1s <= i2s && i2s <= i1e &&\
    \ i2e <= i1e) if (isPrime(i2e - i2s + 1)) \"YES\" else \"NO\"\n            else\
    \ if (i2s <= i1s && i1s <= i2e && i1e <= i2e) if (isPrime(i1e - i1s + 1)) \"YES\"\
    \ else \"NO\"\n            else helper(i1s, i1e, i2s + 1, i2e)\n        }\n  \
    \      helper(interval1._1, interval1._2, interval2._1, interval2._2)", "    \
    \    // Find the intersection of the two intervals\n        val (start, end) =\
    \ ((max(interval1._1, interval2._1), min(interval1._2, interval2._2)))\n     \
    \   if (start <= end) {\n            // Check if intersection is prime\n     \
    \       val length = end - start + 1\n            if (isPrime(length)) {\n   \
    \             return \"YES\"\n            }\n        }\n        \"NO\"", "   \
    \     if (interval1._1 > interval2._2 || interval2._1 > interval1._2) return \"\
    NO\"\n        val (left, right) = if (interval1._1 <= interval2._1) (interval2._1,\
    \ min(interval1._2, interval2._2)) else (interval1._1, min(interval1._2, interval2._2))\n\
    \        isPrime(right - left + 1) match {\n            case true => \"YES\"\n\
    \            case false => \"NO\"\n        }", '        ???', "        val i =\
    \ interval1._1 max interval2._1\n        val j = interval1._2 min interval2._2\n\
    \        if (i > j) \"NO\"\n        else if (i == j) \"YES\"\n        else if\
    \ (isPrime(j - i + 1)) \"YES\"\n        else \"NO\"", "        // convert the\
    \ intervals to ranges, then find their intersection,\n        // and then determine\
    \ if the length of the intersection range is a prime number\n        val range1\
    \ = interval1._1 to interval1._2\n        val range2 = interval2._1 to interval2._2\n\
    \        val isectRange = range1.intersect(range2)\n        if (isectRange.length\
    \ == 0) {\n            \"NO\"\n        } else {\n            if (isPrime(isectRange.length))\
    \ \"YES\" else \"NO\"\n        }", "        def intersect(interval1 : Tuple2[Long,\
    \ Long], interval2 : Tuple2[Long, Long]) : Tuple2[Long, Long] = {\n          \
    \  if (interval1._1 <= interval2._1) {\n                if (interval1._2 >= interval2._1)\
    \ {\n                    if (interval1._2 >= interval2._2) {\n               \
    \         return (interval2._1, interval2._2)\n                    } else {\n\
    \                        return (interval2._1, interval1._2)\n               \
    \     }\n                } else {\n                    return null\n         \
    \       }\n            } else {\n                if (interval2._2 >= interval1._1)\
    \ {\n                    if (interval2._2 >= interval1._2) {\n               \
    \         return (interval1._1, interval1._2)\n                    } else {\n\
    \                        return (interval1._1, interval2._2)\n               \
    \     }\n                } else {\n                    return null\n         \
    \       }\n            }\n        }\n        val intersect = intersect(interval1,\
    \ interval2)\n        if (intersect == null) return \"NO\"\n        val len =\
    \ intersect._2 - intersect._1 + 1\n        if (isPrime(len)) return \"YES\"\n\
    \        return \"NO\"", "        if (interval1._1 >= interval2._2 || interval2._1\
    \ >= interval1._2) {\n            \"NO\"\n        } else {\n            val range\
    \ = interval1._1 max interval2._1 to interval1._2 min interval2._2\n         \
    \   if (range.length >= 2) {\n                \"NO\"\n            } else {\n \
    \               if (range.length == 0) {\n                    \"NO\"\n       \
    \         } else {\n                    if (range.last % 2 == 0) {\n         \
    \               \"NO\"\n                    } else {\n                       \
    \ val sqrt = math.sqrt(range.last)\n                        val range = (3 to\
    \ sqrt.toInt by 2).toList\n                        if (range.exists(range.last\
    \ % _ == 0)) {\n                            \"NO\"\n                        }\
    \ else {\n                            \"YES\"\n                        }\n   \
    \                 }\n                }\n            }\n        }", "        var\
    \ start = max(interval1._1, interval2._1)\n        var end = min(interval1._2,\
    \ interval2._2)\n        if (start > end) {\n            return \"NO\"\n     \
    \   }\n        var length = end - start + 1\n        return if (length <= 1) \"\
    NO\" else if (length == 2) \"YES\" else if (length % 2 == 0) \"NO\" else if (length\
    \ % 3 == 0) \"NO\" else \"YES\"", "        val intLen = (abs(interval1._1 - interval2._1)\
    \ + 1) min (abs(interval1._2 - interval2._2) + 1)\n        if (intLen <= 1) return\
    \ \"NO\"\n        val p = new Problem.Prime()\n        return if (p.isPrime(intLen))\
    \ \"YES\" else \"NO\"", "        val (start1, end1) = interval1\n        val (start2,\
    \ end2) = interval2\n        if (max(start1, start2) > min(end1, end2)) return\
    \ \"NO\"\n        val len = min(end1, end2) - max(start1, start2) + 1\n      \
    \  if (len == 2) return \"YES\"\n        for (i <- 2l to sqrt(len).toLong) {\n\
    \            if (len % i == 0) return \"NO\"\n        }\n        \"YES\"", " \
    \       val start = max(interval1._1, interval2._1)\n        val end = min(interval1._2,\
    \ interval2._2)\n        if (start > end) {\n            \"NO\"\n        } else\
    \ {\n            if (isPrime(end - start + 1)) \"YES\" else \"NO\"\n        }",
  "        val (start1, end1) = interval1\n        val (start2, end2) = interval2\n\
    \        val start = max(start1, start2)\n        val end = min(end1, end2)\n\
    \        if (start >= end) {\n            \"NO\"\n        } else {\n         \
    \   if (end - start == 1) {\n                \"YES\"\n            } else {\n \
    \               if (prime(end - start) == 1) {\n                    \"YES\"\n\
    \                } else {\n                    \"NO\"\n                }\n   \
    \         }\n        }", "        var a = max(interval1._1, interval2._1)\n  \
    \      var b = min(interval1._2, interval2._2)\n        if (a > b) return \"NO\"\
    \n        val c = b - a + 1\n        if (c < 2) return \"NO\"\n        for (i\
    \ <- 2 to sqrt(c).toInt) {\n            if (c % i == 0) return \"NO\"\n      \
    \  }\n        \"YES\"", "        val (start1, end1) = interval1\n        val (start2,\
    \ end2) = interval2\n        val start = if (start1 > start2) start1 else start2\n\
    \        val end = if (end1 < end2) end1 else end2\n        if (start >= end)\
    \ return \"NO\"\n        val diff = end - start\n        return (2 to sqrt(diff).toInt).forall(x\
    \ => diff % x != 0) match {\n            case true => \"YES\"\n            case\
    \ false => \"NO\"\n        }", "        val a = interval1._1\n        val b =\
    \ interval1._2\n        val c = interval2._1\n        val d = interval2._2\n \
    \       val e = max(a, c)\n        val f = min(b, d)\n        if (e > f) \"NO\"\
    \n        else if (f - e == 1) \"YES\"\n        else {\n            val primes\
    \ = Set(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l,\
    \ 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l,\
    \ 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l,\
    \ 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l,\
    \ 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l,\
    \ 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l,\
    \ 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l,\
    \ 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 593l,\
    \ 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l,\
    \ 673l, 677l, 683l, 691l, 701l, 7", "      // Let's assume that both intervals\
    \ are ordered\n      // If the intersection length is 1, it should be NO\n   \
    \   // if the intersection length is 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101\n\
    \      // it should be YES\n      // Otherwise, it should be NO\n      // Let's\
    \ assume that the intersection is non empty\n      if (interval1._1 > interval1._2)\
    \ {\n        intersection((interval1._2, interval1._1), interval2)\n      } else\
    \ if (interval2._1 > interval2._2) {\n        intersection(interval1, (interval2._2,\
    \ interval2._1))\n      } else {\n        val arr = ArrayBuffer(1l,2l,3l,5l,7l,11l,13l,17l,19l,23l,29l,31l,37l,41l,43l,47l,53l,59l,61l,67l,71l,73l,79l,83l,89l,97l,101l)\n\
    \        val smallerEnd = min(interval1._2, interval2._2)\n        val greaterStart\
    \ = max(interval1._1, interval2._1)\n        val intersectLength = smallerEnd\
    \ - greaterStart + 1\n        if (arr.contains(intersectLength)) {\n         \
    \ \"YES\"\n        } else {\n          \"NO\"\n        }\n      }", "        if\
    \ (interval1._1 > interval2._2 || interval2._1 > interval1._2) \"NO\"\n      \
    \  else {\n            val intersection = (max(interval1._1, interval2._1), min(interval1._2,\
    \ interval2._2))\n            if (intersection._1 > intersection._2) \"NO\"\n\
    \            else if (intersection._1 == intersection._2) \"YES\"\n          \
    \  else {\n                var isPrime = true\n                for (i <- 2l to\
    \ intersection._2) {\n                    if (i >= intersection._1 && i < intersection._2\
    \ && intersection._2 % i == 0) {\n                        isPrime = false\n  \
    \                      i = intersection._2\n                    }\n          \
    \      }\n                if (isPrime) \"YES\" else \"NO\"\n            }\n  \
    \      }", "    \tvar intersection = 0l\n    \tif (interval1._1 <= interval2._1\
    \ && interval1._2 >= interval2._1) {\n    \t\tintersection = interval1._2 - interval2._1\n\
    \    \t} else if (interval2._1 <= interval1._1 && interval2._2 >= interval1._1)\
    \ {\n    \t\tintersection = interval2._2 - interval1._1\n    \t}\n    \tif (intersection\
    \ == 0) {\n    \t\treturn \"NO\"\n    \t}\n    \tvar isPrime = true\n    \tfor\
    \ (i <- 2l to intersection/2) {\n    \t\tif (intersection % i == 0) {\n    \t\t\
    \tisPrime = false\n    \t\t}\n    \t}\n    \tif (isPrime) {\n    \t\treturn \"\
    YES\"\n    \t} else {\n    \t\treturn \"NO\"\n    \t}", "        val (x1, y1)\
    \ = interval1\n        val (x2, y2) = interval2\n        val (left, right) = (max(x1,\
    \ x2), min(y1, y2))\n        val length = if (left > right) 0 else right - left\
    \ + 1\n        if (length == 1) \"NO\"\n        else if (length == 0) \"NO\"\n\
    \        else if (length == 2) \"YES\"\n        else {\n            val ns = List.range(2,\
    \ length.toInt)\n            if (ns.exists(x => length % x == 0)) \"NO\"\n   \
    \         else \"YES\"\n        }", "        var (start1, end1) = interval1\n\
    \        var (start2, end2) = interval2\n        if (end1 < start2 || end2 < start1)\
    \ {\n            return \"NO\"\n        }\n        var start = max(start1, start2)\n\
    \        var end = min(end1, end2)\n        if (start <= end) {\n            var\
    \ length = end - start + 1\n            val primes = List(2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\
    \ 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179,\
    \ 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269,\
    \ 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367,\
    \ 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461,\
    \ 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571,\
    \ 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661,\
    \ 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773,\
    \ 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883,\
    \ 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 9", "        val\
    \ a = if (interval1._1 <= interval2._1) interval2._1 else interval1._1\n     \
    \   val b = if (interval1._2 <= interval2._2) interval1._2 else interval2._2\n\
    \        return if (a <= b) (if (isPrime(b - a + 1)) \"YES\" else \"NO\") else\
    \ \"NO\"", "        var start = 0l\n        var end = 0l\n        if (interval1._1\
    \ < interval2._1) {\n            start = interval2._1\n        } else {\n    \
    \        start = interval1._1\n        }\n        if (interval1._2 < interval2._2)\
    \ {\n            end = interval1._2\n        } else {\n            end = interval2._2\n\
    \        }\n        if (start > end) {\n            return \"NO\"\n        }\n\
    \        if (isPrime(end - start + 1)) {\n            return \"YES\"\n       \
    \ } else {\n            return \"NO\"\n        }", "        val (start1, end1)\
    \ = interval1\n        val (start2, end2) = interval2\n        val (start, end)\
    \ = (max(start1, start2), min(end1, end2))\n        if (start <= end) {\n    \
    \        if (prime((end - start + 1).toInt)) {\n                \"YES\"\n    \
    \        } else {\n                \"NO\"\n            }\n        } else {\n \
    \           \"NO\"\n        }", "        val lowerLimit = max(interval1._1, interval2._1)\n\
    \        val upperLimit = min(interval1._2, interval2._2)\n        val dist =\
    \ upperLimit - lowerLimit\n        if (dist < 0) {\n            \"NO\"\n     \
    \   } else {\n            if (dist == 0) {\n                \"YES\"\n        \
    \    } else {\n                if (dist == 1) {\n                    \"NO\"\n\
    \                } else {\n                    val factors = ArrayBuffer[Long]()\n\
    \                    for (i <- 2 to dist.toInt) {\n                        if\
    \ (dist % i == 0) {\n                            factors += i\n              \
    \          }\n                    }\n                    if (factors.length ==\
    \ 0) {\n                        \"YES\"\n                    } else {\n      \
    \                  \"NO\"\n                    }\n                }\n        \
    \    }\n        }", "        val (start1, end1) = interval1\n        val (start2,\
    \ end2) = interval2\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start > end) return \"NO\"\n        return if\
    \ (isPrime(end - start + 1)) \"YES\" else \"NO\"", "        if (interval1._1 >\
    \ interval2._2 || interval2._1 > interval1._2) {\n            \"NO\"\n       \
    \ } else {\n            def isPrime(n : Long) : Boolean = {\n                if\
    \ (n < 2) {\n                    false\n                } else {\n           \
    \         val s = math.sqrt(n).toLong\n                    (2L to s).forall(x\
    \ => n % x != 0)\n                }\n            }\n            val a = max(interval1._1,\
    \ interval2._1)\n            val b = min(interval1._2, interval2._2)\n       \
    \     if (isPrime(b - a + 1)) {\n                \"YES\"\n            } else {\n\
    \                \"NO\"\n            }\n        }", "        val (i1s, i1e) =\
    \ interval1\n        val (i2s, i2e) = interval2\n        val is = if (i1s > i2s)\
    \ i1s else i2s\n        val ie = if (i1e < i2e) i1e else i2e\n        if (is >\
    \ ie) \"NO\"\n        else {\n            val isLessThanIE = is <= ie\n      \
    \      val intervalLength = if (isLessThanIE) ie - is + 1 else 0\n           \
    \ if (isLessThanIE && intervalLength != 1 && intervalLength != 2 && intervalLength\
    \ != 3 && intervalLength != 5 && intervalLength != 7) \"NO\"\n            else\
    \ \"YES\"\n        }", "        // this function will check if the start of interval2\
    \ is inside interval1\n        // and the end of interval2 is inside interval1.\n\
    \        // it's a little bit weired to do it this way, but it is to avoid checking\n\
    \        // if the start or end is inside or outside the interval\n        def\
    \ isInside(start1 : Long, end1 : Long, start2 : Long, end2 : Long) : Boolean =\
    \ {\n            if (start2 >= start1 && start2 <= end1 && end2 >= start1 && end2\
    \ <= end1) {\n                true\n            } else {\n                false\n\
    \            }\n        }\n        // this function will check if the start of\
    \ interval2 is outside interval1\n        // and the end of interval2 is inside\
    \ interval1.\n        def isLeft(start1 : Long, end1 : Long, start2 : Long, end2\
    \ : Long) : Boolean = {\n            if (start2 <= start1 && end2 >= start1 &&\
    \ end2 <= end1) {\n                true\n            } else {\n              \
    \  false\n            }\n        }\n        // this function will check if the\
    \ start of interval2 is inside interval1\n        // and the end of interval2\
    \ is outside interval1.\n        def isRight(start1 : Long, end1 : Long, start2\
    \ : Long, end2 : Long) : Boolean = {\n            if (start2 >= start1 && start2\
    \ <= end1 && end2 >= end1) {\n                true\n            } else {\n   \
    \             false\n            }\n        }\n        // this function will check\
    \ if the start of interval2 is outside interval1\n        // and the end of interval2\
    \ is outside interval1.\n        def isOutside(start1 : Long, end1 : Long, start2\
    \ : Long, end2 : Long) : Boolean = {\n            if (start2 <= start1 && end2\
    \ <= start1) {\n                true\n            } else if (start2 >= end1 &&\
    \ end2 >= end1) {\n                true\n            } else {\n              \
    \  false\n            }\n        }\n        // this function will calculate the\
    \ length of intersection\n        def calcIntersection(start1 : Long, end1 : Long,\
    \ start2 : Long, end2 : Long) : Long = {\n            if (isInside(start", " \
    \       if (interval1._1 > interval2._2 || interval2._1 > interval1._2) \"NO\"\
    \n        else {\n            val upperBound = min(interval1._2, interval2._2)\n\
    \            val lowerBound = max(interval1._1, interval2._1)\n            val\
    \ result = (upperBound - lowerBound + 1).toLong\n            if (BigInt(result).isProbablePrime(10000))\
    \ \"YES\"\n            else \"NO\"\n        }", "        val tuple = {\n     \
    \       val min = max(interval1._1, interval2._1)\n            val max = min(interval1._2,\
    \ interval2._2)\n            if (min <= max) (min, max) else (max, min)\n    \
    \    }\n        if (tuple._1 > tuple._2) \"NO\"\n        else if (isPrime(tuple._2\
    \ - tuple._1 + 1)) \"YES\"\n        else \"NO\"", "        if (interval1._1 >\
    \ interval2._2 || interval2._1 > interval1._2) return \"NO\"\n        val start\
    \ = min(interval1._1, interval2._1)\n        val end = max(interval1._2, interval2._2)\n\
    \        val m = max(interval1._1, interval2._1)\n        val n = min(interval1._2,\
    \ interval2._2)\n        if (m == n) {\n            if (m == start) return \"\
    NO\"\n            return isPrime(m - start + n - m + 1)\n        }\n        return\
    \ isPrime(n - m + 1)", "    \tval (l1, r1) = interval1\n    \tval (l2, r2) = interval2\n\
    \    \tif(l1 > r1 || l2 > r2) return \"NO\"\n    \tval l = max(l1, l2)\n    \t\
    val r = min(r1, r2)\n    \treturn if(l > r) \"NO\" else if(isPrime(r - l + 1))\
    \ \"YES\" else \"NO\"", "        val (start1, end1) = interval1\n        val (start2,\
    \ end2) = interval2\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start > end) \"NO\"\n        else {\n       \
    \     val interval = (start, end)\n            val length = interval._2 - interval._1\
    \ + 1\n            if (length > 1 && isPrime(length)) \"YES\"\n            else\
    \ \"NO\"\n        }", "        val length = if (interval1._1 > interval2._1) (interval1._1,\
    \ interval2._2) else (interval2._1, interval1._2)\n        if (length._1 <= length._2)\
    \ if (List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l,\
    \ 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l,\
    \ 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l,\
    \ 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l,\
    \ 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l,\
    \ 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l,\
    \ 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l,\
    \ 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 593l,\
    \ 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l,\
    \ 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l,\
    \ 761l, 7", "        val (start1, end1) = interval1\n        val (start2, end2)\
    \ = interval2\n        val intersect = if (start1 > start2) start1 else start2\n\
    \        val end = if (end1 < end2) end1 else end2\n        if (intersect > end)\
    \ {\n            \"NO\"\n        } else {\n            val len = abs(end - intersect)\
    \ + 1\n            if (BigInt(len).isProbablePrime(3)) \"YES\" else \"NO\"\n \
    \       }", "    \tvar start = max(interval1._1, interval2._1)\n    \tvar end\
    \ = min(interval1._2, interval2._2)\n    \tif (start > end) return \"NO\"\n  \
    \  \tvar len = end - start + 1\n    \tif (len <= 0) return \"NO\"\n    \tif (len\
    \ < 3) return \"YES\"\n    \tvar isPrime = true\n    \tfor (i <- 2 to (sqrt(len)\
    \ + 1).toInt) {\n    \t\tif (len % i == 0) {\n    \t\t\tisPrime = false\n    \t\
    \t\tbreak\n    \t\t}\n    \t}\n    \tif (isPrime) \"YES\" else \"NO\"", "    \
    \    val a = max(interval1._1, interval2._1)\n        val b = min(interval1._2,\
    \ interval2._2)\n        if (a > b) return \"NO\"\n        val x = b - a + 1\n\
    \        if (x < 2) return \"NO\"\n        val primes = (2l :: Nil) ++ (3l to\
    \ x by 2).filter { j => !(2l to (sqrt(j).toLong)).exists { i => j % i == 0 } }\n\
    \        primes.contains(x) match {\n            case true => \"YES\"\n      \
    \      case false => \"NO\"\n        }", "        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start <= end) {\n            val\
    \ len = end - start + 1\n            if (len == 2 || len % 2 == 1) \"YES\" else\
    \ \"NO\"\n        } else \"NO\"", "        val (a, b) = interval1\n        val\
    \ (c, d) = interval2\n        val start = if (a > c) a else c\n        val end\
    \ = if (b < d) b else d\n        if (start > end) \"NO\"\n        else if (isPrime(end\
    \ - start + 1)) \"YES\"\n        else \"NO\"", "        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else {\n\
    \            val range = start until end + 1\n            val primes = SieveOfEratosthenes(range.size)\n\
    \            val primeSet = new HashSet[Int]()\n            for (i <- 0 until\
    \ primes.size) primeSet += primes(i)\n            if (primeSet.contains(range.size))\
    \ \"YES\"\n            else \"NO\"\n        }", "        val a = interval1._1\n\
    \        val b = interval1._2\n        val c = interval2._1\n        val d = interval2._2\n\
    \        if (a > b || c > d) {\n            \"The intervals are incorrect.\"\n\
    \        } else if (b < c || d < a) {\n            \"NO\"\n        } else {\n\
    \            val p = ListBuffer[Long]()\n            for (i <- a to b; j <- c\
    \ to d) if (i == j) p += i\n            val length = p.length\n            def\
    \ isPrime(i : Int) : Boolean = {\n                if (i < 2) false\n         \
    \       else if (i == 2) true\n                else !(2 to (sqrt(i) + 1).toInt).exists(x\
    \ => i % x == 0)\n            }\n            if (isPrime(length)) \"YES\"\n  \
    \          else \"NO\"\n        }", "        val (min, max) = (interval1._1 min\
    \ interval2._1, interval1._2 max interval2._2)\n        (min to max).toSet.intersect((interval1._1\
    \ to interval1._2).toSet).intersect((interval2._1 to interval2._2).toSet).size\
    \ match {\n            case 0 => \"NO\"\n            case 1 => \"YES\"\n     \
    \       case x => if (isPrime(x)) \"YES\" else \"NO\"\n        }", "        if\
    \ (interval1._1 > interval2._2 || interval2._1 > interval1._2) return \"NO\"\n\
    \        val max = max(interval1._1, interval2._1)\n        val min = min(interval1._2,\
    \ interval2._2)\n        if (min - max <= 0) return \"NO\"\n        val fct =\
    \ (1 to min.toInt).filter(x => min % x == 0).toList\n        if (fct.length ==\
    \ 2) return \"YES\"\n        \"NO\"", "        val start = max(interval1._1, interval2._1)\n\
    \        val end = min(interval1._2, interval2._2)\n        if (start >= end)\
    \ return \"NO\"\n        val len = end - start + 1\n        if (len <= 1) return\
    \ \"NO\"\n        var i = 2l\n        while (i * i <= len) {\n            if (len\
    \ % i == 0) return \"NO\"\n            i += 1\n        }\n        \"YES\"", " \
    \       val (i1, i2) = (interval1, interval2)\n        if (i1._1 > i2._2 || i2._1\
    \ > i1._2) return \"NO\"\n        return if (prime((max(i1._1, i2._1) - min(i1._2,\
    \ i2._2)).abs + 1)) \"YES\" else \"NO\"", "      if (interval1._1 <= interval2._1\
    \ && interval2._1 <= interval1._2) {\n        //interval1 overlaps with interval2\
    \ from the start\n        if (interval1._2 <= interval2._2) {\n          if (interval1._2\
    \ - interval2._1 == 1) {\n            return \"YES\"\n          }\n          else\
    \ if (interval1._2 - interval2._1 <= 2) {\n            return \"NO\"\n       \
    \   }\n          else {\n            val numbers = interval1._2 - interval2._1\n\
    \            var i = 2\n            while (i < numbers) {\n              if (numbers\
    \ % i == 0) {\n                return \"NO\"\n              }\n              i\
    \ += 1\n            }\n            return \"YES\"\n          }\n        }\n  \
    \      else {\n          if (interval2._2 - interval2._1 == 1) {\n           \
    \ return \"YES\"\n          }\n          else if (interval2._2 - interval2._1\
    \ <= 2) {\n            return \"NO\"\n          }\n          else {\n        \
    \    val numbers = interval2._2 - interval2._1\n            var i = 2\n      \
    \      while (i < numbers) {\n              if (numbers % i == 0) {\n        \
    \        return \"NO\"\n              }\n              i += 1\n            }\n\
    \            return \"YES\"\n          }\n        }\n      }\n      else if (interval2._1\
    \ <= interval1._1 && interval1._1 <= interval2._2) {\n        //interval2 overlaps\
    \ with interval1 from the start\n        if (interval2._2 <= interval1._2) {\n\
    \          if (interval2._2 - interval1._1 == 1) {\n            return \"YES\"\
    \n          }\n          else if (interval2._2 - interval1._1 <= 2) {\n      \
    \      return \"NO\"\n          }\n          else {\n            val numbers =\
    \ interval2._2 - interval1._1\n            var i = 2\n            while (i < numbers)\
    \ {\n              if (numbers % i == 0) {\n                return \"NO\"\n  \
    \            }\n              i += 1\n            }\n            return \"YES\"\
    \n          }\n        }\n        else {\n", "        // return \"NO\"\n     \
    \   // var isIntersect = false\n        val start = max(interval1._1, interval2._1)\n\
    \        val end = min(interval1._2, interval2._2)\n        if (start <= end)\
    \ {\n            if (isPrime(end - start + 1)) \"YES\" else \"NO\"\n        }\
    \ else \"NO\"", "        // >>> interval1 = (1, 2)\n        // >>> interval2 =\
    \ (2, 3)\n        // >>> print interval1, interval2\n        // (1, 2) (2, 3)\n\
    \        // >>> interval1 = (-3, -1)\n        // >>> interval2 = (-5, 5)\n   \
    \     // >>> print interval1, interval2\n        // (-3, -1) (-5, 5)\n       \
    \ // >>> intersection(interval1, interval2)\n        // 'YES'\n        // >>>\
    \ interval1 = (0, 10)\n        // >>> interval2 = (15, 20)\n        // >>> print\
    \ interval1, interval2\n        // (0, 10) (15, 20)\n        // >>> intersection(interval1,\
    \ interval2)\n        // 'NO'\n        // >>> interval1 = (1, 4)\n        // >>>\
    \ interval2 = (3, 4)\n        // >>> print interval1, interval2\n        // (1,\
    \ 4) (3, 4)\n        // >>> intersection(interval1, interval2)\n        // 'YES'\n\
    \        // >>> interval1 = (1, 3)\n        // >>> interval2 = (2, 4)\n      \
    \  // >>> print interval1, interval2\n        // (1, 3) (2, 4)\n        // >>>\
    \ intersection(interval1, interval2)\n        // 'NO'\n        // >>> interval1\
    \ = (0, 100000)\n        // >>> interval2 = (100000, 200000)\n        // >>> print\
    \ interval1, interval2\n        // (0, 100000) (100000, 200000)\n        // >>>\
    \ intersection(interval1, interval2)\n        // 'NO'\n        if (interval1._1\
    \ >= interval2._2 || interval2._1 >= interval1._2) {\n            return \"NO\"\
    \n        }\n        var start = interval1._1.max(interval2._1)\n        var end\
    \ = interval1._2.min(interval2._2)\n        if (start > end) {\n            return\
    \ \"NO\"\n        }\n        var length = end - start + 1\n        if (length\
    \ > 100000) {\n            return \"NO\"\n        }\n        var prime = true\n\
    \        for", "        val start = max(interval1._1, interval2._1)\n        val\
    \ end = min(interval1._2, interval2._2)\n        if (start > end) return \"NO\"\
    \n        if (isPrime(end - start + 1)) return \"YES\"\n        \"NO\"", "   \
    \     // calculate intersection using a simple boolean comparison and then \n\
    \        // check if its a prime number or not.\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start <= end) {\n            if (Stream.range(2, (end - start + 1).toInt).forall(x\
    \ => (end - start + 1) % x != 0)) {\n                \"YES\"\n            } else\
    \ {\n                \"NO\"\n            }\n        } else {\n            \"NO\"\
    \n        }", "        val sorted = List(interval1, interval2).sortWith((p1, p2)\
    \ => p1._1 < p2._1)\n        val inter = sorted(0)._2 - sorted(1)._1\n       \
    \ if (inter <= 0) \"NO\"\n        else if (inter == 1) \"YES\"\n        else if\
    \ (inter % 2 == 0) \"NO\"\n        else {\n            val sqrt = sqrt(inter)\n\
    \            val fl = floor(sqrt)\n            val f = fl.toLong\n           \
    \ if (sqrt != f) \"YES\"\n            else \"NO\"\n        }", "        val small\
    \ = interval1._1 max interval2._1\n        val big = interval1._2 min interval2._2\n\
    \        if (small <= big) isPrime(big - small + 1) else \"NO\"", "        val\
    \ (lower, upper) = (max(interval1._1, interval2._1), min(interval1._2, interval2._2))\n\
    \        if (lower > upper) \"NO\"\n        else if (lower == upper) if (isPrime(lower))\
    \ \"YES\" else \"NO\"\n        else if (isPrime(upper - lower + 1)) \"YES\" else\
    \ \"NO\"", "        var start = max(interval1._1, interval2._1)\n        var end\
    \ = min(interval1._2, interval2._2)\n        if (start > end) {\n            return\
    \ \"NO\"\n        }\n        var length = end - start + 1\n        for (i <- 2\
    \ to Math.sqrt(length).toInt) {\n            if (length % i == 0) {\n        \
    \        return \"NO\"\n            }\n        }\n        return \"YES\"", " \
    \       val (start1, end1) = interval1\n        val (start2, end2) = interval2\n\
    \        val intersectStart = max(start1, start2)\n        val intersectEnd =\
    \ min(end1, end2)\n        if (intersectStart > intersectEnd) \"NO\"\n       \
    \ else if (isPrime(intersectEnd - intersectStart + 1)) \"YES\"\n        else \"\
    NO\"", "        val a = interval1._1\n        val b = interval1._2\n        val\
    \ c = interval2._1\n        val d = interval2._2\n        if (d < a || b < c)\
    \ \"NO\"\n        else if (d == a || b == c) \"YES\"\n        else if (d - a <=\
    \ 1 || b - c <= 1) \"NO\"\n        else {\n            val max = min(b, d)\n \
    \           val min = max(a, c)\n            val len = max - min\n           \
    \ var isprime = true\n            for (i <- 2 to sqrt(len).toInt if isprime) {\n\
    \                if (len % i == 0) isprime = false\n            }\n          \
    \  if (isprime) \"YES\" else \"NO\"\n        }", "        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start >= end) \"NO\"\n        else {\n            val length = end - start\
    \ + 1\n            isPrime(length) match {\n                case true => \"YES\"\
    \n                case false => \"NO\"\n            }\n        }", "        if\
    \ (interval1._1 <= interval2._1 && interval2._1 <= interval1._2) {\n         \
    \   if (interval1._2 <= interval2._2) {\n                val l = interval1._2\
    \ - interval2._1 + 1\n                if (isPrime(l)) {\n                    \"\
    YES\"\n                } else {\n                    \"NO\"\n                }\n\
    \            } else {\n                val l = interval2._2 - interval2._1 + 1\n\
    \                if (isPrime(l)) {\n                    \"YES\"\n            \
    \    } else {\n                    \"NO\"\n                }\n            }\n\
    \        } else if (interval2._1 <= interval1._1 && interval1._1 <= interval2._2)\
    \ {\n            if (interval2._2 <= interval1._2) {\n                val l =\
    \ interval2._2 - interval1._1 + 1\n                if (isPrime(l)) {\n       \
    \             \"YES\"\n                } else {\n                    \"NO\"\n\
    \                }\n            } else {\n                val l = interval1._2\
    \ - interval1._1 + 1\n                if (isPrime(l)) {\n                    \"\
    YES\"\n                } else {\n                    \"NO\"\n                }\n\
    \            }\n        } else {\n            \"NO\"\n        }", "    \tval start\
    \ = max(interval1._1, interval2._1)\n    \tval end = min(interval1._2, interval2._2)\n\
    \    \tif (start <= end) isPrime(end - start + 1) else \"NO\"", "        val start\
    \ = max(interval1._1, interval2._1)\n        val end = min(interval1._2, interval2._2)\n\
    \        if (start >= end) return \"NO\"\n        else if (start == end) return\
    \ \"YES\"\n        var i = start\n        while (i <= end) {\n            if (i\
    \ * i > end) return \"YES\"\n            if (end % i == 0) return \"NO\"\n   \
    \         i += 1\n        }\n        \"YES\"", "        val interval = interval1.max(interval2)\
    \ - interval1.min(interval2)\n        if (interval == 1) \"NO\"\n        else\
    \ if (interval == 0) \"NO\"\n        else if (interval == 2) \"YES\"\n       \
    \ else if (interval == 3) \"YES\"\n        else if (interval % 2 == 0) \"NO\"\n\
    \        else if (interval % 3 == 0) \"NO\"\n        else {\n            var i\
    \ = 5;\n            while (i*i <= interval) {\n                if (interval %\
    \ i == 0) {\n                    return \"NO\"\n                }\n          \
    \      i += 2\n            }\n            \"YES\"\n        }", "        var int1\
    \ : List[Long] = Nil\n        var int2 : List[Long] = Nil\n        for (i <- interval1._1\
    \ to interval1._2) {\n            int1 = i :: int1\n        }\n        for (i\
    \ <- interval2._1 to interval2._2) {\n            int2 = i :: int2\n        }\n\
    \        int1 = int1.intersect(int2)\n        val result = int1.length match {\n\
    \            case x if x <= 2 => \"NO\"\n            case _ => if (int1.filter(n\
    \ => n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n % 7 == 0).length == 0) \"YES\"\
    \ else \"NO\"\n        }\n        result", "        def isprime(n : Long) : Boolean\
    \ = {\n            if (n == 2) {\n                return true\n            }\n\
    \            for (i <- 2l to floor(sqrt(n)).toLong) {\n                if (n %\
    \ i == 0) {\n                    return false\n                }\n           \
    \ }\n            return true\n        }\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            return \"NO\"\n        }\n        val length =\
    \ end - start + 1\n        if (isprime(length)) {\n            return \"YES\"\n\
    \        }\n        return \"NO\"", "        // Write your code here\n       \
    \ var i1 = interval1._1\n        var i2 = interval1._2\n        var j1 = interval2._1\n\
    \        var j2 = interval2._2\n        var maxStart = max(i1, j1)\n        var\
    \ minEnd = min(i2, j2)\n        if (maxStart > minEnd) return \"NO\"\n       \
    \ return if (isPrime(minEnd - maxStart + 1)) \"YES\" else \"NO\"", "        val\
    \ a = interval1._1\n        val b = interval1._2\n        val c = interval2._1\n\
    \        val d = interval2._2\n        if (a > b || c > d) {\n            return\
    \ \"NO\"\n        }\n        val x = abs(max(a, c) - min(b, d)) + 1l\n       \
    \ if (x == 1l) {\n            return \"NO\"\n        }\n        for (n <- 2l to\
    \ sqrt(x).toLong) {\n            if (x % n == 0l) {\n                return \"\
    NO\"\n            }\n        }\n        return \"YES\"", "        val left = max(interval1._1,\
    \ interval2._1)\n        val right = min(interval1._2, interval2._2)\n       \
    \ if (left > right) return \"NO\"\n        val length = right - left + 1\n   \
    \     if (length == 1) return \"NO\"\n        val primes = ArrayBuffer[Long]()\n\
    \        for (i <- 2l to length) {\n            var flag = true\n            for\
    \ (prime <- primes) {\n                if (i % prime == 0) {\n               \
    \     flag = false\n                    break\n                }\n           \
    \ }\n            if (flag) primes += i\n        }\n        if (primes.contains(length))\
    \ \"YES\" else \"NO\"", "      def isPrime(x : Long) : Boolean = {\n        if\
    \ (x <= 1) false\n        else if (x == 2) true\n        else !(2l to sqrt(x).toLong).exists(x\
    \ % _ == 0)\n      }\n      val (start1, end1) = interval1\n      val (start2,\
    \ end2) = interval2\n      if (end1 < start2 || end2 < start1) \"NO\"\n      else\
    \ if (isPrime(min(end1, end2) - max(start1, start2) + 1)) \"YES\"\n      else\
    \ \"NO\"", "        val from1 = interval1._1\n        val to1 = interval1._2\n\
    \        val from2 = interval2._1\n        val to2 = interval2._2\n        val\
    \ len1 = to1 - from1\n        val len2 = to2 - from2\n        // If the two intervals\
    \ don't intersect\n        if (from1 > to2 || from2 > to1) {\n            return\
    \ \"NO\"\n        }\n        val intersection = (max(from1, from2), min(to1, to2))\n\
    \        val len = intersection._2 - intersection._1\n        if (len < 2) {\n\
    \            return \"NO\"\n        }\n        (2 to len / 2).filter(len % _ ==\
    \ 0).isEmpty match {\n            case true => \"YES\"\n            case false\
    \ => \"NO\"\n        }", "        val start = max(interval1._1, interval2._1)\n\
    \        val end = min(interval1._2, interval2._2)\n        if (start > end) return\
    \ \"NO\"\n        return isPrime(end - start)", "        var start = max(interval1._1,\
    \ interval2._1)\n        var end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        var len = end - start + 1\n        if (len\
    \ == 1) return \"NO\"\n        var i = 2\n        while (i * i <= len) {\n   \
    \         if (len % i == 0) return \"NO\"\n            i += 1\n        }\n   \
    \     return \"YES\"", "        val intersection = Tuple2(max(interval1._1, interval2._1),\
    \ min(interval1._2, interval2._2))\n        if (intersection._1 > intersection._2)\
    \ return \"NO\"\n        isPrime(intersection._2 - intersection._1 + 1) match\
    \ {\n            case true => \"YES\"\n            case false => \"NO\"\n    \
    \    }", "        var candidate = interval1._1 max interval2._1 to interval1._2\
    \ min interval2._2\n        if (candidate._1 <= candidate._2) {\n            if\
    \ (isPrime(candidate._2 - candidate._1 + 1)) \"YES\" else \"NO\"\n        } else\
    \ \"NO\"", "    \tval primes = List(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113,\
    \ 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\
    \ 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,\
    \ 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\
    \ 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491,\
    \ 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601,\
    \ 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\
    \ 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821,\
    \ 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929,\
    \ 937, 941, 947, 953, 967, 971, 977, 983, 991, 997)\n        if (interval1._1\
    \ > interval1._2 || interval2._1 > interval2._2) {\n            throw new IllegalArgumentException(\"\
    Invalid interval\")\n        }\n        if (interval1._1 > interval2._2 || interval2._1\
    \ > interval1._2) {\n            return \"NO\"\n        }\n        val start =\
    \ max(interval1._1", "        def isPrime(n : Long) : Boolean = {\n          \
    \  if (n <= 1) return false\n            if (n == 2) return true\n           \
    \ if (n % 2 == 0) return false\n            for (i <- 3l to sqrt(n).toLong by\
    \ 2) {\n                if (n % i == 0) return false\n            }\n        \
    \    return true\n        }\n        var start = max(interval1._1, interval2._1)\n\
    \        var end = min(interval1._2, interval2._2)\n        if (start > end) return\
    \ \"NO\"\n        if (isPrime(end - start + 1)) return \"YES\"\n        return\
    \ \"NO\"", "        if (interval1._1 > interval2._2 || interval2._1 > interval1._2)\
    \ \"NO\"\n        else {\n            val start = max(interval1._1, interval2._1)\n\
    \            val end = min(interval1._2, interval2._2)\n            if (start\
    \ >= end) \"NO\"\n            else if (BigInt(end - start).isProbablePrime(100))\
    \ \"YES\"\n            else \"NO\"\n        }", "        def intersectionLength(interval1\
    \ : Tuple2[Long, Long], interval2 : Tuple2[Long, Long]) : Long = {\n         \
    \   val start : Long = max(interval1._1, interval2._1)\n            val end :\
    \ Long = min(interval1._2, interval2._2)\n            if (start <= end) {\n  \
    \              end - start + 1\n            } else {\n                0\n    \
    \        }\n        }\n        val n : Long = intersectionLength(interval1, interval2)\n\
    \        if (n == 0) {\n            \"NO\"\n        } else {\n            if (isPrime(n))\
    \ {\n                \"YES\"\n            } else {\n                \"NO\"\n \
    \           }\n        }", "      // Write your code here\n      val isect = (min(interval1._2,\
    \ interval2._2) - max(interval1._1, interval2._1) + 1).toInt\n      if (isect\
    \ <= 0) \"NO\"\n      else if (isPrime(isect)) \"YES\"\n      else \"NO\"", " \
    \       val start = max(interval1._1, interval2._1)\n        val end = min(interval1._2,\
    \ interval2._2)\n        if (start > end) return \"NO\"\n        isPrime(end -\
    \ start + 1) match {\n            case true => \"YES\"\n            case false\
    \ => \"NO\"\n        }", "        val (start1, end1) = interval1\n        val\
    \ (start2, end2) = interval2\n        val start = max(start1, start2)\n      \
    \  val end = min(end1, end2)\n        if (start > end) {\n            \"NO\"\n\
    \        } else {\n            val length = end - start + 1\n            if (length\
    \ == 2) {\n                \"YES\"\n            } else {\n                for\
    \ (i <- 2 until length if length % i == 0) {\n                    return \"NO\"\
    \n                }\n                \"YES\"\n            }\n        }", "   \
    \     val (left, right) = (List(interval1._1, interval2._1).max, List(interval1._2,\
    \ interval2._2).min)\n        if (left <= right) {\n            if (isPrime(right\
    \ - left + 1)) {\n                \"YES\"\n            } else {\n            \
    \    \"NO\"\n            }\n        } else {\n            \"NO\"\n        }",
  "        val start = max(interval1._1, interval2._1)\n        val end = min(interval1._2,\
    \ interval2._2)\n        if (start > end) {\n            \"NO\"\n        } else\
    \ {\n            val len = end - start + 1\n            val isPrime = scala.collection.mutable.ArrayBuffer[Boolean](true)\n\
    \            for (i <- 2l to len) {\n                isPrime += (isPrime(i.toInt\
    \ - 2) && len % i != 0)\n            }\n            if (isPrime(len.toInt - 2))\
    \ {\n                \"YES\"\n            } else {\n                \"NO\"\n \
    \           }\n        }", "        val intersection = interval1._1 max interval2._1\
    \ to interval1._2 min interval2._2\n        val length = intersection.length\n\
    \        if (length == 0) {\n            \"NO\"\n        } else {\n          \
    \  if (length > 1 && length.toInt % 2 == 0) \"NO\" else \"YES\"\n        }"]
stop_tokens:
- "\n    }\n"
