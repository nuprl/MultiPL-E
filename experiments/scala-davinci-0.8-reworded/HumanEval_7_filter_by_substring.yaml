name: HumanEval_7_filter_by_substring
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Filter an input list of strings only for ones that contain given substring\n\
  \    // >>> filterBySubstring((List[String]()), (\"a\"))\n    // (List[String]())\n\
  \    // >>> filterBySubstring((List[String](\"abc\", \"bacd\", \"cde\", \"array\"\
  )), (\"a\"))\n    // (List[String](\"abc\", \"bacd\", \"array\"))\n    def filterBySubstring(strings\
  \ : List[String], substring : String) : List[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(filterBySubstring((List[String]()),\
  \ (\"john\")).equals((List[String]())));\n    assert(filterBySubstring((List[String](\"\
  xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xxx\")).equals((List[String](\"\
  xxx\", \"xxxAAA\", \"xxx\"))));\n    assert(filterBySubstring((List[String](\"xxx\"\
  , \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xx\")).equals((List[String](\"\
  xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"))));\n    assert(filterBySubstring((List[String](\"\
  grunt\", \"trumpet\", \"prune\", \"gruesome\")), (\"run\")).equals((List[String](\"\
  grunt\", \"prune\"))));\n    }\n\n}\n"
completions: ["        // TODO\n        var ret : List[String] = List[String]()\n\
    \        for (i <- 0 until strings.length) {\n            val s = strings(i)\n\
    \            if (s.contains(substring)) {\n                ret = ret ++ List(s)\n\
    \            }\n        }\n        return ret", '        strings.filter(x => x.contains(substring))',
  "        // Handle empty list case\n        if (strings.isEmpty) {\n           \
    \ return List[String]()\n        }\n        // Recursively filter list\n     \
    \   var subList = filterBySubstring(strings.tail, substring)\n        // If current\
    \ list element contains the substring, add it to the sublist\n        if (strings.head.contains(substring))\
    \ {\n            subList = subList :+ strings.head\n        }\n        // Return\
    \ sublist\n        return subList", '        return strings.filter(string => string.contains(substring))',
  "        for {\n            string <- strings\n            if string.contains(substring)\n\
    \        } yield string", '        return strings.filter(((s) => s.contains(substring)))',
  '        return strings.filter(x => x.contains(substring))', "      val set1 = Set[String]()\n\
    \      val set2 = Set[String]()\n      var newlist = List[String]()\n      for\
    \ (i <- strings) {\n          val bool = i.contains(substring)\n          if (bool)\
    \ set1 += i\n          else set2 += i\n      }\n      newlist = set1.toList\n\
    \      return newlist", "        def filterBySubstringHelper(strings : List[String],\
    \ substring : String, newList : List[String]) : List[String] = {\n           \
    \ strings match {\n                case List() => newList\n                case\
    \ head::tail => if (head.contains(substring)) filterBySubstringHelper(tail, substring,\
    \ newList :+ head) else filterBySubstringHelper(tail, substring, newList)\n  \
    \          }\n        }\n        filterBySubstringHelper(strings, substring, List[String]())",
  '        return strings.filter(string => string.contains(substring))', "       \
    \ // Get one that contains substring\n        def getContain(s : String) : Boolean\
    \ = {\n            if (s.contains(substring)) {\n                true\n      \
    \      } else {\n                false\n            }\n        }\n        // Filtering\n\
    \        return strings.filter(getContain)", "        if (strings.length == 0)\
    \ {\n            return List[String]()\n        }\n        if (strings.head.contains(substring))\
    \ {\n            return strings.head :: filterBySubstring(strings.tail, substring)\n\
    \        }\n        return filterBySubstring(strings.tail, substring)", "    \
    \    // Fill in here\n        return null", '        strings.filter((s : String)
    => s.contains(substring))', '        strings.filter((s : String) => s.contains(substring))',
  '        strings.filter(str => str.contains(substring))', "        //TODO\n    \
    \    return List[String]()", '        for (string <- strings if string.contains(substring))
    yield string', '        strings.filter((str : String) => (str.contains(substring)))',
  "        var res = List[String]()\n        for (string <- strings) {\n         \
    \   if (string.contains(substring)) res = string :: res\n        }\n        res",
  "        // CHECKME: May be implemented more efficiently?\n        var list = List[String]()\n\
    \        for (str <- strings) {\n            if (str.contains(substring)) {\n\
    \                list = str :: list\n            }\n        }\n        return\
    \ list", "        // YOUR CODE HERE\n        strings.filter(x => x.contains(substring))",
  "        val result = (List[String]() /: strings) ((filteredStrings, string) =>\
    \ {\n            if (string.contains(substring)) {\n                filteredStrings\
    \ :+ string\n            } else {\n                filteredStrings\n         \
    \   }\n        })\n        result", "        // >>> filterBySubstringRecurse((List[String](\"\
    abc\", \"bacd\", \"cde\", \"array\")), (\"a\"), (List[String]()))\n        //\
    \ (List[String](\"abc\", \"bacd\", \"array\"))\n        def filterBySubstringRecurse(strings\
    \ : List[String], substring : String, acc : List[String]) : List[String] = {\n\
    \            if (strings.isEmpty)\n                acc\n            else {\n \
    \               if (strings.head.contains(substring))\n                    filterBySubstringRecurse(strings.tail,\
    \ substring, acc :+ strings.head)\n                else\n                    filterBySubstringRecurse(strings.tail,\
    \ substring, acc)\n            }\n        }\n        filterBySubstringRecurse(strings,\
    \ substring, List[String]())", '        strings.filter(x => x.contains(substring))',
  '        strings.filter(s => s.contains(substring))', "        val matchingStrings\
    \ = new ListBuffer[String]()\n        for (string <- strings) {\n            if\
    \ (string.contains(substring)) matchingStrings += string\n        }\n        return\
    \ matchingStrings.toList", '        return strings.filter((x) => x.contains(substring))',
  '        strings.filter(x => x.contains(substring))', '        strings.filter((str
    : String) => str.contains(substring))', '        strings.filter((str : String)
    => str.contains(substring))', '        strings.filter(string => string.contains(substring))',
  "        def iter(strings : List[String], acc : List[String]) : List[String] = {\n\
    \            if (strings.length == 0) {\n                acc\n            } else\
    \ {\n                val str = strings.head\n                if (str.contains(substring))\
    \ {\n                    iter(strings.tail, acc :+ str)\n                } else\
    \ {\n                    iter(strings.tail, acc)\n                }\n        \
    \    }\n        }\n        iter(strings, List[String]())", "        // Assume\
    \ the default case is that the given substring is not present in the input list\
    \ of strings\n        // Return the empty list\n        var output : List[String]\
    \ = List[String]()\n        // Go through the list of input strings\n        for\
    \ (string <- strings) {\n            // If the given substring is present in the\
    \ string, add the string to the output list\n            if (string.contains(substring))\
    \ {\n                output = output :+ string\n            }\n        }\n   \
    \     // Return the output list\n        return output", "        var newList\
    \ = List[String]()\n        for (i <- 0 until strings.length) {\n            if\
    \ (strings(i).contains(substring)) {\n                newList = newList :+ strings(i)\n\
    \            }\n        }\n        return newList", "        val trimmed = strings.map(_.trim)\n\
    \        trimmed.filter(s => s.contains(substring))", '        return strings.filter(string
    => string.contains(substring))', '        (for (x <- strings if x.contains(substring))
    yield x).toList', '        return strings.filter((s) => s.contains(substring))',
  "        if (strings.isEmpty) List[String]()\n        else if (strings.head.contains(substring))\
    \ strings.head :: filterBySubstring(strings.tail, substring)\n        else filterBySubstring(strings.tail,\
    \ substring)", '        return strings.filter((string : String) => string.contains(substring))',
  "        var found = List[String]()\n        for (s <- strings) {\n            if\
    \ (s.contains(substring)) {\n                found = s :: found\n            }\n\
    \        }\n        found", "        var matches : List[String] = List[String]()\n\
    \        for (i <- 0 until strings.length) {\n            if (strings(i).contains(substring))\
    \ matches = matches :+ strings(i)\n        }\n        return matches", "     \
    \   val positive = new ListBuffer[String]\n        for (string <- strings) {\n\
    \            if (string.contains(substring)) {\n                positive += string\n\
    \            }\n        }\n        return positive.toList", '        for (s <-
    strings; if s.contains(substring)) yield s', '        strings.filter(x => x.contains(substring))',
  '        strings.filter(s => s.contains(substring))', '        strings.filter(x
    => x.contains(substring))', '        return strings.filter((string) => string.contains(substring))',
  '        return strings.filter(s => s.contains(substring))', '        strings.filter(_.contains(substring))',
  '        strings.filter( (s : String) => s.contains(substring) )', '        (strings.filter((s
    : String) => s.contains(substring)))', "        if (strings.isEmpty) {\n     \
    \       return List[String]()\n        }\n        else {\n            if (strings.head.contains(substring))\
    \ {\n                return List(strings.head) ::: filterBySubstring(strings.tail,\
    \ substring)\n            }\n            else {\n                return filterBySubstring(strings.tail,\
    \ substring)\n            }\n        }", '      strings.filter(_.contains(substring))',
  '        strings.filter(s => s.contains(substring))', "        // Create list of\
    \ matches\n        var matches = List[String]()\n        // Iterate over strings\n\
    \        for (string <- strings) {\n            // If string contains substring,\
    \ add to list of matches\n            if (string.contains(substring)) matches\
    \ = string :: matches\n        }\n        // Return list of matches\n        return\
    \ matches", "        var filtered = List[String]()\n        for (str <- strings)\
    \ {\n            if (str.contains(substring)) {\n                filtered = str\
    \ :: filtered\n            }\n        }\n        filtered", '        strings.filter(s
    => s.contains(substring))', '        strings.filter((s : String) => s.contains(substring))',
  '        strings.filter((x : String) => x.contains(substring))', '        strings.filter((x)
    => x.contains(substring))', "        if (strings.isEmpty) {\n            List[String]()\n\
    \        } else {\n            val first = strings.head\n            val rest\
    \ = strings.tail\n            if (first.contains(substring)) {\n             \
    \   List(first) ++ filterBySubstring(rest, substring)\n            } else {\n\
    \                filterBySubstring(rest, substring)\n            }\n        }",
  '        strings.filter(str => str.contains(substring))', "        var result :\
    \ List[String] = List()\n        for (str <- strings) {\n            if (str.contains(substring))\
    \ {\n                result = str :: result\n            }\n        }\n      \
    \  return result", '        strings.filter(x => x.contains(substring))', '        strings.filter((x)
    => x.contains(substring))', '        strings.filter(x => x.contains(substring))',
  "        val processedStrings = strings.foldLeft(List[String]())((l, e) => if (e.contains(substring))\
    \ l :+ e else l)\n        processedStrings", "        var result : List[String]\
    \ = List[String]()\n        for (word <- strings) {\n            if (word.contains(substring))\
    \ {\n                result = word :: result\n            }\n        }\n     \
    \   return result", "        // strings.filter(s => s.contains(substring))\n \
    \       strings.filter(_.contains(substring))", "        var newList = new ListBuffer[String]()\n\
    \        for (currStr <- strings) {\n            if (currStr.contains(substring))\
    \ newList += currStr\n        }\n        return newList.toList", "        def\
    \ filterSubstring(target : String) : Boolean = {\n            var result = false\n\
    \            for (index <- 0 until target.length) {\n                if (target.substring(index,\
    \ index + 1) == substring) {\n                    result = true\n            \
    \    }\n            }\n            result\n        }\n        strings.filter(x\
    \ => filterSubstring(x))", '        return strings.filter((str : String) => str.contains(substring))',
  '        strings.filter(s => s.contains(substring))', "        def filter(strings\
    \ : List[String], substring : String, accumulator : List[String]) : List[String]\
    \ = {\n            if (strings.length == 0) accumulator\n            else if (strings.head.contains(substring))\
    \ filter(strings.tail, substring, accumulator :+ strings.head)\n            else\
    \ filter(strings.tail, substring, accumulator)\n        }\n        filter(strings,\
    \ substring, List[String]())", '        strings.filter(_.contains(substring))',
  "        var ret = List[String]()\n        for (i <- 0 until strings.length) {\n\
    \            if (strings(i).contains(substring)) {\n                ret = ret\
    \ :+ strings(i)\n            }\n        }\n        return ret", '        strings.filter(s
    => s.contains(substring))', "        var result : List[String] = List[String]()\n\
    \        for (s <- strings) {\n            if (s.contains(substring)) {\n    \
    \            result = s :: result\n            }\n        }\n        return result",
  '        strings.filter((s : String) => s.contains(substring))', '        strings.filter(word
    => word.contains(substring))', "        if (strings.isEmpty) return List[String]()\n\
    \        if (strings.head.contains(substring)) List(strings.head) ::: filterBySubstring(strings.tail,\
    \ substring)\n        else filterBySubstring(strings.tail, substring)", "    \
    \    var result : List[String] = List()\n        for (x <- strings) {\n      \
    \      if (x.contains(substring)) {\n                result = x :: result\n  \
    \          }\n        }\n        return result", '      return strings.filter(str
    => str.contains(substring))', "        for {\n            s <- strings\n     \
    \       if s.contains(substring)\n        } yield s", '        strings.filter(x
    => x.contains(substring))', '        strings.filter(string => string.contains(substring))',
  '        strings.filter((s : String) => s.contains(substring))', "        val filterResult\
    \ = strings.filter(string => string.contains(substring))\n        filterResult",
  '        return strings.filter(s => s.contains(substring))', '        strings.filter(e
    => e.contains(substring))', '        return (strings.filter((x : String) => x.contains(substring)))',
  '      strings.filter(str => str.indexOf(substring) != -1)', "        var ans =\
    \ List[String]()\n        for (i <- 0 until strings.length) {\n            if\
    \ (strings(i).contains(substring)) {\n                ans = ans :+ strings(i)\n\
    \            }\n        }\n        return ans", '        return strings.filter(string
    => string.contains(substring))', "        var filteredStrings = List[String]()\n\
    \        for (string <- strings) {\n            if (string.contains(substring))\
    \ {\n                filteredStrings = string :: filteredStrings\n           \
    \ }\n        }\n        return filteredStrings", '        for (string <- strings;
    if (string.contains(substring))) yield string', "        var result : List[String]\
    \ = List()\n        for (s <- strings) {\n            if (s.contains(substring))\
    \ {\n                result = result :+ s\n            }\n        }\n        return\
    \ result", '        strings.filter(string => string.contains(substring))', " \
    \       if (strings.isEmpty) strings\n        else {\n            val head = strings.head\n\
    \            val result = ListBuffer[String]()\n            if (head.contains(substring))\
    \ result += head\n            if (strings.tail.isEmpty) result.toList\n      \
    \      else result.toList ++ filterBySubstring(strings.tail, substring)\n    \
    \    }", "        var result : List[String] = List()\n        for (str <- strings)\
    \ if (str.contains(substring)) result = result ++ List(str)\n        return result",
  '        return strings.filter((string) => string.contains(substring))', '        strings.filter(element
    => element.contains(substring))', '        return strings.filter(str => (str.indexOf(substring)
    != -1))', "        var result : List[String] = List[String]()\n        for (i\
    \ <- 0 until strings.length) {\n            if (strings(i).contains(substring))\
    \ {\n                result = strings(i) :: result\n            }\n        }\n\
    \        return result", '        for (s <- strings; if s.contains(substring))
    yield s', '        strings.filter(s => (s.contains(substring)))', '      strings.filter((s
    : String) => s.contains(substring))', '        strings.filter(x => x.contains(substring))',
  '        strings.filter(string => string.contains(substring))', "      if (strings.isEmpty)\
    \ strings\n      else {\n        val left = strings.head\n        val right =\
    \ strings.tail\n        if (left.contains(substring)) left :: filterBySubstring(right,\
    \ substring)\n        else filterBySubstring(right, substring)\n      }", '        strings.filter(_.contains(substring))',
  '        return strings.filter(s => s.contains(substring))', '        return strings.filter(string
    => string.contains(substring))', "        // TODO\n        return List()", '        strings.filter((string
    : String) => string.contains(substring))', "        val N = strings.length\n \
    \       var ret = List[String]()\n        for (i <- 0 until N) {\n           \
    \ val string = strings(i)\n            if (string.contains(substring)) {\n   \
    \             ret = string :: ret\n            }\n        }\n        return ret",
  "        var result : List[String] = List[String]()\n        for (s <- strings)\
    \ {\n            if (s.contains(substring)) {\n                result = s :: result\n\
    \            }\n        }\n        return result", '        strings.filter(_.contains(substring))',
  "        val result : ListBuffer[String] = ListBuffer()\n        for (str <- strings)\
    \ {\n            if (str.contains(substring)) {\n                result += str\n\
    \            }\n        }\n        return result.toList", '        return strings.filter(s
    => s.contains(substring))', '        strings.filter((s : String) => (s.contains(substring)))',
  '        strings.filter(word => word.contains(substring))', '        return strings.filter(s
    => s.contains(substring))', '        return strings.filter(s => s.contains(substring))',
  "        if (strings.isEmpty) List[String]()\n        else if (strings.head.contains(substring))\
    \ List(strings.head) ::: filterBySubstring(strings.tail, substring)\n        else\
    \ filterBySubstring(strings.tail, substring)", "        def helper(strings : List[String],\
    \ filtered : List[String]) : List[String] = {\n            if (strings.isEmpty)\
    \ return filtered\n            if (strings.head.contains(substring)) helper(strings.tail,\
    \ strings.head :: filtered)\n            else helper(strings.tail, filtered)\n\
    \        }\n        helper(strings, List[String]())", '        strings.filter(e
    => e.contains(substring))', '        strings.filter(str => str.contains(substring))',
  '        strings.filter(str => str.contains(substring))', '        strings.filter(_.contains(substring))',
  '        return strings.filter(element => element.contains(substring))', "     \
    \   // Filter the input array\n        var result = strings.filter((string : String)\
    \ => {\n            // Check if it contains substring\n            string.contains(substring)\n\
    \        })\n        // Return the result\n        return result", "      var\
    \ result : List[String] = Nil\n      for (string <- strings) {\n        if (string.contains(substring))\
    \ {\n          result = result :+ string\n        }\n      }\n      return result",
  "        def filterBySubstringRecursive(strings : List[String], substring : String,\
    \ acc : List[String]) : List[String] = {\n            if (strings.isEmpty) acc\n\
    \            else if (strings.head.contains(substring)) filterBySubstringRecursive(strings.tail,\
    \ substring, acc :+ strings.head)\n            else filterBySubstringRecursive(strings.tail,\
    \ substring, acc)\n        }\n        filterBySubstringRecursive(strings, substring,\
    \ List[String]())", '        strings.filter(_.contains(substring))', '        strings.filter(s
    => s.contains(substring))', '        strings.filter(_.contains(substring))', '        strings.filter(_.contains(substring))',
  '        strings.filter(s => s.contains(substring))', "        if (strings.isEmpty)\
    \ {\n            return strings\n        }\n        if (strings.head.contains(substring))\
    \ {\n            return List(strings.head) ::: filterBySubstring(strings.tail,\
    \ substring)\n        }\n        return filterBySubstring(strings.tail, substring)",
  '        return strings.filter(s => s.contains(substring))', "        var result\
    \ : List[String] = Nil\n        for (str <- strings) {\n            if (str.contains(substring))\
    \ {\n                result = str :: result\n            }\n        }\n      \
    \  return result", '        strings.filter((s : String) => s.contains(substring))',
  "        var result : List[String] = List[String]()\n        for (string <- strings)\
    \ {\n            if (string.contains(substring)) {\n                result = result\
    \ :+ string\n            }\n        }\n        return result", "        var result\
    \ : List[String] = List()\n        for (s <- strings) {\n            if (s.contains(substring))\
    \ result = s :: result\n        }\n        return result", "        if (strings.length\
    \ == 0) {\n            return List[String]()\n        }\n        val filtered\
    \ = filterBySubstring(strings.tail, substring)\n        if (strings.head.contains(substring))\
    \ {\n            strings.head :: filtered\n        } else {\n            filtered\n\
    \        }", '        strings.filter(p => p.contains(substring))', '        return
    strings.filter(s => s.contains(substring))', "        var result : List[String]\
    \ = Nil\n        for (s <- strings) {\n            if (s.contains(substring))\
    \ {\n                result = s :: result\n            }\n        }\n        return\
    \ result", "        // Filter function\n        def filter(input : List[String],\
    \ substring : String) : List[String] = {\n            if (input.isEmpty) {\n \
    \               return input\n            } else {\n                // Check if\
    \ current string contains given substring\n                if (input.head.contains(substring))\
    \ {\n                    return List(input.head) ::: filter(input.tail, substring)\n\
    \                } else {\n                    return filter(input.tail, substring)\n\
    \                }\n            }\n        }\n        return filter(strings, substring)",
  "        var filtered = List[String]()\n        for (str <- strings) {\n       \
    \     if (str.contains(substring)) {\n                filtered = filtered ++ List(str)\n\
    \            }\n        }\n        return filtered", "        var result : List[String]\
    \ = List[String]()\n        for (str <- strings) {\n            if (str.contains(substring))\
    \ {\n                result = result :+ str\n            }\n        }\n      \
    \  return result", '        strings.filter(x => x.contains(substring))', '        return
    strings.filter(x => x.indexOf(substring) != -1)', "        if (strings.isEmpty)\
    \ {\n            return List[String]()\n        }\n        var output : List[String]\
    \ = List[String]()\n        for (s <- strings) {\n            if (s.contains(substring))\
    \ {\n                output = output :+ s\n            }\n        }\n        return\
    \ output", "        var s = substring\n        var list = strings\n        list.filter(list\
    \ => list.contains(s))", "        var result : List[String] = List[String]()\n\
    \        for (str <- strings) {\n            if (str.contains(substring)) {\n\
    \                result = str :: result\n            }\n        }\n        return\
    \ result", "        var newList = List[String]()\n        strings.foreach(x =>\
    \ if (x.contains(substring)) newList = newList :+ x)\n        return newList",
  "        // This function should be simple and short, I think it's unnecessary to\n\
    \        // create a new function like \"filterBySubstring\" to filter the list\n\
    \        // because there's a built-in funciton to filter a list - filter(p: (A)\
    \ => Boolean): List[A]\n        // This function should return all elements of\
    \ this list which satisfy a predicate.\n        // So I modified the function\
    \ to a simplified version.\n        strings.filter(word => word.contains(substring))",
  '        strings.filter(string => string.contains(substring))', '        strings.filter((string
    : String) => { string.contains(substring) })', '        return strings.filter((str)
    => str.contains(substring))', '        strings.filter(_.contains(substring))',
  '        strings.filter(string => string.contains(substring))', "        strings.filter(\n\
    \            string => {\n                string.indexOf(substring) != -1\n  \
    \          }\n        )", "        var result : List[String] = List()\n      \
    \  for (string <- strings) {\n            if (string.contains(substring)) {\n\
    \                result = string :: result\n            }\n        }\n       \
    \ return result", "        // >>> strings.filter(str => { str.contains(substring)\
    \ })\n        // (List[String](\"abc\", \"bacd\", \"array\"))\n        strings.filter(str\
    \ => { str.contains(substring) })", "        // >>> strings(0)\n        // \"\
    abc\"\n        // >>> strings(1)\n        // \"bacd\"\n        // >>> strings(2)\n\
    \        // \"cde\"\n        // >>> strings(3)\n        // \"array\"\n       \
    \ val filteredList = strings.filter(x => x.contains(substring))\n        return\
    \ filteredList", "        // TODO: Implement me\n        null", "        var result\
    \ : List[String] = List[String]()\n        for (i <- 0 until strings.length) {\n\
    \            if (strings(i).contains(substring)) {\n                result = result\
    \ :+ strings(i)\n            }\n        }\n        return result", '        strings.filter(s
    => s.contains(substring))', "        var result : List[String] = List()\n    \
    \    for (str <- strings) {\n            if (str.contains(substring)) {\n    \
    \            result = str :: result\n            }\n        }\n        return\
    \ result", '        strings.filter(x => x.contains(substring))', "        var\
    \ filtered : List[String] = List[String]()\n        for (string <- strings) {\n\
    \            if (string.contains(substring)) {\n                filtered = filtered\
    \ :+ string\n            }\n        }\n        return filtered", "        var\
    \ result : List[String] = List[String]()\n        for (index <- 0 until strings.length)\
    \ {\n            if (strings(index).contains(substring)) {\n                result\
    \ = strings(index) :: result\n            }\n        }\n        return result",
  '        strings.filter(x => x.contains(substring))', '        strings.filter((s
    : String) => (s.contains(substring)))', '        return strings.filter(s => s.contains(substring))',
  "        var r = List[String]()\n        for (s <- strings) {\n            if (s.contains(substring))\
    \ {\n                r = s :: r\n            }\n        }\n        return r",
  "        val filtered : ListBuffer[String] = ListBuffer.empty[String]\n        for\
    \ (s <- strings) {\n            if (s.contains(substring)) filtered += s\n   \
    \     }\n        filtered.toList", "        if (strings.isEmpty) return strings\n\
    \        val newStrings = if (strings.head.contains(substring)) List(strings.head)\
    \ else List[String]()\n        return newStrings ::: filterBySubstring(strings.tail,\
    \ substring)", "        var filtered : List[String] = Nil\n        for (s <- strings)\
    \ if (s.contains(substring)) filtered = s :: filtered\n        filtered.reverse",
  '        strings.filter(string => string.contains(substring))', '        return
    strings.filter(_.contains(substring))', "        // If List is empty, return it\n\
    \        if (strings.length == 0)\n            return strings\n        // Check\
    \ if string head is equal to given string\n        else if (strings.head.contains(substring))\n\
    \            return List(strings.head) ::: filterBySubstring(strings.tail, substring)\n\
    \        // Go to the next string\n        else\n            return filterBySubstring(strings.tail,\
    \ substring)", "        var result : List[String] = List[String]()\n        strings.foreach((s\
    \ : String) => if (s.contains(substring)) result = s :: result)\n        return\
    \ result", "        val filt = strings.filter(s => s.contains(substring))\n  \
    \      filt", "        var output : List[String] = List[String]()\n        for\
    \ (string <- strings) {\n            if (string.contains(substring)) {\n     \
    \           output = string :: output\n            }\n        }\n        return\
    \ output", "        val index = strings.indexWhere(! _.contains(substring))\n\
    \        if (index == -1) strings\n        else filterBySubstring(strings.take(index)\
    \ ++ strings.drop(index + 1), substring)", "        // Handle empty list\n   \
    \     if (strings.length == 0) {\n            return List[String]()\n        }\n\
    \        // Recursive implementation\n        val head = strings.head\n      \
    \  val tail = strings.tail\n        if (head.contains(substring)) {\n        \
    \    return head :: filterBySubstring(tail, substring)\n        }\n        else\
    \ {\n            return filterBySubstring(tail, substring)\n        }", "    \
    \    // filter: Filter a list of objects satisfying given predicate\n        //\
    \ >>> filter(List[Int](1,2,3,4,5), (x: Int) => (x % 2 == 0))\n        // (List[Int](2,\
    \ 4))\n        def filter[T](input : List[T], predicate : T => Boolean) : List[T]\
    \ = {\n            if (input.isEmpty) {\n                return List[T]()\n  \
    \          } else {\n                val head = input.head\n                val\
    \ tail = input.tail\n                if (predicate(head)) {\n                \
    \    return head :: filter(tail, predicate)\n                } else {\n      \
    \              return filter(tail, predicate)\n                }\n           \
    \ }\n        }\n        return filter(strings, (string : String) => (string.contains(substring)))",
  '        strings.filter(x => x.contains(substring))', "        val stringsFiltered\
    \ = ListBuffer[String]()\n        for (string <- strings) if (string.contains(substring))\
    \ stringsFiltered += string\n        stringsFiltered.toList", "        // Base\
    \ case: Empty list returns empty list\n        if (strings.isEmpty) {\n      \
    \      return List[String]()\n        }\n        // Recursive case: Recursively\
    \ call on tail, prepending head if head contains substring\n        else {\n \
    \           val result = filterBySubstring(strings.tail, substring)\n        \
    \    if (strings.head.contains(substring)) {\n                return strings.head\
    \ :: result\n            }\n            else {\n                return result\n\
    \            }\n        }", '        strings.filter(s => s.contains(substring))',
  '        return strings.filter(string => string.contains(substring))', '        strings.filter(s
    => s.contains(substring))', '        for (s <- strings; if s.contains(substring))
    yield s']
stop_tokens:
- "\n    }\n"
