language: scala
name: HumanEval_99_closest_integer
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        round(value.toDouble)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpydocumw2.scala:23)\n\tat Problem.main(tmpydocumw2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = BigDecimal(value)\n\
    \        if (n.signum == 0) {\n            0\n        } else {\n            val\
    \ d = n.abs\n            val i = d.toLong\n            if (d == i) {\n       \
    \         i\n            } else {\n                val h = d - i\n           \
    \     if (h >= 0.5) {\n                    i + 1\n                } else {\n \
    \                   i\n                }\n            }\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl1rfj1g8.scala:39)\n\tat Problem.main(tmpl1rfj1g8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = BigDecimal(value)\n        val rounded = number.setScale(0, BigDecimal.RoundingMode.HALF_UP)\n\
    \        if (number < 0)\n            -rounded.toLong\n        else\n        \
    \    rounded.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp38zrxsr_.scala:28)\n\tat Problem.main(tmp38zrxsr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val doubleValue\
    \ = value.toDouble\n        val doubleInt = value.toDouble.toInt\n        if (doubleValue\
    \ - doubleInt >= 0.5) doubleInt + 1 else doubleInt\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsngne7wj.scala:25)\n\tat Problem.main(tmpsngne7wj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val split =\
    \ value.split(\"\\\\.\")\n        if (split.length == 1) {\n            return\
    \ value.toLong\n        }\n        val n = split(1).toInt\n        val b = (n\
    \ - n % 10) / 10\n        val a = n - b * 10\n        val c = value.toLong\n \
    \       val d = if (a <= 5) b else b + 1\n        if (d == 0) {\n            return\
    \ c\n        }\n        if (c >= 0) {\n            return c + d\n        }\n \
    \       else {\n            return c - d\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpk803pir6.scala:25)\n\
    \tat Problem$.main(tmpk803pir6.scala:39)\n\tat Problem.main(tmpk803pir6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var result\
    \ : Long = 0\n        val num : Double = value.toDouble\n        if (num % 1 ==\
    \ 0) {\n            result = num.toLong\n        } else {\n            val s :\
    \ String = num.toString.split(\"\\\\.\")(1)\n            var n : Int = 0\n   \
    \         for (i <- 0 until s.length) {\n                if (s(i) != '0') {\n\
    \                    n = i\n                    break\n                }\n   \
    \         }\n            if (n == 0) {\n                result = num.toLong\n\
    \            } else {\n                val t : Double = (1.0 * s.substring(0,\
    \ n + 1).toInt) / pow(10, n + 1)\n                if (t >= 0.5) {\n          \
    \          result = ceil(num).toLong\n                } else {\n             \
    \       result = floor(num).toLong\n                }\n            }\n       \
    \ }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmply5ktnor.scala:28:20 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010052
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        0\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplmurcwyu.scala:21)\n\tat Problem.main(tmplmurcwyu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var v = value.toDouble\n\
    \        var i = ceil(v)\n        var f = floor(v)\n        if (i == f) {\n  \
    \          if (i > 0) {\n                i\n            } else {\n           \
    \     f\n            }\n        } else {\n            if (abs(v - i) < abs(v -\
    \ f)) {\n                i\n            } else {\n                f\n        \
    \    }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwge6grrn.scala:23:16\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                i\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Found:    (i\
    \ : Double)\n\e[31m   |\e[0m                Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwge6grrn.scala:25:16 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                f\n\e[31m\e[31m   |\e[0m            \
    \    ^\e[0m\n\e[31m   |\e[0m                Found:    (f : Double)\n\e[31m   |\e\
    [0m                Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpwge6grrn.scala:29:16 --------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                i\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m\
    \   |\e[0m                Found:    (i : Double)\n\e[31m   |\e[0m            \
    \    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwge6grrn.scala:31:16\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                f\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Found:    (f\
    \ : Double)\n\e[31m   |\e[0m                Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var v = BigDecimal(value)\n\
    \        if (v < 0) -((-v).toLong)\n        else if (v - v.toLong >= 0.5) v.toLong\
    \ + 1\n        else v.toLong\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjb0kc5i2.scala:26)\n\tat Problem.main(tmpjb0kc5i2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        return 0\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5yu1fk26.scala:21)\n\tat Problem.main(tmp5yu1fk26.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        value.toDouble.round\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw0dtuq5.scala:23)\n\tat Problem.main(tmpxw0dtuq5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val doubleValue\
    \ = value.toDouble\n        return round(doubleValue).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_yqcdc_p.scala:24)\n\tat Problem.main(tmp_yqcdc_p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      try {\n     \
    \   val n = value.toDouble\n        n.round\n      } catch {\n        case e:\
    \ Exception => 0\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpugty_k3e.scala:28)\n\tat Problem.main(tmpugty_k3e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        if (value.length() < 1) {\n            0\n        } else if (x.abs ==\
    \ floor(x.abs)) {\n            x.toLong\n        } else if (x < 0) {\n       \
    \     (floor(x) - 1).toLong\n        } else {\n            (ceil(x) + 1).toLong\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdepcqdx2.scala:31)\n\tat Problem.main(tmpdepcqdx2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        0\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplmurcwyu.scala:21)\n\tat Problem.main(tmplmurcwyu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        round(n)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp04owbuo0.scala:24)\n\tat Problem.main(tmp04owbuo0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val a = BigDecimal(value)\n\
    \        val b = a.toLong\n        val c = BigDecimal(b.toString)\n        if\
    \ (a > c) b + 1\n        else if (a < c) b - 1\n        else b\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe2lmz_lc.scala:29)\n\tat Problem.main(tmpe2lmz_lc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var s = BigDecimal(value)\n\
    \        if (s < 0) return -1 * closestInteger(value.substring(1))\n        val\
    \ x = s.toLong\n        val y = x + 1\n        if (s - x < y - s) x else y\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val (d,f) =\
    \ value.span(_ != '.')\n        if (f.size == 0) d.toLong\n        else {\n  \
    \          val (i,_) = f.splitAt(1)\n            val floor = d.toLong\n      \
    \      val ceil = if (floor == 0) 1 else floor * -1\n            val s = i.substring(1)\n\
    \            if (s.size == 0) floor\n            else {\n                val n\
    \ = s.toInt\n                if (n == 0) floor\n                else {\n     \
    \               val ceilVal = n + ceil\n                    val floorVal = n +\
    \ floor\n                    if (floorVal == 0) ceil\n                    else\
    \ if (ceilVal == 0) floor\n                    else if (abs(ceilVal) < abs(floorVal))\
    \ ceil\n                    else floor\n                }\n            }\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl6cvnbpg.scala:42)\n\tat Problem.main(tmpl6cvnbpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        if (abs(n - round(n)) > 0.5) {\n            if (n > 0)\n            \
    \    ceil(n)\n            else\n                floor(n)\n        } else\n   \
    \         round(n)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpstq0r15f.scala:21:20\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                ceil(n)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                Found:\
    \    Double\n\e[31m   |\e[0m                Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpstq0r15f.scala:23:21 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                floor(n)\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Found:    Double\n\e\
    [31m   |\e[0m                Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val dvalue\
    \ = value.toDouble\n        val ivalue = value.toLong\n        if (dvalue - ivalue\
    \ == 0.5) {\n            if (dvalue < 0) ivalue - 1\n            else ivalue +\
    \ 1\n        }\n        else if (dvalue > ivalue) ivalue + 1\n        else ivalue\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmp8ck_gdjn.scala:19)\n\
    \tat Problem$.main(tmp8ck_gdjn.scala:29)\n\tat Problem.main(tmp8ck_gdjn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        val isNegative = number < 0\n        val intNumber\
    \ = number.abs.toLong\n        val decimal = number - intNumber\n        var result\
    \ = 0l\n        if (decimal >= 0.5) {\n            result = intNumber + 1\n  \
    \      } else {\n            result = intNumber\n        }\n        if (isNegative)\
    \ {\n            -result\n        } else {\n            result\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8y0w4ar5.scala:37)\n\tat Problem.main(tmp8y0w4ar5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var doubleValue\
    \ = value.toDouble\n        if (doubleValue == 0) {\n            0\n        }\
    \ else if (doubleValue < 0) {\n            -floor(abs(doubleValue))\n        }\
    \ else {\n            ceil(doubleValue)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5avlad1i.scala:22:12\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            -floor(abs(doubleValue))\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            Found:    Double\n\e[31m   |\e[0m            Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5avlad1i.scala:24:16 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            ceil(doubleValue)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    Double\n\
    \e[31m   |\e[0m            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var n = BigDecimal(value)\n\
    \        var f = BigDecimal(floor(n.toDouble))\n        var c = BigDecimal(ceil(n.toDouble))\n\
    \        var result = 0l\n        if (n - f > c - n) result = c.toLong\n     \
    \   else result = f.toLong\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1clssprx.scala:28)\n\tat Problem.main(tmp1clssprx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val x = floor(n)\n        val y = ceil(n)\n        if (n - x >= y - n)\
    \ y else x\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp_1pvx2q.scala:21:28\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (n - x\
    \ >= y - n) y \e[33melse\e[0m x\n\e[31m\e[31m   |\e[0m                       \
    \     ^\e[0m\n\e[31m   |\e[0m                            Found:    (y : Double)\n\
    \e[31m   |\e[0m                            Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp_1pvx2q.scala:21:35 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (n - x >= y - n) y \e[33melse\e\
    [0m x\n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m\
    \   |\e[0m                                   Found:    (x : Double)\n\e[31m  \
    \ |\e[0m                                   Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = BigDecimal(value)\n\
    \        val floorN = n.floor\n        val ceilN = n.ceil\n        if (abs(n -\
    \ floorN) == abs(n - ceilN)) {\n            if (floorN > 0) floorN else ceilN\n\
    \        } else if (abs(n - floorN) < abs(n - ceilN)) floorN else ceilN\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8xfh7gv7.scala:19:23 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloorN\e[0m = n.floor\n\e\
    [31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m       value\
    \ floor is not a member of BigDecimal - did you mean n.clone?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp8xfh7gv7.scala:20:22 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mceilN\e[0m = n.ceil\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ ceil is not a member of BigDecimal - did you mean n.until?\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmp8xfh7gv7.scala:21:12 -----------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (abs(n - floorN) == abs(n - ceilN))\
    \ {\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m\
    \   |\e[0mmatch arguments (BigDecimal)\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8xfh7gv7.scala:23:19\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        } \e[33melse\e\
    [0m \e[33mif\e[0m (abs(n - floorN) < abs(n - ceilN)) floorN \e[33melse\e[0m ceilN\n\
    \e[31m\e[31m   |\e[0m                   ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m\
    \   |\e[0mmatch arguments (BigDecimal)\n4 errors found\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        return (round(d)).toLong\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpog6iqltc.scala:24)\n\tat Problem.main(tmpog6iqltc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val sign =\
    \ value.take(1)\n        var n = value.drop(1).toDouble\n        n = n + (n /\
    \ abs(n)) * 0.5\n        return n.toLong * sign.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi67aug44.scala:24)\n\tat Problem.main(tmpi67aug44.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val value_double\
    \ = value.toDouble\n        val lower = floor(value_double)\n        val upper\
    \ = ceil(value_double)\n        if (lower == upper) return lower.toLong\n    \
    \    if (abs(value_double - lower) < abs(value_double - upper)) return lower.toLong\n\
    \        else return upper.toLong\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr4u6favy.scala:28)\n\tat Problem.main(tmpr4u6favy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val f = floor(d)\n        val c = ceil(d)\n        if (d - f > c - d)\
    \ c else f\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz4jqf15v.scala:21:27\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (d - f\
    \ > c - d) c \e[33melse\e[0m f\n\e[31m\e[31m   |\e[0m                        \
    \   ^\e[0m\n\e[31m   |\e[0m                           Found:    (c : Double)\n\
    \e[31m   |\e[0m                           Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz4jqf15v.scala:21:34 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (d - f > c - d) c \e[33melse\e\
    [0m f\n\e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m \
    \  |\e[0m                                  Found:    (f : Double)\n\e[31m   |\e\
    [0m                                  Required: Long\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010065
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        var l = floor(d).toLong\n        var r = ceil(d).toLong\n        if (abs(d\
    \ - l) > abs(d - r)) r else l\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1va1pvww.scala:25)\n\tat Problem.main(tmp1va1pvww.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = BigDecimal(value)\n\
    \        if (num % 1 == 0) {\n            return num.toLong\n        }\n     \
    \   else {\n            if (num % 1 > 0.5) {\n                return (num + 1\
    \ - (num % 1)).toLong\n            }\n            else {\n                return\
    \ (num - (num % 1)).toLong\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8lcu7tkd.scala:33)\n\tat Problem.main(tmp8lcu7tkd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        return round(value.toDouble).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3oq9y2v6.scala:23)\n\tat Problem.main(tmp3oq9y2v6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Write your\
    \ code here\n        return 0\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwft8cmx0.scala:22)\n\tat Problem.main(tmpwft8cmx0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var intVal\
    \ = value.toDouble\n        var lVal = floor(intVal)\n        var hVal = ceil(intVal)\n\
    \        return if ((intVal - lVal) < (hVal - intVal)) lVal.toLong else hVal.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbpfoqnjk.scala:26)\n\tat Problem.main(tmpbpfoqnjk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        value.trim.toDouble.round\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5rrwltxk.scala:23)\n\tat Problem.main(tmp5rrwltxk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        if (num == round(num))\n            return round(num).toLong\n      \
    \  else if (num < 0)\n            return (floor(num) - 1).toLong\n        else\n\
    \            return (ceil(num) + 1).toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8ha879za.scala:28)\n\tat Problem.main(tmp8ha879za.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toDouble\n\
    \        if (v > 0) {\n            if (v - v.toLong > 0.5) v.toLong + 1\n    \
    \        else v.toLong\n        } else {\n            if (v - v.toLong < -0.5)\
    \ v.toLong - 1\n            else v.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyt1xnrxy.scala:29)\n\tat Problem.main(tmpyt1xnrxy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = BigDecimal(value)\n\
    \        if (n < BigDecimal(0)) {\n            return -closestInteger(value.substring(1))\n\
    \        }\n        if (n - n.floor < n.ceil - n) {\n            return n.floor.toLong\n\
    \        }\n        return n.ceil.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptjkaysez.scala:22:18 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (n - n.floor < n.ceil - n) {\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m       value floor\
    \ is not a member of BigDecimal - did you mean n.clone?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmptjkaysez.scala:22:28 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (n - n.floor < n.ceil - n) {\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ ceil is not a member of BigDecimal - did you mean n.until?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmptjkaysez.scala:23:21 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            \e[33mreturn\e[0m n.floor.toLong\n\e[31m\e[31m\
    \   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m       value floor is\
    \ not a member of BigDecimal - did you mean n.clone?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmptjkaysez.scala:25:17 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m        \e[33mreturn\e[0m n.ceil.toLong\n\e[31m\e[31m   |\e[0m\
    \               ^^^^^^\e[0m\n\e[31m   |\e[0m        value ceil is not a member\
    \ of BigDecimal - did you mean n.until?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010065
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val decimals\
    \ = value.split(\"\\\\.\").reverse\n        val decimal = if (decimals.length\
    \ > 1) decimals(0) else \"0\"\n        val num = if (decimals.length > 1) decimals(1)\
    \ else decimals(0)\n        val n = num.toInt\n        val d = decimal.toInt\n\
    \        if (n >= 5) {\n            n + 1\n        } else {\n            n\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdxdzay5v.scala:30)\n\tat Problem.main(tmpdxdzay5v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010065
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        def solve(x\
    \ : BigDecimal) : Long = {\n            if (x < 0) {\n                val n =\
    \ -x\n                if (n - n.toLong < 0.5) (-n.toLong) else (-(n.toLong + 1))\n\
    \            } else {\n                if (x - x.toLong < 0.5) x.toLong else (x.toLong\
    \ + 1)\n            }\n        }\n        val x = BigDecimal(value)\n        solve(x)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // check if\
    \ value is positive or negative.\n        // Convert the value to an integer.\n\
    \        // Get the decimals from the value.\n        // Round the decimals.\n\
    \        // Return new value as an integer.\n        var valueToInt = value.toInt\n\
    \        var valueToDouble = value.toDouble\n        if (valueToDouble - valueToInt\
    \ < 0.5) {\n            return valueToInt\n        } else {\n            return\
    \ valueToInt + 1\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.closestInteger(tmpgtr8qw1g.scala:23)\n\
    \tat Problem$.main(tmpgtr8qw1g.scala:33)\n\tat Problem.main(tmpgtr8qw1g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        round(num)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu6h7rmu3.scala:24)\n\tat Problem.main(tmpu6h7rmu3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010065
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        val p = x.floor\n        val q = x.ceil\n        if (x - p < q - x) p.toLong\
    \ else q.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn_dvc0p1.scala:26)\n\tat Problem.main(tmpn_dvc0p1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010065
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val number = if (n >= 0) ceil(n) else floor(n)\n        return number.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5i8e2ugc.scala:26)\n\tat Problem.main(tmp5i8e2ugc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010065
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        BigDecimal(value).round.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjo6fj671.scala:18:32 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        BigDecimal(value).round.toLong\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong\
    \ is not a member of java.math.MathContext => BigDecimal, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010065
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val integer\
    \ = value.toLong\n        val decimal = value.toDouble - integer\n        if (decimal\
    \ >= 0.5) integer + 1\n        else integer\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpbdy_t751.scala:18)\n\
    \tat Problem$.main(tmpbdy_t751.scala:25)\n\tat Problem.main(tmpbdy_t751.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val input =\
    \ value.toDouble\n        if (input - input.floor == 0.5)\n            (if (input\
    \ >= 0) input.ceil else input.floor).toLong\n        else\n            input.round.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010072
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        round(num)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu6h7rmu3.scala:24)\n\tat Problem.main(tmpu6h7rmu3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010065
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = java.lang.Double.parseDouble(value)\n        if (number > 0) {\n         \
    \   ceil(number).toLong\n        } else {\n            floor(number).toLong\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeuyqtuve.scala:29)\n\tat Problem.main(tmpeuyqtuve.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010072
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val ret = if (d - d.toLong > 0.5) d.toLong + 1 else d.toLong\n      \
    \  return ret\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgb4bdxbm.scala:24)\n\tat Problem.main(tmpgb4bdxbm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        if (n < 0) {\n            ceil(n).toLong\n        } else {\n        \
    \    floor(n).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoy_77ogm.scala:27)\n\tat Problem.main(tmpoy_77ogm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val doubleNum\
    \ = BigDecimal(value)\n        if (doubleNum < 0) {\n            val l = ceil(doubleNum).toLong\n\
    \            if (l - doubleNum == 0.5) l + 1 else l\n        } else {\n      \
    \      val l = floor(doubleNum).toLong\n            if (doubleNum - l == 0.5)\
    \ l - 1 else l\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1ij1qxns.scala:20:25\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e\
    [36ml\e[0m = ceil(doubleNum).toLong\n\e[31m\e[31m   |\e[0m                   \
    \      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         Found:    (doubleNum\
    \ : BigDecimal)\n\e[31m   |\e[0m                         Required: Double\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1ij1qxns.scala:23:26\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e\
    [36ml\e[0m = floor(doubleNum).toLong\n\e[31m\e[31m   |\e[0m                  \
    \        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          Found:    (doubleNum\
    \ : BigDecimal)\n\e[31m   |\e[0m                          Required: Double\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var v = value.toDouble\n\
    \        var r = round(v)\n        var f = floor(v)\n        var c = ceil(v)\n\
    \        if (v > 0) {\n            if (v - f < c - v) f.toLong else c.toLong\n\
    \        } else {\n            if (f - v < v - c) f.toLong else c.toLong\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn9_8qb_6.scala:31)\n\tat Problem.main(tmpn9_8qb_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val n = d.toLong\n        if (abs(d - n) < 0.5) n else n + 1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb6hssxui.scala:25)\n\tat Problem.main(tmpb6hssxui.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        def closest(num\
    \ : Long, value : Double) : Long = {\n            val next = num + 1\n       \
    \     if (abs(num - value) < abs(next - value)) num\n            else next\n \
    \       }\n        val double = value.toDouble\n        if (double < 0) -closest(-double.toLong,\
    \ -double)\n        else closest(double.toLong, double)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      var n = BigDecimal(value).toDouble\n\
    \      var ceil = ceil(n)\n      var floor = floor(n)\n      var diff1 = abs(ceil\
    \ - n)\n      var diff2 = abs(floor - n)\n      if (diff1 > diff2) floor else\
    \ ceil\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoh95bhze.scala:19:17 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m      \e[33mvar\e[0m \e[36mceil\e[0m = ceil(n)\n\e[31m\e\
    [31m   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 Recursive\
    \ \e[33mvariable\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpoh95bhze.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m      \e[33mvar\e[0m \e[36mfloor\e[0m = floor(n)\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvariable\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010070
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val closest = if (num >= 0) {\n            ceil(num).toLong\n       \
    \ } else {\n            floor(num).toLong\n        }\n        val a = closest\
    \ - num\n        val b = num - closest + 1\n        if (abs(a) <= abs(b))\n  \
    \          closest - 1\n        else\n            closest\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6oxmqefr.scala:32)\n\tat Problem.main(tmp6oxmqefr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val a = floor(d)\n        val b = ceil(d)\n        if (d - a < b - d)\n\
    \            a.toLong\n        else\n            b.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxl2me6cu.scala:29)\n\tat Problem.main(tmpxl2me6cu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = java.lang.Double.parseDouble(value)\n\
    \        val n1 = round(n)\n        val n2 = floor(n)\n        val n3 = ceil(n)\n\
    \        //println(n1 + \" \" + n2 + \" \" + n3)\n        if (abs(n - n1) <= abs(n\
    \ - n2)) n1.toLong else n2.toLong\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_6l9siwv.scala:28)\n\tat Problem.main(tmp_6l9siwv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toDouble\n\
    \        val ci = round(v)\n        return ci.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnhwc8lhp.scala:25)\n\tat Problem.main(tmpnhwc8lhp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        value.toDouble.round.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpygreps2a.scala:23)\n\tat Problem.main(tmpygreps2a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        if (n % 1 >= 0.5) (n + 1).toLong\n        else n.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8feo8p12.scala:25)\n\tat Problem.main(tmp8feo8p12.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      var x = value.toDouble\n\
    \      if (x == 0) 0 else {\n        if (abs(x) >= 1)\n          round(x).toLong\n\
    \        else {\n          var i = 1\n          while (abs(x * pow(10, i)) < 1)\
    \ {\n            i += 1\n          }\n          round(x * pow(10, i)).toLong /\
    \ pow(10, i).toLong\n        }\n      }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwzerz5fh.scala:34)\n\tat Problem.main(tmpwzerz5fh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        ???\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.closestInteger(tmpf0rw5a6i.scala:18)\n\tat Problem$.main(tmpf0rw5a6i.scala:21)\n\
    \tat Problem.main(tmpf0rw5a6i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // You must\
    \ fill in the definition of this function.\n        val n = value.toDouble\n \
    \       if (n == floor(n)) floor(n).toLong\n        else if (n > 0) {\n      \
    \      if (n - floor(n) < 0.5) floor(n).toLong\n            else (floor(n) + 1).toLong\n\
    \        }\n        else if (n < 0) {\n            if (ceil(n) - n < 0.5) ceil(n).toLong\n\
    \            else (ceil(n) - 1).toLong\n        }\n        else 0l\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toDouble\n\
    \        if (v - floor(v) > ceil(v) - v) ceil(v).toLong else floor(v).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4x4nwwfv.scala:23)\n\tat Problem.main(tmp4x4nwwfv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = value.toLong\n        if (abs(d - i) >= 0.5)\n            round(d)\n\
    \        else\n            i\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpnx_l2vhy.scala:19)\n\
    \tat Problem$.main(tmpnx_l2vhy.scala:27)\n\tat Problem.main(tmpnx_l2vhy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val sign =\
    \ if (value.head == '-') -1 else 1\n        val without_sign = if (value.head\
    \ == '-') value.tail else value\n        val k = without_sign.indexOf('.')\n \
    \       if (k == -1) {\n            sign * value.toLong\n        } else {\n  \
    \          val (integral, frac) = without_sign.splitAt(k)\n            sign *\
    \ (integral.toLong + \n                (if (frac.tail.toLong >= 5l) 1l else 0l))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val ceil = math.ceil(num)\n        val floor = math.floor(num)\n    \
    \    if (num - floor < ceil - num)\n            floor.toLong\n        else\n \
    \           ceil.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpow4l30b8.scala:29)\n\tat Problem.main(tmpow4l30b8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var x = value.toDouble\n\
    \        var y = x.toLong\n        if(x - y >= 0.5) y += 1\n        return y\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpav_0io9s.scala:26)\n\tat Problem.main(tmpav_0io9s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010076
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        if (x.isWhole) return x.toLong\n        if (abs(x - floor(x)) < abs(x\
    \ - ceil(x))) return floor(x).toLong\n        return ceil(x).toLong\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0hy1fgcw.scala:26)\n\tat Problem.main(tmp0hy1fgcw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010081
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parsed\
    \ = value.toDouble\n        val floor = parsed.floor\n        val ceil = parsed.ceil\n\
    \        if (floor == ceil) ceil\n        else if (parsed - floor < ceil - parsed)\
    \ floor\n        else ceil\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnnwjpq4n.scala:21:27\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (floor\
    \ == ceil) ceil\n\e[31m\e[31m   |\e[0m                           ^^^^\e[0m\n\e\
    [31m   |\e[0m                           Found:    (ceil : Double)\n\e[31m   |\e\
    [0m                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpnnwjpq4n.scala:22:49 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (parsed - floor\
    \ < ceil - parsed) floor\n\e[31m\e[31m   |\e[0m                              \
    \                   ^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \                Found:    (floor : Double)\n\e[31m   |\e[0m                 \
    \                             Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpnnwjpq4n.scala:23:13 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m ceil\n\e[31m\e[31m   |\e[0m \
    \            ^^^^\e[0m\n\e[31m   |\e[0m             Found:    (ceil : Double)\n\
    \e[31m   |\e[0m             Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010082
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var x = value.toDouble\n\
    \        var a = value.toDouble.round\n        var aa = if (a >= 0) a else -a\n\
    \        var b = value.toDouble.ceil\n        var bb = if (b >= 0) b else -b\n\
    \        if (x == a)\n            a\n        else if (x > 0) {\n            if\
    \ (aa < bb)\n                a\n            else\n                b\n        }\n\
    \        else {\n            if (aa < bb)\n                -a\n            else\n\
    \                -b\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpehucn_wh.scala:29:16\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                b\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Found:    (b\
    \ : Double)\n\e[31m   |\e[0m                Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpehucn_wh.scala:35:16 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                -b\n\e[31m\e[31m   |\e[0m           \
    \     ^^\e[0m\n\e[31m   |\e[0m                Found:    Double\n\e[31m   |\e[0m\
    \                Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010082
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        round(num)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu6h7rmu3.scala:24)\n\tat Problem.main(tmpu6h7rmu3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010065
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your implementation\
    \ goes here.\n        ???\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.closestInteger(tmpv_gk5zcc.scala:19)\n\tat Problem$.main(tmpv_gk5zcc.scala:22)\n\
    \tat Problem.main(tmpv_gk5zcc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010082
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        return round(value.toDouble).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3oq9y2v6.scala:23)\n\tat Problem.main(tmp3oq9y2v6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Uncomment\
    \ to test against real input\n        // val in = io.Source.stdin.getLines\n \
    \       // val value = in.next\n        // val test = value.toFloat\n        val\
    \ test = value.toFloat\n        val rounded = round(test)\n        val ceiled\
    \ = ceil(test)\n        val floored = floor(test)\n        val testToCeil = abs(ceiled\
    \ - test)\n        val testToFloor = abs(floored - test)\n        val testToRound\
    \ = abs(rounded - test)\n        if (testToCeil == testToFloor) {\n          \
    \  if (testToCeil == testToRound) {\n                if (rounded > 0) rounded\
    \ else floored\n            } else if (testToRound < testToCeil) {\n         \
    \       rounded\n            } else {\n                if (ceiled > 0) ceiled\
    \ else floored\n            }\n        } else if (testToCeil == testToRound) {\n\
    \            if (ceiled > 0) ceiled else floored\n        } else if (testToFloor\
    \ == testToRound) {\n            if (floored > 0) floored else ceiled\n      \
    \  } else if (testToCeil < testToFloor) {\n            if (testToCeil < testToRound)\
    \ {\n                if (ceiled > 0) ceiled else floored\n            } else {\n\
    \                rounded\n            }\n        } else {\n            if (testToFloor\
    \ < testToRound) {\n                if (floored > 0) floored else ceiled\n   \
    \         } else {\n                rounded\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppv183z2a.scala:31:46\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                \e[33mif\e[0m\
    \ (rounded > \e[31m0\e[0m) rounded \e[33melse\e[0m floored\n\e[31m\e[31m   |\e\
    [0m                                              ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                            Found:    (floored : Double)\n\e\
    [31m   |\e[0m                                            Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppv183z2a.scala:35:32 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mif\e[0m (ceiled > \e[31m0\e[0m)\
    \ ceiled \e[33melse\e[0m floored\n\e[31m\e[31m   |\e[0m                      \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m                                Found:\
    \    (ceiled : Double)\n\e[31m   |\e[0m                                Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppv183z2a.scala:35:44\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                \e[33mif\e[0m\
    \ (ceiled > \e[31m0\e[0m) ceiled \e[33melse\e[0m floored\n\e[31m\e[31m   |\e[0m\
    \                                            ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                         Found:    (floored : Double)\n\e[31m\
    \   |\e[0m                                            Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppv183z2a.scala:38:28 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mif\e[0m (ceiled > \e[31m0\e[0m) ceiled\
    \ \e[33melse\e[0m floored\n\e[31m\e[31m   |\e[0m                            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Found:    (ceiled : Double)\n\e\
    [31m   |\e[0m                            Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmppv183z2a.scala:38:40 --------------------\e\
    ["
  stdout: ''
  timestamp: 1660010084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val v = BigDecimal(value)\n\
    \        if (v < 0) floor(v).toLong else ceil(v).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp809qj24l.scala:19:25\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (v < \e\
    [31m0\e[0m) floor(v).toLong \e[33melse\e[0m ceil(v).toLong\n\e[31m\e[31m   |\e\
    [0m                         ^\e[0m\n\e[31m   |\e[0m                         Found:\
    \    (v : BigDecimal)\n\e[31m   |\e[0m                         Required: Double\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp809qj24l.scala:19:45\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (v < \e\
    [31m0\e[0m) floor(v).toLong \e[33melse\e[0m ceil(v).toLong\n\e[31m\e[31m   |\e\
    [0m                                             ^\e[0m\n\e[31m   |\e[0m      \
    \                                       Found:    (v : BigDecimal)\n\e[31m   |\e\
    [0m                                             Required: Double\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      def helper(n\
    \ : Double) : Long = {\n        val p = n.ceil\n        val m = n.floor\n    \
    \    if (abs(n - p) < abs(n - m)) p else m\n      }\n      val n = value.toDouble\n\
    \      if (n.isWhole) n.toLong else helper(n)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp96ci6pl_.scala:21:37\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (abs(n\
    \ - p) < abs(n - m)) p \e[33melse\e[0m m\n\e[31m\e[31m   |\e[0m              \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \       Found:    (p : Double)\n\e[31m   |\e[0m                              \
    \       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp96ci6pl_.scala:21:44\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (abs(n\
    \ - p) < abs(n - m)) p \e[33melse\e[0m m\n\e[31m\e[31m   |\e[0m              \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                     Found:    (m : Double)\n\e[31m   |\e[0m                \
    \                            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        def round(input\
    \ : String) : Long = {\n            val x = input.toDouble\n            val a\
    \ = floor(x)\n            val b = ceil(x)\n            if ((x - a) == (b - x))\
    \ {\n                if (abs(a) > abs(b)) a.toLong else b.toLong\n           \
    \ } else if ((x - a) < (b - x)) a.toLong else b.toLong\n        }\n        value.contains(\"\
    .\") match {\n            case true => round(value)\n            case false =>\
    \ value.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // create a\
    \ function that converts number to string\n        // create a function that computes\
    \ the distance between two numbers\n        def toDouble(value : String) : Double\
    \ = {\n            try {\n                value.toDouble\n            } catch\
    \ {\n                case e : Exception => {\n                    0.0\n      \
    \          }\n            }\n        }\n        // create a function that takes\
    \ a number and returns the closest integer\n        def closestInt(value : Double)\
    \ : Long = {\n            val ceil = ceil(value)\n            val floor = floor(value)\n\
    \            if (value > 0.0) {\n                if (value - floor > ceil - value)\
    \ ceil.toLong else floor.toLong\n            } else {\n                if (value\
    \ - floor > ceil - value) floor.toLong else ceil.toLong\n            }\n     \
    \   }\n        // create a function that takes a number and returns the closest\
    \ integer\n        def closest(value : Double) : Long = {\n            (ceil(value)\
    \ - value).abs compare (floor(value) - value).abs match {\n                case\
    \ 1 => floor(value).toLong\n                case -1 => ceil(value).toLong\n  \
    \              case 0 => {\n                    if (value > 0.0) ceil(value).toLong\
    \ else floor(value).toLong\n                }\n            }\n        }\n    \
    \    closest(toDouble(value))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpreslwg4p.scala:31:23 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36mceil\e[0m = ceil(value)\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpreslwg4p.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mfloor\e[0m = floor(value)\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010081
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val d2 = d.round\n        if (d2 - d < 0) {\n            d2 - 1\n   \
    \     } else {\n            d2\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpplvv25pz.scala:29)\n\tat Problem.main(tmpplvv25pz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n    \tvar number =\
    \ BigDecimal(value)\n    \tnumber.setScale(0, BigDecimal.RoundingMode.HALF_UP).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      val d = value.toDouble\n\
    \      val nearest = floor(d + 0.5)\n      nearest.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy06or9bo.scala:25)\n\tat Problem.main(tmpy06or9bo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        return ceil(value.toDouble).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp57baytbj.scala:23)\n\tat Problem.main(tmp57baytbj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0)\n        \tceil(d).toLong\n        else\n        \tfloor(d).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgqj1nvk8.scala:28)\n\tat Problem.main(tmpgqj1nvk8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010085
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      val x = value.toDouble\n\
    \      val y = Math.floor(x)\n      if (abs(x - y) < 0.5)\n        y.toLong\n\
    \      else\n        y.toLong + 1\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmbi8izv5.scala:28)\n\tat Problem.main(tmpmbi8izv5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010085
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        round(n)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp04owbuo0.scala:24)\n\tat Problem.main(tmp04owbuo0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        val c = floor(n)\n        val f = ceil(n)\n        if (abs(c - n) ==\
    \ abs(f - n)) {\n            if (n > 0) f else c\n        } else if (abs(c - n)\
    \ < abs(f - n)) c else f\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkwivi0jb.scala:22:23\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (n\
    \ > \e[31m0\e[0m) f \e[33melse\e[0m c\n\e[31m\e[31m   |\e[0m                 \
    \      ^\e[0m\n\e[31m   |\e[0m                       Found:    (f : Double)\n\e\
    [31m   |\e[0m                       Required: Long\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpkwivi0jb.scala:22:30 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (n > \e[31m0\e[0m) f \e[33melse\e\
    [0m c\n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e\
    [0m                              Found:    (c : Double)\n\e[31m   |\e[0m     \
    \                         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpkwivi0jb.scala:23:44 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (abs(c - n) < abs(f\
    \ - n)) c \e[33melse\e[0m f\n\e[31m\e[31m   |\e[0m                           \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \        Found:    (c : Double)\n\e[31m   |\e[0m                             \
    \               Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpkwivi0jb.scala:23:51 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (abs(c - n) < abs(f - n)) c \e\
    [33melse\e[0m f\n\e[31m\e[31m   |\e[0m                                       \
    \            ^\e[0m\n\e[31m   |\e[0m                                         \
    \         Found:    (f : Double)\n\e[31m   |\e[0m                            \
    \                      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010085
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n    \tval num = BigDecimal(value)\n\
    \    \tval floor = num.floor\n    \tval ceil = num.ceil\n    \tval ceiling = ceil.toLong\n\
    \    \tval floored = floor.toLong\n    \tif (num - floor <= 0.5) floored else\
    \ ceiling\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjt4vcski.scala:19:24 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m    \t\e[33mval\e[0m \e[36mfloor\e[0m = num.floor\n\e\
    [31m\e[31m   |\e[0m    \t            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m     value\
    \ floor is not a member of BigDecimal - did you mean num.clone?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpjt4vcski.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m    \t\e[33mval\e[0m \e[36mceil\e[0m = num.ceil\n\e[31m\e\
    [31m   |\e[0m    \t           ^^^^^^^^\e[0m\n\e[31m   |\e[0m      value ceil is\
    \ not a member of BigDecimal - did you mean num.until?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010085
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        return round(value.toDouble).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3oq9y2v6.scala:23)\n\tat Problem.main(tmp3oq9y2v6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = BigDecimal(value)\n\
    \        val (a,b) = (floor(d), ceil(d))\n        if (d - a == b - d) (if (d >\
    \ 0) b else a).toLong else d.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwuggee29.scala:19:27\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m (a,b)\
    \ = (floor(d), ceil(d))\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\
    \e[31m   |\e[0m                           Found:    (d : BigDecimal)\n\e[31m \
    \  |\e[0m                           Required: Double\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpwuggee29.scala:19:36 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m (a,b) = (floor(d), ceil(d))\n\e\
    [31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m\
    \                                    Found:    (d : BigDecimal)\n\e[31m   |\e\
    [0m                                    Required: Double\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var n = value.toDouble\n\
    \        var x = round(n)\n        x\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqrgcf89c.scala:25)\n\tat Problem.main(tmpqrgcf89c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        return if (x < 0) ceil(x).toLong else floor(x).toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpllf1xs_k.scala:23)\n\tat Problem.main(tmpllf1xs_k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010085
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      val d = value.toDouble\n\
    \      val result = round(d)\n      result.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy6ch5a1l.scala:25)\n\tat Problem.main(tmpy6ch5a1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010085
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        if (n < 0) ceil(n) - 1 else ceil(n)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn1wr6qqm.scala:19:19\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (n < \e\
    [31m0\e[0m) ceil(n) - \e[31m1\e[0m \e[33melse\e[0m ceil(n)\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:\
    \    Double\n\e[31m   |\e[0m                   Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn1wr6qqm.scala:19:40 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (n < \e[31m0\e[0m) ceil(n) - \e\
    [31m1\e[0m \e[33melse\e[0m ceil(n)\n\e[31m\e[31m   |\e[0m                    \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \     Found:    Double\n\e[31m   |\e[0m                                    Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010085
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var v : Double\
    \ = value.toDouble\n        val floor = v.floor\n        val ceil = v.ceil\n \
    \       var r = if (abs(floor - v) < abs(ceil - v)) floor else ceil\n        r.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp20cipjf4.scala:27)\n\tat Problem.main(tmp20cipjf4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n    \tval d = value.toDouble\n\
    \    \tif(abs(d - round(d)) == 0.5) {\n    \t\tif(d > 0) round(d) + 1\n    \t\t\
    else round(d) - 1\n    \t}\n    \telse round(d)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd281ub6y.scala:27)\n\tat Problem.main(tmpd281ub6y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010090
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        def digitsToLong(s\
    \ : String) : Long = s.foldLeft(0l) { (sum, c) => sum * 10 + c.asDigit }\n   \
    \     // get rid of leading zeros\n        val t = value.dropWhile(_ == '0')\n\
    \        val p = if (t.head == '-') t.tail else t\n        if (p.isEmpty) return\
    \ 0\n        // The general idea is to use the following equation to get the closest\
    \ integer:\n        //   n = sgn(x) * (m / 10^(-d))  where m and d satisfy the\
    \ following conditions:\n        //   1. d is the smallest possible integer such\
    \ that m / 10^(-d) is an integer\n        //   2. x <= m / 10^(-d)\n        //\n\
    \        // For example, if x = 123.456, then we can let m = 1234 and d = 2. We\
    \ then have\n        //   n = 123 = sgn(x) * (1234 / 10^(-2)) = sgn(x) * (1234\
    \ / 0.01)\n        // If x = 123.456, then we can let m = 1234, m = 1235 and d\
    \ = 2. We then have\n        //   n = 123 = sgn(x) * (1234 / 10^(-2)) = sgn(x)\
    \ * (1234 / 0.01)\n        //   n' = 124 = sgn(x) * (1235 / 10^(-2)) = sgn(x)\
    \ * (1235 / 0.01)\n        //\n        // We also note that it is faster to compute:\n\
    \        //   n = sgn(x) * (m / 10^(-d)) = sgn(x) * (m * 10^d)\n        // instead\
    \ of\n        //   n = sgn(x) * (m / 10^(-d)) = sgn(x) * (m / (1 / 10^d))\n  \
    \      //\n        // Next, we need to find the values of m and d. We note that\n\
    \        //   d is equal to the number of digits after the decimal point\n   \
    \     // in the given number.\n        // Since we are rounding away from zero,\
    \ if the given number is negative\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjsqonrcf.scala:22:8\
    \ ---------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (p.isEmpty)\
    \ \e[33mreturn\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required: Long\n\
    \e[31m   |\e[0m        Maybe you are missing an else part for the conditional?\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var d = value.toDouble\n\
    \        var t = d.toLong\n        if (d - t > 0.5) t + 1 else t\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzuozu1mz.scala:24)\n\tat Problem.main(tmpzuozu1mz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010091
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        if (x < 0) -1l * closestInteger((-1 * x).toString)\n        else if (x\
    \ % 1 == 0) x.toLong\n        else if (x % 1 < 0.5) (x.toLong)\n        else (x.toLong\
    \ + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010093
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      val num = BigDecimal(value)\n\
    \      val whole = num.toLong\n      val decimal = num - whole\n      if (abs(decimal)\
    \ <= 0.5) whole\n      else if (decimal > 0) whole + 1\n      else whole - 1\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpel31oukb.scala:21:10 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m      \e[33mif\e[0m (abs(decimal) <= \e[31m0.5\e[0m)\
    \ whole\n\e[31m\e[31m   |\e[0m          ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m\
    \   |\e[0mmatch arguments ((decimal : BigDecimal))\n1 error found\n"
  stdout: ''
  timestamp: 1660010089
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val ceil = ceil(d)\n        val floor = floor(d)\n        if (ceil -\
    \ d < d - floor) ceil.toLong else floor.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp28rg0v0u.scala:19:19 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(d)\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp28rg0v0u.scala:20:20 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(d)\n\e\
    [31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m               \
    \     Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val decimalPart\
    \ = value.split(\"\\\\.\")(1).toInt\n        val sign = if (value.indexOf(\"-\"\
    ) == 0) -1 else 1\n        val valueAsInt = (value.replace(\"-\", \"\").toDouble\
    \ * 100 + sign * 50).toInt\n        valueAsInt / 100\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpvltterd5.scala:18)\n\tat Problem$.main(tmpvltterd5.scala:24)\n\
    \tat Problem.main(tmpvltterd5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010094
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // TODO: implement\n\
    \        var n = value.toDouble\n        var closest = round(n)\n        closest\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9i_j7u7s.scala:26)\n\tat Problem.main(tmp9i_j7u7s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010093
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Write your\
    \ code here\n        0\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpafb6jg81.scala:22)\n\tat Problem.main(tmpafb6jg81.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010093
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // If a string\
    \ is passed in, turn it into a Double so we can\n        // compute its floor\
    \ and ceiling.\n        val doubleValue = value.toDouble\n        val floor =\
    \ floor(doubleValue)\n        val ceiling = ceil(doubleValue)\n        // Compute\
    \ the distance from the floor and ceiling to the input\n        // value.\n  \
    \      val distToFloor = doubleValue - floor\n        val distToCeiling = ceiling\
    \ - doubleValue\n        // Check whether the distance to the floor or ceiling\
    \ is shorter.\n        // If it's the floor, round down and return the floor.\
    \ Otherwise,\n        // round up and return the ceiling.\n        if (distToFloor\
    \ < distToCeiling) floor.toLong else ceiling.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5x7307h2.scala:21:20 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(doubleValue)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010091
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        return 0\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5yu1fk26.scala:21)\n\tat Problem.main(tmp5yu1fk26.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010054
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        if (n < 0) ceil(n).toLong else floor(n).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplv2gjfcj.scala:23)\n\tat Problem.main(tmplv2gjfcj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010094
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        if(value.endsWith(\".5\")) {\n            if(x > 0) (x+1).toLong\n  \
    \          else (x-1).toLong\n        }\n        else (x + 0.5).toLong\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010094
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Split the\
    \ string on the decimal place\n        val parts = value.split(\"\\\\.\")\n  \
    \      // Get the first number, and convert it to an integer\n        val pre\
    \ = parts(0).toInt\n        // Get the second number, and convert it to an integer\n\
    \        val post = parts(1).toInt\n        // If the post is less than half of\
    \ the max value for an integer,\n        // return the pre, otherwise return the\
    \ pre + 1\n        if (post < 5000) pre else pre + 1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpex70xeno.scala:23)\n\tat Problem$.main(tmpex70xeno.scala:29)\n\
    \tat Problem.main(tmpex70xeno.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010094
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        return Math.round(n)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp16mmoq81.scala:24)\n\tat Problem.main(tmp16mmoq81.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010094
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        if (value.contains(\"\
    .\") && value.split(\".\")(1).toInt == 5) {\n            if (value.contains(\"\
    -\")) return floor(value.toDouble).toLong - 1\n            else return ceil(value.toDouble).toLong\
    \ + 1\n        }\n        round(value.toDouble).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 0\n\tat Problem$.closestInteger(tmpd8u86kvd.scala:18)\n\tat Problem$.main(tmpd8u86kvd.scala:26)\n\
    \tat Problem.main(tmpd8u86kvd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010094
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        return round(number).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp84ugmggw.scala:24)\n\tat Problem.main(tmp84ugmggw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010094
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      val d = value.toDouble\n\
    \      val l = floor(d).toLong\n      val h = ceil(d).toLong\n      if (abs(d\
    \ - l) == abs(d - h)) if (d > 0) h else l else if (abs(d - l) < abs(d - h)) l\
    \ else h\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010094
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        def roundAwayFromZero(value\
    \ : Double) : Long = {\n            if (value.isNegInfinity) Long.MinValue\n \
    \           else if (value.isPosInfinity) Long.MaxValue\n            else if (value\
    \ < 0) -roundAwayFromZero(-value)\n            else if (value - value.toLong >\
    \ 0.5) value.toLong + 1\n            else value.toLong\n        }\n        roundAwayFromZero(value.toDouble)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy9ml6yt0.scala:29)\n\tat Problem.main(tmpy9ml6yt0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010094
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // TODO: Implement\
    \ a function that takes a value (string) representing\n        // a number and\
    \ returns the closest integer to it. If the number is\n        // equidistant\
    \ from two integers, round it away from zero.\n        // Hint: this will use\
    \ the Math.Round, Math.Floor, and Math.Ceiling\n        // functions.\n      \
    \  val t : Double = value.toDouble\n        val floor = floor(t)\n        val\
    \ ceiling = ceil(t)\n        val diff1 = abs(t - floor)\n        val diff2 = abs(t\
    \ - ceiling)\n        if (diff1 < diff2) floor.toLong else ceiling.toLong\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2breu8t6.scala:24:20 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(t)\n\e\
    [31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m               \
    \     Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010092
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        return (Math.round(value.toDouble));\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm6zas2q8.scala:23)\n\tat Problem.main(tmpm6zas2q8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010094
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        val i = number.toLong\n        if (i + 0.5 == number)\
    \ {\n            i + 1\n        } else {\n            i\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdviak6v3.scala:29)\n\tat Problem.main(tmpdviak6v3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010095
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // note: the\
    \ sign of the fractional part determines which way to round\n        val Array(i,\
    \ f) = value.split(\"\\\\.\")\n        val integral = i.toLong\n        val fractional\
    \ = (f + \"0\").take(2).toLong\n        if (fractional <= 25) integral else integral\
    \ + 1\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "scala.MatchError: [Ljava.lang.String;@12cdcf4 (of class [Ljava.lang.String;)\n\
    \tat Problem$.closestInteger(tmpdtn5ylvl.scala:19)\n\tat Problem$.main(tmpdtn5ylvl.scala:25)\n\
    \tat Problem.main(tmpdtn5ylvl.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010095
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val sign =\
    \ value.substring(0, 1)\n        val absValue = BigDecimal(value.substring(1))\n\
    \        val intValue = absValue.toInt\n        if (absValue - intValue >= 0.5)\
    \ intValue + 1\n        else intValue\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsag_bewg.scala:25)\n\tat Problem.main(tmpsag_bewg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val valueFloat\
    \ = value.toFloat\n        return if (valueFloat > 0) round(valueFloat).toLong\
    \ else -round(-valueFloat).toLong\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010097
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val (decimal,\
    \ _) = value.split(\"\\\\.\").map(_.toLong).partition(x => x > 0)\n        val\
    \ (decimal_part, neg) = if (decimal.length == 0) (None, true) else (Some(decimal.last),\
    \ false)\n        if (decimal_part.isEmpty) return 0\n        val (fractional_part,\
    \ tenth) = split(value.drop(decimal_part.get.toString.length + neg.toInt))\n \
    \       val first_digit = fractional_part.head\n        val second_digit = fractional_part.drop(1).head\n\
    \        val add_one = if (first_digit == 5 && second_digit == 0) 0 else if (first_digit\
    \ > 5) 1 else 0\n        (if (neg) -1 else 1) * (decimal_part.get + add_one)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1oma1gnj.scala:21:39 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m (fractional_part, tenth) = split(value.drop(decimal_part.get.toString.length\
    \ + neg.toInt))\n\e[31m\e[31m   |\e[0m                                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Not found: split\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1oma1gnj.scala:21:95\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m (fractional_part,\
    \ tenth) = split(value.drop(decimal_part.get.toString.length + neg.toInt))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                                 ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toInt is\
    \ not a member of Boolean, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp1oma1gnj.scala:21:13 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m (fractional_part, tenth) = split(value.drop(decimal_part.get.toString.length\
    \ + neg.toInt))\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e[0m   \
    \          Recursive \e[33mvalue\e[0m \e[35m$2$\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1oma1gnj.scala:21:30 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m (fractional_part, tenth) = split(value.drop(decimal_part.get.toString.length\
    \ + neg.toInt))\n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e\
    [31m   |\e[0m                              Recursive \e[33mvalue\e[0m \e[35m$2$\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m lon"
  stdout: ''
  timestamp: 1660010099
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = BigDecimal(value)\n\
    \        if (n < 0) {\n            if (n + 0.5 < n.toLong) n.toLong - 1 else n.toLong\n\
    \        } else {\n            if (n + 0.5 > n.toLong) n.toLong + 1 else n.toLong\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqz1tohga.scala:26)\n\tat Problem.main(tmpqz1tohga.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010100
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d >= 0) ceil(d).toLong else floor(d).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzyr3usow.scala:25)\n\tat Problem.main(tmpzyr3usow.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010100
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val dValue\
    \ = BigDecimal(value)\n        val negValue = BigDecimal(0) - dValue\n       \
    \ val negInt = (negValue.toLongExact - negValue.toBigIntExact.toLong)\n      \
    \  if (negInt == 0) {\n            return negValue.toLongExact\n        }\n  \
    \      val posInt = dValue.toLongExact - dValue.toBigIntExact.toLong\n       \
    \ if (posInt == 0) {\n            return dValue.toLongExact\n        }\n     \
    \   if (negInt > posInt) {\n            return negValue.toLongExact\n        }\n\
    \        return dValue.toLongExact\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkebhjhd3.scala:20:68 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnegInt\e[0m = (negValue.toLongExact\
    \ - negValue.toBigIntExact.toLong)\n\e[31m\e[31m   |\e[0m                    \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toLong is not a member of Option[BigInt], but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkebhjhd3.scala:24:63\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mposInt\e[0m = dValue.toLongExact - dValue.toBigIntExact.toLong\n\e[31m\e[31m\
    \   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of Option[BigInt], but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010102
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      var number =\
    \ value.toDouble\n      var ceiling = ceil(number)\n      var floor = floor(number)\n\
    \      var closestNumber = abs(ceiling - number)\n      if (closestNumber >= abs(floor\
    \ - number)) {\n        closestNumber = floor\n      } else {\n        closestNumber\
    \ = ceiling\n      }\n      closestNumber.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpv78gjaw4.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m      \e[33mvar\e[0m \e[36mfloor\e[0m = floor(number)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvariable\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = BigDecimal(value)\n\
    \        n.setScale(0, BigDecimal.RoundingMode.HALF_UP).toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010102
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val doubleVal\
    \ = value.toDouble\n        var floorVal = floor(doubleVal)\n        var ceilVal\
    \ = ceil(doubleVal)\n        var lowerVal = abs(doubleVal - floorVal)\n      \
    \  var upperVal = abs(doubleVal - ceilVal)\n        if (lowerVal < upperVal) {\n\
    \            floorVal.toLong\n        } else {\n            ceilVal.toLong\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwib6ig0h.scala:32)\n\tat Problem.main(tmpwib6ig0h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010102
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        if (value.contains(\"\
    .\")) {\n            var num = value.split(\"\\\\.\")\n            if (num(1).startsWith(\"\
    0\")) return num(0).toLong\n            var n = num(1).toInt\n            if (n\
    \ <= 5) return num(0).toLong\n            else return (num(0).toLong + 1)\n  \
    \      }\n        return value.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpak_c_lg1.scala:29)\n\tat Problem.main(tmpak_c_lg1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010102
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Floor the\
    \ number and add or subtract 0.5 as appropriate\n        val number = value.toDouble\n\
    \        val floored = floor(number)\n        val difference = number - floored\n\
    \        if (difference == 0.5) {\n            // Round away from zero\n     \
    \       val sign = math.signum(number)\n            if (sign == 1) floored + 1\
    \ else floored - 1\n        } else if (difference < 0.5) {\n            floored\n\
    \        } else {\n            floored + 1\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp67itfvw5.scala:25:27\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mif\e[0m (sign\
    \ == \e[31m1\e[0m) floored + \e[31m1\e[0m \e[33melse\e[0m floored - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    Double\n\e[31m   |\e[0m       \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp67itfvw5.scala:25:44 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            \e[33mif\e[0m (sign == \e[31m1\e[0m) floored + \e[31m1\e[0m\
    \ \e[33melse\e[0m floored - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m              \
    \                              ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                               Found:    Double\n\e[31m   |\e[0m            \
    \                                Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp67itfvw5.scala:27:12 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            floored\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (floored : Double)\n\e[31m\
    \   |\e[0m            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp67itfvw5.scala:29:12 --------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m            floored + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    Double\n\e\
    [31m   |\e[0m            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010104
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var number\
    \ : Double = value.toDouble\n        var ceil : Double = ceil(number)\n      \
    \  var floor : Double = floor(number)\n        var diff1 : Double = ceil - number\n\
    \        var diff2 : Double = number - floor\n        if (diff1 < diff2) {\n \
    \           return ceil.toLong\n        } else {\n            return floor.toLong\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpm_v76iws.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mceil\e[0m : \e[35mDouble\e\
    [0m = ceil(number)\n\e[31m\e[31m   |\e[0m                            ^^^^\e[0m\n\
    \e[31m   |\e[0m                            \e[33mvariable\e[0m \e[35mceil\e[0m\
    \ does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpm_v76iws.scala:20:29 -----------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mvar\e[0m \e[36mfloor\e[0m : \e[35mDouble\e[0m = floor(number)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             \e[33mvariable\e[0m \e[35mfloor\e[0m does not take\
    \ parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010100
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\"\"\\.\"\"\").map(BigInt(_))\n        val number = numbers(0)\n\
    \        val decimal = BigDecimal(numbers(1))\n        if (decimal == 0) {\n \
    \           number.toLong\n        } else {\n            val b = pow(10, value.length\
    \ - number.toString.length - 1)\n            val o = (b * (decimal / b + BigDecimal(0.5))).toLong\n\
    \            if (number < 0) {\n                -(number * b + o)\n          \
    \  } else {\n                number * b + o\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1pq2cyd8.scala:27:27\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                -(number * b\
    \ + o)\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m\
    \                           Found:    (b : Double)\n\e[31m   |\e[0m          \
    \                 Required: BigInt\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1pq2cyd8.scala:29:25 --------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                number * b + o\n\e[31m\e[31m   |\e[0m                \
    \         ^\e[0m\n\e[31m   |\e[0m                         Found:    (b : Double)\n\
    \e[31m   |\e[0m                         Required: BigInt\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010105
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (abs(d - ceil(d)) < abs(d - floor(d))) ceil(d).toLong\n        else\
    \ floor(d).toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxynwhiku.scala:24)\n\tat Problem.main(tmpxynwhiku.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        val floor = math.floor(number)\n        val ceil =\
    \ math.ceil(number)\n        if (floor == ceil) {\n            floor.toLong\n\
    \        } else {\n            if (number > 0) {\n                if (number -\
    \ floor < ceil - number) {\n                    floor.toLong\n               \
    \ } else {\n                    ceil.toLong\n                }\n            }\
    \ else {\n                if (floor - number < number - ceil) {\n            \
    \        floor.toLong\n                } else {\n                    ceil.toLong\n\
    \                }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw1ivc6as.scala:42)\n\tat Problem.main(tmpw1ivc6as.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        return round(value.toDouble).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3oq9y2v6.scala:23)\n\tat Problem.main(tmp3oq9y2v6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val m = d - floor(d)\n        val c = if (m < 0.5) d.toLong - 1 else\
    \ d.toLong\n        return c\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpefidr9go.scala:24)\n\tat Problem.main(tmpefidr9go.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = round(d)\n        if (i > d) {\n            i - 1\n        }\
    \ else {\n            i\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpllwamj5v.scala:28)\n\tat Problem.main(tmpllwamj5v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // code here\n\
    \        value.toDouble.round.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4ks4t1y2.scala:24)\n\tat Problem.main(tmp4ks4t1y2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010105
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        return x.round\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7mtma65j.scala:24)\n\tat Problem.main(tmp7mtma65j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var value_float\
    \ = value.toFloat\n        var value_int = value.toInt\n        if (value_float\
    \ > value_int) value_int + 1 else value_int\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.closestInteger(tmpibftjd7o.scala:19)\n\
    \tat Problem$.main(tmpibftjd7o.scala:24)\n\tat Problem.main(tmpibftjd7o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010105
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val doubleValue\
    \ = value.toDouble\n        if(doubleValue < 0) {\n            val ret = ceil(doubleValue)\n\
    \            return ret.toLong\n        }\n        else {\n            val ret\
    \ = floor(doubleValue)\n            return ret.toLong\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpul3vt7rn.scala:30)\n\tat Problem.main(tmpul3vt7rn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        floor(x + .5).toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1kwd6c5y.scala:24)\n\tat Problem.main(tmp1kwd6c5y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010106
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val x = abs(d)\n        val y = floor(x)\n        val z = ceil(x)\n \
    \       if (abs(y-x) == abs(z-x))\n            if (d >= 0) z else -z\n       \
    \ else if (abs(y-x) < abs(z-x))\n            y.toLong\n        else\n        \
    \    z.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe4t7bxog.scala:23:24\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (d\
    \ >= \e[31m0\e[0m) z \e[33melse\e[0m -z\n\e[31m\e[31m   |\e[0m               \
    \         ^\e[0m\n\e[31m   |\e[0m                        Found:    (z : Double)\n\
    \e[31m   |\e[0m                        Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpe4t7bxog.scala:23:31 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (d >= \e[31m0\e[0m) z \e[33melse\e\
    [0m -z\n\e[31m\e[31m   |\e[0m                               ^^\e[0m\n\e[31m  \
    \ |\e[0m                               Found:    Double\n\e[31m   |\e[0m     \
    \                          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010105
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = BigDecimal(value)\n\
    \        if (n - n.round == 0) n.round.toLong\n        else if (n < 0) n.round.toLong\
    \ - 1\n        else n.round.toLong + 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx5192z15.scala:19:16\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (n - n.round\
    \ == \e[31m0\e[0m) n.round.toLong\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Found:    java.math.MathContext => BigDecimal\n\
    \e[31m   |\e[0m                Required: BigDecimal\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpx5192z15.scala:19:38 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (n - n.round == \e[31m0\e[0m) n.round.toLong\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue toLong is not a member of java.math.MathContext => BigDecimal,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpx5192z15.scala:20:32 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (n < \e[31m0\e\
    [0m) n.round.toLong - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    \
    \    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member of java.math.MathContext\
    \ => BigDecimal, but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpx5192z15.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m n.round.toLong + \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010109
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toDouble\n\
    \        val i = round(v)\n        if (abs(v - i) == 0.5) i.toLong + signum(v).toLong\n\
    \        else i.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps4rlceqa.scala:25)\n\tat Problem.main(tmps4rlceqa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var a = value.toFloat\n\
    \        var integer = round(a)\n        return integer.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm56im2o5.scala:25)\n\tat Problem.main(tmpm56im2o5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010108
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        if (abs(number - floor(number + 0.5)) < 0.001) floor(number\
    \ + 0.5).toLong\n        else if (number >= 0) floor(number + 0.5).toLong\n  \
    \      else ceil(number - 0.5).toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010110
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      // Your code\
    \ here\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppsbgdc3u.scala:17:48\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mclosestInteger\e\
    [0m(\e[36mvalue\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                ^\e[0m\n\e[31m   |\e\
    [0m                                                Found:    Unit\n\e[31m   |\e\
    [0m                                                Required: Long\n\e[31m18 |\e\
    [0m      \e[34m// Your code here\e[0m\n\e[31m19 |\e[0m    }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010110
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n    \tif (value ==\
    \ null) {\n    \t\tthrow new NullPointerException(\"value must not be null\")\n\
    \    \t}\n    \tval f = value.toFloat\n    \tf match {\n    \t\tcase _ if (f <\
    \ 0) => ceil(f).toLong\n    \t\tcase _ if (f == 0) => 0\n    \t\tcase _ if (f\
    \ > 0) => floor(f).toLong\n    \t}\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpecrhl4uw.scala:30)\n\tat Problem.main(tmpecrhl4uw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010111
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        if (x == floor(x)) {\n            x.toLong\n        } else {\n      \
    \      val c = (floor(x), ceil(x))\n            val d = (x - c._1).abs\n     \
    \       val e = (x - c._2).abs\n            if (d < e) {\n                c._1.toLong\n\
    \            } else {\n                c._2.toLong\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6s7bgp46.scala:35)\n\tat Problem.main(tmp6s7bgp46.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010112
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = num.floor\n        val ceiling = num.ceil\n        if ((ceiling\
    \ - num) == (num - floor)) {\n            if (num < 0) floor else ceiling\n  \
    \      } else if ((ceiling - num) < (num - floor)) {\n            ceiling\n  \
    \      } else {\n            floor\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbrqjrbjt.scala:22:25\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (num\
    \ < \e[31m0\e[0m) floor \e[33melse\e[0m ceiling\n\e[31m\e[31m   |\e[0m       \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                         Found:\
    \    (floor : Double)\n\e[31m   |\e[0m                         Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbrqjrbjt.scala:22:36\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (num\
    \ < \e[31m0\e[0m) floor \e[33melse\e[0m ceiling\n\e[31m\e[31m   |\e[0m       \
    \                             ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                  Found:    (ceiling : Double)\n\e[31m   |\e[0m             \
    \                       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpbrqjrbjt.scala:24:12 --------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            ceiling\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    (ceiling : Double)\n\e[31m   |\e[0m\
    \            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpbrqjrbjt.scala:26:12 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            floor\n\e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\e[31m\
    \   |\e[0m            Found:    (floor : Double)\n\e[31m   |\e[0m            Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010112
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val a = new\
    \ BigDecimal(value)\n        val b = a.setScale(0, BigDecimal.RoundingMode.HALF_UP)\n\
    \        b.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1qcw8wdt.scala:18:31\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36ma\e\
    [0m = \e[33mnew\e[0m \e[35mBigDecimal\e[0m(value)\n\e[31m\e[31m   |\e[0m     \
    \                          ^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \        Found:    (value : String)\n\e[31m   |\e[0m                         \
    \      Required: java.math.BigDecimal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010111
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = BigDecimal(value)\n\
    \        if (x == BigDecimal(x.toLongExact)) x.toLong else x.setScale(0, RoundingMode.HALF_UP).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0lxypx95.scala:19:72 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (x == BigDecimal(x.toLongExact))\
    \ x.toLong \e[33melse\e[0m x.setScale(\e[31m0\e[0m, RoundingMode.HALF_UP).toLong\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       Not found: RoundingMode\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010108
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        val floor = math.floor(x)\n        val ceil = math.ceil(x)\n        val\
    \ remainder = x - floor\n        return if (remainder >= 0.5) ceil.toLong else\
    \ floor.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_qjmd1e2.scala:27)\n\tat Problem.main(tmp_qjmd1e2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010113
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val floatValue\
    \ = value.toFloat\n        val integerValue = value.toInt\n        if (floatValue\
    \ - integerValue > 0.5) integerValue + 1\n        else integerValue\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.closestInteger(tmp3_2s9ldg.scala:19)\n\
    \tat Problem$.main(tmp3_2s9ldg.scala:25)\n\tat Problem.main(tmp3_2s9ldg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010114
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        return round(d).toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4fvbrptt.scala:24)\n\tat Problem.main(tmp4fvbrptt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010114
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        if (value.contains(\"\
    .\")) {\n            val d = BigDecimal(value)\n            val c = d.setScale(0,\
    \ BigDecimal.RoundingMode.HALF_UP)\n            return c.toLong\n        }\n \
    \       else return value.toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010114
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        round(d)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjhidie4p.scala:24)\n\tat Problem.main(tmpjhidie4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010114
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toDouble\n\
    \        val c = if (v > 0) v + 0.5 else v - 0.5\n        c.toLong\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010114
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var rounded\
    \ = value.toDouble\n        var floor = floor(rounded)\n        var ceiling =\
    \ ceil(rounded)\n        var diff_ceiling = abs(ceiling - rounded)\n        var\
    \ diff_floor = abs(floor - rounded)\n        if (diff_ceiling < diff_floor) ceiling.toLong\
    \ else floor.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmps2lq_a9y.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mfloor\e[0m = floor(rounded)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvariable\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010111
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        return (round(value.toDouble)).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp8hhxqzf.scala:23)\n\tat Problem.main(tmpp8hhxqzf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010114
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        if (value.length()\
    \ == 0) return 0;\n        var value2 = value;\n        var sign = \"\";\n   \
    \     if (value.charAt(0) == '-') {\n            sign = \"-\";\n            value2\
    \ = value.substring(1);\n        }\n        var point = value2.indexOf('.');\n\
    \        if (point == -1) return value2.toLong;\n        var before_point = value2.substring(0,\
    \ point);\n        var after_point = value2.substring(point + 1);\n        if\
    \ (after_point.length() == 0) return value2.toLong;\n        var first_after_point\
    \ = after_point.charAt(0);\n        var first_after_point_i = first_after_point.toInt\
    \ - '0'.toInt;\n        var candidate1 = value2.toLong;\n        var candidate2\
    \ = candidate1 + 1;\n        if (first_after_point_i > 4) {\n            return\
    \ candidate2;\n        } else if (first_after_point_i < 4) {\n            return\
    \ candidate1;\n        } else {\n            var value2_array = value2.toCharArray.map(_.toInt);\n\
    \            var i = 1;\n            while (i < value2_array.length) {\n     \
    \           if (value2_array(point + i) > '0'.toInt) {\n                    return\
    \ candidate2;\n                } else if (value2_array(point + i) < '0'.toInt)\
    \ {\n                    return candidate1;\n                }\n             \
    \   i += 1;\n            }\n            return candidate1;\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpxbou7uhp.scala:32)\n\
    \tat Problem$.main(tmpxbou7uhp.scala:54)\n\tat Problem.main(tmpxbou7uhp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010115
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val doubleValue\
    \ = value.toDouble\n        val floorValue = floor(doubleValue)\n        val ceilValue\
    \ = ceil(doubleValue)\n        if (abs(floorValue - doubleValue) == abs(ceilValue\
    \ - doubleValue)) {\n            if (floorValue >= 0) {\n                ceilValue.toLong\n\
    \            } else {\n                floorValue.toLong\n            }\n    \
    \    } else if (abs(floorValue - doubleValue) < abs(ceilValue - doubleValue))\
    \ {\n            floorValue.toLong\n        } else {\n            ceilValue.toLong\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010116
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Fill in\
    \ the body of this function\n        // test if it is exactly an integer\n   \
    \     if (value.last.toString.equals(\".\")) {\n            val v_int = value.split(\"\
    \\\\.\")(0).toLong\n            return v_int\n        }\n        val isInteger\
    \ = value.contains(\".\")\n        if (isInteger == false) {\n            return\
    \ value.toLong\n        }\n        val v_float = value.toFloat\n        val v_double\
    \ = value.toDouble\n        val floor = floor(v_double).toLong\n        val ceiling\
    \ = ceil(v_double).toLong\n        // if it is an integer\n        if (v_float\
    \ - floor == 0) {\n            return floor\n        }\n        val diff_to_floor\
    \ = abs(v_float - floor)\n        val diff_to_ceiling = abs(v_float - ceiling)\n\
    \        if (diff_to_floor < diff_to_ceiling) {\n            return floor\n  \
    \      }\n        else {\n            return ceiling\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo6ta067r.scala:30:20 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(v_double).toLong\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010113
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // TODO: Return\
    \ the closest integer to the given value.\n        val d : Double = value.toDouble\n\
    \        return round(d)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1enax6e2.scala:25)\n\tat Problem.main(tmp1enax6e2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010115
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Implement\
    \ your solution here\n        throw new UnsupportedOperationException(\"Not yet\
    \ implemented\")\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: Not yet implemented\n\tat Problem$.closestInteger(tmpcqco5pck.scala:19)\n\
    \tat Problem$.main(tmpcqco5pck.scala:22)\n\tat Problem.main(tmpcqco5pck.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010115
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val a = ceil(d)\n        val b = floor(d)\n        if (abs(d - a) ==\
    \ abs(d - b)) {\n            if (d >= 0) a.toLong else b.toLong\n        } else\
    \ if (abs(d - a) < abs(d - b)) a.toLong else b.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d - floor(d) == 0.5)\n            if (d > 0) ceil(d) else floor(d)\n\
    \        else\n            round(d)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqs6dvhl5.scala:20:27\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m (d\
    \ > \e[31m0\e[0m) ceil(d) \e[33melse\e[0m floor(d)\n\e[31m\e[31m   |\e[0m    \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Found:\
    \    Double\n\e[31m   |\e[0m                       Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqs6dvhl5.scala:20:41 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m (d > \e[31m0\e[0m) ceil(d)\
    \ \e[33melse\e[0m floor(d)\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                    Found:\
    \    Double\n\e[31m   |\e[0m                                    Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Write your\
    \ code here\n        val intval = if (value.indexOf(\".\") >= 0) value.substring(0,\
    \ value.indexOf(\".\")).toLong else value.toLong\n        if (value.indexOf(\"\
    .\") >= 0) {\n            val fracval = value.substring(value.indexOf(\".\") +\
    \ 1).toLong\n            if (fracval == 0) intval\n            else if (fracval\
    \ < 5) intval\n            else intval + 1\n        } else intval\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpshqt3j_h.scala:30)\n\tat Problem.main(tmpshqt3j_h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        round(number)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfb0h_kx8.scala:24)\n\tat Problem.main(tmpfb0h_kx8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010119
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val fValue\
    \ = value.toFloat\n        if (fValue > 0) {\n            val decimals = fValue\
    \ % 1\n            if (decimals >= 0.5) {\n                return (fValue + 1\
    \ - decimals).toLong\n            } else {\n                return (fValue - decimals).toLong\n\
    \            }\n        } else {\n            val decimals = fValue % 1\n    \
    \        if (decimals >= 0.5) {\n                return (fValue - 1 - decimals).toLong\n\
    \            } else {\n                return (fValue - decimals).toLong\n   \
    \         }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_60ubue3.scala:38)\n\tat Problem.main(tmp_60ubue3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010120
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        if (value.contains(\"\
    .\")) {\n            val left = value.substring(0, value.indexOf(\".\"))\n   \
    \         val right = value.substring(value.indexOf(\".\") + 1)\n            if\
    \ (right.forall(_ == '0')) {\n                left.toLong\n            } else\
    \ {\n                val r = left.toInt + (if (right.toInt >= 5) 1 else 0)\n \
    \               r.toLong\n            }\n        } else {\n            value.toLong\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0ktkj03t.scala:34)\n\tat Problem.main(tmp0ktkj03t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        return round(value.toDouble).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3oq9y2v6.scala:23)\n\tat Problem.main(tmp3oq9y2v6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val x = value.toDouble\n\
    \        if(x.toInt.toDouble == x) {\n            x.toInt.toLong\n        } else\
    \ {\n            if(x > 0) {\n                x.toInt.toLong + 1\n           \
    \ } else {\n                x.toInt.toLong - 1\n            }\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplf72k75e.scala:33)\n\tat Problem.main(tmplf72k75e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        return round(value.toDouble).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3oq9y2v6.scala:23)\n\tat Problem.main(tmp3oq9y2v6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var number\
    \ : Double = value.toDouble\n        var isNegative : Boolean = false\n      \
    \  if (number < 0) {\n            isNegative = true\n            number = -number\n\
    \        }\n        var integerPart : Long = (number).toLong\n        var fractionalPart\
    \ : Double = number - integerPart\n        var result : Long = integerPart\n \
    \       if (fractionalPart > 0.5) {\n            result += 1\n        }\n    \
    \    if (isNegative) {\n            result = -result\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcnb8190v.scala:37)\n\tat Problem.main(tmpcnb8190v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        BigDecimal(value).setScale(0,\
    \ BigDecimal.RoundingMode.HALF_UP).toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010120
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = value.toDouble\n        val ceil = ceil(number)\n        val floor = floor(number)\n\
    \        if (ceil - number == number - floor) {\n            if (ceil >= 0) ceil.toLong\
    \ else floor.toLong\n        } else if (ceil - number < number - floor) ceil.toLong\
    \ else floor.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpw9f19fvj.scala:19:19 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mceil\e[0m = ceil(number)\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35mceil\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpw9f19fvj.scala:20:20 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(number)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val result\
    \ = value.toDouble\n        val resultFloor = result.floor\n        val resultCeil\
    \ = result.ceil\n        if (resultFloor + 0.5 == result) resultCeil\n       \
    \ else if (resultFloor + 0.5 < result) resultCeil\n        else resultFloor\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg8fs5lx1.scala:21:41\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (resultFloor\
    \ + \e[31m0.5\e[0m == result) resultCeil\n\e[31m\e[31m   |\e[0m              \
    \                           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                        Found:    (resultCeil : Double)\n\e[31m   |\e[0m    \
    \                                     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpg8fs5lx1.scala:22:45 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (resultFloor +\
    \ \e[31m0.5\e[0m < result) resultCeil\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                         Found:    (resultCeil : Double)\n\e[31m   |\e[0m   \
    \                                      Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpg8fs5lx1.scala:23:13 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m resultFloor\n\e[31m\e[31m   |\e\
    [0m             ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:    (resultFloor\
    \ : Double)\n\e[31m   |\e[0m             Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // TODO: Implement\
    \ Me\n        return value.toLong\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmp3jd8pw7h.scala:19)\n\
    \tat Problem$.main(tmp3jd8pw7h.scala:23)\n\tat Problem.main(tmp3jd8pw7h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010122
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        if (value.endsWith(\"\
    .0\")) value.substring(0, value.length - 2).toLong\n        else {\n         \
    \   val y = value.toDouble\n            if (y > 0) ceil(y).toLong\n          \
    \  else floor(y).toLong\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoj7q2rik.scala:29)\n\tat Problem.main(tmpoj7q2rik.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010122
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var d = value.toDouble\n\
    \        if (d < 0) {\n            val n = ceil(d)\n            val f = floor(d)\n\
    \            if ((n - d) < (d - f)) n.toLong else f.toLong\n        } else {\n\
    \            val n = floor(d)\n            val f = ceil(d)\n            if ((d\
    \ - n) < (f - d)) n.toLong else f.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010123
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        val i = floor(d).toLong\n        if (i == d) {\n            i\n     \
    \   } else {\n            (i + 1)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuj9kqyaq.scala:29)\n\tat Problem.main(tmpuj9kqyaq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010123
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val floor = floor(num)\n        if (floor - num == 0.5) round(num)\n\
    \        else if (floor - num < 0.5) floor\n        else floor + 1\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4zow5zo2.scala:19:20 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mfloor\e[0m = floor(num)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mfloor\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n      val num = value.toDouble\n\
    \      val round_to_nearest_int = round(num)\n      round_to_nearest_int.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphncyw1_2.scala:25)\n\tat Problem.main(tmphncyw1_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010123
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val n = value.toDouble\n\
    \        if (value.endsWith(\".5\")) {\n            if (n < 0) ceil(n).toLong\
    \ - 1 else ceil(n).toLong\n        } else {\n            round(n).toLong\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010123
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val number\
    \ = BigDecimal(value)\n        // We add 0.5 to the number because the rounding\
    \ mode is\n        // set to 'round half to even' and this makes sure that\n \
    \       // the number is rounded up or down when the fractional\n        // part\
    \ is exactly 0.5.\n        (number + 0.5).round(new MathContext(0)).toLong\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7fwrc0t2.scala:23:33 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        (number + \e[31m0.5\e[0m).round(\e[33mnew\e[0m\
    \ \e[35mMathContext\e[0m(\e[31m0\e[0m)).toLong\n\e[31m\e[31m   |\e[0m        \
    \                         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \               Not found: type MathContext\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        return value.toDouble.round\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy2trxl15.scala:23)\n\tat Problem.main(tmpy2trxl15.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010123
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toDouble\n\
    \        if (abs(v - round(v)) < abs(v - floor(v))) round(v) else floor(v)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj6kotgo0.scala:19:70\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (abs(v\
    \ - round(v)) < abs(v - floor(v))) round(v) \e[33melse\e[0m floor(v)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \ ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                             \
    \           Found:    Double\n\e[31m   |\e[0m                                \
    \                        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010124
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Implement\
    \ Here\n        return 0\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw0wvo0k8.scala:22)\n\tat Problem.main(tmpw0wvo0k8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010123
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Your code\
    \ goes here.\n        val l = value.toLong\n        val d = value.toDouble\n \
    \       if (abs(d - l) > 0.5)\n            l + signum(d - l)\n        else\n \
    \           l\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt5qlg1r1.scala:22:12\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            l + signum(d - l)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \       Found:    Double\n\e[31m   |\e[0m            Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010123
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        if (value.isEmpty())\
    \ return 0\n        val num : Double = value.toDouble\n        var fl : Float\
    \ = (value.toFloat - num).toFloat\n        var n : Long = round(num)\n       \
    \ if (fl != 0) {\n            if (n < 0) n = n - 1\n            else n = n + 1\n\
    \        }\n        return n\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_st6vmwv.scala:31)\n\tat Problem.main(tmp_st6vmwv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toDouble\n\
    \        return round(v).toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmk5k78kq.scala:24)\n\tat Problem.main(tmpmk5k78kq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010125
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val d = value.toDouble\n\
    \        if (d > 0) floor(d + 0.5) else ceil(d - 0.5)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvtre2tr_.scala:19:24\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (d > \e\
    [31m0\e[0m) floor(d + \e[31m0.5\e[0m) \e[33melse\e[0m ceil(d - \e[31m0.5\e[0m)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                  Found:    Double\n\e[31m   |\e[0m                   Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvtre2tr_.scala:19:43\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mif\e[0m (d > \e\
    [31m0\e[0m) floor(d + \e[31m0.5\e[0m) \e[33melse\e[0m ceil(d - \e[31m0.5\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       Found:    Double\n\e[31m\
    \   |\e[0m                                       Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        BigDecimal(value).round(new\
    \ java.math.MathContext(1,java.math.RoundingMode.HALF_UP)).toLong\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp74jw_66z.scala:22)\n\tat Problem.main(tmp74jw_66z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // Convert\
    \ to BigDecimal.\n        val valueAsBigDecimal = BigDecimal(value)\n        //\
    \ Find the nearest integer.\n        val nearestInteger = valueAsBigDecimal.setScale(0,\
    \ BigDecimal.RoundingMode.HALF_UP)\n        // Return the integer.\n        nearestInteger.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010125
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        var n = BigDecimal(value)\n\
    \        if (n < 0) {\n            // round away from zero\n            BigDecimal((n\
    \ + BigDecimal(\"0.5\")).toLong)\n        } else {\n            // round away\
    \ from zero\n            BigDecimal((n - BigDecimal(\"0.5\")).toLong)\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprcsxze42.scala:21:22\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            BigDecimal((n + BigDecimal(\e\
    [31m\"0.5\"\e[0m)).toLong)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    BigDecimal\n\e[31m   |\e[0m        \
    \    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprcsxze42.scala:24:22\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            BigDecimal((n - BigDecimal(\e\
    [31m\"0.5\"\e[0m)).toLong)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    BigDecimal\n\e[31m   |\e[0m        \
    \    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        // (\"14.5\"\
    ) -> (14l, 15l)\n        val (left, right) = {\n            val parts = value.split(\"\
    \\\\.\")\n            if (parts.length == 1) (parts(0).toLong, parts(0).toLong)\n\
    \            else (parts(0).toLong, parts(0).toLong + 1)\n        }\n        val\
    \ value0 = value.toDouble\n        val dl = abs(value0 - left)\n        val dr\
    \ = abs(value0 - right)\n        if (dl < dr) left\n        else right\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi7ol54d5.scala:33)\n\tat Problem.main(tmpi7ol54d5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010125
