name: HumanEval_136_largest_smallest_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that returns a tuple (a, b), where 'a' is\n    // the\
  \ largest of negative integers, and 'b' is the smallest\n    // of positive integers\
  \ in a list.\n    // If there is no negative or positive integers, return them as\
  \ None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
  \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
  \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n   \
  \ // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
  \ : Tuple2[Option[Long], Option[Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
  \ 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong,\
  \ 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong,\
  \ 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n\
  \    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
  \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
  \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
  \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
  \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
  \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n\
  \    }\n\n}\n"
completions: ["        if (lst.isEmpty) {\n            return (Some(None), Some(None))\n\
    \        }\n        val maxMin = lst.foldLeft((None : Option[Long], None : Option[Long]))((tuple,\
    \ x) =>\n            {\n                val pos = if (x > 0) Some(x) else None\n\
    \                val neg = if (x < 0) Some(x) else None\n                (if (tuple._1\
    \ == None) neg else if (neg == None) tuple._1 else Some(max(tuple._1.get, neg.get)),\n\
    \                 if (tuple._2 == None) pos else if (pos == None) tuple._2 else\
    \ Some(min(tuple._2.get, pos.get)))\n            })\n        maxMin", "      \
    \  var sm = Long.MaxValue\n        var la = Long.MinValue\n        for (l <- lst)\
    \ {\n            if (l > 0 && l < sm) {\n                sm = l\n            }\n\
    \            if (l < 0 && l > la) {\n                la = l\n            }\n \
    \       }\n        if (sm == Long.MaxValue) {\n            return (Some(None),\
    \ Some(None))\n        }\n        if (la == Long.MinValue) {\n            return\
    \ (Some(None), Some(sm))\n        }\n        return (Some(la), Some(sm))", " \
    \       // The target list is a list of tuples. Each tuple has\n        // two\
    \ fields: the first field is the value of the integer\n        // in the original\
    \ list, and the second field is a Boolean\n        // value indicating whether\
    \ the integer is positive or\n        // negative.\n        val targetList = for\
    \ {n <- lst} yield (n, (n >= 0))\n        // Filter out the positive integers\
    \ from the target list.\n        val positiveList = targetList.filter(element\
    \ => element._2 == true)\n        // Filter out the negative integers from the\
    \ target list.\n        val negativeList = targetList.filter(element => element._2\
    \ == false)\n        // Find the smallest positive integer.\n        val minimum\
    \ = if (positiveList.length > 0) Some(positiveList.map(element => element._1).min)\
    \ else None\n        // Find the largest negative integer.\n        val maximum\
    \ = if (negativeList.length > 0) Some(negativeList.map(element => element._1).max)\
    \ else None\n        (maximum, minimum)", "      var largestNegative = None :\
    \ Option[Long]\n      var smallestPositive = None : Option[Long]\n      for (e\
    \ <- lst) {\n        if (e < 0) {\n          if (largestNegative == None) {\n\
    \            largestNegative = Some(e)\n          } else {\n            if (e\
    \ > largestNegative.get) {\n              largestNegative = Some(e)\n        \
    \    }\n          }\n        } else if (e > 0) {\n          if (smallestPositive\
    \ == None) {\n            smallestPositive = Some(e)\n          } else {\n   \
    \         if (e < smallestPositive.get) {\n              smallestPositive = Some(e)\n\
    \            }\n          }\n        }\n      }\n      (largestNegative, smallestPositive)",
  "        // Your code goes here.\n        // Replace the line below with your implementation.\n\
    \        (Some(None), Some(None))", "        var maxNegative : Option[Long] =\
    \ None\n        var minPositive : Option[Long] = None\n        for (x <- lst)\
    \ {\n            if (x < 0 && (maxNegative == None || maxNegative.get < x)) maxNegative\
    \ = Some(x)\n            if (x > 0 && (minPositive == None || minPositive.get\
    \ > x)) minPositive = Some(x)\n        }\n        (maxNegative, minPositive)",
  "        // Fill in the missing code here.\n        var result : Tuple2[Option[Long],\
    \ Option[Long]] = null\n        if (lst.isEmpty) {\n            result = (Some(None),\
    \ Some(None))\n        } else {\n            val lst1 = lst.filter(x => x < 0)\n\
    \            val lst2 = lst.filter(x => x > 0)\n            if (lst1.isEmpty)\
    \ {\n                result = (Some(None), Some(lst2.min))\n            } else\
    \ if (lst2.isEmpty) {\n                result = (Some(lst1.max), Some(None))\n\
    \            } else {\n                result = (Some(lst1.max), Some(lst2.min))\n\
    \            }\n        }\n        result", "        // Fill in the code for this\
    \ function\n        (None, None)", "        // Fill in here\n        var largest\
    \ = None:Option[Long]\n        var smallest = None:Option[Long]\n        if(lst.length\
    \ > 0) {\n            lst.foreach(x => {\n                if(x < 0) {\n      \
    \              if(largest == None) {\n                        largest = Some(x)\n\
    \                    } else {\n                        if(largest.get < x) {\n\
    \                            largest = Some(x)\n                        }\n  \
    \                  }\n                } else if(x > 0) {\n                   \
    \ if(smallest == None) {\n                        smallest = Some(x)\n       \
    \             } else {\n                        if(smallest.get > x) {\n     \
    \                       smallest = Some(x)\n                        }\n      \
    \              }\n                }\n            })\n        }\n        (largest,\
    \ smallest)", "        // Fill-in the necessary code here\n        val negs =\
    \ lst.filter(_ < 0)\n        val poss = lst.filter(_ > 0)\n        (negs.isEmpty\
    \ match {\n            case true => Some(None)\n            case false => Some(negs.max)\n\
    \        }, poss.isEmpty match {\n            case true => Some(None)\n      \
    \      case false => Some(poss.min)\n        })", "        // This function will\
    \ be entered n times, where n is the number of elements in\n        // the list.\
    \ Therefor, the complexity is O(n).\n        (if (lst.exists(_ < 0)) Some(lst.filter(_\
    \ < 0).max) else None,\n         if (lst.exists(_ > 0)) Some(lst.filter(_ > 0).min)\
    \ else None)", "        // Fill in the code here\n        var maxNeg: Option[Long]\
    \ = None\n        var minPos: Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i > 0) {\n                if (minPos.isEmpty) {\n           \
    \         minPos = Some(i)\n                } else {\n                    minPos\
    \ = minPos.map(min => min.min(i))\n                }\n            } else if (i\
    \ < 0) {\n                if (maxNeg.isEmpty) {\n                    maxNeg =\
    \ Some(i)\n                } else {\n                    maxNeg = maxNeg.map(max\
    \ => max.max(i))\n                }\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        def f(acc : Tuple2[Option[Long], Option[Long]], x : Long)\
    \ : Tuple2[Option[Long], Option[Long]] = acc match {\n            case (None,\
    \ None) => if (x > 0) (None, Some(x)) else (Some(x), None)\n            case (Some(a),\
    \ None) => if (x > 0) (Some(a), Some(x)) else (Some(max(a, x)), None)\n      \
    \      case (None, Some(b)) => if (x > 0) (Some(min(b, x)), Some(b)) else (Some(x),\
    \ Some(b))\n            case (Some(a), Some(b)) => if (x > 0) (Some(a), Some(min(b,\
    \ x))) else (Some(max(a, x)), Some(b))\n        }\n        if (lst.isEmpty) (None,\
    \ None) else lst.foldLeft(None, None)(f)", "        if (lst.size == 0) return\
    \ (Some(None), Some(None))\n        val positives = new HashSet[Long]\n      \
    \  val negatives = new HashSet[Long]\n        for (x <- lst) {\n            if\
    \ (x > 0) positives += x\n            else if (x < 0) negatives += x\n       \
    \ }\n        if (positives.size == 0) return (Some(None), Some(None))\n      \
    \  if (negatives.size == 0) return (Some(None), Some(positives.min))\n       \
    \ return (Some(negatives.max), Some(positives.min))", "        val min = lst.filter(i\
    \ => i > 0).min\n        val max = lst.filter(i => i < 0).max\n        val minO\
    \ = if (min == null) None else Some(min)\n        val maxO = if (max == null)\
    \ None else Some(max)\n        (maxO, minO)", "        // Your solution here\n\
    \        var min = Long.MaxValue\n        var max = Long.MinValue\n        for\
    \ (i <- lst) {\n            min = min min i\n            max = max max i\n   \
    \     }\n        if (min >= 0) {\n            return (None, Some(min))\n     \
    \   }\n        if (max <= 0) {\n            return (Some(max), None)\n       \
    \ }\n        (Some(max), Some(min))", "\t\t// Find the largest negative integer:\n\
    \t\tval largestNegativeInt : Option[Long] = {\n\t\t\tval neg : List[Long] = lst.filter(x\
    \ => x < 0)\n\t\t\tif (neg.isEmpty) {\n\t\t\t\tNone\n\t\t\t} else {\n\t\t\t\t\
    Some(neg.max)\n\t\t\t}\n\t\t}\n\t\t// Find the smallest positive integer:\n\t\t\
    val smallestPositiveInt : Option[Long] = {\n\t\t\tval pos : List[Long] = lst.filter(x\
    \ => x > 0)\n\t\t\tif (pos.isEmpty) {\n\t\t\t\tNone\n\t\t\t} else {\n\t\t\t\t\
    Some(pos.min)\n\t\t\t}\n\t\t}\n\t\t(largestNegativeInt, smallestPositiveInt)",
  "        // Your code here\n        null", "        // define the initial value\
    \ (None, None)\n        var result = (None: Option[Long], None: Option[Long])\n\
    \        // initialize to empty list\n        var lstNeg = List[Long]()\n    \
    \    var lstPos = List[Long]()\n        for (i <- lst) {\n            // for negative\n\
    \            if (i < 0) lstNeg = lstNeg :+ i\n            // for positive\n  \
    \          if (i > 0) lstPos = lstPos :+ i\n        }\n        // if not empty,\n\
    \        if (!lstNeg.isEmpty) result = (Some(lstNeg.max), result._2)\n       \
    \ if (!lstPos.isEmpty) result = (result._1, Some(lstPos.min))\n        // return\n\
    \        result", "        // Fill up this function body\n        // 'None' is\
    \ represented as a 'null' value\n        // You can modify the function signature\
    \ as you wish\n        // You can add more 'implicit' functions if it eases your\
    \ task\n        // More explicit hints are given inline\n        // Hint: The\
    \ use of 'foldLeft' and 'foldRight' is discouraged.\n        //       The use\
    \ of 'reduceLeft' and 'reduceRight' is also discouraged.\n        // Hint: If\
    \ you want to use a mutable structure, use the\n        //       'ArrayBuffer'\
    \ data structure\n        val positiveList = ArrayBuffer[Long]()\n        val\
    \ negativeList = ArrayBuffer[Long]()\n        for (i <- lst) {\n            if\
    \ (i > 0) positiveList += i\n            else if (i < 0) negativeList += i\n \
    \       }\n        (positiveList.size match { case 0 => None; case _ => Some(positiveList.min)\
    \ },\n         negativeList.size match { case 0 => None; case _ => Some(negativeList.max)\
    \ })", "        // Implement me!\n        var largest : Option[Long] = None\n\
    \        var smallest : Option[Long] = None\n        lst.foreach { num =>\n  \
    \          if (num < 0) {\n                if (largest.isEmpty || largest.get\
    \ < num) {\n                    largest = Some(num)\n                }\n     \
    \       } else if (num > 0) {\n                if (smallest.isEmpty || smallest.get\
    \ > num) {\n                    smallest = Some(num)\n                }\n    \
    \        }\n        }\n        (largest, smallest)", '        // Write your code
    here.', "        var positiveValues = ArrayBuffer[Long]()\n        var negativeValues\
    \ = ArrayBuffer[Long]()\n        for (item <- lst) {\n            if (item > 0)\
    \ positiveValues += item\n            else if (item < 0) negativeValues += item\n\
    \        }\n        (if (negativeValues.length > 0) Some(negativeValues.min) else\
    \ None, if (positiveValues.length > 0) Some(positiveValues.min) else None)", '      //
    Write your code here', "        var lstNeg : List[Long] = List()\n        var\
    \ lstPos : List[Long] = List()\n        for (num <- lst) {\n            if (num\
    \ > 0) {\n                lstPos = lstPos :+ num\n            } else if (num <\
    \ 0) {\n                lstNeg = lstNeg :+ num\n            }\n        }\n   \
    \     var res1 : Option[Long] = null\n        var res2 : Option[Long] = null\n\
    \        if (lstNeg.length > 0) {\n            res1 = Some(lstNeg.max)\n     \
    \   } else {\n            res1 = None\n        }\n        if (lstPos.length >\
    \ 0) {\n            res2 = Some(lstPos.min)\n        } else {\n            res2\
    \ = None\n        }\n        (res1, res2)", "        // Fill in your code here\n\
    \        if (lst.length > 0) {\n            val negs = lst.filter(_ < 0)\n   \
    \         val pos = lst.filter(_ > 0)\n            var a : Option[Long] = None\n\
    \            var b : Option[Long] = None\n            if (negs.length > 0) a =\
    \ Some(negs.reduceLeft(_ max _))\n            if (pos.length > 0) b = Some(pos.reduceLeft(_\
    \ min _))\n            return (a, b)\n        }\n        return (Some(None), Some(None))",
  "        val s = lst.filter(v => v > 0)\n        val l = lst.filter(v => v < 0)\n\
    \        var min = None : Option[Long]\n        var max = None : Option[Long]\n\
    \        if (s.length > 0) min = Some(s.min)\n        if (l.length > 0) max =\
    \ Some(l.max)\n        return (max, min)", "        val larg = lst.filter(_ <\
    \ 0l).maxOption\n        val smal = lst.filter(_ > 0l).minOption\n        return\
    \ (larg, smal)", '        return (Some(None), Some(None))', "      // (largest\
    \ negative integer, smallest positive integer)\n      var tuple = (None, None)\n\
    \      if (!lst.isEmpty) {\n        // Iterate through list.\n        // If element\
    \ > 0 and < smallest positive integer,\n        // set smallest positive integer\
    \ to element.\n        // If element < 0 and > largest negative integer,\n   \
    \     // set largest negative integer to element.\n        for (i <- lst) {\n\
    \          if (i > 0) {\n            if (tuple._2 == None) {\n              tuple\
    \ = (tuple._1, Some(i))\n            } else if (i < tuple._2.get) {\n        \
    \      tuple = (tuple._1, Some(i))\n            }\n          } else if (i < 0)\
    \ {\n            if (tuple._1 == None) {\n              tuple = (Some(i), tuple._2)\n\
    \            } else if (i > tuple._1.get) {\n              tuple = (Some(i), tuple._2)\n\
    \            }\n          }\n        }\n      }\n      return tuple", "      var\
    \ largest : Option[Long] = None\n      var smallest : Option[Long] = None\n  \
    \    for (i <- lst) {\n        largest = if (largest == None) {\n          if\
    \ (i < 0) Some(i) else None\n        } else {\n          if (i < 0 && i > largest.get)\
    \ Some(i) else largest\n        }\n        smallest = if (smallest == None) {\n\
    \          if (i > 0) Some(i) else None\n        } else {\n          if (i > 0\
    \ && i < smallest.get) Some(i) else smallest\n        }\n      }\n      (largest,\
    \ smallest)", '        // Fill in the code here', "        // The first tuple\
    \ value is the largest negative integer.\n        // The second tuple value is\
    \ the smallest positive integer.\n        var largestSmallest : Tuple2[Option[Long],\
    \ Option[Long]] = (None, None)\n        lst.foreach(x => {\n            if (x\
    \ < 0) {\n                largestSmallest = (largestSmallest._1 match {\n    \
    \                case None => Some(x)\n                    case Some(y) => Some(max(x,\
    \ y))\n                }, largestSmallest._2)\n            } else if (x > 0) {\n\
    \                largestSmallest = (largestSmallest._1, largestSmallest._2 match\
    \ {\n                    case None => Some(x)\n                    case Some(y)\
    \ => Some(min(x, y))\n                })\n            }\n        })\n        largestSmallest",
  "        if (lst.isEmpty) (Some(None), Some(None))\n        else {\n           \
    \ var neg = List[Long]()\n            var pos = List[Long]()\n            lst.foreach(a\
    \ => {\n                if (a < 0) neg = a :: neg\n                else if (a\
    \ > 0) pos = a :: pos\n            })\n            (Some(neg.max), Some(pos.min))\n\
    \        }", "        if (lst.isEmpty) return (Some(None), Some(None))\n     \
    \   var negMax : Long = 0\n        var posMin : Long = 10000000000000000000L\n\
    \        var negMaxFound : Boolean = false\n        var posMinFound : Boolean\
    \ = false\n        for (i <- lst) {\n            if (i > 0) {\n              \
    \  if (i < posMin) {\n                    posMin = i\n                    posMinFound\
    \ = true\n                }\n            } else {\n                if (i > negMax)\
    \ {\n                    negMax = i\n                    negMaxFound = true\n\
    \                }\n            }\n        }\n        if (negMaxFound) return\
    \ (Some(negMax), Some(posMin))\n        if (posMinFound) return (Some(None), Some(posMin))\n\
    \        return (Some(None), Some(None))", "        val sorted = lst.sorted\n\
    \        val min = sorted.filter(v => v > 0).headOption\n        val max = sorted.filter(v\
    \ => v < 0).lastOption\n        (max, min)", "      // Write your code below.\n\
    \      // You can add more functions and variables as you need.\n      // Do not\
    \ change the function name, or function parameters.\n      \n      // Began with\
    \ a tuple of (Some(None), Some(None)) to represent the case of an empty list.\n\
    \      var tuple = (Some(None), Some(None))\n      // Loop through the list.\n\
    \      for (element <- lst) {\n        // Check if the element is negative, if\
    \ so store it if it is the largest negative number.\n        if (element < 0)\
    \ {\n          if (tuple._1.getOrElse(Some(None)) == Some(None)) {\n         \
    \   tuple = (Some(element), tuple._2)\n          } else if (tuple._1.getOrElse(Some(None))\
    \ < Some(element)) {\n            tuple = (Some(element), tuple._2)\n        \
    \  }\n        // Check if the element is positive, if so store it if it is the\
    \ smallest positive number.\n        } else if (element > 0) {\n          if (tuple._2.getOrElse(Some(None))\
    \ == Some(None)) {\n            tuple = (tuple._1, Some(element))\n          }\
    \ else if (tuple._2.getOrElse(Some(None)) > Some(element)) {\n            tuple\
    \ = (tuple._1, Some(element))\n          }\n        }\n      }\n      // Return\
    \ the tuple.\n      tuple", "        val l : List[Long] = lst.filter(x => x >\
    \ 0)\n        val s : List[Long] = lst.filter(x => x < 0)\n        val b : Option[Long]\
    \ = if (l.length == 0) None else Some(l.min)\n        val a : Option[Long] = if\
    \ (s.length == 0) None else Some(s.max)\n        return (a, b)", "        var\
    \ largest : Option[Long] = None\n        var smallest : Option[Long] = None\n\
    \        for (i <- lst) {\n            largest = Some(max(i, largest.getOrElse(0)))\n\
    \            smallest = Some(min(i, smallest.getOrElse(0)))\n        }\n     \
    \   (largest, smallest)", "        var lrg = Some(None)\n        var sml = Some(None)\n\
    \        for (value <- lst) {\n            if (value > 0) {\n                sml\
    \ = Some(sml.get.fold[Long](value)(min(_, value)))\n            } else if (value\
    \ < 0) {\n                lrg = Some(lrg.get.fold[Long](value)(max(_, value)))\n\
    \            }\n        }\n        return (lrg, sml)", '        Tuple2(None, None)',
  '        return (None, None)', "        // Write your code here\n        return\
    \ (Some(None), Some(None))", "        var negativeList = new ArrayBuffer[Long]()\n\
    \        var positiveList = new ArrayBuffer[Long]()\n        for (i <- lst) {\n\
    \            if (i > 0) {\n                positiveList += i\n            } else\
    \ if (i < 0) {\n                negativeList += i\n            }\n        }\n\
    \        var r1 = if (negativeList.length == 0) None else Some(negativeList.max)\n\
    \        var r2 = if (positiveList.length == 0) None else Some(positiveList.min)\n\
    \        Tuple2(r1, r2)", '        (None, None)', "        //TODO\n        (None,\
    \ None)", "        lst.filter(x => x > 0).minOption match {\n            case\
    \ Some(smallest) => lst.filter(x => x < 0).maxOption match {\n               \
    \ case Some(largest) => (Some(largest), Some(smallest))\n                case\
    \ None => (Some(None), Some(smallest))\n            }\n            case None =>\
    \ lst.filter(x => x < 0).maxOption match {\n                case Some(largest)\
    \ => (Some(largest), Some(None))\n                case None => (Some(None), Some(None))\n\
    \            }\n        }", "        if (lst.isEmpty) {\n            (Some(None),\
    \ Some(None))\n        } else {\n            var lstn, lstp : List[Long] = Nil\n\
    \            lst.foreach(x => if (x > 0) lstp = x :: lstp else if (x < 0) lstn\
    \ = x :: lstn)\n            (Some(if (lstn.isEmpty) None else Some(lstn.max)),\
    \ Some(if (lstp.isEmpty) None else Some(lstp.min)))\n        }", "        val\
    \ (neg, pos) = lst.partition(_ < 0)\n        return (if (neg.isEmpty) None else\
    \ Some(neg.max), if (pos.isEmpty) None else Some(pos.min))", "        var maxNegative\
    \ : Option[Long] = None\n        var minPositive : Option[Long] = None\n     \
    \   var lstNeg : List[Long] = List()\n        var lstPos : List[Long] = List()\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                lstNeg =\
    \ lstNeg :+ i\n            } else if (i > 0) {\n                lstPos = lstPos\
    \ :+ i\n            }\n        }\n        if (lstNeg.size > 0) {\n           \
    \ maxNegative = Some(lstNeg.max)\n        }\n        if (lstPos.size > 0) {\n\
    \            minPositive = Some(lstPos.min)\n        }\n        (maxNegative,\
    \ minPositive)", "        var neg = Option.empty[Long]\n        var pos = Option.empty[Long]\n\
    \        for (x <- lst) {\n            if (x < 0) neg = Some(max(x, neg.getOrElse(Long.MinValue)))\n\
    \            if (x > 0) pos = Some(min(x, pos.getOrElse(Long.MaxValue)))\n   \
    \     }\n        (neg, pos)", "        val list = lst.filter(x => x != 0)\n  \
    \      val answer = (\n            if (list.size > 0) {\n                val neg\
    \ = list.filter(x => x < 0)\n                if (neg.size > 0) {\n           \
    \         Some(neg.max)\n                } else {\n                    None\n\
    \                }\n            } else {\n                None\n            },\n\
    \            if (list.size > 0) {\n                val pos = list.filter(x =>\
    \ x > 0)\n                if (pos.size > 0) {\n                    Some(pos.min)\n\
    \                } else {\n                    None\n                }\n     \
    \       } else {\n                None\n            }\n        )\n        answer",
  "        // Your code here!\n        val negatives = lst.filter(x => x < 0)\n  \
    \      val positives = lst.filter(x => x > 0)\n        var ans : Tuple2[Option[Long],\
    \ Option[Long]] = (Some(None), Some(None))\n        if (negatives.length > 0)\
    \ {\n            ans = (Some(negatives.max), ans._2)\n        }\n        if (positives.length\
    \ > 0) {\n            ans = (ans._1, Some(positives.min))\n        }\n       \
    \ ans", '      return ((None, None))', "        var small = Option.empty[Long]\n\
    \        var large = Option.empty[Long]\n        for (i <- lst) {\n          \
    \  if (i < 0) {\n                if (large.isEmpty) large = Some(i)\n        \
    \        else large = Some(max(large.get, i))\n            }\n            else\
    \ if (i > 0) {\n                if (small.isEmpty) small = Some(i)\n         \
    \       else small = Some(min(small.get, i))\n            }\n        }\n     \
    \   return (large, small)", "        val x = lst.filter(x => x < 0)\n        val\
    \ y = lst.filter(x => x > 0)\n        var max = None: Option[Long]\n        var\
    \ min = None: Option[Long]\n        if (x.length > 0) {\n            max = Some(x.max)\n\
    \        }\n        if (y.length > 0) {\n            min = Some(y.min)\n     \
    \   }\n        (max, min)", "        if (lst.isEmpty) return (Some(None), Some(None))\n\
    \        val neg = lst.filter(x => x < 0).sortWith(_ > _)\n        val pos = lst.filter(x\
    \ => x > 0).sortWith(_ < _)\n        return (Some(neg.firstOption.getOrElse(None)),\
    \ Some(pos.firstOption.getOrElse(None)))", "        var positiveMin : Option[Long]\
    \ = None\n        var negativeMax : Option[Long] = None\n        for (e <- lst)\
    \ {\n            if (e >= 0) {\n                if (positiveMin == None) positiveMin\
    \ = Some(e)\n                else if (e < positiveMin.get) positiveMin = Some(e)\n\
    \            }\n            else {\n                if (negativeMax == None) negativeMax\
    \ = Some(e)\n                else if (e > negativeMax.get) negativeMax = Some(e)\n\
    \            }\n        }\n        (negativeMax, positiveMin)", "        var minPos\
    \ : Option[Long] = None\n        var maxNeg : Option[Long] = None\n        for\
    \ (e <- lst) {\n            if (e < 0) {\n                if (maxNeg.isEmpty)\
    \ {\n                    maxNeg = Some(e)\n                } else {\n        \
    \            if (e > maxNeg.get) {\n                        maxNeg = Some(e)\n\
    \                    }\n                }\n            } else if (e > 0) {\n \
    \               if (minPos.isEmpty) {\n                    minPos = Some(e)\n\
    \                } else {\n                    if (e < minPos.get) {\n       \
    \                 minPos = Some(e)\n                    }\n                }\n\
    \            }\n        }\n        return (maxNeg, minPos)", "        var largestOfNegatives\
    \ : Option[Long] = None\n        var smallestOfPositives : Option[Long] = None\n\
    \        for (x <- lst) {\n            if (x > 0) {\n                if (smallestOfPositives\
    \ == None) smallestOfPositives = Some(x)\n                else if (x < smallestOfPositives.get)\
    \ smallestOfPositives = Some(x)\n            }\n            else if (x < 0) {\n\
    \                if (largestOfNegatives == None) largestOfNegatives = Some(x)\n\
    \                else if (x > largestOfNegatives.get) largestOfNegatives = Some(x)\n\
    \            }\n        }\n        (largestOfNegatives, smallestOfPositives)",
  "        var smallest = 0l\n        var largest = 0l\n        var smallestFound\
    \ = false\n        var largestFound = false\n        for (i <- lst) {\n      \
    \      if (i < 0) {\n                if (!largestFound) {\n                  \
    \  largest = i\n                    largestFound = true\n                } else\
    \ {\n                    if (i > largest) largest = i\n                }\n   \
    \         } else if (i > 0) {\n                if (!smallestFound) {\n       \
    \             smallest = i\n                    smallestFound = true\n       \
    \         } else {\n                    if (i < smallest) smallest = i\n     \
    \           }\n            }\n        }\n        if (largestFound) (Some(largest),\
    \ if (smallestFound) Some(smallest) else None)\n        else (None, if (smallestFound)\
    \ Some(smallest) else None)", "        val negs = lst.filter(x => x < 0)\n   \
    \     val poss = lst.filter(x => x > 0)\n        val larg = if (negs.length >\
    \ 0) Some(negs.max) else None\n        val smal = if (poss.length > 0) Some(poss.min)\
    \ else None\n        return (larg, smal)", "        // This function will be used\
    \ to collect the minimum and maximum\n        // value of the list. If a value\
    \ is larger than the current maximum,\n        // or is less than the current\
    \ minimum, then it will replace either\n        // the minimum or maximum value.\n\
    \        def f(acc : Tuple2[Option[Long], Option[Long]], x : Long) : Tuple2[Option[Long],\
    \ Option[Long]] = {\n            if (acc._1 == None && acc._2 == None) {\n   \
    \             if (x < 0) (Some(x), None)\n                else if (x > 0) (None,\
    \ Some(x))\n                else acc\n            }\n            else if (acc._1\
    \ == None) {\n                if (x < 0) (Some(x), acc._2)\n                else\
    \ if (x > 0 && x < acc._2.get) (acc._1, Some(x))\n                else acc\n \
    \           }\n            else if (acc._2 == None) {\n                if (x >\
    \ 0) (acc._1, Some(x))\n                else if (x < 0 && x > acc._1.get) (Some(x),\
    \ acc._2)\n                else acc\n            }\n            else {\n     \
    \           if (x < 0 && x > acc._1.get) (Some(x), acc._2)\n                else\
    \ if (x > 0 && x < acc._2.get) (acc._1, Some(x))\n                else acc\n \
    \           }\n        }\n        lst.foldLeft((None : Option[Long], None : Option[Long]))(f)",
  "        // Create a function that returns the largest negative integer and\n  \
    \      // smallest positive integer from a List[Long].\n        // If there is\
    \ no negative or positive integers, return them as None.\n        def largestSmallestIntegers(lst\
    \ : List[Long]) : Tuple2[Option[Long], Option[Long]] = {\n            // Define\
    \ the maximum long value.\n            val maxLong = Long.MaxValue\n         \
    \   // Initialize the largest negative integer and smallest positive integer\n\
    \            // as the maximum long value.\n            var largestNegativeInteger\
    \ = maxLong\n            var smallestPositiveInteger = maxLong\n            //\
    \ For each element in the list...\n            for (i <- lst) {\n            \
    \    // If the current element is less than 0, update the largest negative integer.\n\
    \                if (i < 0) {\n                    if (i > largestNegativeInteger)\
    \ largestNegativeInteger = i\n                }\n                // If the current\
    \ element is greater than 0, update the smallest positive integer.\n         \
    \       else if (i > 0) {\n                    if (i < smallestPositiveInteger)\
    \ smallestPositiveInteger = i\n                }\n            }\n            //\
    \ If the largest negative integer is the max long value, update it to None.\n\
    \            if (largestNegativeInteger == maxLong) largestNegativeInteger = None\n\
    \            // If the smallest positive integer is the max long value, update\
    \ it to None.\n            if (smallestPositiveInteger == maxLong) smallestPositiveInteger\
    \ = None\n            // Return a tuple containing the largest negative integer\
    \ and smallest positive integer.\n            (largestNegativeInteger, smallestPositiveInteger)\n\
    \        }\n        // Return the call to the inner function.\n        largestSmallestIntegers(lst)",
  "        // Your code here.\n        var maxNeg = Option(Long.MinValue)\n      \
    \  var minPos = Option(Long.MaxValue)\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (i > maxNeg.get) {\n                    maxNeg\
    \ = Option(i)\n                }\n            } else if (i > 0) {\n          \
    \      if (i < minPos.get) {\n                    minPos = Option(i)\n       \
    \         }\n            }\n        }\n        if (maxNeg.get == Long.MinValue)\
    \ {\n            maxNeg = None\n        }\n        if (minPos.get == Long.MaxValue)\
    \ {\n            minPos = None\n        }\n        return (maxNeg, minPos)", " \
    \       var hasPositive = false\n        var hasNegative = false\n        var\
    \ min = 0l\n        var max = 0l\n        for (i <- lst) {\n            if (i\
    \ > 0) {\n                hasPositive = true\n                if (i < min || min\
    \ == 0) min = i\n            }\n            if (i < 0) {\n                hasNegative\
    \ = true\n                if (i > max || max == 0) max = i\n            }\n  \
    \      }\n        if (hasPositive) (if (hasNegative) Some(max) else None, Some(min))\
    \ else (if (hasNegative) Some(max) else None, None)", "      val sortedList =\
    \ lst.sortWith(_ > _)\n      val positiveList = sortedList.filter(_ > 0)\n   \
    \   val negativeList = sortedList.filter(_ < 0)\n      if (positiveList.length\
    \ == 0) {\n        return (Some(negativeList.head), Some(Long.MinValue))\n   \
    \   }\n      if (negativeList.length == 0) {\n        return (Some(Long.MaxValue),\
    \ Some(positiveList.head))\n      }\n      return (Some(negativeList.head), Some(positiveList.head))",
  "        // Fill the following code\n        (None, None)", "        var min = Double.MaxValue;\n\
    \        var max = Double.MinValue;\n        for (e <- lst) {\n            if\
    \ (e < 0 && e > max) {\n                max = e;\n            }\n            if\
    \ (e > 0 && e < min) {\n                min = e;\n            }\n        }\n \
    \       if (min == Double.MaxValue) {\n            (Some(None), Some(None))\n\
    \        } else if (max == Double.MinValue) {\n            (Some(None), Some(min.toLong))\n\
    \        } else {\n            (Some(max.toLong), Some(min.toLong))\n        }",
  "        var l = List[Long]()\n        var s = List[Long]()\n        lst.foreach\
    \ { x => if (x < 0) l = x :: l else if (x > 0) s = x :: s }\n        (l.headOption,\
    \ s.headOption)", "        // TODO: Implement Me!\n        var amax = -999999999999999999L\n\
    \        var amin = 999999999999999999L\n        var bmax = -999999999999999999L\n\
    \        var bmin = 999999999999999999L\n        for (num <- lst) {\n        \
    \    if (num > 0) {\n                amin = min(num, amin)\n            } else\
    \ if (num < 0) {\n                amax = max(num, amax)\n            }\n     \
    \   }\n        if (amin == 999999999999999999L) {\n            bmin = None\n \
    \       } else {\n            bmin = Some(amin)\n        }\n        if (amax ==\
    \ -999999999999999999L) {\n            bmax = None\n        } else {\n       \
    \     bmax = Some(amax)\n        }\n        return (bmax, bmin)", "        var\
    \ neg = List[Long]()\n        var pos = List[Long]()\n        lst.foreach {i =>\
    \ if (i > 0) pos ::= i else if (i < 0) neg ::= i}\n        return (neg.sortWith((a,\
    \ b) => a > b).headOption, pos.sortWith((a, b) => a < b).headOption)", "     \
    \   val pos = new ListBuffer[Long]\n        val neg = new ListBuffer[Long]\n \
    \       for (i <- lst) {\n            if (i < 0) {\n                neg += i\n\
    \            } else if (i > 0) {\n                pos += i\n            }\n  \
    \      }\n        if (neg.length == 0) {\n            (None, if (pos.length >\
    \ 0) Some(pos.min) else None)\n        } else if (pos.length == 0) {\n       \
    \     (Some(neg.max), None)\n        } else {\n            (Some(neg.max), Some(pos.min))\n\
    \        }", '        return (None, None)', "        lst.filter(_ > 0).sorted.headOption\
    \ match {\n            case Some(a) => {\n                lst.filter(_ < 0).sorted.reverse.headOption\
    \ match {\n                    case Some(b) => Tuple2(Some(b), Some(a))\n    \
    \                case None => Tuple2(Some(None), Some(a))\n                }\n\
    \            }\n            case None => {\n                lst.filter(_ < 0).sorted.reverse.headOption\
    \ match {\n                    case Some(b) => Tuple2(Some(b), Some(None))\n \
    \                   case None => Tuple2(Some(None), Some(None))\n            \
    \    }\n            }\n        }", "        // Fill in the below function body.\n\
    \        val lst1 = lst.filter(_ > 0)\n        val lst2 = lst.filter(_ < 0)\n\
    \        if (lst1.isEmpty && lst2.isEmpty) (None, None)\n        else if (lst1.isEmpty)\
    \ (Some(lst2.max), None)\n        else if (lst2.isEmpty) (None, Some(lst1.min))\n\
    \        else (Some(lst2.max), Some(lst1.min))", '        return (None, None)',
  "        var min : Option[Long] = None\n        var max : Option[Long] = None\n\
    \        for (n <- lst) {\n            if (n > 0) {\n                if (min ==\
    \ None) {\n                    min = Some(n)\n                } else {\n     \
    \               min = if (n < min.get) Some(n) else min\n                }\n \
    \           } else if (n < 0) {\n                if (max == None) {\n        \
    \            max = Some(n)\n                } else {\n                    max\
    \ = if (n > max.get) Some(n) else max\n                }\n            }\n    \
    \    }\n        (max, min)", "        // Fill in here\n        var neg : List[Long]\
    \ = Nil\n        var pos : List[Long] = Nil\n        for (i <- lst) {\n      \
    \      if (i > 0) pos ::= i\n            else if (i < 0) neg ::= i\n        }\n\
    \        val largestNeg = neg match {\n            case Nil => None\n        \
    \    case h :: t => {\n                var largest = h\n                for (i\
    \ <- t) if (i > largest) largest = i\n                Some(largest)\n        \
    \    }\n        }\n        val smallestPos = pos match {\n            case Nil\
    \ => None\n            case h :: t => {\n                var smallest = h\n  \
    \              for (i <- t) if (i < smallest) smallest = i\n                Some(smallest)\n\
    \            }\n        }\n        (largestNeg, smallestPos)", "        val pos\
    \ = lst.filter(x => x > 0)\n        val neg = lst.filter(x => x < 0)\n       \
    \ val posMin = pos.length match {\n            case 0 => None\n            case\
    \ _ => Some(pos.min)\n        }\n        val negMax = neg.length match {\n   \
    \         case 0 => None\n            case _ => Some(neg.max)\n        }\n   \
    \     return (negMax, posMin)", "        var minPos = (Long.MaxValue, 0l)\n  \
    \      var maxNeg = (Long.MinValue, 0l)\n        for (value <- lst) {\n      \
    \      if (value > 0) {\n                if (value < minPos._1) {\n          \
    \          minPos = (value, 1l)\n                }\n            } else if (value\
    \ < 0) {\n                if (value > maxNeg._1) {\n                    maxNeg\
    \ = (value, 1l)\n                }\n            }\n        }\n        return (if\
    \ (maxNeg._2 == 1l) Some(maxNeg._1) else None, if (minPos._2 == 1l) Some(minPos._1)\
    \ else None)", "        var negativeMax = Option.empty[Long]\n        var positiveMin\
    \ = Option.empty[Long]\n        for (n <- lst) {\n            if (n > 0) {\n \
    \               if (positiveMin.isEmpty) positiveMin = Some(n)\n             \
    \   else positiveMin = Some(min(positiveMin.get, n))\n            }\n        \
    \    else if (n < 0) {\n                if (negativeMax.isEmpty) negativeMax =\
    \ Some(n)\n                else negativeMax = Some(max(negativeMax.get, n))\n\
    \            }\n        }\n        return (negativeMax, positiveMin)", "     \
    \   var largestNeg = Option.empty[Long]\n        var smallestPos = Option.empty[Long]\n\
    \        for (e <- lst) {\n            if (e < 0) largestNeg = Some(max(largestNeg.getOrElse(e),\
    \ e))\n            else if (e > 0) smallestPos = Some(min(smallestPos.getOrElse(e),\
    \ e))\n        }\n        (largestNeg, smallestPos)", "        val neg = ListBuffer[Long]()\n\
    \        val pos = ListBuffer[Long]()\n        for (x <- lst) {\n            if\
    \ (x > 0) pos += x\n            else if (x < 0) neg += x\n        }\n        (if\
    \ (neg.isEmpty) None else Some(neg.max), if (pos.isEmpty) None else Some(pos.min))",
  "        // Add code here\n        val positives = lst.filter((x : Long) => x >\
    \ 0)\n        val negatives = lst.filter((x : Long) => x < 0)\n        (if (negatives.isEmpty)\
    \ None else Some(negatives.max), if (positives.isEmpty) None else Some(positives.min))",
  "        if (lst.size == 0) return (Some(None), Some(None))\n        val poss =\
    \ lst.filter(x => x > 0)\n        val negs = lst.filter(x => x < 0)\n        val\
    \ largestNeg = (Some(negs.max), Some(negs.min))\n        val smallestPos = (Some(poss.max),\
    \ Some(poss.min))\n        if (largestNeg._1 == None) return (largestNeg._1, smallestPos._2)\n\
    \        else if (smallestPos._2 == None) return (largestNeg._2, smallestPos._2)\n\
    \        else (largestNeg._2, smallestPos._2)", "      var positive : Option[Long]\
    \ = None\n      var negative : Option[Long] = None\n      for (n <- lst) {\n \
    \       if (n > 0) positive = Some(n)\n        if (n < 0) negative = Some(n)\n\
    \      }\n      (negative, positive)", "        val negative = lst.filter(_ <\
    \ 0).sorted\n        val positive = lst.filter(_ > 0).sorted\n        val maxNegative\
    \ = if (negative.length == 0) None else Some(negative.head)\n        val minPositive\
    \ = if (positive.length == 0) None else Some(positive.head)\n        (maxNegative,\
    \ minPositive)", "        val xs = lst.filter(i => i < 0).sortWith(_ > _)\n  \
    \      val ys = lst.filter(i => i > 0).sortWith(_ < _)\n        val zs = lst.filter(i\
    \ => i == 0)\n        val a = if (xs.length > 0) Some(xs(0)) else None\n     \
    \   val b = if (ys.length > 0) Some(ys(0)) else None\n        Tuple2(a, b)", '        //
    TODO: Implement me!', "        // your solution here\n        null", '        return
    (None, None)', "        // TODO: Provide an implementation for this function\n\
    \        return (None, None)", "      // TODO - fill in the code here\n      var\
    \ l = 0L\n      var s = 0L\n      var find = false\n      for (i <- lst) {\n \
    \       if (i > 0) {\n          if (!find) {\n            find = true\n      \
    \      s = i\n          } else {\n            if (i < s) {\n              s =\
    \ i\n            }\n          }\n        } else {\n          if (i > l) {\n  \
    \          l = i\n          }\n        }\n      }\n      if (find) {\n       \
    \ (Some(l), Some(s))\n      } else {\n        (Some(None), Some(None))\n     \
    \ }", "        // Fill in the code here.\n        var largest : Option[Long] =\
    \ None\n        var smallest : Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i > 0) {\n                if (smallest == None) smallest = Some(i)\n\
    \                else if (i < smallest.get) smallest = Some(i)\n            }\n\
    \            else if (i < 0) {\n                if (largest == None) largest =\
    \ Some(i)\n                else if (i > largest.get) largest = Some(i)\n     \
    \       }\n        }\n        (largest, smallest)", '        (lst.filter(_ < 0).reduceOption((a,
    b) => max(a, b)), lst.filter(_ > 0).reduceOption((a, b) => min(a, b)))', '        //implement
    your solution here', '        return (Some(None), Some(None))', "        val sortedLst\
    \ = lst.sortWith(_ < _)\n        return (None, None)", "        // Initialize\n\
    \        var a: Option[Long] = Some(None)\n        var b: Option[Long] = Some(None)\n\
    \        // Iterate\n        for (i <- lst) {\n            if (i < 0) a = Some(i)\n\
    \            if (i > 0) b = Some(i)\n        }\n        // Return\n        (a,\
    \ b)", "        // TODO: implement\n        (None, None)", "        var maxNeg:\
    \ Option[Long] = Some(None)\n        var minPos: Option[Long] = Some(None)\n \
    \       lst.map(x => {\n            if (x < 0) {\n                if (maxNeg.get\
    \ == None) {\n                    maxNeg = Some(x)\n                } else {\n\
    \                    if (x > maxNeg.get) {\n                        maxNeg = Some(x)\n\
    \                    }\n                }\n            } else if (x > 0) {\n \
    \               if (minPos.get == None) {\n                    minPos = Some(x)\n\
    \                } else {\n                    if (x < minPos.get) {\n       \
    \                 minPos = Some(x)\n                    }\n                }\n\
    \            }\n        })\n        Tuple2(maxNeg, minPos)", "        // Fill-in\
    \ here\n        return (None, None)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        lst.foreach(x\
    \ => {\n            if (x > 0) {\n                if (smallestPositive == None)\
    \ smallestPositive = Some(x)\n                else if (x < smallestPositive.get)\
    \ smallestPositive = Some(x)\n            }\n            else if (x < 0) {\n \
    \               if (largestNegative == None) largestNegative = Some(x)\n     \
    \           else if (x > largestNegative.get) largestNegative = Some(x)\n    \
    \        }\n        })\n        (largestNegative, smallestPositive)", "      \
    \  var largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (x <- lst) {\n            if (x > 0 && (smallestPositive\
    \ == None || x < smallestPositive.get)) smallestPositive = Some(x)\n         \
    \   if (x < 0 && (largestNegative == None || x > largestNegative.get)) largestNegative\
    \ = Some(x)\n        }\n        (largestNegative, smallestPositive)", "      \
    \  // Your code goes here\n        (Some(None), Some(None))", "        // Fill-in\n\
    \        (Some(None), Some(None))", "        // Fill in your code here\n     \
    \   return (None, None)", "        var largestNegative : Option[Long] = None\n\
    \        var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) {\n  \
    \                  largestNegative = Some(i)\n                } else {\n     \
    \               if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        // Build and return a tuple containing\
    \ the largest negative integer and smallest positive integer\n        return (None,\
    \ None)", "      // TODO: Implement solution here\n      null", "        // Fill\
    \ this in.\n        val neg = lst.filter(_ < 0).sortWith(_ > _)\n        val pos\
    \ = lst.filter(_ > 0).sortWith(_ < _)\n        if (neg.isEmpty) (None, pos.headOption)\n\
    \        else if (pos.isEmpty) (neg.headOption, None)\n        else (neg.headOption,\
    \ pos.headOption)", "        //TODO: Insert your code here\n        return (None,\
    \ None)", "        var smallest = None:Option[Long]\n        var largest = None:Option[Long]\n\
    \        for (x <- lst) {\n            if (x > 0) {\n                if (smallest.isEmpty)\
    \ smallest = Some(x)\n                else if (x < smallest.get) smallest = Some(x)\n\
    \            }\n            else if (x < 0) {\n                if (largest.isEmpty)\
    \ largest = Some(x)\n                else if (x > largest.get) largest = Some(x)\n\
    \            }\n        }\n        return (largest, smallest)", "        // Your\
    \ code goes here\n        ???", "        // TODO: Implement solution here.\n \
    \       return null", "        // Note: If a value may or may not have a value,\
    \ then return None.\n        // Note: If a value is known not to have a value,\
    \ then return Some(None).\n        // Note: If a value is known to have a value,\
    \ then return Some(value).\n        // Note: A value can only have a value or\
    \ have no value; it cannot have multiple values.\n        return (Some(None),\
    \ Some(None))", "        // See if the list is empty, if it is return None\n \
    \       if (lst.isEmpty) {\n            return (Some(None), Some(None))\n    \
    \    }\n        // Filter the list by negative or positive numbers\n        val\
    \ negativeInts = lst.filter(x => x < 0)\n        val positiveInts = lst.filter(x\
    \ => x > 0)\n        // If there is negative numbers, order the list in descending\
    \ order,\n        // find the first value and return as Some, otherwise return\
    \ None\n        var largestNegative : Option[Long] = None\n        if (negativeInts.length\
    \ > 0) {\n            largestNegative = Some(negativeInts.sorted.reverse.head)\n\
    \        }\n        // If there is positive numbers, order the list in ascending\
    \ order,\n        // find the first value and return as Some, otherwise return\
    \ None\n        var smallestPositive : Option[Long] = None\n        if (positiveInts.length\
    \ > 0) {\n            smallestPositive = Some(positiveInts.sorted.head)\n    \
    \    }\n        // Return a tuple of the result\n        return (largestNegative,\
    \ smallestPositive)", "        val ret = Tuple2(Option(1l), Option(2l))\n    \
    \    ret", "        // Tuples are immutable so we make the mutable version\n \
    \       var tuple : Tuple2[Option[Long], Option[Long]] = (None, None)\n      \
    \  for (i <- lst) {\n            if (i > 0) {\n                // If 'b' is None,\
    \ then we set it as the smallest positive integer\n                if (tuple._2\
    \ == None) tuple = (tuple._1, Some(i))\n                // If it's not None, then\
    \ we check if the current value is smaller\n                // and set the tuple\
    \ variable if it is smaller\n                else {\n                    if (i\
    \ < tuple._2.get) tuple = (tuple._1, Some(i))\n                }\n           \
    \ }\n            else if (i < 0) {\n                // If 'a' is None, then we\
    \ set it as the largest negative integer\n                if (tuple._1 == None)\
    \ tuple = (Some(i), tuple._2)\n                // If it's not None, then we check\
    \ if the current value is larger\n                // and set the tuple variable\
    \ if it is larger\n                else {\n                    if (i > tuple._1.get)\
    \ tuple = (Some(i), tuple._2)\n                }\n            }\n        }\n \
    \       tuple", "        if (lst.isEmpty) return (Some(None), Some(None))\n  \
    \      var largest = Some(None)\n        var smallest = Some(None)\n        for\
    \ (i <- lst) {\n            if (i > 0 && largest != None) {\n                largest\
    \ = Some(if (largest.get == None) i else max(largest.get, i))\n            }\n\
    \            if (i < 0 && smallest != None) {\n                smallest = Some(if\
    \ (smallest.get == None) i else min(smallest.get, i))\n            }\n       \
    \ }\n        return (largest, smallest)", "        var l = ListBuffer[Long]()\n\
    \        var s = ListBuffer[Long]()\n        for (x <- lst) {\n            if\
    \ (x >= 0) s += x\n            else l += x\n        }\n        var largest = l.sorted\n\
    \        var smallest = s.sorted\n        var lr = if (largest.size > 0) Some(largest.last)\
    \ else None\n        var sr = if (smallest.size > 0) Some(smallest.head) else\
    \ None\n        return (lr, sr)", "        // [0] = min, [1] = max\n        val\
    \ tuple = Array(None: Option[Long], None: Option[Long])\n        if (lst.length\
    \ == 0) return (tuple(0), tuple(1))\n        tuple(0) = Some(lst(0))\n       \
    \ tuple(1) = Some(lst(0))\n        lst.foreach(x => {\n            if (x > 0)\
    \ {\n                if (tuple(1) == None || x < tuple(1).get) tuple(1) = Some(x)\n\
    \            } else if (x < 0) {\n                if (tuple(0) == None || x >\
    \ tuple(0).get) tuple(0) = Some(x)\n            }\n        })\n        return\
    \ (tuple(0), tuple(1))", "        var a : Option[Long] = None\n        var b :\
    \ Option[Long] = None\n        for (i <- lst) {\n            if (i >= 0) {\n \
    \               if (b == None) {\n                    b = Some(i)\n          \
    \      } else {\n                    if (i < b.get) {\n                      \
    \  b = Some(i)\n                    }\n                }\n            } else {\n\
    \                if (a == None) {\n                    a = Some(i)\n         \
    \       } else {\n                    if (i > a.get) {\n                     \
    \   a = Some(i)\n                    }\n                }\n            }\n   \
    \     }\n        Tuple2(a, b)", "      var (maxLst, minLst) = lst.partition(i\
    \ => i > 0)\n      (if (maxLst.length > 0) Some(maxLst.min) else None, if (minLst.length\
    \ > 0) Some(minLst.max) else None)", '        // your code here', "        val\
    \ negativeLst = lst.filter(_ < 0)\n        val positiveLst = lst.filter(_ > 0)\n\
    \        if (negativeLst.isEmpty) {\n            (None, positiveLst.minOption)\n\
    \        } else if (positiveLst.isEmpty) {\n            (negativeLst.maxOption,\
    \ None)\n        } else {\n            (negativeLst.maxOption, positiveLst.minOption)\n\
    \        }", "        // TODO: Implement this function.\n        val list = lst.sorted\n\
    \        var largest_negative:Option[Long] = None\n        var smallest_positive:Option[Long]\
    \ = None\n        if(list.head == 0){\n            largest_negative = None\n \
    \           smallest_positive = None\n        }\n        else if(list.head > 0){\n\
    \            largest_negative = None\n            smallest_positive = Some(list.head)\n\
    \        }\n        else if(list.last < 0){\n            largest_negative = Some(list.last)\n\
    \            smallest_positive = None\n        }\n        else{\n            largest_negative\
    \ = Some(list.head)\n            smallest_positive = Some(list.last)\n       \
    \ }\n        (largest_negative, smallest_positive)", "        def loop(acc : (Option[Long],\
    \ Option[Long]), x : Long) : (Option[Long], Option[Long]) =\n            if (x\
    \ < 0l) (Some(max(acc._1.getOrElse(x), x)), acc._2)\n            else if (x >\
    \ 0l) (acc._1, Some(min(acc._2.getOrElse(x), x)))\n            else acc\n    \
    \    lst.foldLeft((None, None))(loop)", "        var a = None\n        var b =\
    \ None\n        for (x <- lst) {\n            if (x >= 0) {\n                if\
    \ (b == None) {\n                    b = Some(x)\n                } else {\n \
    \                   if (x < b.get) {\n                        b = Some(x)\n  \
    \                  }\n                }\n            } else {\n              \
    \  if (a == None) {\n                    a = Some(x)\n                } else {\n\
    \                    if (x > a.get) {\n                        a = Some(x)\n \
    \                   }\n                }\n            }\n        }\n        (a,\
    \ b)", "        // Type your answer here\n        null", "        // Place your\
    \ code here\n        null", "        // Write your code here\n        if (lst.isEmpty)\
    \ {\n            return (Some(None), Some(None))\n        } else {\n         \
    \   var negative_max = Option.empty[Long]\n            var positive_min = Option.empty[Long]\n\
    \            for (i <- lst) {\n                if (i > 0 && positive_min.isEmpty)\
    \ {\n                    positive_min = Some(i)\n                } else if (i\
    \ > 0 && positive_min.isDefined && i < positive_min.get) {\n                 \
    \   positive_min = Some(i)\n                }\n                if (i < 0 && negative_max.isEmpty)\
    \ {\n                    negative_max = Some(i)\n                } else if (i\
    \ < 0 && negative_max.isDefined && i > negative_max.get) {\n                 \
    \   negative_max = Some(i)\n                }\n            }\n            return\
    \ (negative_max, positive_min)\n        }", "        val negativeList = lst.filter(x\
    \ => x < 0)\n        val positiveList = lst.filter(x => x > 0)\n        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        if (negativeList.size > 0) {\n            largestNegative = Some(negativeList.max)\n\
    \        }\n        if (positiveList.size > 0) {\n            smallestPositive\
    \ = Some(positiveList.min)\n        }\n        (largestNegative, smallestPositive)",
  "        val positives = lst.filter(x => x > 0).toList.sorted\n        val negatives\
    \ = lst.filter(x => x < 0).toList.sorted\n        if (negatives.isEmpty && positives.isEmpty)\
    \ (Some(None), Some(None))\n        else if (negatives.isEmpty) (Some(None), Some(positives.head))\n\
    \        else if (positives.isEmpty) (Some(negatives.reverse.head), Some(None))\n\
    \        else (Some(negatives.reverse.head), Some(positives.head))", '        (None,
    None)', "        var neg = None : Option[Long]\n        var pos = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (neg ==\
    \ None) {\n                    neg = Some(i)\n                } else {\n     \
    \               neg = if (i > neg.get) Some(i) else neg\n                }\n \
    \           } else if (i > 0) {\n                if (pos == None) {\n        \
    \            pos = Some(i)\n                } else {\n                    pos\
    \ = if (i < pos.get) Some(i) else pos\n                }\n            }\n    \
    \    }\n        (neg, pos)", "        // Fill in the code here.\n        // Do\
    \ *not* modify any of the existing code.\n        var min : Option[Long] = Some(None)\n\
    \        var max : Option[Long] = Some(None)\n        for (num <- lst) {\n   \
    \         if (num < 0 && (max == Some(None) || num > max.get)) max = Some(num)\n\
    \            if (num > 0 && (min == Some(None) || num < min.get)) min = Some(num)\n\
    \        }\n        return (max, min)", "        val sorted = lst.sorted\n   \
    \     val somePositiveInteger =\n            if (sorted.length == 0) None\n  \
    \          else if (sorted.head > 0) Some(sorted.head)\n            else None\n\
    \        val someNegativeInteger =\n            if (sorted.length == 0) None\n\
    \            else if (sorted.last < 0) Some(sorted.last)\n            else None\n\
    \        (someNegativeInteger, somePositiveInteger)", "        var a = Option.empty[Long]\n\
    \        var b = Option.empty[Long]\n        var found = false\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (!found) {\n       \
    \             a = Some(i)\n                    found = true\n                }\
    \ else if (i > a.get) {\n                    a = Some(i)\n                }\n\
    \            } else if (i > 0) {\n                if (!found) {\n            \
    \        b = Some(i)\n                    found = true\n                } else\
    \ if (i < b.get) {\n                    b = Some(i)\n                }\n     \
    \       }\n        }\n        (a, b)", "        val n : Option[Long] = lst.filter((x)\
    \ => x < 0).reduceLeftOption(max(_, _))\n        val p : Option[Long] = lst.filter((x)\
    \ => x > 0).reduceLeftOption(min(_, _))\n        (n, p)", "        if (lst.length\
    \ == 0) {\n            return (Some(None), Some(None))\n        }\n        val\
    \ negativeNumbers = lst.filter(_ < 0)\n        val positiveNumbers = lst.filter(_\
    \ > 0)\n        val largestNegativeNumber = if (negativeNumbers.length == 0) None\
    \ else Some(negativeNumbers.max)\n        val smallestPositiveNumber = if (positiveNumbers.length\
    \ == 0) None else Some(positiveNumbers.min)\n        return (largestNegativeNumber,\
    \ smallestPositiveNumber)", "        var (largestNegative, smallestPositive) =\
    \ (None, None)\n        for (number <- lst) {\n            if (number < 0) {\n\
    \                largestNegative = largestNegative match {\n                 \
    \   case Some(large) => Some(max(large, number))\n                    case None\
    \ => Some(number)\n                }\n            } else if (number > 0) {\n \
    \               smallestPositive = smallestPositive match {\n                \
    \    case Some(small) => Some(min(small, number))\n                    case None\
    \ => Some(number)\n                }\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        val negative = lst.filter(x =>\
    \ x < 0).maxOption\n        val positive = lst.filter(x => x > 0).minOption\n\
    \        return (negative, positive)", "        if (lst.length == 0) return (Some(None),\
    \ Some(None))\n        var negativeLargest = -Long.MaxValue\n        var positiveSmallest\
    \ = Long.MaxValue\n        for (x <- lst) {\n            if (x > 0 && x < positiveSmallest)\
    \ positiveSmallest = x\n            if (x < 0 && x > negativeLargest) negativeLargest\
    \ = x\n        }\n        if (negativeLargest == -Long.MaxValue) return (Some(None),\
    \ Some(positiveSmallest))\n        if (positiveSmallest == Long.MaxValue) return\
    \ (Some(negativeLargest), Some(None))\n        return (Some(negativeLargest),\
    \ Some(positiveSmallest))", "        var lst1 : List[Long] = List.empty[Long]\n\
    \        var lst2 : List[Long] = List.empty[Long]\n        for (n <- lst) {\n\
    \            if (n < 0) {\n                lst1 = n :: lst1\n            } else\
    \ if (n > 0) {\n                lst2 = n :: lst2\n            }\n        }\n \
    \       if (lst1.isEmpty) (Some(None), Some(lst2.min))\n        else if (lst2.isEmpty)\
    \ (Some(lst1.max), Some(None))\n        else (Some(lst1.max), Some(lst2.min))",
  "        var smallest = Long.MaxValue\n        var largest = Long.MinValue\n   \
    \     for (i <- lst) {\n            smallest = min(smallest, i)\n            largest\
    \ = max(largest, i)\n        }\n        var largestNegative = None : Option[Long]\n\
    \        var smallestPositive = None : Option[Long]\n        if (largest < 0)\
    \ largestNegative = Some(largest)\n        if (smallest > 0) smallestPositive\
    \ = Some(smallest)\n        (largestNegative, smallestPositive)", "        //\
    \ Your Code Here\n        var flag = true\n        var min = lst(0)\n        var\
    \ max = lst(0)\n        for (e <- lst) {\n            if (e < 0) {\n         \
    \       flag = false\n                if (max < e) max = e\n            }\n  \
    \          else {\n                if (min > e) min = e\n            }\n     \
    \   }\n        if (flag) return (None, None)\n        (Some(max), Some(min))",
  '        (None, None)', "        // Write your code here\n        var max = None\
    \ : Option[Long]\n        var min = None : Option[Long]\n        for (num <- lst)\
    \ {\n            if (num < 0) {\n                if (max == None) {\n        \
    \            max = Some(num)\n                } else {\n                    if\
    \ (num > max.get) {\n                        max = Some(num)\n               \
    \     }\n                }\n            } else if (num > 0) {\n              \
    \  if (min == None) {\n                    min = Some(num)\n                }\
    \ else {\n                    if (num < min.get) {\n                        min\
    \ = Some(num)\n                    }\n                }\n            }\n     \
    \   }\n        return (max, min)", "        // Create a function that returns\
    \ a tuple (a, b), where 'a' is\n        // the largest of negative integers, and\
    \ 'b' is the smallest\n        // of positive integers in a list.\n        //\
    \ If there is no negative or positive integers, return them as None.\n       \
    \ var neg = None : Option[Long]\n        var pos = None : Option[Long]\n     \
    \   for (x <- lst) {\n            if (x < 0) {\n                neg = Some(x)\n\
    \            } else if (x > 0) {\n                pos = Some(x)\n            }\n\
    \        }\n        (neg, pos)", "        // A function to convert the input list\
    \ to a list\n        // containing positive and negative integers.\n        def\
    \ positiveNegative(lst : List[Long]) : List[Long] = {\n            val newList\
    \ = for {\n                elem <- lst\n                if elem < 0l || elem >\
    \ 0l\n            } yield elem\n            return newList\n        }\n      \
    \  // If a list is empty, return the two values as None.\n        if (lst.isEmpty)\n\
    \            return (Some(None), Some(None))\n        // Get the sorted list of\
    \ positive and negative integers.\n        val sortedList = positiveNegative(lst).sorted\n\
    \        // If a list only has negative values, then return the largest negative\n\
    \        // value as 'a', and None as 'b'.\n        if (sortedList.head < 0l)\n\
    \            return (Some(sortedList.head), Some(None))\n        // If a list\
    \ only has positive values, then return the smallest positive\n        // value\
    \ as 'b', and None as 'a'.\n        if (sortedList.last > 0l)\n            return\
    \ (Some(None), Some(sortedList.last))\n        // Otherwise, return the largest\
    \ negative value as 'a', and smallest\n        // positive value as 'b'.\n   \
    \     return (Some(sortedList.head), Some(sortedList.last))", "        var largest\
    \ : Option[Long] = None\n        var smallest : Option[Long] = None\n        lst.foreach(\
    \ (i : Long) =>\n            if (i < 0) {\n                if (largest == None)\
    \ largest = Some(i)\n                else if (i > largest.get) largest = Some(i)\n\
    \            }\n            else if (i > 0) {\n                if (smallest ==\
    \ None) smallest = Some(i)\n                else if (i < smallest.get) smallest\
    \ = Some(i)\n            }\n        )\n        return (largest, smallest)", " \
    \       // Implement this.\n        (None, None)", "        if (lst.isEmpty) {\n\
    \            return (Some(None), Some(None))\n        }\n        var largest :\
    \ Option[Long] = None\n        var smallest : Option[Long] = None\n        for\
    \ (num <- lst) {\n            if (num > 0 && (smallest == None || num < smallest.get))\
    \ {\n                smallest = Some(num)\n            }\n            if (num\
    \ < 0 && (largest == None || num > largest.get)) {\n                largest =\
    \ Some(num)\n            }\n        }\n        return (largest, smallest)", " \
    \       // Fill up this function body\n        // 'a' is the largest of negative\
    \ integers\n        // 'b' is the smallest of positive integers\n        (None,\
    \ None)", "        var tuple : Tuple2[Option[Long], Option[Long]] = (None, None)\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                tuple = (Some(max(tuple._1.getOrElse(i),\
    \ i)), tuple._2)\n            } else if (i > 0) {\n                tuple = (tuple._1,\
    \ Some(min(tuple._2.getOrElse(i), i)))\n            }\n        }\n        tuple",
  "        // TODO: Implement solution here\n        return (None, None)", "     \
    \   var negArr = new ArrayBuffer[Long]()\n        var posArr = new ArrayBuffer[Long]()\n\
    \        var negValue : Option[Long] = None\n        var posValue : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i > 0) posArr += i\n     \
    \       else if (i < 0) negArr += i\n        }\n        if (negArr.size > 0) negValue\
    \ = Some(negArr.min)\n        if (posArr.size > 0) posValue = Some(posArr.max)\n\
    \        return (negValue, posValue)", "        val neg = new ListBuffer[Long]()\n\
    \        val pos = new ListBuffer[Long]()\n        lst.foreach(x => if (x > 0)\
    \ pos += x else if (x < 0) neg += x)\n        if (neg.isEmpty) (None, if (pos.isEmpty)\
    \ None else Some(pos.min))\n        else if (pos.isEmpty) (Some(neg.max), None)\n\
    \        else (Some(neg.max), Some(pos.min))", "        // Fill in the function\
    \ here.\n        return null", "        var smallest : Option[Long] = None\n \
    \       var largest : Option[Long] = None\n        for (i <- lst) {\n        \
    \    if (i > 0) {\n                if (smallest == None) {\n                 \
    \   smallest = Some(i)\n                } else {\n                    if (i <\
    \ smallest.get) {\n                        smallest = Some(i)\n              \
    \      }\n                }\n            } else if (i < 0) {\n               \
    \ if (largest == None) {\n                    largest = Some(i)\n            \
    \    } else {\n                    if (i > largest.get) {\n                  \
    \      largest = Some(i)\n                    }\n                }\n         \
    \   }\n        }\n        return (largest, smallest)", "      val n = lst.length\n\
    \      var maxNeg = None : Option[Long]\n      var minPos = None : Option[Long]\n\
    \      for (i <- 0 until n) {\n        if (lst(i) < 0) {\n          if (maxNeg\
    \ == None) maxNeg = Some(lst(i))\n          else if (lst(i) > maxNeg.get) maxNeg\
    \ = Some(lst(i))\n        }\n        else if (lst(i) > 0) {\n          if (minPos\
    \ == None) minPos = Some(lst(i))\n          else if (lst(i) < minPos.get) minPos\
    \ = Some(lst(i))\n        }\n      }\n      (maxNeg, minPos)", "        // Fill\
    \ in the implementation of this function.\n        var smallest = None:Option[Long]\n\
    \        var largest = None:Option[Long]\n        for (i <- lst) {\n         \
    \ if (i > 0 && (smallest == None || i < smallest.get)) smallest = Some(i)\n  \
    \        if (i < 0 && (largest == None || i > largest.get)) largest = Some(i)\n\
    \        }\n        (largest, smallest)", "        val negative = lst.filter(_\
    \ < 0)\n        val positive = lst.filter(_ > 0)\n        val negative2 = if (negative.isEmpty)\
    \ Some(None) else Some(negative.max)\n        val positive2 = if (positive.isEmpty)\
    \ Some(None) else Some(positive.min)\n        (negative2, positive2)", "     \
    \   var maxNegative: Option[Long] = None\n        var minPositive: Option[Long]\
    \ = None\n        lst.foreach(x => {\n            if (x < 0) {\n             \
    \   if (maxNegative == None) maxNegative = Some(x)\n                else if (x\
    \ > maxNegative.get) maxNegative = Some(x)\n            }\n            else if\
    \ (x > 0) {\n                if (minPositive == None) minPositive = Some(x)\n\
    \                else if (x < minPositive.get) minPositive = Some(x)\n       \
    \     }\n        })\n        (maxNegative, minPositive)", '        return (None,
    None)', "        def loop(lst : List[Long], largestNegative : Option[Long], smallestPositive\
    \ : Option[Long]) : Tuple2[Option[Long], Option[Long]] = {\n            if (lst.isEmpty)\
    \ (largestNegative, smallestPositive)\n            else {\n                val\
    \ value = lst.head\n                if (value > 0) {\n                    val\
    \ newSmallestPositive =\n                        if (smallestPositive == None)\
    \ Some(value)\n                        else Some(min(value, smallestPositive.get))\n\
    \                    loop(lst.tail, largestNegative, newSmallestPositive)\n  \
    \              }\n                else if (value < 0) {\n                    val\
    \ newLargestNegative =\n                        if (largestNegative == None) Some(value)\n\
    \                        else Some(max(value, largestNegative.get))\n        \
    \            loop(lst.tail, newLargestNegative, smallestPositive)\n          \
    \      }\n                else loop(lst.tail, largestNegative, smallestPositive)\n\
    \            }\n        }\n        loop(lst, None, None)", "        // Write your\
    \ code here\n        return null", "\t\tvar positives = new HashSet[Long]()\n\t\
    \tvar negatives = new HashSet[Long]()\n\t\tfor (value <- lst) {\n\t\t\tif (value\
    \ > 0) positives += value\n\t\t\telse if (value < 0) negatives += value\n\t\t\
    }\n\t\tif (positives.size == 0) return (None, None)\n\t\tif (negatives.size ==\
    \ 0) return (None, Some(positives.min))\n\t\treturn (Some(negatives.max), Some(positives.min))",
  "        def lst2(lst : List[Long]) : Tuple2[Long, Long] = {\n            if (lst.size\
    \ == 0)\n                return (Long.MaxValue, Long.MinValue)\n            else\
    \ {\n                val x = lst.head\n                val y = lst2(lst.tail)\n\
    \                val a = if (x < 0 && x > y._1) x else y._1\n                val\
    \ b = if (x > 0 && x < y._2) x else y._2\n                return (a, b)\n    \
    \        }\n        }\n        var a = lst2(lst)._1\n        var b = lst2(lst)._2\n\
    \        if (a == Long.MaxValue) a = Long.MinValue\n        if (b == Long.MinValue)\
    \ b = Long.MaxValue\n        var ar = if (a == Long.MinValue) None else Some(a)\n\
    \        var br = if (b == Long.MaxValue) None else Some(b)\n        return (ar,\
    \ br)", "        // Tuple2[Option[Long], Option[Long]] = (largest, smallest)\n\
    \        // If there is no negative or positive integers, return them as None.\n\
    \        var largest = Some(None)\n        var smallest = Some(None)\n       \
    \ for (i <- lst) {\n            largest = if (i > largest.getOrElse(None)) Some(i)\
    \ else largest\n            smallest = if (i < smallest.getOrElse(None)) Some(i)\
    \ else smallest\n        }\n        (largest, smallest)", "        // Fill in\
    \ here!\n        var s = \"\"\n        val tuple : Tuple2[Option[Long], Option[Long]]\
    \ = (None, None)\n        tuple", "        var smallest = Option.empty[Long]\n\
    \        var largest = Option.empty[Long]\n        for (x <- lst) {\n        \
    \    if (x > 0) {\n                if (smallest.isEmpty) smallest = Some(x)\n\
    \                else if (x < smallest.get) smallest = Some(x)\n            }\n\
    \            else if (x < 0) {\n                if (largest.isEmpty) largest =\
    \ Some(x)\n                else if (x > largest.get) largest = Some(x)\n     \
    \       }\n        }\n        (largest, smallest)", "        // Fill Up this function\
    \ body\n        // `n` is the variable that iterates over the list\n        //\
    \ operation.reduce((a, b) => { if (a > b) a else b })\n        (None, None)",
  "        // Implement this function and return the correct value\n        var min\
    \ = lst.reduceLeft(_ min _)\n        var max = lst.reduceLeft(_ max _)\n     \
    \   if (min > 0) (None, Some(min))\n        else if (max < 0) (Some(max), None)\n\
    \        else (Some(max), Some(min))", "        // Write your code here\n    \
    \    null", "        lst.foldLeft(Tuple2(None : Option[Long], None : Option[Long]))((acc,\
    \ value) => {\n            var largest = acc._1\n            var smallest = acc._2\n\
    \            if (value > 0) {\n                smallest = smallest match {\n \
    \                   case None => Some(value)\n                    case Some(s)\
    \ => if (value < s) Some(value) else smallest\n                }\n           \
    \ } else if (value < 0) {\n                largest = largest match {\n       \
    \             case None => Some(value)\n                    case Some(l) => if\
    \ (value > l) Some(value) else largest\n                }\n            }\n   \
    \         Tuple2(largest, smallest)\n        })", "        def f(lst : List[Long],\
    \ largest : Option[Long], smallest : Option[Long]) : Tuple2[Option[Long], Option[Long]]\
    \ = {\n            if (lst.isEmpty) (largest, smallest)\n            else if (lst.head\
    \ > 0) {\n                val s = smallest match {\n                    case Some(x)\
    \ => Some(min(x, lst.head))\n                    case None => Some(lst.head)\n\
    \                }\n                f(lst.tail, largest, s)\n            }\n \
    \           else if (lst.head < 0) {\n                val l = largest match {\n\
    \                    case Some(x) => Some(max(x, lst.head))\n                \
    \    case None => Some(lst.head)\n                }\n                f(lst.tail,\
    \ l, smallest)\n            }\n            else f(lst.tail, largest, smallest)\n\
    \        }\n        f(lst, None, None)", "\t\t\t\tvar largestNegative : Option[Long]\
    \ = None\n\t\t\t\tvar smallestPositive : Option[Long] = None\n\t\t\t\tfor (x <-\
    \ lst) {\n\t\t\t\t\t\tif (x < 0 && (largestNegative == None || largestNegative.get\
    \ < x)) {\n\t\t\t\t\t\t\t\tlargestNegative = Some(x)\n\t\t\t\t\t\t}\n\t\t\t\t\t\
    \tif (x > 0 && (smallestPositive == None || smallestPositive.get > x)) {\n\t\t\
    \t\t\t\t\t\tsmallestPositive = Some(x)\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn\
    \ (largestNegative, smallestPositive)", "        var minPos = None : Option[Long]\n\
    \        var maxNeg = None : Option[Long]\n        if (lst != null) {\n      \
    \      var i = 0\n            while (i < lst.length) {\n                if (lst(i)\
    \ > 0 && (minPos == None || lst(i) < minPos.get)) minPos = Some(lst(i))\n    \
    \            if (lst(i) < 0 && (maxNeg == None || lst(i) > maxNeg.get)) maxNeg\
    \ = Some(lst(i))\n                i += 1\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        // Fill in this function\n        (None, None)", "      \
    \  // Insert your code here\n        val tupleA = lst.filter(_ < 0).sorted.reverse.headOption\n\
    \        val tupleB = lst.filter(_ > 0).sorted.headOption\n        return (tupleA,\
    \ tupleB)", "        var map = Map[Long, Long]()\n        for (x <- lst) {\n \
    \           map(x) = x\n        }\n        var sorted = map.toList.sortWith(_._1\
    \ < _._1)\n        var neg : Option[Long] = None\n        var pos : Option[Long]\
    \ = None\n        if (sorted.isEmpty) {\n            return (Some(None), Some(None))\n\
    \        }\n        for (x <- sorted) {\n            if (x._1 < 0) {\n       \
    \         neg = Some(x._1)\n            }\n            if (x._1 > 0) {\n     \
    \           pos = Some(x._1)\n                return (neg, pos)\n            }\n\
    \        }\n        return (neg, pos)", '        // Start coding here', "    \
    \  // Fill up this function body\n      // You can add another function as well,\
    \ if you need\n      val (neg, pos) = lst.partition(_ < 0)\n      (if (neg.isEmpty)\
    \ None else Some(neg.max), if (pos.isEmpty) None else Some(pos.min))", "     \
    \   // Fill this in.\n        var r = new Tuple2[Option[Long], Option[Long]](None,\
    \ None)\n        for (x <- lst) {\n            if (x < 0) {\n                if\
    \ (r._1 == None) r = new Tuple2[Option[Long], Option[Long]](Some(x), r._2)\n \
    \               else if (r._1.get < x) r = new Tuple2[Option[Long], Option[Long]](Some(x),\
    \ r._2)\n            }\n            else if (x > 0) {\n                if (r._2\
    \ == None) r = new Tuple2[Option[Long], Option[Long]](r._1, Some(x))\n       \
    \         else if (r._2.get > x) r = new Tuple2[Option[Long], Option[Long]](r._1,\
    \ Some(x))\n            }\n        }\n        r", "        lst.filter(_ > 0).reduceLeftOption((a,\
    \ b) => min(a, b)) match {\n            case Some(m) =>\n                lst.filter(_\
    \ < 0).reduceLeftOption((a, b) => max(a, b)) match {\n                    case\
    \ Some(n) => (Some(n), Some(m))\n                    case None => (None, Some(m))\n\
    \                }\n            case None => (lst.filter(_ < 0).reduceLeftOption((a,\
    \ b) => max(a, b)), None)\n        }", "\t\tval positives = lst.filter(x => x\
    \ > 0)\n\t\tval negatives = lst.filter(x => x < 0)\n\t\treturn (Option(negatives.max),\
    \ Option(positives.min))", "        var neg : Option[Long] = None\n        var\
    \ pos : Option[Long] = None\n        for (l <- lst) {\n            if (l < 0)\
    \ {\n                if (neg == None) neg = Some(l)\n                else if (l\
    \ > neg.get) neg = Some(l)\n            }\n            else if (l > 0) {\n   \
    \             if (pos == None) pos = Some(l)\n                else if (l < pos.get)\
    \ pos = Some(l)\n            }\n        }\n        return (neg, pos)", "     \
    \   val negativeList = lst.filter(x => x < 0).sorted\n        val positiveList\
    \ = lst.filter(x => x > 0).sorted\n        if (negativeList.length == 0) (None,\
    \ Some(positiveList.head))\n        else if (positiveList.length == 0) (Some(negativeList.last),\
    \ None)\n        else (Some(negativeList.last), Some(positiveList.head))", " \
    \       var largestNeg = None : Option[Long]\n        var smallestPos = None :\
    \ Option[Long]\n        for (i <- lst) {\n            if (i < 0) largestNeg =\
    \ Some(max(largestNeg.getOrElse(Long.MinValue), i))\n            if (i > 0) smallestPos\
    \ = Some(min(smallestPos.getOrElse(Long.MaxValue), i))\n        }\n        (largestNeg,\
    \ smallestPos)", "        var largestNeg : Option[Long] = None\n        var smallestPos\
    \ : Option[Long] = None\n        lst.foreach(e => {\n            if (e < 0 &&\
    \ largestNeg == None) largestNeg = Some(e)\n            else if (e < 0 && largestNeg\
    \ != None && e > largestNeg.get) largestNeg = Some(e)\n            if (e > 0 &&\
    \ smallestPos == None) smallestPos = Some(e)\n            else if (e > 0 && smallestPos\
    \ != None && e < smallestPos.get) smallestPos = Some(e)\n        })\n        (largestNeg,\
    \ smallestPos)", "        var minp = Long.MaxValue\n        var maxn = Long.MinValue\n\
    \        var hasMin = false\n        var hasMax = false\n        for (i <- lst)\
    \ {\n            if (i > 0) {\n                hasMin = true\n               \
    \ if (i < minp) minp = i\n            } else if (i < 0) {\n                hasMax\
    \ = true\n                if (i > maxn) maxn = i\n            }\n        }\n \
    \       val minpOption = if (hasMin) Some(minp) else None\n        val maxnOption\
    \ = if (hasMax) Some(maxn) else None\n        (maxnOption, minpOption)", "   \
    \     lst.filter(e => e.isValidLong).foldLeft((Some(None), Some(None)) : Tuple2[Option[Long],\
    \ Option[Long]]) {\n            (acc, e) =>\n                if (e < 0) {\n  \
    \                  if (acc._1.getOrElse(None) == None || acc._1.getOrElse(None).getOrElse(0l)\
    \ < e) {\n                        (Some(Some(e)), acc._2)\n                  \
    \  } else {\n                        acc\n                    }\n            \
    \    } else {\n                    if (acc._2.getOrElse(None) == None || acc._2.getOrElse(None).getOrElse(0l)\
    \ > e) {\n                        (acc._1, Some(Some(e)))\n                  \
    \  } else {\n                        acc\n                    }\n            \
    \    }\n        }", "        val biggestNegative = lst.filter(_ < 0).sorted.takeRight(1)\n\
    \        val smallestPositive = lst.filter(_ > 0).sorted.take(1)\n        if (biggestNegative.isEmpty\
    \ && smallestPositive.isEmpty) {\n            (Some(None), Some(None))\n     \
    \   } else if (biggestNegative.isEmpty) {\n            (Some(None), Some(smallestPositive.head))\n\
    \        } else if (smallestPositive.isEmpty) {\n            (Some(biggestNegative.head),\
    \ Some(None))\n        } else {\n            (Some(biggestNegative.head), Some(smallestPositive.head))\n\
    \        }", '        (Option(None), Option(None))', "        var tuple : Tuple2[Option[Long],\
    \ Option[Long]] = (None, None)\n        if (lst.length == 0) {\n            tuple\n\
    \        } else {\n            val negatives = lst.filter(x => x < 0)\n      \
    \      val positives = lst.filter(x => x > 0)\n            if (negatives.length\
    \ > 0) {\n                tuple._1 = Some(negatives.max)\n            }\n    \
    \        if (positives.length > 0) {\n                tuple._2 = Some(positives.min)\n\
    \            }\n            tuple\n        }", "        val negatives = lst.filter(x\
    \ => x < 0)\n        val positives = lst.filter(x => x > 0)\n        var largest\
    \ : Option[Long] = None\n        var smallest : Option[Long] = None\n        if\
    \ (negatives.length > 0) {\n            largest = Some(negatives.max)\n      \
    \  }\n        if (positives.length > 0) {\n            smallest = Some(positives.min)\n\
    \        }\n        (largest, smallest)", "      def largestSmallestIntegersHelper(lst\
    \ : List[Long], largestNegative : Option[Long], smallestPositive : Option[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.isEmpty) {\n     \
    \     return (largestNegative, smallestPositive)\n        }\n        val h = lst.head\n\
    \        if (h > 0) {\n          if (smallestPositive.isEmpty) largestSmallestIntegersHelper(lst.tail,\
    \ largestNegative, Some(h))\n          else if (h < smallestPositive.get) largestSmallestIntegersHelper(lst.tail,\
    \ largestNegative, Some(h))\n          else largestSmallestIntegersHelper(lst.tail,\
    \ largestNegative, smallestPositive)\n        }\n        else if (h < 0) {\n \
    \         if (largestNegative.isEmpty) largestSmallestIntegersHelper(lst.tail,\
    \ Some(h), smallestPositive)\n          else if (h > largestNegative.get) largestSmallestIntegersHelper(lst.tail,\
    \ Some(h), smallestPositive)\n          else largestSmallestIntegersHelper(lst.tail,\
    \ largestNegative, smallestPositive)\n        }\n        else largestSmallestIntegersHelper(lst.tail,\
    \ largestNegative, smallestPositive)\n      }\n      largestSmallestIntegersHelper(lst,\
    \ None, None)"]
stop_tokens:
- "\n    }\n"
