name: HumanEval_128_prod_signs
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list arr of integers and you need to return\n    // sum\
  \ of magnitudes of integers multiplied by product of all signs\n    // of each number\
  \ in the list, represented by 1, -1 or 0.\n    // Note: return None for empty arr.\n\
  \    // Example:\n    // >>> prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
  \ -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong, 1l.toLong)))\n\
  \    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n    def prodSigns(arr\
  \ : List[Long]) : Option[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
  \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n   \
  \ assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
  \    }\n\n}\n"
completions: ["        if (arr.length == 0) None\n        else {\n            var\
    \ prod : Long = 1\n            var sum : Long = 0\n            for (i <- arr)\
    \ {\n                var sign : Long = i / abs(i)\n                if (sign ==\
    \ 0) sign = 1\n                prod *= sign\n                sum += abs(i)\n \
    \           }\n            Some(sum * prod)\n        }", "        // Write your\
    \ code here.\n        // Return the actual answer.\n        var sign = 1\n   \
    \     var sum = 0\n        if (arr.isEmpty) {\n            return None\n     \
    \   }\n        for (i <- arr) {\n            if (i > 0) {\n                sign\
    \ *= 1\n            } else if (i < 0) {\n                sign *= -1\n        \
    \    } else {\n                sign *= 0\n            }\n            sum += abs(i).toInt\n\
    \        }\n        Some(sum * sign)", "        if (arr.isEmpty) return None\n\
    \        val s = arr.map(x => x.signum).reduce(_ * _)\n        return Some(arr.map(abs(_)).reduce(_\
    \ + _) * s)", "        // Write your code here\n        return None", "      \
    \  if (arr.isEmpty) return None\n        var negatives = 0\n        var zeros\
    \ = 0\n        var product = 1l\n        var sum = 0l\n        for (i <- arr)\
    \ {\n            if (i < 0) negatives += 1\n            else if (i == 0) zeros\
    \ += 1\n            sum += abs(i)\n            product *= signum(i)\n        }\n\
    \        if (negatives % 2 == 0 || zeros != 0) product = abs(product)\n      \
    \  Some(sum * product)", '        None', "        if (arr.length == 0) return\
    \ None\n        var signs = 1\n        var magnitude = 0l\n        for (n <- arr)\
    \ {\n            if (n < 0) signs *= -1\n            magnitude += abs(n)\n   \
    \     }\n        Some(magnitude * signs)", "        if (arr.isEmpty) {\n     \
    \       None\n        } else {\n            var result = 1l.toLong\n         \
    \   for (x <- arr) {\n                if (x < 0) {\n                    result\
    \ *= -1\n                } else if (x > 0) {\n                    result *= 1\n\
    \                } else {\n                    result *= 0\n                }\n\
    \            }\n            var sum = 0l.toLong\n            for (x <- arr) {\n\
    \                sum += abs(x)\n            }\n            Some(sum * result)\n\
    \        }", "        val arr2 = arr.filter(_ != 0)\n        if (arr2.isEmpty)\
    \ None\n        else {\n            val n = arr2.size\n            val p = pow(2,\
    \ n - 1).toLong\n            Some(arr2.map(a => abs(a) * p).sum)\n        }",
  "        if (arr.length == 0) return None\n        var signs : List[Long] = Nil\n\
    \        var magnitudes : List[Long] = Nil\n        for (n <- arr) {\n       \
    \     signs = math.signum(n).toLong :: signs\n            magnitudes = math.abs(n)\
    \ :: magnitudes\n        }\n        Some(magnitudes.foldLeft(1l)(_ * _) * signs.foldLeft(1l)(_\
    \ * _))", "    \tif (arr.length == 0) return None\n    \tvar prodSign = 1\n  \
    \  \tvar magSum = 0\n    \tfor (x <- arr) {\n    \t\tif (x < 0) prodSign *= -1\n\
    \    \t\tmagSum += abs(x)\n    \t}\n    \treturn Some(magSum * prodSign)", " \
    \       if (arr.length == 0) return None\n        val negs = arr.filter(_ < 0).length\n\
    \        val sign = if (negs % 2 == 0) 1 else -1\n        val mags = arr.map(abs(_))\n\
    \        val prod = mags.product\n        Some(sign * prod)", "        if (arr.length\
    \ == 0) None\n        else {\n            val p = arr.foldLeft(1l)((z, i) => z\
    \ * signum(i).toLong)\n            Some(arr.foldLeft(0l)((z, i) => z + abs(i))\
    \ * p)\n        }", "        // the first thing that comes to mind is to first\
    \ filter the list\n        // by removing the 0's, and then map it to -1, 1 to\
    \ represent\n        // signs and then reduce the product and sum of remaining\
    \ elements\n        if (arr.length == 0) {\n            return None\n        }\n\
    \        Some(arr.filter(x => x != 0).map(x => if (x > 0) 1 else -1).reduce(_\
    \ * _) * arr.filter(x => x != 0).map(x => abs(x)).reduce(_ + _))", "        if\
    \ (arr.length == 0) return None\n        var sum = 0l\n        var product = 1l\n\
    \        for (e <- arr) {\n            sum += abs(e)\n            if (e != 0)\
    \ product *= e / abs(e)\n        }\n        Some(sum * product)", "        if\
    \ (arr.length == 0) return None\n        var sum = 0l\n        var prod = 1l\n\
    \        for (i <- arr) {\n            if (i > 0) sum += i else if (i < 0) {sum\
    \ -= i; prod *= -1}\n        }\n        Some(sum * prod)", "        val list =\
    \ arr.map(x => x.toString.toLong)\n        if (list.size > 0) {\n          var\
    \ product = 1l\n          var sum = 0l\n          for (number <- list) {\n   \
    \         if (number > 0) {\n              product *= 1\n              sum +=\
    \ number\n            } else if (number < 0) {\n              product *= -1\n\
    \              sum += -number\n            } else if (number == 0) {\n       \
    \       product *= 0\n            }\n          }\n          Some(sum * product)\n\
    \        } else {\n          None\n        }", "        if (arr.length == 0) return\
    \ None\n        var product = 1l\n        var sum = 0l\n        for (i <- arr)\
    \ {\n            sum += abs(i)\n            if (i > 0) product *= 1\n        \
    \    else if (i < 0) product *= -1\n            else product *= 0\n        }\n\
    \        return Some(sum * product)", "        arr match {\n            case Nil\
    \ => None\n            case _ => {\n                val result = arr.foldLeft(1l)((total,\
    \ x) => total * signum(x).toLong)\n                Some(result)\n            }\n\
    \        }", "        val as = arr.toArray\n        if (as.length == 0) return\
    \ None\n        var sign = 1l\n        for (i <- 0 until as.length) {\n      \
    \      if (as(i) < 0) {\n                sign *= -1\n                as(i) *=\
    \ -1\n            }\n            else if (as(i) == 0) {\n                sign\
    \ = 0\n                as(i) = 1\n            }\n        }\n        if (sign ==\
    \ 0) return Some(0)\n        return Some(as.product * sign)", "        // your\
    \ code here\n        if (arr.isEmpty) None\n        else {\n            Some(\n\
    \                arr.map(x => if (x == 0) 0 else if (x > 0) 1 else -1).product\
    \ * \n                arr.map(x => if (x < 0) -x else x).sum\n            )\n\
    \        }", "        if (arr.length == 0) return None\n        var sgn = 1l\n\
    \        var tot = 0l\n        for (e <- arr) {\n            val i = e.toInt\n\
    \            if (i == 0) return Some(0l)\n            else if (i < 0) sgn *= -1\n\
    \            tot += abs(i)\n        }\n        Some(tot * sgn)", "        def\
    \ prodSigns(arr : List[Long], res : Long) : Long = {\n            arr match {\n\
    \                case List() => return res\n                case x :: xs => prodSigns(xs,\
    \ res * (x.signum * abs(x)))\n            }\n        }\n        if (arr.length\
    \ == 0) None else Some(prodSigns(arr, 1))", "\t    if (arr.length == 0) {\n\t\t\
    \    None\n\t    } else {\n\t\t    Some(arr.map(i => (i * i).toLong).sum * arr.map(i\
    \ => (if (i > 0) 1 else if (i < 0) -1 else 0)).product)\n\t    }", "\t\treturn\
    \ arr match {\n\t\t\tcase Nil => None\n\t\t\tcase arr: List[Long] => {\n\t\t\t\
    \tvar prod = 1L\n\t\t\t\tvar sum = 0L\n\t\t\t\tarr.foreach(e => {\n\t\t\t\t\t\
    prod *= signum(e)\n\t\t\t\t\tsum += abs(e)\n\t\t\t\t})\n\t\t\t\tSome(sum * prod)\n\
    \t\t\t}\n\t\t}", "        var product : Long = 1l\n        var sum = 0l\n    \
    \    for (i <- arr) {\n            sum += abs(i)\n            product *= i.signum\n\
    \        }\n        if (arr.isEmpty) None else Some(sum * product)", "      if\
    \ (arr.isEmpty) None\n      else if (arr.forall(_ == 0)) Some(0)\n      else {\n\
    \        var prod = 1\n        for (x <- arr) if (x != 0) prod *= x / abs(x)\n\
    \        Some(arr.map(x => x * prod).sum)\n      }", "        val sgn = arr.map(BigInt(_)).map(BigInt(_)).map(x\
    \ => if (x == 0) 0 else x.signum).foldLeft(BigInt(1))(_ * _)\n        val abs\
    \ = arr.map(abs(_)).foldLeft(0l)(_ + _)\n        if (arr.length == 0) None else\
    \ Some(sgn.toLong * abs)", "        var sum = 0l\n        var prod = 1l\n    \
    \    arr.foreach(e => {\n            sum += e.abs\n            prod *= e.signum\n\
    \        })\n        if (arr.isEmpty) None else Some(sum * prod)", "        if\
    \ (arr.length == 0) None\n        else {\n            var prod = arr.map(x =>\
    \ if (x == 0) 0 else signum(x).toLong).product\n            var sum = arr.map(x\
    \ => if (x == 0) 0 else abs(x)).sum\n            Some(sum * prod)\n        }",
  "        def helper(acc: Long, arr: List[Long]): Long = arr match {\n          \
    \  case Nil => acc\n            case 0l :: xs => helper(acc, xs)\n           \
    \ case x :: xs => helper(acc * x, xs)\n        }\n        if (arr.isEmpty) None\n\
    \        else Some(arr.map(abs(_)).sum * helper(1, arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)))", "        var p = 1l\n        var s = 0l\n    \
    \    for (n <- arr) {\n            if (n == 0) p = 0\n            else if (n <\
    \ 0) p *= -1\n            s += abs(n)\n        }\n        if (arr.isEmpty) None\n\
    \        else Some(p * s)", "        if (arr.isEmpty) None\n        else {\n \
    \           val products = arr.map(x => if (x > 0) 1 else if (x < 0) -1 else 0)\n\
    \            val magnitudes = arr.map(x => abs(x.toInt))\n            Some(magnitudes.zip(products).map(x\
    \ => x._1 * x._2).sum)\n        }", "        // Write your code here\n       \
    \ None", "        if (arr.length == 0) return None\n        var sum = 0l\n   \
    \     var product = 1l\n        for (element <- arr) {\n            if (element\
    \ > 0) sum += element\n            else if (element < 0) {sum += -element; product\
    \ *= -1}\n        }\n        Some(sum * product)", "        if (arr.isEmpty) None\n\
    \        else {\n            val res = arr.map(x => if (x < 0) -1 else if (x >\
    \ 0) 1 else 0).foldLeft(1)((product, sign) => product * sign)\n            if\
    \ (res < 0) Option(arr.map(abs(_)).foldLeft(1l)(_ * _))\n            else Option(arr.map(abs(_)).foldLeft(1l)(_\
    \ * _) * res)\n        }", "        // Write your solution here\n        val s\
    \ = arr.map(abs(_))\n        val s2 = arr.map(x => if (x >= 0) 1 else if (x <\
    \ 0) -1 else 0)\n        val p = s2.foldLeft(1l)(_ * _)\n        p match {\n \
    \           case 0 => None\n            case 1 => Some(s.sum)\n            case\
    \ -1 => Some(-s.sum)\n            case _ => None\n        }", "        // Your\
    \ Code Here\n        if (arr.length <= 0) None\n        else {\n            var\
    \ prod = 1l\n            var sum = 0l\n            for (x <- arr) {\n        \
    \        if (x == 0) prod *= 0\n                else if (x > 0) {\n          \
    \          prod *= 1\n                    sum += x\n                }\n      \
    \          else {\n                    prod *= -1\n                    sum +=\
    \ -x\n                }\n            }\n            Some(sum * prod)\n       \
    \ }", "        if (arr.length == 0) return None\n        var prod = 1l\n     \
    \   var sum = 0l\n        for (i <- arr) {\n            prod *= signum(i)\n  \
    \          sum += abs(i)\n        }\n        return Some(sum * prod)", "     \
    \   if (arr.isEmpty) return None\n        var ans = 0l\n        for (num <- arr)\
    \ {\n            if (num == 0) ans = 0l\n            else if (num > 0) ans +=\
    \ num\n            else ans -= num\n        }\n        Some(ans)", "        return\
    \ arr match {\n            case Nil => None\n            case x :: xs => Some(arr.map(x\
    \ => abs(x) * x.signum).sum)\n        }", "        if (arr.isEmpty) None\n   \
    \     else {\n            var p = 1l\n            var s = 0l\n            for\
    \ (i <- arr) {\n                if (i > 0) p *= 1\n                else if (i\
    \ < 0) p *= -1\n                else p *= 0\n                s += abs(i)\n   \
    \         }\n            Option(p * s)\n        }", "        if (arr.length ==\
    \ 0) {\n            None\n        } else {\n            // Return the answer\n\
    \            var signs : ArrayBuffer[Int] = new ArrayBuffer[Int]()\n         \
    \   for (x <- arr) {\n                if (x == 0) {\n                    signs\
    \ += 0\n                } else if (x > 0) {\n                    signs += 1\n\
    \                } else {\n                    signs += -1\n                }\n\
    \            }\n            var sum = 0l\n            for (x <- arr) {\n     \
    \           sum += abs(x)\n            }\n            var prod = 1\n         \
    \   for (x <- signs) {\n                prod *= x\n            }\n           \
    \ Some(sum * prod)\n        }", "        val signNums = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val magniNum = arr.map(x => abs(x)).foldLeft(1l)(_\
    \ * _)\n        if (signNums.contains(0)) Some(0) else Some(signNums.foldLeft(1l)(_\
    \ * _) * magniNum)", "        // Your code goes here\n        return None", " \
    \       arr match {\n            case Nil => None\n            case _ => Some(arr.map(abs(_)).sum\
    \ * arr.map(signum(_)).product)\n        }", "        var p = 1l\n        for\
    \ (a <- arr) {\n            p *= (if (a > 0) 1 else if (a < 0) -1 else 0)\n  \
    \      }\n        if (arr.length > 0) Some(arr.map(abs(_)).sum * p) else None",
  "        var products = ListBuffer[Long]()\n        if (arr.length == 0) {\n   \
    \         return None\n        }\n        for (item <- arr) {\n            if\
    \ (item == 0) {\n                products += 1\n            } else if (item >\
    \ 0) {\n                products += 1\n            } else {\n                products\
    \ += -1\n            }\n        }\n        var product : Long = 1\n        for\
    \ (item <- products) {\n            product *= item\n        }\n        var total\
    \ : Long = 0\n        for (item <- arr) {\n            total += item.abs\n   \
    \     }\n        return Some(total * product)", "        // Use your solution\
    \ to solve this problem.\n        // Place your code here.\n        None", " \
    \   \tif (arr.isEmpty) None\n    \telse Some(arr.foldLeft(1l)((a, b) => {\n  \
    \  \t\tval sign = if (b > 0) 1l else if (b < 0) -1l else 0l\n    \t\ta * sign\
    \ * abs(b)\n    \t}))", "        var prod = 1l\n        var sum = 0l\n       \
    \ for (e <- arr) {\n            prod *= signum(e).toLong\n            sum += abs(e)\n\
    \        }\n        sum * prod match {\n            case 0 => None\n         \
    \   case n => Some(n)\n        }", "        var prod = 1l.toLong\n        var\
    \ sum = 0l.toLong\n        for (n <- arr) {\n            prod *= (if (n > 0) 1\
    \ else if (n < 0) -1 else 0)\n            sum += abs(n)\n        }\n        if\
    \ (arr.length == 0) None else Some(sum * prod)", "        val product = arr.map(x\
    \ => (if (x > 0) 1 else if (x < 0) -1 else 0)).product\n        val sum = arr.map(x\
    \ => abs(x)).sum\n        if (arr.isEmpty) None else Some(sum * product)", " \
    \       if (arr.isEmpty) None\n        else {\n            def prodSignsRec(arr\
    \ : List[Long], acc : Long) : Long = {\n                if (arr.isEmpty) acc\n\
    \                else {\n                    var x = arr.head\n              \
    \      if (x > 0) prodSignsRec(arr.tail, acc * (x + 1) / 2)\n                \
    \    else if (x < 0) prodSignsRec(arr.tail, acc * (x - 1) / 2)\n             \
    \       else prodSignsRec(arr.tail, acc * 0)\n                }\n            }\n\
    \            Some(prodSignsRec(arr, 1))\n        }", "      val nums = arr.filter(_\
    \ != 0)\n      val signs = arr.filter(_ != 0).filter(_ < 0).length % 2\n     \
    \ val ans = if (signs == 0) 1 else -1\n      nums.length match {\n        case\
    \ 0 => None\n        case _ => Some(ans * nums.map(x => math.abs(x)).product)\n\
    \      }", "        if (arr.isEmpty) None\n        else {\n            val signs\
    \ = arr.map(x => if (x > 0) 1 else if (x < 0) -1 else 0)\n            val magnitudes\
    \ = arr.map(x => abs(x))\n            var signProduct = 1\n            for (sign\
    \ <- signs) signProduct *= sign\n            var magnitudeSum = 0\n          \
    \  for (magnitude <- magnitudes) magnitudeSum += magnitude\n            Some(signProduct\
    \ * magnitudeSum)\n        }", "        if (arr.length == 0) None\n        else\
    \ {\n            val magnitudes = arr.map(x => abs(x))\n            val signProduct\
    \ = arr.map(x => \n                if (x > 0) 1\n                else if (x <\
    \ 0) -1\n                else 0\n            ).reduce(_ * _)\n            Some(magnitudes.reduce(_\
    \ + _) * signProduct)\n        }", "        if (arr.isEmpty) return None\n   \
    \     val res = arr.foldLeft(1l.toLong, 0l.toLong)((b, a) => {\n            if\
    \ (a == 0) (b._1, b._2)\n            else if (a > 0) (b._1 * a, b._2 + a)\n  \
    \          else (b._1 * a, b._2 - a)\n        })\n        return Some(res._1 *\
    \ res._2)", "        if (arr.length == 0) return None\n        var negCount =\
    \ 0\n        for (i <- arr) if (i < 0) negCount += 1\n        val prod = if (negCount\
    \ % 2 == 0) 1 else -1\n        var sum = 0\n        for (i <- arr) sum += abs(i.toInt)\n\
    \        Option(sum * prod)", "        if (arr.isEmpty) None\n        else {\n\
    \            var ans = 1l.toLong\n            for (i <- arr) {\n             \
    \   if (i > 0) ans *= 1l.toLong\n                else if (i < 0) ans *= -1l.toLong\n\
    \                else ans *= 0l.toLong\n            }\n            if (ans ==\
    \ 0l.toLong) None\n            else {\n                for (i <- arr) {\n    \
    \                if (i != 0) ans *= abs(i)\n                }\n              \
    \  Some(ans)\n            }\n        }", "        if (arr.isEmpty) None\n    \
    \    else {\n            var prod = 1l.toLong\n            for (n <- arr) {\n\
    \                if (n == 0) prod = 0\n                else prod *= abs(n) / n\n\
    \            }\n            Some(prod * arr.map(abs(_)).sum)\n        }", "  \
    \      // your code here\n        var l = arr.map(x => {\n          if (x > 0)\n\
    \            1\n          else if (x < 0)\n            -1\n          else\n  \
    \          0\n        })\n        if (l.isEmpty)\n          None\n        else\n\
    \          Some(l.reduce(_ * _) * arr.map(x => abs(x)).reduce(_ + _))", "    \
    \    if (arr.length == 0) return None\n        return Some(arr.map(x => abs(x)).foldLeft(1l)((a,\
    \ b) => a * b) *\n            arr.map(x => if (x == 0) 0 else if (x > 0) 1 else\
    \ -1).foldLeft(1l)((a, b) => a * b))", "        var sum = 0l\n        var prod\
    \ = 1l\n        for (i <- arr) {\n            var n = 0\n            if (i < 0)\
    \ {\n                n = -1\n            } else if (i > 0) {\n               \
    \ n = 1\n            }\n            sum += abs(i)\n            prod *= n\n   \
    \     }\n        if (sum == 0) {\n            return None\n        }\n       \
    \ return Some(sum * prod)", "        if (arr.length == 0) return None\n      \
    \  var negs = 0\n        var zeros = 0\n        for (a <- arr) {\n           \
    \ if (a == 0) zeros += 1\n            else if (a < 0) negs += 1\n        }\n \
    \       if (zeros > 0) return Some(0)\n        var sign = if (negs % 2 == 0) 1\
    \ else -1\n        var sum = 0.toLong\n        for (a <- arr) sum += abs(a)\n\
    \        Some(sum * sign)", "        val product = arr.map(x => {\n          \
    \  if (x == 0) 0\n            else if (x > 0) 1\n            else -1\n       \
    \ }).product\n        val sum = arr.map(x => abs(x)).sum\n        if (product\
    \ == 0) return Some(0)\n        return Some(sum * product)", "        val list\
    \ = arr.filter(_ != 0)\n        if (list.isEmpty) return None\n        val prod\
    \ = list.map(sign(_)).reduce(_ * _)\n        val sum = list.map(abs(_)).reduce(_\
    \ + _)\n        Some(sum * prod)", "        if (arr.length == 0) return None\n\
    \        var prod = 1l\n        var sum = 0l\n        for (x <- arr) {\n     \
    \       if (x < 0) prod *= -1\n            sum += abs(x)\n        }\n        Some(sum\
    \ * prod)", "        if (arr.length == 0) return None\n        var product = 1\n\
    \        var magnitude = 0\n        for (i <- arr) {\n            if (i == 0)\
    \ product = 0\n            else if (i < 0) product *= -1\n            magnitude\
    \ += abs(i)\n        }\n        Some(magnitude * product)", "        // TODO implement\
    \ this function\n        return null", "        if (arr.length == 0) None\n  \
    \      else Some(arr.foldLeft(1l)((prod, curr) => prod * abs(curr) * signum(curr)))",
  "        val result = arr.map(math.abs(_)).product\n        val signs = arr.map(signum(_))\n\
    \        if (signs.isEmpty) None\n        else Option(result * signs.product)",
  "        if (arr.length == 0) return None\n        var result : Long = 1\n     \
    \   for (x <- arr) {\n            if (x == 0) result = 0\n            else if\
    \ (x < 0) result *= -1\n        }\n        for (x <- arr) result *= abs(x)\n \
    \       Some(result)", "        if (arr.length == 0) return None\n        var\
    \ prod : Long = 1l.toLong\n        var sum : Long = 0l.toLong\n        for (x\
    \ <- arr) {\n            prod *= if (x < 0) -1 else if (x > 0) 1 else 0\n    \
    \        sum += x.abs\n        }\n        return Some(sum * prod)", "        arr\
    \ match {\n            case Nil => None\n            case _ => Some(arr.map(x\
    \ => scala.math.abs(x) * signum(x)).sum)\n        }", "        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            Some(arr.map(x => if (x ==\
    \ 0) 0 else x / abs(x)).reduce(_ * _) * arr.map(x => abs(x)).reduce(_ + _))\n\
    \        }", "        // your code goes here.\n        return None", "       \
    \ var res : Long = 1l\n        var empty = true\n        for (num <- arr) {\n\
    \            if (num != 0) {\n                empty = false\n                res\
    \ *= signum(num)\n            }\n        }\n        if (empty) {\n           \
    \ None\n        } else {\n            Some(res)\n        }", "        if (arr.length\
    \ == 0) return None\n        var sumMagnitude = 0\n        var prodSign = 1\n\
    \        for (n <- arr) {\n            sumMagnitude += abs(n.toInt)\n        \
    \    prodSign *= signum(n.toInt)\n        }\n        Some(sumMagnitude * prodSign)",
  "        if (arr.length == 0) None\n        else {\n            var sum = 0l\n \
    \           for (a <- arr) {\n                sum += (if (a > 0) 1 else if (a\
    \ < 0) -1 else 0)\n            }\n            var prod = 1l\n            for (a\
    \ <- arr) {\n                prod *= (if (a > 0) 1 else if (a < 0) -1 else 0)\n\
    \            }\n            Some(sum * prod)\n        }", "        if (arr.isEmpty)\
    \ return None\n        val plus = arr.map(x => (abs(x), if (x > 0) 1 else if (x\
    \ < 0) -1 else 0)).reduce((a, b) => (a._1 + b._1, a._2 * b._2))\n        Some(plus._1\
    \ * plus._2)", "        var m = 1\n        var p = 1\n        for (i <- arr) {\n\
    \            if (i > 0) p *= 1\n            else if (i < 0) p *= -1\n        \
    \    else if (i == 0) m = 0\n            m *= abs(i)\n        }\n        if (arr.length\
    \ > 0) Some(m * p) else None", "        var prod = 1\n        var sum = 0\n  \
    \      for (num <- arr) {\n            prod *= num / abs(num)\n            sum\
    \ += abs(num)\n        }\n        if (sum == 0) return None\n        Some(sum\
    \ * prod)", "        if (arr.isEmpty) return None\n        var sum = 0l\n    \
    \    var prod = 1l\n        for (i <- arr) {\n            sum += abs(i)\n    \
    \        prod *= i match {\n                case 0 => 0\n                case\
    \ _ => i / abs(i)\n            }\n        }\n        return Some(sum * prod)",
  "        if (arr.isEmpty) return None\n        var s = 1l\n        var p = 1l\n\
    \        for (i <- arr) {\n            if (i > 0) s += i\n            else if\
    \ (i < 0) s -= i\n            else p = 0\n            p *= signum(i)\n       \
    \ }\n        return Some(s * p)", "        val prod = arr.map(x => (if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)).reduce(_ * _)\n        if (prod == 0) None else\
    \ Some(arr.map(x => abs(x)).reduce(_ + _) * prod)", "        if (arr.isEmpty)\
    \ return None\n        val signs = arr.map(x => if (x == 0) 0 else if (x > 0)\
    \ 1 else -1)\n        val magnitudes = arr.map(x => x.abs)\n        var total\
    \ = 1l\n        for (s <- signs) {\n            total *= s\n        }\n      \
    \  val magnitudeTotal = magnitudes.foldLeft(0l)((x, y) => x + y)\n        Some(magnitudeTotal\
    \ * total)", "        if (arr.isEmpty) return None\n        var product : Long\
    \ = 1l\n        var sum : Long = 0l\n        for (i <- arr) {\n            product\
    \ *= (if (i == 0) 1 else (if (i > 0) 1 else -1))\n            sum += abs(i)\n\
    \        }\n        return Some(sum * product)", "        val s = arr.size\n \
    \       if (s == 0) {\n            None\n        } else {\n            val sum\
    \ = arr.map(abs(_)).sum\n            val sign = if (arr.forall(_ > 0)) 1 else\
    \ if (arr.exists(_ < 0)) -1 else 0\n            Some(sum * sign)\n        }",
  "        if (arr.isEmpty) None\n        else {\n            var product = 1l\n \
    \           var sum = 0l\n            arr.foreach(x => {\n                if (x\
    \ > 0) product *= 1\n                else if (x < 0) product *= -1\n         \
    \       else product *= 0\n                sum += abs(x)\n            })\n   \
    \         Some(sum * product)\n        }", "        var sum = 0l\n        var\
    \ prod = 1l\n        for (n <- arr) {\n            val sign = if (n < 0) -1 else\
    \ if (n > 0) 1 else 0\n            sum += sign * n\n            prod *= sign\n\
    \        }\n        if (arr.isEmpty) None else Some(sum * prod)", "        if\
    \ (arr.isEmpty) return None\n        val positiveSign = 1\n        val negativeSign\
    \ = -1\n        val zeroSign = 0\n        var sumOfMagnitudes = 0.toLong\n   \
    \     var productOfSigns = 1.toLong\n        for (number <- arr) {\n         \
    \   var sign = (number / abs(number)).toInt\n            if (sign == 0) sign =\
    \ zeroSign\n            productOfSigns *= sign\n            sumOfMagnitudes +=\
    \ abs(number)\n        }\n        return Some(sumOfMagnitudes * productOfSigns)",
  "        var total : Long = 1\n        var sum : Long = 0\n        for (i <- arr)\
    \ {\n            val sign = if (i < 0) -1 else if (i > 0) 1 else 0\n         \
    \   sum += abs(i)\n            total *= sign\n        }\n        sum * total",
  "        val l = arr.length\n        if (l == 0) return None\n        val negs =\
    \ arr.count(_ < 0)\n        val pos = arr.count(_ > 0)\n        val sum = arr.map(x\
    \ => if (x == 0) 0 else abs(x)).sum\n        val sgn = if (negs % 2 == 0) 1 else\
    \ -1\n        Some(sum * sgn)", "        def prodSignsRec(arr : List[Long], runningSign\
    \ : Long, runningProduct : Long) : Long = {\n            arr match {\n       \
    \         case Nil => runningProduct\n                case h :: t => if (h > 0)\
    \ prodSignsRec(t, 1, runningProduct * runningSign)\n                         \
    \      else if (h < 0) prodSignsRec(t, -1, runningProduct * runningSign)\n   \
    \                            else prodSignsRec(t, runningSign, runningProduct)\n\
    \            }\n        }\n        if (arr.length == 0) None\n        else Some(prodSignsRec(arr,\
    \ 1, 1))", "        if (arr.length == 0) None\n        else {\n            var\
    \ prod = 1\n            var sum = 0\n            arr.foreach(x => {\n        \
    \        if (x > 0) {\n                    prod *= 1\n                    sum\
    \ += x\n                }\n                else if (x < 0) {\n               \
    \     prod *= -1\n                    sum += (-x)\n                }\n       \
    \         else {\n                    prod *= 0\n                }\n         \
    \   })\n            Some(sum * prod)\n        }", "        if (arr.isEmpty) return\
    \ None\n        val signProduct = arr.map(x => if (x == 0) 0 else if (x > 0) 1\
    \ else -1).product\n        val magnitudeSum = arr.map(x => abs(x)).sum\n    \
    \    Some(signProduct * magnitudeSum)", "    \tif (arr.isEmpty) return None\n\
    \    \tvar product = 1l\n    \tvar sum = 0l\n    \tfor (x <- arr) {\n    \t\t\
    if (x > 0) product *= 1\n    \t\telse if (x < 0) product *= -1\n    \t\telse if\
    \ (x == 0) product *= 0\n    \t\tsum += math.abs(x)\n    \t}\n    \tsum *= product\n\
    \    \treturn Some(sum)", "        if (arr.isEmpty) None\n        else {\n   \
    \         var s = 1l\n            var m = 0l\n            for (n <- arr) {\n \
    \               if (n > 0) s *= 1\n                else if (n < 0) s *= -1\n \
    \               else {\n                    s = 0\n                    m = 0\n\
    \                }\n                m += abs(n)\n            }\n            Some(s\
    \ * m)\n        }", "        // Your code here.\n        if (arr.isEmpty) None\n\
    \        else {\n            val signs = arr.map(x => if (x == 0) 0 else if (x\
    \ > 0) 1 else -1)\n            val magnitudes = arr.map(x => abs(x))\n       \
    \     Some(magnitudes.foldLeft(1l)(_ * _) * signs.foldLeft(1l)(_ * _))\n     \
    \   }", "        if (arr.length == 0) return None\n        var product = 1l\n\
    \        var sum = 0l\n        for (x <- arr) {\n            if (x == 0) {\n \
    \               product = 0\n                sum = 0\n            } else if (x\
    \ < 0) {\n                product *= -1\n                sum += abs(x)\n     \
    \       } else {\n                sum += x\n            }\n        }\n       \
    \ return Some(sum * product)", '        None', "        if (arr.isEmpty) None\n\
    \        else Some(arr.map(abs(_)).sum * arr.map(_.signum).product)", "\tval arr2\
    \ = arr.filter(x => x != 0l)\n\tif (arr2.length > 0) {\n\t    val l = arr2.map(x\
    \ => if (x < 0) -1 else 1).foldLeft(1)((x, y) => x * y)\n\t    val m = arr2.map(x\
    \ => abs(x)).sum\n\t    Some(l * m)\n\t} else {\n\t    None\n\t}", "        //\
    \ Your code here\n        var product = 1l\n        var sum = 0l\n        for\
    \ (x <- arr) {\n            if (x > 0) {\n                product *= 1\n     \
    \           sum += x\n            }\n            else if (x < 0) {\n         \
    \       product *= -1\n                sum += -x\n            }\n            else\
    \ {\n                product *= 0\n            }\n        }\n        if (arr.length\
    \ == 0) {\n            None\n        }\n        else {\n            Some(sum *\
    \ product)\n        }", "        if (arr.length == 0) return None\n        var\
    \ prod : Long = 1\n        var sum : Long = 0\n        for (n <- arr) {\n    \
    \        prod *= Math.signum(n).toLong\n            sum += Math.abs(n)\n     \
    \   }\n        return Some(sum * prod)", "        if (arr.length > 0) {\n    \
    \        var signProd = 1l\n            var magSum = 0l\n            for (i <-\
    \ arr) {\n                if (i > 0) signProd *= 1\n                else if (i\
    \ < 0) signProd *= -1\n                else signProd *= 0\n                magSum\
    \ += i.abs\n            }\n            Some(magSum * signProd)\n        } else\
    \ None", "        if (arr.length > 0) {\n        \tval zeros = arr.filter(_ ==\
    \ 0).length\n        \tval negatives = arr.filter(_ < 0).length\n        \tval\
    \ positives = arr.filter(_ > 0).length\n        \tval magnitude = arr.map(abs(_)).sum\n\
    \        \tval product = pow(0.5, zeros) * pow(-0.5, negatives) * pow(1.5, positives)\n\
    \        \tSome(magnitude * product)\n        } else {\n        \tNone\n     \
    \   }", "        if (arr.isEmpty) return None\n        val signs = arr.map {x\
    \ =>\n            if (x > 0) 1\n            else if (x < 0) -1\n            else\
    \ 0\n        }\n        val magnitudes = arr.map {x => abs(x)}\n        val signProd\
    \ = signs.reduceLeft(_ * _)\n        val magnitudeSum = magnitudes.reduceLeft(_\
    \ + _)\n        Option(signProd * magnitudeSum)", "        if (arr.length == 0)\
    \ None\n        else Some(arr.foldLeft(1l.toLong)((a, b) => if (b == 0) a else\
    \ a * signum(b).toLong))", "        var ans : Long = 1l\n        for (i <- arr)\
    \ ans *= abs(i)\n        return Some(ans)", "        // your code here\n     \
    \   null", "    \tif (arr.isEmpty) None\n    \telse Some(arr.map(x => if (x >\
    \ 0) 1l else if (x < 0) -1l else 0l).reduce(_ * _) * arr.map(x => abs(x)).reduce(_\
    \ + _))", "        if (arr.length == 0) {\n            None\n        } else {\n\
    \            var magnitudes = arr.map(x => if (x < 0) -x else x)\n           \
    \ var sum = magnitudes.sum\n            var product = arr.map(x => if (x < 0)\
    \ -1 else 1).product\n            Some(sum * product)\n        }", "        if\
    \ (arr.length == 0) return None\n        val signs = arr.map(x => if (x > 0) 1\
    \ else if (x < 0) -1 else 0)\n        val mags = arr.map(abs(_))\n        val\
    \ signProduct = signs.foldLeft(1)(_ * _)\n        Some(mags.foldLeft(0l)(_ + _)\
    \ * signProduct)", "        var prod = 1l\n        var sum = 0l\n        for (x\
    \ <- arr) {\n            prod *= x / abs(x)\n            sum += abs(x)\n     \
    \   }\n        return if (sum == 0) None else Some(sum * prod)", "        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            var sum = 0l\n          \
    \  var product = 1l\n            arr.foreach(i => {\n                if (i ==\
    \ 0) product *= 0\n                else product *= signum(i)\n               \
    \ sum += abs(i)\n            })\n            Some(sum * product)\n        }",
  "        if (arr.isEmpty) return None\n        var m = 1\n        var s = 1\n  \
    \      for (i <- arr) {\n            m *= abs(i)\n            s *= if (i < 0)\
    \ -1 else if (i > 0) 1 else 0\n        }\n        Some(m * s)", "        val ans\
    \ = arr.foldLeft(Some(0l.toLong) : Option[Long])((x, y) => {\n            if (x\
    \ == None) None\n            else {\n                if (y == 0) Some(x.get *\
    \ 0)\n                else if (y > 0) Some(x.get * 1)\n                else Some(x.get\
    \ * -1)\n            }\n        })\n        if (ans == None) None\n        else\
    \ {\n            var product = 1l.toLong\n            for (x <- arr) {\n     \
    \           if (x != 0) product *= abs(x)\n            }\n            Some(product\
    \ * ans.get)\n        }", "        var s = 0l\n        var p = 1l\n        for\
    \ (x <- arr) {\n            s += abs(x)\n            if (x > 0) p *= 1\n     \
    \       else if (x < 0) p *= -1\n        }\n        if (arr.isEmpty) return None\n\
    \        return Some(s * p)", "        if (arr.isEmpty) return None\n        var\
    \ prod = 1l\n        var sum = 0l\n        for (i <- arr) {\n            prod\
    \ *= if (i == 0) 1 else if (i > 0) 1 else -1\n            sum += abs(i)\n    \
    \    }\n        Some(sum * prod)", "        // Another possible solution:\n  \
    \      // arr.map(_.signum).product * arr.map(abs(_)).sum\n        // Also, it's\
    \ possible to solve this problem in functional\n        // style, which is more\
    \ common in Scala.\n        if (arr.isEmpty) return None\n        var sum = 0l\n\
    \        var prod = 1l\n        for (i <- arr) {\n            sum += abs(i)\n\
    \            prod *= if (i > 0) 1 else if (i < 0) -1 else 0\n        }\n     \
    \   Some(sum * prod)", "        if (arr.length == 0) return None\n        val\
    \ signs = arr.map {\n            case x if x > 0 => 1\n            case x if x\
    \ < 0 => -1\n            case x if x == 0 => 0\n        }\n        val ret = arr.map\
    \ {\n            case x if x > 0 => x\n            case x if x < 0 => -x\n   \
    \         case x if x == 0 => 0\n        }.sum * signs.product\n        Some(ret)",
  "        if (arr.isEmpty) None\n        else Some(arr.map(x => signum(x)).product\
    \ * arr.map(x => abs(x)).sum)", "        if (arr.length == 0) None\n        else\
    \ {\n            val magnitudes = arr.map(a => abs(a))\n            val signs\
    \ = arr.map(a => if (a > 0) 1 else if (a < 0) -1 else 0)\n            Some(magnitudes.sum\
    \ * signs.product)\n        }", "        if (arr.isEmpty) return None\n      \
    \  arr.foldLeft(1l.toLong, 0l.toLong) {case ((ps, ms), e) => if (e < 0) (ps *\
    \ -1, ms + abs(e)) else if (e > 0) (ps, ms + e) else (ps, ms)} match {\n     \
    \       case (p, m) => Some(p * m)\n        }", "        if (arr.isEmpty) return\
    \ None\n        var p = 1l.toLong\n        var s = 0l.toLong\n        for (i <-\
    \ arr) {\n            if (i == 0) continue\n            if (i < 0) p *= -1\n \
    \           s += abs(i)\n        }\n        Some(p * s)", "        // Write your\
    \ code here\n        ???", "      if (arr.length == 0) return None\n      val\
    \ ret = arr.map(abs(_)).reduceLeft((a, b) => a * b) * arr.map(_.signum).reduceLeft((a,\
    \ b) => a * b)\n      return Some(ret)", "        if (arr.length == 0) return\
    \ None\n        var prod = 1l\n        var sum = 0l\n        for (x <- arr) {\n\
    \            prod *= x.signum\n            sum += x.abs\n        }\n        Some(sum\
    \ * prod)", "        if (arr.length == 0) {\n            None\n        } else\
    \ {\n            val prods = arr.map(x => if (x > 0) 1 else if (x < 0) -1 else\
    \ 0)\n            val magn = arr.map(x => abs(x))\n            Option(magn.sum\
    \ * prods.product)\n        }", "        if (arr.length == 0) None\n        else\
    \ {\n            val signs = arr.map(x => if (x == 0) 0 else if (x > 0) 1 else\
    \ -1)\n            val mags = arr.map(x => abs(x))\n            Some(mags.foldLeft(1l)(_\
    \ * _) * signs.foldLeft(1l)(_ * _))\n        }", "        val t = arr.map(x =>\
    \ (abs(x), if (x > 0) 1 else if (x < 0) -1 else 0)).toArray\n        var product\
    \ = 1\n        var sum = 0\n        for (x <- t) {\n            product *= x._2\n\
    \            sum += x._1\n        }\n        if (product == 0) None else Some(sum\
    \ * product)", "        // your code here\n        var x : Long = 0\n        var\
    \ y : Long = 1\n        if (arr.length == 0) return None\n        for (i <- arr)\
    \ {\n            if (i != 0) {\n                x += abs(i)\n                y\
    \ *= i / abs(i)\n            }\n        }\n        Some(x * y)", "        // Your\
    \ code goes here.\n        val option : Option[Long] = Some(0)\n        return\
    \ option", "        // your code here\n        if (arr.isEmpty) None\n       \
    \ else {\n            val a = arr.map(_.abs)\n            val b = arr.map(_.signum)\n\
    \            Some(a.product * b.product)\n        }", "        if (arr.isEmpty)\
    \ None\n        else {\n            var prod = arr.head\n            for (i <-\
    \ 1 until arr.length) {\n                if (arr(i) == 0l) prod = 0l\n       \
    \         else if (prod == 0l) prod = arr(i)\n                else if (prod >\
    \ 0) prod *= arr(i)\n                else if (prod < 0 && arr(i) > 0) prod *=\
    \ arr(i)\n                else if (prod < 0 && arr(i) < 0) prod *= arr(i)\n  \
    \          }\n            var mag = 0l\n            for (i <- 0 until arr.length)\
    \ {\n                if (arr(i) > 0) mag += arr(i)\n                else if (arr(i)\
    \ < 0) mag -= arr(i)\n            }\n            Some(mag * prod)\n        }",
  "\t    if (arr.isEmpty) None\n\t    else {\n\t\t    val prod = arr.map(i => if (i\
    \ < 0) -1 else if (i > 0) 1 else 0).product\n\t\t    val sum = arr.map(i => abs(i)).sum\n\
    \t\t    Some(sum * prod)\n\t    }", "        // Your code goes here\n        var\
    \ sums = 0l\n        var prod = 1l\n        for (a <- arr) {\n            sums\
    \ += a.abs\n            prod *= (if (a > 0) 1 else if (a < 0) -1 else 0)\n   \
    \     }\n        if (arr.length == 0) None else Some(sums * prod)", "        if\
    \ (arr.length == 0) return None\n        var sign = 1\n        var sum = 0\n \
    \       for (a <- arr) {\n            if (a == 0) {\n                sign = 0\n\
    \                sum = 0\n            } else {\n                sum += a.abs\n\
    \                sign *= a.signum\n            }\n        }\n        return Some(sum\
    \ * sign)", "        // Your Code Here\n        None", "        if (arr.length\
    \ == 0) {\n            None\n        } else {\n            val signList = arr.map(x\
    \ => if (x == 0) 0 else if (x > 0) 1 else -1)\n            val prod = signList.product\n\
    \            val sum = arr.map(x => abs(x)).sum\n            Some(sum * prod)\n\
    \        }", "        if (arr.isEmpty) None\n        else {\n            val n\
    \ = arr.length\n            val s = sum(arr)\n            val p = product(arr)\n\
    \            Some(s * p)\n        }", "        if (arr.length == 0) {\n      \
    \      None\n        } else {\n            val prod = arr.map(el => el.signum).product\n\
    \            val sum = arr.map(el => abs(el)).sum\n            Some(sum * prod)\n\
    \        }", "        if (arr.isEmpty) return None\n        var signs = 1\n  \
    \      var magnitudes = 0\n        for (n <- arr) {\n            if (n > 0) signs\
    \ *= 1\n            else if (n < 0) signs *= -1\n            else signs *= 0\n\
    \            magnitudes += abs(n.toInt)\n        }\n        Some(magnitudes *\
    \ signs)", "        if (arr.length == 0) {\n            None\n        } else {\n\
    \            var prod = 1l.toLong\n            var sum = 0l.toLong\n         \
    \   for (x <- arr) {\n                prod *= x.signum\n                sum +=\
    \ x.abs\n            }\n            Some(sum * prod)\n        }", "        //\
    \ Your Code Here\n        if (arr.length == 0) return None\n        var nums =\
    \ List[Int]()\n        for (num <- arr) {\n        \tif (num == 0) nums = nums\
    \ :+ 0\n        \telse if (num > 0) nums = nums :+ 1\n        \telse nums = nums\
    \ :+ -1\n        }\n        var prod = 1\n        for (num <- nums) {\n      \
    \  \tprod *= num\n        }\n        var sum = 0\n        for (num <- arr) {\n\
    \        \tsum += abs(num)\n        }\n        return Some(sum * prod)", "   \
    \     if (arr.length == 0) return None\n        var x = 1l\n        var s = 0l\n\
    \        for (i <- arr) {\n            if (i > 0) x *= 1\n            else if\
    \ (i < 0) x *= -1\n            else { x = 0; s += 1 }\n            s += abs(i)\n\
    \        }\n        Some(s * x)", "        if (arr.isEmpty) None\n        else\
    \ {\n            val abs_arr = arr.map(abs(_))\n            Some(abs_arr.product\
    \ * arr.map(signum(_)).product)\n        }", "        if (arr.isEmpty) return\
    \ None\n        return Some(arr.foldLeft(1l)((x, y) => x * y))", "        val\
    \ signs = arr.map(x => if (x > 0) 1 else if (x < 0) -1 else 0)\n        val magnitudes\
    \ = arr.map(x => abs(x))\n        if (magnitudes.isEmpty) None else Some(magnitudes.sum\
    \ * signs.product)", "        if (arr.length == 0) None\n        else {\n    \
    \        Some(arr.foldLeft(1l.toLong)((sum, n) => {\n                if (n < 0)\
    \ -abs(n) + sum\n                else if (n > 0) abs(n) + sum\n              \
    \  else sum\n            }))\n        }", "        if (arr.isEmpty) return None\n\
    \        var prod = 1\n        var sum = 0\n        for (x <- arr) {\n       \
    \     prod *= (if (x > 0) 1 else if (x < 0) -1 else 0)\n            sum += abs(x.toInt)\n\
    \        }\n        return Some(sum * prod)", "        val N = arr.length\n  \
    \      if (N == 0) None\n        else {\n            var prod = 1l\n         \
    \   var sum = 0l\n            for (i <- 0 until N) {\n                val x =\
    \ arr(i)\n                if (x < 0) prod *= -1\n                else if (x ==\
    \ 0) prod = 0\n                sum += abs(x)\n            }\n            Some(sum\
    \ * prod)\n        }", "        val signArr = arr.map(x => if (x == 0) 0 else\
    \ if (x > 0) 1 else -1)\n        if (signArr.size > 0) {\n            val res\
    \ = signArr.foldLeft(1)((res, x) => res * x)\n            val magnitudes = arr.map(x\
    \ => if (x < 0) -x else x)\n            Some(magnitudes.foldLeft(0l)((res, x)\
    \ => res + x) * res)\n        } else {\n            None\n        }", '        return
    if (arr.isEmpty) None else Some(arr.map(x => if (x == 0) 0 else if (x > 0) 1 else
    -1).product * arr.map(x => abs(x)).sum)', "        if (arr.length == 0) return\
    \ None\n        var prod = 0l.toLong\n        var sum = 0l.toLong\n        for\
    \ (x <- arr) {\n            prod *= if (x == 0) 0 else if (x > 0) 1 else -1\n\
    \            sum += abs(x)\n        }\n        return Some(sum * prod)", "   \
    \     if (arr.length == 0) None\n        else {\n            var temp = 1l\n \
    \           for (x <- arr) {\n                if (x == 0) temp = 0\n         \
    \       else if (x < 0) temp *= -1\n            }\n            var sum = 0l\n\
    \            for (x <- arr) {\n                if (x != 0) sum += abs(x)\n   \
    \         }\n            Some(sum * temp)\n        }", "        if (arr.isEmpty)\
    \ return None\n        var ans = 1l.toLong\n        for (i <- arr) ans *= i\n\
    \        Some(ans)", "        val product = arr.product\n        product match\
    \ {\n            case 0 => Some(0)\n            case _ => Some(arr.map(abs(_)).sum\
    \ * product)\n        }", "        var sgn_magnitude = 0\n        for (i <- arr)\
    \ {\n            val sign =\n                if (i > 0) 1\n                else\
    \ if (i < 0) -1\n                else 0\n            val magnitude = abs(i)\n\
    \            sgn_magnitude += sign * magnitude\n        }\n        if (arr.length\
    \ > 0) Some(sgn_magnitude)\n        else None", "        arr match {\n       \
    \     case List() => None\n            case _ => {\n                var sign =\
    \ 1\n                var sum = 0\n                for (i <- arr) {\n         \
    \           if (i > 0) {\n                        sign *= 1\n                \
    \        sum += i\n                    } else if (i < 0) {\n                 \
    \       sign *= -1\n                        sum += -i\n                    } else\
    \ {\n                        sign *= 0\n                    }\n              \
    \  }\n                Some(sum * sign)\n            }\n        }", "        if\
    \ (arr.length == 0) None\n        else Some(arr.map(x => x.abs).product * arr.filter(x\
    \ => x != 0l).map(x => signum(x)).product)", "        if (arr.isEmpty) {\n   \
    \         None\n        } else {\n            var sum = 0l\n            var prod\
    \ = 1l\n            for (x <- arr) {\n                if (x == 0) sum += 1\n \
    \               else if (x > 0) sum += x\n                else sum -= x\n    \
    \            prod *= scala.math.signum(x)\n            }\n            Some(sum\
    \ * prod)\n        }", "        if (arr.isEmpty) return None\n        var p =\
    \ 1l\n        var s = 0l\n        for (i <- arr) {\n            if (i > 0) p *=\
    \ 1\n            else if (i < 0) p *= -1\n            s += abs(i)\n        }\n\
    \        return Some(p * s)", "        // your code here\n        None", "   \
    \     // Your code here\n        var mul = 1l\n        var sum = 0l\n        for\
    \ (i <- arr) {\n            if (i == 0) {\n                return None\n     \
    \       }\n            else if (i > 0) {\n                mul *= 1\n         \
    \       sum += i\n            }\n            else {\n                mul *= -1\n\
    \                sum += (-i)\n            }\n        }\n        Some(mul * sum)",
  "      if (arr.isEmpty) None\n      else Some(arr.map(v => (abs(v) * (if (v == 0)\
    \ 0 else signum(v)))).reduce(_ + _))", "\t\tvar prod = arr.foldLeft(1l)((acc,\
    \ x) => {\n\t\t\tif (x == 0) {\n\t\t\t\t0\n\t\t\t} else {\n\t\t\t\tif (x > 0)\
    \ acc * 1 else acc * -1\n\t\t\t}\n\t\t})\n\t\tvar smag = arr.foldLeft(0l)((acc,\
    \ x) => {\n\t\t\tif (x != 0) {\n\t\t\t\tacc + x.abs\n\t\t\t} else {\n\t\t\t\t\
    acc\n\t\t\t}\n\t\t})\n\t\tif (prod == 0) None else Some(smag * prod)", "     \
    \   if (arr.length == 0) None\n        else {\n            var sum = 0l\n    \
    \        var product = 1l\n            for (i <- arr) {\n                if (i\
    \ == 0) product *= 0\n                else {\n                    sum += abs(i)\n\
    \                    product *= abs(i) / i\n                }\n            }\n\
    \            Some(sum * product)\n        }", "        if (arr.isEmpty) {\n  \
    \          None\n        } else {\n            val signs = arr.map(x => if (x\
    \ > 0) 1 else if (x < 0) -1 else 0)\n            val magnitudes = arr.map(x =>\
    \ if (x > 0) x else if (x < 0) -x else 0)\n            Some(magnitudes.product\
    \ * signs.product)\n        }", "        val res = if (arr.isEmpty) {\n      \
    \      None\n        } else {\n            val sum = arr.map(abs(_)).sum\n   \
    \         val prod = arr.filter(_ != 0).map(signum(_)).product\n            Some(sum\
    \ * prod)\n        }\n        res", "      // Fill-in here\n      None", "   \
    \     if (arr.isEmpty) return None\n        var result : Long = 1\n        var\
    \ ans : Long = 0\n        for (x <- arr) {\n            if (x == 0) {\n      \
    \          result = 0\n                ans = 0\n            } else if (x > 0)\
    \ {\n                ans += x\n            } else {\n                ans += (-x)\n\
    \                result *= -1\n            }\n        }\n        if (result ==\
    \ 0) return Some(0)\n        return Some(ans * result)", "        if (arr.length\
    \ == 0) {\n            None\n        } else {\n            var signProduct = 1l.toLong\n\
    \            var sumMagnitudes = 0l.toLong\n            for (i <- arr) {\n   \
    \             val sign = i match {\n                    case n if n < 0 => -1\n\
    \                    case n if n > 0 => 1\n                    case n if n ==\
    \ 0 => 0\n                }\n                signProduct *= sign\n           \
    \     sumMagnitudes += abs(i)\n            }\n            Some(sumMagnitudes *\
    \ signProduct)\n        }", "        if (arr.length == 0) return None\n      \
    \  var signProduct = 1l\n        var magnitudeSum = 0l\n        for (x <- arr)\
    \ {\n            val sign = if (x == 0) 0 else if (x > 0) 1 else -1\n        \
    \    signProduct *= sign\n            magnitudeSum += x.abs\n        }\n     \
    \   return Some(signProduct * magnitudeSum)", "      if (arr.isEmpty) return None\n\
    \      var sum = 0l\n      for (n <- arr) {\n        if (n < 0) sum += -n\n  \
    \      else if (n > 0) sum += n\n      }\n      var prod = 1l\n      for (n <-\
    \ arr) {\n        if (n < 0) prod *= -1\n        else if (n > 0) prod *= 1\n \
    \     }\n      sum * prod", "        if (arr.length == 0) {\n            None\n\
    \        } else {\n            var ans = 0l\n            for (x <- arr) {\n  \
    \              var y = x\n                if (y > 0) {\n                    ans\
    \ += y\n                } else if (y < 0) {\n                    ans -= y\n  \
    \              }\n            }\n            var p = 1\n            for (x <-\
    \ arr) {\n                var y = x\n                if (y != 0) {\n         \
    \           p *= x / abs(x)\n                }\n            }\n            ans\
    \ *= p\n            Some(ans)\n        }", "        if (arr.length == 0) return\
    \ None\n        else {\n            val magnitudes = arr.map(abs(_))\n       \
    \     val signs = arr.map(x => if (x == 0) 0 else if (x > 0) 1 else -1)\n    \
    \        val magnitudeProduct = magnitudes.reduce(_ * _)\n            val signProduct\
    \ = signs.reduce(_ * _)\n            return Some(magnitudeProduct * signProduct)\n\
    \        }", "        if (arr.isEmpty) None\n        else {\n            var sign\
    \ = 0l\n            var mag = 0l\n            for (i <- arr) {\n             \
    \   if (i < 0) sign -= 1\n                else if (i > 0) sign += 1\n        \
    \        mag += abs(i)\n            }\n            if (sign == 0) Some(0)\n  \
    \          else Some(sign * mag)\n        }", "        if (arr.isEmpty) None\n\
    \        else Some(arr.map(x => if (x == 0) 0 else x / abs(x.toDouble)).product\
    \ * arr.map(x => abs(x)).sum)", "      if (arr.isEmpty) None\n      else {\n \
    \       var prod = 1l\n        var sum = 0l\n        for (i <- arr) {\n      \
    \    prod *= i / abs(i)\n          sum += abs(i)\n        }\n        Some(sum\
    \ * prod)\n      }", "        if (arr.length == 0) return None\n        val sign\
    \ = arr.map(abs(_)).product\n        var prod = 1l\n        for (i <- arr) {\n\
    \            i match {\n                case x if x > 0 => prod *= 1\n       \
    \         case x if x < 0 => prod *= -1\n                case _ => prod *= 0\n\
    \            }\n        }\n        return Some(sign * prod)", "        if (arr.isEmpty)\
    \ return None\n        val result = arr.map(a => if (a < 0) -1 else if (a > 0)\
    \ 1 else 0).foldLeft(1)((a, b) => a * b)\n        return Some(arr.map(a => if\
    \ (a == 0) 0 else if (a < 0) -a else a).sum * result)", "        if (arr.length\
    \ == 0) None\n        else {\n            var prod = 1\n            var sum =\
    \ 0\n            for (e <- arr) {\n                sum += e.abs\n            \
    \    if (e > 0) prod *= 1\n                else if (e < 0) prod *= -1\n      \
    \          else prod *= 0\n            }\n            Some(sum * prod)\n     \
    \   }", "        if (arr.isEmpty) {\n            None\n        } else {\n    \
    \        var prod = 1l\n            var sum = 0l\n            for (i <- arr) {\n\
    \                if (i > 0) {\n                    prod *= 1\n               \
    \     sum += i\n                } else if (i < 0) {\n                    prod\
    \ *= -1\n                    sum += -i\n                } else {\n           \
    \         sum += 0\n                }\n            }\n            Option(sum *\
    \ prod)\n        }", "        val sign = (x : Long) => if (x == 0) 0 else if (x\
    \ > 0) 1 else -1\n        val zeroCount = arr.filter(_ == 0).length\n        if\
    \ (zeroCount > 0) return Some(0)\n        val list = arr.map(abs(_)).map(sign(_))\n\
    \        Some(list.product * list.sum)", "        //if (arr.isEmpty) return None\n\
    \        var sign = 1\n        var sum = 0\n        for (i <- arr) {\n       \
    \     if (i < 0) sign *= -1\n            sum += abs(i)\n        }\n        if\
    \ (arr.isEmpty) None\n        else Some(sum * sign)", "        if (arr.length\
    \ == 0) return None\n        val p = arr.map(e => if (e < 0) -1 else if (e > 0)\
    \ 1 else 0).product\n        val s = arr.map(e => abs(e)).sum\n        Some(p\
    \ * s)", "        // Implementation here.\n        if (arr.isEmpty) return None\n\
    \        else {\n            val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n            val magnitudes = arr.map(x => abs(x))\n        \
    \    Some(magnitudes.foldLeft(1l)(_ * _) * signs.foldLeft(1l)(_ * _))\n      \
    \  }", "        if (arr.isEmpty) return None\n        var a = 1l\n        var\
    \ x = 1l\n        for (i <- arr) {\n            x *= i.abs\n            if (i\
    \ != 0) a *= i.signum\n        }\n        Some(x * a)", '        // Write your
    code here', "        if (arr.isEmpty) {\n            None\n        } else {\n\
    \            val sumMagnitudes = arr.map(x => x.abs).sum\n            val productSigns\
    \ = arr.foldLeft(1l)((accum, x) => accum * (if (x < 0) -1 else if (x > 0) 1 else\
    \ 0))\n            Some(sumMagnitudes * productSigns)\n        }", "        //\
    \ Good luck! Add any helper functions you may need.\n        def mult(product\
    \ : Long, list : List[Long]) : Long = {\n            if (list.isEmpty) product\n\
    \            else if (list.head > 0) mult(product, list.tail)\n            else\
    \ if (list.head < 0) mult(product * (-1), list.tail)\n            else mult(0,\
    \ list.tail)\n        }\n        if (arr.isEmpty) None\n        else Some(arr.map(abs(_)).sum\
    \ * mult(1, arr))", "        // Your Solution Here\n        if (arr.isEmpty) None\n\
    \        else Some(arr.map(abs(_)).sum * arr.map(signum(_)).product)", "     \
    \   if (arr.length == 0) {\n            None\n        } else {\n            var\
    \ sum = 0.toLong\n            var prod = 1.toLong\n            for (i <- arr)\
    \ {\n                sum += abs(i)\n                prod *= i.signum\n       \
    \     }\n            Some(sum * prod)\n        }", "        if (arr.isEmpty) {\n\
    \            None\n        } else {\n            var sum = 0l\n            var\
    \ prod = 1l\n            for (i <- arr) {\n                if (i > 0) {\n    \
    \                sum += i\n                    prod *= 1\n                } else\
    \ if (i < 0) {\n                    sum += (-i)\n                    prod *= (-1)\n\
    \                } else {\n                    sum += 0\n                    prod\
    \ *= 0\n                }\n            }\n            Some(sum * prod)\n     \
    \   }", "        var mul = 1\n        var sum = 0\n        for (x <- arr) {\n\
    \            if (x > 0) {\n                mul *= 1\n                sum += x\n\
    \            } else if (x < 0) {\n                mul *= -1\n                sum\
    \ += -x\n            } else {\n                mul *= 0\n            }\n     \
    \   }\n        if (arr.length > 0) {\n            return Some(mul * sum)\n   \
    \     } else {\n            return None\n        }", "        val arr2 = arr.map(x\
    \ => if (x > 0) 1 else if (x < 0) -1 else 0)\n        val prod = arr2.foldLeft(1)(_\
    \ * _)\n        if (prod == 0) return None\n        else {\n            val sum\
    \ = arr.foldLeft(0l)(_ + abs(_))\n            return Some(sum * prod)\n      \
    \  }", "        val res = arr.foldLeft((1l, 0l))((t, i) => if (i == 0) (0l, 0l)\
    \ else (t._1 * i.signum, t._2 + i.abs))\n        if (res._1 == 0) None else Some(res._1\
    \ * res._2)"]
stop_tokens:
- "\n    }\n"
