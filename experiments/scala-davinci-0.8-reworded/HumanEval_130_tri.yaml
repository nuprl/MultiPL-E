name: HumanEval_130_tri
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
  \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
  \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    // tri(1)\
  \ = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n - 1) + tri(n\
  \ - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2) = 1 + (2 /\
  \ 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n    // =\
  \ 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n, you have\
  \ to a return a list of the \n    // first n + 1 numbers of the Tribonacci sequence.\n\
  \    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong, 3l.toLong,\
  \ 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n    assert(tri((7l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n\
  \    assert(tri((8l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
  \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
  \ 5l.toLong, 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
  \ 5l.toLong, 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong,\
  \ 80l.toLong, 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n\
  \    assert(tri((0l)).equals((List[Long](1l.toLong))));\n    assert(tri((1l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong))));\n    }\n\n}\n"
completions: ["        var result = new ArrayBuffer[Long]()\n        result += 1\n\
    \        result += 3\n        var i = 3\n        while (i <= n) {\n          \
    \  var v = result(i - 1) + result(i - 2) + result(i - 3)\n            if (i %\
    \ 2 == 0) v += i / 2\n            result += v\n            i += 1\n        }\n\
    \        result.toList", "        if (n < 1) List(1)\n        else {\n       \
    \     val seq = ListBuffer[Long]()\n            seq += 1\n            seq += 3\n\
    \            seq += 2\n            val arr = Array.fill(n.toInt)(0L)\n       \
    \     seq.copyToBuffer(arr)\n            for (i <- 3 to n.toInt) {\n         \
    \       arr(i) = if (i % 2 == 0) 1 + i / 2 else arr(i - 1) + arr(i - 2) + arr(i\
    \ + 1)\n            }\n            arr.toList\n        }", "        def sub(n\
    \ : Long, lst : List[Long]) : List[Long] = {\n            if (n == 0) lst.reverse\n\
    \            else if (n % 2 == 0) sub(n - 1, n / 2 + 1 :: lst)\n            else\
    \ sub(n - 1, lst(0) + lst(1) + lst(2) :: lst)\n        }\n        sub(n, List(1,\
    \ 3, 2))", "        if (n < 1) {\n            List(1l)\n        } else if (n ==\
    \ 1) {\n            List(1l, 3l)\n        } else {\n            val result = new\
    \ ListBuffer[Long]\n            result += 1l\n            result += 3l\n     \
    \       result += 2l\n            var i = 1\n            while (i < n) {\n   \
    \             if (i % 2 == 0) {\n                    result += 1 + i / 2\n   \
    \             } else {\n                    result += result(i - 1) + result(i\
    \ - 2) + result(i + 1)\n                }\n                i += 1\n          \
    \  }\n            result.toList\n        }", "        if (n == 0) return List(1)\n\
    \        val t = new Array[Long]((n + 1).toInt)\n        t(0) = 1\n        t(1)\
    \ = 3\n        for (i <- 2 to (n - 1).toInt) {\n            if (i % 2 == 0) {\n\
    \                t(i) = 1 + i / 2\n            } else {\n                t(i)\
    \ = t(i - 1) + t(i - 2) + t(i + 1)\n            }\n        }\n        t.toList",
  "        val result = new ArrayBuffer[Long]()\n        result += 1\n        result\
    \ += 3\n        if (n == 1) return result.toList\n        result += 2\n      \
    \  if (n == 2) return result.toList\n        for (i <- 3 to n.toInt) {\n     \
    \       if (i % 2 == 0) result += (1 + i / 2)\n            else result += (result(i\
    \ - 1) + result(i - 2) + result(i + 1))\n        }\n        result.toList", " \
    \   \tval r = ListBuffer[Long]()\n    \tr += 1\n    \tr += 3\n    \tr += 2\n \
    \   \tdef f(i : Long) : Long = {\n    \t\tif (i == n) return r(r.length - 1)\n\
    \    \t\telse {\n    \t\t\tif (i % 2 == 0) r += (1 + i / 2)\n    \t\t\telse r\
    \ += (r(r.length - 1) + r(r.length - 2) + r(r.length + 1))\n    \t\t\tf(i + 1)\n\
    \    \t\t}\n    \t}\n    \tf(3)\n    \tr.toList", "        // f(n) = 1 + n / 2\
    \ if n is even.\n        // f(n) = f(n - 1) + f(n - 2) + f(n + 1) if n is odd.\n\
    \        def f(n : Long) : Long = {\n            if (n == 1) 3\n            else\
    \ if (n % 2 == 0) {\n                1 + n / 2\n            } else {\n       \
    \         f(n - 1) + f(n - 2) + f(n + 1)\n            }\n        }\n        List.range(1,\
    \ n + 2).map(f(_)).toList", "        def rec(x : Long, l : List[Long]) : List[Long]\
    \ = {\n            x match {\n                case 1 => rec(x + 1, l :+ 3)\n \
    \               case x if x > n => l\n                case x if x % 2 == 0 =>\
    \ rec(x + 1, l :+ (1 + x / 2))\n                case x => rec(x + 1, l :+ (l(x.toInt\
    \ - 2) + l(x.toInt - 1) + l(x.toInt + 1)))\n            }\n        }\n       \
    \ rec(1, List[Long]())", "        // TODO\n        List[Long]()", "        var\
    \ l = List[Long]()\n        var c = 0\n        while (c <= n) {\n            l\
    \ = c match {\n                case 0 => List(0)\n                case 1 => List(0,\
    \ 1)\n                case 2 => List(0, 1, 3)\n                case _ => l :+\
    \ (1 + c / 2)\n            }\n            c += 1\n        }\n        l", "\t\t\
    // Fill up this function body\n\t\t// You can add another function as well, if\
    \ required\n        var l = Array.fill(n.toInt+1)(0L)\n        l(0) = 1\n    \
    \    l(1) = 3\n        if (n >= 2) {\n            l(2) = 2\n            for (i\
    \ <- 3 to n.toInt) {\n                if (i % 2 == 0) l(i) = (i / 2).toLong\n\
    \                else l(i) = l(i - 1) + l(i - 2) + l(i + 1)\n            }\n \
    \       }\n        l.toList", "        var lst = new ListBuffer[Long]\n      \
    \  if (n == 0) {\n            lst += 1\n            return lst.toList\n      \
    \  }\n        lst += 1\n        if (n == 1) return lst.toList\n        lst +=\
    \ 3\n        if (n == 2) return lst.toList\n        lst += 2\n        if (n ==\
    \ 3) return lst.toList\n        lst += 8\n        if (n == 4) return lst.toList\n\
    \        var i = 4\n        while (i < n) {\n            lst += (if (i % 2 ==\
    \ 0) lst(i) + 1 else lst(i - 1) + lst(i - 2) + lst(i + 1))\n            i += 1\n\
    \        }\n        return lst.toList", "        // Fill up this function body\n\
    \        // 'n' is the number of elements in the Tribonacci sequence\n       \
    \ List[Long]()", "        if (n == 0) List[Long]()\n        else if (n == 1) List[Long](1)\n\
    \        else if (n == 2) List[Long](1, 3)\n        else {\n            var ans\
    \ = List[Long](1, 3, 2)\n            var k = 2\n            while (k < n) {\n\
    \                if (k % 2 == 0) ans = ans :+ (1 + k / 2)\n                else\
    \ ans = ans :+ (ans(k - 1) + ans(k - 2) + ans(k + 1))\n                k += 1\n\
    \            }\n            ans\n        }", '        ???', "        if (n ==\
    \ 0) List(1)\n        else {\n            val cache = new mutable.HashMap[Long,\
    \ Long]\n            def tri(n : Long) : Long = {\n                if (cache.contains(n))\
    \ cache(n)\n                else {\n                    val ans = if (n == 1)\
    \ 3\n                    else if (n % 2 == 0) 1 + n / 2\n                    else\
    \ tri(n - 1) + tri(n - 2) + tri(n + 1)\n                    cache += (n -> ans)\n\
    \                    ans\n                }\n            }\n            (1 to\
    \ n.toInt).map(tri(_)).toList\n        }", "        def triIter(n : Long, res\
    \ : List[Long]) : List[Long] = {\n            if (n == 1) res.reverse\n      \
    \      else if (n % 2 == 0) triIter(n - 1, (n / 2 + 1) :: res)\n            else\
    \ triIter(n - 1, res.head + res.tail.head + res.tail.tail.head :: res)\n     \
    \   }\n        triIter(n, List[Long](1, 3, 2))", "        def triHelp(n : Long,\
    \ next : Long, list : List[Long]) : List[Long] = {\n            if (n == 0) {\n\
    \                next :: list\n            } else {\n                if (n % 2\
    \ == 0) {\n                    triHelp(n - 1, (1 + n / 2), next :: list)\n   \
    \             } else {\n                    triHelp(n - 1, next + list.head +\
    \ list.tail.head, next :: list)\n                }\n            }\n        }\n\
    \        triHelp(n, 0, List(1, 3, 2))", "        val cached = new HashMap[Long,\
    \ Long]\n        cached += (1l -> 3l)\n        def tri(n : Long) : Long = {\n\
    \            cached.get(n) match {\n                case Some(x) => x\n      \
    \          case None => {\n                    val value = if (n % 2 == 0) 1 +\
    \ n / 2 else tri(n - 1) + tri(n - 2) + tri(n + 1)\n                    cached\
    \ += (n -> value)\n                    value\n                }\n            }\n\
    \        }\n        (1l to n).map(tri(_)).toList", "        var list = List[Long]()\n\
    \        var a = 1l\n        var b = 3l\n        var c = 2l\n        for (i <-\
    \ 0 to n.toInt) {\n            i match {\n                case 0 => list = list\
    \ :+ 1l\n                case 1 => list = list :+ 3l\n                case 2 =>\
    \ list = list :+ 2l\n                case _ => {\n                    var d =\
    \ a + b + c\n                    a = b\n                    b = c\n          \
    \          c = d\n                    list = list :+ d\n                }\n  \
    \          }\n        }\n        list", "        // Fill up this function body\n\
    \        // 'n' is the number of elements in Tribonacci sequence\n        def\
    \ triRec(n : Long, acc : List[Long]) : List[Long] = {\n            n match {\n\
    \                case 0 => 1L :: acc\n                case 1 => 3L :: acc\n  \
    \              case 2 => 2L :: acc\n                case _ => if (n % 2 == 0)\
    \ (1 + n / 2) :: acc else triRec(n - 1, triRec(n - 2, triRec(n + 1, acc)))\n \
    \           }\n        }\n        triRec(n, List[Long]()).reverse", "        //\
    \ Fill up this function body\n        // `0` is the only number in Scala that\
    \ can be used to get the remainder of a division or a modulo operation.\n    \
    \    // In other languages you might use `-1` or `1` to get the remainder of division\
    \ when the\n        // dividend is negative.\n        (for (i <- 1l to n) yield\
    \ if (i % 2 == 0) (1 + i / 2) else (1)).toList", "        var ans = List[Long]()\n\
    \        ans = ans.+:(3l)\n        ans = ans.+:(2l)\n        ans = ans.+:(1l)\n\
    \        for (i <- 3l to n) {\n            var t = ans(i.toInt - 1) + ans(i.toInt\
    \ - 2) + ans(i.toInt - 3)\n            if (i % 2 == 0) {\n                t =\
    \ 1 + i / 2\n            }\n            ans = ans.+:(t)\n        }\n        ans.reverse",
  "        def loop(n : Long, a : Long, b : Long, c : Long, list : List[Long]) : List[Long]\
    \ = {\n            if (n == 0) {\n                a :: list\n            } else\
    \ if (n % 2 == 0) {\n                loop(n - 1, a + 1 + n / 2, a, b, list)\n\
    \            } else {\n                loop(n - 1, a + b + c, a, b, list)\n  \
    \          }\n        }\n        loop(n, 1, 3, 2, Nil)", "        def t(i : Long)\
    \ : Long = if (i < 2) 3 else if (i % 2 == 0) 1 + i / 2 else t(i - 1) + t(i - 2)\
    \ + t(i + 1)\n        (1l to n).map(t).toList", "        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ var a = 1L\n        var b = 3L\n        var c = 2L\n        var temp = 0L\n\
    \        var ans = List[Long]()\n        ans = ans :+ a\n        if (n > 0) ans\
    \ = ans :+ b\n        if (n > 1) ans = ans :+ c\n        for (i <- 3L to n) {\n\
    \            if (i % 2 == 0) temp = (1 + i / 2)\n            else temp = a + b\
    \ + c\n            a = b\n            b = c\n            c = temp\n          \
    \  ans = ans :+ temp\n        }\n        ans", "        val cache = new HashMap[Long,\
    \ Long]()\n        def triInner(n : Long) : Long = {\n            if (n == 1)\
    \ 3\n            else if (n == 2) 2\n            else if (n == 3) 8\n        \
    \    else if (cache.contains(n)) cache(n)\n            else {\n              \
    \  val tmp = if (n % 2 == 0) (n / 2) + 1 else triInner(n - 1) + triInner(n - 2)\
    \ + triInner(n + 1)\n                cache += (n -> tmp)\n                tmp\n\
    \            }\n        }\n        val result = new ListBuffer[Long]()\n     \
    \   (1 to n + 1).foreach(x => result += triInner(x))\n        result.toList",
  "        var list = new ListBuffer[Long]\n        list += 1\n        list += 3\n\
    \        var i = 2\n        while (i <= n) {\n            if (i % 2 == 0) {\n\
    \                list += 1 + i / 2\n            } else {\n                list\
    \ += list(i - 1) + list(i - 2) + list(i + 1)\n            }\n            i +=\
    \ 1\n        }\n        list.toList", "        def tri_helper(count : Long, l\
    \ : List[Long]) : List[Long] = {\n            if (count > n) l.reverse\n     \
    \       else if (count == 0) tri_helper(count + 1, 1l :: l)\n            else\
    \ if (count == 1) tri_helper(count + 1, 3l :: l)\n            else if (count ==\
    \ 2) tri_helper(count + 1, 2l :: l)\n            else if (count % 2 == 0) tri_helper(count\
    \ + 1, (1 + count / 2) :: l)\n            else tri_helper(count + 1, (l(2) + l(1)\
    \ + l(0)) :: l)\n        }\n        tri_helper(0, Nil)", "    \tif (n == 0) return\
    \ List(1)\n    \tif (n == 1) return List(1, 3)\n    \tif (n == 2) return List(1,\
    \ 3, 2)\n    \tval tribonacci = new Array[Long](n.toInt + 1)\n    \ttribonacci(0)\
    \ = 1\n    \ttribonacci(1) = 3\n    \ttribonacci(2) = 2\n    \tfor (i <- 3 to\
    \ n.toInt) {\n    \t\tif (i % 2 == 0) tribonacci(i) = 1 + i / 2\n    \t\telse\
    \ tribonacci(i) = tribonacci(i - 1) + tribonacci(i - 2) + tribonacci(i + 1)\n\
    \    \t}\n    \ttribonacci.toList", "        def triInternal(n : Long, first :\
    \ Long, second : Long, third : Long) : List[Long] = {\n            if (n == 0)\
    \ return List(first)\n            else {\n                if (n % 2 == 0) return\
    \ first :: triInternal(n - 1, second, third, (1 + n / 2))\n                else\
    \ return first :: triInternal(n - 1, second, third, third + second + first)\n\
    \            }\n        }\n        return triInternal(n, 1, 3, 2)", "        def\
    \ loop(m : Long, l : List[Long]) : List[Long] = {\n            if (m == 0) l\n\
    \            else if (m % 2 == 0) loop(m - 1, 1 + m / 2 :: l)\n            else\
    \ loop(m - 1, l.head + l.tail.head + l.tail.tail.head :: l)\n        }\n     \
    \   loop(n, 3 :: Nil)", "        // Your code here\n        null", "        if\
    \ (n == 0) return Nil\n        if (n == 1) return List(1)\n        if (n == 2)\
    \ return List(1, 3)\n        val array = new Array[Long](n.toInt + 1)\n      \
    \  array(0) = 1\n        array(1) = 3\n        array(2) = 2\n        for (i <-\
    \ Range(3, n.toInt + 1)) {\n            if (i % 2 == 0) {\n                array(i)\
    \ = 1 + i / 2\n            } else {\n                array(i) = array(i - 1) +\
    \ array(i - 2) + array(i + 1)\n            }\n        }\n        array.toList",
  "        // Fill up this function body\n        // 'return List()' if you need to\
    \ return an empty list\n        if (n == 0) {\n            return List()\n   \
    \     }\n        var l = List(1, 3, 2)\n        while (l.length < n + 1) {\n \
    \           val len = l.length\n            if (len % 2 == 0) {\n            \
    \    l = l :+ 1 + len / 2\n            } else {\n                l = l :+ l(len\
    \ - 1) + l(len - 2) + l(len + 1)\n            }\n        }\n        return l",
  "        // Fill up this function body\n        // You can add another function\
    \ as well, if required\n\t\tval seq = new scala.collection.mutable.ArrayBuffer[Long]\n\
    \t\tseq += 1\n\t\tseq += 3\n\t\tseq += 2\n\t\t\n\t\tvar j = 3\n\t\tfor ( i <-\
    \ 3l to n){\n\t\t\tif ( i % 2 == 0){\n\t\t\t\tseq += (1 + i / 2)\n\t\t\t}else{\n\
    \t\t\t\tseq += (seq(j - 1) + seq(j - 2) + seq(j))\n\t\t\t\tj += 1\n\t\t\t}\n\t\
    \t}\n\t\tseq.toList", "    \tvar a = 1l\n    \tvar b = 3l\n    \tvar c = 2l\n\
    \    \tval result = new ListBuffer[Long]\n    \tresult += 1l\n    \tresult +=\
    \ 3l\n    \tresult += 2l\n    \tfor (i <- 0 until n - 2) {\n    \t\tif (i % 2\
    \ == 0) {\n    \t\t\tresult += 1 + c / 2\n    \t\t\ta = c\n    \t\t\tc = result(result.length\
    \ - 1)\n    \t\t} else {\n    \t\t\tresult += a + b + c\n    \t\t\tb = c\n   \
    \ \t\t\tc = result(result.length - 1)\n    \t\t}\n    \t}\n    \tresult.toList",
  "        //return null\n        val sequence = ListBuffer[Long]()\n        sequence\
    \ += 1\n        sequence += 3\n        for (i <- 2 to n.toInt) {\n           \
    \ if (i % 2 == 0) {\n                sequence += (1 + i / 2)\n            } else\
    \ {\n                sequence += (sequence(i - 1) + sequence(i - 2) + sequence(i\
    \ + 1))\n            }\n        }\n        sequence.toList", "        def triI(n\
    \ : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n      \
    \      else {\n                if (n % 2 == 0) triI(n - 1, (1 + n / 2) :: l)\n\
    \                else triI(n - 1, (l(0) + l(1) + l(2)) :: l)\n            }\n\
    \        }\n        triI(n, List(1))", "        if (n == 0) return List(1)\n \
    \       val list = new ListBuffer[Long]\n        list += 1\n        list += 3\n\
    \        list += 2\n        var nn = n\n        while (nn > 2) {\n           \
    \ list += list(list.length - 1) + list(list.length - 2) + list(list.length - 3)\n\
    \            nn -= 1\n        }\n        list.toList", "        val a = 1l\n \
    \       val b = 3l\n        val c = 2l\n        var d = 0l\n        var lst =\
    \ List[Long](a, b, c)\n        for (i <- 3l to n) {\n            if (i % 2 ==\
    \ 0) d = 1 + i / 2\n            else d = lst(i.toInt - 1) + lst(i.toInt - 2) +\
    \ lst(i.toInt + 1)\n            lst :+= d\n        }\n        lst", "        var\
    \ ret = List[Long]()\n        ret :+= 1\n        for (i <- 1 to n.toInt) {\n \
    \           if (i == 1) ret :+= 3\n            else if (i == 2) ret :+= 2\n  \
    \          else {\n                if (i % 2 == 0) ret :+= (1 + i / 2)\n     \
    \           else ret :+= (ret(i - 2) + ret(i - 1) + ret(i + 1))\n            }\n\
    \        }\n        ret", "\t\tif (n == 0) {\n\t\t\treturn List(1L)\n\t\t}\n\t\
    \tif (n == 1) {\n\t\t\treturn List(1L, 3L)\n\t\t}\n\t\tvar a = 1L\n\t\tvar b =\
    \ 3L\n\t\tvar c = 2L\n\t\tvar result = List(a, b, c)\n\t\tfor (i <- 3l to n) {\n\
    \t\t\tval d = if (i % 2 == 0) (1 + i / 2) else (a + b + c)\n\t\t\tresult = result\
    \ :+ d\n\t\t\ta = b\n\t\t\tb = c\n\t\t\tc = d\n\t\t}\n\t\treturn result", "  \
    \      // Fill up this function body\n        // 'coffeescript' is not available\
    \ for this exercise.\n        null", "        def f(i : Long, l : List[Long])\
    \ : List[Long] = {\n            if (i == n) l\n            else if (i % 2 == 0)\
    \ f(i + 1, l :+ 1 + i / 2)\n            else f(i + 1, l :+ l(i.toInt - 1).toLong\
    \ + l(i.toInt - 2).toLong + l(i.toInt + 1).toLong)\n        }\n        f(1, List(1))",
  "        var l = ListBuffer[Long]()\n        var t1 = 1l\n        var t2 = 3l\n\
    \        var t3 = 2l\n        l += t1\n        l += t2\n        l += t3\n    \
    \    for (i <- 1l to n - 2) {\n            val t4 = if (i % 2 == 0) 1 + i / 2\
    \ else t1 + t2 + t3\n            l += t4\n            t1 = t2\n            t2\
    \ = t3\n            t3 = t4\n        }\n        l.toList", "        // Fill up\
    \ this function body\n        // You may also need to define some auxillary functions\
    \ or classes\n        if (n == 1) List(1)\n        else if (n == 2) List(1, 3)\n\
    \        else if (n == 3) List(1, 3, 2)\n        else {\n        \tval c = tri(n\
    \ - 1)\n        \tc.+((if (n % 2 == 0) c(n.toInt - 1) + c(n.toInt - 2) + c(n.toInt\
    \ + 1) else 1 + n / 2))\n        }", "        val memo = new Array[Long](n.toInt\
    \ + 1)\n        def triHelper(m : Long) : Long = {\n            if (m == 1) 1\n\
    \            else if (m == 2) 3\n            else if (m == 3) 2\n            else\
    \ if (memo(m.toInt) != 0) memo(m.toInt)\n            else {\n                val\
    \ value = if (m % 2 == 0) 1 + m / 2\n                else triHelper(m - 1) + triHelper(m\
    \ - 2) + triHelper(m + 1)\n                memo(m.toInt) = value\n           \
    \     value\n            }\n        }\n        (1 to n.toInt).map(m => triHelper(m)).toList",
  "        def loop(l : List[Long], n : Long) : List[Long] = {\n            if (n\
    \ == 0) l\n            else if (n % 2 == 0) loop(1 + n / 2 :: l, n - 1)\n    \
    \        else loop(l.head + l.tail.head + l.tail.tail.head :: l, n - 1)\n    \
    \    }\n        loop(List(3), n).reverse", "        var t = ArrayBuffer[Long]()\n\
    \        for (i <- 0 to n.toInt) {\n            if (i == 0) t += 1\n         \
    \   else if (i == 1) t += 3\n            else if (i == 2) t += 2\n           \
    \ else if (i % 2 == 0) t += (1 + i / 2)\n            else t += (t(i - 1) + t(i\
    \ - 2) + t(i + 1))\n        }\n        return t.toList", "        var list = List[Long]()\n\
    \        var i = 1l\n        var a = 1l\n        var b = 3l\n        var c = 2l\n\
    \        while (i <= n) {\n            list = i match {\n                case\
    \ 1 => list :+ a\n                case 2 => list :+ b\n                case 3\
    \ => list :+ c\n                case _ => list :+ (a + b + c)\n            }\n\
    \            a = b\n            b = c\n            c = list.last\n           \
    \ i += 1\n        }\n        list", "        if (n == 0) List(1)\n        else\
    \ {\n            val xs = tri(n - 1)\n            if (n % 2 == 0) xs :+ (1 + n\
    \ / 2)\n            else xs :+ (xs(xs.length - 1) + xs(xs.length - 2) + xs(xs.length\
    \ - 3))\n        }", "        def iter(curr : Long, n : Long, list : List[Long])\
    \ : List[Long] = {\n        \tif (curr > n) list\n        \telse if (curr == 1)\
    \ {\n        \t\tlist :+ 3l\n        \t} else if (curr % 2 == 0) {\n        \t\
    \titer(curr + 1, n, list :+ (1 + curr / 2))\n        \t} else {\n        \t\t\
    iter(curr + 1, n, list :+ (list(curr.toInt - 1) + list(curr.toInt - 2) + list(curr.toInt\
    \ + 1)))\n        \t}\n        }\n        iter(1, n, List[Long]())", "       \
    \ var tribonacci = new Array[Long](n.toInt + 1)\n        for (i <- 0 to n.toInt)\
    \ tribonacci(i) = 0\n        tribonacci(0) = 1\n        tribonacci(1) = 3\n  \
    \      tribonacci(2) = 2\n        if (n <= 2) return tribonacci.toList\n     \
    \   for (i <- 3 to n.toInt) tribonacci(i) = if (i % 2 == 0) 1 + i / 2 else tribonacci(i\
    \ - 1) + tribonacci(i - 2) + tribonacci(i + 1)\n        return tribonacci.toList",
  "        // Fill up this function body\n        // `0` is the only invalid input\n\
    \        0L :: (1L to n).toList.map(i => {\n            if (i == 1) 3L else if\
    \ (i % 2 == 0) 1L + i / 2 else tri(i - 1) + tri(i - 2) + tri(i + 1)\n        })",
  "      var result = ListBuffer[Long]()\n      result += 1\n      result += 3\n \
    \     result += 2\n      var i = 3\n      while (i <= n) {\n        var v = result(i\
    \ - 1) + result(i - 2) + result(i - 3)\n        if (i % 2 == 0) v = 1 + i / 2\n\
    \        result += v\n        i += 1\n      }\n      result.toList", "       \
    \ // Fill up this function body\n        // You may also need to define some helper\
    \ functions\n        val L = new ListBuffer[Long]\n        def tri_helper(n :\
    \ Long, x : Long, y : Long, z : Long) : List[Long] = {\n            if (n == 1)\
    \ L += z\n            else {\n                if (n % 2 == 0) L += z\n       \
    \         else {\n                    val t = x + y + z\n                    L\
    \ += t\n                    tri_helper(n - 1, y, z, t)\n                }\n  \
    \          }\n            L.toList\n        }\n        tri_helper(n, 1, 3, 2)",
  "        if (n < 1) throw new Exception(\"n has to be positive.\")\n        val\
    \ res = new ArrayBuffer[Long]\n        def triHelper(curr : Long, prev1 : Long,\
    \ prev2 : Long, prev3 : Long) : Unit = {\n            if (curr == n + 1) return\n\
    \            if (curr == 1) res += 1\n            else if (curr == 2) res += 3\n\
    \            else if (curr == 3) res += 2\n            else if (curr % 2 == 0)\
    \ res += curr / 2\n            else res += prev1 + prev2 + prev3\n           \
    \ triHelper(curr + 1, res(res.length - 1), res(res.length - 2), res(res.length\
    \ - 3))\n        }\n        triHelper(1, 0, 0, 0)\n        res.toList", "    \
    \    if (n == 0) List(1l)\n        else if (n == 1) List(1l, 3l)\n        else\
    \ if (n == 2) List(1l, 3l, 2l)\n        else {\n            val a = 1l\n     \
    \       val b = 3l\n            val c = 2l\n            List(a, b, c) ::: (for\
    \ (i <- 3 to n.toInt) yield {\n                if (i % 2 == 0) (i / 2) + 1\n \
    \               else a + b + c\n            }).toList\n        }", "        def\
    \ get(i : Long) : Long = {\n            if (i == 1) 3 else if (i % 2 == 0) 1 +\
    \ i / 2 else get(i - 1) + get(i - 2) + get(i + 1)\n        }\n        if (n ==\
    \ 0) List[Long]() else (1 to n.toInt).map(i => get(i)).toList", '        null',
  "        // Solution 1: use recursion\n        // def calculate(i : Long) : Long\
    \ = {\n        //     val base = 2l\n        //     if (i == 1) 3l\n        //\
    \     else if (i == base) 1l + i / base\n        //     else if (i == base + 1)\
    \ 1l + (base + 1) / base\n        //     else if (i % 2 == 0) {\n        //  \
    \       calculate(i - 1) + calculate(i - 2) + calculate(i + 1)\n        //   \
    \  } else {\n        //         1l + i / base\n        //     }\n        // }\n\
    \        // val result = new ListBuffer[Long]\n        // for (i <- 1 to n.toInt)\
    \ {\n        //     result += calculate(i)\n        // }\n        // result.toList\n\
    \        // Solution 2: use memoization\n        def calculate(i : Long) : Long\
    \ = {\n            val base = 2l\n            if (i == 1) 3l\n            else\
    \ if (i == base) 1l + i / base\n            else if (i == base + 1) 1l + (base\
    \ + 1) / base\n            else if (i % 2 == 0) {\n                calculate(i\
    \ - 1) + calculate(i - 2) + calculate(i + 1)\n            } else {\n         \
    \       1l + i / base\n            }\n        }\n        val cache = new HashMap[Long,\
    \ Long]\n        cache(1) = 3l\n        cache(2) = 1l + (2l / 2l)\n        cache(3)\
    \ = 1l + (3l / 2l)\n        def get(i : Long) : Long = {\n            if (cache.contains(i))\
    \ cache(i)\n            else {\n                val result = calculate(i)\n  \
    \              cache(i) = result\n                result\n            }\n    \
    \    }\n        val result = new ListBuffer[Long]\n        for (i <- 1 to n.toInt)\
    \ {\n            result += get(i)\n        }\n        result.toList", "      \
    \  def triIter(n : Long, x : Long, y : Long, z : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (n == 0) acc.reverse\n            else {\n             \
    \   if (n % 2 == 0) triIter(n - 1, x, y, z, (x + y + z) :: acc)\n            \
    \    else triIter(n - 1, x, y, z, (1 + n / 2) :: acc)\n            }\n       \
    \ }\n        triIter(n, 1, 3, 2, List())", "        var lst = ListBuffer(1l, 3l,\
    \ 2l)\n        for (i <- 3l to n) {\n            if (i % 2 == 0) lst += (1 + i\
    \ / 2)\n            else lst += (lst(i.toInt - 1) + lst(i.toInt - 2) + lst(i.toInt\
    \ + 1))\n        }\n        lst.toList", "        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        var list\
    \ = new ListBuffer[Long]()\n        list += 1\n        for (i <- 1 to n.toInt)\
    \ {\n            if (i == 1) list += 3\n            else if (i % 2 == 0) list\
    \ += (1 + i / 2)\n            else list += (list(i - 1) + list(i - 2) + list(i\
    \ + 1))\n        }\n        list.toList", "        var i = 0l\n        var result\
    \ = new ListBuffer[Long]\n        while (i <= n) {\n            result += solve(i)\n\
    \            i += 1\n        }\n        result.toList", "    \tval s = new Array[Long](n.toInt\
    \ + 1)\n    \tfor (i <- 1 to n.toInt) {\n    \t\tif (i == 1) s(i) = 3\n    \t\t\
    else if (i == 2) s(i) = 1\n    \t\telse if (i == 3) s(i) = 2\n    \t\telse if\
    \ (i % 2 == 0) s(i) = 1 + i / 2\n    \t\telse s(i) = s(i - 1) + s(i - 2) + s(i\
    \ + 1)\n    \t}\n    \ts.toList", "        def triR(n : Long, a : Long, b : Long,\
    \ c : Long) : List[Long] = {\n            if (n == 0) Nil\n            else if\
    \ (n == 1) List(a)\n            else if (n == 2) List(a, b)\n            else\
    \ if (n == 3) List(a, b, c)\n            else if (n % 2 == 0) {\n            \
    \    val nn = n / 2\n                val next = a + b + c + nn\n             \
    \   next :: triR(n - 1, b, c, next)\n            } else {\n                val\
    \ next = a + b + c\n                next :: triR(n - 1, b, c, next)\n        \
    \    }\n        }\n        triR(n, 1, 3, 2)", '      ???', "        if (n == 0)\
    \ List(1)\n        else if (n == 1) List(1, 3)\n        else if (n == 2) List(1,\
    \ 3, 2)\n        else {\n            val list = tri(n - 1)\n            val m\
    \ = list(list.length - 1)\n            val k = list(list.length - 2)\n       \
    \     val j = list(list.length - 3)\n            val result = List(m + k + j)\n\
    \            list ::: result\n        }", "        var a = 1.toLong\n        var\
    \ b = 3.toLong\n        var c = 2.toLong\n        var d = 0.toLong\n        var\
    \ res = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (i % 2\
    \ == 0) d = a + i / 2\n            else d = a + b + c\n            res = res :+\
    \ d\n            a = b\n            b = c\n            c = d\n        }\n    \
    \    res", "        val a = new Array[Long](n.toInt + 1)\n        a(0) = 1\n \
    \       a(1) = 3\n        for (i <- 2 to n.toInt) {\n            if (i % 2 ==\
    \ 0) a(i) = 1 + i / 2\n            else a(i) = a(i - 1) + a(i - 2) + a(i + 1)\n\
    \        }\n        a.toList", "        if (n == 0) List(1)\n        else if (n\
    \ == 1) List(1, 3)\n        else if (n == 2) List(1, 3, 2)\n        else List(1,\
    \ 3, 2) ::: (1l to n).map(i => {\n        \tif (i % 2 == 0) i / 2\n        \t\
    else tri(i - 1).last + tri(i - 2).last + tri(i + 1).last\n        }).toList",
  "        if (n == 0) List(1)\n        else if (n == 1) List(1, 3)\n        else\
    \ if (n == 2) List(1, 3, 2)\n        else List(1, 3, 2) ::: recursiveTri(n - 2,\
    \ 2, 1, 3)", "        // Fill up this function body\n        // You can add another\
    \ function as well, if required\n        var result = new ListBuffer[Long]()\n\
    \        result += 1\n        result += 3\n        for (i <- 2 to n.toInt) {\n\
    \            if (i % 2 == 0) result += (1 + i / 2)\n            else result +=\
    \ (result(i - 1) + result(i - 2) + result(i + 1))\n        }\n        result.toList",
  "        var triList = new ListBuffer[Long]\n        triList += 1l\n        triList\
    \ += 3l\n        for (i <- 2l to n) {\n            if (i % 2 == 0) {\n       \
    \         triList += (1 + i / 2)\n            } else {\n                triList\
    \ += (triList(i.toInt - 1) + triList(i.toInt - 2) + triList(i.toInt + 1))\n  \
    \          }\n        }\n        triList.toList", "        def trib(n : Long,\
    \ tri : Array[Long]) : Array[Long] = {\n            if (n < 1) {\n           \
    \     return tri\n            }\n            else {\n                if (n % 2\
    \ == 0) {\n                    tri(n.toInt) = 1 + n / 2\n                }\n \
    \               else {\n                    tri(n.toInt) = tri(n.toInt - 1) +\
    \ tri(n.toInt - 2) + tri(n.toInt + 1)\n                }\n                trib(n\
    \ - 1, tri)\n            }\n        }\n        trib(n, Array.fill(n.toInt + 1)(0l)).toList",
  "        def tri1(a : Long, b : Long, c : Long, n : Long) : List[Long] = {\n   \
    \         if (n == 0) {\n                List(c)\n            } else {\n     \
    \           c :: tri1(b, c, \n                    if (n % 2 == 0) {\n        \
    \                1 + n / 2\n                    } else {\n                   \
    \     a + b + c\n                    }, n - 1)\n            }\n        }\n   \
    \     tri1(0, 1, 3, n)", '        // Good Luck!', "        var l = new ListBuffer[Long]()\n\
    \        l += 1\n        l += 3\n        for (i <- 2 to n.toInt) {\n         \
    \   if (i % 2 == 0) l += (1 + i / 2)\n            else l += (l(i - 1) + l(i -\
    \ 2) + l(i + 1))\n        }\n        l.toList", "        val result = ListBuffer[Long]()\n\
    \        var a = 1l\n        var b = 3l\n        var c = 2l\n        var d = a\
    \ + b + c\n        result += a\n        result += b\n        result += c\n   \
    \     result += d\n        while (result.length < n + 1) {\n            a = b\n\
    \            b = c\n            c = d\n            d = a + b + c\n           \
    \ result += d\n        }\n        result.toList", "    \tvar cache = new HashMap[Long,\
    \ Long]\n    \tcache(1) = 3\n    \tdef getTri(n : Long) : Long = {\n    \t\tif\
    \ (cache.contains(n)) cache(n)\n    \t\telse {\n    \t\t\tval v = if (n % 2 ==\
    \ 0) 1 + n / 2 else getTri(n - 1) + getTri(n - 2) + getTri(n + 1)\n    \t\t\t\
    cache(n) = v\n    \t\t\tv\n    \t\t}\n    \t}\n    \t(1 to n.toInt).map(x => getTri(x)).toList",
  "        // Solution 1: use 3 recursions\n        def helper(i : Long, x : Long,\
    \ y : Long, z : Long) : List[Long] = {\n            if (i == n) List(x, y, z)\n\
    \            else if (i % 2 == 0) helper(i + 1, x, y, z) ::: List(1 + i / 2)\n\
    \            else helper(i + 1, x, y, z) ::: List(helper(i + 1, x, y, z).takeRight(3).sum)\n\
    \        }\n        if (n < 3) List(1)\n        else helper(2, 1, 3, 2)\n    \
    \    // Solution 2: use recursion and ArrayBuffer\n        def helper(n : Long)\
    \ : ArrayBuffer[Long] = {\n            if (n == 1) ArrayBuffer(1)\n          \
    \  else if (n == 2) ArrayBuffer(1, 3)\n            else if (n == 3) ArrayBuffer(1,\
    \ 3, 2)\n            else {\n                val list = helper(n - 1)\n      \
    \          list += if (n % 2 == 0) 1 + n / 2 else list.takeRight(3).sum\n    \
    \            list\n            }\n        }\n        helper(n).toList", '        ???',
  "        n match {\n            case x if x < 0 => throw new IllegalArgumentException\n\
    \            case 0 => List[Long](1)\n            case 1 => List[Long](1, 3)\n\
    \            case 2 => List[Long](1, 3, 2)\n            case _ => {\n        \
    \        var l = List[Long](1, 3, 2)\n                for (i <- 4l to n) {\n \
    \                   if (i % 2 == 0) l = l :+ (1 + i / 2)\n                   \
    \ else l = l :+ (l(l.length - 1) + l(l.length - 2) + l(l.length - 3))\n      \
    \          }\n                l\n            }\n        }", "        if (n ==\
    \ 0) return List[Long](1)\n        val r = tri(n - 1)\n        r :+ (if (n % 2\
    \ == 0) (1 + n / 2) else (r(r.length - 3) + r(r.length - 2) + r(r.length - 1)))",
  "      var current = List[Long](1l, 3l, 2l)\n      if (n <= 2) return current.slice(0,\
    \ n.toInt + 1)\n      else {\n        while (current.length <= n.toInt) {\n  \
    \        if (current.length % 2 == 0) current = current :+ (current.length / 2\
    \ + 1)\n          else current = current :+ (current(current.length - 1) + current(current.length\
    \ - 2) + current(current.length - 3))\n        }\n        return current\n   \
    \   }", "        // Fill up this function body\n        // 'n' is the number of\
    \ first numbers of the Tribonacci sequence.\n        // Return a list of Long\
    \ type.\n        if (n < 1) return List()\n        var l : List[Long] = List()\n\
    \        l = l :+ 1\n        if (n == 1) return l\n        l = l :+ 3\n      \
    \  if (n == 2) return l\n        l = l :+ 2\n        for (i <- 3 to n.toInt) {\n\
    \            if (i % 2 == 0) l = l :+ (1 + i / 2)\n            else l = l :+ (l(i\
    \ - 1) + l(i - 2) + l(i + 1))\n        }\n        return l", "        var arr\
    \ = ArrayBuffer[Long]()\n        arr += 1\n        arr += 3\n        arr += 2\n\
    \        for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) {\n          \
    \      arr += (1 + i / 2)\n            } else {\n                arr += (arr(i\
    \ - 1) + arr(i - 2) + arr(i + 1))\n            }\n        }\n        arr.toList",
  "        if (n == 0) return List(1l)\n        var tri = List(1l, 3l)\n        var\
    \ i = 1\n        while (i < n) {\n            val next = if (i % 2 == 0) (1 +\
    \ (i / 2)) else tri(i - 1) + tri(i - 2) + tri(i + 1)\n            tri = tri :+\
    \ next\n            i += 1\n        }\n        tri", "        def trii(n : Long,\
    \ acc : List[Long]) : List[Long] = n match {\n            case 0 => acc\n    \
    \        case _ => if (n % 2 == 0) trii(n - 1, acc :+ (1 + n / 2)) else trii(n\
    \ - 1, acc :+ (acc(acc.length - 1) + acc(acc.length - 2) + acc(acc.length - 3)))\n\
    \        }\n        trii(n, List[Long](1, 3, 2))", "        var result = List[Long]()\n\
    \        if (n < 0) return result\n        for (i <- 0l to n) {\n            if\
    \ (i == 0) result = result :+ 1\n            else if (i == 1) result = result\
    \ :+ 3\n            else if (i == 2) result = result :+ 2\n            else if\
    \ (i % 2 == 0) result = result :+ (1 + i / 2)\n            else result = result\
    \ :+ (result(i.toInt - 1) + result(i.toInt - 2) + result(i.toInt + 1))\n     \
    \   }\n        return result", "        // Your code goes here.\n        // TODO:\
    \ code it.\n        val seq = List[Long](1, 3, 2)\n        val k = ceil(log(n\
    \ + 1) / log(2))\n        val a = List[Long](1, 3, 2)\n        var b = List[Long](1,\
    \ 3, 2)\n        for (i <- 0 until (k.toInt - 2)) {\n            val b0 = b(0)\
    \ + b(1) + b(2)\n            val b1 = b(1) + b(2) + b0\n            val b2 = b(2)\
    \ + b0 + b1\n            b = List[Long](b0, b1, b2)\n        }\n        val z\
    \ = if (n < 3) 3 else pow(2, k.toInt).toLong - 2 + (if (n % 2 == 0) n / 2 else\
    \ n)\n        a ++ b ++ List[Long](z)", "        var cache = new Array[Long](n.toInt\
    \ + 1)\n        cache(0) = 1\n        cache(1) = 3\n        cache(2) = 2\n   \
    \     def f(k : Int) : Long = {\n            if (cache(k) != 0) cache(k)\n   \
    \         else {\n                if (k % 2 == 0) cache(k) = (1 + k / 2)\n   \
    \             else cache(k) = f(k - 1) + f(k - 2) + f(k + 1)\n               \
    \ cache(k)\n            }\n        }\n        for (i <- 0 to n.toInt) f(i)\n \
    \       cache.toList", "        if (n == 0) return List(1)\n        else if (n\
    \ == 1) return List(1, 3)\n        else if (n == 2) return List(1, 3, 2)\n   \
    \     var l = List(1l, 3l, 2l)\n        for (i <- 3l to n) {\n            if (i\
    \ % 2 == 0) l = (1 + i / 2) :: l\n            else l = (l(0) + l(1) + l(2)) ::\
    \ l\n        }\n        return l.reverse", "        def tri_helper(n : Long, ls\
    \ : List[Long]) : List[Long] = {\n            if (n == 0) return ls\n        \
    \    val x = if (n % 2 == 0) 1 + n / 2 else ls(ls.length - 3) + ls(ls.length -\
    \ 2) + ls(ls.length - 1)\n            tri_helper(n - 1, ls :+ x)\n        }\n\
    \        tri_helper(n, List[Long](1))", "        var l = ListBuffer[Long]()\n\
    \        var r = (1l to n).toList\n        r.foreach(x => l += (\n           \
    \ if (x == 1) {\n                3\n            } else if (x % 2 == 0) {\n   \
    \             1 + x / 2\n            } else {\n                l(x.toInt - 2)\
    \ + l(x.toInt - 1) + l(x.toInt + 1)\n            }\n        ))\n        l.toList",
  "        var r = ArrayBuffer[Long]()\n        r += 1\n        if (n >= 1) r += 3\n\
    \        if (n >= 2) r += 2\n        for (i <- 3 to n.toInt) {\n            if\
    \ (i % 2 == 0) r += (1 + i / 2)\n            else r += (r(i - 1) + r(i - 2) +\
    \ r(i + 1))\n        }\n        r.toList", "        val res = Array.fill(n.toInt\
    \ + 1)(0l)\n        res(0) = 1\n        res(1) = 3\n        res(2) = 2\n     \
    \   for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) res(i) = 1 + i / 2\n\
    \            else res(i) = res(i - 1) + res(i - 2) + res(i + 1)\n        }\n \
    \       res.toList", "        n match {\n            case 0 => List[Long](1)\n\
    \            case 1 => List[Long](1, 3)\n            case 2 => List[Long](1, 3,\
    \ 2)\n            case _ => {\n                val prev = tri(n - 1)\n       \
    \         val a = prev(n.toInt - 1)\n                val b = prev(n.toInt - 2)\n\
    \                val c = prev(n.toInt - 3)\n                val d = if (n % 2\
    \ == 0) 1 + n / 2 else a + b + c\n                prev :+ d\n            }\n \
    \       }", "        def triAcc(iter : Long, list : List[Long]) : List[Long] =\
    \ {\n            if (iter > n) list\n            else {\n                if (iter\
    \ == 1) triAcc(iter + 1, list :+ 3)\n                else if (iter % 2 == 0) triAcc(iter\
    \ + 1, list :+ (1 + iter / 2))\n                else triAcc(iter + 1, list :+\
    \ (list(iter.toInt - 1) + list(iter.toInt - 2) + list(iter.toInt + 1)))\n    \
    \        }\n        }\n        triAcc(1, List())", "        var result = new ListBuffer[Long]\n\
    \        var a = 1l\n        var b = 3l\n        var c = 2l\n        result +=\
    \ a\n        result += b\n        result += c\n        while (result.length <\
    \ n + 1) {\n            result += a + b + c\n            a = b\n            b\
    \ = c\n            c = result.last\n        }\n        result.toList", "     \
    \ var l = new ListBuffer[Long]()\n      l += 1\n      l += 3\n      var t = 1\n\
    \      if (n >= 2) {\n        l += 2\n        t = 2\n      }\n      while (t <\
    \ n) {\n        var tmp = l(l.length - 1) + l(l.length - 2) + l(l.length - 3)\n\
    \        l += tmp\n        t += 1\n      }\n      l.toList", "        var index\
    \ = 1\n        var trib = ListBuffer[Long]()\n        trib += 1\n        trib\
    \ += 3\n        trib += 2\n        while (index < n) {\n            if (index\
    \ % 2 == 0) {\n                trib += (1 + index / 2)\n            } else {\n\
    \                trib += (trib(index - 1) + trib(index - 2) + trib(index + 1))\n\
    \            }\n            index += 1\n        }\n        trib.toList", "   \
    \     var result = List[Long]()\n        if (n >= 1) result = List[Long](1l.toLong)\n\
    \        if (n >= 2) result = List[Long](1l.toLong, 3l.toLong)\n        if (n\
    \ >= 3) result = List[Long](1l.toLong, 3l.toLong, 2l.toLong)\n        for (i <-\
    \ 3l to n) {\n            val v = if (i % 2 == 0) 1 + i / 2 else result(i.toInt\
    \ - 1) + result(i.toInt - 2) + result(i.toInt + 1)\n            result = result\
    \ :+ v\n        }\n        result", "        val ans = new ListBuffer[Long]\n\
    \        ans += 1\n        ans += 3\n        if (n == 1) return ans.toList\n \
    \       ans += 2\n        if (n == 2) return ans.toList\n        ans += 8\n  \
    \      if (n == 3) return ans.toList\n        for (i <- 1 to n - 3) {\n      \
    \      ans += ans(ans.length - 3) + ans(ans.length - 2) + ans(ans.length - 1)\n\
    \        }\n        ans.toList", "        // Fill up this function body\n    \
    \    // You may also define new functions as you wish\n        val map = new HashMap[Long,\
    \ Long]\n        map(1) = 3\n        def get(n : Long) : Long = {\n          \
    \  if (map.contains(n)) {\n                map(n)\n            } else {\n    \
    \            if (n % 2 == 0) {\n                    val tri = 1 + n / 2\n    \
    \                map(n) = tri\n                    tri\n                } else\
    \ {\n                    val tri = get(n - 1) + get(n - 2) + get(n + 1)\n    \
    \                map(n) = tri\n                    tri\n                }\n  \
    \          }\n        }\n        val list = ListBuffer[Long]()\n        for (i\
    \ <- 1 to n.toInt) {\n            list += get(i)\n        }\n        list.toList",
  "        var list = List[Long]()\n        var i = 0\n        for (i <- 0 to n.toInt)\
    \ list :+= (if (i == 0) 1 else if (i == 1) 3 else if (i == 2) 2 else tri(n - 1)\
    \ + tri(n - 2) + tri(n + 1))\n        list", "        if (n < 1) Nil\n       \
    \ else if (n == 1) List(3)\n        else {\n            var result = List(1, 3,\
    \ 2)\n            for (i <- 3 to n.toInt) {\n                if (i % 2 == 0) result\
    \ = result :+ (i / 2).toLong\n                else result = result :+ (result(i\
    \ - 1) + result(i - 2) + result(i + 1))\n            }\n            result\n \
    \       }", "        val dp = HashMap[Long, Long]()\n        def triHelper(n :\
    \ Long) : Long = {\n        \tif (n <= 0) 1\n        \telse {\n        \t\tif\
    \ (dp.contains(n)) dp(n)\n        \t\telse {\n        \t\t\tif (n % 2 == 0) {\n\
    \        \t\t\t\tval ans = 1 + n / 2\n        \t\t\t\tdp += n -> ans\n       \
    \ \t\t\t\tans\n        \t\t\t}\n        \t\t\telse {\n        \t\t\t\tval ans\
    \ = triHelper(n - 1) + triHelper(n - 2) + triHelper(n + 1)\n        \t\t\t\tdp\
    \ += n -> ans\n        \t\t\t\tans\n        \t\t\t}\n        \t\t}\n        \t\
    }\n        }\n        val result = for (i <- 1 to n.toInt) yield triHelper(i)\n\
    \        result.toList", "    \t\tdef tri(n : Long, a : Long, b : Long, c : Long)\
    \ : List[Long] = {\n    \t\t\tif (n <= 0) List[Long]()\n    \t\t\telse if (n ==\
    \ 1) (1l +: tri(n - 1, a, b, c))\n    \t\t\telse if (n == 2) (a +: tri(n - 1,\
    \ a, b, c))\n    \t\t\telse if (n == 3) (b +: tri(n - 1, a, b, c))\n    \t\t\t\
    else if (n == 4) (c +: tri(n - 1, a, b, c))\n    \t\t\telse (tri(n - 1, a, b,\
    \ c).last + tri(n - 2, a, b, c).last + tri(n + 1, a, b, c).last) +: tri(n - 1,\
    \ a, b, c)\n    \t\t}\n    \t\ttri(n, 1, 3, 2)", "        if (n == 0) List(1)\n\
    \        else if (n == 1) List(1, 3)\n        else if (n == 2) List(1, 3, 2)\n\
    \        else if (n % 2 == 0) List(1, 3, 2) ::: List(n / 2 + 1)\n        else\
    \ {\n            var result = tri(n - 3)\n            result = result ::: List(result(result.length\
    \ - 3) + result(result.length - 2) + result(result.length - 1))\n            result\n\
    \        }", "        // Fill up this function body\n        // 'n' is the number\
    \ of elements you have to return in the list\n        return List(1, 2, 3).slice(0,\
    \ n.toInt)", "    \tval m = n + 1\n    \tval a = new Array[Long](m.toInt)\n  \
    \  \ta(0) = 1\n    \ta(1) = 3\n    \tif (m == 1) {\n    \t    return List(a(0))\n\
    \    \t}\n    \telse if (m == 2) {\n    \t    return List(a(0), a(1))\n    \t\
    }\n    \ta(2) = 2\n    \tfor (i <- 3 until m.toInt) {\n    \t\tif (i % 2 == 0)\
    \ {\n    \t\t\ta(i) = 1 + i / 2\n    \t\t}\n    \t\telse {\n    \t\t\ta(i) = a(i\
    \ - 1) + a(i - 2) + a(i + 1)\n    \t\t}\n    \t}\n    \treturn a.toList", "  \
    \      var list = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n  \
    \          if (i == 1) list += 3\n            else if (i == 2) list += 2\n   \
    \         else if (i == 3) list += 8\n            else if (i % 2 == 0) list +=\
    \ 1 + i / 2\n            else list += list(i - 1) + list(i - 2) + list(i - 3)\n\
    \        }\n        list.toList", "        var arr = new Array[Long](n.toInt +\
    \ 1)\n        arr(0) = 1\n        arr(1) = 3\n        arr(2) = 2\n        for\
    \ (i <- 3 to n.toInt) {\n            if (i % 2 == 0) arr(i) = 1 + i / 2\n    \
    \        else arr(i) = arr(i - 1) + arr(i - 2) + arr(i + 1)\n        }\n     \
    \   arr.toList", "    \tvar l = List[Long]()\n    \tl = l.::(1)\n    \tl = l.::(3)\n\
    \    \tl = l.::(2)\n    \tdef t(n : Long, prev3 : Long, prev2 : Long, prev1 :\
    \ Long) : List[Long] = {\n    \t\tif (n > 0) {\n    \t\t\tvar t = 0l\n    \t\t\
    \tif (n % 2 == 0) t = 1 + n / 2\n    \t\t\telse t = prev3 + prev2 + prev1\n  \
    \  \t\t\tt(n - 1, prev2, prev1, t)\n    \t\t\tl = l.::(t)\n    \t\t}\n    \t\t\
    else l\n    \t}\n    \tt(n, 2, 3, 1)\n    \tl.reverse", "        // Write your\
    \ code here\n        null", "    \t\tdef f(n : Long) : Long = {\n    \t\t\tif\
    \ (n == 1) 1\n    \t\t\telse 1 + n / 2\n    \t\t}\n    \t\tdef fib(n : Long) :\
    \ Long = {\n    \t\t\tif (n == 1) 3\n    \t\t\telse if (n == 2) f(1)\n    \t\t\
    \telse f(n) + fib(n - 1) + fib(n - 2)\n    \t\t}\n    \t\tif (n == 0) List(1)\n\
    \    \t\telse if (n == 1) List(1, 3)\n    \t\telse if (n == 2) List(1, 3, 2)\n\
    \    \t\telse List(1, 3, 2) ::: (for (i <- 3 to n.toInt) yield fib(i)).toList",
  "        val a = ListBuffer[Long]()\n        a += 1\n        a += 3\n        a +=\
    \ 2\n        for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) a += (1 +\
    \ i / 2)\n            else a += (a(i - 1) + a(i - 2) + a(i + 1))\n        }\n\
    \        a.toList", "        // Put your code here\n        List()", "       \
    \ if (n == 0) List(1)\n        else if (n == 1) List(1, 3)\n        else if (n\
    \ == 2) List(1, 3, 2)\n        else if (n % 2 == 0) (1 to n.toInt).map((x) =>\
    \ 1 + (x / 2)).toList\n        else {\n            val t1 = tri(n - 1)\n     \
    \       val t2 = tri(n - 2)\n            val t3 = tri(n + 1)\n            val\
    \ v = t1.last + t2.last + t3.last\n            t1 :+ v\n        }", "        var\
    \ seq = new ListBuffer[Long]\n        seq += 1\n        seq += 3\n        seq\
    \ += 2\n        for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) seq +=\
    \ (1 + i / 2)\n            else seq += (seq(i - 1) + seq(i - 2) + seq(i + 1))\n\
    \        }\n        seq.toList", "        var arr = Array.fill(n.toInt + 1)(0L)\n\
    \        arr(0) = 1\n        arr(1) = 3\n        arr(2) = 2\n        for (i <-\
    \ 3 to n.toInt) {\n            arr(i) = if (i % 2 == 0) 1 + i / 2 else arr(i -\
    \ 1) + arr(i - 2) + arr(i + 1)\n        }\n        arr.toList", "        def tri(n\
    \ : Long, cache : Map[Long, Long]) : Long = {\n            if (cache.contains(n))\
    \ cache(n)\n            else {\n                val result = n match {\n     \
    \               case 1 => 3\n                    case 2 => 1\n               \
    \     case 3 => 2\n                    case n if n % 2 == 0 => 1 + n / 2\n   \
    \                 case n => tri(n - 1, cache) + tri(n - 2, cache) + tri(n + 1,\
    \ cache)\n                }\n                cache += (n -> result)\n        \
    \        result\n            }\n        }\n        val cache = Map[Long, Long]()\n\
    \        val result = for (i <- 1l to n) yield tri(i, cache)\n        result.toList",
  "        def tri_(p : Long, q : Long, r : Long, n : Long) : List[Long] = n match\
    \ {\n            case 0 => List(1)\n            case 1 => List(3)\n          \
    \  case 2 => List(1, 2)\n            case _ => {\n                if (n % 2 ==\
    \ 0) {\n                    val next = 1 + n / 2\n                    tri_(q,\
    \ r, next, n - 1) :+ next\n                } else {\n                    val next\
    \ = p + q + r\n                    tri_(q, r, next, n - 1) :+ next\n         \
    \       }\n            }\n        }\n        tri_(0, 0, 0, n)", "        // Fill\
    \ up this function body\n        // 'n' is the number given by the problem\n \
    \       // You have to return a list of 'n'+1 size\n        // Do not change the\
    \ function name\n        if (n == 1) {\n            List(1l)\n        } else if\
    \ (n == 2) {\n            List(1l, 3l)\n        } else {\n            var ans\
    \ = List(1l, 3l, 2l)\n            var i = 3\n            while (i <= n) {\n  \
    \              var x = if (i % 2 == 0) {\n                    1 + i / 2\n    \
    \            } else {\n                    ans(i - 1) + ans(i - 2) + ans(i + 1)\n\
    \                }\n                ans = ans :+ x\n                i += 1\n \
    \           }\n            ans\n        }", "        val result = ListBuffer[Long]()\n\
    \        def triHelper(n : Long) : Long = {\n            if (n == 1) 3\n     \
    \       else if (n % 2 == 0) 1 + n / 2\n            else triHelper(n - 1) + triHelper(n\
    \ - 2) + triHelper(n + 1)\n        }\n        for (i <- 0 to n.toInt) result +=\
    \ triHelper(i)\n        result.toList", "        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        val result\
    \ = ListBuffer[Long]()\n        var i = 1\n        while (i <= n) {\n        \
    \    i match {\n                case 1 => result += 3\n                case x\
    \ if x % 2 == 0 => result += (1 + (x / 2))\n                case _ => result +=\
    \ (result(i - 2) + result(i - 3) + result(i - 1))\n            }\n           \
    \ i += 1\n        }\n        result.toList", "        val cache = new HashMap[Long,\
    \ Long]\n        def tri(n : Long) : Long = {\n            if (cache.contains(n))\
    \ cache(n)\n            else {\n                val result = n match {\n     \
    \               case 0 => 1\n                    case 1 => 3\n               \
    \     case 2 => 2\n                    case x if x % 2 == 0 => 1 + x / 2\n   \
    \                 case x => tri(x - 1) + tri(x - 2) + tri(x + 1)\n           \
    \     }\n                cache += (n -> result)\n                result\n    \
    \        }\n        }\n        (0 to n.toInt).map(tri(_)).toList", "        val\
    \ (zero, one, two) = (0l, 1l, 2l)\n        //val (zero, one, two) = (Long.MinValue,\
    \ Long.MinValue + 1, Long.MinValue + 2)\n        def tri_rec(n : Long, x : List[Long])\
    \ : List[Long] = {\n            if (n == 0) x.reverse else {\n               \
    \ if (n % 2 == 0)\n                    tri_rec(n - 1, (1 + n / 2) :: x)\n    \
    \            else {\n                    if (x.length == 1) tri_rec(n - 1, (1\
    \ + 2 + 3) :: x)\n                    else if (x.length == 2) tri_rec(n - 1, (x(zero)\
    \ + x(one) + x(two)) :: x)\n                    else tri_rec(n - 1, (x(zero) +\
    \ x(one) + x(two)) :: x.dropRight(1))\n                }\n            }\n    \
    \    }\n        tri_rec(n, List(3l))", "        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        List[Long]()",
  "        if (n == 0)\n            return Nil\n        val list = new ListBuffer[Long]\n\
    \        list += 1l\n        list += 3l\n        if (n == 1)\n            return\
    \ list.toList\n        list += 2l\n        if (n == 2)\n            return list.toList\n\
    \        for (i <- 3l to n) {\n            if (i % 2 == 0)\n                list\
    \ += (1 + i / 2)\n            else\n                list += (list(i.toInt - 1)\
    \ + list(i.toInt - 2) + list(i.toInt + 1))\n        }\n        list.toList", " \
    \       var result = new ListBuffer[Long]\n        if (n == 0) return List()\n\
    \        var tri1 = 0l; var tri2 = 0l; var tri3 = 3l\n        for (i <- 1 to n.toInt)\
    \ {\n            if (i % 2 == 0) result += (i / 2)\n            else {\n     \
    \           result += (tri1 + tri2 + tri3)\n                tri1 = tri2; tri2\
    \ = tri3; tri3 = result(result.length - 1)\n            }\n        }\n       \
    \ result.toList", "        def triRec(n : Long, f : Long, s : Long, t : Long)\
    \ : List[Long] = {\n            if (n < 0) List[Long]()\n            else if (n\
    \ == 0) List[Long](f)\n            else if (n == 1) List[Long](f, s)\n       \
    \     else if (n == 2) List[Long](f, s, t)\n            else if (n % 2 == 0) triRec(n\
    \ - 1, f, s, t + (n / 2))\n            else triRec(n - 1, f, s, t + f + s + t)\n\
    \        }\n        triRec(n, 1, 3, 2)", "      if (n == 0) List(1)\n      else\
    \ if (n == 1) List(1, 3)\n      else {\n        val l = tri(n - 1)\n        if\
    \ (n % 2 == 0) l :+ (1 + n / 2)\n        else l :+ (l(l.length - 3) + l(l.length\
    \ - 2) + l(l.length - 1))\n      }", "        // Fill up this function body\n\
    \        // You may add another function as well, if required", "        var list\
    \ = ListBuffer[Long]()\n        list += 1\n        list += 3\n        if (n >\
    \ 1) list += 2\n        for (i <- 3 to n.toInt) {\n            if (i % 2 == 0)\
    \ list += i / 2\n            else list += list(i - 2) + list(i - 1) + list(i +\
    \ 1)\n        }\n        list.toList", "        var seq = List[Long](1, 3, 2)\n\
    \        if (n == 0) return seq.take(1)\n        if (n == 1) return seq.take(2)\n\
    \        if (n == 2) return seq.take(3)\n        for (i <- 3 to n.toInt) {\n \
    \           val even = (i % 2 == 0)\n            if (even) seq = seq :+ (1 + i\
    \ / 2)\n            else seq = seq :+ (seq(i - 1) + seq(i - 2) + seq(i + 1))\n\
    \        }\n        return seq", "      var ans = List[Long]()\n      for (i <-\
    \ 1 to n.toInt) {\n        if (i == 1) ans ::= 1\n        else if (i == 2) ans\
    \ ::= 3\n        else if (i == 3) ans ::= 2\n        else if (i % 2 == 0) ans\
    \ ::= ans(i - 1) / 2\n        else ans ::= ans(i - 1) + ans(i - 2) + ans(i - 3)\n\
    \      }\n      ans.reverse", "        val l = new ArrayBuffer[Long]\n       \
    \ l += 1l\n        l += 3l\n        var i = 2l\n        while (i <= n) {\n   \
    \         if (i % 2 == 0) {\n                l += 1 + i / 2\n            } else\
    \ {\n                l += l(i.toInt - 1) + l(i.toInt - 2) + l(i.toInt + 1)\n \
    \           }\n            i += 1\n        }\n        l.toList", "        def\
    \ h(index : Long, lst : List[Long]) : List[Long] = {\n            if (index ==\
    \ n) return lst\n            val newElem = if (index % 2 == 0) 1 + index / 2 else\
    \ lst(lst.length - 1) + lst(lst.length - 2) + lst(lst.length - 3)\n          \
    \  h(index + 1, lst :+ newElem)\n        }\n        h(1, List(1))", "    \tif\
    \ (n == 0) List[Long]()\n    \telse if (n == 1) List[Long](1)\n    \telse if (n\
    \ == 2) List[Long](1, 3)\n    \telse if (n == 3) List[Long](1, 3, 2)\n    \telse\
    \ {\n    \t\tval half = n / 2\n    \t\tval lower = tri(half)\n    \t\tval upper\
    \ = tri(n - half)\n    \t\t(1L +: lower ::: (lower.zip(upper).map(x => x._1 +\
    \ x._2) :+ upper.last))\n    \t}", "        if (n < 0) return List[Long]()\n \
    \       var a = List[Long](1, 3, 2)\n        var last = a.last\n        while\
    \ (last < n) {\n            if (last % 2 == 0) a = a :+ (1 + last / 2)\n     \
    \       else a = a :+ (a(a.length - 1) + a(a.length - 2) + a(a.length - 3))\n\
    \            last = a.last\n        }\n        return a", "        def tri(n :\
    \ Long, acc : List[Long]) : List[Long] = {\n            if (n == 1) {\n      \
    \          3 :: acc\n            } else if (n % 2 == 0) {\n                tri(n\
    \ - 1, 1 + n / 2 :: acc)\n            } else {\n                tri(n - 1, acc.head\
    \ + acc.tail.head + acc.tail.tail.head :: acc)\n            }\n        }\n   \
    \     tri(n, List[Long]())", "        // Let f(n) be the result of the above recurrence.\
    \ Then\n        // f(n) = c1 * a^n + c2 * b^n + c3 * c^n\n        // where c1,\
    \ c2, c3 are some constants and a, b, c are the roots of the cubic equation\n\
    \        // a^3 - a^2 - a - 1 = 0.\n        // a = (1 + 3 * sqrt(33)) / 6, b =\
    \ (1 - 3 * sqrt(33)) / 6, c = -1 / 2\n        // It's easy to see that c1, c2,\
    \ c3 can be found using\n        // f(1) = c1 * a + c2 * b + c3 * c\n        //\
    \ f(2) = c1 * a^2 + c2 * b^2 + c3 * c^2\n        // f(3) = c1 * a^3 + c2 * b^3\
    \ + c3 * c^3\n        // Which are three equations with three variables (c1, c2,\
    \ c3)\n        // By solving this system we get\n        // c1 = 3, c2 = -2 *\
    \ 3^2 * sqrt(33) / 33, c3 = -3^3 / 33\n        // Now f(n) can be calculated in\
    \ O(logn) time by the fast power algorithm.\n        val a = (1 + 3 * sqrt(33))\
    \ / 6\n        val b = (1 - 3 * sqrt(33)) / 6\n        val c = -1 / 2\n      \
    \  val c1 = 3\n        val c2 = -2 * 3 * 3 * sqrt(33) / 33\n        val c3 = -3\
    \ * 3 * 3 / 33\n        val power = (x : Double, y : Long) => {\n            if\
    \ (y == 0) {\n                1\n            } else if (y == 1) {\n          \
    \      x\n            } else {\n                val t = power(x, y / 2)\n    \
    \            t * t * (if (y % 2 == 0) 1 else x)\n            }\n        }\n  \
    \      def f(n : Long) : Long = {\n            if (n == 0) 0\n            else\
    \ if", "        val memo = Array.fill(n.toInt + 1)(-1l)\n        memo(0) = 1l\n\
    \        memo(1) = 3l\n        def solve(i : Int) : Long = {\n            if (memo(i)\
    \ != -1) memo(i)\n            else if (i % 2 == 0) {\n                memo(i)\
    \ = 1 + i / 2\n                memo(i)\n            }\n            else {\n  \
    \              memo(i) = solve(i - 1) + solve(i - 2) + solve(i + 1)\n        \
    \        memo(i)\n            }\n        }\n        (0 to n.toInt).map(solve(_)).toList",
  "    \tif (n == 0) return List(1)\n    \tif (n == 1) return List(1, 3)\n    \tif\
    \ (n == 2) return List(1, 3, 2)\n    \tvar result = List[Long](1, 3, 2)\n    \t\
    var i = 3l\n    \twhile (i <= n) {\n    \t\tresult = result :+ (if (i % 2 == 0)\
    \ (1 + i / 2) else (result(i.toInt - 1) + result(i.toInt - 2) + result(i.toInt\
    \ + 1)))\n    \t\ti += 1\n    \t}\n    \tresult", "        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ List()", "        // Fill up this function body\n        // 'List[Long]' constructor\
    \ is not that easy to write,\n        // so you might want to use it in your implementation.\n\
    \        // Don't forget to 'import scala.collection.mutable._'\n        // to\
    \ use 'ArrayBuffer' data structure.\n        val ans = new ArrayBuffer[Long]\n\
    \        ans += 1\n        if (n >= 1) ans += 3\n        for (i <- 2 to n.toInt)\
    \ {\n            if (i % 2 == 0) ans += 1 + i / 2\n            else ans += ans(i\
    \ - 1) + ans(i - 2) + ans(i + 1)\n        }\n        ans.toList", "        //\
    \ Fill up this function body\n        // You may add another function as well,\
    \ if required\n        var result = ListBuffer[Long]()\n        var a = 1l\n \
    \       var b = 3l\n        var c = 2l\n        result += a\n        result +=\
    \ b\n        result += c\n        for (i <- 3l to n) {\n            if (i % 2\
    \ == 0) result += (1 + i / 2)\n            else {\n                result += (result(i.toInt\
    \ - 1) + result(i.toInt - 2) + result(i.toInt + 1))\n            }\n        }\n\
    \        result.toList", "        var lst = new Array[Long](n.toInt + 1)\n   \
    \     lst(0) = 1\n        lst(1) = 3\n        for (i <- 2 to n.toInt) {\n    \
    \        if (i % 2 == 0) {\n                lst(i) = 1 + i / 2\n            }\
    \ else {\n                lst(i) = lst(i - 1) + lst(i - 2) + lst(i + 1)\n    \
    \        }\n        }\n        lst.toList", "        def loop(n : Long, dp : List[Long])\
    \ : List[Long] = {\n            if (n == 0) dp\n            else {\n         \
    \       if (n % 2 == 0) loop(n - 1, dp :+ (1 + n / 2))\n                else loop(n\
    \ - 1, dp :+ (dp(dp.length - 1) + dp(dp.length - 2) + dp(dp.length - 3)))\n  \
    \          }\n        }\n        loop(n, List[Long](1))", "        def tri_rec(i\
    \ : Long, arr : List[Long]) : List[Long] = {\n            if (i == n) arr\n  \
    \          else if (i % 2 == 0) tri_rec(i + 1, arr :+ (1 + i / 2))\n         \
    \   else tri_rec(i + 1, arr :+ (arr(i.toInt - 1) + arr(i.toInt - 2) + arr(i.toInt\
    \ + 1)))\n        }\n        tri_rec(1, List[Long](1))", "        if (n == 0)\n\
    \            List(1l)\n        else if (n == 1)\n            List(1l, 3l)\n  \
    \      else if (n == 2)\n            List(1l, 3l, 2l)\n        else {\n      \
    \      val list = tri(n - 1)\n            if (n % 2 == 0)\n                list\
    \ :+ (1 + n / 2)\n            else\n                list :+ (list(list.length\
    \ - 1) + list(list.length - 2) + list(list.length - 3))\n        }", "       \
    \ var result = new ListBuffer[Long]\n        if (n == 0) return List[Long](1l)\n\
    \        if (n == 1) return List[Long](1l, 3l)\n        if (n == 2) return List[Long](1l,\
    \ 3l, 2l)\n        result += 1l\n        result += 3l\n        result += 2l\n\
    \        for (i <- 3l to n) {\n            var next = 0l\n            if (i %\
    \ 2 == 0) next = 1 + i / 2\n            else next = result(i.toInt - 1) + result(i.toInt\
    \ - 2) + result(i.toInt + 1)\n            result += next\n        }\n        return\
    \ result.toList", "        var a = ListBuffer[Long]()\n        for (i <- 1 to\
    \ n.toInt) {\n        \tif (i == 1) a += 3\n        \telse if (i == 2) a += 1\n\
    \        \telse if (i == 3) a += 2\n        \telse {\n        \t\tif (i % 2 ==\
    \ 0) a += i / 2\n        \t\telse a += a(i - 2) + a(i - 3) + a(i - 1)\n      \
    \  \t}\n        }\n        a.toList", "        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        var tri\
    \ = List[Long](1, 3, 2)\n        while (tri.length != n + 1) {\n            var\
    \ cur = tri.length\n            if (cur % 2 == 0) {\n                tri = tri\
    \ :+ (1 + cur / 2)\n            } else {\n                tri = tri :+ (tri(cur\
    \ - 1) + tri(cur - 2) + tri(cur + 1))\n            }\n        }\n        tri",
  "        def triR(n : Long, s : List[Long]) : List[Long] = {\n            if (n\
    \ == 0) s\n            else if (n == 1) s :+ 3\n            else if (n % 2 ==\
    \ 0) triR(n - 1, s :+ (1 + n / 2))\n            else triR(n - 1, s :+ (s(s.length\
    \ - 1) + s(s.length - 2) + s(s.length - 3)))\n        }\n        triR(n, List[Long]())",
  "        var a = 1l; var b = 1l; var c = 1l;\n        return List.range(0, n.toInt\
    \ + 1).map(x => {\n            var v = a + b + c;\n            if (v % 2 == 0)\
    \ v /= 2;\n            a = b; b = c; c = v;\n            return v;\n        }).toList;",
  "        val arr = new Array[Long](n.toInt + 1)\n        arr(0) = 1\n        arr(1)\
    \ = 3\n        for (i <- 2 to n.toInt) {\n            if (i % 2 == 0) arr(i) =\
    \ 1 + i / 2\n            else arr(i) = arr(i - 1) + arr(i - 2) + arr(i + 1)\n\
    \        }\n        arr.toList", "        // Good Luck!\n        val result =\
    \ new ListBuffer[Long]()\n        result += 1\n        result += 3\n        result\
    \ += 2\n        for (i <- 4 to n.toInt) {\n            if (i % 2 == 0) {\n   \
    \             result += 1 + i / 2\n            } else {\n                result\
    \ += result(i - 2) + result(i - 1) + result(i + 1)\n            }\n        }\n\
    \        result.toList", "        def tri(n : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (n == 0) acc\n            else if (n == 1) tri(n - 1, 3\
    \ :: acc)\n            else if (n % 2 == 0) tri(n - 1, (1 + n / 2) :: acc)\n \
    \           else tri(n - 1, (acc(1) + acc(2) + acc(0)) :: acc)\n        }\n  \
    \      tri(n, List())", "        val fib = ArrayBuffer[Long](1, 3, 2)\n      \
    \  if (n == 1) fib.take(2).toList\n        else {\n            (3l to n).foreach(x\
    \ => fib += fib(x.toInt - 1) + fib(x.toInt - 2) + fib(x.toInt + 1))\n        \
    \    fib.toList\n        }", "    \tif (n == 0) List(1)\n    \telse if (n == 1)\
    \ List(1, 3)\n    \telse {\n    \t\tval lst = tri(n - 1)\n    \t\tval m = lst.length\n\
    \    \t\tvar x = lst(m - 1) + lst(m - 2) + lst(m - 3)\n    \t\tif (n % 2 == 0)\
    \ x = 1 + n / 2\n    \t\tlst :+ x\n    \t}", "        var list = List[Long]()\n\
    \        var i = 1\n        while (i <= n) {\n            list :+= tri(i)\n  \
    \          i += 1\n        }\n        list", "        def tri(a : Long, b : Long,\
    \ c : Long, l : List[Long]) : List[Long] = {\n            if (l.length == n +\
    \ 1) l\n            else if (l.length % 2 == 0) tri(a, b, c, c +: l)\n       \
    \     else tri(b, c, c + b + a, c + b + a +: l)\n        }\n        tri(1, 3,\
    \ 2, List[Long](1))", "        // your solution here\n        val result : ListBuffer[Long]\
    \ = ListBuffer(1l)\n        for (i <- 1l to n) {\n            if (i == 1) {\n\
    \                result += 3l\n            } else if (i % 2 == 0) {\n        \
    \        result += (1 + i / 2)\n            } else {\n                result +=\
    \ (result(i.toInt - 1) + result(i.toInt - 2) + result(i.toInt + 1))\n        \
    \    }\n        }\n        result.toList", "        def helper(l : List[Long],\
    \ n : Long) : List[Long] = {\n            if (n == 0) l\n            else {\n\
    \                if (n % 2 == 0) helper(l :+ (1 + n / 2), n - 1)\n           \
    \     else helper(l :+ (l(l.length - 1) + l(l.length - 2) + l(l.length - 3)),\
    \ n - 1)\n            }\n        }\n        helper(List(1, 3, 2), n)", "     \
    \ val l = new Array[Long]((n + 1).toInt)\n      l(0) = 1\n      l(1) = 3\n   \
    \   if (n == 0) return List(1)\n      if (n == 1) return List(1, 3)\n      for\
    \ (i <- 2 to n.toInt) {\n        if (i % 2 == 0) l(i) = 1 + i / 2\n        else\
    \ l(i) = l(i - 1) + l(i - 2) + l(i + 1)\n      }\n      return l.toList", "  \
    \      // Implements a fibonacci seq\n        // fib(n) = fib(n - 1) + fib(n -\
    \ 2)\n        def fib(n : Long) : Long = {\n            // If n is not in memory,\
    \ compute it\n            if (!fibonacci.contains(n)) {\n                fibonacci(n)\
    \ = if (n % 2 == 0) 1 + n / 2 else fib(n - 1) + fib(n - 2) + fib(n + 1)\n    \
    \        }\n            fibonacci(n)\n        }\n        var fibonacci = Map[Long,\
    \ Long]()\n        fibonacci(1) = 3\n        fibonacci(2) = 1\n        fibonacci(3)\
    \ = 2\n        (0 to n.toInt).map(x => fib(x)).toList", "        var b1 = 0l\n\
    \        var b2 = 1l\n        var b3 = 3l\n        val res = new ListBuffer[Long]\n\
    \        res += 0\n        res += 1\n        res += 3\n        for (i <- 3 to\
    \ n.toInt) {\n            if (i % 2 == 0) res += (i / 2 + 1)\n            else\
    \ {\n                res += (res(i - 1) + res(i - 2) + res(i + 1))\n         \
    \   }\n        }\n        res.toList", "    \tif (n == 0) return List(1)\n   \
    \ \tif (n == 1) return List(1, 3)\n    \tval result = new ListBuffer[Long]\n \
    \   \tresult += 1\n    \tresult += 3\n    \tresult += 2\n    \tfor (i <- 3l to\
    \ n) {\n    \t\tif (i % 2 == 0) result += (1 + i / 2)\n    \t\telse result +=\
    \ (result(result.length - 1) + result(result.length - 2) + result(result.length))\n\
    \    \t}\n    \tresult.toList", "        if (n == 0) return List(1)\n        if\
    \ (n == 1) return List(1, 3)\n        val lst = tri(n - 1)\n        val newlst\
    \ = lst :+ ((if (n % 2 == 0) 1 + n / 2 else lst(lst.length - 1) + lst(lst.length\
    \ - 2) + lst(lst.length - 3)))\n        return newlst", "        var cache = Array.fill(n.toInt\
    \ + 1)(0)\n        var res = new ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt)\
    \ {\n            var x = 0l\n            if (i == 1) x = 3\n            else if\
    \ (i == 2) x = 1\n            else if (i == 3) x = 2\n            else if (i %\
    \ 2 == 0) x = i / 2\n            else x = 1 + cache(i - 1) + cache(i - 2) + cache(i\
    \ + 1)\n            cache(i) = x.toInt\n            res += x\n        }\n    \
    \    res.toList", "    \tval a = new Array[Long](n.toInt + 1)\n    \ta(0) = 1\n\
    \    \ta(1) = 3\n    \ta(2) = 2\n    \tfor (i <- 3 to n.toInt) {\n    \t\tif (i\
    \ % 2 == 0) a(i) = (1 + i / 2)\n    \t\telse a(i) = a(i - 1) + a(i - 2) + a(i\
    \ + 1)\n    \t}\n    \treturn a.toList", "        var lst = new ListBuffer[Long]\n\
    \        for (i <- 1 to n.toInt) {\n            if (i == 1) lst += 3\n       \
    \     else if (i == 2) lst += 1\n            else if (i == 3) lst += 2\n     \
    \       else if (i % 2 == 0) lst += 1 + i / 2\n            else lst += lst(i -\
    \ 4) + lst(i - 3) + lst(i - 2)\n        }\n        lst.toList", "        def triIter(n\
    \ : Long, l : List[Long]) : List[Long] = {\n            if (n <= 0) l\n      \
    \      else if (n % 2 == 0) triIter(n - 1, 1 + n / 2 :: l)\n            else {\n\
    \                val x = l.head + l.tail.head + l.tail.tail.head\n           \
    \     triIter(n - 1, x :: l)\n            }\n        }\n        triIter(n, List())",
  "    \tif (n == 0) return List(1)\n    \tif (n == 1) return List(1, 3)\n    \tif\
    \ (n == 2) return List(1, 3, 2)\n    \tvar triList = tri(n - 1)\n    \tvar triCurr\
    \ = triList(triList.length - 1) + triList(triList.length - 2) + triList(triList.length\
    \ - 3)\n    \ttriList = triList :+ triCurr\n    \treturn triList", "        def\
    \ f(n : Long) : Long = if (n == 1) 3 else if (n % 2 == 0) 1 + n / 2 else f(n -\
    \ 1) + f(n - 2) + f(n + 1)\n        var l = List[Long]()\n        (0 to n.toInt).foreach(i\
    \ => l :+= f(i))\n        l", "        def helper(n : Long, lst : List[Long])\
    \ : List[Long] = n match {\n            case 0 => lst\n            case _ => {\n\
    \                if (n % 2 == 0) {\n                    helper(n - 1, lst :+ (1\
    \ + n / 2))\n                } else {\n                    helper(n - 1, lst :+\
    \ (lst(lst.length - 1) + lst(lst.length - 2) + lst(lst.length - 3)))\n       \
    \         }\n            }\n        }\n        helper(n, List(1))", "        var\
    \ t = new Array[Long](n.toInt + 1)\n        t(0) = 1; t(1) = 3; t(2) = 2\n   \
    \     for (i <- 3 to n.toInt) {\n            t(i) = if (i % 2 == 0) 1 + i / 2\
    \ else t(i - 1) + t(i - 2) + t(i + 1)\n        }\n        t.toList", "       \
    \ def tri(n : Long, a : Long, b : Long, c : Long) : List[Long] = {\n         \
    \   if (n == 0) List[Long]()\n            else if (n == 1) List[Long](1)\n   \
    \         else if (n == 2) List[Long](1, 3)\n            else if (n == 3) List[Long](1,\
    \ 3, 2)\n            else {\n                val d = if (n % 2 == 0) (n / 2) else\
    \ ((a + b + c) % 1000000007)\n                d :: tri(n - 1, b, c, d)\n     \
    \       }\n        }\n        tri(n, 0, 0, 0).reverse", "        // Fill up this\
    \ function body\n        // 'return List()' if the result is an empty list\n \
    \       // 'return List(1)' for a list with single element '1'\n        List(1,\
    \ 3, 2, 8)", "        n match {\n            case n if n == 0 => List(1)\n   \
    \         case n if n == 1 => List(1, 3)\n            case n if n == 2 => List(1,\
    \ 3, 2)\n            case n if n > 2 => {\n                val list = tri(n -\
    \ 1)\n                val value = if (n % 2 == 0) {\n                    (1 +\
    \ n / 2)\n                } else {\n                    list(list.length - 3)\
    \ + list(list.length - 2) + list(list.length - 1)\n                }\n       \
    \         list :+ value\n            }\n        }", "    \tvar list = new ListBuffer[Long]\n\
    \    \tlist += 1\n    \tlist += 3\n    \tvar x = 2\n    \twhile (x <= n) {\n \
    \   \t\tvar tri = 1 + (x / 2)\n    \t\tif (x % 2 == 1) {\n    \t\t\ttri = list(x\
    \ - 1) + list(x - 2) + list(x + 1)\n    \t\t}\n    \t\tlist += tri\n    \t\tx\
    \ += 1\n    \t}\n    \tlist.toList", "        val memo = new Array[Long](n.toInt\
    \ + 1)\n        memo(0) = 1\n        memo(1) = 3\n        memo(2) = 2\n      \
    \  def dp(x : Int) : Long = {\n            if (memo(x) != 0) memo(x)\n       \
    \     else {\n                val ans = if (x % 2 == 0) 1 + x / 2 else dp(x -\
    \ 1) + dp(x - 2) + dp(x + 1)\n                memo(x) = ans\n                ans\n\
    \            }\n        }\n        val l = new ListBuffer[Long]\n        for (i\
    \ <- 0 to n.toInt) l += dp(i)\n        l.toList", "        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ List()", "        //if (n == 0) return List[Long](1, 1, 1)\n        if (n ==\
    \ 1) return List[Long](1, 3)\n        if (n == 2) return List[Long](1, 3, 2)\n\
    \        var tri = new Array[Long](n.toInt + 1)\n        tri(0) = 1\n        tri(1)\
    \ = 3\n        tri(2) = 2\n        for (i <- 3 to n.toInt) {\n            tri(i)\
    \ = if (i % 2 == 0) 1 + i / 2 else tri(i - 1) + tri(i - 2) + tri(i + 1)\n    \
    \    }\n        tri.toList", "        // Fill up this function body\n        //\
    \ 'n' is non-negative integer\n        if (n == 0) List(1)\n        else if (n\
    \ == 1) List(1, 3)\n        else {\n            var a = 1l\n            var b\
    \ = 3l\n            var c = 2l\n            var lst = List[Long](a, b, c)\n  \
    \          for (i <- 3l to n) {\n                val v = if (i % 2 == 0) {\n \
    \                   1 + i / 2\n                } else {\n                    a\
    \ + b + c\n                }\n                a = b\n                b = c\n \
    \               c = v\n                lst = lst :+ v\n            }\n       \
    \     lst\n        }", "        def isEven(n : Long) : Boolean = n % 2 == 0\n\
    \        def findTri(n : Long) : Long = {\n            if (n == 1) 3\n       \
    \     else if (isEven(n)) n / 2 + 1\n            else {\n                val n1\
    \ = findTri(n - 1)\n                val n2 = findTri(n - 2)\n                val\
    \ n3 = findTri(n + 1)\n                n1 + n2 + n3\n            }\n        }\n\
    \        def find(n : Long, list : List[Long]) : List[Long] = {\n            if\
    \ (n <= 0) list\n            else find(n - 1, findTri(n) :: list)\n        }\n\
    \        find(n, List())", "        def run(x : Long, a : Long, b : Long, c :\
    \ Long) : Long = {\n            if (x == 0) 0\n            else if (x == 1) 1\n\
    \            else if (x == 2) 2\n            else if (x == 3) 3\n            else\
    \ if (x % 2 == 0) run(x - 1, a + b + c, a, b)\n            else run(x - 1, b,\
    \ c, a + b + c)\n        }\n        def loop(x : Long, l : List[Long]) : List[Long]\
    \ = {\n            if (x > n) l\n            else loop(x + 1, l :+ run(x, 0, 0,\
    \ 0))\n        }\n        loop(0, List())", "        if (n == 0) List[Long]()\n\
    \        else if (n == 1) List[Long](1)\n        else if (n == 2) List[Long](1,\
    \ 3)\n        else if (n == 3) List[Long](1, 3, 2)\n        else {\n         \
    \   var result = tri(n - 1)\n            var value = 0l\n            if (n % 2\
    \ == 0) value = 1 + n / 2\n            else value = result(result.length - 1)\
    \ + result(result.length - 2) + result(result.length - 3)\n            result\
    \ :+ value\n        }", "        if (n == 0) List(1)\n        else if (n == 1)\
    \ List(1, 3)\n        else if (n == 2) List(1, 3, 2)\n        else if (n % 2 ==\
    \ 0) tri(n - 1) :+ (1 + n / 2)\n        else tri(n - 1) :+ (tri(n - 1).last +\
    \ tri(n - 2).last + tri(n + 1).last)", "        // Fill up this function body\n\
    \        // 'a' is the accumulator, it is initialized with 1L which is base case\n\
    \        // 'b' is the base, which is 1 in our case.\n        // 'f' is the function\
    \ to be applied to every element of the list to be generated.\n        // 'lt'\
    \ is the list of elements to be generated.\n        def f(a : Long, b : Long,\
    \ f : (Long, Long) => Long, lt : List[Long]) : List[Long] = {\n            //\
    \ This function will generate elements of the list by applying function 'f' to\
    \ every element of 'lt'\n            lt match {\n                case List() =>\
    \ Nil\n                case x :: xs => f(a, b, f, lt.tail) ::: List(f(a, b, f,\
    \ lt))\n            }\n        }\n        def g(a : Long, b : Long) : Long = {\n\
    \            // This function will apply the function to the elements of the list\
    \ to be generated\n            // 'a' is the accumulator, it is initialized with\
    \ 1L which is base case\n            // 'b' is the element to be appended to the\
    \ list.\n            val ret = (b match {\n                case 1 => 3\n     \
    \           case _ => a + b\n            })\n            return ret\n        }\n\
    \        return f(1L, 1L, g, (1L to n).toList)", "        // Fill up this function\
    \ body\n        // 'n' is the number to which Tribonacci sequence is needed\n\
    \        // You have to return a list of the Tribonacci sequence of first 'n +\
    \ 1' numbers", "        var result = List[Long]()\n        if (n <= 0) return\
    \ result\n        result +:= 1\n        if (n == 1) return result\n        result\
    \ +:= 3\n        if (n == 2) return result\n        result +:= 2\n        if (n\
    \ == 3) return result\n        for (i <- (4l to n)) {\n            val last =\
    \ result.length - 1\n            val next = result(last - 2) + result(last - 1)\
    \ + result(last)\n            result +:= next\n        }\n        result.reverse",
  "        var list = new ListBuffer[Long]()\n        list += 1\n        list += 3\n\
    \        list += 2\n        for (i <- 4l to n) {\n            var value = 0l\n\
    \            if (i % 2 == 0) value = 1 + i / 2\n            else value = list(i.toInt\
    \ - 2) + list(i.toInt - 1) + list(i.toInt + 1)\n            list += value\n  \
    \      }\n        return list.toList", "        var f : List[Long] = List(0, 1,\
    \ 3)\n        def g(n : Long) : Long = {\n            if (n <= 3) {\n        \
    \        f(n.toInt)\n            } else {\n                if (n % 2 == 0) 1 +\
    \ n / 2\n                else {\n                    var a = g(n - 1)\n      \
    \              var b = g(n - 2)\n                    var c = g(n + 1)\n      \
    \              a + b + c\n                }\n            }\n        }\n      \
    \  (1l to n).map(i => g(i)).toList"]
stop_tokens:
- "\n    }\n"
