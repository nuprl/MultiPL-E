name: HumanEval_65_circular_shift
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Circular shift the digits of the integer x, shift the digits right by shift\n\
  \    // and return the result as a string.\n    // If shift > number of digits,\
  \ return digits reversed.\n    // >>> circularShift((12l), (1l))\n    // (\"21\"\
  )\n    // >>> circularShift((12l), (2l))\n    // (\"12\")\n    def circularShift(x\
  \ : Long, shift : Long) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(circularShift((100l),\
  \ (2l)).equals((\"001\")));\n    assert(circularShift((12l), (2l)).equals((\"12\"\
  )));\n    assert(circularShift((97l), (8l)).equals((\"79\")));\n    assert(circularShift((12l),\
  \ (1l)).equals((\"21\")));\n    assert(circularShift((11l), (101l)).equals((\"11\"\
  )));\n    }\n\n}\n"
completions: ["        val s = x.toString\n        if (shift >= s.length) {\n    \
    \        return new StringBuilder(s).reverse.toString\n        }\n        val\
    \ shiftString = s.substring(0, s.length - shift.toInt)\n        val appendString\
    \ = s.substring(s.length - shift.toInt)\n        appendString + shiftString",
  "        val digits = x.toString.map(c => c.toString)\n        if (shift > digits.length)\
    \ digits.reverse.reduceLeft(_ + _)\n        else digits.takeRight(shift.toInt)\
    \ ++ digits.take(digits.length - shift.toInt) reduceLeft(_ + _)", "        val\
    \ s = x.toString\n        val len = s.length\n        if (shift >= len) {\n  \
    \          s.reverse\n        } else {\n            val (a, b) = s.splitAt(len\
    \ - shift.toInt)\n            a + b\n        }", "        val digits = x.toString\n\
    \        val n = digits.length\n        val m = min(n, shift)\n        digits.substring(n\
    \ - m, n) + digits.substring(0, n - m)", "        val digits = x.toString.map(_.asDigit)\n\
    \        if (shift >= digits.length) digits.reverse.mkString\n        else digits.dropRight(shift.toInt).mkString\
    \ + digits.takeRight(shift.toInt).mkString", "        val digits = x.toString.length\n\
    \        if (shift >= digits) {\n            return x.toString.reverse\n     \
    \   }\n        val right = (x / pow(10, shift).toLong).toString\n        val left\
    \ = (x % pow(10, shift).toLong).toString\n        return left + right", "    \
    \    val xS = x.toString\n        val shiftS = shift.toString\n        val xL\
    \ = xS.length\n        if (shiftS.length >= xL) {\n            return xS.reverse\n\
    \        }\n        val shiftMod = shift % xL\n        val left = xS.slice(0,\
    \ xL - shiftMod.toInt)\n        val right = xS.slice(xL - shiftMod.toInt, xL)\n\
    \        val result = right + left\n        return result", "        if (shift\
    \ == 0) x.toString\n        else {\n            val digits = x.toString.map(e\
    \ => e.toString)\n            val n = digits.length\n            val shift1 =\
    \ if (shift >= n) n - 1 else shift.toInt\n            val shifted = (digits.slice(n\
    \ - shift1, n) ++ digits.slice(0, n - shift1)).mkString\n            if (shift\
    \ >= n) shifted.reverse else shifted\n        }", "        val digits = x.toString.toList\n\
    \        if (shift > digits.length) digits.reverse.mkString\n        else (digits.dropRight(shift.toInt)\
    \ ::: digits.takeRight(shift.toInt)).mkString", "      val s = x.toString\n  \
    \    val n = s.length\n      val l = if (shift < n) n - shift else 0\n      val\
    \ r = if (shift > n) shift - n else 0\n      val newS = s.substring(l, n) + s.substring(0,\
    \ l)\n      newS.reverse.substring(r, n) + newS.reverse.substring(0, r)", "  \
    \      val str = x.toString()\n        if (shift > str.length) str.reverse\n \
    \       else (str.substring(str.length - shift.toInt) + str.substring(0, str.length\
    \ - shift.toInt))", "        val s = x.toString\n        if (shift > s.length)\
    \ s.reverse\n        else {\n            val (left, right) = s.splitAt(s.length\
    \ - shift.toInt)\n            right + left\n        }", "        val s = x.toString\n\
    \        if (shift > s.length) s.reverse\n        else {\n            val (a,\
    \ b) = s.splitAt(s.length - shift.toInt)\n            b + a\n        }", "   \
    \     val digits = x.toString\n        val shiftAmount = if (shift > digits.length)\
    \ digits.length else shift.toInt\n        val shiftedDigits = digits.takeRight(shiftAmount)\
    \ + digits.dropRight(shiftAmount)\n        shiftedDigits", "        var m = BigInt(x)\n\
    \        var a = List[Int]()\n        while (m > 0) {\n            a = (m % 10).toInt\
    \ :: a\n            m /= 10\n        }\n        for (i <- 1 to shift.toInt) {\n\
    \            val temp = a.head\n            a = a.tail :+ temp\n        }\n  \
    \      a.reverse.mkString", "      if (shift == 0) x.toString\n      else {\n\
    \        val s = x.toString\n        val n = s.length\n        if (shift > n)\
    \ s.reverse\n        else (s.substring(n - shift.toInt) + s.substring(0, n - shift.toInt))\n\
    \      }", "        val nDigits = x.toString.length\n        if (shift > nDigits)\
    \ x.toString.reverse\n        else x.toString.slice(shift.toInt, nDigits) + x.toString.slice(0,\
    \ shift.toInt)", "        val digits = x.toString.toList\n        val numDigits\
    \ = digits.length\n        if (shift >= numDigits) {\n            return digits.reverse.mkString\n\
    \        }\n        val splitPos = numDigits - shift.toInt\n        val (front,\
    \ back) = digits.splitAt(splitPos)\n        return (back ::: front).mkString",
  "        val digits = (x.toString.length - shift.toString.length).toInt\n      \
    \  var xStr = x.toString\n        if (digits < 0) return xStr.reverse\n      \
    \  var shiftStr = shift.toString\n        xStr = xStr.substring(0, digits) + shiftStr\
    \ + xStr.substring(digits + shiftStr.length, xStr.length)\n        return xStr",
  "        val s = x.toString\n        val n = s.length\n        if (shift >= n) return\
    \ s.reverse\n        val prefix = s.take(n - shift.toInt)\n        val suffix\
    \ = s.drop(n - shift.toInt)\n        return suffix + prefix", "        val xLength\
    \ = x.toString.length\n        if (shift > xLength) {\n            val reversedX\
    \ = x.toString.reverse\n            return reversedX\n        }\n        var xString\
    \ = x.toString\n        val shiftString = shift.toString\n        val left = xString.substring(0,\
    \ shiftString.toInt)\n        val right = xString.substring(shiftString.toInt,\
    \ xLength)\n        xString = right + left\n        return xString", "      val\
    \ n = x.toString().length()\n      if (shift >= n) return x.toString().reverse\n\
    \      val first = x.toString().substring(0, n - shift.toInt)\n      val second\
    \ = x.toString().substring(n - shift.toInt, n)\n      second + first", "     \
    \   if (shift == 0) return x.toString\n        val str = x.toString\n        val\
    \ len = str.length\n        if (shift >= len) return str.reverse\n        str.substring(len\
    \ - shift.toInt) + str.substring(0, len - shift.toInt)", "        var k = shift\n\
    \        var b = x.toString.toList\n        while (k > 0) {\n            val temp\
    \ = b.remove(0)\n            b = b :+ temp\n            k -= 1\n        }\n  \
    \      b.reverse.mkString", "        val s = x.toString\n        val l = s.length\n\
    \        if (shift > l) s.reverse\n        else s.substring(l - shift.toInt) +\
    \ s.substring(0, l - shift.toInt)", "        val numDigits = x.toString.length\n\
    \        val newDigits = x.toString.substring(numDigits - shift.toInt, numDigits)\
    \ + x.toString.substring(0, numDigits - shift.toInt)\n        newDigits", "  \
    \      val length = x.toString.length\n        if (shift > length) {\n       \
    \     x.toString.reverse\n        } else {\n            x.toString.substring(length\
    \ - shift.toInt) + x.toString.substring(0, length - shift.toInt)\n        }",
  "        val s = x.toString\n        val shiftMod = shift % s.length\n        if\
    \ (shiftMod == 0) s\n        else if (shiftMod > 0) s.substring(s.length - shiftMod)\
    \ + s.substring(0, s.length - shiftMod)\n        else s.substring(-shiftMod) +\
    \ s.substring(0, -shiftMod)", "        val s = x.toString\n        val n = s.length\n\
    \        (s.substring(n - shift.toInt, n) + s.substring(0, n - shift.toInt)).reverse",
  "        if (shift == 0) {\n            return x.toString\n        }\n        val\
    \ s = x.toString\n        val t = s.reverse\n        val u = t.substring(0, (t.length\
    \ - shift.toInt).max(0))\n        val v = t.substring((t.length - shift.toInt).max(0))\n\
    \        return (v + u).reverse", "        val s = x.toString\n        if (shift\
    \ >= s.length) {\n            s.reverse\n        } else {\n            s.drop(shift.toInt)\
    \ + s.take(shift.toInt)\n        }", "        val s = x.toString\n        if (shift\
    \ > s.length) return s.reverse\n        else return s.slice(s.length - shift.toInt,\
    \ s.length) + s.slice(0, s.length - shift.toInt)", "        if (shift > x.toString.length)\
    \ return x.toString.reverse\n        val digit = x.toString.reverse.substring(0,\
    \ shift.toInt)\n        val rest = x.toString.reverse.substring(shift.toInt)\n\
    \        return digit + rest", "        val xstr = x.toString\n        if (shift\
    \ < xstr.length) xstr.substring(xstr.length - shift.toInt) + xstr.substring(0,\
    \ xstr.length - shift.toInt)\n        else xstr.reverse", "        if (shift ==\
    \ 0) return x.toString\n        var s = x.toString\n        if (shift < s.length)\
    \ {\n            val temp = s.substring(0, s.length - shift.toInt)\n         \
    \   s = s.substring(s.length - shift.toInt) + temp\n        }\n        else {\n\
    \            s = s.reverse\n        }\n        s", "        val str = x.toString\n\
    \        val len = str.length\n        val shiftLen = shift % len\n        if\
    \ (shiftLen == 0) str\n        else str.drop(len - shiftLen) + str.take(len -\
    \ shiftLen)", "        var digits = (x.toString).map(y => y).toList\n        if\
    \ (shift < digits.length) {\n            val (end, front) = digits.splitAt(digits.length\
    \ - shift.toInt)\n            (front ++ end).mkString\n        } else (digits.reverse).mkString",
  "        if (shift > x.toString.length)\n            return x.toString.reverse\n\
    \        x.toString.substring(shift.toInt) + x.toString.substring(0, shift.toInt)",
  "      val s = x.toString\n      if (shift > s.length) return s.reverse\n      val\
    \ (left, right) = s.splitAt(s.length - shift.toInt)\n      right + left", "  \
    \      if (shift == 0) return x.toString\n        var s = x.toString\n       \
    \ val digitCount = s.length\n        if (shift > digitCount) return s.reverse\n\
    \        val y = s.substring(digitCount - shift.toInt, digitCount) + s.substring(0,\
    \ digitCount - shift.toInt)\n        y", "        var str = x.toString\n     \
    \   var i = 0\n        while (i < shift) {\n            val temp = str.last\n\
    \            str = temp + str.substring(0, str.length - 1)\n            i += 1\n\
    \        }\n        str", "        val s = x.toString\n        if (shift >= s.length)\
    \ {\n            val r = new StringBuilder\n            for (i <- s.length - 1\
    \ to 0 by -1) {\n                r.append(s(i))\n            }\n            r.toString\n\
    \        } else {\n            val r = new StringBuilder\n            for (i <-\
    \ shift to s.length - 1) {\n                r.append(s(i))\n            }\n  \
    \          for (i <- 0 to shift - 1) {\n                r.append(s(i))\n     \
    \       }\n            r.toString\n        }", "        val digits = x.toString.toList\n\
    \        val len = digits.length\n        val result = (1 to len).map(i => digits((i\
    \ - 1 + shift) % len))\n        result.mkString", "        val digits = String.valueOf(x).map(_.asDigit).toList\n\
    \        val reversed = digits.reverse\n        val shiftMod = (shift % digits.length).toInt\n\
    \        if (shiftMod > 0) {\n            val prefix = reversed.take(shiftMod)\n\
    \            val suffix = reversed.drop(shiftMod)\n            (suffix ::: prefix).mkString\n\
    \        } else {\n            digits.mkString\n        }", "        if (shift\
    \ > x.toString.length) return x.toString.reverse\n        val s = x.toString\n\
    \        return s.substring(s.length - shift.toInt) + s.substring(0, s.length\
    \ - shift.toInt)", "        // First get the number of digits of x\n        var\
    \ x2 = x\n        var n = 0\n        while (x2 > 0) {\n            x2 /= 10\n\
    \            n += 1\n        }\n        // Reverse digits of x\n        var x3\
    \ = 0l\n        for (i <- 1 to n) {\n            x3 = x3 * 10 + x % 10\n     \
    \       x /= 10\n        }\n        // Now do the circular shift\n        var\
    \ x4 = 0l\n        for (i <- 1 to n) {\n            x4 = x4 * 10 + x3 % 10\n \
    \           x3 /= 10\n            shift -= 1\n            if (shift == 0) return\
    \ x4.toString\n        }\n        // If we get here, the shift was greater than\
    \ number of digits.\n        // Just return the reverse\n        x4.toString",
  "        val digits = x.toString\n        if (shift > digits.length) digits.reverse\n\
    \        else digits.substring(digits.length - shift.toInt) + digits.substring(0,\
    \ digits.length - shift.toInt)", "        if (shift >= x.toString.length)\n  \
    \          return x.toString.reverse\n        else\n            return x.toString.substring(shift.toInt)\
    \ + x.toString.substring(0, shift.toInt)", "        if (shift == 0) x.toString\n\
    \        else if (shift > x.toString.length) {\n            val reverse = x.toString.reverse\n\
    \            val head = reverse.take(shift.toInt % reverse.length)\n         \
    \   val tail = reverse.takeRight(reverse.length - head.length)\n            (head\
    \ + tail).reverse\n        }\n        else {\n            val head = x.toString.takeRight(shift.toInt)\n\
    \            val tail = x.toString.take(x.toString.length - head.length)\n   \
    \         head + tail\n        }", "        val s = x.toString\n        if (shift\
    \ > s.length)\n            return s.reverse\n        else\n            return\
    \ s.substring(shift.toInt) + s.substring(0, shift.toInt)", "        val s = x.toString\n\
    \        val len = s.length\n        if (shift > len) s.reverse\n        else\
    \ s.drop(len - shift.toInt) + s.take(len - shift.toInt)", "        if (shift >\
    \ x.toString.length) x.toString.reverse\n        else x.toString.substring(x.toString.length\
    \ - shift.toInt) + x.toString.substring(0, x.toString.length - shift.toInt)",
  "        val s = x.toString\n        val n = s.length\n        val (a, b) = s.splitAt(if\
    \ (shift < n) (n - shift).toInt else 0)\n        b + a", "        val r = (x %\
    \ 10l)\n        if (x < 10l) {\n            // r is last digit\n            r.toString\n\
    \        } else {\n            // (10l ** (shift % x.toString.length))\n     \
    \       (circularShift(x / 10l, shift) + r.toString).substring(0, x.toString.length)\n\
    \        }", "        var d = x.toString.size\n        var str = x.toString\n\
    \        var l = List[Char]()\n        if (shift == d) {\n            return str.reverse\n\
    \        }\n        else if (shift > d) {\n            return str.reverse\n  \
    \      }\n        else {\n            for (i <- 0 until d) {\n               \
    \ l = str((i + shift) % d) :: l\n            }\n            return l.mkString(\"\
    \")\n        }", "        if (shift > (x + \"\").length) ((x + \"\").reverse)\n\
    \        else {\n            var s = x + \"\"\n            (s.substring(s.length\
    \ - shift.toInt, s.length) + s.substring(0, s.length - shift.toInt))\n       \
    \ }", "        val digits = x.toString.toList\n        val len = digits.length\n\
    \        val newList = ListBuffer.empty[Char]\n        for (i <- 0 until len)\
    \ {\n            val index = (i + shift) % len\n            newList += digits(index)\n\
    \        }\n        newList.mkString", "        val digits = x.toString\n    \
    \    if (shift > digits.length) {\n            digits.reverse\n        } else\
    \ {\n            digits.substring(digits.length - shift.toInt) + digits.substring(0,\
    \ digits.length - shift.toInt)\n        }", "        var str = (x.toString.toList)\n\
    \        var shiftStart = str.length - shift.toInt\n        var list1 = str.slice(shiftStart,\
    \ str.length)\n        var list2 = str.slice(0, shiftStart)\n        return (list1\
    \ ::: list2).reverse.mkString", "        val s = x.toString\n        if (shift\
    \ > s.length) s.reverse\n        else (s.substring(s.length - shift.toInt) + s.substring(0,\
    \ s.length - shift.toInt))", "        if (shift > x.toString.length) return x.toString.reverse\n\
    \        val reversed = x.toString.reverse\n        (reversed.drop(shift.toInt)\
    \ + reversed.take(shift.toInt)).reverse", "        if (shift > log10(x).toLong\
    \ + 1) x.toString.reverse\n        else {\n            val (h, t) = (x / pow(10,\
    \ shift).toLong, x % pow(10, shift).toLong)\n            (t.toString + h.toString).reverse\n\
    \        }", "        val s = x.toString\n        val length = s.length\n    \
    \    if (shift >= length)\n            s.reverse\n        else\n            s.drop(length\
    \ - shift.toInt) + s.take(length - shift.toInt)", "        val digits = x.toString.length\n\
    \        val (r1, r2) = x.toString.splitAt(digits - (shift % digits).toInt)\n\
    \        (r2 + r1).reverse", "        val str = x.toString\n        if (shift\
    \ >= str.length) str.reverse\n        else str.substring(str.length - shift.toInt)\
    \ + str.substring(0, str.length - shift.toInt)", "        var xString = x.toString\n\
    \        if (shift >= xString.length) {\n            return xString.reverse\n\
    \        }\n        var yString = xString.substring(0, xString.length - shift.toInt)\n\
    \        xString = xString.substring(xString.length - shift.toInt)\n        return\
    \ xString + yString", '        x.toString.substring(x.toString.length - shift.toInt,
    x.toString.length) + x.toString.substring(0, x.toString.length - shift.toInt)',
  "      if (shift > x.toString.length)\n        return x.toString.reverse\n     \
    \ else {\n        val s = (x.toString.takeRight(shift.toInt) + x.toString.dropRight(shift.toInt))\n\
    \        s\n      }", "        val digit = x.toString.map(_.asDigit)\n       \
    \ if (shift > digit.length) digit.reverse.mkString\n        else digit.reverse.drop(shift.toInt).reverse.mkString\
    \ + digit.reverse.take(shift.toInt).reverse.mkString", "        val s = x.toString\n\
    \        val n = s.length\n        val shiftMod = shift % n\n        if (shiftMod\
    \ == 0) {\n            return s\n        }\n        else if (shiftMod < n - shiftMod)\
    \ {\n            return s.substring(shiftMod) + s.substring(0, shiftMod)\n   \
    \     }\n        else {\n            return s.substring(n - shiftMod) + s.substring(0,\
    \ n - shiftMod)\n        }", "        val digits = x.toString\n        val n =\
    \ digits.length\n        if (shift >= n) digits.reverse\n        else digits.takeRight(shift.toInt)\
    \ + digits.dropRight(shift.toInt)", "        val digits = new ArrayBuffer[Long]\n\
    \        var y = x\n        while (y > 0) {\n            digits += y % 10\n  \
    \          y /= 10\n        }\n        if (shift > digits.length) return digits.reverse.mkString\n\
    \        digits.rotateRight(shift.toInt)\n        return digits.mkString", " \
    \       val digits = x.toString.length\n        val shift2 = shift % digits\n\
    \        if (shift2 == 0) {\n            x.toString\n        } else {\n      \
    \      ((x / pow(10, shift2)).toLong.toString + (x % pow(10, shift2)).toLong.toString.reverse).reverse\n\
    \        }", "        val a = x.toString\n        if (shift > a.length) a.reverse\n\
    \        else a.substring(a.length - shift.toInt) + a.substring(0, a.length -\
    \ shift.toInt)", "      var n = x\n      var digits = new ListBuffer[Long]()\n\
    \      while (n > 0) {\n        digits += n % 10\n        n /= 10\n      }\n \
    \     if (shift > digits.length) {\n        return digits.reverse.mkString\n \
    \     }\n      for (i <- 0l until shift) {\n        digits.prepend(digits.last)\n\
    \        digits.remove(digits.length - 1)\n      }\n      digits.mkString", " \
    \       var temp = x\n        for (i <- 0 until shift) {\n            var digit\
    \ = temp % 10\n            temp /= 10\n            temp += digit * pow(10, floor(log10(x)).toInt).toLong\n\
    \        }\n        return temp.toString", "        var s = x.toString\n     \
    \   var i = shift % s.length\n        s = s.substring(i) + s.substring(0, i)\n\
    \        s", "        if (shift == 0) return x.toString\n        val xStr = x.toString\n\
    \        val shiftMod = shift % xStr.length\n        if (shiftMod == 0) return\
    \ xStr\n        return xStr.substring(xStr.length - shiftMod) + xStr.substring(0,\
    \ xStr.length - shiftMod)", "        var t = x\n        var digits = 0\n     \
    \   while (t > 0) {\n            t /= 10\n            digits += 1\n        }\n\
    \        if (shift > digits) return x.toString.reverse\n        var l = x % (pow(10,\
    \ shift).toLong)\n        var r = x / (pow(10, shift).toLong)\n        l + (r\
    \ * pow(10, digits - shift)).toLong", "      val str = (if (shift > x.toString.length)\
    \ x.toString.reverse else x.toString.substring(shift.toInt) + x.toString.substring(0,\
    \ shift.toInt))\n      println(str)\n      str", "      if (shift == 0) {\n  \
    \      return x.toString\n      }\n      var arr = x.toString.toCharArray\n  \
    \    var t1 = arr.take(arr.length - shift.toInt)\n      var t2 = arr.drop(arr.length\
    \ - shift.toInt)\n      (t2 ++ t1).mkString", "        val y = x.toString\n  \
    \      val n = y.length\n        val s = shift.toInt\n        if (s >= n) y.reverse\n\
    \        else {\n            val t = y.substring(s, n) + y.substring(0, s)\n \
    \           val m = t.toLong\n            m.toString\n        }", "        var\
    \ xString = x.toString()\n        var answer = xString.substring(xString.length\
    \ - shift.toInt, xString.length) + xString.substring(0, xString.length - shift.toInt)\n\
    \        return answer", "        val digits = x.toString.map(_.asDigit)\n   \
    \     (shift to digits.length).foldLeft(digits)((digits, i) => digits(i - 1) ::\
    \ digits.take(i - 1) ::: digits.drop(i))\n      .mkString", "      val n = x.toString.length\n\
    \      val s = if (shift >= n) {\n          x.toString.reverse\n      } else {\n\
    \          val (a, b) = x.toString.splitAt(n - shift.toInt)\n          b + a\n\
    \      }\n      s", "        if (shift == 0) return x.toString\n        var y\
    \ = x\n        val k = y.toString.length\n        val r = shift % k\n        if\
    \ (r > 0) {\n            var t = y % (pow(10, r).toLong)\n            y = y /\
    \ (pow(10, r).toLong)\n            y = t * (pow(10, k - r).toLong) + y\n     \
    \   }\n        y.toString", "        val d = x.toString.length - shift.toString.length\n\
    \        if (d > 0) {\n            return x.toString.drop(d) + x.toString.take(d)\n\
    \        } else {\n            return x.toString.reverse\n        }", "      \
    \  val digits = x.toString.length\n        if (shift >= digits) {\n          \
    \  x.toString.reverse\n        } else {\n            (x.toString.substring(digits\
    \ - shift.toInt) + x.toString.substring(0, digits - shift.toInt))\n        }",
  "        val str = x.toString\n        val n = str.length\n        val s = str.substring(n\
    \ - shift.toInt, n) + str.substring(0, n - shift.toInt)\n        if (shift > n)\
    \ str.reverse else s", "        val s = x.toString\n        val n = s.length\n\
    \        val j = if (shift > n) n - shift % n else shift\n        s.substring(j)\
    \ + s.substring(0, j)", "        if (shift == 0) return x.toString\n        else\
    \ if (shift >= x.toString.length) return x.toString.reverse\n        else return\
    \ x.toString.substring(shift.toInt) + x.toString.substring(0, shift.toInt)", " \
    \       var digits = x.toString.toCharArray\n        var r = digits.length - shift.toInt\n\
    \        var result = digits.slice(r, digits.length) ++ digits.slice(0, r)\n \
    \       return result.mkString", "      val digits = x.toString.toArray\n    \
    \  val n = digits.length\n      val shiftMod = shift % n\n      val m = min(shiftMod,\
    \ n - shiftMod)\n      val left = if (shiftMod <= 0) digits else digits.slice(shiftMod,\
    \ n)\n      val right = if (shiftMod <= 0) digits.slice(0, n + shiftMod) else\
    \ digits.slice(0, shiftMod)\n      new String(left ++ right)", "        var xstr\
    \ = x.toString\n        if (shift >= xstr.length) return xstr.reverse\n      \
    \  return xstr.substring(shift.toInt) + xstr.substring(0, shift.toInt)", "   \
    \     var p = x.toString.reverse.toCharArray\n        val k = p.length\n     \
    \   // shift = 0..k\n        var y = new Array[Char](k)\n        if (shift ==\
    \ 0) return x.toString\n        if (shift > k) return new String(p)\n        var\
    \ q = 0\n        while (q < k) {\n            y(q) = p((q + shift) % k)\n    \
    \        q += 1\n        }\n        new String(y)", "        val s = x.toString\n\
    \        if (shift >= s.length) s.reverse\n        else (s.drop(shift.toInt) +\
    \ s.take(shift.toInt)).reverse", "        val digits = x.toString\n        val\
    \ numDigits = digits.length\n        if (shift >= numDigits) digits.reverse\n\
    \        else digits.substring(numDigits - shift.toInt) + digits.substring(0,\
    \ numDigits - shift.toInt)", "        var result = x.toString\n        if (result.length\
    \ > shift) {\n            result = result.substring(result.length - shift.toInt)\
    \ + result.substring(0, result.length - shift.toInt)\n        } else {\n     \
    \       result = result.reverse\n        }\n        return result", "        var\
    \ remainder = x\n        var size = 0\n        while (remainder > 0) {\n     \
    \       remainder /= 10\n            size += 1\n        }\n        if (shift ==\
    \ size) return (x.toString)\n        var digit = remainder = x\n        var i\
    \ = 0\n        while (i < shift) {\n            digit = remainder % 10\n     \
    \       remainder /= 10\n            i += 1\n        }\n        (remainder.toString\
    \ + digit.toString)", "        def f(x : Long, shift : Long, d : Int) : Long =\
    \ {\n            if (d < shift) {\n                val lastDigit = x % 10\n  \
    \              val rest = x / 10\n                f(rest + lastDigit * pow(10,\
    \ (d + 1)).toLong, shift, d + 1)\n            } else x\n        }\n        def\
    \ g(x : Long, d : Int) : String = {\n            if (d > 0) g(x / 10, d - 1) +\
    \ (x % 10).toString\n            else \"\"\n        }\n        g(f(x, shift, 0),\
    \ x.toString.length - shift.toString.length)", "        if (shift > x.toString.length)\
    \ {\n            x.toString.reverse\n        } else {\n            x.toString.substring(x.toString.length\
    \ - shift.toInt) + x.toString.substring(0, x.toString.length - shift.toInt)\n\
    \        }", "      val xStr = x.toString\n      val strLen = xStr.length\n  \
    \    if (shift >= strLen) {\n        return xStr.reverse\n      }\n      else\
    \ {\n        return xStr.substring(shift.toInt) + xStr.substring(0, shift.toInt)\n\
    \      }", "        if (shift >= log10(x).toLong + 1) return x.toString.reverse\n\
    \        else {\n            val s = x.toString\n            return s.substring(s.length\
    \ - shift.toInt) + s.substring(0, s.length - shift.toInt)\n        }", "     \
    \   val xs = x.toString\n        if (shift > xs.length) (xs.reverse)\n       \
    \ else {\n            val s = xs.substring(0, (xs.length - shift).toInt)\n   \
    \         val e = xs.substring((xs.length - shift).toInt)\n            (e + s)\n\
    \        }", "        if (shift == 0) x.toString\n        else {\n           \
    \ val n = x.toString.length\n            if (shift >= n) x.toString.reverse\n\
    \            else {\n                val y = x.toString.substring(n - shift.toInt)\
    \ + x.toString.substring(0, n - shift.toInt)\n                y\n            }\n\
    \        }", "        if (shift >= x.toString.length) (x.toString.reverse)\n \
    \       else {\n            val s = x.toString\n            s.substring(s.length\
    \ - shift.toInt) + s.substring(0, s.length - shift.toInt)\n        }", "     \
    \ val numOfDigits = floor(log10(x)).toInt + 1\n      if (shift == numOfDigits)\
    \ {\n        val temp = x.toString\n        temp.reverse\n      }\n      else\
    \ {\n        val temp = x.toString\n        (temp.substring(temp.length - shift.toInt)\
    \ + temp.substring(0, temp.length - shift.toInt))\n      }", "        val s =\
    \ x.toString\n        val n = s.length\n        val r = x.toString.reverse\n \
    \       if (shift >= n) {\n            return r\n        }\n        return r.substring(0,\
    \ n - shift.toInt) + r.substring(n - shift.toInt, n)", "        val n = x.toString.length\n\
    \        if (shift == n) return new StringBuffer(x.toString).reverse.toString\n\
    \        if (shift > n) return circularShift(x, shift % n)\n        new StringBuffer(x.toString.substring(shift.toInt)\
    \ + x.toString.substring(0, shift.toInt)).toString", "        def circularShift(x\
    \ : Long, shift : Long, size : Long) : String = {\n            if (shift == 0)\
    \ x.toString\n            else if (shift > size) (x / pow(10, shift - size).toLong).toString.reverse\n\
    \            else ((x % pow(10, size - shift).toLong) * pow(10, shift).toLong\
    \ + (x / pow(10, size - shift).toLong)).toString\n        }\n        circularShift(x,\
    \ shift, x.toString.size)", "        val d = x.toString.length\n        val k\
    \ = if (shift > d) d else shift\n        val s = x.toString\n        s.drop(d\
    \ - k) + s.take(d - k)", "    \tval digits = x.toString.toList\n    \tif (shift\
    \ >= digits.length) digits.reverse.mkString\n    \telse {\n    \t\tval (first,\
    \ second) = digits.splitAt(digits.length - shift.toInt)\n    \t\t(second ++ first).mkString\n\
    \    \t}", "        if (shift == 0) return x.toString()\n        var digits =\
    \ x.toString().toList\n        if (shift >= digits.length) return digits.reverse.mkString\n\
    \        var k = 0\n        var temp = digits(0)\n        while (k < shift) {\n\
    \            var j = 0\n            while (j < digits.length - 1) {\n        \
    \        var t = digits(j)\n                digits(j) = digits(j + 1)\n      \
    \          digits(j + 1) = t\n                j += 1\n            }\n        \
    \    digits(digits.length - 1) = temp\n            k += 1\n        }\n       \
    \ return digits.mkString", "        val digits = x.toString.toList\n        val\
    \ n = digits.length\n        val shiftDigits = if (shift > n) n else shift.toInt\n\
    \        (digits.takeRight(shiftDigits) ::: digits.dropRight(shiftDigits)).mkString",
  "        val list : ArrayBuffer[Int] = x.toString.map(_.asDigit).toBuffer\n    \
    \    val len = list.length\n        val (a, b) = list.splitAt(if (shift > len)\
    \ len - 1 else len - shift.toInt)\n        (b ++ a).mkString", "        val s\
    \ = x.toString\n        val len = s.length\n        val s2 = new StringBuilder\n\
    \        for (i <- (0l until len)) s2.append(s((i + shift) % len))\n        return\
    \ s2.toString", "        val n = (x.toString).length\n        val s = x.toString\n\
    \        if (shift > n) {\n            (s.substring(n - 1, n) + s.substring(0,\
    \ n - 1)).toString\n        } else {\n            (s.substring(n - shift.toInt,\
    \ n) + s.substring(0, n - shift.toInt)).toString\n        }", "        if (shift\
    \ < 1) {\n            return x.toString\n        }\n        val digs = new StringBuilder\n\
    \        var x1 = x\n        while (x1 > 0) {\n            digs.append(x1 % 10)\n\
    \            x1 /= 10\n        }\n        digs.reverse\n        val a = digs.toString.toCharArray\n\
    \        val n = a.length\n        val a2 = new Array[Char](n)\n        for (i\
    \ <- 0 until n) {\n            a2(i) = a((i + shift) % n)\n        }\n       \
    \ new String(a2)", "        val digits = x.toString.map(_.asDigit)\n        if\
    \ (shift > digits.length) {\n            digits.reverse.mkString\n        } else\
    \ {\n            val split = digits.splitAt(digits.length - shift.toInt)\n   \
    \         (split._2 ++ split._1).mkString\n        }", "        if (shift == 0)\
    \ return x.toString\n        val digits = x.toString.length\n        if (shift\
    \ > digits) return x.toString.reverse\n        val endDigits = x.toString.slice(0,\
    \ shift.toInt)\n        val beginDigits = x.toString.slice(shift.toInt, digits)\n\
    \        beginDigits + endDigits", "        val digits = x.toString.toList\n \
    \       val shift1 = shift % digits.length\n        if (shift1 == 0) digits.mkString(\"\
    \")\n        else if (shift1 > digits.length) digits.reverse.mkString(\"\")\n\
    \        else {\n            val (l1, l2) = digits.splitAt(digits.length - shift1)\n\
    \            (l2 ::: l1).mkString(\"\")\n        }", "        var s = x.toString\n\
    \        if (shift > s.length) {\n            s = s.reverse\n        } else {\n\
    \            s = s.substring(s.length - shift.toInt) + s.substring(0, s.length\
    \ - shift.toInt)\n        }\n        s", "        val s = x.toString\n       \
    \ val len = s.length\n        val (n1, n2) = s.splitAt(len - (shift % len).toInt)\n\
    \        n2 + n1", "        val s = x.toString\n        val l = s.length\n   \
    \     if (shift >= l) {\n            s.reverse\n        } else {\n           \
    \ val u = shift.toInt\n            val a = s.substring(u, l)\n            val\
    \ b = s.substring(0, u)\n            (a + b)\n        }", "        val shiftNew\
    \ = if (shift > x.toString.length) x.toString.length - 1 else shift\n        val\
    \ right = x.toString.substring(x.toString.length - shiftNew, x.toString.length)\n\
    \        val left = x.toString.substring(0, x.toString.length - shiftNew)\n  \
    \      (right + left)", "        var s = x.toString.reverse\n        var digits\
    \ = s.length\n        if (shift < digits) s = s.substring(0, (digits - shift).toInt)\
    \ + s.substring((digits - shift).toInt)\n        s.reverse", "        val num\
    \ = x.toString\n        val size = num.size\n        var xs = num.toList\n   \
    \     for (i <- 1 to shift.toInt) {\n            xs = xs.tail :+ xs.head\n   \
    \     }\n        xs.mkString", "        val digits = x.toString.length\n     \
    \   if (shift > digits)\n            return x.toString.reverse\n        return\
    \ x.toString.substring(digits - shift.toInt) + x.toString.substring(0, digits\
    \ - shift.toInt)", "        // The approach here is to convert x to a string,\
    \ and then to reverse it and\n        // take the appropriate substrings of it.\n\
    \        // O(n) where n is the number of digits in x\n        val str = x.toString()\n\
    \        val len = str.length\n        // Note that if shift > len, we simply\
    \ revert to reversing the string\n        val start = if (shift < len) len - shift\
    \ else 0\n        val rev = str.reverse\n        val (a, b) = rev.splitAt(start)\n\
    \        return (b + a).reverse", "        val strX = x.toString\n        val\
    \ digits = strX.length\n        val shiftBuf = shift % digits\n        if (shiftBuf\
    \ == 0) strX\n        else {\n            val head = strX.substring(digits - shiftBuf)\n\
    \            val tail = strX.substring(0, digits - shiftBuf)\n            head\
    \ + tail\n        }", "        if (shift > x.toString.length) {\n            return\
    \ (x.toString.reverse)\n        }\n        var s = x.toString\n        var right\
    \ = s.substring(0, s.length - shift.toInt)\n        var left = s.substring(s.length\
    \ - shift.toInt, s.length)\n        return (left + right)", "        val n = x.toString.length\n\
    \        if (shift >= n) (x.toString).reverse\n        else {\n            val\
    \ y = x.toString\n            y.drop(shift.toInt) + y.take(shift.toInt)\n    \
    \    }", "      val s = x.toString\n      if (shift > s.length) return s.reverse\n\
    \      else return s.substring(s.length - shift.toInt) + s.substring(0, s.length\
    \ - shift.toInt)", "        val s = x.toString\n        if (shift < s.length)\
    \ (s.substring(shift.toInt) + s.substring(0, shift.toInt))\n        else (s.reverse)",
  "        var s = x.toString\n        if (shift >= s.length) {\n            s = s.reverse\n\
    \        } else {\n            s = s.substring(s.length - shift.toInt) + s.substring(0,\
    \ s.length - shift.toInt)\n        }\n        s", "        def circularShiftRec(x\
    \ : Long, shift : Long, acc : String) : String = {\n            if (x == 0) acc\n\
    \            else {\n                val digit = x % 10\n                val newX\
    \ = (x - digit) / 10\n                val newShift = shift - 1\n             \
    \   if (newShift == 0) circularShiftRec(newX, newShift, digit + acc)\n       \
    \         else circularShiftRec(newX, newShift, acc + digit)\n            }\n\
    \        }\n        def reverse(x : Long) : String = {\n            def reverseRec(x\
    \ : Long, acc : String) : String = {\n                if (x == 0) acc\n      \
    \          else {\n                    val digit = x % 10\n                  \
    \  val newX = (x - digit) / 10\n                    reverseRec(newX, digit + acc)\n\
    \                }\n            }\n            reverseRec(x, \"\")\n        }\n\
    \        val len = x.toString.length\n        if (shift > len) reverse(x)\n  \
    \      else circularShiftRec(x, shift, \"\")", "        val n = math.pow(10, (math.log10(x).toInt\
    \ + 1)).toLong\n        val s = shift % n\n        val d = x / s\n        val\
    \ r = x % s\n        val rs = r.toString.reverse\n        (rs + d).toString",
  "        var s = x.toString\n        var sLen = s.length\n        var shiftMod =\
    \ shift % sLen\n        if (shiftMod == 0) {\n            return s\n        }\n\
    \        else {\n            return s.substring(sLen - shiftMod) + s.substring(0,\
    \ sLen - shiftMod)\n        }", "        if (shift == 0) return x.toString\n \
    \       val digitList = new ListBuffer[Int]\n        var a = x\n        while\
    \ (a > 0) {\n            digitList += (a % 10).toInt\n            a /= 10\n  \
    \      }\n        val shiftAmount = shift % digitList.length\n        for (i <-\
    \ 0 until shiftAmount) {\n            val temp = digitList(digitList.length -\
    \ 1)\n            digitList.remove(digitList.length - 1)\n            digitList.insert(0,\
    \ temp)\n        }\n        val sb = new StringBuilder\n        for (digit <-\
    \ digitList) sb.append(digit)\n        sb.toString", "        if (shift < 0) throw\
    \ new IllegalArgumentException(\"shift\")\n        val xDigits = x.toString.map(_.asDigit).toList\n\
    \        val numDigits = xDigits.length\n        val shiftMod = shift % numDigits\n\
    \        if (shiftMod == 0) {\n            x.toString\n        } else {\n    \
    \        val (a, b) = xDigits.splitAt(numDigits - shiftMod)\n            (b :::\
    \ a).mkString\n        }", "      val digits = x.toString.length\n      val s\
    \ = shift % digits\n      val r = (x.toString).drop(s.toInt) + (x.toString).take(s.toInt)\n\
    \      return r", "        val xs = x.toString\n        if (shift > xs.length)\
    \ xs.reverse\n        else xs.substring(xs.length - shift.toInt) + xs.substring(0,\
    \ xs.length - shift.toInt)", "        val numDigits = x.toString.length\n    \
    \    if (shift >= numDigits) {\n            // Just reverse\n            return\
    \ x.toString.reverse\n        }\n        val leftDigits = x.toString.substring(0,\
    \ numDigits - shift.toInt)\n        val rightDigits = x.toString.substring(numDigits\
    \ - shift.toInt, numDigits)\n        return rightDigits + leftDigits", "     \
    \   val s = x.toString\n        if (shift == 0) {\n            return s\n    \
    \    }\n        val numDigits = floor(log10(x)).toInt + 1\n        if (shift >=\
    \ numDigits) {\n            return s.reverse\n        }\n        val prefix =\
    \ s.substring(0, numDigits - shift.toInt)\n        val suffix = s.substring(numDigits\
    \ - shift.toInt)\n        return suffix + prefix", "      val len = (math.log10(x.toDouble)\
    \ + 1).toInt\n      if (shift >= len) (x.toString.reverse)\n      else {\n   \
    \     val (pre, post) = x.toString.splitAt(len - shift.toInt)\n        post +\
    \ pre\n      }", "        if (shift == 0) x.toString\n        else {\n       \
    \     val digits = x.toString.length\n            if (shift >= digits) x.toString.reverse\n\
    \            else {\n                val (a, b) = x.toString.splitAt(digits -\
    \ shift.toInt)\n                b + a\n            }\n        }", "        val\
    \ s = x.toString\n        val length = s.length\n        if (shift > length) s.reverse\n\
    \        else {\n            val shiftlen = s.substring(length - shift.toInt)\n\
    \            val shiftamount = s.substring(0, length - shift.toInt)\n        \
    \    shiftlen + shiftamount\n        }", "        val digits = math.ceil(math.log10(x)).toInt\n\
    \        if (shift >= digits)\n            return x.toString.reverse\n       \
    \ val strX = x.toString\n        val left = strX.slice(strX.length - shift.toInt,\
    \ strX.length)\n        val right = strX.slice(0, strX.length - shift.toInt)\n\
    \        return left + right", "        if (shift == 0)\n            x.toString\n\
    \        else if (shift > x.toString.length)\n            x.toString.reverse\n\
    \        else {\n            val a = x.toString.slice(0, x.toString.length - shift.toInt)\n\
    \            val b = x.toString.slice(x.toString.length - shift.toInt, x.toString.length)\n\
    \            b + a\n        }", "        var digits = x.toString.toList\n    \
    \    var result = \"\"\n        if (shift > digits.length) {\n            result\
    \ = digits.reverse.mkString\n        } else {\n            var left = digits.drop(shift.toInt)\n\
    \            var right = digits.take(shift.toInt)\n            result = (left\
    \ ::: right).mkString\n        }\n        return result", "        if (shift ==\
    \ 0) x.toString else {\n            val digits = x.toString.length\n         \
    \   val shift2 = if (shift > digits) digits else shift\n            val part1\
    \ = x.toString.substring(0, (digits - shift2))\n            val part2 = x.toString.substring((digits\
    \ - shift2), digits)\n            part2 + part1\n        }", "        var result\
    \ = x.toString\n        for (i <- 0 until shift) {\n            result = result.last\
    \ + result.slice(0, result.length - 1)\n        }\n        return result", " \
    \       val s = x.toString\n        if (shift == 0) s\n        else if (shift\
    \ > s.length) s.reverse\n        else s.slice(s.length - shift.toInt, s.length)\
    \ + s.slice(0, s.length - shift.toInt)", "        val s = x.toString\n       \
    \ val t = if (shift > s.length) (s.reverse) else (s.drop((shift % s.length).toInt)\
    \ + s.take((shift % s.length).toInt))\n        (t)", "    \tif (shift == 0) return\
    \ x.toString\n    \tval xStr = x.toString\n    \tval xLen = xStr.length\n    \t\
    if (shift > xLen) return xStr.reverse\n    \tval r = xStr.substring(0, (xLen -\
    \ shift).toInt)\n    \tval l = xStr.substring((xLen - shift).toInt, xLen.toInt)\n\
    \    \t(l + r)", "    \tval str = x.toString\n    \tval len = str.length\n   \
    \ \tval rotations = shift % len\n    \tif (rotations == 0) str\n    \telse str.substring(len\
    \ - rotations, len) + str.substring(0, len - rotations)", "        val str = x.toString\n\
    \        val n = str.length\n        if (shift > n) str.reverse\n        else\
    \ str.substring(n - shift.toInt) + str.substring(0, n - shift.toInt)", "     \
    \   def iter(x : Long, shift : Long, numberDigits : Long) : String = {\n     \
    \       if (shift > numberDigits) return x.toString.reverse\n            val i\
    \ = x / pow(10, numberDigits - shift).toLong\n            val d = x % pow(10,\
    \ numberDigits - shift).toLong\n            iter(d * pow(10, shift).toLong + i,\
    \ shift, numberDigits)\n        }\n        iter(x, shift, floor(log10(x)).toLong\
    \ + 1)", "        val s = x.toString()\n        val n = s.length\n        (s.substring(n\
    \ - shift.toInt, n) + s.substring(0, n - shift.toInt)).reverse", "        val\
    \ n = x.toString.length\n        if (shift == n) return x.toString.reverse\n \
    \       if (shift == 0) return x.toString\n        val ret = x.toString.reverse.substring(0,\
    \ shift.toInt) + x.toString.substring(0, n - shift.toInt)\n        return ret.reverse",
  "        val n = numberOfDigits(x)\n        val s = if (shift >= n) n else shift\n\
    \        val d = digits(x)\n        val c = d.slice(n - s, n) ++ d.slice(0, n\
    \ - s)\n        c.reverse.mkString", "        val str = x.toString\n        val\
    \ n = str.length\n        if (shift >= n) str.reverse\n        else {\n      \
    \      val (a, b) = str.splitAt(str.length - shift.toInt)\n            (b + a)\n\
    \        }", "        // Modulo, see http://stackoverflow.com/questions/386425/scala-what-is-the-modulus-function-for-long-integers\n\
    \        val count = x.toString.length\n        val mod = shift % count\n    \
    \    if (mod == 0) {\n            x.toString\n        } else {\n            val\
    \ result = (x.toString.substring(count - mod) + x.toString.substring(0, count\
    \ - mod))\n            result\n        }", "        if (shift == 0) x.toString\n\
    \        else {\n            val digits = x.toString.length\n            val shiftd\
    \ = if (shift > digits) shift % digits else shift\n            val shifted = if\
    \ (shiftd == digits) x else (x / pow(10, shiftd)).toLong\n            val left\
    \ = shifted % 10\n            val right = (shifted - left) / 10\n            (left.toString\
    \ + right.toString).reverse\n        }", "    \tval digits = x.toString.map(_.asDigit)\n\
    \    \tval size = digits.size\n    \tval shiftDigits = digits.slice(size - shift.toInt,\
    \ size)\n    \tval remainderDigits = digits.slice(0, size - shift.toInt)\n   \
    \ \treturn (shiftDigits ++ remainderDigits).mkString", "        if (shift >= x.toString.length)\
    \ return x.toString.reverse\n        val z = x.toString.dropRight(shift.toInt)\n\
    \        val y = x.toString.takeRight(shift.toInt)\n        y + z", "        val\
    \ length = x.toString.length\n        if (shift < length) {\n            val right\
    \ = x % pow(10, shift).toLong\n            (right.toString + x.toString.take((length\
    \ - shift).toInt)).toString\n        } else {\n            x.toString.reverse\n\
    \        }", "        var result = \"\"\n        if (shift == 0) {\n         \
    \   result = x.toString\n        } else {\n            var s = x.toString\n  \
    \          var n = s.length\n            if (shift < n) {\n                result\
    \ = s.substring(n - shift.toInt, n) + s.substring(0, n - shift.toInt)\n      \
    \      } else {\n                result = s.reverse\n            }\n        }\n\
    \        return result", "        val s = x.toString\n        val n = s.length\n\
    \        if (shift > n) s.reverse\n        else s.substring(n - shift.toInt) +\
    \ s.substring(0, n - shift.toInt)", "        if (shift > x.toString.length)\n\
    \            x.toString.reverse\n        else {\n            val y = x.toString\n\
    \            y.substring(shift) + y.substring(0, shift)\n        }", "      if\
    \ (shift > x.toString.length)\n        x.toString.reverse\n      else {\n    \
    \    val (a, b) = x.toString.splitAt(x.toString.length - shift.toInt)\n      \
    \  b + a\n      }", "        val s = x.toString\n        val n = s.length\n  \
    \      if (shift >= n) s.reverse\n        else s.substring(n - shift.toInt) +\
    \ s.substring(0, n - shift.toInt)", "        val s = x.toString\n        val k\
    \ = s.length\n        val t = if (shift > k) s.reverse else s.drop(shift.toInt)\
    \ + s.take(shift.toInt)\n        t", "        val chars = x.toString.toList\n\
    \        if (shift > chars.length) {\n            return chars.reverse.mkString\n\
    \        }\n        else {\n            return (chars.takeRight(shift.toInt) ++\
    \ chars.take(chars.length - shift.toInt)).mkString\n        }", "        val digits\
    \ = x.toString.toList\n        //println(\"digits: \" + digits)\n        val shiftList\
    \ = List.range(0, digits.length) map (x => (x + shift) % digits.length)\n    \
    \    //println(\"shiftList: \" + shiftList)\n        val shiftedDigits = (shiftList\
    \ map (x => digits(x))).mkString\n        //println(\"shiftedDigits: \" + shiftedDigits)\n\
    \        shiftedDigits", "        val d = log10(x).toInt + 1\n        val s =\
    \ if (shift > d) {\n            val ds = shift - d\n            val ret = new\
    \ StringBuilder(d)\n            for (i <- (0 until d)) {\n                ret(i)\
    \ = ('0' + x.toString()((i + ds) % d).toInt).toChar\n            }\n         \
    \   ret.toString()\n        } else {\n            val ret = new StringBuilder(d)\n\
    \            for (i <- (0 until d)) {\n                ret(i) = ('0' + x.toString()((i\
    \ + shift) % d).toInt).toChar\n            }\n            ret.toString()\n   \
    \     }\n        s", "        if (shift == 0) {\n            x.toString\n    \
    \    } else {\n            val numDigits = x.toString.length\n            val\
    \ shiftRight = if (shift >= numDigits) shift % numDigits else shift\n        \
    \    val shiftLeft = numDigits - shiftRight\n            val (left, right) = (x\
    \ / pow(10, shiftLeft), x % pow(10, shiftLeft))\n            (right.toLong * pow(10,\
    \ shiftRight).toLong + left).toString\n        }", "        val s = x.toString\n\
    \        val d = s.length\n        val n = if (shift < d) d - shift else shift\
    \ % d\n        s.takeRight(n) + s.dropRight(n)", "        // Find the number of\
    \ digits in the integer\n        var digits = 0\n        var num = x\n       \
    \ while (num > 0) {\n            digits += 1\n            num /= 10\n        }\n\
    \        // If shift is greater than the number of digits, return the reversed\
    \ digits of x\n        if (shift >= digits) return (x.toString.reverse)\n    \
    \    // Otherwise shift right by shift\n        return ((x % pow(10, shift)).toLong.toString\
    \ + (x / pow(10, shift)).toLong.toString)", "        val numString = x.toString\n\
    \        val numLen = numString.length\n        val shiftMod = shift % numLen\n\
    \        if (shiftMod == 0) return numString\n        if (shiftMod == numLen)\
    \ return numString.reverse\n        if (shiftMod < numLen / 2) {\n           \
    \ return numString.substring(shiftMod) + numString.substring(0, shiftMod)\n  \
    \      }\n        return numString.substring(numLen - shiftMod) + numString.substring(0,\
    \ numLen - shiftMod)", "        if (shift == 0) x.toString\n        else {\n \
    \           val digits = x.toString.map(digit => digit).toList\n            val\
    \ n = digits.length\n            val res = (digits.takeRight(shift.toInt) :::\
    \ digits.take(n - shift.toInt)).mkString\n            res\n        }", "     \
    \ if (shift == 0)\n        x.toString\n      else {\n        val numDigits = log10(x).toInt\
    \ + 1\n        val digits = x.toString.map(_.asDigit)\n        val shiftDigits\
    \ = digits.dropRight(shift.toInt % numDigits)\n        val shiftedDigits = digits.drop(shift.toInt\
    \ % numDigits) ++ shiftDigits\n        shiftedDigits.mkString\n      }", "   \
    \     val str = x.toString\n        if (shift >= str.length) str.reverse\n   \
    \     else str.substring(str.length - shift.toInt) + str.substring(0, str.length\
    \ - shift.toInt)", "        if (shift > x.toString.length) {\n            return\
    \ new StringBuilder(x.toString).reverse.toString\n        }\n        val n = x.toString.length\n\
    \        val y = x.toString.substring(n - shift.toInt) + x.toString.substring(0,\
    \ n - shift.toInt)\n        return y", "        if (shift == 0)\n            x.toString\n\
    \        else if (shift > x.toString.length)\n            x.toString.reverse\n\
    \        else\n            x.toString.dropRight(shift.toInt) + x.toString.takeRight(shift.toInt)",
  "        if (shift == 0) return (x + \"\")\n        val s = (x + \"\")\n       \
    \ if (shift > s.length) {\n            (s.reverse)\n        } else {\n       \
    \     s.substring(s.length - shift.toInt, s.length) + s.substring(0, s.length\
    \ - shift.toInt)\n        }", "      val digits = x.toString.toList\n      if\
    \ (shift >= digits.length) digits.reverse.mkString(\"\")\n      else {\n     \
    \   val (firstDigits, lastDigits) = digits.splitAt(digits.length - shift.toInt)\n\
    \        (lastDigits ++ firstDigits).mkString(\"\")\n      }", "        var result\
    \ = \"\"\n        var str = x.toString\n        var reversed = str.reverse\n \
    \       val d = min(shift, str.length)\n        var (left, right) = reversed.splitAt(d)\n\
    \        var s = left.reverse + right.reverse\n        s", "        val numDigits\
    \ = (1 + log10(x)).toInt\n        val shiftActual = if (shift >= numDigits) numDigits\
    \ - 1 else shift.toInt\n        val remainder = (x % (pow(10, shiftActual).toLong)).toInt\n\
    \        val rest = (x / (pow(10, shiftActual).toLong)).toInt\n        val result\
    \ = (remainder * pow(10, numDigits - shiftActual).toLong) + rest\n        result.toString",
  "        val length = x.toString.length\n        if (shift > length) {\n       \
    \     val s = x.toString.reverse\n            return s\n        }\n        val\
    \ s = x.toString\n        val right = s.substring(length - shift.toInt, length)\n\
    \        val left = s.substring(0, length - shift.toInt)\n        return right\
    \ + left", "        if (shift == 0) return x.toString\n        else {\n      \
    \      var result = \"\";\n            val length = x.toString.length;\n     \
    \       val start = length - (shift % length);\n            for (i <- start until\
    \ length) result += x.toString.charAt(i);\n            for (i <- 0 until start)\
    \ result += x.toString.charAt(i);\n            return result;\n        }", " \
    \       if (shift >= numDigits(x)) return numToStr(x).reverse\n        numToStr(x).substring(numDigits(x)\
    \ - shift.toInt) + numToStr(x).substring(0, numDigits(x) - shift.toInt)", "  \
    \      if (shift >= x.toString.length) {\n            val str = x.toString.reverse\n\
    \            if (str.charAt(0) == '0') {\n                str.drop(1)\n      \
    \      } else {\n                str\n            }\n        } else {\n      \
    \      val str = x.toString\n            val a = str.drop(str.length - shift.toInt)\n\
    \            val b = str.take(str.length - shift.toInt)\n            a + b\n \
    \       }", "        val n = x.toString.length\n        val s = shift % n\n  \
    \      val a = x.toString.takeRight(s)\n        val b = x.toString.dropRight(s)\n\
    \        val y = a + b\n        y", "        def circularShiftR(x : Long, shift\
    \ : Long, count : Long) : String = {\n            if (count == shift) x.toString\n\
    \            else circularShiftR((x % 10) * pow(10, count).toLong + x / 10, shift,\
    \ count + 1)\n        }\n        val digits = floor(log10(x)).toLong + 1\n   \
    \     val shiftDigits = if (shift >= digits) digits - 1 else shift\n        circularShiftR(x,\
    \ shiftDigits, 0)", "        val digits = x.toString.length\n        val shifted\
    \ = if (shift >= digits) {\n            x.toString.reverse\n        } else {\n\
    \            val end = x.toString.substring(0, shift.toInt)\n            val begin\
    \ = x.toString.substring(shift.toInt)\n            begin + end\n        }\n  \
    \      shifted", "        val digits = x.toString\n        val l = digits.length\n\
    \        val s = if (shift > l) l else (shift % l).toInt\n        if (s == 0)\
    \ digits else digits.drop(s) + digits.take(s)", "        var digits = (x.toString).map(x\
    \ => x.toString).toList\n        val size = digits.size\n        if (shift > size)\
    \ return reverse(digits)\n        else return (digits.drop(size - shift.toInt)\
    \ ::: digits.take(size - shift.toInt)).foldLeft(\"\")((x, y) => x + y)", "   \
    \     var len = x.toString.length\n        if (shift > len) return (x.toString.reverse)\n\
    \        x.toString.substring(shift.toInt, len) + x.toString.substring(0, shift.toInt)",
  "        val s = x.toString\n        if (shift == 0l) {\n            s\n       \
    \ } else if (shift > s.length) {\n            s.reverse\n        } else {\n  \
    \          (s.slice(s.length - shift.toInt, s.length) + s.slice(0, s.length -\
    \ shift.toInt))\n        }"]
stop_tokens:
- "\n    }\n"
