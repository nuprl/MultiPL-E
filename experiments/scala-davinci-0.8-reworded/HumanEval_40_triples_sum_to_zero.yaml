name: HumanEval_40_triples_sum_to_zero
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // triples_sum_to_zero takes a list of integers as an input.\n    // it returns\
  \ true if there are three distinct elements in the list that\n    // sum to zero,\
  \ and false otherwise.\n    // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong,\
  \ 5l.toLong, 0l.toLong)))\n    // (false)\n    // >>> triplesSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, -2l.toLong, 1l.toLong)))\n    // (true)\n    // >>> triplesSumToZero((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 7l.toLong)))\n    // (false)\n    // >>> triplesSumToZero((List[Long](2l.toLong,\
  \ 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong)))\n    // (true)\n   \
  \ // >>> triplesSumToZero((List[Long](1l.toLong)))\n    // (false)\n    def triplesSumToZero(l\
  \ : List[Long]) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, 5l.toLong, 0l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, 5l.toLong, -1l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, -2l.toLong, 1l.toLong))) == (true));\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 7l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong,\
  \ 2l.toLong, 5l.toLong, 7l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](2l.toLong,\
  \ 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong))) == (true));\n    assert(triplesSumToZero((List[Long](1l.toLong)))\
  \ == (false));\n    assert(triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong,\
  \ -100l.toLong))) == (false));\n    assert(triplesSumToZero((List[Long](100l.toLong,\
  \ 3l.toLong, 5l.toLong, -100l.toLong))) == (false));\n    }\n\n}\n"
completions: ["        val s = l.toSet\n        for (x <- s) {\n            for (y\
    \ <- s) {\n                if (x != y) {\n                    if (s.contains(-x\
    \ - y)) {\n                        return true\n                    }\n      \
    \          }\n            }\n        }\n        return false", "        // YOUR\
    \ IMPLEMENTATION HERE\n        var x = new Array[Int](l.length)\n        for (i\
    \ <- 0 until l.length) {\n            x(i) = (l(i)).toInt\n        }\n       \
    \ Arrays.sort(x)\n        for (i <- 0 until x.length - 2) {\n            if (triple_sum_to_zero(x,\
    \ i + 1, x.length - 1, x(i))) return true\n        }\n        return false", " \
    \       var zeros : Long = 0\n        var pos : Long = 0\n        var neg : Long\
    \ = 0\n        var i : Long = 0\n        while(i < l.length) {\n            if(l(i.toInt)\
    \ == 0) zeros += 1\n            else if(l(i.toInt) > 0) pos += 1\n           \
    \ else neg += 1\n            i += 1\n        }\n        return (pos != 0 && neg\
    \ != 0) || zeros >= 3", '        l.combinations(3).exists(x => x.sum == 0)', " \
    \       var table = HashMap[Long, Long]()\n        for (el <- l) {\n         \
    \   if (table.contains(el)) {\n                table.update(el, table(el) + 1)\n\
    \            } else {\n                table.update(el, 1)\n            }\n  \
    \      }\n        for (el <- l) {\n            for (el2 <- l) {\n            \
    \    val want = -(el + el2)\n                if (want == el || want == el2) {\n\
    \                    if (table(want) > 1) {\n                        return true\n\
    \                    }\n                } else {\n                    if (table.contains(want))\
    \ {\n                        return true\n                    }\n            \
    \    }\n            }\n        }\n        return false", "        // YOUR CODE\
    \ HERE\n        if (l.length < 3) return false\n        for (i <- 0 until l.length)\
    \ {\n            for (j <- i + 1 until l.length) {\n                for (k <-\
    \ j + 1 until l.length) {\n                    if (l(i) + l(j) + l(k) == 0) return\
    \ true\n                }\n            }\n        }\n        return false", " \
    \       l.sorted.foreach(println)\n        // println(l.sorted)\n        for (i\
    \ <- 0 until l.length - 2) {\n            var j = i + 1\n            var k = l.length\
    \ - 1\n            while (j < k) {\n                val sum = l(i) + l(j) + l(k)\n\
    \                if (sum == 0) {\n                    return true\n          \
    \      } else if (sum < 0) {\n                    j += 1\n                } else\
    \ {\n                    k -= 1\n                }\n            }\n        }\n\
    \        return false", '        l.sorted.combinations(3).toList.exists((a) =>
    (a(0) + a(1) + a(2) == 0l))', '        return (l.combinations(3).exists(x => x.sum
    == 0))', '        false', '        return (0l.toLong in l)', "        // your\
    \ code here.\n        //def sort(l : List[Long]) : List[Long] = l match {\n  \
    \      //    case head :: tail => {\n        //        val temp = sort(tail)\n\
    \        //        temp match {\n        //            case head2 :: tail2 =>\n\
    \        //                if (head < head2) head :: temp\n        //        \
    \        else head2 :: head :: tail2\n        //            case List() =>\n \
    \       //                List(head)\n        //        }\n        //    }\n \
    \       //    case List() =>\n        //        List()\n        //}\n        def\
    \ isExists(l : List[Long], target : Long) : Boolean = l match {\n            case\
    \ head :: tail =>\n                if (head == target) true\n                else\
    \ isExists(tail, target)\n            case List() =>\n                false\n\
    \        }\n        val sorted = l.sortWith((a, b) => a < b)\n        val ls :\
    \ List[Long] = l.distinct\n        val t = sorted.size\n        def go(i : Int,\
    \ j : Int, k : Int) : Boolean = {\n            if (i == t - 2) false\n       \
    \     else if (j == t - 1) go(i + 1, i + 2, i + 3)\n            else if (k ==\
    \ t) go(i, j + 1, j + 2)\n            else if (sorted(i) + sorted(j) + sorted(k)\
    \ == 0) true\n            else go(i, j, k + 1)\n        }\n        go(0, 1, 2)",
  "        val h = new HashMap[Long,Int]\n        for (i <- l) {\n            if (h.contains(i))\
    \ h(i) += 1\n            else h += (i -> 1)\n        }\n        for (i <- l) {\n\
    \            val m = -i\n            for (j <- l) {\n                val n = m\
    \ - j\n                if (h.contains(n) && (i != j || h(i) > 1) && (i != n ||\
    \ h(i) > 1) && (j != n || h(j) > 1)) {\n                    return true\n    \
    \            }\n            }\n        }\n        return false", "        def\
    \ helper(remaining : List[Long], seen : Set[Long]) : Boolean = remaining match\
    \ {\n            case Nil => false\n            case x :: xs => {\n          \
    \      val r = 0 - x\n                if (seen.contains(r)) return true\n    \
    \            val newSeen = seen + x\n                helper(xs, newSeen)\n   \
    \         }\n        }\n        helper(l, Set())", "        val h = new HashMap[Long,\
    \ Long]()\n        var soln = false\n        for (i <- l.indices) {\n        \
    \    if (h.contains(l(i))) {\n                h(l(i)) += 1\n            } else\
    \ {\n                h(l(i)) = 1\n            }\n        }\n        for (i <-\
    \ l.indices) {\n            for (j <- l.indices) {\n                if (i != j)\
    \ {\n                    if (h.contains(-(l(i) + l(j)))) {\n                 \
    \       soln = true\n                    }\n                }\n            }\n\
    \        }\n        return soln", "        var b : Boolean = false\n        var\
    \ t : List[Long] = l\n        var m = new HashMap[Long, Int]\n        while (t.length\
    \ > 0) {\n            var i : Long = t.head\n            if (m.contains(i)) {\n\
    \                m(i) = m(i) + 1\n            } else {\n                m(i) =\
    \ 1\n            }\n            t = t.tail\n        }\n        t = l\n       \
    \ while (t.length > 0) {\n            var i : Long = t.head\n            var k\
    \ : Long = -1 * i\n            if (m.contains(k)) {\n                if (i ==\
    \ 0 && m(k) > 1) {\n                    b = true\n                } else if (i\
    \ != 0) {\n                    b = true\n                }\n            }\n  \
    \          t = t.tail\n        }\n        b", '        return false', "      \
    \  if (l.length < 3) {\n            return false\n        }\n        val sl =\
    \ l.sortWith((a, b) => (a < b))\n        var it = sl.zipWithIndex\n        for\
    \ (x <- sl) {\n            it = it.dropWhile((a) => (a._2 == 0))\n           \
    \ var yit = it\n            for (y <- it) {\n                yit = yit.dropWhile((a)\
    \ => (a._2 == 0))\n                var zit = yit\n                for (z <- yit)\
    \ {\n                    if (x + y._1 + z._1 == 0) {\n                       \
    \ return true\n                    }\n                }\n            }\n     \
    \   }\n        return false", '        throw new UnsupportedOperationException',
  "        val m = l.sorted.toArray\n        for (i <- 0 until m.length - 2) {\n \
    \           var low = i + 1\n            var high = m.length - 1\n           \
    \ while (low < high) {\n                if (m(i) + m(low) + m(high) == 0) return\
    \ true\n                else if (m(i) + m(low) + m(high) < 0) low += 1\n     \
    \           else high -= 1\n            }\n        }\n        return false", " \
    \       l.length match {\n            case 0 => false\n            case 1 => false\n\
    \            case 2 => false\n            case 3 => l(0) + l(1) + l(2) == 0\n\
    \            case _ => l.permutations.toList.exists(x => x(0) + x(1) + x(2) ==\
    \ 0)\n        }", '        return false', '        return false', "        if\
    \ (l.length < 3) return false\n        var set = Set[Long]()\n        for (i <-\
    \ l) set += i\n        for (i <- set) for (j <- set - i) for (k <- set - i - j)\
    \ if (i + j + k == 0) return true\n        return false", "        def aux(l :\
    \ List[Long], s : HashSet[Long]) : Boolean = {\n            if (l.isEmpty) return\
    \ false\n            else {\n                if (s.contains(-l.head)) return true\n\
    \                else {\n                    var s2 = s\n                    for\
    \ (x <- s) s2 = s2 + x + l.head\n                    return aux(l.tail, s2)\n\
    \                }\n            }\n        }\n        return aux(l, HashSet())",
  "        val a : List[Long] = l.sorted\n        for (i <- 0 to a.length - 3) {\n\
    \            var j : Int = i + 1\n            var k : Int = a.length - 1\n   \
    \         while (j < k) {\n                val s : Long = a(i) + a(j) + a(k)\n\
    \                if (s < 0) {\n                    j += 1\n                } else\
    \ if (s > 0) {\n                    k -= 1\n                } else {\n       \
    \             return true\n                }\n            }\n        }\n     \
    \   return false", "        l.sorted\n        return (for (i <- 0 until l.length\
    \ - 2; j <- i + 1 until l.length - 1; k <- j + 1 until l.length) yield (l(i) +\
    \ l(j) + l(k) == 0)).contains(true)", "        if (l.size < 3) return false\n\
    \        val set = l.toSet\n        val sorted = l.sorted\n        var i = 0\n\
    \        while (i < sorted.size - 2) {\n            var j = i + 1\n          \
    \  while (j < sorted.size - 1) {\n                var k = j + 1\n            \
    \    while (k < sorted.size) {\n                    if (sorted(i) + sorted(j)\
    \ + sorted(k) == 0) return true\n                    k += 1\n                }\n\
    \                j += 1\n            }\n            i += 1\n        }\n      \
    \  return false", "        val a : List[Long] = l.sortWith(_ < _)\n        for\
    \ (i <- 0 to a.length - 3) {\n            val t : Long = -(a(i) + a(i + 1))\n\
    \            if (a.slice(i + 2, a.length).contains(t)) {\n                return\
    \ true\n            }\n        }\n        return false", "        var m : HashMap[Long,\
    \ Long] = new HashMap[Long, Long]\n        for (x <- l) {\n            if (m.contains(x))\
    \ {\n                m(x) = m(x) + 1\n            } else {\n                m(x)\
    \ = 1\n            }\n        }\n        for (x <- l) {\n            for (y <-\
    \ l) {\n                val z = -1 * (x + y)\n                if (m.contains(z))\
    \ {\n                    if (x == y && y == z) {\n                        if (m(x)\
    \ >= 3) {\n                            return true\n                        }\n\
    \                    } else if (x == y || y == z || x == z) {\n              \
    \          if (m(x) >= 2 && m(y) >= 2 && m(z) >= 2) {\n                      \
    \      return true\n                        }\n                    } else {\n\
    \                        return true\n                    }\n                }\n\
    \            }\n        }\n        return false", "        for (i <- 0 until l.length)\
    \ {\n            for (j <- i + 1 until l.length) {\n                if (Set(l(i),\
    \ l(j)).forall(x => l.contains(-x))) {\n                    return true\n    \
    \            }\n            }\n        }\n        return false", "        val\
    \ set = scala.collection.mutable.Set[Long]()\n        for (elem <- l) {\n    \
    \        if (set.contains(-elem)) {\n                return true\n           \
    \ }\n            else {\n                val i = -elem\n                for (elem2\
    \ <- set) {\n                    if (set.contains(i - elem2)) {\n            \
    \            return true\n                    }\n                }\n         \
    \       set.add(elem)\n            }\n        }\n        return false", "    \
    \    // return value\n        var r : Boolean = false\n        // check edge cases\n\
    \        if (l.length < 3) {\n            return r\n        }\n        // iterate\
    \ over all the possible pairs\n        for (i <- 0 to l.length - 1) {\n      \
    \      for (j <- i + 1 to l.length - 1) {\n                for (k <- j + 1 to\
    \ l.length - 1) {\n                    // check if the sum of the elements i,\
    \ j, and k is 0\n                    if (l(i) + l(j) + l(k) == 0) {\n        \
    \                r = true\n                    }\n                }\n        \
    \    }\n        }\n        // return the result\n        return r", "        if\
    \ (l.length < 3) false\n        else {\n            l.sorted.combinations(3).filter(x\
    \ => x(0) + x(1) + x(2) == 0).length != 0\n        }", '        return false',
  "        // if the list has more than three elements,\n        // recurse\n    \
    \    if (l.length > 3) {\n            // take the first element,\n           \
    \ val first : Long = l.head\n            // recurse on the tail.\n           \
    \ return triplesSumToZero(l.tail) ||\n            // recurse on the list without\
    \ first.\n            triplesSumToZero(l.tail :+ first)\n        }\n        //\
    \ if the list has three elements, check whether the sum of its\n        // elements\
    \ is zero.\n        if (l.length == 3) {\n            // take the elements.\n\
    \            val first : Long = l.head\n            val second : Long = l.tail.head\n\
    \            val third : Long = l.tail.tail.head\n            // return true if\
    \ the sum of the elements is zero.\n            return first + second + third\
    \ == 0\n        }\n        // the list has less than three elements,\n       \
    \ // so there are no three elements that sum to zero.\n        false", "     \
    \   // Replace the following line with your implementation.\n        return false",
  "\t    var result : Boolean = false\n\t    var lst : List[Long] = l\n\t    if (lst.length\
    \ < 3) {\n\t\t    result = false\n\t    } else {\n\t\t    for (i <- 0 to lst.length\
    \ - 1) {\n\t\t\t    for (j <- 0 to lst.length - 1) {\n\t\t\t\t    for (k <- 0\
    \ to lst.length - 1) {\n\t\t\t\t\t    if (i != j && i != k && j != k) {\n\t\t\t\
    \t\t\t    if (lst(i) + lst(j) + lst(k) == 0) {\n\t\t\t\t\t\t\t    result = true\n\
    \t\t\t\t\t\t    }\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t    }\n\t\t    }\n\t\
    \    }\n\t    result", "        val s = l.toSet\n        val p = s.filter(x =>\
    \ s.contains(x.toLong * -1))\n        val r = for (i <- p) yield (i, i.toLong\
    \ * -1)\n        for (i <- r) {\n            for (j <- s) {\n                if\
    \ (j != i._1 && j != i._2) {\n                    if (s.contains(i._1 + i._2 +\
    \ j)) {\n                        return true\n                    }\n        \
    \        }\n            }\n        }\n        return false", "        // Write\
    \ your code here\n        return true", "        // your code here\n        false",
  '        return true', '        l.combinations(3).exists(c => c.reduceLeft(_ + _)
    == 0)', "        val sl = l.sorted\n        val ls = sl.toSet\n        val m =\
    \ new HashMap[Long, Set[Long]]()\n        for (i <- 0 until sl.length) {\n   \
    \         if (m.contains(sl(i))) {\n                m(sl(i)) += (i)\n        \
    \    } else {\n                m += (sl(i) -> Set(i))\n            }\n       \
    \ }\n        for (i <- 0 until sl.length) {\n            for (j <- i + 1 until\
    \ sl.length) {\n                val x = sl(i)\n                val y = sl(j)\n\
    \                val z = -1 * (x + y)\n                if (m.contains(z)) {\n\
    \                    val zs = m(z)\n                    if (zs.contains(i) &&\
    \ zs.contains(j)) {\n                        return true\n                   \
    \ }\n                }\n            }\n        }\n        return false", "   \
    \     val original: HashSet[Long] = HashSet.empty\n        l.foreach((x: Long)\
    \ => original.add(x))\n        val sorted: List[Long] = l.sorted((x: Long, y:\
    \ Long) => x < y)\n        var i: Int = 0\n        while (i < sorted.length) {\n\
    \            var j: Int = i + 1\n            while (j < sorted.length) {\n   \
    \             var k: Int = j + 1\n                while (k < sorted.length) {\n\
    \                    if (sorted(i) + sorted(j) + sorted(k) == 0) {\n         \
    \               return true\n                    }\n                    k = k\
    \ + 1\n                }\n                j = j + 1\n            }\n         \
    \   i = i + 1\n        }\n        return false", "        val h = new HashMap[Long,\
    \ Int]\n        for (i <- l) {\n            if (h.contains(i)) h(i) += 1\n   \
    \         else h(i) = 1\n        }\n        for (a <- l) {\n            for (b\
    \ <- l) {\n                val c = -(a + b)\n                if (h.contains(c))\
    \ {\n                    if (a == b && a == c) {\n                        if (h(a)\
    \ >= 3) return true\n                    } else if (a == b || a == c || b == c)\
    \ {\n                        if (h(a) >= 2 || h(b) >= 2 || h(c) >= 2) return true\n\
    \                    } else return true\n                }\n            }\n  \
    \      }\n        return false", "        for (i <- 0 until l.length - 2) {\n\
    \            for (j <- i + 1 until l.length - 1) {\n                for (k <-\
    \ j + 1 until l.length) {\n                    if (l(i) + l(j) + l(k) == 0) {\n\
    \                        return true\n                    }\n                }\n\
    \            }\n        }\n        return false", "        def inner(m : Map[Long,\
    \ Int], l : List[Long]) : Boolean = {\n            l match {\n               \
    \ case h :: t => {\n                    val result = m.get(0 - h) match {\n  \
    \                      case Some(i) => if (i > 0) true else false\n          \
    \              case None => false\n                    }\n                   \
    \ inner(m + (h -> (m.getOrElse(h, 0) + 1)), t) || result\n                }\n\
    \                case Nil => false\n            }\n        }\n        inner(Map(),\
    \ l)", "      val p = l.sorted\n      for (i <- 0 until p.length - 2) {\n    \
    \    val a = p(i)\n        var left = i + 1\n        var right = p.length - 1\n\
    \        while (left < right) {\n          val b = p(left)\n          val c =\
    \ p(right)\n          if (a + b + c == 0) return true\n          else if (a +\
    \ b + c < 0) left += 1\n          else right -= 1\n        }\n      }\n      return\
    \ false", "        // your solution goes here\n        false", '        ???',
  "        var counts = new HashMap[Long, Long]\n        for (n <- l) {\n        \
    \    var c = if (counts.contains(n)) counts(n) else 0\n            counts(n) =\
    \ c + 1\n        }\n        for (c <- counts) {\n            if (c._2 >= 3) {\n\
    \                if (c._1 == 0) return true\n            }\n            for (d\
    \ <- counts) {\n                if (c._1 < d._1) {\n                    if (counts.contains(-c._1\
    \ - d._1)) {\n                        return true\n                    }\n   \
    \             }\n            }\n        }\n        return false", "        l.sorted\
    \ match {\n            case Nil => false\n            case x :: Nil => false\n\
    \            case x :: y :: Nil => false\n            case x :: y :: z :: Nil\
    \ => x + y + z == 0\n            case x :: y :: z :: tail => {\n             \
    \   if (x + y + z == 0) true\n                else if (x + y + z < 0) triplesSumToZero(y\
    \ :: z :: tail)\n                else triplesSumToZero(x :: y :: tail)\n     \
    \       }\n        }", "        if (l.length < 3) {\n            return false\n\
    \        }\n        val m = l.groupBy((x: Long) => x).mapValues((x: List[Long])\
    \ => x.length)\n        if (m.contains(0l) && m(0l) >= 3) {\n            return\
    \ true\n        }\n        var i = 1l\n        while (i < 0) {\n            if\
    \ (m.contains(i) && m.contains(-i)) {\n                return true\n         \
    \   }\n            i += 1\n        }\n        false", "        def aux(l : List[Long],\
    \ i : Int, s : Set[Long]) : Boolean = {\n            if (i > l.length - 3) false\n\
    \            else if (s.contains(-l(i) - l(i + 1)) || s.contains(-l(i) - l(i +\
    \ 2)) || s.contains(-l(i + 1) - l(i + 2))) true\n            else aux(l, i + 1,\
    \ s + l(i))\n        }\n        if (l.length <= 2) false\n        else aux(l,\
    \ 0, Set())", "        val cnt = new HashMap[Long, Int]\n        for (x <- l)\
    \ {\n            val nx = cnt.getOrElse(x, 0)\n            cnt(x) = nx + 1\n \
    \       }\n        var ans = false\n        for (x <- l) {\n            for (y\
    \ <- l) {\n                if (x != y) {\n                    val z = 0 - x -\
    \ y\n                    if (z != x && z != y) {\n                        val\
    \ nz = cnt.getOrElse(z, 0)\n                        if (nz > 0) {\n          \
    \                  if (nz == 1) cnt.remove(z)\n                            else\
    \ cnt(z) = nz - 1\n                            ans = true\n                  \
    \      }\n                    }\n                }\n            }\n        }\n\
    \        ans", "        var result = false\n        if (l.length >= 3) {\n   \
    \         for (i <- 0 until l.length - 2) {\n                for (j <- i + 1 until\
    \ l.length - 1) {\n                    for (k <- j + 1 until l.length) {\n   \
    \                     if (l(i) + l(j) + l(k) == 0) {\n                       \
    \     result = true\n                        }\n                    }\n      \
    \          }\n            }\n        }\n        return result", '        return
    false', "        for (i <- 0 until l.length - 2) {\n            for (j <- i +\
    \ 1 until l.length - 1) {\n                for (k <- j + 1 until l.length) {\n\
    \                    if (l(i) + l(j) + l(k) == 0) {\n                        return\
    \ true\n                    }\n                }\n            }\n        }\n \
    \       return false", "        // YOUR CODE HERE\n        return false", "  \
    \      //print(\"triplesSumToZero not implemented!\")\n        if (l.length <\
    \ 3) return false\n        // find all pairs that sum to zero\n        val pairs\
    \ : List[(Long, Long)] = for {\n            x <- l\n            y <- l\n     \
    \       if x != y\n            if x + y == 0\n        } yield (x, y)\n       \
    \ // find a third number that sums to zero with all the pairs\n        val number\
    \ : List[Long] = for {\n            x <- l\n            y <- pairs\n         \
    \   if x != y._1\n            if x != y._2\n            if x + y._1 + y._2 ==\
    \ 0\n        } yield x\n        // return true if the third number exists, false\
    \ otherwise\n        return number.length > 0", '        return false', '        //
    YOUR CODE HERE', "        // you can get the length of a list with l.length,\n\
    \        // or call l.isEmpty to check whether the list is empty.\n        //\
    \ (you will want to do both of these things.)\n        // you can get the first\
    \ element of a list with l.head\n        // and the rest of the list with l.tail.\n\
    \        // use l.tail.isEmpty to see if the list has only one element.\n    \
    \    // use l.map to apply a function to every element of a list,\n        //\
    \ e.g. (l.map((x : Long) => x * x)) returns a list containing\n        // the\
    \ squares of all the elements of l.\n        // use l.filter to keep only the\
    \ elements of a list that satisfy\n        // a predicate (i.e. a function from\
    \ T to Boolean), e.g.\n        // (l.filter((x : Long) => (x % 2) == 0)) returns\
    \ a list containing\n        // only the even elements of l.\n        // use l.exists\
    \ to see if any element of a list satisfies a predicate.\n        // use l.sum\
    \ to compute the sum of a list of numbers.\n        // use l.sortWith to sort\
    \ a list. e.g.\n        // (l.sortWith((x : Long, y : Long) => x < y)) sorts the\
    \ list l\n        // from smallest to largest.\n        //\n        // feel free\
    \ to define auxiliary functions.\n        // if you're stuck, try defining a function\
    \ that checks whether\n        // any triple in a list sums to a given number.\n\
    \        l.isEmpty || false", '        l.combinations(3).map(_.sum).filter(_ ==
    0).size > 0', "        if (l.length < 3) return false\n        l.sorted.sliding(3).toList.exists(l\
    \ => l(0) + l(1) + l(2) == 0)", "        if (l.length < 3) return false\n    \
    \    val s = l.toSet\n        var a = s.toList.sorted\n        for (i <- 0 until\
    \ a.length - 2) {\n            for (j <- i + 1 until a.length - 1) {\n       \
    \         if (s.contains(-(a(i) + a(j)))) return true\n            }\n       \
    \ }\n        return false", "        val array = l.sorted.toArray\n        for\
    \ (i <- 0 until l.length) {\n            var left = i + 1\n            var right\
    \ = l.length - 1\n            while (left < right) {\n                val sum\
    \ = array(i) + array(left) + array(right)\n                if (sum == 0) {\n \
    \                   return true\n                } else if (sum < 0) {\n     \
    \               left += 1\n                } else {\n                    right\
    \ -= 1\n                }\n            }\n        }\n        return false", '        return
    false', "        // need at least three elements\n        if (l.length < 3)\n\
    \            return false\n        // sort the list\n        val l_sorted = l.sorted\n\
    \        // keep track of the values we've seen in a hashset\n        val seen\
    \ = HashSet[Long]()\n        // add the first two elements to the hashset\n  \
    \      seen += l_sorted(0)\n        seen += l_sorted(1)\n        // loop over\
    \ the rest of the elements in the list\n        for (i <- 2 until l_sorted.length)\
    \ {\n            // for each element, check if the sum of the first two elements\
    \ and its\n            // negative exists in the hashset\n            if (seen.contains(-(l_sorted(0)\
    \ + l_sorted(1) + l_sorted(i))))\n                return true\n            else\n\
    \                seen += l_sorted(i)\n        }\n        return false", '        return
    l.combinations(3).map(_.sum).filter(_ == 0).size > 0', "        // case 1: empty\
    \ list\n        if (l.length == 0) return false\n        // case 2: list has two\
    \ or fewer elements\n        if (l.length < 3) return false\n        // case 3:\
    \ list has exactly three elements\n        if (l.length == 3) {\n            val\
    \ a = l(0)\n            val b = l(1)\n            val c = l(2)\n            if\
    \ (a + b + c == 0) return true\n            else return false\n        }\n   \
    \     // case 4: list has more than three elements\n        var m = HashMap[Long,\
    \ List[Long]]()\n        for (j <- 0 to l.length - 1) {\n            val k = l(j)\n\
    \            if (m.contains(k)) {\n                val y = m(k)\n            \
    \    y = k :: y\n                m += (k -> y)\n            }\n            else\
    \ {\n                m += (k -> List(k))\n            }\n        }\n        //\
    \ now m has been populated\n        for (j <- 0 to l.length - 1) {\n         \
    \   val a = l(j)\n            for (k <- 0 to l.length - 1) {\n               \
    \ val b = l(k)\n                val c = -(a + b)\n                if (m.contains(c))\
    \ {\n                    val y = m(c)\n                    // check if any element\
    \ of the list y is not a, b, or c\n                    for (n <- 0 to y.length\
    \ - 1) {\n                        val z = y(n)\n                        if (z\
    \ != a && z != b && z != c) return true\n                    }\n             \
    \   }\n            }\n        }\n        return false", "        // Your answer\
    \ goes here.\n        return false", '        return false', "        // todo:\
    \ implement this function\n        return false", "        // copy of original\
    \ list sorted in ascending order\n        val sortedList = l.sorted\n        for\
    \ (first <- 0 to sortedList.length - 3) {\n            // mark the elements of\
    \ the list that we have seen\n            val seen = new HashSet[Long]\n     \
    \       // the inverse of the second element we are looking for.\n           \
    \ // the second element is such that first + second + third = 0\n            val\
    \ secondInv = -sortedList(first)\n            for (second <- first + 1 to sortedList.length\
    \ - 2) {\n                // third value we are looking for\n                val\
    \ third = secondInv - sortedList(second)\n                // if we have seen the\
    \ value of third, then we have found three\n                // elements that sum\
    \ to zero.\n                if (seen.contains(third)) {\n                    return\
    \ true\n                }\n                // otherwise, add the second element\
    \ to the set of seen values\n                seen.add(sortedList(second))\n  \
    \          }\n        }\n        // if we get to the end of the list, then we\
    \ have not found three\n        // elements that sum to zero.\n        false",
  '      return false', "        if (l.size < 3) return false\n        val sortedList\
    \ = l.sorted\n        var i = 0\n        while (i < sortedList.size - 2) {\n \
    \           var j = i + 1\n            var k = sortedList.size - 1\n         \
    \   while (j < k) {\n                val sum = sortedList(i) + sortedList(j) +\
    \ sortedList(k)\n                if (sum == 0) return true\n                else\
    \ if (sum < 0) j += 1\n                else k -= 1\n            }\n          \
    \  i += 1\n        }\n        return false", "        var i = 0\n        var j\
    \ = 0\n        var k = 0\n        for (i <- 0 to l.length - 3) {\n           \
    \ for (j <- i + 1 to l.length - 2) {\n                for (k <- j + 1 to l.length\
    \ - 1) {\n                    if (l(i) + l(j) + l(k) == 0) {\n               \
    \         return true\n                    }\n                }\n            }\n\
    \        }\n        return false", "        val map = new HashMap[Long, List[Long]]()\n\
    \        for (i <- 0 until l.length) {\n            val key = l(i)\n         \
    \   val value = if (map.contains(key)) map(key) else List[Long]()\n          \
    \  map(key) = value :+ i\n        }\n        for (i <- 0 until l.length) {\n \
    \           for (j <- i + 1 until l.length) {\n                val a = l(i)\n\
    \                val b = l(j)\n                val c = -(a + b)\n            \
    \    if (map.contains(c)) {\n                    val list = map(c)\n         \
    \           val k = list.filter(_ > j).headOption\n                    if (k.isDefined)\
    \ {\n                        return true\n                    }\n            \
    \    }\n            }\n        }\n        return false", "        val myl = l.toSet.toList\n\
    \        for (i <- myl.indices) {\n            for (j <- i + 1 until myl.length)\
    \ {\n                if (myl.contains(-myl(i) - myl(j))) return true\n       \
    \     }\n        }\n        false", '        l.sorted.combinations(3).exists(x
    => x.sum == 0)', "        def aux(l : List[Long], m : Map[Long, Long]) : Boolean\
    \ = l match {\n            case Nil => false\n            case x :: xs => {\n\
    \                val m2 = m.withDefault(_ => 0l)\n                val m3 = m2.updated(x,\
    \ m2(x) + 1l)\n                def x2(y : Long) = (x * y != 0) && (m3(-x - y)\
    \ != 0) && (((x == y) && (m3(x) > 1)) || (x != y))\n                if (xs.exists(x2))\
    \ true else aux(xs, m3)\n            }\n        }\n        aux(l, Map[Long, Long]())",
  "        for (a <- l) {\n            for (b <- l) {\n                for (c <- l)\
    \ {\n                    if (a + b + c == 0 && a != b && b != c && a != c) return\
    \ true\n                }\n            }\n        }\n        return false", " \
    \       var result : Boolean = false\n        for (i <- 0 until l.length - 2)\
    \ {\n            for (j <- i + 1 until l.length - 1) {\n                for (k\
    \ <- j + 1 until l.length) {\n                    if (l(i) + l(j) + l(k) == 0)\
    \ {\n                        result = true\n                    }\n          \
    \      }\n            }\n        }\n        return result", "        var xs =\
    \ l.sorted\n        var result = false\n        var i = 0\n        while (i <\
    \ xs.length && !result) {\n            var j = i + 1\n            var k = xs.length\
    \ - 1\n            while (j < k && !result) {\n                var sum = xs(i)\
    \ + xs(j) + xs(k)\n                if (sum == 0) {\n                    result\
    \ = true\n                } else if (sum < 0) {\n                    j += 1\n\
    \                } else {\n                    k -= 1\n                }\n   \
    \         }\n            i += 1\n        }\n        result", "        l.sorted\
    \ match {\n            case Nil => false\n            case List(i) => false\n\
    \            case List(i, j) => false\n            case x =>\n               \
    \ {\n                    val t = x.tail\n                    val l = x.length\n\
    \                    var n = 0\n                    var k = l - 1\n          \
    \          while (n < l - 2) {\n                        var i = t(n)\n       \
    \                 var j = 0\n                        var m = n + 1\n         \
    \               while (m < l - 1) {\n                            j = t(m)\n  \
    \                          var sum = i + j\n                            while\
    \ (sum <= 0 && k > m) {\n                                if (sum + t(k) == 0)\
    \ {\n                                    return true\n                       \
    \         }\n                                k -= 1\n                        \
    \    }\n                            m += 1\n                        }\n      \
    \                  n += 1\n                    }\n                    false\n\
    \                }\n        }", "      val n = l.length\n      for (i <- 0 until\
    \ n) {\n        for (j <- i + 1 until n) {\n          for (k <- j + 1 until n)\
    \ {\n            if (l(i) + l(j) + l(k) == 0) {\n              return true\n \
    \           }\n          }\n        }\n      }\n      return false", "       \
    \ // YOUR CODE HERE\n        ???", "        if (l.length < 3) return false\n \
    \       val a = l.sorted.toArray\n        for (i <- 0 until a.length - 2) {\n\
    \            val j = i + 1\n            val k = a.length - 1\n            while\
    \ (j < k) {\n                val sum = a(i) + a(j) + a(k)\n                if\
    \ (sum == 0) return true\n                else if (sum < 0) j += 1\n         \
    \       else k -= 1\n            }\n        }\n        return false", "      \
    \  var s = new TreeSet[Long]()\n        l.foreach(e => s.add(e))\n        var\
    \ b = false\n        var it = s.iterator\n        while (it.hasNext) {\n     \
    \       var i = it.next\n            var it2 = s.iterator\n            while (it2.hasNext)\
    \ {\n                var j = it2.next\n                if (i == j) b = true\n\
    \                else {\n                    if (s.contains(-(i + j))) return\
    \ true\n                }\n            }\n        }\n        return false", " \
    \       def bisect(l : List[Long], a : Long, b : Long) : List[Long] = {\n    \
    \        val c : Long = (a + b) / 2\n            l match {\n                case\
    \ List() => List()\n                case x :: xs => if (x > c) bisect(xs, a, c)\
    \ else bisect(xs, c, b)\n            }\n        }\n        def filter_zero(l :\
    \ List[Long]) : List[Long] = {\n            l match {\n                case List()\
    \ => List()\n                case x :: xs => if (x == 0) x :: filter_zero(xs)\
    \ else filter_zero(xs)\n            }\n        }\n        def filter_positive(l\
    \ : List[Long]) : List[Long] = {\n            l match {\n                case\
    \ List() => List()\n                case x :: xs => if (x > 0) x :: filter_positive(xs)\
    \ else filter_positive(xs)\n            }\n        }\n        def filter_negative(l\
    \ : List[Long]) : List[Long] = {\n            l match {\n                case\
    \ List() => List()\n                case x :: xs => if (x < 0) x :: filter_negative(xs)\
    \ else filter_negative(xs)\n            }\n        }\n        def is_in(l : List[Long],\
    \ x : Long) : Boolean = {\n            l match {\n                case List()\
    \ => false\n                case y :: ys => if (y == x) true else is_in(ys, x)\n\
    \            }\n        }\n        if (l.length < 3) false else {\n          \
    \  val neg : List[Long] = bisect(filter_negative(l), -9999999999999999l, 0l)\n\
    \            val pos : List[Long] = bisect(filter_positive(l), 0l, 9999999999999999l)\n\
    \            val zero : List[Long] = filter_zero(l)\n            if (neg.length\
    \ < 2 || pos.length < 2) {\n                if (zero.length < 3) false else true\n\
    \            } else {\n                var b : Boolean = false\n             \
    \   var i : Int = 0\n                while (i < neg.length - 1 && !b", "     \
    \   var m:scala.collection.mutable.Map[Long,Integer] = new scala.collection.mutable.HashMap[Long,Integer]()\n\
    \        for (x <- l) {\n            if (m.contains(x)) {\n                m(x)\
    \ = m(x) + 1\n            } else {\n                m(x) = 1\n            }\n\
    \        }\n        for (x <- l) {\n            for (y <- l) {\n             \
    \   if (x != y) {\n                    if (m.contains(0 - x - y)) {\n        \
    \                if (x != 0 - x - y && y != 0 - x - y) {\n                   \
    \         return true\n                        } else if (x == 0 - x - y && m(x)\
    \ > 1) {\n                            return true\n                        } else\
    \ if (y == 0 - x - y && m(y) > 1) {\n                            return true\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        return false", '        null', "\tdef helper(l : List[Long],\
    \ s : Set[Long]) : Boolean = l match {\n\t    case Nil => false\n\t    case x\
    \ :: xs => {\n\t\tif (s.contains(-x)) return true\n\t\ts += x\n\t\thelper(xs,\
    \ s)\n\t    }\n\t}\n\thelper(l, Set())", "        val triples =\n            (for\
    \ (i <- 0 until l.length; j <- i + 1 until l.length; k <- j + 1 until l.length)\
    \ yield (l(i), l(j), l(k))).toList\n        val sums =\n            for (triple\
    \ <- triples) yield (triple._1 + triple._2 + triple._3)\n        sums.contains(0)",
  "        var result = false\n        for (i <- 0 until l.length) {\n           \
    \ for (j <- i + 1 until l.length) {\n                for (k <- j + 1 until l.length)\
    \ {\n                    if (l(i) + l(j) + l(k) == 0) {\n                    \
    \    result = true\n                    }\n                }\n            }\n\
    \        }\n        return result", "        if (l.size < 3) false\n        else\
    \ {\n            val sorted = l.sorted\n            var a = 0\n            var\
    \ b = 1\n            var c = sorted.size - 1\n            while (a < sorted.size\
    \ - 2) {\n                var sum = sorted(a) + sorted(b) + sorted(c)\n      \
    \          if (sum == 0) return true\n                else if (sum < 0) b += 1\n\
    \                else c -= 1\n                if (b == c) {\n                \
    \    a += 1\n                    b = a + 1\n                    c = sorted.size\
    \ - 1\n                }\n            }\n            false\n        }", "    \
    \    val nums = l.toSet\n        val possibles = nums.flatMap(x => nums.map(y\
    \ => x + y))\n        l.exists(x => possibles.contains(-x))", "        // *************\
    \ INSERT CODE HERE **************\n        if (l.length < 3) return false\n  \
    \      else {\n            var distinctNumbers: Map[Long, Boolean] = Map()\n \
    \           for (x <- l) {\n                distinctNumbers(x) = true\n      \
    \      }\n            for (x <- distinctNumbers.keys) {\n                for (y\
    \ <- distinctNumbers.keys) {\n                    if (x != y) {\n            \
    \            if (distinctNumbers.contains(-x - y)) {\n                       \
    \     return true\n                        }\n                    }\n        \
    \        }\n            }\n            return false\n        }", '        l.map(x
    => if (x == 0) true else false).fold(false)(_ || _)', '        false', "     \
    \   // YOUR CODE HERE\n        if (l.length < 3) {\n            return false\n\
    \        } else {\n            val sortedList = l.sorted\n            val x =\
    \ sortedList(0)\n            val n = sortedList.length\n            var i = 0\n\
    \            var j = n - 1\n            while (i < n - 2) {\n                while\
    \ (j > i + 1) {\n                    if (x + sortedList(i + 1) + sortedList(j)\
    \ == 0) {\n                        return true\n                    } else if\
    \ (x + sortedList(i + 1) + sortedList(j) > 0) {\n                        j -=\
    \ 1\n                    } else {\n                        i += 1\n          \
    \          }\n                }\n                i += 1\n                j = n\
    \ - 1\n            }\n            return false\n        }", "        // insert\
    \ your code here\n        return true", "        l.sortWith((l1, l2) => l1 < l2)\n\
    \        if (l.length < 3) return false\n        var i = 0\n        while (i <\
    \ l.length - 2) {\n            var j = i + 1\n            var k = l.length - 1\n\
    \            while (j < k) {\n                val sum = l(i) + l(j) + l(k)\n \
    \               if (sum == 0) return true\n                else if (sum < 0) j\
    \ += 1\n                else k -= 1\n            }\n            i += 1\n     \
    \   }\n        return false", "        for (i <- 0 until l.length)\n         \
    \   for (j <- i + 1 until l.length)\n                for (k <- j + 1 until l.length)\n\
    \                    if (l(i) + l(j) + l(k) == 0)\n                        return\
    \ true\n        return false", "        val p = new HashMap[Long, Int]\n     \
    \   p.clear\n        for (i <- l) {\n            if (p.contains(i)) {\n      \
    \          val value = p.get(i).get\n                p.put(i, value + 1)\n   \
    \         } else {\n                p.put(i, 1)\n            }\n        }\n  \
    \      for (i <- l) {\n            for (j <- l) {\n                val sum = -(i\
    \ + j)\n                if (sum == i && p.get(i).get > 1) {\n                \
    \    return true\n                } else if (sum == j && p.get(j).get > 1) {\n\
    \                    return true\n                } else if (sum != i && sum !=\
    \ j && p.contains(sum)) {\n                    return true\n                }\n\
    \            }\n        }\n        return false", "        // your code here\n\
    \        false", "      val l2 = l.sorted\n      for (x <- 0 to l2.length - 3)\
    \ {\n        for (y <- x + 1 to l2.length - 2) {\n          for (z <- y + 1 to\
    \ l2.length - 1) {\n            if (l2(x) + l2(y) + l2(z) == 0) {\n          \
    \    return true\n            }\n          }\n        }\n      }\n      return\
    \ false", "        val m = l.groupBy(a => a)\n        for (a <- m) {\n       \
    \     for (b <- m) {\n                if (a._1 != b._1) {\n                  \
    \  val c = -1 * (a._1 + b._1)\n                    if (m.contains(c)) {\n    \
    \                    return true\n                    }\n                }\n \
    \           }\n        }\n        return false", "        val p = l.permutations.toList\n\
    \        for (i <- p) {\n            for (j <- 0 to i.length - 3) {\n        \
    \        if (i(j) + i(j + 1) + i(j + 2) == 0) {\n                    return true\n\
    \                }\n            }\n        }\n        return false", "       \
    \ if (l.length < 3) {\n            return false\n        }\n        else {\n \
    \           val sorted = l.sorted\n            val head = sorted.head\n      \
    \      val tail = sorted.tail\n            if (sorted.last + sorted.last + sorted.last\
    \ >= 0) {\n                return false\n            }\n            else {\n \
    \               var left = 0\n                var right = l.length - 1\n     \
    \           while (right - left >= 2) {\n                    val sum = sorted(left)\
    \ + sorted(right)\n                    if (sum < 0) {\n                      \
    \  val newHead = sorted(left + 1)\n                        val newTail = sorted.dropRight(l.length\
    \ - right)\n                        if (triplesSumToZero(newHead :: newTail))\
    \ {\n                            return true\n                        }\n    \
    \                    else {\n                            left += 1\n         \
    \               }\n                    }\n                    else {\n       \
    \                 val newHead = sorted(left)\n                        val newTail\
    \ = sorted.dropRight(l.length - right + 1)\n                        if (triplesSumToZero(newHead\
    \ :: newTail)) {\n                            return true\n                  \
    \      }\n                        else {\n                            right -=\
    \ 1\n                        }\n                    }\n                }\n   \
    \             false\n            }\n        }", "        if (l.length < 3) return\
    \ false\n        var m = Map[Long, Long]()\n        for (i <- 0 until l.length)\
    \ {\n            m += (l(i) -> i)\n        }\n        for (i <- 0 until l.length)\
    \ {\n            for (j <- i + 1 until l.length) {\n                if (m.contains(-l(i)\
    \ - l(j))) return true\n            }\n        }\n        return false", "   \
    \     // YOUR CODE HERE\n        val lookup = scala.collection.mutable.HashMap[Long,\
    \ Int]()\n        for (i <- l) {\n            if (lookup.contains(i)) {\n    \
    \            lookup(i) += 1\n            } else {\n                lookup(i) =\
    \ 1\n            }\n        }\n        for (i <- l) {\n            for (j <- l)\
    \ {\n                val k = -(i + j)\n                if (lookup.contains(k))\
    \ {\n                    if (i == j && j == k) {\n                        if (lookup(i)\
    \ >= 3) {\n                            return true\n                        }\n\
    \                    } else if (i == j) {\n                        if (lookup(i)\
    \ >= 2) {\n                            return true\n                        }\n\
    \                    } else if (j == k) {\n                        if (lookup(j)\
    \ >= 2) {\n                            return true\n                        }\n\
    \                    } else if (i == k) {\n                        if (lookup(i)\
    \ >= 2) {\n                            return true\n                        }\n\
    \                    } else {\n                        return true\n         \
    \           }\n                }\n            }\n        }\n        return false",
  '        return false', "        // count_negative_numbers takes a list of integers\
    \ as an input.\n        // it returns the number of negative integers in the list.\n\
    \        // >>> count_negative_numbers((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 7l.toLong)))\n        // (0)\n        // >>> count_negative_numbers((List[Long](2l.toLong,\
    \ 3l.toLong, -1l.toLong, 7l.toLong)))\n        // (1)\n        // >>> count_negative_numbers((List[Long](-2l.toLong,\
    \ 3l.toLong, -1l.toLong, 7l.toLong)))\n        // (2)\n        // >>> count_negative_numbers((List[Long](2l.toLong,\
    \ -3l.toLong, -1l.toLong, -7l.toLong)))\n        // (3)\n        // >>> count_negative_numbers((List[Long](-2l.toLong,\
    \ -3l.toLong, -1l.toLong, -7l.toLong)))\n        // (4)\n        def count_negative_numbers(l\
    \ : List[Long]) : Int = {\n            ((l match {\n                case Nil =>\
    \ (0)\n                case (x :: xs) => {\n                    (((if ((x < 0))\
    \ (1) else (0))) + (count_negative_numbers(xs)))\n                }\n        \
    \    }))\n        }\n        // count_positive_numbers takes a list of integers\
    \ as an input.\n        // it returns the number of positive integers in the list.\n\
    \        // >>> count_positive_numbers((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 7l.toLong)))\n        // (4)\n        // >>> count_positive_numbers((List[Long](2l.toLong,\
    \ 3l.toLong, -1l.toLong, 7l.toLong)))\n        // (3)\n        // >>> count_positive_numbers((List[Long](-2l.toLong,\
    \ 3l.toLong, -1l.toLong, 7l.to", "        // My code here\n        false", " \
    \       for (i <- 0 until l.length - 2) {\n            for (j <- i + 1 until l.length\
    \ - 1) {\n                for (k <- j + 1 until l.length) {\n                \
    \    if (l(i) + l(j) + l(k) == 0) return true\n                }\n           \
    \ }\n        }\n        return false", "        // PRECONDITION: l.length >= 3\n\
    \        // POSTCONDITION: returns true if there exists three distinct elements\
    \ in l such that a + b + c = 0\n        val s = l.toSet\n        val p = s.foldLeft(Set[Long]())((a,\
    \ b) => a + (-b))\n        s.exists(p(_))", "        // Write your code here.\n\
    \        return false", "        // This function uses two for loops to go through\
    \ every possible\n        // combination of three elements in the input list.\n\
    \        // It adds each combination and returns true if it is zero, and false\n\
    \        // otherwise.\n        for (x <- l) {\n            for (y <- l) {\n \
    \               for (z <- l) {\n                    if (x != y && x != z && y\
    \ != z) {\n                        if (x + y + z == 0) {\n                   \
    \         return true\n                        }\n                    }\n    \
    \            }\n            }\n        }\n        return false", "        // >>>\
    \ triplesSumToZero((List[Long](1l.toLong, 3l.toLong, 5l.toLong, 0l.toLong)))\n\
    \        // (false)\n        // >>> triplesSumToZero((List[Long](1l.toLong, 3l.toLong,\
    \ -2l.toLong, 1l.toLong)))\n        // (true)\n        // >>> triplesSumToZero((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 7l.toLong)))\n        // (false)\n        // >>> triplesSumToZero((List[Long](2l.toLong,\
    \ 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong)))\n        // (true)\n\
    \        // >>> triplesSumToZero((List[Long](1l.toLong)))\n        // (false)\n\
    \        // >>> triplesSumToZero((List[Long](1l.toLong, 0l.toLong, 0l.toLong)))\n\
    \        // (true)\n        // >>> triplesSumToZero((List[Long](1l.toLong, 1l.toLong,\
    \ 0l.toLong)))\n        // (true)\n        // >>> triplesSumToZero((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong)))\n        // (true)\n        // >>> triplesSumToZero((List[Long](1l.toLong,\
    \ -1l.toLong, 1l.toLong)))\n        // (true)\n        // >>> triplesSumToZero((List[Long](1l.toLong,\
    \ 1l.toLong, -1l.toLong)))\n        // (true)\n        // >>> triplesSumToZero((List[Long](1l.toLong,\
    \ -1l.toLong, -1l.toLong)))\n        // (true)\n        // >>> triplesSumToZero((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong)))\n        // (true)\n        // >>> triplesSumToZero((List[Long](-1l.toLong,\
    \ -1", "        def triplesSumToZeroHelper(l : List[Long], acc : List[Long]) :\
    \ Boolean = l match {\n            case List() => false\n            case x ::\
    \ xs => acc match {\n                case List() => triplesSumToZeroHelper(xs,\
    \ List(x))\n                case y :: ys => if (x + y == 0) true else triplesSumToZeroHelper(xs,\
    \ y :: acc)\n            }\n        }\n        triplesSumToZeroHelper(l, List())",
  "        val n = l.length\n        if (n < 3) return false\n        val l2 = l.toArray\n\
    \        scala.util.Sorting.quickSort(l2)\n        for (i <- 0 until n) {\n  \
    \          val a = l2(i)\n            var j = i + 1\n            var k = n - 1\n\
    \            while (j < k) {\n                val b = l2(j)\n                val\
    \ c = l2(k)\n                if (a + b + c == 0) return true\n               \
    \ else if (a + b + c < 0) j += 1\n                else k -= 1\n            }\n\
    \        }\n        return false", "        // YOUR CODE HERE\n        // Hint:\
    \ You will need to implement a function that sorts the list\n        // and returns\
    \ it.\n        // Hint: You will need to implement a function that finds the closest\n\
    \        // match in a sorted list (be careful with duplicates).\n        // If\
    \ you can find the closest match for each of the elements in the\n        // list,\
    \ you will be able to check for the existence of a triple\n        // that sums\
    \ to zero.\n        var b: Boolean = false\n        for (i <- l) {\n         \
    \   for (j <- l) {\n                for (k <- l) {\n                    if (i\
    \ != j && i != k && j != k) {\n                        if (i + j + k == 0) {\n\
    \                            b = true\n                        }\n           \
    \         }\n                }\n            }\n        }\n        return b", '        return
    true', '        l.forall(i => l.forall(j => l.forall(k => !(i + j + k == 0))))',
  "\t    if (l.size < 3) return false\n\t    var a : List[Long] = l.sorted\n\t   \
    \ var b : List[Long] = a.tail\n\t    var c : List[Long] = b.tail\n\t    while\
    \ (a.size > 0) {\n\t\t    while (b.size > 0) {\n\t\t\t    while (c.size > 0) {\n\
    \t\t\t\t    if (a.head + b.head + c.head == 0) return true\n\t\t\t\t    c = c.tail\n\
    \t\t\t    }\n\t\t\t    b = b.tail\n\t\t\t    c = b.tail\n\t\t    }\n\t\t    a\
    \ = a.tail\n\t\t    b = a.tail\n\t\t    c = b.tail\n\t    }\n\t    return false",
  "        val sorted = l.sorted\n        // We keep a head, middle, and tail pointer.\n\
    \        // head is the least value\n        // tail is the greatest value\n \
    \       // middle iterates all values in between\n        var head = 0\n     \
    \   var tail = sorted.length - 1\n        // If there are three elements in the\
    \ list and the sum of the first two\n        // elements is greater than the last\
    \ element, then no three element\n        // sum can be zero.\n        if (sorted.length\
    \ > 2 && sorted(head) + sorted(head + 1) > sorted(tail)) {\n            return\
    \ false\n        }\n        var middle = 1\n        // We will iterate through\
    \ the list and narrow our search space\n        // until we find a solution or\
    \ we determine one doesn't exist.\n        while (head < middle && middle < tail)\
    \ {\n            // if three elements sum to zero\n            if (sorted(head)\
    \ + sorted(middle) + sorted(tail) == 0) {\n                return true\n     \
    \       }\n            // if the sum is less than zero, we have to increase the\
    \ sum\n            // by increasing head or decreasing tail.\n            else\
    \ if (sorted(head) + sorted(middle) + sorted(tail) < 0) {\n                //\
    \ If increasing head would make the sum too big, we increase\n               \
    \ // middle instead.\n                if (sorted(head) + sorted(middle + 1) +\
    \ sorted(tail) > 0) {\n                    middle += 1\n                }\n  \
    \              // Otherwise we increase head.\n                else {\n      \
    \              head += 1\n                }\n            }\n            // if\
    \ the sum is greater than zero, we have to decrease the sum\n            // by\
    \ decreasing tail or increasing head.\n            else {\n                //\
    \ If decreasing tail would make the sum too small, we decrease\n             \
    \   // middle instead.\n                if (sorted(head) + sorted(middle) + sorted(tail\
    \ - 1) < 0) {\n                    middle += 1\n                }\n          \
    \      // Otherwise we decrease tail.\n                else {\n              \
    \      tail -= 1\n                }\n            }\n        }\n        return\
    \ false", "        if (l.length < 3) false\n        else {\n            var visited\
    \ = Set[Long]()\n            for (i <- 0 until l.length) {\n                for\
    \ (j <- 0 until l.length) {\n                    if (i != j) {\n             \
    \           val compliment = -(l(i) + l(j))\n                        if (visited.contains(compliment))\
    \ return true\n                    }\n                }\n                visited\
    \ += l(i)\n            }\n            false\n        }", "        def sum(n1 :\
    \ Long, n2 : Long, n3 : Long) : Boolean = (n1 + n2 + n3) == 0\n        def loop(n\
    \ : Int, l : List[Long]) : Boolean = {\n            if (n >= l.length) false\n\
    \            else if (sum(l(n), l(n + 1), l(n + 2))) true\n            else loop(n\
    \ + 1, l)\n        }\n        if (l.length < 3) false\n        else loop(0, l)",
  "      (l.length >= 3) && \n      (for (i <- (0 until l.length); j <- (i + 1 until\
    \ l.length); k <- (j + 1 until l.length)) yield l(i) + l(j) + l(k) == 0l).contains(true)",
  "        // Your Code Goes Here\n        // Return true or false\n        val n\
    \ = l.length\n        if (n < 3) {\n            return false\n        }\n    \
    \    val s = l.toSet\n        val n_set = s.size\n        var i = 0\n        while\
    \ (i < n) {\n            var j = i + 1\n            while (j < n) {\n        \
    \        val sum = l(i) + l(j)\n                if (s.contains(-sum)) {\n    \
    \                return true\n                }\n                j += 1\n    \
    \        }\n            i += 1\n        }\n        return false", "        //\
    \ >>> Boolean = true\n        for (i <- l.indices) {\n            // >>> i: Int\
    \ = 0\n            // >>> i: Int = 1\n            // >>> i: Int = 2\n        \
    \    // >>> i: Int = 3\n            // >>> i: Int = 4\n            // >>> i: Int\
    \ = 5\n            for (j <- i + 1 until l.length) {\n                // >>> j:\
    \ Int = 1\n                // >>> j: Int = 2\n                // >>> j: Int =\
    \ 3\n                // >>> j: Int = 4\n                // >>> j: Int = 5\n  \
    \              for (k <- j + 1 until l.length) {\n                    // >>> k:\
    \ Int = 2\n                    // >>> k: Int = 3\n                    // >>> k:\
    \ Int = 4\n                    // >>> k: Int = 5\n                    // >>> k:\
    \ Int = 2\n                    // >>> k: Int = 3\n                    // >>> k:\
    \ Int = 4\n                    // >>> k: Int = 5\n                    // >>> k:\
    \ Int = 2\n                    // >>> k: Int = 3\n                    // >>> k:\
    \ Int = 4\n                    // >>> k: Int = 5\n                    // >>> k:\
    \ Int = 2\n                    // >>> k: Int = 3\n                    // >>> k:\
    \ Int = 4\n                    // >>> k: Int = 5\n                    // >>> k:\
    \ Int = 2\n                    // >>> k: Int = 3\n                    // >>> k:\
    \ Int = 4\n                    // >>> k: Int = 5\n                    // >>> k:\
    \ Int = 2\n                    // >>> k: Int = 3\n                    // >>> k:\
    \ Int = 4\n                    // >>> k: Int = 5\n                    // >>> k:\
    \ Int = 2\n                    // >>> k: Int = 3\n                    // >>> k:\
    \ Int = 4\n                    // >>> k: Int = 5\n                    // >>> k:\
    \ Int = 2\n                    // >>> k: Int = 3\n                    // >>> k:\
    \ Int = 4\n                    // >>> k: Int = 5\n                    // >>> k:\
    \ Int = 2\n                    // >>> k: Int = 3\n                    // >>> k:\
    \ Int = 4\n                    // >>> k: Int = 5\n                    // >>> k:\
    \ Int = 2\n                    // >>> k: Int = 3\n                    // >>> k:\
    \ Int = 4\n                    // >>> k: Int = 5\n                    // >>>",
  '        l.combinations(3).toList.exists(list => list.sum == 0)', "      var list\
    \ = l\n      if (list.length < 3) return false\n      list = list.sorted\n   \
    \   for (i <- 0 until list.length - 2) {\n        var j = i + 1\n        var k\
    \ = list.length - 1\n        while (j < k) {\n          val sum = list(i) + list(j)\
    \ + list(k)\n          if (sum == 0) return true\n          else if (sum < 0)\
    \ j += 1\n          else k -= 1\n        }\n      }\n      return false", "  \
    \      def loop(first: Int, middle: Int, last: Int, a: List[Long]): Boolean =\
    \ {\n            if (a.isEmpty) {\n                return false\n            }\n\
    \            if (a.length < 3) {\n                return false\n            }\n\
    \            var temp: Long = 0l\n            temp = a(first) + a(middle) + a(last)\n\
    \            if (temp == 0) {\n                return true\n            }\n  \
    \          if (last == a.length - 1) {\n                if (middle == a.length\
    \ - 2) {\n                    if (first == a.length - 3) {\n                 \
    \       return false\n                    }\n                    else {\n    \
    \                    return loop(first + 1, first + 2, first + 3, a)\n       \
    \             }\n                }\n                else {\n                 \
    \   return loop(first, middle + 1, middle + 2, a)\n                }\n       \
    \     }\n            else {\n                return loop(first, middle, last +\
    \ 1, a)\n            }\n        }\n        loop(0, 1, 2, l)", "        // fill\
    \ in the code for this function\n        return true", "        // first we sort\
    \ the list of integers\n        val l2 = l.sorted\n        // to check if the\
    \ list contains a tripple of integers that sum to zero, we can simply\n      \
    \  // iterate over the list, and perform a modified binary search for the complement\n\
    \        // of each element in the list.\n        for (i <- 0 until l2.length\
    \ - 2) {\n            if (search(l2, i + 1, l2.length - 1, -l2(i))) {\n      \
    \          return true\n            }\n        }\n        false", "        l.isEmpty\
    \ || {\n            l.head.abs > l.last.abs && triplesSumToZero(l.tail)\n    \
    \    }", "        val sorted = l.sorted\n        var lo = 0\n        var hi =\
    \ sorted.length - 1\n        while (lo < hi) {\n            var sum = sorted(lo)\
    \ + sorted(hi)\n            if (sum == 0) {\n                return true\n   \
    \         } else if (sum < 0) {\n                lo += 1\n            } else {\n\
    \                hi -= 1\n            }\n        }\n        return false", " \
    \       for (i <- 0 until l.length - 2) {\n            for (j <- i + 1 until l.length\
    \ - 1) {\n                for (k <- j + 1 until l.length) {\n                \
    \    if (l(i) + l(j) + l(k) == 0) {\n                        return true\n   \
    \                 }\n                }\n            }\n        }\n        return\
    \ false", "        // Your code here\n        false", "        // your code goes\
    \ here\n        return false", '        l.combinations(3).map(p => p.reduceLeft(_
    + _)).filter(_ == 0).size > 0', "        l.sorted.foreach(x => println(x))\n \
    \       true", "        val l2 = l.sortWith(_ < _)\n        //println(l2)\n  \
    \      val l3 = l2.distinct\n        //println(l3)\n        val l4 = l3.groupBy(x\
    \ => x)\n        //println(l4)\n        val l5 = l4.map{case (x, y) => x -> y.length}\n\
    \        //println(l5)\n        var i = 0\n        while (i < l3.length - 2) {\n\
    \            var j = i + 1\n            while (j < l3.length - 1) {\n        \
    \        var k = j + 1\n                while (k < l3.length) {\n            \
    \        //println(l3(i), l3(j), l3(k))\n                    if (l3(i) + l3(j)\
    \ + l3(k) == 0) {\n                        if (l5(l3(i)) > 1 && l5(l3(j)) > 1\
    \ && l5(l3(k)) > 1) {\n                            return true\n             \
    \           }\n                        if (l5(l3(i)) > 1 && l5(l3(j)) > 1 && l5(l3(k))\
    \ == 1) {\n                            return true\n                        }\n\
    \                        if (l5(l3(i)) > 1 && l5(l3(j)) == 1 && l5(l3(k)) > 1)\
    \ {\n                            return true\n                        }\n    \
    \                    if (l5(l3(i)) == 1 && l5(l3(j)) > 1 && l5(l3(k)) > 1) {\n\
    \                            return true\n                        }\n        \
    \                if (l5(l3(i)) > 1 && l5(l3(j)) == 1 && l5(l3(k)) == 1) {\n  \
    \                          return true\n                        }\n          \
    \              if (l5(l3(i)) == 1 && l5(l3(j)) > 1 && l5(l3(k)) == 1) {\n    \
    \                        return true\n                        }\n            \
    \            if (l5(l3(i)) == 1 && l5(l3(j)) == 1 && l5(l3(", "        var arr:Array[Long]\
    \ = l.toArray\n        arr = arr.sorted\n        for (i <- 0 until arr.length\
    \ - 2) {\n            var low:Int = i + 1\n            var high:Int = arr.length\
    \ - 1\n            while (low < high) {\n                var sum:Long = arr(i)\
    \ + arr(low) + arr(high)\n                if (sum == 0) {\n                  \
    \  return true\n                } else if (sum < 0) {\n                    low\
    \ += 1\n                } else {\n                    high -= 1\n            \
    \    }\n            }\n        }\n        return false", "        val m = l.sorted\n\
    \        if (m.size < 3) return false\n        var i = 0\n        while (i < m.size\
    \ - 2) {\n            val j = i + 1\n            val k = m.size - 1\n        \
    \    while (j < k) {\n                val sum = m(i) + m(j) + m(k)\n         \
    \       if (sum == 0) return true\n                else if (sum < 0) j += 1\n\
    \                else k -= 1\n            }\n            i += 1\n        }\n \
    \       return false", '        return false', '        // your code goes here',
  "        val x = l.sorted\n        var i = 0\n        var j = 0\n        var k =\
    \ 0\n        for (i <- 0 to (x.length - 3)) {\n            j = i + 1\n       \
    \     k = x.length - 1\n            while (j < k) {\n                val xi =\
    \ x(i)\n                val xj = x(j)\n                val xk = x(k)\n       \
    \         if (xi + xj + xk == 0) {\n                    return true\n        \
    \        } else if (xi + xj + xk < 0) {\n                    j += 1\n        \
    \        } else {\n                    k -= 1\n                }\n           \
    \ }\n        }\n        return false", "        if (l.size < 3) return false\n\
    \        var (neg, pos) = (Set[Long](), Set[Long]())\n        for (x <- l) {\n\
    \            if (x < 0) neg += x\n            else pos += x\n        }\n     \
    \   for (x <- neg) {\n            for (y <- pos) {\n                if (neg.contains(-x\
    \ - y)) return true\n            }\n        }\n        return false", '        l.combinations(3).toList.exists(_.sum
    == 0)', "        val (left, right) = l.partition(x => x <= 0)\n        if (left.length\
    \ >= 3) left.combinations(3).exists(c => c.sum == 0)\n        else if (right.length\
    \ >= 3) right.combinations(3).exists(c => c.sum == 0)\n        else (left ++ right).combinations(3).exists(c\
    \ => c.sum == 0)", "        // TODO: complete this method\n        return false",
  '        l.combinations(3).map(_.toList).map(_.sum).exists(_ == 0)', "        //\
    \ WRITE YOUR CODE HERE\n        return false", "        // YOUR CODE HERE\n  \
    \      if (l.length < 3) false\n        else {\n            var numHash = new\
    \ HashMap[Long, Long]\n            var b = false\n            for (num <- l) {\n\
    \                if (numHash.contains(num) && numHash(num) == 0l) {\n        \
    \            b = true\n                }\n                else {\n           \
    \         if (numHash.contains(num)) {\n                        numHash(num) +=\
    \ 1\n                    }\n                    else {\n                     \
    \   numHash += ((num, 0l))\n                    }\n                }\n       \
    \     }\n            if (b) true\n            else {\n                for (num\
    \ <- l) {\n                    val pair2 = -num\n                    for (num2\
    \ <- l) {\n                        if (numHash.contains(num2) && numHash(num2)\
    \ == 0l) {\n                            if (num2 == pair2) {\n               \
    \                 b = true\n                            }\n                  \
    \      }\n                        else {\n                            if (numHash.contains(num2))\
    \ {\n                                numHash(num2) += 1\n                    \
    \        }\n                            else {\n                             \
    \   numHash += ((num2, 0l))\n                            }\n                 \
    \       }\n                    }\n                }\n                b\n     \
    \       }\n        }", "        // TODO - Add your code here.\n        false",
  "        // Your code here\n        null", '        ???', "        def helper(l\
    \ : List[Long], n : Int) : Boolean = {\n            if (n == 0) true\n       \
    \     else if (n == 1 && l.length < 3) false\n            else if (n == 1 && l.length\
    \ == 3) l(0) + l(1) + l(2) == 0\n            else if (n == 2 && l.length < 3)\
    \ false\n            else if (n == 2 && l.length == 3) l(0) + l(1) + l(2) == 0\n\
    \            else {\n                val elem = l(n - 1)\n                val\
    \ remaining = l.slice(0, n - 1)\n                helper(remaining, n - 1) || helper(remaining,\
    \ n - 2) || helper(remaining, n - 3)\n            }\n        }\n        if (l.length\
    \ == 0) false\n        else helper(l, l.length)", "\t\t\tif (l.length < 3) return\
    \ false\n\t\t\tfor (i <- 0 until l.length) {\n\t\t\t\tfor (j <- i + 1 until l.length)\
    \ {\n\t\t\t\t\tfor (k <- j + 1 until l.length) {\n\t\t\t\t\t\tif (l(i) + l(j)\
    \ + l(k) == 0) return true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false",
  "        val sum = 0\n        val distinct = l.toSet.toList\n        val sorted\
    \ = distinct.sorted\n        def _isTripleSumToZero(indices : List[Long]) : Boolean\
    \ = {\n            indices match {\n                case Nil => return false\n\
    \                case x :: Nil => return false\n                case x :: y ::\
    \ Nil => return false\n                case x :: y :: z :: rest => {\n       \
    \             if (sorted(x.toInt) + sorted(y.toInt) + sorted(z.toInt) == sum)\
    \ {\n                        return true\n                    }\n            \
    \        else {\n                        return _isTripleSumToZero(List(x, y +\
    \ 1, z + 1))\n                    }\n                }\n            }\n      \
    \  }\n        return _isTripleSumToZero(List(0l, 1l, 2l))", "        // Make a\
    \ set of all items in the list that are less than zero.\n        val negative\
    \ = l.filter((x : Long) => x < 0).toSet\n        // Make a set of all items in\
    \ the list that are greater than zero.\n        val positive = l.filter((x : Long)\
    \ => x > 0).toSet\n        // Make a set of all items in the list that are equal\
    \ to zero.\n        val zero = l.filter((x : Long) => x == 0).toSet\n        //\
    \ Return whether there is a positive item, a negative item, and a zero item.\n\
    \        return positive.exists((p : Long) => negative.exists((n : Long) => zero.exists((z\
    \ : Long) => p + n + z == 0)))", '        l.combinations(3).exists(l => l.sum
    == 0)', '        ???', "        if (l.size < 3) false\n        else {\n      \
    \      var m : Set[Long] = Set()\n            var t : Set[Tuple3[Long, Long, Long]]\
    \ = Set()\n            for (i <- 0 until l.size) {\n                for (j <-\
    \ i + 1 until l.size) {\n                    val a = l(i)\n                  \
    \  val b = l(j)\n                    if (m.contains(-1 * (a + b))) t += ((a, b,\
    \ -1 * (a + b)))\n                    else m += b\n                }\n       \
    \     }\n            if (t.size > 0) true\n            else false\n        }",
  "        l.sort((x, y) => x < y)\n        val l_size = l.size\n        var i = 0\n\
    \        while (i < l_size - 2) {\n            val l_i = l(i)\n            if\
    \ (l_i == 0) {\n                return true\n            }\n            var j\
    \ = i + 1\n            while (j < l_size - 1) {\n                val l_j = l(j)\n\
    \                var k = j + 1\n                while (k < l_size) {\n       \
    \             val l_k = l(k)\n                    if (l_i + l_j + l_k == 0) {\n\
    \                        return true\n                    }\n                \
    \    k += 1\n                }\n                j += 1\n            }\n      \
    \      i += 1\n        }\n        return false", "        if (l.length < 3) {\n\
    \            return false\n        }\n        val _sorted = l.sorted\n       \
    \ for (i <- 0 to _sorted.length - 3) {\n            val a = _sorted(i)\n     \
    \       for (j <- i + 1 to _sorted.length - 2) {\n                val b = _sorted(j)\n\
    \                val c = -(a + b)\n                if (c >= b && binarySearch(_sorted,\
    \ j + 1, _sorted.length - 1, c)) {\n                    return true\n        \
    \        }\n            }\n        }\n        return false", '        return false',
  "        val m : Map[Long, Long] = Map[Long, Long]()\n        val a : List[Long]\
    \ = l\n        var i : Long = 0l\n        var b : List[Long] = List[Long]()\n\
    \        var c : List[Long] = List[Long]()\n        var x : Long = 0l\n      \
    \  var y : Long = 0l\n        var z : Long = 0l\n        var result : Boolean\
    \ = false\n        var d : Long = 0l\n        var e : Long = 0l\n        var f\
    \ : Long = 0l\n        var g : Long = 0l\n        var h : Long = 0l\n        val\
    \ j : Long = ((-1l.toLong) + 1l.toLong)\n        d = 0l\n        e = 0l\n    \
    \    f = 0l\n        g = 0l\n        h = 0l\n        i = 0l\n        while ((i\
    \ < ((a.length.toLong - 1l.toLong) + 1l.toLong))) {\n            b = a.slice((i\
    \ + 1l.toLong), a.length.toLong)\n            d = 0l\n            e = 0l\n   \
    \         f = 0l\n            g = 0l\n            h = 0l\n            while ((d\
    \ < ((b.length.toLong - 1l.toLong) + 1l.toLong))) {\n                c = b.slice((d\
    \ + 1l.toLong), b.length.toLong)\n                e = 0l\n                f =\
    \ 0l\n                g = 0l\n                h = 0l\n                while ((e\
    \ < ((c.length.toLong - 1l.toLong) + 1l.toLong))) {\n                    x = a(i.toInt)\n\
    \                    y = b(d.toInt)\n                    z = c(e.toInt)\n    \
    \                if ((((x + y) + z) == 0l.toLong)) {\n                       \
    \ result = true\n                    }\n                    e = (e + 1l.toLong)\n\
    \                }\n                d = (d + 1l.toLong)\n            }\n     \
    \       i = (i + 1l.toLong)\n        }\n        return result", "        var result\
    \ = false\n        val h = new HashMap[Long, Long]\n        for (v <- l) {\n \
    \           if (h.contains(v)) {\n                h(v) = h(v) + 1\n          \
    \  } else {\n                h += (v -> 1)\n            }\n        }\n       \
    \ for (v <- l) {\n            h(v) = h(v) - 1\n            if (h.contains(v))\
    \ {\n                h(v) = h(v) - 1\n            }\n            if (h.contains(0l.toLong\
    \ - v) && h(0l.toLong - v) > 0) {\n                result = true\n           \
    \ }\n            if (h.contains(v)) {\n                h(v) = h(v) + 1\n     \
    \       }\n            h(v) = h(v) + 1\n        }\n        result", "      //\
    \ // implement this function\n      // return false\n      // val test1 = (List[Long](1l.toLong,\
    \ 3l.toLong, 5l.toLong, 0l.toLong))\n      // val test2 = (List[Long](1l.toLong,\
    \ 3l.toLong, -2l.toLong, 1l.toLong))\n      // val test3 = (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 7l.toLong))\n      // val test4 = (List[Long](2l.toLong,\
    \ 4l.toLong, -5l.toLong, 3l.toLong, 9l.toLong, 7l.toLong))\n      // val test5\
    \ = (List[Long](1l.toLong))\n      // val test6 = (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong))\n      // val test7 = (List[Long](0l.toLong, 2l.toLong, 3l.toLong,\
    \ 0l.toLong))\n      // var res = false\n      // // val l = List(1, 3, -2, 1)\n\
    \      // val result = for {\n      //   i <- 0 until l.length\n      //   j <-\
    \ i+1 until l.length\n      //   k <- j+1 until l.length\n      //   if (l(i)\
    \ + l(j) + l(k) == 0)\n      // } yield (res = true)\n      // val sum = for {\n\
    \      //   i <- 0 until l.length\n      //   j <- i+1 until l.length\n      //\
    \   k <- j+1 until l.length\n      // } yield (l(i) + l(j) + l(k))\n      // //\
    \ println(sum)\n      // if (result.length > 0)\n      //   res = true\n     \
    \ // else\n      //   res = false\n      // println(res)\n      // res\n     \
    \ // // println(result)\n      // val l = List(1, 3, -2, 1)\n      // val test\
    \ = for {\n      //   i <- 0 until l", '        l.sorted.combinations(3).toList.exists(l
    => l.head + l.tail.head + l.tail.tail.head == 0)', "        l.sorted.zipWithIndex.foreach(x\
    \ => {\n            if (triplesSumToZeroHelper(l.drop(x._2 + 1), -x._1)) {\n \
    \               return true\n            }\n        })\n        return false",
  "        if (l.length >= 3) {\n            val h = l.head\n            val rem =\
    \ l.tail\n            val s = rem.foldLeft(false)((acc, x) =>\n              \
    \  acc || rem.foldLeft(false)((acc2, y) =>\n                    acc2 || rem.foldLeft(false)((acc3,\
    \ z) =>\n                        acc3 || (x + y + z == 0)\n                  \
    \  )\n                )\n            )\n            val t = triplesSumToZero(rem)\n\
    \            s || t\n        } else {\n            false\n        }", "      \
    \  // YOUR CODE HERE\n        return false", "        for (x <- l) {\n       \
    \     for (y <- l) {\n                for (z <- l) {\n                    if (x\
    \ != y && x != z && y != z && x + y + z == 0) {\n                        return\
    \ true\n                    }\n                }\n            }\n        }\n \
    \       return false", '        return false', "        // START CODE HERE\n \
    \       val uniqueLongs = l.distinct\n        for (x <- uniqueLongs) {\n     \
    \       for (y <- uniqueLongs) {\n                for (z <- uniqueLongs) {\n \
    \                   if (x != y && x != z && y != z && x + y + z == 0) {\n    \
    \                    return true\n                    }\n                }\n \
    \           }\n        }\n        return false\n        // END CODE HERE", " \
    \       if (l.length < 3) {\n            return false\n        }\n        val\
    \ ll = l.sorted\n        for (i <- 0 to ll.length - 3) {\n            var j =\
    \ i + 1\n            var k = ll.length - 1\n            while (j < k) {\n    \
    \            val sum = ll(i) + ll(j) + ll(k)\n                if (sum == 0) {\n\
    \                    return true\n                } else if (sum < 0) {\n    \
    \                j += 1\n                } else {\n                    k -= 1\n\
    \                }\n            }\n        }\n        return false", "       \
    \ return l.sorted.zipWithIndex.exists({\n            case (n, i) => {\n      \
    \          l.sorted.zipWithIndex.drop(i + 1).exists({\n                    case\
    \ (m, j) => {\n                        val b = -(n + m)\n                    \
    \    return l.sorted.drop(j + 1).exists(m => m == b)\n                    }\n\
    \                })\n            }\n        })", "        // we go through each\
    \ item with a for loop. we then add each possible combination of two\n       \
    \ // items from the list to a hashset to use for quick search of the complement.\n\
    \        // we then iterate through again to see if there is a complement. if\
    \ there is we return true.\n        // if there isn't then we return false.\n\
    \        val found = HashSet[Long]()\n        for (i <- l) {\n            for\
    \ (j <- l) {\n                if (i != j) {\n                    found += i +\
    \ j\n                }\n            }\n        }\n        for (i <- l) {\n   \
    \         if (found.contains(-i)) {\n                return true\n           \
    \ }\n        }\n        return false", "        val result = l.sorted.filter(x\
    \ => x < 0).reverse.combinations(3).find(c => c.sum == 0)\n        if (result.isEmpty)\
    \ {\n            false\n        } else {\n            true\n        }", "    \
    \    val c = l.groupBy((x: Long) => x)\n        c.keys.foreach(x => {\n      \
    \      c.keys.foreach(y => {\n                c.keys.foreach(z => {\n        \
    \            val s = x + y + z\n                    if (s == 0 && x != y && y\
    \ != z && x != z) {\n                        return true\n                   \
    \ }\n                })\n            })\n        })\n        return false", " \
    \       val s = l.toSet\n        for (x <- s) for (y <- s) for (z <- s) {\n  \
    \          if (x < y && y < z && x + y + z == 0) return true\n        }\n    \
    \    return false", "        // TODO: Fill in the implementation details here\n\
    \        var r = false\n        for (x <- l) {\n            for (y <- l) {\n \
    \               for (z <- l) {\n                    if (x + y + z == 0) {\n  \
    \                      r = true\n                    }\n                }\n  \
    \          }\n        }\n        return r", "        var set = Set[Long]()\n \
    \       l.foreach(e => set += e)\n        return false", '        return false',
  "        l.sortWith(_ < _)\n        var flag : Boolean = false\n        for (i <-\
    \ 0 to l.length - 3) {\n            var j : Int = i + 1\n            var k : Int\
    \ = l.length - 1\n            while (j < k) {\n                var sum : Long\
    \ = l(i) + l(j) + l(k)\n                if (sum == 0) {\n                    flag\
    \ = true\n                    return flag\n                }\n               \
    \ else if (sum < 0) j += 1\n                else k -= 1\n            }\n     \
    \   }\n        return flag", "        val ls : Array[Long] = l.sorted.toArray\n\
    \        var s = new HashSet[Long]\n        for (i <- ls) {\n            for (j\
    \ <- ls) {\n                s.add(i + j)\n            }\n        }\n        for\
    \ (i <- ls) {\n            if (s.contains(-i)) return true\n        }\n      \
    \  return false", "        // first, filter out the values that are too small\
    \ to be part of a triple\n        // these are all negative values except 0, which\
    \ has already been tested\n        val filteredList = l.filter(a => (a > 0l))\n\
    \        // then, generate a set containing the squares of the numbers in the\
    \ list.\n        // if, for some element a of the list, -a^2 is not in the set,\
    \ then that\n        // element cannot be part of a triple.\n        val squareSet\
    \ = filteredList.map(a => (a * a)).toSet\n        // if any element of the list\
    \ is not part of a triple, return false\n        if (filteredList.exists(a =>\
    \ !(squareSet.contains(-a * a)))) return false\n        // then, generate a set\
    \ containing the numbers in the list.\n        // if, for some element a of the\
    \ list, -2a is not in the set, then that\n        // element cannot be part of\
    \ a triple.\n        val numberSet = filteredList.toSet\n        // if any element\
    \ of the list is not part of a triple, return false\n        if (filteredList.exists(a\
    \ => !(numberSet.contains(-2l * a)))) return false\n        // if there are elements\
    \ of the list that are not part of a triple, return false\n        // otherwise,\
    \ return true\n        return true", '        return (l.combinations(3).exists(t
    => t.sum == 0))', "        val n = l.length\n        if (n < 3) return false\n\
    \        val r = Array.fill(n){0}\n        r(0) = l(0)\n        for (i <- 1 until\
    \ n) r(i) = r(i - 1) + l(i)\n        var i = 0\n        while (i < n - 2) {\n\
    \            var j = i + 1\n            while (j < n - 1) {\n                var\
    \ k = j + 1\n                while (k < n) {\n                    if (i == 0)\
    \ {\n                        if (r(j - 1) == -r(k)) return true\n            \
    \        } else {\n                        if (r(j - 1) - r(i - 1) == -r(k)) return\
    \ true\n                    }\n                    k += 1\n                }\n\
    \                j += 1\n            }\n            i += 1\n        }\n      \
    \  return false", "        // Insert code here\n        var m : Map[Long, Int]\
    \ = new HashMap()\n        var a : Array[Long] = l.toArray\n        a.foreach\
    \ { v =>\n            if (!m.contains(v)) m += (v -> 1)\n            else m +=\
    \ (v -> (m(v) + 1))\n        }\n        var c : Long = 0\n        for (i <- 0\
    \ until a.length) {\n            for (j <- i + 1 until a.length) {\n         \
    \       c = -(a(i) + a(j))\n                if (c == a(i) && c == a(j)) {\n  \
    \                  if (m(c) >= 3) return true\n                } else if (c ==\
    \ a(i) || c == a(j)) {\n                    if (m(c) >= 2) return true\n     \
    \           } else if (m.contains(c)) return true\n            }\n        }\n\
    \        return false", "        var buffer : ListBuffer[Long] = new ListBuffer[Long]()\n\
    \        buffer ++= l\n        buffer = buffer.sortWith(_<_)\n        var array\
    \ = buffer.toArray\n        for (i <- 0 until array.length) {\n            if\
    \ (i == 0 || array(i) != array(i - 1)) {\n                var j = i + 1\n    \
    \            var k = array.length - 1\n                while (j < k) {\n     \
    \               if (array(i) + array(j) + array(k) == 0) {\n                 \
    \       return true\n                    } else if (array(i) + array(j) + array(k)\
    \ < 0) {\n                        j += 1\n                    } else {\n     \
    \                   k -= 1\n                    }\n                }\n       \
    \     }\n        }\n        return false", "        // IMPLEMENT ME\n        return\
    \ false", '        return false']
stop_tokens:
- "\n    }\n"
