language: scala
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var index = 0\n        var result = new\
    \ ListBuffer[String]()\n        var stack = new Stack[Int]()\n        while (index\
    \ < paren_string.length) {\n            if (paren_string(index) == '(') {\n  \
    \              stack.push(index)\n            } else if (paren_string(index) ==\
    \ ')') {\n                result += paren_string.substring(stack.pop, index +\
    \ 1)\n            }\n            index += 1\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpouqzxycd.scala:25)\n\tat Problem.main(tmpouqzxycd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013069
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        ???\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.separateParenGroups(tmpn441y2h4.scala:11)\n\tat Problem$.main(tmpn441y2h4.scala:14)\n\
    \tat Problem.main(tmpn441y2h4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Create an array of characters from\
    \ the input string\n        val paren_arr = paren_string.toCharArray()\n     \
    \   // Create a stack that will contain all the open parens we haven't closed\
    \ yet\n        var stack = new Stack[Char]()\n        // Create a list that will\
    \ contain the index of each \"prefix\" of the input string.\n        // A prefix\
    \ is any substring of the input string that ends with a close paren and starts\
    \ with the first open paren\n        // For example: \"( ) (( )) (( )( ))\" has\
    \ 3 different prefixes: \"( )\", \"(() )\" and \"(()() )\"\n        var prefixes\
    \ = new ListBuffer[Int]()\n        // Create a list that will contain the index\
    \ of each \"suffix\" of the input string.\n        // A suffix is any substring\
    \ of the input string that starts with an open paren and ends with the last close\
    \ paren\n        // For example: \"( ) (( )) (( )( ))\" has 3 different suffixes:\
    \ \") \", \" ))\" and \" )) )\"\n        var suffixes = new ListBuffer[Int]()\n\
    \        // Create a list that will contain the index of each open paren\n   \
    \     var open_parens = new ListBuffer[Int]()\n        // Create a list that will\
    \ contain the index of each close paren\n        var close_parens = new ListBuffer[Int]()\n\
    \        // Iterate through all the characters in the input string\n        for\
    \ (i <- 0 until paren_arr.length) {\n            // If we see an open paren, push\
    \ it onto the stack\n            if (paren_arr(i) == '(') {\n                stack.push(paren_arr(i))\n\
    \                open_parens += i\n            }\n            // If we see a close\
    \ paren and the stack is empty, then this close paren is a prefix\n          \
    \  else if (paren_arr(i) == ')' && stack.isEmpty) prefixes += i\n            //\
    \ If we see a close paren and the stack is not empty, then pop an open paren off\
    \ the stack\n            else if (paren_arr(i) == ')') {\n                stack.pop()\n\
    \                close_parens += i\n            }\n        }\n        // If there\
    \ are\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpedbdsjd9.scala:28:8\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m until paren_arr.length) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\
    \e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required: List[String]\n\
    \e[31m29 |\e[0m            \e[34m// If we see an open paren, push it onto the\
    \ stack\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m (paren_arr(i) == \e[31m'('\e\
    [0m) {\n\e[31m31 |\e[0m                stack.push(paren_arr(i))\n\e[31m32 |\e\
    [0m                open_parens += i\n\e[31m33 |\e[0m            }\n\e[31m34 |\e\
    [0m            \e[34m// If we see a close paren and the stack is empty, then this\
    \ close paren is a prefix\e[0m\n\e[31m35 |\e[0m            \e[33melse\e[0m \e\
    [33mif\e[0m (paren_arr(i) == \e[31m')'\e[0m && stack.isEmpty) prefixes += i\n\e\
    [31m36 |\e[0m            \e[34m// If we see a close paren and the stack is not\
    \ empty, then pop an open paren off the stack\e[0m\n\e[31m37 |\e[0m          \
    \  \e[33melse\e[0m \e[33mif\e[0m (paren_arr(i) == \e[31m')'\e[0m) {\n\e[31m38\
    \ |\e[0m                stack.pop()\n\e[31m39 |\e[0m                close_parens\
    \ += i\n\e[31m40 |\e[0m            }\n\e[31m41 |\e[0m        }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        return null\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.separateParenGroups(String)\" is null\n\
    \tat Problem$.main(tmpz1v679zw.scala:14)\n\tat Problem.main(tmpz1v679zw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        return List[String]()\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkpfmu9h4.scala:14)\n\tat Problem.main(tmpkpfmu9h4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013069
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val pairs = \"()\"\n        val stack\
    \ = new Stack[Char]\n        var result = new ListBuffer[String]\n        var\
    \ paren_string_arr = paren_string.toCharArray\n        var temp = new ListBuffer[Char]\n\
    \        for (i <- 0 until paren_string_arr.length) {\n            if (paren_string_arr(i)\
    \ == ' ') {\n                //ignore spaces\n            } else if (paren_string_arr(i)\
    \ == pairs(0)) {\n                stack.push(paren_string_arr(i))\n          \
    \  } else if (paren_string_arr(i) == pairs(1)) {\n                if (stack.isEmpty)\
    \ {\n                    return List[String]()\n                } else {\n   \
    \                 stack.pop\n                    if (stack.isEmpty) {\n      \
    \                  result += temp.mkString\n                        temp = new\
    \ ListBuffer[Char]\n                    }\n                }\n            } else\
    \ {\n                if (!stack.isEmpty) {\n                    temp += paren_string_arr(i)\n\
    \                } else {\n                    return List[String]()\n       \
    \         }\n            }\n        }\n        return result.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5yocp97q.scala:42)\n\tat Problem.main(tmp5yocp97q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val stack = ListBuffer[Char]()\n     \
    \   var result = ListBuffer[String]()\n        var temp = ListBuffer[Char]()\n\
    \        paren_string.foreach(c => {\n            if (c == ' ')\n            \
    \    return\n            if (c == '(') {\n                stack.append(c)\n  \
    \              temp.append(c)\n            }\n            else if (c == ')') {\n\
    \                if (stack.isEmpty)\n                    return\n            \
    \    stack.remove(stack.length - 1)\n                temp.append(c)\n        \
    \        if (stack.isEmpty) {\n                    result.append(temp.mkString)\n\
    \                    temp.clear\n                }\n            }\n        })\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdl5j1bu3.scala:16:16\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m                \e[33mreturn\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \         Found:    Unit\n\e[31m   |\e[0m                Required: List[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdl5j1bu3.scala:23:20\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                    \e[33mreturn\e\
    [0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                 Found:    Unit\n\e[31m   |\e[0m                    Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val stack = new Stack[Char]\n        var\
    \ group_start = 0\n        var last_open = 0\n        val groups = ListBuffer[String]()\n\
    \        for (i <- 0 until paren_string.length) {\n            if (paren_string(i)\
    \ == '(') {\n                stack.push('(')\n                if (stack.size ==\
    \ 1) group_start = i\n            } else if (paren_string(i) == ')') {\n     \
    \           stack.pop\n                if (stack.size == 0) {\n              \
    \      groups += paren_string.substring(group_start, i + 1)\n                }\n\
    \            }\n        }\n        groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj_45na48.scala:32)\n\tat Problem.main(tmpj_45na48.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013069
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        throw new Exception(\"Not implemented.\"\
    )\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.Exception: Not implemented.\n\tat Problem$.separateParenGroups(tmpdr4indgs.scala:11)\n\
    \tat Problem$.main(tmpdr4indgs.scala:14)\n\tat Problem.main(tmpdr4indgs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups = List[String]()\n        var\
    \ temp = new StringBuilder()\n        var parenLevel = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                parenLevel += 1\n          \
    \      temp += c\n            } else if (c == ')') {\n                parenLevel\
    \ -= 1\n                temp += c\n            } else if (c == ' ') {\n      \
    \          if (parenLevel == 0) {\n                    groups ::= temp.toString\n\
    \                    temp = new StringBuilder()\n                } else {\n  \
    \                  temp += c\n                }\n            }\n        }\n  \
    \      if (temp.length > 0) groups ::= temp.toString\n        groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2stxu1e2.scala:37)\n\tat Problem.main(tmp2stxu1e2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013069
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val ret = new ArrayBuffer[String]\n  \
    \      if (paren_string.length == 0) {\n            return ret.toList\n      \
    \  }\n        var opened = 0\n        var start = 0\n        for (i <- 0 until\
    \ paren_string.length) {\n            if (paren_string(i) == '(') {\n        \
    \        opened += 1\n            } else if (paren_string(i) == ')') {\n     \
    \           opened -= 1\n            }\n            if (opened == 0) {\n     \
    \           ret += paren_string.substring(start, i + 1)\n                start\
    \ = i + 1\n            }\n        }\n        ret.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpadbt9z8r.scala:31)\n\tat Problem.main(tmpadbt9z8r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_stack = new Stack[Char]()\n\
    \        var result = new ListBuffer[String]()\n        var current_string = new\
    \ StringBuilder()\n        for (i <- 0 until paren_string.length) {\n        \
    \    if (paren_string(i) == '(') {\n                paren_stack.push('(')\n  \
    \              current_string.append('(')\n            } else if (paren_string(i)\
    \ == ')') {\n                paren_stack.pop()\n                current_string.append(')')\n\
    \                if (paren_stack.isEmpty) {\n                    result += current_string.toString\n\
    \                    current_string = new StringBuilder()\n                }\n\
    \            }\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013069
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        ???\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.separateParenGroups(tmpn441y2h4.scala:11)\n\tat Problem$.main(tmpn441y2h4.scala:14)\n\
    \tat Problem.main(tmpn441y2h4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013069
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var retList = List[String]()\n       \
    \ var start = 0\n        var cur : Char = '0'\n        var valid = false\n   \
    \     for (i <- paren_string.indices) {\n            cur = paren_string(i)\n \
    \           if (cur == '(') {\n                valid = true\n                start\
    \ = i\n            }\n            else if (cur == ')') {\n                if (valid)\
    \ {\n                    retList = retList :+ paren_string.substring(start, i\
    \ + 1)\n                    valid = false\n                }\n            }\n\
    \        }\n        retList\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6599f0cv.scala:31)\n\tat Problem.main(tmp6599f0cv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if (paren_string.length == 0) {\n    \
    \        return List()\n        }\n        val paren_groups = new ListBuffer[String]\n\
    \        var buffer = new StringBuilder\n        for (c <- paren_string) {\n \
    \           if (c == ' ') {\n                continue\n            }\n       \
    \     if (c == '(') {\n                buffer.append(c)\n            } else if\
    \ (c == ')') {\n                buffer.append(c)\n                if (buffer.length\
    \ == 2) {\n                    paren_groups += buffer.toString\n             \
    \       buffer = new StringBuilder\n                }\n            }\n       \
    \ }\n        return paren_groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcs4cjfw2.scala:18:16 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                continue\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: continue\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013065
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_list = List[String]()\n    \
    \    var open_count = 0\n        var start_index = 0\n        var i = 0\n    \
    \    for (ch <- paren_string) {\n            if (ch == '(') {\n              \
    \  if (open_count == 0) {\n                    start_index = i\n             \
    \   }\n                open_count += 1\n            } else if (ch == ')') {\n\
    \                open_count -= 1\n                if (open_count == 0) {\n   \
    \                 paren_list = paren_list :+ paren_string.substring(start_index,\
    \ i + 1)\n                }\n            }\n            i += 1\n        }\n  \
    \      paren_list\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcflmvi6p.scala:35)\n\tat Problem.main(tmpcflmvi6p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013069
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var list = List[String]()\n        var\
    \ index = 0\n        var counter = 0\n        var start = 0\n        for (i <-\
    \ 0 until paren_string.length()) {\n            if (paren_string(i) == '(') {\n\
    \                if (counter == 0) start = i\n                counter += 1\n \
    \           }\n            else if (paren_string(i) == ')') {\n              \
    \  counter -= 1\n                if (counter == 0) {\n                    list\
    \ = list :+ paren_string.substring(start, i + 1)\n                }\n        \
    \    }\n        }\n        list\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_qd07u21.scala:33)\n\tat Problem.main(tmp_qd07u21.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013069
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        return null\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.separateParenGroups(String)\" is null\n\
    \tat Problem$.main(tmpz1v679zw.scala:14)\n\tat Problem.main(tmpz1v679zw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.split(\"\\\\(\\\\s*\\\\)\"\
    ).toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptylmzuf9.scala:14)\n\tat Problem.main(tmptylmzuf9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        //var string_builder = new StringBuilder()\n\
    \        var index = 0\n        var groups : List[String] = List()\n        var\
    \ open_count = 0\n        var closed_count = 0\n        for (ch <- paren_string)\
    \ {\n            if (ch == '(') {\n                open_count += 1\n         \
    \   } else if (ch == ')') {\n                closed_count += 1\n            }\n\
    \            if (open_count == closed_count) {\n                groups = groups\
    \ :+ paren_string.substring(index - open_count, index)\n                open_count\
    \ = 0\n                closed_count = 0\n            }\n            index += 1\n\
    \        }\n        return groups\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuigjq8wi.scala:32)\n\tat Problem.main(tmpuigjq8wi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013069
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var parens = paren_string.replaceAll(\"\
    \\\\s\", \"\")\n        var res = new ListBuffer[String]()\n        if (parens.length\
    \ == 0) return res.toList\n        var current = new StringBuilder()\n       \
    \ var stack = new Stack[Char]()\n        var last = 0\n        for (i <- 0 until\
    \ parens.length) {\n            val c = parens(i)\n            c match {\n   \
    \             case '(' => stack.push(c)\n                case ')' => if (stack.isEmpty)\
    \ throw new IllegalArgumentException else stack.pop\n                case _ =>\
    \ throw new IllegalArgumentException\n            }\n            if (stack.isEmpty)\
    \ {\n                res += parens.substring(last, i + 1)\n                last\
    \ = i + 1\n            }\n        }\n        res.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013069
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // solution\n        Nil\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6lgxrzba.scala:15)\n\tat Problem.main(tmp6lgxrzba.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var left_paren_cnt : Int = 0;\n      \
    \  var right_paren_cnt : Int = 0;\n        var group_begins : List[Int] = List();\n\
    \        var group_ends : List[Int] = List();\n        for (i <- 0 until paren_string.length)\
    \ {\n            if (paren_string(i) == '(') left_paren_cnt += 1\n           \
    \ else if (paren_string(i) == ')') right_paren_cnt += 1\n            if (left_paren_cnt\
    \ == right_paren_cnt && left_paren_cnt != 0) {\n                group_ends = i\
    \ :: group_ends;\n                group_begins = i - left_paren_cnt + 1 :: group_begins;\n\
    \                left_paren_cnt = 0;\n                right_paren_cnt = 0;\n \
    \           }\n        }\n        val list_of_groups : List[String] = for (i <-\
    \ 0 until group_begins.length) yield {\n            paren_string.substring(group_begins(i),\
    \ group_ends(i) + 1)\n        }\n        list_of_groups\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv5n_e3me.scala:25:44\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mlist_of_groups\e\
    [0m : \e[35mList\e[0m[\e[35mString\e[0m] = \e[33mfor\e[0m (i <- \e[31m0\e[0m until\
    \ group_begins.length) \e[33myield\e[0m {\n\e[31m\e[31m   |\e[0m             \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                      Found:    \e[1m\e[31mIndexedSeq\e[0m[String]\n\e[31m  \
    \ |\e[0m                                            Required: \e[1m\e[32mList\e\
    [0m[String]\n\e[31m26 |\e[0m            paren_string.substring(group_begins(i),\
    \ group_ends(i) + \e[31m1\e[0m)\n\e[31m27 |\e[0m        }\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_list = List[String]()\n    \
    \    var paren_stack = List[String]()\n        var current_paren = \"(\"\n   \
    \     paren_string.foreach((c : Char) => {\n            if (c == '(') {\n    \
    \            paren_stack = \"(\" :: paren_stack\n            } else if (c == ')')\
    \ {\n                paren_stack = paren_stack.tail\n                if (paren_stack.isEmpty)\
    \ {\n                    paren_list = current_paren :: paren_list\n          \
    \          current_paren = \"(\"\n                }\n            } else if (c\
    \ == ' ') {\n                if (paren_stack.isEmpty) {\n                    paren_list\
    \ = current_paren :: paren_list\n                    current_paren = \"(\"\n \
    \               }\n            } else {\n                current_paren += c\n\
    \            }\n        })\n        paren_list.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_mpjex5_.scala:35)\n\tat Problem.main(tmp_mpjex5_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013069
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val stack = new Stack[Char]\n        val\
    \ parens = paren_string.filter(_ != ' ')\n        var i = 0\n        var group\
    \ = \"\"\n        var groups = List[String]()\n        while (i < parens.length)\
    \ {\n            if (parens(i) == '(') {\n                stack.push(parens(i))\n\
    \            } else {\n                stack.pop\n                if (stack.isEmpty)\
    \ {\n                    groups = groups :+ (group + \")\")\n                \
    \    group = \"\"\n                } else {\n                    group += \")\"\
    \n                }\n            }\n            i += 1\n        }\n        groups\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5xx6ex3t.scala:33)\n\tat Problem.main(tmp5xx6ex3t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013069
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.replaceAll(\" \", \"\").split(\"\
    \\\\(\\\\)\").toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6n3a7npn.scala:14)\n\tat Problem.main(tmp6n3a7npn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013076
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n    \tval s = paren_string.filterNot(_ == ' ')\n\
    \    \tdef helper(i : Int, nested : Int, groups : List[String], accum : String)\
    \ : List[String] = {\n    \t\tif (i == s.length) {\n    \t\t\tgroups.+:(accum)\n\
    \    \t\t} else {\n    \t\t\tif (s(i) == '(') {\n    \t\t\t\thelper(i + 1, nested\
    \ + 1, groups, accum + '(')\n    \t\t\t} else {\n    \t\t\t\tif (nested == 1)\
    \ {\n    \t\t\t\t\thelper(i + 1, 0, groups.+:(accum + ')'), \"\")\n    \t\t\t\t\
    } else {\n    \t\t\t\t\thelper(i + 1, nested - 1, groups, accum + ')')\n    \t\
    \t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \thelper(0, 0, List(), \"\")\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpway8dwro.scala:30)\n\tat Problem.main(tmpway8dwro.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var (i, left_count, right_count, groups)\
    \ = (0, 0, 0, ListBuffer[String]())\n        val paren_string_list = paren_string.filterNot(x\
    \ => \" \".equals(x.toString)).toList\n        for (i <- 0 until paren_string_list.length)\
    \ {\n            if (paren_string_list(i) == '(') left_count += 1\n          \
    \  else if (paren_string_list(i) == ')') right_count += 1\n            if (left_count\
    \ == right_count) {\n                groups += paren_string_list.slice(0, i +\
    \ 1).mkString\n                if (i != paren_string_list.length - 1) separateParenGroups(paren_string_list.slice(i\
    \ + 1, paren_string_list.length).mkString)\n            }\n        }\n       \
    \ groups.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkfgc8et_.scala:24)\n\tat Problem.main(tmpkfgc8et_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_cntr = 0\n        var start_index\
    \ = 0\n        var ret = new ListBuffer[String]()\n        for (i <- 0 until paren_string.length)\
    \ {\n            if (paren_string(i) == '(') paren_cntr += 1\n            else\
    \ if (paren_string(i) == ')') paren_cntr -= 1\n            if (paren_cntr == 0)\
    \ {\n                ret += paren_string.substring(start_index, i + 1)\n     \
    \           start_index = i + 1\n            }\n        }\n        ret.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwm5opz8c.scala:25)\n\tat Problem.main(tmpwm5opz8c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      val open = ListBuffer[Int]()\n      val\
    \ result = ListBuffer[String]()\n      var current = new StringBuilder()\n   \
    \   for (i <- 0 until paren_string.length) {\n        if (paren_string(i) == '(')\
    \ {\n          open += i\n        } else if (paren_string(i) == ')') {\n     \
    \     val start = open.remove(open.length - 1)\n          result += paren_string.substring(start,\
    \ i + 1)\n        }\n      }\n      result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpghwvx3cc.scala:25)\n\tat Problem.main(tmpghwvx3cc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        return List()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk_6eujh9.scala:14)\n\tat Problem.main(tmpk_6eujh9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var i = 0\n        var parens = new ListBuffer[String]\n\
    \        while (i < paren_string.length) {\n            if (paren_string(i) ==\
    \ '(') {\n                var nested = 1\n                var j = i + 1\n    \
    \            while (j < paren_string.length && nested > 0) {\n               \
    \     if (paren_string(j) == '(') nested += 1\n                    else if (paren_string(j)\
    \ == ')') nested -= 1\n                    j += 1\n                }\n       \
    \         parens += paren_string.substring(i, j)\n                i = j\n    \
    \        }\n            else i += 1\n        }\n        parens.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppfzkxmup.scala:33)\n\tat Problem.main(tmppfzkxmup.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result : List[String] = List[String]()\n\
    \        var working_string : String = paren_string\n        while (working_string.size\
    \ > 0) {\n            val open_index = working_string.indexOf('(')\n         \
    \   if (open_index >= 0) {\n                var closing_index = open_index + 1\n\
    \                var open_count = 1\n                while (open_count > 0) {\n\
    \                    if (working_string(closing_index) == '(') {\n           \
    \             open_count += 1\n                    } else if (working_string(closing_index)\
    \ == ')') {\n                        open_count -= 1\n                    }\n\
    \                    closing_index += 1\n                }\n                result\
    \ = result :+ working_string.substring(open_index, closing_index)\n          \
    \      working_string = working_string.substring(closing_index, working_string.size)\n\
    \            } else {\n                working_string = \"\"\n            }\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwcprpzkf.scala:38)\n\tat Problem.main(tmpwcprpzkf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // This is the input string that you need\
    \ to separate into groups\n        var paren_input = paren_string\n        //\
    \ This is the list of groups that you need to return\n        var paren_output\
    \ = List[String]()\n        // This is a stack you can use to temporarily store\
    \ the parentheses you are reading from the input string\n        var paren_stack\
    \ = new scala.collection.mutable.Stack[Char]()\n        // You need to add code\
    \ here to do the following:\n        // 1. Iterate through all the characters\
    \ in the input string\n        // 2. When you see an open brace, push it onto\
    \ the stack\n        // 3. When you see a closed brace, pop the stack and add\
    \ both braces to the paren_output. The last one\n        //    popped is the first\
    \ one added to the output string\n        // 4. If the stack is empty when you\
    \ see a closed brace, then that closed brace has no open brace\n        //   \
    \ to match it. You can handle this in whatever way you choose, but the code should\
    \ not crash.\n        var paren_output_str = \"\"\n        for (char <- paren_input)\
    \ {\n            if (char == ' ') {}\n            else if (char == '(') paren_stack.push(char)\n\
    \            else if (char == ')') {\n                if (paren_stack.length ==\
    \ 0) {}\n                else {\n                    paren_output_str += paren_stack.pop\n\
    \                    paren_output_str += char\n                }\n           \
    \ }\n        }\n        paren_output = paren_output :+ paren_output_str\n    \
    \    return paren_output\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr9zk2i1h.scala:40)\n\tat Problem.main(tmpr9zk2i1h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Write your code here\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp36zuppm3.scala:10:68\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m    \e[33mdef\e[0m \e[36mseparateParenGroups\e\
    [0m(\e[36mparen_string\e[0m : \e[35mString\e[0m) : \e[35mList\e[0m[\e[35mString\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \                   Found:    Unit\n\e[31m   |\e[0m                          \
    \                        Required: List[String]\n\e[31m11 |\e[0m        \e[34m//\
    \ Write your code here\e[0m\n\e[31m12 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013078
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var s = Stack[Int]()\n        var paren_groups\
    \ = ArrayBuffer[String]()\n        var curr_group = new StringBuilder()\n    \
    \    var i = 0\n        while (i < paren_string.length) {\n            paren_string(i)\
    \ match {\n                case '(' => {\n                    if (s.isEmpty) s.push(i)\n\
    \                    else curr_group.append('(')\n                }\n        \
    \        case ')' => {\n                    if (s.isEmpty) throw new IllegalArgumentException(\"\
    Unbalanced parens: \" + paren_string)\n                    else {\n          \
    \              if (s.top == i - 1) {\n                            paren_groups.append(curr_group.toString)\n\
    \                            curr_group = new StringBuilder()\n              \
    \              s.pop\n                        }\n                        else\
    \ curr_group.append(')')\n                    }\n                }\n         \
    \       case ' ' =>\n                case _ => throw new IllegalArgumentException(\"\
    Illegal character in paren string: \" + paren_string)\n            }\n       \
    \     i += 1\n        }\n        if (!s.isEmpty) throw new IllegalArgumentException(\"\
    Unbalanced parens: \" + paren_string)\n        paren_groups.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IllegalArgumentException: Unbalanced parens: (()()) ((())) ()\
    \ ((())()())\n\tat Problem$.separateParenGroups(tmprfor_nig.scala:37)\n\tat Problem$.main(tmprfor_nig.scala:41)\n\
    \tat Problem.main(tmprfor_nig.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups = List[String]()\n        var\
    \ current_group = \"\"\n        var depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                depth += 1\n               \
    \ current_group += c\n            } else if (c == ')') {\n                depth\
    \ -= 1\n                current_group += c\n                if (depth == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') throw new RuntimeException(\"\
    Unrecognized character : \" + c)\n        }\n        groups\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013079
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val parens = paren_string.filter(s =>\
    \ Set('(', ')').contains(s))\n        var results = List[String]()\n        var\
    \ current_result = List[Char]()\n        def helper(current_index : Int, current_paren_count\
    \ : Int) : Unit = {\n            if (current_index == parens.length) {\n     \
    \           results = results :+ current_result.mkString\n                return\n\
    \            }\n            val current_paren = parens(current_index)\n      \
    \      if (current_paren == '(') {\n                helper(current_index + 1,\
    \ current_paren_count + 1)\n                current_result = current_result :+\
    \ current_paren\n                helper(current_index + 1, current_paren_count\
    \ + 1)\n            } else {\n                helper(current_index + 1, current_paren_count\
    \ - 1)\n                current_result = current_result :+ current_paren\n   \
    \             helper(current_index + 1, current_paren_count - 1)\n           \
    \ }\n            current_result = current_result.dropRight(1)\n        }\n   \
    \     helper(0, 0)\n        results\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660013084
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def separateParenGroups(paren_string :\
    \ String, acc : List[String]) : List[String] = {\n            if (paren_string.isEmpty)\
    \ {\n                return acc\n            }\n            var i = 0\n      \
    \      var left = 0\n            while (left >= 0 && i < paren_string.length)\
    \ {\n                val c = paren_string(i)\n                if (c == '(') {\n\
    \                    left += 1\n                } else if (c == ')') {\n     \
    \               left -= 1\n                }\n                i += 1\n       \
    \     }\n            if (left < 0) {\n                separateParenGroups(paren_string.substring(i),\
    \ paren_string.substring(0, i) :: acc)\n            } else {\n               \
    \ separateParenGroups(paren_string.substring(i), acc)\n            }\n       \
    \ }\n        separateParenGroups(paren_string, List())\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpspb0c7ze.scala:35)\n\tat Problem.main(tmpspb0c7ze.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val no_spaces = paren_string.replaceAll(\"\
    \\\\s\", \"\")\n        // read all characters in the string and separate paren\
    \ groups\n        val s = no_spaces.toList\n        var i = 0\n        var l =\
    \ List[String]()\n        while (i < s.length) {\n            var buf = List[Char]()\n\
    \            var paren = 1\n            while (paren > 0) {\n                buf\
    \ = buf :+ s(i)\n                if (s(i) == '(') paren += 1\n               \
    \ else if (s(i) == ')') paren -= 1\n                i += 1\n            }\n  \
    \          l = l :+ buf.mkString\n        }\n        l\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 24\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.separateParenGroups(tmpzz4msaeo.scala:20)\n\tat Problem$.main(tmpzz4msaeo.scala:30)\n\
    \tat Problem.main(tmpzz4msaeo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var i = 0\n        var result = List[String]()\n\
    \        while (i < paren_string.length) {\n            var j = i + 1\n      \
    \      while (j < paren_string.length && paren_string(j) != ' ') j += 1\n    \
    \        result = result :+ paren_string.substring(i, j)\n            i = j +\
    \ 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprqnqaz37.scala:25)\n\tat Problem.main(tmprqnqaz37.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013080
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if (paren_string.length == 0)\n      \
    \      return List(paren_string)\n        val paren_stack = new Stack[Char]\n\
    \        val result = new ListBuffer[String]\n        var current_string = \"\"\
    \n        for (c <- paren_string) {\n            if (c == '(') {\n           \
    \     if (paren_stack.isEmpty)\n                    current_string = \"\"\n  \
    \              paren_stack.push(c)\n            }\n            else if (c == ')')\
    \ {\n                if (paren_stack.isEmpty)\n                    throw new IllegalArgumentException(\"\
    Invalid string\")\n                else {\n                    paren_stack.pop\n\
    \                    if (paren_stack.isEmpty)\n                        result\
    \ += current_string\n                }\n            }\n            else if (c\
    \ != ' ')\n                current_string += c\n        }\n        if (!paren_stack.isEmpty)\n\
    \            throw new IllegalArgumentException(\"Invalid string\")\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnmbdt5ii.scala:39)\n\tat Problem.main(tmpnmbdt5ii.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var open = 0\n        var close = 0\n\
    \        var groups = List[String]()\n        var group = \"\"\n        for (c\
    \ <- paren_string) {\n            if (c == '(') {\n                open += 1\n\
    \                group += \"(\"\n            } else if (c == ')') {\n        \
    \        close += 1\n                group += \")\"\n            }\n         \
    \   if (open == close) {\n                groups = groups :+ group\n         \
    \       group = \"\"\n                open = 0\n                close = 0\n  \
    \          }\n        }\n        groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyj3teulj.scala:33)\n\tat Problem.main(tmpyj3teulj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013080
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val s = paren_string.replaceAll(\"\\\\\
    s\", \"\")\n        var index = 0\n        val groups = new ListBuffer[String]\n\
    \        while (index < s.length) {\n            var left = 0\n            var\
    \ right = 0\n            var i = index\n            while (i < s.length) {\n \
    \               if (s(i) == '(') left += 1\n                else if (s(i) == ')')\
    \ right += 1\n                if (left == right) {\n                    groups\
    \ += s.substring(index, i + 1)\n                    index = i + 1\n          \
    \          i = s.length\n                }\n                i += 1\n         \
    \   }\n        }\n        groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013080
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var ans = List[String]()\n        var\
    \ curr = \"\"\n        var stack = Stack[Char]()\n        for (c <- paren_string)\
    \ {\n            if (c == ' ') {\n                if (stack.size == 0) ans = ans\
    \ :+ curr\n                else curr += c\n            }\n            else if\
    \ (c == '(') {\n                if (stack.size == 0) curr = \"\"\n           \
    \     stack.push(c)\n            }\n            else if (c == ')') {\n       \
    \         stack.pop\n                if (stack.size == 0) {\n                \
    \    ans = ans :+ curr\n                    curr = \"\"\n                }\n \
    \           }\n        }\n        return ans\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpztpgz7na.scala:34)\n\tat Problem.main(tmpztpgz7na.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      var r : List[String] = List()\n      //\
    \ Your code here\n      return r\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiwzunbp5.scala:16)\n\tat Problem.main(tmpiwzunbp5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val res = ListBuffer[String]()\n     \
    \   val st = new Stack[Char]()\n        var cur = \"\"\n        for (c <- paren_string)\
    \ {\n            if (c == ' ') {\n                if (st.isEmpty) {\n        \
    \            res += cur\n                    cur = \"\"\n                }\n \
    \           } else if (c == '(') {\n                st.push(c)\n             \
    \   cur += c\n            } else if (c == ')') {\n                if (st.isEmpty)\
    \ {\n                    println(\"INVALID PAREN STRING!!\")\n               \
    \     return List[String]()\n                }\n                st.pop\n     \
    \           cur += c\n            }\n        }\n        res.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmxsasyhs.scala:35)\n\tat Problem.main(tmpmxsasyhs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013080
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups : List[String] = List()\n \
    \       var current_group : String = \"\"\n        var paren_depth : Int = 0\n\
    \        for (paren <- paren_string) {\n            if (paren == ' ') {\n    \
    \            continue\n            }\n            if (paren == '(') {\n      \
    \          paren_depth += 1\n            }\n            if (paren == ')') {\n\
    \                paren_depth -= 1\n            }\n            current_group +=\
    \ paren\n            if (paren_depth == 0) {\n                groups = groups\
    \ :+ current_group\n                current_group = \"\"\n            }\n    \
    \    }\n        return groups\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpew61d7z5.scala:16:16 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                continue\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: continue\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013077
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_string_clean = paren_string.replaceAll(\"\
    \ \", \"\")\n        var ret = List[String]()\n        var buffer = new StringBuilder()\n\
    \        var i = 0\n        var open_parens = 0\n        var j = 0\n        for\
    \ (i <- 0 until paren_string_clean.length) {\n            if (paren_string_clean(i)\
    \ == '(') {\n                if (open_parens == 0) j = i\n                open_parens\
    \ += 1\n            }\n            else if (paren_string_clean(i) == ')') {\n\
    \                open_parens -= 1\n                if (open_parens == 0) {\n \
    \                   buffer.append(paren_string_clean.substring(j, i + 1))\n  \
    \                  ret = ret :+ buffer.toString\n                    buffer.clear\n\
    \                }\n            }\n        }\n        ret\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013088
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Your code here\n        return null\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.separateParenGroups(String)\" is null\n\
    \tat Problem$.main(tmpeb99npu3.scala:15)\n\tat Problem.main(tmpeb99npu3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013086
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val elements = Stack[Char]()\n       \
    \ val open_parens = Stack[Int]()\n        for (i <- 0 until paren_string.length)\
    \ {\n            val c = paren_string(i)\n            if (c == '(') {\n      \
    \          elements.push(c)\n                open_parens.push(i)\n           \
    \ } else if (c == ')') {\n                if (elements.isEmpty || elements.pop\
    \ != '(') return List()\n                else if (open_parens.length == 1) return\
    \ paren_string.substring(open_parens.pop) :: List()\n                else open_parens.pop\n\
    \            }\n        }\n        if (elements.isEmpty) {\n            val sb\
    \ = new StringBuilder\n            sb.append(paren_string.substring(0, open_parens.pop))\n\
    \            for (i <- 0 until open_parens.length) {\n                sb.append(paren_string.substring(open_parens(i),\
    \ open_parens(i + 1)))\n            }\n            sb.toString :: List()\n   \
    \     } else List()\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3nsi6b1.scala:34)\n\tat Problem.main(tmpf3nsi6b1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013089
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      var current_string = \"\"\n      var out\
    \ = List[String]()\n      var curr_count = 0\n      for (c <- paren_string) {\n\
    \        if (c == '(') {\n          if (curr_count == 0) {\n            current_string\
    \ = current_string + c\n          }\n          curr_count += 1\n        } else\
    \ if (c == ')') {\n          curr_count -= 1\n          if (curr_count == 0) {\n\
    \            current_string = current_string + c\n            out = out :+ current_string\n\
    \            current_string = \"\"\n          }\n        } else if (curr_count\
    \ > 0) {\n          current_string = current_string + c\n        }\n      }\n\
    \      out\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk5y6lz61.scala:34)\n\tat Problem.main(tmpk5y6lz61.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013089
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var stack = new Stack[String]\n      \
    \  var groups = new ListBuffer[String]\n        var isInGroup = false\n      \
    \  for (c <- paren_string) {\n            c match {\n                case '('\
    \ => { if (!isInGroup) { isInGroup = true } ; stack.push(\"(\") }\n          \
    \      case ')' => {\n                    var group = \"\"\n                 \
    \   while (!stack.isEmpty) {\n                        group = stack.pop + group\n\
    \                    }\n                    groups += group\n                \
    \    isInGroup = false\n                }\n                case _ => {}\n    \
    \        }\n        }\n        groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkm0gjd1b.scala:31)\n\tat Problem.main(tmpkm0gjd1b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      var output = new ListBuffer[String]\n  \
    \    var s = new Stack[Char]\n      var i = 0\n      while (i < paren_string.length)\
    \ {\n        if (paren_string(i) == '(') {\n          s.push(paren_string(i))\n\
    \        } else if (paren_string(i) == ')') {\n          if (s.isEmpty) {\n  \
    \          // Unbalanced string\n            throw new Exception(\"Unbalanced\
    \ string\")\n          } else {\n            s.pop\n            if (s.isEmpty)\
    \ {\n              output += paren_string.substring(i-3, i+1)\n            }\n\
    \          }\n        }\n        i += 1\n      }\n      return output.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjim85mpt.scala:33)\n\tat Problem.main(tmpjim85mpt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = ListBuffer[String]()\n\
    \        var current_group = ListBuffer[Char]()\n        var cur_open = 0\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  cur_open += 1\n                current_group += c\n            } else if (c\
    \ == ')') {\n                cur_open -= 1\n                current_group += c\n\
    \            } else if (c == ' ') {\n                continue\n            } else\
    \ {\n                throw new Exception(s\"Unexpected character: $c\")\n    \
    \        }\n            if (cur_open == 0) {\n                paren_groups +=\
    \ current_group.mkString\n                current_group = ListBuffer[Char]()\n\
    \            }\n        }\n        paren_groups.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpodzodi_8.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                continue\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: continue\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013085
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // We will use a stack to parse this string\n\
    \        // For example, if we encounter a '(' character, we will push it onto\
    \ the stack\n        // When we encounter a ')' character, we pop off all the\
    \ '(' characters off the stack\n        // and create a separate string out of\
    \ the characters.\n        var stack = Stack[Char]()\n        var separate_groups\
    \ = List[String]()\n        var current_word = \"\"\n        paren_string.foreach((ch)\
    \ => {\n            if (ch == '(') {\n                // Push onto the stack\n\
    \                stack.push(ch)\n            } else if (ch == ')') {\n       \
    \         // Keep popping off the stack until we have no more '('\n          \
    \      while (stack.top != '(') {\n                    current_word += stack.pop\n\
    \                }\n                // Now we pop off the '(' and add it to the\
    \ current word\n                stack.pop\n                // We have the current\
    \ word, but we need to store it in reverse order\n                separate_groups\
    \ = separate_groups :+ current_word.reverse\n                // Reset the current\
    \ word\n                current_word = \"\"\n            } else if (ch != ' ')\
    \ {\n                // We only add the character to the stack if it is not a\
    \ space\n                stack.push(ch)\n            }\n        })\n        separate_groups\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmf073h5v.scala:41)\n\tat Problem.main(tmpmf073h5v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result = List[String]()\n        var\
    \ level = 0\n        var str = \"\"\n        var record = false\n        paren_string.foreach(c\
    \ => {\n            if (c == '(') {\n                if (level == 0) {\n     \
    \               record = true\n                }\n                level += 1\n\
    \            } else if (c == ')') {\n                level -= 1\n            \
    \    if (level == 0) {\n                    result = str :: result\n         \
    \           str = \"\"\n                    record = false\n                }\n\
    \            } else if (c != ' ') {\n                throw new Exception(\"Invalid\
    \ character\")\n            }\n            if (record) {\n                str\
    \ = c.toString + str\n            }\n        })\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzq7cfsxu.scala:38)\n\tat Problem.main(tmpzq7cfsxu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var last_paren_index = 0\n        var\
    \ paren_group_index = 0\n        var paren_string_group_stack = List[String]()\n\
    \        var paren_string_group_list = List[String]()\n        var paren_string_char_array\
    \ = paren_string.toCharArray()\n        for (i <- 0 until paren_string_char_array.length)\
    \ {\n            if (paren_string_char_array(i) == '(') {\n                paren_group_index\
    \ += 1\n            } else if (paren_string_char_array(i) == ')') {\n        \
    \        paren_group_index -= 1\n            }\n            if (paren_group_index\
    \ == 0) {\n                paren_string_group_stack = paren_string.substring(last_paren_index,\
    \ i + 1) :: paren_string_group_stack\n                last_paren_index = i + 1\n\
    \            }\n        }\n        paren_string_group_stack.foreach(group => {\n\
    \            paren_string_group_list = group.replaceAll(\" \", \"\") :: paren_string_group_list\n\
    \        })\n        paren_string_group_list.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr0dlkogo.scala:33)\n\tat Problem.main(tmpr0dlkogo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def helper(paren_string : String, acc\
    \ : List[String], temp : List[Char]) : List[String] = {\n            if (paren_string.isEmpty)\
    \ acc\n            else if (paren_string.head == '(') helper(paren_string.tail,\
    \ acc, '(' :: temp)\n            else if (paren_string.head == ')') helper(paren_string.tail,\
    \ acc ++ List(temp.tail.reverse.mkString), Nil)\n            else helper(paren_string.tail,\
    \ acc, paren_string.head :: temp)\n        }\n        helper(paren_string, Nil,\
    \ Nil)\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: tail of empty list\n\tat scala.collection.immutable.Nil$.tail(List.scala:664)\n\
    \tat scala.collection.immutable.Nil$.tail(List.scala:661)\n\tat Problem$.helper$1(tmp7iwpsr65.scala:14)\n\
    \tat Problem$.separateParenGroups(tmp7iwpsr65.scala:17)\n\tat Problem$.main(tmp7iwpsr65.scala:20)\n\
    \tat Problem.main(tmp7iwpsr65.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.split(\" \").filter(_ !=\
    \ \"\").map(_.replaceAll(\"\\\\(\",\"( \").replaceAll(\"\\\\)\",\" )\")).map(_.split(\"\
    \ \").filter(_ != \"\")).map(_.foldLeft(\"\")(_ + _)).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4_drlc5m.scala:17)\n\tat Problem.main(tmp4_drlc5m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // TODO: Implement me!\n        return\
    \ null\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.separateParenGroups(String)\" is null\n\
    \tat Problem$.main(tmpa0zprryt.scala:15)\n\tat Problem.main(tmpa0zprryt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013089
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // remove spaces\n        val str = paren_string.replaceAll(\"\
    \\\\s\", \"\")\n        val n = str.length\n        var result = List[String]()\n\
    \        var groups = new ArrayBuffer[ArrayBuffer[Char]]()\n        var cnt =\
    \ 0\n        for (i <- 0 until n) {\n            if (str(i) == '(') {\n      \
    \          if (cnt == 0) {\n                    groups += new ArrayBuffer[Char]()\n\
    \                }\n                cnt += 1\n            } else {\n         \
    \       cnt -= 1\n            }\n            groups(groups.length - 1) += str(i)\n\
    \        }\n        for (e <- groups) {\n            result = result :+ e.mkString\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // ListBuffer is like List but you can\
    \ append/prepend to it.\n        var ret = ListBuffer[String]()\n        var cur_paren_string\
    \ = \"\"\n        var num_open_parens = 0\n        for (cur_char <- paren_string)\
    \ {\n            if (cur_char == '(') {\n                num_open_parens += 1\n\
    \                cur_paren_string += cur_char\n            } else if (cur_char\
    \ == ')') {\n                num_open_parens -= 1\n                cur_paren_string\
    \ += cur_char\n                if (num_open_parens == 0) {\n                 \
    \   ret += cur_paren_string\n                    cur_paren_string = \"\"\n   \
    \             }\n            }\n        }\n        return ret.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      var stack = new Stack[Int]()\n      var\
    \ result = new ListBuffer[String]()\n      var start = 0\n      for (i <- 0 until\
    \ paren_string.length) {\n        if (paren_string(i) == '(') stack.push(i)\n\
    \        else if (paren_string(i) == ')') {\n          if (stack.isEmpty) throw\
    \ new Exception(\"Extra right paren\")\n          var left_idx = stack.pop\n \
    \         if (stack.isEmpty) {\n            result += paren_string.substring(start,\
    \ i + 1)\n            start = i + 1\n          }\n        }\n      }\n      if\
    \ (!stack.isEmpty) throw new Exception(\"Extra left paren\")\n      result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzpp8ps9m.scala:29)\n\tat Problem.main(tmpzpp8ps9m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result : List[String] = List();\n\
    \        var parenStack : List[Char] = List();\n        var i : Int = 0;\n   \
    \     var cur : Int = 0;\n        while (i < paren_string.length) {\n        \
    \    paren_string(i) match {\n                case '(' => {\n                \
    \    parenStack = paren_string(i) :: parenStack;\n                    if (parenStack.length\
    \ == 1) cur = i;\n                }\n                case ')' => {\n         \
    \           if (parenStack.length > 0) {\n                        parenStack =\
    \ parenStack.tail;\n                        if (parenStack.length == 0) {\n  \
    \                          result = paren_string.substring(cur, i + 1) :: result;\n\
    \                        }\n                    }\n                }\n       \
    \         case _ => {}\n            }\n            i += 1;\n        }\n      \
    \  return result;\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj5nj1c5k.scala:36)\n\tat Problem.main(tmpj5nj1c5k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val groups = ListBuffer[String]()\n  \
    \      var group = \"\"\n        var counter = 0\n        for (i <- 0 until paren_string.length)\
    \ {\n            paren_string(i) match {\n                case '(' => counter\
    \ += 1\n                case ')' => counter -= 1\n                case _ => {}\n\
    \            }\n            group += paren_string(i)\n            if (counter\
    \ == 0) {\n                groups += group\n                group = \"\"\n   \
    \         }\n        }\n        groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdqs8p70f.scala:29)\n\tat Problem.main(tmpdqs8p70f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        return List()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk_6eujh9.scala:14)\n\tat Problem.main(tmpk_6eujh9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // >>> separateParenGroups((\"( ) (( ))\
    \ (( )( ))\"))\n        // (List[String](\"()\", \"(())\", \"(()())\"))\n    \
    \    paren_string.split(\"\\\\s\").filter(x => x.length > 0).toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_xdm38a8.scala:19)\n\tat Problem.main(tmp_xdm38a8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if (paren_string.isEmpty) return List[String]()\n\
    \        var current_string = \"\"\n        var index = 0\n        val answer\
    \ = ListBuffer[String]()\n        var open_count = 0\n        while (index < paren_string.length)\
    \ {\n            if (paren_string(index) == '(') {\n                open_count\
    \ += 1\n                current_string += '('\n            } else if (paren_string(index)\
    \ == ')') {\n                open_count -= 1\n                current_string +=\
    \ ')'\n            }\n            if (open_count == 0) {\n                answer\
    \ += current_string\n                current_string = \"\"\n            }\n  \
    \          index += 1\n        }\n        return answer.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphnpxieh2.scala:33)\n\tat Problem.main(tmphnpxieh2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = ListBuffer[String]()\n\
    \        var stack = ListBuffer[Char]()\n        for (paren <- paren_string) {\n\
    \            if (paren == '(') {\n                stack += paren\n           \
    \ } else if (paren == ')') {\n                stack.remove(stack.length - 1)\n\
    \                if (stack.isEmpty) {\n                    paren_groups += paren_string.substring(paren_string.indexOf('('),\
    \ paren_string.indexOf(')') + 1)\n                }\n            }\n        }\n\
    \        paren_groups.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuemnd_co.scala:26)\n\tat Problem.main(tmpuemnd_co.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val groups = new ListBuffer[String]\n\
    \        var current = \"\"\n        val open_braces = new Stack[Int]\n      \
    \  for (i <- 0 until paren_string.length) {\n            if (paren_string(i) ==\
    \ '(') {\n                open_braces.push(i)\n            } else if (paren_string(i)\
    \ == ')') {\n                val start = open_braces.pop\n                current\
    \ += paren_string.substring(start, i + 1)\n                if (open_braces.isEmpty)\
    \ {\n                    groups += current\n                    current = \"\"\
    \n                }\n            }\n        }\n        groups.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp69u9j_69.scala:29)\n\tat Problem.main(tmp69u9j_69.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_string_no_spaces_char_arr = paren_string_no_spaces.toCharArray\n\
    \        var paren_arr_list = List[String]()\n        for (i <- 0 until paren_string_no_spaces_char_arr.length)\
    \ {\n            var paren_str = \"\"\n            var count = 0\n           \
    \ for (j <- i until paren_string_no_spaces_char_arr.length) {\n              \
    \  if (paren_string_no_spaces_char_arr(j) == '(') {\n                    count\
    \ += 1\n                } else if (paren_string_no_spaces_char_arr(j) == ')')\
    \ {\n                    count -= 1\n                }\n                paren_str\
    \ += paren_string_no_spaces_char_arr(j)\n                if (count == 0) {\n \
    \                   paren_arr_list = paren_arr_list :+ paren_str\n           \
    \         i = j\n                    break\n                }\n            }\n\
    \        }\n        return paren_arr_list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpojlxvwzv.scala:26:22 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    i = j\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment to\
    \ val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpojlxvwzv.scala:27:20\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    break\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.filter(_ != ' ').split(\"\
    \\\\)\\\\(\").toList.map(_ + \")\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppomf3gmt.scala:14)\n\tat Problem.main(tmppomf3gmt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013098
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n    \tvar groups : List[String] = List[String]()\n\
    \    \tvar current_group : String = \"\"\n    \tvar paren_stack : Stack[Char]\
    \ = Stack[Char]()\n    \tfor (c <- paren_string) {\n    \t\tif (c == ' ') {\n\
    \    \t\t\tcontinue\n    \t\t}\n    \t\tif (c == '(') {\n    \t\t\tparen_stack.push(c)\n\
    \    \t\t}\n    \t\telse if (c == ')') {\n    \t\t\tparen_stack.pop()\n    \t\t\
    }\n    \t\tcurrent_group += c\n    \t\tif (paren_stack.isEmpty) {\n    \t\t\t\
    groups = groups :+ current_group\n    \t\t\tcurrent_group = \"\"\n    \t\t}\n\
    \    \t}\n    \treturn groups\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpglrjnlzc.scala:16:8 -------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m    \t\t\tcontinue\n\e[31m\e[31m   |\e[0m    \t\t\t^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m    \t\t\tNot found: continue\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013093
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result = List[String]()\n        var\
    \ cur_str = new StringBuilder\n        var paren_count = 0\n        for (c <-\
    \ paren_string) {\n            if (c == '(') {\n                paren_count +=\
    \ 1\n                cur_str += c\n            } else if (c == ')') {\n      \
    \          paren_count -= 1\n                cur_str += c\n                if\
    \ (paren_count == 0) {\n                    result = cur_str.toString :: result\n\
    \                    cur_str = new StringBuilder\n                }\n        \
    \    } else if (c != ' ') {\n                cur_str += c\n            }\n   \
    \     }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7dsouhda.scala:32)\n\tat Problem.main(tmp7dsouhda.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013098
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // We need to define an actual stack structure\
    \ and not use the standard library for this.\n        // Let's define a basic\
    \ linked list\n        class Stack[T] {\n            class Node[T](val data :\
    \ T, var next : Node[T])\n            var head : Node[T] = null\n            def\
    \ push(data : T) = {\n                val tmp = new Node(data, head)\n       \
    \         head = tmp\n            }\n            def pop() : T = {\n         \
    \       val tmp = head.data\n                head = head.next\n              \
    \  tmp\n            }\n            def peek() : T = head.data\n            def\
    \ empty() : Boolean = head == null\n        }\n        // Now we use our stack\
    \ to find the groups\n        val stack = new Stack[(Int, Int)]\n        val list\
    \ = new ListBuffer[String]\n        var found = false\n        var paren_count\
    \ = 0\n        var first = 0\n        var last = 0\n        for (i <- 0 until\
    \ paren_string.length) {\n            if (paren_string(i) == '(') {\n        \
    \        if (!found) {\n                    first = i\n                    found\
    \ = true\n                }\n                paren_count += 1\n              \
    \  stack.push(i)\n            }\n            else if (paren_string(i) == ')')\
    \ {\n                if (paren_count > 0) {\n                    stack.pop()\n\
    \                    paren_count -= 1\n                }\n                else\
    \ stack.push(i)\n            }\n            if (paren_count == 0 && !stack.empty())\
    \ {\n                last = i\n                list += paren_string.substring(first,\
    \ last + 1)\n                stack.pop()\n                found = false\n    \
    \        }\n        }\n        list.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkhsi3581.scala:42:27\
    \ --------------------\e[0m\e[0m\n\e[31m42 |\e[0m                stack.push(i)\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Found:    (\e[1m\e[31mi\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e\
    [0m Int)\n\e[31m   |\e[0m                           Required: (\e[1m\e[32mInt\e\
    [0m\e[1m\e[32m,\e[0m Int)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpkhsi3581.scala:49:32 --------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m                \e[33melse\e[0m stack.push(i)\n\e[31m\e[31m   |\e[0m \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \          Found:    (\e[1m\e[31mi\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m Int)\n\
    \e[31m   |\e[0m                                Required: (\e[1m\e[32mInt\e[0m\e\
    [1m\e[32m,\e[0m Int)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013099
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.replaceAll(\"\\\\s+\", \"\
    \").split(\"((\\\\()\\\\))\").toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpibj6_du5.scala:14)\n\tat Problem.main(tmpibj6_du5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013100
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var ans = new ListBuffer[String]\n   \
    \     var i = 0\n        var s = new StringBuilder\n        var num_open = 0\n\
    \        var num_close = 0\n        while (i < paren_string.length) {\n      \
    \      if (paren_string(i) == '(') {\n                s.append('(')\n        \
    \        num_open += 1\n            } else if (paren_string(i) == ')') {\n   \
    \             s.append(')')\n                num_close += 1\n            }\n \
    \           if (num_open == num_close) {\n                ans += s.toString\n\
    \                s = new StringBuilder\n                num_open = 0\n       \
    \         num_close = 0\n            }\n            i += 1\n        }\n      \
    \  ans.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9cm306mk.scala:35)\n\tat Problem.main(tmp9cm306mk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013101
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // HashMap of the strings and their corresponding\
    \ int positions\n        var paren_groups = new HashMap[String, List[Int]]()\n\
    \        var paren_count : Int = 0\n        // Iterate through each parenthesis\
    \ in the string, keeping track of the paren count at each step\n        for (i\
    \ <- 0 until paren_string.length) {\n            // If the character is an open\
    \ paren, increment the paren count\n            if (paren_string(i) == '(') {\n\
    \                paren_count += 1\n            }\n            // If the character\
    \ is a closed paren, decrement the paren count\n            else if (paren_string(i)\
    \ == ')') {\n                paren_count -= 1\n            }\n            // If\
    \ the paren count is 0, the paren group we have iterated through is complete.\
    \ Store this group\n            // in the HashMap\n            if (paren_count\
    \ == 0) {\n                paren_groups += (paren_string.substring(0, i + 1) ->\
    \ List[Int](0, i))\n                // Update the string to remove the current\
    \ paren group. Set the paren_count back to 0\n                paren_string = paren_string.substring(i\
    \ + 1, paren_string.length)\n                paren_count = 0\n               \
    \ // Reset the iterator\n                i = 0\n            }\n        }\n   \
    \     var paren_group_list : List[String] = List[String]()\n        // Iterate\
    \ through the list of keys in the HashMap. Strip the spaces and push each key\
    \ to the paren_group_list\n        for (key <- paren_groups.keys) {\n        \
    \    paren_group_list = paren_group_list :+ key.replaceAll(\"\\\\s+\", \"\")\n\
    \        }\n        return paren_group_list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpimojtv5l.scala:29:29 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                paren_string = paren_string.substring(i\
    \ + \e[31m1\e[0m, paren_string.length)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val paren_string\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpimojtv5l.scala:32:18 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                i = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to\
    \ val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013097
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups = List[String]()\n        var\
    \ open = 0\n        var parens = \"\"\n        for (paren <- paren_string) {\n\
    \            if (paren == '(') open += 1\n            else if (paren == ')') open\
    \ -= 1\n            if (open > 0) parens += paren\n            if (open == 0 &&\
    \ parens != \"\") {\n                groups = groups :+ parens\n             \
    \   parens = \"\"\n            }\n        }\n        groups\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp879hl3ml.scala:26)\n\tat Problem.main(tmp879hl3ml.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013101
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n    \tval l = paren_string.length\n    \tvar n\
    \ : List[String] = List()\n    \tvar i = 0\n    \tvar j = 0\n    \twhile (i <\
    \ l) {\n    \t\twhile (paren_string(i) == ' ') {\n    \t\t\ti += 1\n    \t\t}\n\
    \    \t\tj = i\n    \t\twhile (paren_string(j) != ' ') {\n    \t\t\tj += 1\n \
    \   \t\t}\n    \t\tn = n :+ paren_string.substring(i, j)\n    \t\ti = j\n    \t\
    }\n    \tn\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: String index out of range: 27\n\
    \tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\
    \tat scala.collection.StringOps$.apply$extension(StringOps.scala:185)\n\tat Problem$.separateParenGroups(tmppgjbjzi3.scala:20)\n\
    \tat Problem$.main(tmppgjbjzi3.scala:29)\n\tat Problem.main(tmppgjbjzi3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013100
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        //List(\"()\", \"(())\", \"(()())\", \"\
    (()(()))\")\n        paren_string.trim().split(\"[ ]+\").toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyme_qhmv.scala:18)\n\tat Problem.main(tmpyme_qhmv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013100
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var open_braces = 0\n        var open_parens\
    \ = 0\n        var groups = ListBuffer[String]()\n        var current_group =\
    \ \"\"\n        for (ch <- paren_string) {\n            if (ch == '(') {\n   \
    \             open_parens += 1\n                if (open_braces == 0)\n      \
    \              open_braces = 1\n            }\n            else if (ch == ')')\
    \ {\n                open_parens -= 1\n                if (open_parens == 0) {\n\
    \                    open_braces = 0\n                    groups += current_group\n\
    \                    current_group = \"\"\n                }\n            }\n\
    \            else if (ch != ' ') {\n                if (open_braces > 0)\n   \
    \                 current_group += ch\n            }\n        }\n        groups.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp912794wu.scala:37)\n\tat Problem.main(tmp912794wu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013101
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        return List(\"()\", \"(())\", \"(()())\"\
    )\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptk_s_7hp.scala:14)\n\tat Problem.main(tmptk_s_7hp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013100
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val arr : Array[Char] = paren_string.toCharArray()\n\
    \        val str : ListBuffer[String] = ListBuffer[String]()\n        val temp\
    \ : StringBuilder = new StringBuilder(\"\")\n        var cnt : Int = 0\n     \
    \   for (i <- 0 until arr.length) {\n            if (arr(i) == '(') {\n      \
    \          cnt += 1\n                temp.append('(')\n            } else if (arr(i)\
    \ == ')') {\n                cnt -= 1\n                temp.append(')')\n    \
    \        }\n            if (cnt == 0) {\n                str += temp.toString()\n\
    \                temp.clear()\n            }\n        }\n        str.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx698qnxh.scala:31)\n\tat Problem.main(tmpx698qnxh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013101
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.filter(_ != ' ').split(\"\
    \").foldLeft((List[String](), 0))((acc, c) => {\n            c match {\n     \
    \           case \"(\" => (acc._1 :+ \"\", acc._2 + 1)\n                case \"\
    )\" => if (acc._2 == 1) (acc._1 :+ \")\", 0) else (acc._1.init :+ (acc._1.last\
    \ + \")\"), acc._2 - 1)\n                case other => (acc._1.init :+ (acc._1.last\
    \ + other), acc._2)\n            }\n        })._1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprsmlen6f.scala:20)\n\tat Problem.main(tmprsmlen6f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013101
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val group = new Stack[String]\n      \
    \  var current = \"\"\n        for (ch <- paren_string) ch match {\n         \
    \   case '(' => group.push(current)\n                current = \"\"\n        \
    \    case ')' => current = group.pop + current + \")\"\n                println(current)\n\
    \            case ' ' =>\n            case _ => current += ch\n        }\n   \
    \     if (current != \"\") group.push(current)\n        group.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9hd9kop1.scala:25)\n\tat Problem.main(tmp9hd9kop1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ')

    ))

    )))

    )

    ))

    ))))))

    )))))))

    )

    ))

    )))

    ))))

    ))))))))))))

    '
  timestamp: 1660013101
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups = new ListBuffer[String]\n\
    \        var group_index = 0\n        var paren_count = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                if (paren_count == 0) {\n  \
    \                  groups += \"\"\n                }\n                paren_count\
    \ += 1\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                if (paren_count == 0) {\n                    group_index += 1\n\
    \                }\n            } else if (c != ' ') {\n                groups(group_index)\
    \ += c\n            }\n        }\n        groups.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwsywysgq.scala:32)\n\tat Problem.main(tmpwsywysgq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013101
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val stack = new Stack[Char]\n        val\
    \ words = new ArrayBuffer[String]\n        var word = new StringBuilder\n    \
    \    for (c <- paren_string) {\n            if (c == ' ') {\n                if\
    \ (word.length > 0) {\n                    words += word.toString\n          \
    \          word = new StringBuilder\n                }\n            } else if\
    \ (c == '(') {\n                if (word.length > 0) {\n                    words\
    \ += word.toString\n                    word = new StringBuilder\n           \
    \     }\n                stack.push(c)\n            } else if (c == ')') {\n \
    \               stack.pop\n                if (stack.isEmpty) {\n            \
    \        words += word.toString\n                    word = new StringBuilder\n\
    \                } else {\n                    word += c\n                }\n\
    \            } else {\n                word += c\n            }\n        }\n \
    \       words.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2_b2wj8q.scala:41)\n\tat Problem.main(tmp2_b2wj8q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013102
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result = List[String]()\n        var\
    \ stack = Stack[Int]()\n        var start = 0\n        var end = 0\n        for\
    \ (i <- 0 until paren_string.length) {\n            if (paren_string(i) == '(')\
    \ {\n                stack.push(1)\n                if (stack.size == 1) start\
    \ = i\n            }\n            else if (paren_string(i) == ')') {\n       \
    \         stack.pop\n                if (stack.size == 0) {\n                \
    \    end = i\n                    result = result :+ paren_string.substring(start,\
    \ end + 1)\n                }\n            }\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjgqo26o_.scala:34)\n\tat Problem.main(tmpjgqo26o_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013101
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var buffer = new StringBuilder\n     \
    \   var prev_c = '\\0'\n        var stack : List[Char] = Nil\n        var result\
    \ : List[String] = Nil\n        for (c <- paren_string) {\n            if (c ==\
    \ ' ') {\n                // Ignore spaces\n            } else if (c == '(') {\n\
    \                stack = c :: stack\n            } else if (c == ')') {\n    \
    \            if (stack.isEmpty) return Nil\n                stack = stack.tail\n\
    \                if (stack.isEmpty) {\n                    result = buffer.toString\
    \ :: result\n                    buffer = new StringBuilder\n                }\n\
    \            } else {\n                buffer.append(c)\n            }\n     \
    \   }\n        result.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpcb__i5l2.scala:12:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mprev_c\e[0m = \e[31m'\\\
    0'\e[0m\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m  \
    \             octal escape literals are unsupported: use \\u0000 instead\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013098
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_stack = new Stack[Char]\n  \
    \      var current_string = new StringBuffer\n        var result = new ListBuffer[String]\n\
    \        for (c <- paren_string.filter(_ != ' ')) {\n            if (c == '(')\
    \ {\n                paren_stack.push(c)\n            } else if (c == ')') {\n\
    \                if (paren_stack.length > 0) {\n                    paren_stack.pop\n\
    \                    if (paren_stack.length == 0) {\n                        result\
    \ += current_string.toString\n                        current_string = new StringBuffer\n\
    \                    }\n                }\n            }\n            if (paren_stack.length\
    \ > 0) {\n                current_string += c\n            }\n        }\n    \
    \    result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1akcxq1g.scala:27:31 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                current_string += c\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of StringBuffer - did you mean StringBuffer.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660013100
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_stack = new Stack[Char]\n  \
    \      var result = new ListBuffer[String]\n        var current_string = new StringBuilder\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    paren_stack.push(c)\n            } else if (c == ')') {\n               \
    \ if (paren_stack.isEmpty) {\n                    return Nil\n               \
    \ } else {\n                    paren_stack.pop\n                    if (paren_stack.isEmpty)\
    \ {\n                        result += current_string.toString\n             \
    \           current_string = new StringBuilder\n                    }\n      \
    \          }\n            } else if (c != ' ') {\n                return Nil\n\
    \            }\n        }\n        if (!paren_stack.isEmpty) {\n            return\
    \ Nil\n        }\n        return result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptj0_kxk6.scala:37)\n\tat Problem.main(tmptj0_kxk6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013102
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result = new ListBuffer[String]\n\
    \        var curr = \"\"\n        var paren_count = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                paren_count += 1\n         \
    \       curr += c\n            } else if (c == ')') {\n                if (paren_count\
    \ == 1) {\n                    result += curr + \")\"\n                    curr\
    \ = \"\"\n                } else {\n                    curr += c\n          \
    \      }\n                paren_count -= 1\n            }\n        }\n       \
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013102
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result = List[String]()\n        var\
    \ temp = \"\"\n        var paren_stack = Stack[Char]()\n        for (x <- paren_string)\
    \ {\n            if (x == '(') {\n                paren_stack.push(x)\n      \
    \      } else if (x == ')') {\n                if (paren_stack.isEmpty) {\n  \
    \                  throw new IllegalArgumentException(\"Invalid\")\n         \
    \       } else {\n                    temp += x\n                    paren_stack.pop\n\
    \                    if (paren_stack.isEmpty) {\n                        result\
    \ = temp :: result\n                        temp = \"\"\n                    }\n\
    \                }\n            } else if (x != ' ') {\n                throw\
    \ new IllegalArgumentException(\"Invalid character in string\")\n            }\n\
    \        }\n        if (!paren_stack.isEmpty) {\n            throw new IllegalArgumentException(\"\
    Not all parens closed\")\n        }\n        result.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppxwv5k_n.scala:38)\n\tat Problem.main(tmppxwv5k_n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013102
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var stack = new Stack[Char]\n        var\
    \ groups = new ListBuffer[String]\n        var group = new StringBuilder\n   \
    \     def add_parenthesis(paren : Char) : Unit = {\n            group += paren\n\
    \            stack.push(paren)\n        }\n        def close_parenthesis : Unit\
    \ = {\n            group += stack.pop\n        }\n        def close_paren_group\
    \ = {\n            groups += group.toString\n            group = new StringBuilder\n\
    \        }\n        paren_string.foreach {\n            case '(' => add_parenthesis('(')\n\
    \            case ')' => close_parenthesis\n            case ' ' => // do nothing\n\
    \            case _ => throw new Exception(\"Unexpected parenthesis type\")\n\
    \        }\n        if (stack.length != 0) {\n            throw new Exception(\"\
    Unbalanced parenthesis\")\n        }\n        groups.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm8z830si.scala:37)\n\tat Problem.main(tmpm8z830si.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Parse the string and return List containing\
    \ the groupings\n        // You can assume that the provided string is well-formed.\n\
    \        //\n        // For example, if the input string is:\n        //     \"\
    ( ) (( )) (( )( ))\"\n        // The resulting List should be:\n        //   \
    \  (List[String](\"()\", \"(())\", \"(()())\"))\n        ???\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.separateParenGroups(tmpvj2x8by3.scala:18)\n\tat Problem$.main(tmpvj2x8by3.scala:21)\n\
    \tat Problem.main(tmpvj2x8by3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013107
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var non_spaces = List[Char]()\n      \
    \  for (c <- paren_string) {\n            if (c != ' ') {\n                non_spaces\
    \ = non_spaces :+ c\n            }\n        }\n        val paren_string_no_spaces\
    \ = non_spaces.mkString\n        var nested_groups = List[String]()\n        var\
    \ current_string = \"\"\n        var paren_count = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                paren_count += 1\n         \
    \   }\n            if (c == ')') {\n                paren_count -= 1\n       \
    \     }\n            current_string += c\n            if (paren_count == 0) {\n\
    \                nested_groups = nested_groups :+ current_string\n           \
    \     current_string = \"\"\n            }\n        }\n        nested_groups\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013109
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val pattern = new Regex(\"(?<=\\\\()[^()]*(?=\\\
    \\))\")\n        pattern.findAllIn(paren_string).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyptydlvv.scala:11:26 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mpattern\e[0m = \e[33mnew\e\
    [0m \e[35mRegex\e[0m(\e[31m\"(?<=\\\\()[^()]*(?=\\\\))\"\e[0m)\n\e[31m\e[31m \
    \  |\e[0m                          ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \           Not found: type Regex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val groups = ListBuffer[String]()\n  \
    \      val parens = ListBuffer[Char]()\n        for (c <- paren_string if c !=\
    \ ' ') {\n            parens += c\n        }\n        //println(parens)\n    \
    \    val stack = ListBuffer[Char]()\n        var i = 0\n        var done = false\n\
    \        while (i < parens.length && !done) {\n            if (parens(i) == '(')\
    \ {\n                stack += parens(i)\n            } else {\n              \
    \  if (stack.length > 0) {\n                    stack.remove(stack.length - 1)\n\
    \                } else {\n                    groups += parens.slice(0, i).mkString\n\
    \                    parens.remove(0, i)\n                    i = 0\n        \
    \        }\n            }\n            i += 1\n            if (i == parens.length)\
    \ {\n                groups += parens.mkString\n                done = true\n\
    \            }\n        }\n        groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfcitgr_4.scala:41)\n\tat Problem.main(tmpfcitgr_4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013109
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val groups = Buffer[String]()\n      \
    \  var cur_group = new StringBuilder\n        var open_parens = 0\n        for\
    \ (c <- paren_string) {\n            if (c == '(') {\n                if (open_parens\
    \ == 0) {\n                    cur_group.clear\n                }\n          \
    \      open_parens += 1\n                cur_group += c\n            } else if\
    \ (c == ')') {\n                open_parens -= 1\n                cur_group +=\
    \ c\n                if (open_parens == 0) {\n                    groups += cur_group.toString\n\
    \                }\n            } else if (c == ' ') {\n                // ignore\n\
    \            } else {\n                // should never get here\n            \
    \    throw new Exception(\"invalid paren string\")\n            }\n        }\n\
    \        return groups.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013110
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val parenGroupList = ListBuffer[String]()\n\
    \        // Track number of open and close parentheses\n        var openParens\
    \ = 0\n        var closeParens = 0\n        // Track each group of parentheses\n\
    \        var parenGroup = new StringBuilder\n        paren_string.filter(_ !=\
    \ ' ').foreach { char =>\n            parenGroup += char\n            // Open\
    \ parentheses increases openParens count by 1\n            if (char == '(') {\n\
    \                openParens += 1\n            }\n            // Close parentheses\
    \ increases closeParens count by 1\n            else if (char == ')') {\n    \
    \            closeParens += 1\n            }\n            // When number of open\
    \ and close parentheses are the same\n            // Add the parenGroup to the\
    \ list\n            // Reset the number of open and close parentheses to 0\n \
    \           // Clear the parenGroup\n            if (openParens == closeParens)\
    \ {\n                parenGroupList += parenGroup.toString\n                openParens\
    \ = 0\n                closeParens = 0\n                parenGroup.clear\n   \
    \         }\n        }\n        return parenGroupList.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013111
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var sub_paren_groups = new ListBuffer[String]\n\
    \        for (i <- 0 until paren_string.length - 1) {\n            var first_paren\
    \ = paren_string.indexOf('(', i)\n            if (first_paren < 0) break\n   \
    \         var paren_count = 1\n            var paren_group = \"\"\n          \
    \  for (j <- first_paren + 1 until paren_string.length) {\n                if\
    \ (paren_string(j) == '(') paren_count += 1\n                else if (paren_string(j)\
    \ == ')') paren_count -= 1\n                paren_group += paren_string(j)\n \
    \               if (paren_count == 0) {\n                    sub_paren_groups\
    \ += paren_group\n                    break\n                }\n            }\n\
    \        }\n        sub_paren_groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4nob76bl.scala:14:33 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mif\e[0m (first_paren < \e[31m0\e[0m)\
    \ break\n\e[31m\e[31m   |\e[0m                                 ^^^^^\e[0m\n\e\
    [31m   |\e[0m                                 Not found: break\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp4nob76bl.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013107
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n    \tval result = new ListBuffer[String]()\n\
    \    \tvar layer = 0\n    \tvar start = 0\n    \tfor (i <- 0 until paren_string.length)\
    \ {\n    \t\tif (paren_string(i) == '(') layer += 1\n    \t\telse if (paren_string(i)\
    \ == ')') layer -= 1\n    \t\tif (layer == 0) {\n    \t\t\tval substr = paren_string.substring(start,\
    \ i + 1)\n    \t\t\tresult += substr\n    \t\t\tstart = i + 1\n    \t\t}\n   \
    \ \t}\n    \tresult.toList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpem9sukmj.scala:26)\n\tat Problem.main(tmpem9sukmj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013111
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def helper(s : String, acc : List[String],\
    \ left : Int, right : Int) : List[String] = {\n            if (s.isEmpty) {\n\
    \                if (left == right) acc else throw new IllegalArgumentException(\"\
    unbalanced parentheses\")\n            } else {\n                if (s.head ==\
    \ '(') helper(s.tail, acc, left + 1, right)\n                else if (s.head ==\
    \ ')') {\n                    if (left == right) helper(s.tail, acc :+ s.take(right\
    \ - left + 1), 0, 0)\n                    else helper(s.tail, acc, left, right\
    \ + 1)\n                } else helper(s.tail, acc, left, right)\n            }\n\
    \        }\n        helper(paren_string.filter(_ != ' '), List[String](), 0, 0)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_h0qr6hm.scala:25)\n\tat Problem.main(tmp_h0qr6hm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013111
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def parse(s : String, begin : Int, end\
    \ : Int, inBlock : Boolean, count : Int, record : List[String]) : List[String]\
    \ = {\n            if (end == s.length) {\n                if (inBlock) record.reverse\n\
    \                else record.reverse.::(s.substring(begin, end))\n           \
    \ }\n            else if (s(end) == ' ') parse(s, begin, end + 1, inBlock, count,\
    \ record)\n            else if (s(end) == '(') parse(s, begin, end + 1, true,\
    \ count + 1, record)\n            else if (s(end) == ')') {\n                if\
    \ (count == 1) parse(s, end + 1, end + 1, false, 0, record.::(s.substring(begin,\
    \ end)))\n                else parse(s, begin, end + 1, true, count - 1, record)\n\
    \            }\n            else parse(s, begin, end + 1, inBlock, count, record)\n\
    \        }\n        parse(paren_string, 0, 0, false, 0, Nil)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqp12t32h.scala:27)\n\tat Problem.main(tmpqp12t32h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013111
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def helper(paren_string : String, ans\
    \ : List[String]) : List[String] = {\n            if (paren_string.length <= 0)\
    \ ans\n            else {\n                val (paren_string2, word) = helper2(paren_string)\n\
    \                helper(paren_string2, ans :+ word)\n            }\n        }\n\
    \        def helper2(paren_string : String) : (String, String) = {\n         \
    \   val first_paren = paren_string.indexOf('(')\n            val second_paren\
    \ = paren_string.indexOf(')')\n            if (first_paren >= 0 && second_paren\
    \ >= 0) (paren_string.substring(second_paren + 1), paren_string.substring(first_paren,\
    \ second_paren + 1))\n            else throw new NoSuchElementException\n    \
    \    }\n        helper(paren_string, List())\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 2, end 1, length 22\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.helper2$1(tmp6xxs9gxv.scala:21)\n\tat Problem$.helper$1(tmp6xxs9gxv.scala:14)\n\
    \tat Problem$.separateParenGroups(tmp6xxs9gxv.scala:24)\n\tat Problem$.main(tmp6xxs9gxv.scala:27)\n\
    \tat Problem.main(tmp6xxs9gxv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013112
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // 1. Separate the input string into a\
    \ list of characters, filtering out spaces\n        val paren_list = paren_string.replaceAll(\"\
    \ \", \"\").toList\n        // 2. Call separateParenGroupsHelper with the list\
    \ you created in step 1 and an empty buffer for\n        //    collecting results\n\
    \        separateParenGroupsHelper(paren_list, ListBuffer[String]())\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph3aofw2m.scala:15:8 -------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        separateParenGroupsHelper(paren_list, ListBuffer[\e\
    [35mString\e[0m]())\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Not found: separateParenGroupsHelper\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013108
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val stack = new Stack[Char]\n        var\
    \ group_start_idx = 0\n        var group_idx = 0\n        val ret = new ListBuffer[String]\n\
    \        var i = 0\n        while (i < paren_string.length) {\n            if\
    \ (paren_string(i) == '(') {\n                stack.push('(')\n              \
    \  if (stack.size == 1) {\n                    group_start_idx = i\n         \
    \       }\n            } else if (paren_string(i) == ')') {\n                stack.pop\n\
    \                if (stack.size == 0) {\n                    ret += paren_string.substring(group_start_idx,\
    \ i + 1)\n                }\n            }\n            i += 1\n        }\n  \
    \      return ret.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn629momi.scala:36)\n\tat Problem.main(tmpn629momi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013112
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Write your code here\n        ???\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.separateParenGroups(tmpcnc9am9a.scala:12)\n\tat Problem$.main(tmpcnc9am9a.scala:15)\n\
    \tat Problem.main(tmpcnc9am9a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013111
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var stack = Stack[Int]()\n        var\
    \ last_push_index = 0\n        var separated_groups = List[String]()\n       \
    \ for (i <- 0 until paren_string.length) {\n            if (paren_string(i) ==\
    \ '(') {\n                stack.push(i)\n                last_push_index = i\n\
    \            } else if (paren_string(i) == ')') {\n                stack.pop()\n\
    \                if (stack.isEmpty) {\n                    separated_groups =\
    \ separated_groups :+ paren_string.substring(last_push_index, i + 1)\n       \
    \         }\n            }\n        }\n        return separated_groups\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsi781t__.scala:28)\n\tat Problem.main(tmpsi781t__.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013111
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def isOpenParen(c : Char) : Boolean =\
    \ (c == '(')\n        def isCloseParen(c : Char) : Boolean = (c == ')')\n    \
    \    def isParen(c : Char) : Boolean = (isOpenParen(c) || isCloseParen(c))\n \
    \       def isValidGroup(p_string : String) : Boolean = {\n            def isValidHelper(s\
    \ : String, open : Int) : Boolean = (s match {\n                case \"\" => (open\
    \ == 0)\n                case _ => if (isOpenParen(s.head)) isValidHelper(s.tail,\
    \ open + 1)\n                          else if (isCloseParen(s.head)) open > 0\
    \ && isValidHelper(s.tail, open - 1)\n                          else isValidHelper(s.tail,\
    \ open)\n            })\n            isValidHelper(p_string, 0)\n        }\n \
    \       def separateHelper(s : String, acc : List[String]) : List[String] = {\n\
    \            val openParenIndex = s.indexWhere(isOpenParen)\n            val closeParenIndex\
    \ = s.indexWhere(isCloseParen)\n            if (openParenIndex == -1 || closeParenIndex\
    \ == -1) acc\n            else {\n                val new_s = s.substring(openParenIndex,\
    \ closeParenIndex + 1)\n                if (isValidGroup(new_s)) separateHelper(s.substring(closeParenIndex\
    \ + 1), acc :+ new_s)\n                else separateHelper(s.substring(closeParenIndex\
    \ + 1), acc)\n            }\n        }\n        separateHelper(paren_string.filterNot(c\
    \ => c == ' '), List())\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 2, end 1, length 14\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.separateHelper$1(tmp82qab8ij.scala:28)\n\tat Problem$.separateParenGroups(tmp82qab8ij.scala:33)\n\
    \tat Problem$.main(tmp82qab8ij.scala:36)\n\tat Problem.main(tmp82qab8ij.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013112
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val result = ArrayBuffer[String]()\n \
    \       val buf = new StringBuilder\n        var current_depth = 0\n        for\
    \ (paren <- paren_string) {\n            paren match {\n                case '('\
    \ => {\n                    current_depth += 1\n                    buf.append(paren)\n\
    \                }\n                case ')' => {\n                    buf.append(paren)\n\
    \                    current_depth -= 1\n                    if (current_depth\
    \ == 0) {\n                        result += buf.toString\n                  \
    \      buf.clear\n                    }\n                }\n                case\
    \ _ => {\n                    // do nothing\n                }\n            }\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013113
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // This solution is to find all pairs\
    \ of parenthesis, and then break up the string into groups\n        // based on\
    \ where these pairs are\n        val paren_stack = new Stack[Int]\n        //\
    \ For now, let's just find where all the pairs are\n        var pairs = new ListBuffer[(Int,\
    \ Int)]\n        for (i <- 0 until paren_string.length) {\n            if (paren_string(i)\
    \ == '(') {\n                paren_stack.push(i)\n            } else if (paren_string(i)\
    \ == ')') {\n                pairs += ((paren_stack.pop, i))\n            }\n\
    \        }\n        // Now we've got pairs; based on pairs, break the string into\
    \ groups\n        val groups = new ListBuffer[String]\n        pairs += ((-1,\
    \ paren_string.length - 1))\n        var i = 0\n        while (i < pairs.length\
    \ - 1) {\n            var (start, end) = pairs(i)\n            // Now we want\
    \ to find the end of the group\n            var j = i + 1\n            var group_end\
    \ = i\n            while (j < pairs.length && pairs(j)._1 < end) {\n         \
    \       // This means that this pair is contained within the previous one\n  \
    \              group_end = j\n                j += 1\n            }\n        \
    \    groups += paren_string.substring(start + 1, pairs(group_end)._2)\n      \
    \      i = group_end + 1\n        }\n        groups.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjji4inso.scala:43)\n\tat Problem.main(tmpjji4inso.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013113
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // >>> separateParenGroups((\"( ) (( ))\
    \ (( )( ))\"))\n        // (List[String](\"()\", \"(())\", \"(()())\"))\n    \
    \    paren_string.trim().split(\" \").toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp26y13khm.scala:19)\n\tat Problem.main(tmp26y13khm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013113
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var temp = new ListBuffer[String]()\n\
    \        var count = 0\n        var str = new StringBuilder\n        for (i <-\
    \ 0 until paren_string.length) {\n            if (paren_string(i) == '(') {\n\
    \                count += 1\n                str.append(paren_string(i))\n   \
    \         }\n            else if (paren_string(i) == ')') {\n                count\
    \ -= 1\n                str.append(paren_string(i))\n            }\n         \
    \   if (count == 0) {\n                temp += str.toString\n                str\
    \ = new StringBuilder\n            }\n        }\n        return temp.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6shbee1n.scala:31)\n\tat Problem.main(tmp6shbee1n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013113
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val ret = new ListBuffer[String]\n   \
    \     var curr = new StringBuilder\n        var open = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                open += 1\n                curr\
    \ += c\n            } else if (c == ')') {\n                open -= 1\n      \
    \          curr += c\n                if (open == 0) {\n                    ret\
    \ += curr.toString\n                    curr = new StringBuilder\n           \
    \     }\n            } else if (c != ' ') {\n                curr += c\n     \
    \       }\n        }\n        ret.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013114
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // paren_string.trim.split(\" \").toList\n\
    \        val split_strings = paren_string.trim.split(\" \")\n        val unpacked_strings\
    \ = new ListBuffer[String]\n        var s = \"\"\n        for (str <- split_strings)\
    \ {\n            s += str\n            if (str.length == 2) {\n              \
    \  unpacked_strings += s\n                s = \"\"\n            }\n        }\n\
    \        unpacked_strings.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplvhlkto9.scala:25)\n\tat Problem.main(tmplvhlkto9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013113
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = ListBuffer[String]()\n\
    \        var curr_group = \"\"\n        var balance = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                balance += 1\n             \
    \   curr_group += c\n            } else if (c == ')') {\n                balance\
    \ -= 1\n                curr_group += c\n            } else if (c == ' ') {\n\
    \                // ignore\n            } else {\n                throw new IllegalArgumentException(paren_string)\n\
    \            }\n            if (balance == 0) {\n                paren_groups\
    \ += curr_group\n                curr_group = \"\"\n            }\n        }\n\
    \        if (balance != 0) throw new IllegalArgumentException(paren_string)\n\
    \        paren_groups.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph_dmq2yg.scala:35)\n\tat Problem.main(tmph_dmq2yg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013114
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        import scala.collection.mutable.ListBuffer\n\
    \        var open_count = 0\n        var close_count = 0\n        var start_index\
    \ = 0\n        var end_index = 0\n        var is_open = false\n        var answer\
    \ = new ListBuffer[String]()\n        for (i <- 0 until paren_string.length) {\n\
    \            if (paren_string(i) == '(') {\n                if (!is_open) {\n\
    \                    is_open = true\n                    start_index = i\n   \
    \             }\n                open_count += 1\n            }\n            else\
    \ if (paren_string(i) == ')') {\n                close_count += 1\n          \
    \      if (open_count == close_count) {\n                    is_open = false\n\
    \                    end_index = i\n                    answer += paren_string.substring(start_index,\
    \ end_index + 1)\n                    open_count = 0\n                    close_count\
    \ = 0\n                }\n            }\n        }\n        answer.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdisa5sgk.scala:43)\n\tat Problem.main(tmpdisa5sgk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013117
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if (paren_string.isEmpty)\n          \
    \  List[String]()\n        var paren_list = List[String]()\n        var start\
    \ = 0\n        var end = 0\n        var brace_count = 0\n        while (end <\
    \ paren_string.length) {\n            if (paren_string(end) == '(')\n        \
    \        brace_count += 1\n            else if (paren_string(end) == ')')\n  \
    \              brace_count -= 1\n            if (brace_count == 0) {\n       \
    \         paren_list = paren_list :+ paren_string.substring(start, end + 1)\n\
    \                start = end + 1\n            }\n            end += 1\n      \
    \  }\n        return paren_list\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp05wuc_ph.scala:31)\n\tat Problem.main(tmp05wuc_ph.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013118
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Write your code here\n        return\
    \ null\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.separateParenGroups(String)\" is null\n\
    \tat Problem$.main(tmpwvkjrp5w.scala:15)\n\tat Problem.main(tmpwvkjrp5w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013117
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // For starters, I'd split the string\
    \ by spaces\n        val space_split = paren_string.split(\" \")\n        var\
    \ result = new ListBuffer[String]()\n        for (piece <- space_split) {\n  \
    \          if (piece.length > 0) {\n                result += piece\n        \
    \    }\n        }\n        return result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmbim6nhb.scala:25)\n\tat Problem.main(tmpmbim6nhb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013120
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // TODO: Return list of separated paren\
    \ groups\n        var result : List[String] = List()\n        var str_list : List[String]\
    \ = List()\n        var counter : Int = 0\n        for (c <- paren_string) {\n\
    \            if (c == '(') {\n                counter += 1\n            } else\
    \ if (c == ')') {\n                counter -= 1\n            }\n            str_list\
    \ = str_list :+ c.toString\n            if (counter == 0) {\n                result\
    \ = result :+ str_list.mkString\n                str_list = List()\n         \
    \   }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpco084haf.scala:30)\n\tat Problem.main(tmpco084haf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val stack = new Stack[Char]\n        val\
    \ result = new ListBuffer[String]\n        var group = new StringBuilder\n   \
    \     for (c <- paren_string) {\n            if (c == '(') {\n               \
    \ if (stack.size == 0) {\n                    group = new StringBuilder\n    \
    \            }\n                stack.push(c)\n            } else if (c == ')')\
    \ {\n                stack.pop\n                if (stack.size == 0) {\n     \
    \               result += group.toString\n                }\n            } else\
    \ if (c != ' ') {\n                group += c\n            }\n        }\n    \
    \    result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyypjtxfx.scala:32)\n\tat Problem.main(tmpyypjtxfx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var stack = List[Char]()\n        var\
    \ curr_group = List[Char]()\n        var groups = List[String]()\n        var\
    \ isBalanced = true\n        for (ch <- paren_string) {\n            if (ch ==\
    \ ' ') {\n                // Ignore\n            } else if (ch == '(') {\n   \
    \             stack = ch :: stack\n            } else if (ch == ')') {\n     \
    \           if (stack.isEmpty) {\n                    isBalanced = false\n   \
    \             } else {\n                    curr_group = ch :: curr_group\n  \
    \                  stack = stack.tail\n                    if (stack.isEmpty)\
    \ {\n                        groups = curr_group.reverse.mkString(\"\") :: groups\n\
    \                        curr_group = List[Char]()\n                    }\n  \
    \              }\n            } else {\n                // Shouldn't get here\n\
    \                isBalanced = false\n            }\n        }\n        if (isBalanced)\
    \ groups else List[String]()\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjfuj_9x8.scala:39)\n\tat Problem.main(tmpjfuj_9x8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups = new ListBuffer[String]()\n\
    \        var current = new StringBuilder\n        var c = 0\n        for (i <-\
    \ 0 until paren_string.length) {\n            val current_char = paren_string(i)\n\
    \            if (current_char == '(') c += 1\n            else if (current_char\
    \ == ')') c -= 1\n            if (c == 0 && current_char == ')') {\n         \
    \       groups += current.toString\n                current = new StringBuilder\n\
    \            }\n            else if (current_char != ' ') current += current_char\n\
    \        }\n        groups.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5vq7coc8.scala:27)\n\tat Problem.main(tmp5vq7coc8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013122
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var open_paren = 0\n        var last_paren\
    \ = 0\n        var paren_groups = List[String]()\n        for (i <- 0 until paren_string.length)\
    \ {\n            if (paren_string(i) == '(') open_paren += 1\n            else\
    \ if (paren_string(i) == ')') open_paren -= 1\n            if (open_paren == 0)\
    \ {\n                paren_groups = paren_groups :+ paren_string.substring(last_paren,\
    \ i + 1)\n                last_paren = i + 1\n            }\n        }\n     \
    \   paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3sg45hi1.scala:25)\n\tat Problem.main(tmp3sg45hi1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013122
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var index : Int = 0\n        var paren_list\
    \ : List[String] = List()\n        var current_string : String = \"\"\n      \
    \  val paren_string_chars : Array[Char] = paren_string.replaceAll(\" \", \"\"\
    ).toCharArray\n        while (index < paren_string_chars.length) {\n         \
    \   var count : Int = 0\n            while (paren_string_chars(index) != ')' ||\
    \ count != 0) {\n                current_string += paren_string_chars(index)\n\
    \                if (paren_string_chars(index) == '(') count += 1\n          \
    \      else if (paren_string_chars(index) == ')') count -= 1\n               \
    \ index += 1\n            }\n            paren_list = paren_list :+ current_string\n\
    \            current_string = \"\"\n            index += 1\n        }\n      \
    \  paren_list\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 24 out of bounds for length\
    \ 24\n\tat Problem$.separateParenGroups(tmpbaof15fh.scala:17)\n\tat Problem$.main(tmpbaof15fh.scala:30)\n\
    \tat Problem.main(tmpbaof15fh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013122
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Fill this out\n        var res = List[String]()\n\
    \        var stack = Stack[Char]()\n        var curStr = \"\"\n        for (c\
    \ <- paren_string) {\n            if (c == ' ') continue\n            if (c ==\
    \ '(') {\n                stack.push(c)\n                curStr += c\n       \
    \     } else {\n                if (stack.nonEmpty) {\n                    stack.pop\n\
    \                    curStr += c\n                }\n                if (stack.isEmpty)\
    \ {\n                    res = curStr :: res\n                    curStr = \"\"\
    \n                }\n            }\n        }\n        res.reverse\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp13mgc0fl.scala:16:26 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (c == \e[31m' '\e[0m) continue\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          Not found: continue\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013118
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // TODO: fill in this function\n     \
    \   var current = \"\";\n        var stack = new Stack[Char]();\n        var result\
    \ = new ListBuffer[String]();\n        for (c <- paren_string) {\n           \
    \ if (c == '(') {\n                if (stack.isEmpty) {\n                    current\
    \ = current + c;\n                }\n                stack.push(c);\n        \
    \    } else if (c == ')') {\n                if (stack.isEmpty) {\n          \
    \          return null;\n                }\n                stack.pop();\n   \
    \             if (stack.isEmpty) {\n                    current = current + c;\n\
    \                    result += current;\n                    current = \"\";\n\
    \                }\n            } else if (c != ' ') {\n                return\
    \ null;\n            }\n        }\n        if (!stack.isEmpty) {\n           \
    \ return null;\n        }\n        return result.toList;\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3ehjxg44.scala:41)\n\tat Problem.main(tmp3ehjxg44.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013122
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups = new ListBuffer[String]()\n\
    \        var start = -1\n        var num_pairs = 0\n        for (i <- 0 until\
    \ paren_string.length) {\n            paren_string(i) match {\n              \
    \  case '(' => {\n                    if (start == -1) start = i\n           \
    \         num_pairs += 1\n                }\n                case ')' => {\n \
    \                   num_pairs -= 1\n                    if (num_pairs == 0) {\n\
    \                        groups += paren_string.substring(start, i + 1)\n    \
    \                    start = -1\n                    }\n                }\n  \
    \              case _ => {}\n            }\n        }\n        groups.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprc4mc7yd.scala:36)\n\tat Problem.main(tmprc4mc7yd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013123
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def separateParenGroups_(paren_string\
    \ : String, prefix : String, suffix : List[String]) : List[String] = {\n     \
    \       if (paren_string.length == 0) {\n                suffix\n            }\
    \ else if (paren_string.head == ' ') {\n                separateParenGroups_(paren_string.tail,\
    \ prefix, suffix)\n            } else if (paren_string.head == '(') {\n      \
    \          separateParenGroups_(paren_string.tail, prefix + \"(\", suffix)\n \
    \           } else if (paren_string.head == ')') {\n                separateParenGroups_(paren_string.tail,\
    \ prefix + \")\", suffix :+ prefix + \")\")\n            } else {\n          \
    \      throw new Exception(\"Invalid character in parentheses string\")\n    \
    \        }\n        }\n        separateParenGroups_(paren_string, \"\", List())\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6v663c2i.scala:27)\n\tat Problem.main(tmp6v663c2i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013123
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // We keep track of an int. The int is\
    \ the number of open parens. This can only ever be 1 or 0.\n        // When we\
    \ see a '(' we add 1 to the int and start a new string.\n        // When we see\
    \ a ')' we subtract 1 from the int and end the string.\n        // We iterate\
    \ until the int is 0 and we have no more chars.\n        // We need to add the\
    \ ending string as the last element in our List[String]\n        // Also we need\
    \ to make sure that the string is not empty and does not start with a ')'.\n\n\
    \        // Algorithm:\n        // start the int at 0\n        // start the string\
    \ at null\n        // start a List[String] at null\n        // Iterate through\
    \ the chars in the input string\n        // If the char is a '(' and the int is\
    \ 0, start a new string and add 1 to the int\n        // If the char is a '('\
    \ and the int is 1, add a '(' to the string\n        // If the char is a ')' and\
    \ the int is 1, add a ')' to the string and subtract 1 from the int\n        //\
    \ If the char is a ')' and the int is 0, subtract 1 from the int\n        // If\
    \ the int is 0, add the string to the List[String] and make the string null\n\
    \        // Return the List[String]\n        var paren_count = 0\n        var\
    \ current_string = \"\"\n        var paren_list = List[String]()\n        for\
    \ (c <- paren_string) {\n            if (c == '(') {\n                if (paren_count\
    \ == 0) {\n                    paren_count += 1\n                    current_string\
    \ = \"(\"\n                } else {\n                    current_string += \"\
    (\"\n                }\n            } else if (c == ')') {\n                if\
    \ (paren_count == 1) {\n                    current_string += \")\"\n        \
    \            paren_count -= 1\n                } else {\n                    paren_count\
    \ -= 1\n                }\n            } else {\n                continue\n  \
    \          }\n            if (paren_count == 0) {\n                paren_list\
    \ = current_string :: paren_list\n                current_string = \"\"\n    \
    \        }\n        }\n        return\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7je0fquk.scala:48:16 ------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                continue\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: continue\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7je0fquk.scala:55:8\
    \ ---------------------\e[0m\e[0m\n\e[31m55 |\e[0m        \e[33mreturn\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\
    \e[31m   |\e[0m        Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013122
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // To be implemented.\n        var temp\
    \ = paren_string.toCharArray\n        var index = 0\n        var start = 0\n \
    \       var end = 0\n        var list = new ArrayBuffer[String]()\n        while\
    \ (index < temp.length) {\n            if (temp(index) == '(') {\n           \
    \     start = index\n                while (index < temp.length && temp(index)\
    \ != ')') {\n                    index += 1\n                }\n             \
    \   end = index\n                list += temp.slice(start, end + 1).mkString\n\
    \            }\n            index += 1\n        }\n        list.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnqq0x6ap.scala:31)\n\tat Problem.main(tmpnqq0x6ap.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013123
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_array = paren_string.filter(_\
    \ != ' ').toCharArray()\n        var result = List[String]()\n        var count\
    \ = 0\n        var buffer = new ListBuffer[Char]()\n        for (c <- paren_array)\
    \ {\n            if (c == '(') {\n                if (count == 0) buffer.clear()\n\
    \                count += 1\n                buffer += c\n            } else {\n\
    \                count -= 1\n                buffer += c\n                if (count\
    \ == 0) result = buffer.toList.mkString :: result\n            }\n        }\n\
    \        result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013124
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var stack = new Stack[Char]\n        val\
    \ result = new ListBuffer[String]\n        var current = new StringBuilder\n \
    \       def addCurrent() = {\n            result += current.toString\n       \
    \     current = new StringBuilder\n        }\n        for (c <- paren_string)\
    \ c match {\n            case '(' => stack.push(c)\n            case ')' => {\n\
    \                if (stack.isEmpty) throw new RuntimeException(\"invalid\")\n\
    \                stack.pop\n                if (stack.isEmpty) addCurrent\n  \
    \          }\n            case ' ' =>\n            case _ => current += c\n  \
    \      }\n        if (!stack.isEmpty) throw new RuntimeException(\"invalid\")\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E100] Syntax Error: /tmp/tmp34620u2h.scala:23:35 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mif\e[0m (stack.isEmpty) addCurrent\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       \e[33mmethod\e[0m \e[35maddCurrent\e[0m must\
    \ be called with () argument\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val parens = \"( )\".toList\n        val\
    \ open = parens(0)\n        val close = parens(1)\n        var open_count = 0\n\
    \        var groups = List[String]()\n        var group = \"\"\n        for (c\
    \ <- paren_string.toList) {\n            if (c == open) {\n                open_count\
    \ += 1\n                group += c\n            } else if (c == close) {\n   \
    \             open_count -= 1\n                group += c\n                if\
    \ (open_count == 0) {\n                    groups = groups :+ group\n        \
    \            group = \"\"\n                }\n            }\n        }\n     \
    \   groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo8_1837z.scala:33)\n\tat Problem.main(tmpo8_1837z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013124
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var count = 0\n        var cur = 0\n \
    \       var parens = \"\"\n        var parensList = List[String]()\n        paren_string.foreach\
    \ {c => {\n            if (c == '(') {\n                count += 1\n         \
    \       parens += c\n            }\n            else if (c == ')') {\n       \
    \         count -= 1\n                parens += c\n            }\n           \
    \ if (count == 0) {\n                parensList = parens :: parensList\n     \
    \           parens = \"\"\n            }\n        }}\n        parensList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6noo8oai.scala:32)\n\tat Problem.main(tmp6noo8oai.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_list = paren_string.filter(_\
    \ != ' ').toList\n        val result = ListBuffer[String]()\n        var temp\
    \ = ListBuffer[Char]()\n        var stack = 0\n        for (paren <- paren_list)\
    \ {\n            if (paren == '(') {\n                stack += 1\n           \
    \     temp += paren\n            } else {\n                temp += paren\n   \
    \             stack -= 1\n                if (stack == 0) {\n                \
    \    result += temp.mkString\n                    temp = ListBuffer[Char]()\n\
    \                }\n            }\n        }\n        result.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val regex = \"\"\"\\([ ]*\\)|\\([^\\)]*\\\
    )\"\"\".r\n        val groups = regex.findAllIn(paren_string).toList\n       \
    \ return groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq7kdxlmf.scala:16)\n\tat Problem.main(tmpq7kdxlmf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if (paren_string.length == 0) return Nil\n\
    \        var result : List[String] = Nil\n        var temp : List[Char] = Nil\n\
    \        for (c <- paren_string) {\n            if (c == ' ') {\n            }\
    \ else if (c == '(') {\n                temp = temp :+ c\n            } else if\
    \ (c == ')') {\n                if (temp.last == '(') {\n                    temp\
    \ = temp.take(temp.length - 1)\n                    if (temp.length == 0) {\n\
    \                        result = result :+ \"()\"\n                    }\n  \
    \              } else {\n                    temp = temp :+ c\n              \
    \  }\n            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2kdpi6rm.scala:32)\n\tat Problem.main(tmp2kdpi6rm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val res = Buffer[String]()\n        var\
    \ sb = new StringBuilder\n        var stack = Stack[Char]()\n        for (c <-\
    \ paren_string) {\n            if (c == '(') {\n                stack.push(c)\n\
    \            } else if (c == ')') {\n                stack.pop\n             \
    \   if (stack.isEmpty) {\n                    res += sb.toString\n           \
    \         sb = new StringBuilder\n                }\n            } else if (c\
    \ != ' ') {\n                sb += c\n            }\n        }\n        res.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt1vo58y2.scala:30)\n\tat Problem.main(tmpt1vo58y2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_stack = new Stack[Char]\n  \
    \      var start_index = 0\n        var result = List[String]()\n        for (i\
    \ <- 0 until paren_string.length) {\n            if (paren_string(i) == '(') {\n\
    \                paren_stack.push('(')\n            } else if (paren_string(i)\
    \ == ')') {\n                paren_stack.pop\n                if (paren_stack.isEmpty)\
    \ {\n                    result = result :+ paren_string.substring(start_index,\
    \ i + 1)\n                    start_index = i + 1\n                }\n       \
    \     }\n        }\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpid7wjbqn.scala:28)\n\tat Problem.main(tmpid7wjbqn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013129
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var res = List[String]()\n        var\
    \ temp = List[Char]()\n        paren_string.foreach {c => {\n            if (c\
    \ == ' ') {\n                // Do nothing\n            } else if (c == '(') {\n\
    \                temp = temp :+ c\n            } else if (c == ')') {\n      \
    \          temp = temp :+ c\n                if (temp.length % 2 == 0) {\n   \
    \                 res = res :+ temp.mkString\n                    temp = List[Char]()\n\
    \                }\n            }\n        }}\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpurrlg6jj.scala:29)\n\tat Problem.main(tmpurrlg6jj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013129
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val parenList = paren_string.filterNot(List('\
    \ ').contains(_)).toList.map(_.toString)\n        return separate(parenList, 0,\
    \ List[String]())\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpceniiuj6.scala:12:15 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mreturn\e[0m separate(parenList, \e[31m0\e\
    [0m, List[\e[35mString\e[0m]())\n\e[31m\e[31m   |\e[0m               ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Not found: separate\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def separateParenGroups(paren_string :\
    \ String, open_count : Int, curr_group : String, out : List[String]) : List[String]\
    \ = {\n            if (paren_string.length == 0) {\n                if (open_count\
    \ != 0) throw new IllegalArgumentException(\"Mismatched parentheses\")\n     \
    \           out\n            } else {\n                val next_char = paren_string.head\n\
    \                if (next_char == '(') {\n                    separateParenGroups(paren_string.tail,\
    \ open_count + 1, curr_group + next_char, out)\n                } else if (next_char\
    \ == ')') {\n                    if (open_count == 0) throw new IllegalArgumentException(\"\
    Mismatched parentheses\")\n                    if (open_count == 1) separateParenGroups(paren_string.tail,\
    \ 0, \"\", curr_group + next_char :: out)\n                    else separateParenGroups(paren_string.tail,\
    \ open_count - 1, curr_group + next_char, out)\n                } else {\n   \
    \                 separateParenGroups(paren_string.tail, open_count, curr_group,\
    \ out)\n                }\n            }\n        }\n        separateParenGroups(paren_string,\
    \ 0, \"\", List[String]())\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2oecrkkw.scala:31)\n\tat Problem.main(tmp2oecrkkw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013131
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val buf = new StringBuilder\n        var\
    \ groups = List[String]()\n        var open = 0\n        var closed = 0\n    \
    \    for (c <- paren_string) {\n            if (c == '(') {\n                if\
    \ (open == 0) {\n                    buf.clear\n                }\n          \
    \      open += 1\n                buf += c\n            } else if (c == ')') {\n\
    \                closed += 1\n                buf += c\n                if (open\
    \ == closed) {\n                    groups = buf.toString :: groups\n        \
    \            open = 0\n                    closed = 0\n                }\n   \
    \         }\n        }\n        groups.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013131
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var stack = new Stack[Char]\n        var\
    \ groups = new ListBuffer[String]\n        var currGroup = new StringBuilder\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    if (stack.isEmpty) {\n                    currGroup = new StringBuilder\n\
    \                }\n                stack.push(c)\n            } else if (c ==\
    \ ')') {\n                stack.pop\n                if (stack.isEmpty) {\n  \
    \                  groups += currGroup.toString\n                }\n         \
    \   } else if (c != ' ') {\n                currGroup += c\n            }\n  \
    \      }\n        groups.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3ao4x0js.scala:32)\n\tat Problem.main(tmp3ao4x0js.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013132
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def helper(paren_string : String, paren_stack\
    \ : List[Char], ret_string : String) : String = {\n            if (paren_string.length\
    \ == 0) {\n                if (paren_stack.length == 0) ret_string\n         \
    \       else throw new Exception(\"Uneven parentheses!\")\n            }\n   \
    \         else {\n                val c = paren_string.head\n                if\
    \ (c == '(') helper(paren_string.tail, c :: paren_stack, ret_string + c)\n   \
    \             else if (c == ')') {\n                    if (paren_stack.length\
    \ == 0) throw new Exception(\"Extra close parentheses\")\n                   \
    \ helper(paren_string.tail, paren_stack.tail, ret_string + c)\n              \
    \  }\n                else if (c == ' ') helper(paren_string.tail, paren_stack,\
    \ ret_string)\n                else throw new Exception(\"Invalid character!\"\
    )\n            }\n        }\n        val paren_string_trimmed = paren_string.trim\n\
    \        val ret_string = helper(paren_string_trimmed, List(), \"\")\n       \
    \ val trimmed_ret_string = ret_string.trim\n        if (trimmed_ret_string.length\
    \ == 0) List()\n        else trimmed_ret_string.split(\" \").toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpspmofvu7.scala:34)\n\tat Problem.main(tmpspmofvu7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013132
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var data = paren_string.replaceAll(\"\
    \ \", \"\")\n        var result = List[String]()\n        while (data.length()\
    \ > 0) {\n            var temp = data.splitAt(data.indexOf(\")\") + 1)\n     \
    \       data = temp._2\n            result = result :+ temp._1\n        }\n  \
    \      return result\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe7i_7mzz.scala:21)\n\tat Problem.main(tmpe7i_7mzz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013132
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Remove spaces in the string\n     \
    \   val string = paren_string.replaceAll(\" \", \"\")\n        // List of the\
    \ groups of parentheses\n        val groups = ListBuffer[String]()\n        //\
    \ Position of the start of the current group\n        var start = 0\n        //\
    \ Count of opening parentheses in the current group\n        var open = 0\n  \
    \      for (i <- 0 until string.length) {\n            // Current character\n\
    \            val char = string(i)\n            // Decrement the number of open\
    \ parentheses if the current character is a closing parenthesis\n            if\
    \ (char == ')') {\n                open -= 1\n            }\n            // If\
    \ the current group is closed, add it to the list and reset the start position\n\
    \            if (open == 0) {\n                groups += string.substring(start,\
    \ i + 1)\n                start = i + 1\n            }\n            // Increment\
    \ the number of open parentheses if the current character is an opening parenthesis\n\
    \            if (char == '(') {\n                open += 1\n            }\n  \
    \      }\n        groups.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplmbyghdt.scala:39)\n\tat Problem.main(tmplmbyghdt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013133
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result : List[String] = List()\n \
    \       var parens = new ListBuffer[Char]()\n        var parens_count = 0\n  \
    \      var i = 0\n        while (i < paren_string.length) {\n            val ch\
    \ = paren_string(i)\n            if (ch == '(') {\n                parens_count\
    \ += 1\n                parens += ch\n            } else if (ch == ')') {\n  \
    \              parens_count -= 1\n                parens += ch\n            }\n\
    \            if (parens_count == 0) {\n                result = parens.mkString\
    \ :: result\n                parens.clear\n            }\n            i += 1\n\
    \        }\n        result.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8aev00az.scala:33)\n\tat Problem.main(tmp8aev00az.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013133
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result = new ListBuffer[String]\n\
    \        var count = 0\n        var cur = \"\"\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                count += 1\n               \
    \ cur += c\n            } else if (c == ')') {\n                cur += c\n   \
    \             count -= 1\n                if (count == 0) {\n                \
    \    result += cur\n                    cur = \"\"\n                }\n      \
    \      }\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013133
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // DONE\n        var lst : List[String]\
    \ = List()\n        var i = 0\n        var str = \"\"\n        while (i < paren_string.length)\
    \ {\n            if (paren_string(i) == '(') {\n                str += paren_string(i)\n\
    \                while (paren_string(i) != ')') {\n                    i += 1\n\
    \                    str += paren_string(i)\n                }\n             \
    \   lst ::= str\n                str = \"\"\n            }\n            i += 1\n\
    \        }\n        lst.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp4qlm__x.scala:30)\n\tat Problem.main(tmpp4qlm__x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013133
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // FILL IN YOUR CODE HERE\n        return\
    \ List(\"(())\");\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsx7q0me9.scala:15)\n\tat Problem.main(tmpsx7q0me9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013133
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val paren_groups = new ListBuffer[String]()\n\
    \        var curr_group = new StringBuilder()\n        var curr_group_open = 0\n\
    \        for (paren <- paren_string) {\n            if (paren == '(') {\n    \
    \            curr_group.append('(')\n                curr_group_open += 1\n  \
    \          } else if (paren == ')') {\n                curr_group.append(')')\n\
    \                curr_group_open -= 1\n                if (curr_group_open ==\
    \ 0) {\n                    paren_groups += curr_group.toString\n            \
    \        curr_group = new StringBuilder()\n                }\n            }\n\
    \        }\n        paren_groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013134
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        return paren_string.split(\" \").toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_lnm37qk.scala:17)\n\tat Problem.main(tmp_lnm37qk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013133
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_stack = new Stack[Char]()\n\
    \        var result = new ListBuffer[String]()\n        var substring = new StringBuilder()\n\
    \        for (c <- paren_string) {\n            if (c == ' ') {\n            \
    \    // Skip\n            } else if (c == '(') {\n                paren_stack.push(c)\n\
    \                substring.append(c)\n            } else if (c == ')') {\n   \
    \             paren_stack.pop()\n                substring.append(c)\n       \
    \         if (paren_stack.isEmpty) {\n                    result += substring.toString()\n\
    \                    substring = new StringBuilder()\n                }\n    \
    \        }\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013134
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        null\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.separateParenGroups(String)\" is null\n\
    \tat Problem$.main(tmpnsugop43.scala:14)\n\tat Problem.main(tmpnsugop43.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013134
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups = List[String]()\n        var\
    \ paren_count = 0\n        var group = \"\"\n        var last_was_space = false\n\
    \        paren_string.foreach {char =>\n            if (char == ' ') {\n     \
    \           if (!last_was_space) {\n                    group += ' '\n       \
    \             last_was_space = true\n                }\n            } else {\n\
    \                if (char == '(') {\n                    paren_count += 1\n  \
    \                  group += '('\n                } else if (char == ')') {\n \
    \                   paren_count -= 1\n                    group += ')'\n     \
    \               if (paren_count == 0) {\n                        groups = groups\
    \ :+ group\n                        group = \"\"\n                    }\n    \
    \            }\n                last_was_space = false\n            }\n      \
    \  }\n        return groups\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjbr8uluj.scala:39)\n\tat Problem.main(tmpjbr8uluj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013135
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Use a stack to keep track of the depth\
    \ of nested parenthesis.\n        // For example, in the string ( ( ( ( ( ) )\
    \ ) ) ) the stack would be pushed 5 times and popped 5 times.\n        // For\
    \ each group of parenthesis, we can use a separate string to keep track of the\
    \ group.\n        // Once we hit the same depth as the current string (at the\
    \ end of a group), add that string to the list.\n        // >>> separateParenGroups((\"\
    ( ) (( )) (( )( ))\"))\n        // (List[String](\"()\", \"(())\", \"(()())\"\
    ))\n        val result : ListBuffer[String] = ListBuffer()\n        val stack\
    \ : Stack[Int] = Stack()\n        val current : StringBuilder = new StringBuilder()\n\
    \        for (i <- 0 until paren_string.length) {\n            if (paren_string(i)\
    \ == '(') {\n                stack.push(i)\n                current.append('(')\n\
    \            } else if (paren_string(i) == ')') {\n                if (stack.size\
    \ > 0) {\n                    current.append(')')\n                    stack.pop()\n\
    \                    if (stack.size == 0) {\n                        result.append(current.toString)\n\
    \                        current.clear()\n                    }\n            \
    \    }\n            }\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013135
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        def helper(paren_string : String, acc\
    \ : List[String]) : List[String] = {\n            if (paren_string.length == 0)\
    \ acc\n            else {\n                val split = paren_string.indexOf(\"\
    \ \")\n                if (split == -1) {\n                    val str = paren_string.dropWhile(_\
    \ == ' ')\n                    if (acc.length == 0) List(str)\n              \
    \      else acc :+ str\n                }\n                else {\n          \
    \          val str = paren_string.take(split).dropWhile(_ == ' ')\n          \
    \          helper(paren_string.drop(split).dropWhile(_ == ' '), acc :+ str)\n\
    \                }\n            }\n        }\n        helper(paren_string, List())\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmc0hftic.scala:32)\n\tat Problem.main(tmpmc0hftic.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013135
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Keep track of open parens\n       \
    \ var open_paren_count = 0\n        // Keep track of the current paren group\n\
    \        var cur_paren_group = \"\"\n        // Keep track of the list of paren\
    \ groups\n        var paren_groups = List[String]()\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                open_paren_count += 1\n    \
    \            cur_paren_group += c\n            } else if (c == ')') {\n      \
    \          open_paren_count -= 1\n                cur_paren_group += c\n     \
    \           if (open_paren_count == 0) {\n                    paren_groups = cur_paren_group\
    \ :: paren_groups\n                    cur_paren_group = \"\"\n              \
    \  }\n            }\n        }\n        return paren_groups.reverse\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013136
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result : List[String] = List[String]()\n\
    \        var balance : Int = 0\n        var start : Int = 0\n        for (i <-\
    \ 0 until paren_string.length) {\n            if (paren_string(i) == '(') balance\
    \ += 1\n            else if (paren_string(i) == ')') balance -= 1\n          \
    \  if (balance == 0) {\n                result = result :+ paren_string.substring(start,\
    \ i + 1)\n                start = i + 1\n            }\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwm4azjqe.scala:25)\n\tat Problem.main(tmpwm4azjqe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013136
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // YOUR CODE HERE\n        null\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.separateParenGroups(String)\" is null\n\
    \tat Problem$.main(tmpq73t9zcy.scala:15)\n\tat Problem.main(tmpq73t9zcy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013135
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // <<< Hint: use a stack to keep track\
    \ of parenthesis balance\n        return Nil\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmslszic8.scala:15)\n\tat Problem.main(tmpmslszic8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013139
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        paren_string.split(\"\\\\(\\\\s*\\\\)\"\
    ).map(_.trim).filter(_.length > 0).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1klleaaj.scala:14)\n\tat Problem.main(tmp1klleaaj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013140
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var paren_group_list = List[String]()\n\
    \        var current_group = new StringBuilder\n        var paren_count = 0\n\
    \        for (ch <- paren_string) {\n            if (ch == '(') {\n          \
    \      paren_count += 1\n                current_group.append(ch)\n          \
    \  } else if (ch == ')') {\n                paren_count -= 1\n               \
    \ current_group.append(ch)\n            }\n            if (paren_count == 0) {\n\
    \                paren_group_list = paren_group_list :+ current_group.toString\n\
    \                current_group = new StringBuilder\n            }\n        }\n\
    \        return paren_group_list\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0i0y1acl.scala:30)\n\tat Problem.main(tmp0i0y1acl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013141
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        //return paren_string.split(\"[ ]+\").filter(_.length()\
    \ > 0).toList\n        val paren_groups = ArrayBuffer[String]()\n        var current_group\
    \ = new StringBuilder()\n        val input_string = paren_string.replaceAll(\"\
    \ \", \"\")\n        for (i <- 0 until input_string.length()) {\n            if\
    \ (input_string(i) == '(') {\n                current_group.append(input_string(i))\n\
    \            } else if (input_string(i) == ')') {\n                current_group.append(input_string(i))\n\
    \                paren_groups += current_group.toString()\n                current_group\
    \ = new StringBuilder()\n            }\n        }\n        return paren_groups.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0fhluu03.scala:27)\n\tat Problem.main(tmp0fhluu03.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013143
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var res : List[String] = List()\n    \
    \    var s : String = \"\"\n        var st : ArrayStack[Char] = new ArrayStack[Char]()\n\
    \        for (i <- 0 until paren_string.length) {\n            if (paren_string(i)\
    \ == '(') {\n                st.push(paren_string(i))\n            } else if (paren_string(i)\
    \ == ')') {\n                st.pop()\n                if (st.isEmpty) {\n   \
    \                 res = res :+ s\n                    s = \"\"\n             \
    \   }\n            } else if (paren_string(i) != ' ') {\n                s +=\
    \ paren_string(i)\n            }\n        }\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2o1j0s02.scala:30)\n\tat Problem.main(tmp2o1j0s02.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013143
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val open_parens = Stack[Int]()\n     \
    \   val paren_groups = ListBuffer[String]()\n        var start_idx = 0\n     \
    \   for (i <- 0 until paren_string.length) {\n            if (paren_string(i)\
    \ == '(') open_parens.push(i)\n            else if (paren_string(i) == ')') {\n\
    \                if (open_parens.isEmpty) throw new IllegalArgumentException(\"\
    Imbalanced parentheses!\")\n                open_parens.pop\n                if\
    \ (open_parens.isEmpty) {\n                    paren_groups += paren_string.substring(start_idx,\
    \ i + 1)\n                    start_idx = i + 1\n                }\n         \
    \   }\n        }\n        if (!open_parens.isEmpty) throw new IllegalArgumentException(\"\
    Imbalanced parentheses!\")\n        paren_groups.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt47qrvmo.scala:29)\n\tat Problem.main(tmpt47qrvmo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013142
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val parens = paren_string.toList.filterNot(c\
    \ => c == ' ')\n        def getNextGroup(parens : List[Char], group : List[Char],\
    \ acc : List[String]) : List[String] = {\n            if (parens.isEmpty) group.reverse\
    \ :: acc\n            else if (parens.head == '(') getNextGroup(parens.tail, parens.head\
    \ :: group, acc)\n            else if (parens.head == ')') getNextGroup(parens.tail,\
    \ parens.head :: group, group.reverse :: acc)\n            else getNextGroup(parens.tail,\
    \ parens.head :: group, acc)\n        }\n        getNextGroup(parens, Nil, Nil)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaec00m0p.scala:13:38\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m            \e[33mif\e[0m (parens.isEmpty)\
    \ group.reverse :: acc\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    List[Char]\n\e[31m\
    \   |\e[0m                                Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaec00m0p.scala:15:95 --------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (parens.head\
    \ == \e[31m')'\e[0m) getNextGroup(parens.tail, parens.head :: group, group.reverse\
    \ :: acc)\n\e[31m\e[31m   |\e[0m                                             \
    \                                            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                    Found:    List[Char]\n\e\
    [31m   |\e[0m                                                    Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013142
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result : List[String] = List()\n \
    \       var buf : ListBuffer[Char] = ListBuffer()\n        var open : Int = 0\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    open += 1\n                buf += c\n            } else if (c == ')') {\n\
    \                open -= 1\n                buf += c\n            } else if (c\
    \ == ' ') {\n                if (open == 0) {\n                    result = result\
    \ :+ buf.mkString\n                    buf = ListBuffer()\n                }\n\
    \            }\n        }\n        if (buf.length > 0) result = result :+ buf.mkString\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013144
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Your code here\n        return paren_string.toCharArray.filterNot(c\
    \ => c == ' ').mkString.split(\"[)]\\\\([(]\").toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp62c2ybu1.scala:15)\n\tat Problem.main(tmp62c2ybu1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013144
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Corner case handling\n        if (paren_string.isEmpty)\n\
    \            return List()\n        if (paren_string == \" \")\n            return\
    \ List()\n        // Algorithm\n        var lst : List[String] = List()\n    \
    \    var count = 0\n        var output : String = \"\"\n        for (ele <- paren_string)\
    \ {\n            if (ele != ' ') {\n                output += ele\n          \
    \      if (ele == '(')\n                    count += 1\n                else if\
    \ (ele == ')')\n                    count -= 1\n                if (count == 0)\
    \ {\n                    lst = output :: lst\n                    output = \"\"\
    \n                }\n            }\n        }\n        return lst.reverse\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013144
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var group = new StringBuilder\n      \
    \  var groups = new ListBuffer[String]\n        var open_count = 0\n        var\
    \ i = 0\n        while (i < paren_string.length) {\n            if (paren_string(i)\
    \ == '(') {\n                open_count += 1\n                group.append(paren_string(i))\n\
    \            } else if (paren_string(i) == ')') {\n                open_count\
    \ -= 1\n                group.append(paren_string(i))\n            }\n       \
    \     if (open_count == 0) {\n                groups += group.toString\n     \
    \           group = new StringBuilder\n            }\n            i += 1\n   \
    \     }\n        groups.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbyi8tlus.scala:32)\n\tat Problem.main(tmpbyi8tlus.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013144
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var ret = List[String]()\n        var\
    \ l = List[Char]()\n        var start = 0\n        var end = 0\n        for (i\
    \ <- 0 until paren_string.length) {\n            if (paren_string(i) == '(') {\n\
    \                l = l :+ paren_string(i)\n                if (l.length == 1)\
    \ start = i\n            }\n            else if (paren_string(i) == ')') {\n \
    \               l = l.tail\n                if (l.length == 0) {\n           \
    \         end = i\n                    ret = ret :+ paren_string.substring(start,\
    \ end + 1)\n                }\n            }\n        }\n        ret\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1siyty0h.scala:34)\n\tat Problem.main(tmp1siyty0h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013145
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      var stack = new Stack[Char]()\n      var\
    \ groups = new ListBuffer[String]()\n      val paren_string_without_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n      for (i <- 0 until paren_string_without_spaces.length) {\n \
    \       val c = paren_string_without_spaces(i)\n        if (c == '(') {\n    \
    \      stack.push(c)\n        } else if (c == ')') {\n          stack.pop()\n\
    \          if (stack.isEmpty) {\n            groups += paren_string_without_spaces.substring(0,\
    \ i + 1)\n            paren_string_without_spaces.substring(i + 1)\n         \
    \ }\n        }\n      }\n      groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqnded5vf.scala:29)\n\tat Problem.main(tmpqnded5vf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013144
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result : List[String] = List[String]()\n\
    \        var group : String = \"\"\n        var braces_left : Int = 0\n      \
    \  for (c <- paren_string) {\n            if (c == '(') {\n                braces_left\
    \ += 1\n                group += '('\n            } else if (c == ')') {\n   \
    \             braces_left -= 1\n                group += ')'\n            } else\
    \ if (c == ' ') {\n                continue\n            } else {\n          \
    \      return List[String]()\n            }\n            if (braces_left == 0)\
    \ {\n                result = result :+ group\n                group = \"\"\n\
    \            }\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpglj_g3bi.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                continue\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: continue\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013141
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // TODO: write this!\n        return null\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.separateParenGroups(String)\" is null\n\
    \tat Problem$.main(tmp00t4gdm8.scala:15)\n\tat Problem.main(tmp00t4gdm8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013144
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var list = List[String]()\n        var\
    \ start = 0\n        for (i <- 0 until paren_string.length) {\n            val\
    \ c = paren_string(i)\n            if (c == '(') start += 1\n            else\
    \ if (c == ')') start -= 1\n            if (start == 0) {\n                list\
    \ = list :+ paren_string.substring(0, i + 1)\n                return list :::\
    \ separateParenGroups(paren_string.substring(i + 1))\n            }\n        }\n\
    \        return list\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq4rmq22i.scala:25)\n\tat Problem.main(tmpq4rmq22i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013146
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n    \t// First, remove all spaces.\n    \tval\
    \ parenStringNoSpaces = paren_string.replaceAll(\"\\\\s+\",\"\")\n    \t// Next,\
    \ we will create a list of all the positions of the opening parentheses and closing\
    \ parentheses\n    \t// and separate them into two different lists.\n    \tval\
    \ allParens = parenStringNoSpaces.toCharArray\n    \tvar openPos : List[Int] =\
    \ List()\n    \tvar closePos : List[Int] = List()\n    \tfor (i <- 0 until allParens.length)\
    \ {\n    \t\tif (allParens(i) == '(') openPos = openPos :+ i\n    \t\telse if\
    \ (allParens(i) == ')') closePos = closePos :+ i\n    \t}\n    \t// Now, we will\
    \ determine the indices of the opening and closing parentheses of each group.\n\
    \    \tvar opening : Int = 0\n    \tvar closing : Int = 0\n    \tvar parenGroupIndices\
    \ : List[List[Int]] = List()\n    \t// Keep cycling until all parentheses have\
    \ been used.\n    \twhile (openPos.length > 0) {\n    \t\topening = openPos.last\n\
    \    \t\topenPos = openPos.dropRight(1)\n    \t\tclosing = closePos.last\n   \
    \ \t\tclosePos = closePos.dropRight(1)\n    \t\tparenGroupIndices = parenGroupIndices\
    \ :+ List(opening, closing)\n    \t}\n    \t// Now, we will use the indices to\
    \ find each group's string.\n    \tvar parenGroups : List[String] = List()\n \
    \   \tfor (group <- parenGroupIndices) {\n    \t\tparenGroups = parenGroups :+\
    \ parenStringNoSpaces.substring(group(0), group(1) + 1)\n    \t}\n    \t// Finally,\
    \ return the list of groups.\n    \tparenGroups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpark199hh.scala:43)\n\tat Problem.main(tmpark199hh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013145
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Initialize a stack to store unmatched\
    \ open parens.\n        val stack = new Stack[Char]\n        // Also initialize\
    \ a linked list to store groups of balanced parens.\n        val paren_groups\
    \ = new LinkedList[String]\n        // Initialize a buffer string to store the\
    \ current group of balanced parens.\n        var buffer = \"\"\n        // Iterate\
    \ through each character in the string.\n        for (c <- paren_string) {\n \
    \           // Ignore spaces\n            if (c != ' ') {\n                //\
    \ If open paren, push to stack\n                if (c == '(') stack.push(c)\n\
    \                // If closed paren and no open parens, error\n              \
    \  else if (stack.isEmpty) return null\n                // If closed paren and\
    \ stack is not empty, pop open paren from stack.\n                else stack.pop\n\
    \                // Add character to buffer.\n                buffer += c\n  \
    \          }\n        }\n        // After iterating through all characters, if\
    \ stack is not empty, error.\n        if (!stack.isEmpty) return null\n      \
    \  // If no error, add buffer to the list of paren groups and return it.\n   \
    \     paren_groups.append(buffer)\n        paren_groups.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkdtqg6_m.scala:14:31 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mparen_groups\e[0m = \e[33mnew\e\
    [0m \e[35mLinkedList\e[0m[\e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m          \
    \                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \        Not found: type LinkedList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013143
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var result = new ListBuffer[String]\n\
    \        var x = paren_string.split(\" \").toList\n        for (s <- x) {\n  \
    \          var i = 0\n            var j = s.length - 1\n            while (i <\
    \ j) {\n                if (s(i) == '(' && s(j) == ')') {\n                  \
    \  i += 1\n                    j -= 1\n                } else {\n            \
    \        i = -1\n                    j = -1\n                }\n            }\n\
    \            if (i == j) result += s\n        }\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuey7b0xm.scala:30)\n\tat Problem.main(tmpuey7b0xm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013147
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // We are going to use a stack to process\
    \ the input string.\n        // The stack will be a list of tuples of (Boolean,\
    \ String). Boolean will be true if the top of the stack is\n        // an open\
    \ paren, false if it is a closed paren. The string will be the concatenation of\
    \ the output\n        // strings for that level.\n        // As we loop through\
    \ the input string, we will see if we encounter a space or a close paren.\n  \
    \      // If we encounter a space, we append it to the top of the stack (as a\
    \ string).\n        // If we encounter a close paren, we pop the top of the stack\
    \ and push the two elements, with the second as\n        // a closed paren.\n\
    \        // We will keep doing this until we hit the end of the string, at which\
    \ point the stack should have one\n        // element, which is the final solution\n\
    \        val stack = Stack[(Boolean, String)]()\n        var paren_string_remaining\
    \ = paren_string\n        while (paren_string_remaining.length > 0) {\n      \
    \      if (paren_string_remaining.charAt(0) == ' ') {\n                // Add\
    \ a space to the top of the stack\n                if (stack.top._1) {\n     \
    \               stack.push((true, stack.pop._2 + \" \"))\n                } else\
    \ {\n                    stack.push((false, stack.pop._2 + \" \"))\n         \
    \       }\n            } else if (paren_string_remaining.charAt(0) == '(') {\n\
    \                // Open a new paren group\n                stack.push((true,\
    \ \"( \"))\n            } else if (paren_string_remaining.charAt(0) == ')') {\n\
    \                // Close a paren group. The top of the stack must be a space.\n\
    \                val top = stack.pop\n                assert(top._1 == false)\n\
    \                stack.push((false, top._2 + \")\"))\n            }\n        \
    \    paren_string_remaining = paren_string_remaining.substring(1)\n        }\n\
    \        // At this point, we should have one element in the stack and it should\
    \ be a closed paren\n        assert(stack.length == 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn01nr013.scala:43:14\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m        assert(stack.length ==\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required: List[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013146
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Fill in the function body here\n  \
    \      var result = List[String]()\n        var count = 0\n        var l:Int =\
    \ paren_string.length\n        var index = 0\n        for(i <- 0 to l) {\n   \
    \         if(paren_string(i) == '(') count += 1\n            else if(paren_string(i)\
    \ == ')') count -= 1\n            if(count == 0 && i != l) {\n               \
    \ var s = paren_string.substring(index, i+1)\n                result ::= s\n \
    \               index = i+1\n            }\n        }\n        result.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: String index out of range: 27\n\
    \tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\
    \tat scala.collection.StringOps$.apply$extension(StringOps.scala:185)\n\tat Problem$.separateParenGroups$$anonfun$1(tmp_yf8h6j6.scala:17)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.separateParenGroups(tmp_yf8h6j6.scala:24)\n\
    \tat Problem$.main(tmp_yf8h6j6.scala:28)\n\tat Problem.main(tmp_yf8h6j6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013146
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var groups = List[String]()\n        var\
    \ stack = List[Char]()\n        var curr : String = \"\"\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                stack = c :: stack\n       \
    \         curr += c\n            } else if (c == ')') {\n                stack\
    \ = stack.tail\n                curr += c\n                if (stack.isEmpty)\
    \ {\n                    groups = curr :: groups\n                    curr = \"\
    \"\n                }\n            } else if (c != ' ') {\n                curr\
    \ += c\n            }\n        }\n        groups.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013147
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      null\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.collection.immutable.List.equals(Object)\"\
    \ because the return value of \"Problem$.separateParenGroups(String)\" is null\n\
    \tat Problem$.main(tmp69tqap12.scala:14)\n\tat Problem.main(tmp69tqap12.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013146
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var list : List[String] = List()\n   \
    \     var paren_accumulator : String = \"\"\n        var balance : Int = 0\n \
    \       for (c <- paren_string) {\n            if (c == '(') {\n             \
    \   if (balance == 0) {\n                    if (paren_accumulator != \"\") list\
    \ = list :+ paren_accumulator\n                    paren_accumulator = \"\"\n\
    \                }\n                balance += 1\n                paren_accumulator\
    \ += c\n            } else if (c == ')') {\n                balance -= 1\n   \
    \             paren_accumulator += c\n            } else {\n                paren_accumulator\
    \ += c\n            }\n        }\n        if (paren_accumulator != \"\") list\
    \ = list :+ paren_accumulator\n        return list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn7vv51ue.scala:33)\n\tat Problem.main(tmpn7vv51ue.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013148
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        return List[String](\"()\", \"(())\",\
    \ \"(()())\")\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp30g9g3mc.scala:14)\n\tat Problem.main(tmp30g9g3mc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013148
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        if (paren_string.isEmpty) return List[String]()\n\
    \        if (paren_string.startsWith(\" \")) return separateParenGroups(paren_string.tail)\n\
    \        var start = 0\n        var i = 0\n        while (i < paren_string.length)\
    \ {\n            val c = paren_string(i)\n            if (c == ' ') {\n      \
    \          i += 1\n            } else if (c == '(') {\n                start =\
    \ i\n                i += 1\n            } else if (c == ')') {\n            \
    \    return paren_string.substring(start, i + 1) :: separateParenGroups(paren_string.substring(i\
    \ + 1))\n            } else {\n                i += 1\n            }\n       \
    \ }\n        return List[String]()\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps_t5xamq.scala:31)\n\tat Problem.main(tmps_t5xamq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013148
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n      val list = paren_string.split(\"(?<=\\\\\
    ))\\\\s*(?=\\\\()\").toList\n      return list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwk9gog2c.scala:15)\n\tat Problem.main(tmpwk9gog2c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var parenStack = new Stack[Char]\n   \
    \     var outputList = new ListBuffer[String]\n        var currentString = new\
    \ StringBuilder\n        for (ch <- paren_string) {\n            if (ch == '(')\
    \ {\n                parenStack.push(ch)\n                currentString += ch\n\
    \            } else if (ch == ')') {\n                if (parenStack.isEmpty)\
    \ throw new Exception(\"Mismatched parentheses\")\n                parenStack.pop\n\
    \                currentString += ch\n                if (parenStack.isEmpty)\
    \ {\n                    outputList += currentString.toString\n              \
    \      currentString = new StringBuilder\n                }\n            } else\
    \ if (ch != ' ') {\n                throw new Exception(\"Expected parens or space,\
    \ got \" + ch)\n            }\n        }\n        if (!parenStack.isEmpty) throw\
    \ new Exception(\"Mismatched parentheses\")\n        outputList.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // Use a stack to keep track of open and\
    \ closed parentheses\n        var stack = new Stack[Char]()\n        var currentGroup\
    \ = new StringBuilder()\n        var groups = new ListBuffer[String]()\n     \
    \   for (c <- paren_string) {\n            if (c == '(') {\n                stack.push(c)\n\
    \            } else if (c == ')') {\n                if (stack.size == 0) {\n\
    \                    return List[String]()\n                }\n              \
    \  if (stack.size == 1) {\n                    groups += currentGroup.toString()\n\
    \                    currentGroup = new StringBuilder()\n                }\n \
    \               stack.pop()\n            } else if (c != ' ') {\n            \
    \    currentGroup += c\n            }\n        }\n        if (stack.size > 0)\
    \ {\n            return List[String]()\n        }\n        return groups.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2zhb_jns.scala:37)\n\tat Problem.main(tmp2zhb_jns.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val s = paren_string.replaceAll(\" \"\
    , \"\")\n        var groups = new ArrayBuffer[String]()\n        var temp = new\
    \ ArrayBuffer[Char]()\n        var paren_counter = 0\n        for (c <- s) {\n\
    \            if (c == '(') {\n                paren_counter += 1\n           \
    \     temp += c\n            } else if (c == ')') {\n                paren_counter\
    \ -= 1\n                temp += c\n            }\n            if (paren_counter\
    \ == 0) {\n                groups += temp.mkString\n                temp.clear\n\
    \            }\n        }\n        groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        // use stack to help build the string\n\
    \        var stack : List[Char] = List()\n        var result : List[String] =\
    \ List()\n        var currentString : String = \"\"\n        paren_string.foreach(x\
    \ => {\n            if (x != ' ') {\n                if (x == '(') {\n       \
    \             stack = x :: stack\n                } else {\n                 \
    \   if (stack.length == 0) {\n                        result = currentString ::\
    \ result\n                        currentString = \"\"\n                    }\
    \ else {\n                        stack = stack.tail\n                       \
    \ currentString += x\n                    }\n                }\n            }\n\
    \        })\n        if (currentString != \"\") {\n            result = currentString\
    \ :: result\n        }\n        result.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0b6e614p.scala:36)\n\tat Problem.main(tmp0b6e614p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        return List()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk_6eujh9.scala:14)\n\tat Problem.main(tmpk_6eujh9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        var nested_count = 0\n        var groups\
    \ = List[String]()\n        var current_group = \"\"\n        paren_string.foreach\
    \ {\n            case '(' => {\n                nested_count += 1\n          \
    \      current_group += '('\n            }\n            case ')' => {\n      \
    \          nested_count -= 1\n                current_group += ')'\n         \
    \       if (nested_count == 0) {\n                    groups = groups :+ current_group\n\
    \                    current_group = \"\"\n                }\n            }\n\
    \            case _ =>\n        }\n        groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013150
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) ((\
    \ )( ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
    \ : String) : List[String] = {\n        val open = ListBuffer[Char]()\n      \
    \  val groups = ListBuffer[String]()\n        var s = \"\"\n        for (c <-\
    \ paren_string) {\n            if (c == '(') {\n                open += c\n  \
    \              s += c\n            } else if (c == ')') {\n                s +=\
    \ c\n                open -= '('\n                if (open.isEmpty) {\n      \
    \              groups += s\n                    s = \"\"\n                }\n\
    \            }\n        }\n        groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013150
