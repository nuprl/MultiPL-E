name: HumanEval_56_correct_bracketing
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // brackets is a string of \"<\" and \">\".\n    // return true if every opening\
  \ bracket has a corresponding closing bracket.\n    // >>> correctBracketing((\"\
  <\"))\n    // (false)\n    // >>> correctBracketing((\"<>\"))\n    // (true)\n \
  \   // >>> correctBracketing((\"<<><>>\"))\n    // (true)\n    // >>> correctBracketing((\"\
  ><<>\"))\n    // (false)\n    def correctBracketing(brackets : String) : Boolean\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(correctBracketing((\"\
  <>\")) == (true));\n    assert(correctBracketing((\"<<><>>\")) == (true));\n   \
  \ assert(correctBracketing((\"<><><<><>><>\")) == (true));\n    assert(correctBracketing((\"\
  <><><<<><><>><>><<><><<>>>\")) == (true));\n    assert(correctBracketing((\"<<<><>>>>\"\
  )) == (false));\n    assert(correctBracketing((\"><<>\")) == (false));\n    assert(correctBracketing((\"\
  <\")) == (false));\n    assert(correctBracketing((\"<<<<\")) == (false));\n    assert(correctBracketing((\"\
  >\")) == (false));\n    assert(correctBracketing((\"<<>\")) == (false));\n    assert(correctBracketing((\"\
  <><><<><>><>><<>\")) == (false));\n    assert(correctBracketing((\"<><><<><>><>>><>\"\
  )) == (false));\n    }\n\n}\n"
completions: ["        def iter(brackets : String, count : Int) : Boolean = {\n  \
    \          if (count < 0) false\n            else if (brackets.isEmpty) count\
    \ == 0\n            else {\n                if (brackets.head == '<') iter(brackets.tail,\
    \ count + 1)\n                else iter(brackets.tail, count - 1)\n          \
    \  }\n        }\n        iter(brackets, 0)", "        var open : Int = 0\n   \
    \     for (i <- 0 until brackets.length) {\n            if (brackets(i) == '<')\
    \ open += 1\n            else open -= 1\n            if (open < 0) return false\n\
    \        }\n        return open == 0", "        var stack = Stack[String]()\n\
    \        for (c <- brackets) {\n            c match {\n                case '<'\
    \ => stack.push(\"<\")\n                case '>' => {\n                    if\
    \ (stack.isEmpty) return false\n                    stack.pop\n              \
    \  }\n            }\n        }\n        stack.isEmpty", "        def aux(s : String,\
    \ fst : Int, cnt : Int) : Boolean = {\n            if (s.isEmpty) fst == 0\n \
    \           else if (s.head == '<') aux(s.tail, fst + 1, cnt)\n            else\
    \ if (fst == 0) false\n            else aux(s.tail, fst - 1, cnt)\n        }\n\
    \        aux(brackets, 0, 0)", "        var stack = 0\n        for (char <- brackets)\
    \ {\n            if (char == '<') stack += 1\n            else if (char == '>')\
    \ stack -= 1\n            if (stack < 0) return false\n        }\n        stack\
    \ == 0", "        def balances(rest : String, balance : Int) : Boolean = {\n \
    \           if (balance < 0) return false\n            if (rest.length == 0) return\
    \ balance == 0\n            if (rest.head == '<') return balances(rest.tail, balance\
    \ + 1)\n            if (rest.head == '>') return balances(rest.tail, balance -\
    \ 1)\n            throw new Exception\n        }\n        balances(brackets, 0)",
  "        var x = 0\n        for (i <- 0 until brackets.length) {\n        \tif (brackets(i)\
    \ == '<') x += 1\n        \telse x -= 1\n        \tif (x < 0) return false\n \
    \       }\n        return x == 0", "        var count = 0\n        for (ch <-\
    \ brackets) {\n            if (ch == '<') count += 1\n            else count -=\
    \ 1\n            if (count < 0) return false\n        }\n        count == 0",
  "        var count = 0\n        for (b <- brackets) {\n            if (b == '<')\
    \ count += 1\n            else if (b == '>') count -= 1\n            if (count\
    \ < 0) return false\n        }\n        return count == 0", "        def helper(i\
    \ : Int, count : Int) : Boolean = {\n            if (i == brackets.length) count\
    \ == 0\n            else if (brackets(i) == '<') helper(i + 1, count + 1)\n  \
    \          else if (count == 0) false\n            else helper(i + 1, count -\
    \ 1)\n        }\n        helper(0, 0)", "        var sum = 0\n        for (i <-\
    \ 0 until brackets.length) {\n            val c = brackets(i)\n            if\
    \ (c == '<') sum += 1\n            else sum -= 1\n            if (sum < 0) return\
    \ false\n        }\n        sum == 0", "        def f(brackets : List[Char], stack\
    \ : List[Char]) : Boolean = {\n            if (brackets.isEmpty) true\n      \
    \      else if (brackets.head == '<') f(brackets.tail, brackets.head :: stack)\n\
    \            else if (stack.isEmpty) false\n            else f(brackets.tail,\
    \ stack.tail)\n        }\n        f(brackets.toList, List())", "        var open\
    \ = 0\n        for (b <- brackets) {\n            if (b == '<') open += 1\n  \
    \          else open -= 1\n            if (open < 0) return false\n        }\n\
    \        open == 0", "        var numOpens = 0\n        for (bracket <- brackets)\
    \ {\n            if (bracket == '<') numOpens += 1\n            else numOpens\
    \ -= 1\n            if (numOpens < 0) return false\n        }\n        return\
    \ numOpens == 0", "        brackets.count(_ == '<') == brackets.count(_ == '>')",
  "        if (brackets.length == 0) return true\n        if (brackets.length == 1)\
    \ return false\n        var stack = List[Char]()\n        var lastPush = ' '\n\
    \        for (char <- brackets) {\n            char match {\n                case\
    \ '<' => stack = char :: stack\n                case '>' => if (stack.length ==\
    \ 0) return false\n                            lastPush = stack.head\n       \
    \                     stack = stack.tail\n                            if (lastPush\
    \ != '<') return false\n            }\n        }\n        if (stack.length !=\
    \ 0) return false\n        return true", "        var depth = 0\n        for (bracket\
    \ <- brackets) {\n            bracket match {\n                case '<' => depth\
    \ += 1\n                case '>' => if (depth == 0) return false; depth -= 1\n\
    \            }\n        }\n        return depth == 0", "        var sum = 0\n\
    \        for (bracket <- brackets) {\n            if (bracket == '<') sum += 1\n\
    \            else sum -= 1\n            if (sum < 0) return false\n        }\n\
    \        return sum == 0", '        brackets.length % 2 == 0 && brackets.filter("<>"
    contains _).groupBy(c => c).forall(kv => kv._1 == "<" && kv._2.length == brackets.filter("<>"
    contains _).groupBy(c => c).head._2.length)', "      var count = 0\n      brackets.foreach\
    \ { c =>\n        if (c == '<') count += 1\n        else if (c == '>') count -=\
    \ 1\n        if (count < 0) return false\n      }\n      return count == 0", " \
    \       var stack = 0\n        for (c <- brackets) {\n            if (c == '<')\
    \ {\n                stack += 1\n            } else {\n                stack -=\
    \ 1\n                if (stack < 0) {\n                    return false\n    \
    \            }\n            }\n        }\n        stack == 0", "        def check(remaining\
    \ : String, openBrackets : Int) : Boolean = {\n            if (remaining.isEmpty)\
    \ openBrackets == 0\n            else if (remaining.head == '<') check(remaining.tail,\
    \ openBrackets + 1)\n            else if (openBrackets == 0) false\n         \
    \   else check(remaining.tail, openBrackets - 1)\n        }\n        check(brackets,\
    \ 0)", "    \tif (brackets.isEmpty) return true\n    \tval stack = new Stack[Char]\n\
    \    \tfor (c <- brackets) {\n    \t\tif (c == '<') stack.push(c)\n    \t\telse\
    \ if (c == '>') {\n    \t\t\tif (stack.isEmpty) return false\n    \t\t\tstack.pop\n\
    \    \t\t}\n    \t}\n    \tstack.isEmpty", "        def check(cs : Array[Char],\
    \ s : Int) : Boolean = {\n            if (s == 0) {\n                if (cs.length\
    \ == 0) true\n                else cs(0) == '>'\n            } else if (cs.length\
    \ == 0) false\n            else {\n                if (cs(0) == '<') check(cs.slice(1,\
    \ cs.length), s + 1)\n                else if (cs(0) == '>') check(cs.slice(1,\
    \ cs.length), s - 1)\n                else false\n            }\n        }\n \
    \       check(brackets.toCharArray, 0)", "        if (brackets.length % 2 == 1)\
    \ return false\n        def isCorrect(str : String) : Boolean = {\n          \
    \  if (str.length == 0) return true\n            if (str.length == 1) return false\n\
    \            if (str.head == '<' && str.last == '>') {\n                val str2\
    \ = str.substring(1, str.length - 1)\n                return isCorrect(str2)\n\
    \            }\n            if (str.head == '<') {\n                val cnt =\
    \ str.indexOf('>')\n                if (cnt == -1) return false\n            \
    \    val str2 = str.substring(1, cnt)\n                val str3 = str.substring(cnt\
    \ + 1)\n                return isCorrect(str2) && isCorrect(str3)\n          \
    \  }\n            if (str.last == '>') {\n                val cnt = str.lastIndexOf('<')\n\
    \                if (cnt == -1) return false\n                val str2 = str.substring(0,\
    \ cnt)\n                val str3 = str.substring(cnt + 1, str.length - 1)\n  \
    \              return isCorrect(str2) && isCorrect(str3)\n            }\n    \
    \        return false\n        }\n        return isCorrect(brackets)", "     \
    \   if (brackets.isEmpty) return true\n        var count = 0\n        for (b <-\
    \ brackets) {\n            if (b == '<') count += 1\n            else if (b ==\
    \ '>') count -= 1\n            if (count < 0) return false\n        }\n      \
    \  count == 0", "        def helper(brackets : String, leftCount : Int) : Boolean\
    \ = {\n            if (brackets.length == 0) leftCount == 0\n            else\
    \ if (brackets.charAt(0) == '<') helper(brackets.substring(1), leftCount + 1)\n\
    \            else if (leftCount == 0) false\n            else helper(brackets.substring(1),\
    \ leftCount - 1)\n        }\n        helper(brackets, 0)", "    \tvar nOpen =\
    \ 0\n    \tfor (c <- brackets) {\n    \t\tif (c == '<') nOpen += 1\n    \t\telse\
    \ nOpen -= 1\n    \t\tif (nOpen < 0) return false\n    \t}\n    \tnOpen == 0",
  "        var open = 0\n        for (c <- brackets) {\n            if (c == '<')\
    \ open += 1\n            else if (c == '>') open -= 1\n            if (open <\
    \ 0) return false\n        }\n        open == 0", "        var stack = new Stack[Char]()\n\
    \        var ok = true\n        brackets.foreach(c => {\n            if (c ==\
    \ '<') stack.push(c)\n            else if (c == '>') {\n                if (stack.isEmpty)\
    \ ok = false\n                else stack.pop\n            }\n        })\n    \
    \    return ok && stack.isEmpty", "        var open = 0\n        for (b <- brackets)\
    \ {\n            if (b == '<') {\n                open += 1\n            } else\
    \ {\n                open -= 1\n                if (open < 0) return false\n \
    \           }\n        }\n        return open == 0", "      var ret = true\n \
    \     var stack = new Stack[Char]\n      for (i <- 0 until brackets.length) {\n\
    \        if (brackets(i) == '<') {\n          stack.push('<')\n        } else\
    \ {\n          if (stack.isEmpty) {\n            ret = false\n          } else\
    \ {\n            stack.pop\n          }\n        }\n      }\n      if (!stack.isEmpty)\
    \ ret = false\n      ret", "        val stack = new Stack[Char]\n        brackets.foreach(x\
    \ => {\n            if (x == '<') stack.push(x)\n            else {\n        \
    \        if (stack.isEmpty) return false\n                else stack.pop\n   \
    \         }\n        })\n        stack.isEmpty", "        var opener = 0\n   \
    \     var closer = 0\n        brackets.foreach(x => if (x == '<') opener += 1\
    \ else closer += 1)\n        return opener == closer", "    \tvar left = 0\n \
    \   \tvar right = 0\n    \tfor (i <- 0 until brackets.length) {\n    \t\tif (brackets(i)\
    \ == '<') left += 1\n    \t\telse right += 1\n    \t\tif (right > left) return\
    \ false\n    \t}\n    \treturn left == right", "        var stack = new scala.collection.mutable.Stack[Char]()\n\
    \        var isCorrect = true\n        for (c <- brackets) {\n            if (c\
    \ == '<') stack.push(c)\n            else if (c == '>') {\n                if\
    \ (stack.isEmpty) {\n                    isCorrect = false\n                 \
    \   return isCorrect\n                }\n                else stack.pop\n    \
    \        }\n        }\n        if (!stack.isEmpty) isCorrect = false\n       \
    \ isCorrect", '        brackets.replaceAll(">","").length == brackets.replaceAll("<","").length',
  "        var counter = 0\n        for (c <- brackets) {\n            if (c == '<')\
    \ counter += 1\n            else if (c == '>') counter -= 1\n            if (counter\
    \ < 0) return false\n        }\n        return counter == 0", "        brackets.count(_\
    \ == '<') == brackets.count(_ == '>')", "      var stack : List[Char] = List()\n\
    \      for (x <- brackets) {\n        if (x == '<') stack = '<' :: stack\n   \
    \     else if (x == '>') {\n          if (stack.isEmpty) return false\n      \
    \    else stack = stack.tail\n        }\n      }\n      return stack.isEmpty",
  "        val stack = new Stack[Char]\n        for (b <- brackets) {\n          \
    \  if (b == '<') {\n                stack.push(b)\n            } else {\n    \
    \            if (stack.isEmpty) {\n                    return false\n        \
    \        } else {\n                    stack.pop\n                }\n        \
    \    }\n        }\n        return stack.isEmpty", "        var returnValue = true\n\
    \        var open = 0\n        for (bracket <- brackets) {\n            if (bracket\
    \ == '<') {\n                open += 1\n            } else {\n               \
    \ open -= 1\n                if (open < 0) {\n                    returnValue\
    \ = false\n                }\n            }\n        }\n        if (open != 0)\
    \ {\n            returnValue = false\n        }\n        returnValue", "     \
    \   var stack = new Stack[Char]\n        for (bracket <- brackets) {\n       \
    \     if (bracket == '<') stack.push(bracket)\n            else if (bracket ==\
    \ '>') {\n                if (stack.size == 0) return false\n                stack.pop\n\
    \            }\n        }\n        stack.size == 0", "        var stack = Stack[Char]()\n\
    \        for (c <- brackets) {\n            if (c == '<') {\n                stack.push(c)\n\
    \            } else {\n                if (stack.isEmpty) {\n                \
    \    return false\n                } else {\n                    stack.pop\n \
    \               }\n            }\n        }\n        return stack.isEmpty", " \
    \       var count = 0\n        brackets.foreach(c => c match {\n            case\
    \ '<' => count += 1\n            case '>' => count -= 1\n        })\n        count\
    \ == 0", "        if (brackets.isEmpty) return true\n        if (brackets.head\
    \ == '>') return false\n        var i = 0\n        var count = 0\n        for\
    \ (c <- brackets) {\n            if (c == '<') count += 1\n            else count\
    \ -= 1\n            if (count < 0) return false\n        }\n        count == 0",
  "      var stack = new Stack[Char]\n      for (b <- brackets) {\n        if (b ==\
    \ '<') stack.push(b)\n        else {\n          if (stack.isEmpty) return false\n\
    \          stack.pop\n        }\n      }\n      return stack.isEmpty", "     \
    \   var numL : Int = 0\n        var numR : Int = 0\n        for (bracket <- brackets)\
    \ {\n            if (bracket == '<') {\n                numL += 1\n          \
    \  } else if (bracket == '>') {\n                numR += 1\n            }\n  \
    \          if (numR > numL) {\n                return false\n            }\n \
    \       }\n        return numL == numR", "        if (brackets.isEmpty) return\
    \ true\n        var count = 0\n        for (c <- brackets) {\n            c match\
    \ {\n                case '<' => count += 1\n                case '>' => count\
    \ -= 1\n            }\n            if (count < 0) return false\n        }\n  \
    \      return count == 0", "        if (brackets.size == 0) return true\n    \
    \    val stack = new Stack[Char]\n        for (ch <- brackets) {\n           \
    \ if (ch == '<') stack.push(ch)\n            else if (ch == '>') if (stack.isEmpty)\
    \ return false else stack.pop\n        }\n        stack.isEmpty", "        var\
    \ counter = 0\n        for (i <- 0 until brackets.length()) {\n            if\
    \ (brackets(i) == '<') counter += 1\n            else counter -= 1\n         \
    \   if (counter < 0) return false\n        }\n        return counter == 0", " \
    \       val stack = new Stack[Char]\n        for (c <- brackets) {\n         \
    \   if (c == '<') {\n                stack.push(c)\n            } else {\n   \
    \             if (stack.isEmpty) {\n                    return false\n       \
    \         } else {\n                    stack.pop\n                }\n       \
    \     }\n        }\n        return stack.isEmpty", "        // Make a stack of\
    \ ints that will hold the number of open brackets in brackets\n        // as we\
    \ go along. We initialize the stack with a 0 and push the number of\n        //\
    \ open brackets we have as we step through brackets.\n        val openCount =\
    \ new Stack[Int]()\n        openCount.push(0)\n        for (i <- 0 until brackets.length)\
    \ {\n            if (brackets(i) == '<') {\n                openCount.push(openCount.top\
    \ + 1)\n            } else {\n                openCount.push(openCount.top - 1)\n\
    \            }\n            if (openCount.top < 0) {\n                return false\n\
    \            }\n        }\n        openCount.top == 0", "        var stack = new\
    \ Stack[Char]\n        for (c <- brackets) c match {\n            case '<' =>\
    \ stack.push(c)\n            case '>' => {\n                if (stack.isEmpty)\
    \ return false\n                else stack.pop\n            }\n        }\n   \
    \     return stack.isEmpty", "        val stack = ListBuffer[Char]()\n       \
    \ for (bracket <- brackets) {\n            if (bracket == '<') stack += bracket\n\
    \            else if (stack.size == 0) return false\n            else stack.remove(stack.size\
    \ - 1)\n        }\n        return stack.size == 0", "      if (brackets.length\
    \ == 0) true\n      else if (brackets.length == 1) false\n      else {\n     \
    \   val (left,right) = brackets.splitAt(1)\n        if (left == \"<\") {\n   \
    \       if (right.length > 0) {\n            val (fst,snd) = right.splitAt(1)\n\
    \            if (fst == \">\") {\n              correctBracketing(snd)\n     \
    \       } else {\n              false\n            }\n          } else {\n   \
    \         false\n          }\n        } else {\n          false\n        }\n \
    \     }", "      val n = brackets.length()\n      val stack = new Stack[String]()\n\
    \      for (i <- 0 until n) {\n        val c = brackets.substring(i, i + 1)\n\
    \        if (c == \"<\") stack.push(c)\n        else if (c == \">\") {\n     \
    \     if (stack.isEmpty) return false\n          stack.pop()\n        }\n    \
    \  }\n      return stack.isEmpty", "      var balance = 0\n      for (c <- brackets)\
    \ {\n        c match {\n          case '<' => balance += 1\n          case '>'\
    \ => balance -= 1\n        }\n        if (balance < 0) return false\n      }\n\
    \      return balance == 0", "        var left = 0\n        for (b <- brackets)\
    \ {\n            if (b == '<') left += 1\n            else left -= 1\n       \
    \     if (left < 0) return false\n        }\n        return left == 0", "    \
    \    def rec(count : Int, brackets : String) : Boolean = {\n            if (count\
    \ < 0) false\n            else if (brackets.length == 0) count == 0\n        \
    \    else if (brackets.charAt(0) == '<') rec(count + 1, brackets.substring(1))\n\
    \            else rec(count - 1, brackets.substring(1))\n        }\n        rec(0,\
    \ brackets)", "        val stack = new Stack[Char]\n        for (ch <- brackets)\
    \ {\n            if (ch == '<') stack.push(ch)\n            else if (ch == '>')\
    \ {\n                if (stack.isEmpty) return false\n                else stack.pop\n\
    \            }\n        }\n        stack.isEmpty", "      var depth = 0\n    \
    \  for (s <- brackets) {\n        if (s == '<') depth += 1\n        else depth\
    \ -= 1\n        if (depth < 0) return false\n      }\n      depth == 0", "   \
    \     var stack = List[Char]()\n        for (c <- brackets) {\n            if\
    \ (c == '<') {\n                stack = c :: stack\n            } else {\n   \
    \             if (stack.length == 0) return false\n                if (stack.head\
    \ != '<') return false\n                stack = stack.tail\n            }\n  \
    \      }\n        return stack.length == 0", "        val stack = new Stack[Char]\n\
    \        for (c <- brackets) {\n            if (c == '<') {\n                stack.push(c)\n\
    \            } else {\n                if (stack.isEmpty) {\n                \
    \    return false\n                } else {\n                    stack.pop\n \
    \               }\n            }\n        }\n        return stack.isEmpty", " \
    \       var counter = 0\n        for (i <- 0 until brackets.length) {\n      \
    \      brackets(i) match {\n                case '<' => counter += 1\n       \
    \         case '>' => counter -= 1\n            }\n            if (counter < 0)\
    \ return false\n        }\n        return counter == 0", "        var count =\
    \ 0\n        for (bracket <- brackets) {\n            bracket match {\n      \
    \          case '<' => count += 1\n                case '>' => count -= 1\n  \
    \          }\n            if (count < 0) return false\n        }\n        count\
    \ == 0", "        val stack = new Stack[Char]\n        var allCorrect = true\n\
    \        for (c <- brackets) {\n            if (c == '<') stack.push(c)\n    \
    \        else if (c == '>') {\n                if (stack.isEmpty) allCorrect =\
    \ false\n                else stack.pop\n            }\n        }\n        if\
    \ (!stack.isEmpty) allCorrect = false\n        allCorrect", "        var count\
    \ = 0\n        for (i <- 0 until brackets.length) {\n            if (brackets(i)\
    \ == '<') count += 1\n            else count -= 1\n            if (count < 0)\
    \ return false\n        }\n        return count == 0", "        val stack = new\
    \ Stack[Char]\n        for (bracket <- brackets) {\n            if (bracket ==\
    \ '<') stack.push(bracket)\n            else if (stack.isEmpty) return false\n\
    \            else stack.pop\n        }\n        stack.isEmpty", "        var depth\
    \ = 0\n        for (i <- 0 until brackets.length) {\n            if (brackets(i)\
    \ == '<') depth += 1\n            else depth -= 1\n            if (depth < 0)\
    \ return false\n        }\n        depth == 0", "        var bracketsLeft = 0\n\
    \        for (i <- 0 until brackets.length) {\n            if (brackets(i) ==\
    \ '<') bracketsLeft += 1\n            else if (brackets(i) == '>') bracketsLeft\
    \ -= 1\n            if (bracketsLeft < 0) return false\n        }\n        return\
    \ bracketsLeft == 0", "        var i = 0\n        var stack = new Stack[Char]\n\
    \        while (i < brackets.length) {\n            if (brackets(i) == '<') {\n\
    \                stack.push('<')\n            } else {\n                if (stack.isEmpty)\
    \ return false\n                if (stack.pop() != '<') return false\n       \
    \     }\n            i += 1\n        }\n        if (stack.isEmpty) true else false",
  "    \tif (brackets.isEmpty) return true\n    \tvar count = 0\n    \tfor (x <- brackets)\
    \ {\n    \t\tif (x == '<') count += 1\n    \t\telse count -= 1\n    \t\tif (count\
    \ < 0) return false\n    \t}\n    \treturn count == 0", "        // for every\
    \ \"<\" character, increment a counter.\n        // for every \">\" character,\
    \ decrement the counter.\n        // if the counter drops below zero at any point,\
    \ return false.\n        // if the counter is nonzero at the end, return false.\n\
    \        // if the counter never drops below zero, return true.\n        var count\
    \ = 0\n        for (char <- brackets) {\n            if (char == '<') count +=\
    \ 1\n            else if (char == '>') count -= 1\n            if (count < 0)\
    \ return false\n        }\n        return count == 0", "        if (brackets.length\
    \ % 2 == 1) return false\n        var count = 0\n        for (i <- 0 until brackets.length)\
    \ {\n            if (brackets(i) == '<') count += 1\n            else count -=\
    \ 1\n            if (count < 0) return false\n        }\n        return count\
    \ == 0", "        val length = brackets.length\n        val stack = new ArrayStack[Char]\n\
    \        for (i <- 0 until length) {\n            if (brackets(i) == '<') {\n\
    \                stack.push('<')\n            } else {\n                if (stack.isEmpty)\
    \ return false\n                else {\n                    stack.pop\n      \
    \          }\n            }\n        }\n        stack.isEmpty", "        // add\
    \ a closing bracket at the end to avoid special cases later\n        brackets\
    \ + \">\" == brackets.replaceAll(\"<>\", \"\")", "        var stack = new Stack[Char]()\n\
    \        for (c <- brackets) {\n            if (c == '<') stack.push(c)\n    \
    \        else {\n                if (stack.isEmpty) return false\n           \
    \     stack.pop\n            }\n        }\n        return stack.isEmpty", "  \
    \      def check(stack : List[Char], brackets : String) : Boolean = {\n      \
    \      if (brackets.length == 0) stack.isEmpty\n            else {\n         \
    \       if (brackets.head == '<') check(brackets.head :: stack, brackets.tail)\n\
    \                else if (stack.isEmpty) false\n                else check(stack.tail,\
    \ brackets.tail)\n            }\n        }\n        check(List(), brackets)",
  "        var answer = true\n        var current = 0\n        for (i <- 0 until brackets.length)\
    \ {\n            if (brackets(i) == '<') {\n                current += 1\n   \
    \         } else {\n                current -= 1\n            }\n            if\
    \ (current < 0) {\n                answer = false\n            }\n        }\n\
    \        if (current != 0) {\n            answer = false\n        }\n        return\
    \ answer", "        var lc = 0\n        var rc = 0\n        for (b <- brackets)\
    \ {\n            if (b == '<') lc += 1\n            else if (b == '>') rc += 1\n\
    \            if (rc > lc) return false\n        }\n        return rc == lc", " \
    \       // >>> correctBracketing(\"<><>\")\n        // (true)\n        // >>>\
    \ correctBracketing(\"<><><>>\")\n        // (true)\n        // >>> correctBracketing(\"\
    <><><>><>\")\n        // (true)\n        // >>> correctBracketing(\"<>><><><>><>\"\
    )\n        // (true)\n        // >>> correctBracketing(\"<><><>><><>\")\n    \
    \    // (true)\n        // >>> correctBracketing(\"<<><><>><><>\")\n        //\
    \ (true)\n        // >>> correctBracketing(\"<>><<><><>><><>\")\n        // (true)\n\
    \        // >>> correctBracketing(\"<><><>><>><><><>><><>\")\n        // (true)\n\
    \        // >>> correctBracketing(\"<>><><><>><>><><><>><><>\")\n        // (true)\n\
    \        // >>> correctBracketing(\"<><><>><><><>><><><>><><>\")\n        // (true)\n\
    \        // >>> correctBracketing(\"<>><><><>><><><>><><><>><><>\")\n        //\
    \ (true)\n        // >>> correctBracketing(\"<><><>><><><>><><><>><><><>><><>\"\
    )\n        // (true)\n        // >>> correctBracketing(\"<>><><><>><><><>><><><>><><><>><><>\"\
    )\n        // (true)\n        // >>> correctBracketing(\"<><><>><><><>><><><>><><><>><><><>><><>\"\
    )\n        // (true)\n        // >>> correctBracketing(\"<>><><><>><><><>><><><>><><><>><><><>><><>\"\
    )\n        // (true)\n        // >>> correctBracketing(\"<><><>><><><>><><><>><><><>><><><>><><><>><><>\"\
    )\n        // (true)\n        // >>> correctBracketing(\"<>><><><>><><><>><><><>><><><>><><><>><><><>><><",
  "        var stack = List[Char]()\n        for (c <- brackets) {\n            if\
    \ (c == '<') {\n                stack = c :: stack\n            } else {\n   \
    \             if (stack.isEmpty) return false\n                stack = stack.tail\n\
    \            }\n        }\n        return stack.isEmpty", "        var count =\
    \ 0\n        for (i <- 0 until brackets.length) {\n            if (brackets(i)\
    \ == '<') count += 1\n            else if (brackets(i) == '>') count -= 1\n  \
    \          if (count < 0) return false\n        }\n        count == 0", "    \
    \  val stack = new Stack[Char]\n      for (i <- 0 until brackets.length) {\n \
    \       if (brackets(i) == '<') stack.push('<')\n        else {\n          if\
    \ (stack.isEmpty) return false\n          else stack.pop\n        }\n      }\n\
    \      stack.isEmpty", "        var counter = 0\n        for (c <- brackets) {\n\
    \            if (c == '<') {\n                counter += 1\n            } else\
    \ {\n                counter -= 1\n            }\n            if (counter < 0)\
    \ {\n                return false\n            }\n        }\n        counter ==\
    \ 0", "        var open = 0\n        for (b <- brackets) {\n            if (b\
    \ == '<') open += 1\n            else if (b == '>') open -= 1\n            if\
    \ (open < 0) return false\n        }\n        open == 0", "    \tval stack = Stack[Char]()\n\
    \    \tfor (c <- brackets) {\n    \t\tif (c == '<') stack.push(c)\n    \t\telse\
    \ if (c == '>') {\n    \t\t\tif (stack.isEmpty) return false\n    \t\t\tstack.pop\n\
    \    \t\t}\n    \t}\n    \tstack.isEmpty", "        val stack = Stack[Char]()\n\
    \        for (c <- brackets) {\n            if (c == '<') {\n                stack.push(c)\n\
    \            } else {\n                if (stack.isEmpty) return false\n     \
    \           stack.pop\n            }\n        }\n        stack.isEmpty", "   \
    \     var stack = ListBuffer[Char]()\n        for (ch <- brackets) {\n       \
    \     if (ch == '<') stack += ch\n            else if (ch == '>') {\n        \
    \        if (stack.isEmpty) return false\n                stack -= stack.last\n\
    \            }\n        }\n        stack.isEmpty", "        var openingBrackets\
    \ : Int = 0\n        for (bracket <- brackets) {\n            bracket match {\n\
    \                case '<' => openingBrackets += 1\n                case '>' =>\
    \ openingBrackets -= 1\n            }\n            if (openingBrackets < 0) return\
    \ false\n        }\n        openingBrackets == 0", "        val n = brackets.length\n\
    \        var c = 0\n        for (i <- 0 until n) {\n            if (brackets(i)\
    \ == '<') c += 1\n            else c -= 1\n            if (c < 0) return false\n\
    \        }\n        return c == 0", "        var count = 0\n        for (i <-\
    \ 0 until brackets.length) {\n            if (brackets(i) == '<') {\n        \
    \        count += 1\n            } else {\n                count -= 1\n      \
    \      }\n            if (count < 0) {\n                return false\n       \
    \     }\n        }\n        return count == 0", "        if (brackets.length %\
    \ 2 == 1) return false\n        var balance = 0\n        for (i <- 0 until brackets.length)\
    \ {\n            if (brackets(i) == '<') balance += 1\n            else balance\
    \ -= 1\n            if (balance < 0) return false\n        }\n        return balance\
    \ == 0", "        val stack = new Stack[Char]\n        var good = true\n     \
    \   for (c <- brackets) {\n            if (c == '<') stack.push(c)\n         \
    \   else if (c == '>') {\n                if (stack.isEmpty) good = false\n  \
    \              else stack.pop\n            }\n        }\n        good && stack.isEmpty",
  "        var closesRequired = 0\n        for (i <- 0 until brackets.length) {\n\
    \            if (brackets(i) == '<') closesRequired += 1\n            else closesRequired\
    \ -= 1\n            if (closesRequired < 0) return false\n        }\n        closesRequired\
    \ == 0", "        var numOpen = 0\n        for (i <- 0 until brackets.length)\
    \ {\n            if (brackets(i) == '<') numOpen += 1\n            else numOpen\
    \ -= 1\n            if (numOpen < 0) return false\n        }\n        return numOpen\
    \ == 0", "    \tvar result = true\n    \tval stack = Stack[Char]()\n    \tfor\
    \ (char <- brackets) {\n    \t\tif (char == '<') {\n    \t\t\tstack.push(char)\n\
    \    \t\t} else {\n    \t\t\tif (stack.isEmpty) {\n    \t\t\t\tresult = false\n\
    \    \t\t\t} else {\n    \t\t\t\tstack.pop\n    \t\t\t}\n    \t\t}\n    \t}\n\
    \    \tif (!stack.isEmpty) result = false\n    \tresult", "        var stack =\
    \ new Stack[Char]()\n        for (bracket <- brackets) {\n            if (bracket\
    \ == '<') stack.push(bracket)\n            else if (stack.isEmpty) return false\n\
    \            else stack.pop\n        }\n        return stack.isEmpty", "     \
    \   var count = 0\n        for (bracket <- brackets) {\n            if (bracket\
    \ == '<') {\n                count += 1\n            } else if (bracket == '>')\
    \ {\n                count -= 1\n            }\n            if (count < 0) {\n\
    \                return false\n            }\n        }\n        return count\
    \ == 0", "        var depth = 0\n        brackets.foreach(x => {\n           \
    \ if (x == '<') depth += 1\n            else depth -= 1\n            if (depth\
    \ < 0) return false\n        })\n        return depth == 0", "        var stack\
    \ = new Stack[Char]()\n        var isCorrect = true\n        for (i <- 0 until\
    \ brackets.length) {\n            var char = brackets.charAt(i)\n            if\
    \ (char == '<') {\n                stack.push(char)\n            } else {\n  \
    \              if (stack.isEmpty) {\n                    isCorrect = false\n \
    \               } else {\n                    stack.pop\n                }\n \
    \           }\n        }\n        isCorrect && stack.isEmpty", "        // \"\
    (\" and \")\" correspond to \"<\" and \">\"\n        def balanced(brackets : String)\
    \ : Boolean = {\n            var net = 0\n            for (b <- brackets) {\n\
    \                b match {\n                    case '(' => net += 1\n       \
    \             case ')' => net -= 1\n                }\n                if (net\
    \ < 0) return false\n            }\n            if (net == 0) true else false\n\
    \        }\n        balanced(brackets.replace(\"<\", \"(\").replace(\">\", \"\
    )\"))", "        val count = brackets.foldLeft(0)((acc, c) => if (c == '<') acc\
    \ + 1 else acc - 1)\n        count == 0", "    \tval s = Stack[Char]()\n    \t\
    for (c <- brackets) {\n    \t\tif (c == '<') s.push(c)\n    \t\telse {\n    \t\
    \t\tif (s.isEmpty) return false\n    \t\t\ts.pop\n    \t\t}\n    \t}\n    \ts.isEmpty",
  "        var open = 0\n        var close = 0\n        brackets.foreach(c => {\n\
    \            if (c == '<') {\n                open += 1\n            } else if\
    \ (c == '>') {\n                close += 1\n            }\n        })\n      \
    \  return open == close", "        var stack = List[Char]()\n        for (c <-\
    \ brackets) {\n            if (c == '<') stack = c :: stack\n            else\
    \ {\n                if (stack.isEmpty) return false\n                stack =\
    \ stack.tail\n            }\n        }\n        stack.isEmpty", "        var stack\
    \ = ListBuffer[Char]()\n        for (i <- 0 until brackets.length) {\n       \
    \     val c = brackets(i)\n            if (c == '<') stack += c\n            else\
    \ if (c == '>') {\n                if (stack.length == 0) return false\n     \
    \           else stack.remove(stack.length - 1)\n            }\n        }\n  \
    \      stack.length == 0", "        var count = 0\n        for (c <- brackets)\
    \ {\n            if (c == '<') count += 1\n            else if (c == '>') count\
    \ -= 1\n            if (count < 0) return false\n        }\n        count == 0",
  "        val xs = brackets.toList\n        var count = 0\n        for (x <- xs)\
    \ {\n            if (x == '<') count += 1\n            else if (x == '>') count\
    \ -= 1\n            if (count < 0) return false\n        }\n        count == 0",
  "    \tif (brackets.length == 0) {\n    \t\treturn true\n    \t}\n    \tvar inOpen\
    \ = 0\n    \tvar inClose = 0\n    \tfor (c <- brackets) {\n    \t\tif (c == '<')\
    \ inOpen += 1\n    \t\telse inClose += 1\n    \t\tif (inClose > inOpen) return\
    \ false\n    \t}\n    \treturn inOpen == inClose", "        var count = 0\n  \
    \      for (i <- 0 until brackets.length) {\n            if (brackets(i) == '<')\
    \ count += 1\n            else if (brackets(i) == '>') count -= 1\n          \
    \  if (count < 0) return false\n        }\n        return count == 0", "     \
    \   var count = 0\n        for (c <- brackets) {\n            c match {\n    \
    \            case '<' => count += 1\n                case '>' => count -= 1\n\
    \            }\n            if (count < 0) return false\n        }\n        return\
    \ count == 0", "        var openCount = 0\n        for (bracket <- brackets) {\n\
    \            if (bracket == '<') openCount += 1\n            else if (bracket\
    \ == '>') openCount -= 1\n            if (openCount < 0) return false\n      \
    \  }\n        return openCount == 0", "        val stack = new Stack[Char]\n \
    \       brackets.foreach {\n            case '<' => stack.push('<')\n        \
    \    case '>' => if (stack.isEmpty || stack.pop != '<') return false\n       \
    \ }\n        stack.isEmpty", "        var stack = ListBuffer[Char]()\n       \
    \ brackets.foreach(c => if (c == '<') stack += c else if (stack.size > 0) stack.remove(stack.size\
    \ - 1) else return false)\n        return stack.size == 0", "    \tif (brackets.isEmpty)\
    \ true\n    \telse if (brackets.count(_ == '<') != brackets.count(_ == '>')) false\n\
    \    \telse {\n    \t\tval count = 0\n    \t\tdef helper(brackets : String, count\
    \ : Int) : Boolean = {\n    \t\t\tif (brackets.isEmpty) {\n    \t\t\t\tif (count\
    \ == 0) true\n    \t\t\t\telse false\n    \t\t\t}\n    \t\t\telse if (brackets.head\
    \ == '<') helper(brackets.tail, count + 1)\n    \t\t\telse if (brackets.head ==\
    \ '>') {\n    \t\t\t\tif (count == 0) false\n    \t\t\t\telse helper(brackets.tail,\
    \ count - 1)\n    \t\t\t}\n    \t\t\telse false\n    \t\t}\n    \t\thelper(brackets,\
    \ count)\n    \t}", "        brackets.count(_ == '<') == brackets.count(_ == '>')",
  "        def correctBracketing0(brackets : String, count : Int) : Boolean = {\n\
    \            if (count < 0) return false\n            if (brackets.isEmpty) count\
    \ == 0\n            else if (brackets.head == '<') correctBracketing0(brackets.tail,\
    \ count + 1)\n            else correctBracketing0(brackets.tail, count - 1)\n\
    \        }\n        correctBracketing0(brackets, 0)", "        var leftBrackets\
    \ = 0\n        for (c <- brackets) {\n            if (c == '<') leftBrackets +=\
    \ 1\n            else if (c == '>') leftBrackets -= 1\n            if (leftBrackets\
    \ < 0) return false\n        }\n        return leftBrackets == 0", "        def\
    \ check(str : String, open : Int) : Boolean = {\n            if (str.isEmpty)\
    \ open == 0\n            else if (str.head == '<') check(str.tail, open + 1)\n\
    \            else if (open == 0) false\n            else check(str.tail, open\
    \ - 1)\n        }\n        check(brackets, 0)", "        val stack = new scala.collection.mutable.Stack[Char]\n\
    \        for (c <- brackets) {\n            if (c == '<') stack.push(c)\n    \
    \        else {\n                if (stack.isEmpty) return false\n           \
    \     stack.pop\n            }\n        }\n        stack.isEmpty", "        val\
    \ stack = new Stack[Char]\n        for (c <- brackets) {\n            if (c ==\
    \ '<') stack.push(c)\n            else if (c == '>') {\n                if (stack.isEmpty)\
    \ return false\n                else stack.pop\n            }\n        }\n   \
    \     stack.isEmpty", "      var opened = 0\n      for (i <- 0 until brackets.length)\
    \ {\n        if (brackets(i) == '<') opened += 1\n        else opened -= 1\n \
    \       if (opened < 0) return false\n      }\n      return opened == 0", "  \
    \      val n = brackets.length\n        var count = 0\n        for (i <- 0 until\
    \ n) {\n            if (brackets(i) == '<') count += 1\n            else count\
    \ -= 1\n            if (count < 0) return false\n        }\n        count == 0",
  "        var cnt = 0\n        for (bracket <- brackets) {\n            if (bracket\
    \ == '<') cnt += 1\n            else if (bracket == '>') cnt -= 1\n          \
    \  if (cnt < 0) return false\n        }\n        return cnt == 0", "        var\
    \ count = 0\n        for (c <- brackets) if (c == '<') count += 1 else count -=\
    \ 1\n        return count == 0", "        var count = 0\n        for (i <- 0 until\
    \ brackets.length) {\n            if (brackets(i) == '<') {\n                count\
    \ += 1\n            } else {\n                count -= 1\n            }\n    \
    \        if (count < 0) {\n                return false\n            }\n     \
    \   }\n        return count == 0", "        var count = 0\n        brackets.foreach(ch\
    \ => {\n            if (ch == '<') count += 1\n            else if (ch == '>')\
    \ count -= 1\n            if (count < 0) return false\n        })\n        return\
    \ count == 0", "        var count = 0\n        brackets.foreach(c => {\n     \
    \       if (c == '<') count += 1\n            else if (c == '>') count -= 1\n\
    \            if (count < 0) return false\n        })\n        return count ==\
    \ 0", "        var count = 0\n        for (c <- brackets) {\n            if (c\
    \ == '<') count += 1\n            else if (c == '>') count -= 1\n            if\
    \ (count < 0) return false\n        }\n        return count == 0", "      val\
    \ stack = new Stack[Char]\n      for (ch <- brackets) {\n        if (ch == '<')\
    \ stack.push(ch)\n        else if (ch == '>') {\n          if (stack.isEmpty)\
    \ return false\n          else stack.pop\n        }\n      }\n      stack.isEmpty",
  "        // the loop is well-founded because the length of brackets is decreasing.\n\
    \        @annotation.tailrec\n        def loop(brackets : String, openCount :\
    \ Int) : Boolean = {\n            if (brackets.isEmpty)\n                openCount\
    \ == 0\n            else if (brackets.head == '<')\n                loop(brackets.tail,\
    \ openCount + 1)\n            else if (openCount == 0)\n                false\n\
    \            else\n                loop(brackets.tail, openCount - 1)\n      \
    \  }\n        loop(brackets, 0)", "        var opened = 0\n        for (bracket\
    \ <- brackets) {\n            if (bracket == '<') opened += 1\n            else\
    \ if (bracket == '>') opened -= 1\n            if (opened < 0) return false\n\
    \        }\n        return opened == 0", "      var numOpen = 0\n      for (i\
    \ <- 0 until brackets.length) {\n        if (brackets(i) == '<') numOpen += 1\n\
    \        else numOpen -= 1\n        if (numOpen < 0) return false\n      }\n \
    \     return numOpen == 0", "        val stack = ListBuffer[Char]()\n        for\
    \ (c <- brackets) {\n            if (c == '<') {\n                stack += c\n\
    \            } else {\n                if (stack.isEmpty) return false\n     \
    \           stack.remove(stack.length - 1)\n            }\n        }\n       \
    \ return stack.isEmpty", "        var open = 0\n        for (i <- 0 until brackets.length)\
    \ {\n            if (brackets(i) == '<') open += 1\n            else if (brackets(i)\
    \ == '>') open -= 1\n            if (open < 0) return false\n        }\n     \
    \   return open == 0", "        val splitBrackets = brackets.split(\"\")\n   \
    \     val stack = Stack[String]()\n        for (ch <- splitBrackets) {\n     \
    \       if (ch == \"<\") {\n                stack.push(ch)\n            } else\
    \ if (ch == \">\") {\n                if (stack.isEmpty) {\n                 \
    \   return false\n                } else {\n                    stack.pop\n  \
    \              }\n            }\n        }\n        return stack.isEmpty", " \
    \       var bracketCount = 0\n        for (b <- brackets) {\n            b match\
    \ {\n                case '<' => bracketCount += 1\n                case '>' =>\
    \ bracketCount -= 1\n            }\n            if (bracketCount < 0) return false\n\
    \        }\n        bracketCount == 0", "        var stack = new Stack[String]\n\
    \        for (bracket <- brackets) {\n            if (bracket == '<') {\n    \
    \            stack.push(\"<\")\n            } else {\n                if (stack.isEmpty)\
    \ return false\n                stack.pop\n            }\n        }\n        return\
    \ stack.isEmpty", "        var stack = new Stack[Char]\n        for (c <- brackets)\
    \ {\n            if (c == '<') stack.push(c)\n            else {\n           \
    \     if (stack.isEmpty) return false\n                else stack.pop\n      \
    \      }\n        }\n        return stack.isEmpty", "        var stack = ListBuffer[Char]()\n\
    \        brackets.foreach(c => if (c == '<') stack += c else if (stack.isEmpty\
    \ || stack.last != '<') return false else stack.trimEnd(1))\n        stack.isEmpty",
  '        // your code here', "        val stack = new Stack[Char]\n        for (c\
    \ <- brackets) {\n            if (c == '<') stack.push(c)\n            else {\n\
    \                if (stack.size == 0) return false\n                else stack.pop\n\
    \            }\n        }\n        stack.size == 0", "        var stack = List[Char]()\n\
    \        for (i <- 0 until brackets.length) {\n            val c = brackets(i)\n\
    \            if (c == '<') stack = c :: stack\n            else {\n          \
    \      if (stack.isEmpty) return false\n                stack = stack.tail\n \
    \           }\n        }\n        return stack.isEmpty", "        var depth =\
    \ 0\n        for (x <- brackets) {\n            if (x == '<') {\n            \
    \    depth += 1\n            } else if (x == '>') {\n                depth -=\
    \ 1\n            }\n            if (depth < 0) {\n                return false\n\
    \            }\n        }\n        return depth == 0", "    \tval stk = new Stack[Char]\n\
    \    \tfor (c <- brackets) {\n    \t\tif (c == '<') stk.push(c)\n    \t\telse\
    \ if (c == '>') {\n    \t\t\tif (stk.isEmpty) return false\n    \t\t\telse stk.pop\n\
    \    \t\t}\n    \t}\n    \tstk.isEmpty", "        val stack = new scala.collection.mutable.Stack[Char]\n\
    \        for (c <- brackets) {\n            if (c == '<') stack.push(c)\n    \
    \        else if (c == '>') {\n                if (stack.isEmpty) return false\n\
    \                stack.pop\n            }\n        }\n        return stack.isEmpty",
  "        var count = 0\n        for (i <- 0 until brackets.length) {\n         \
    \   if (brackets(i) == '<') count += 1\n            else if (brackets(i) == '>')\
    \ count -= 1\n            if (count < 0) return false\n        }\n        return\
    \ count == 0", "        var cnt = 0\n        for (c <- brackets) c match {\n \
    \           case '<' => cnt += 1\n            case '>' => cnt -= 1\n         \
    \   case _ => ()\n        }\n        cnt == 0", "      var result = true\n   \
    \   var counter = 0\n      brackets.foreach(c => if (c == '<') counter += 1 else\
    \ counter -= 1)\n      if (counter != 0) result = false\n      result", "    \
    \    // return the first opening bracket that does not have a corresponding closing\
    \ bracket.\n        // return None if every opening bracket has a corresponding\
    \ closing bracket.\n        def firstMissingClosingBracket(brackets : String)\
    \ : Option[Int] = {\n            val openingBrackets = new Stack[Int]()\n    \
    \        var i = 0\n            while (i < brackets.length) {\n              \
    \  if (brackets(i) == '<') {\n                    openingBrackets.push(i)\n  \
    \              } else {\n                    if (openingBrackets.isEmpty) {\n\
    \                        return Some(i)\n                    } else {\n      \
    \                  openingBrackets.pop()\n                    }\n            \
    \    }\n                i += 1\n            }\n            if (openingBrackets.isEmpty)\
    \ {\n                None\n            } else {\n                Some(openingBrackets.pop())\n\
    \            }\n        }\n        firstMissingClosingBracket(brackets) == None",
  "    \tvar stack = new Stack[Char]()\n    \tvar i = 0\n    \twhile (i < brackets.length)\
    \ {\n    \t\tif (brackets(i) == '<') stack.push('<')\n    \t\telse if (brackets(i)\
    \ == '>') {\n    \t\t\tif (stack.isEmpty) return false\n    \t\t\telse stack.pop\n\
    \    \t\t}\n    \t\ti += 1\n    \t}\n    \tstack.isEmpty", "    \tval n = brackets.length\n\
    \    \tif (n % 2 == 1) return false\n    \tval stack = Stack[Char]()\n    \tvar\
    \ i = 0\n    \twhile (i < n) {\n    \t\tif (brackets(i) == '<') stack.push('<')\n\
    \    \t\telse {\n    \t\t\tif (stack.isEmpty) return false\n    \t\t\tstack.pop\n\
    \    \t\t}\n    \t\ti += 1\n    \t}\n    \treturn stack.isEmpty", "        def\
    \ invalidBracketing(a : Array[Int]) : Boolean = {\n            var x = 0\n   \
    \         while (x < a.length) {\n                if (a(x) < 0) return true\n\
    \                x += 1\n            }\n            return false\n        }\n\
    \        var bArray = brackets.toCharArray\n        // a(i) is the number of unmatched\
    \ open brackets up to and including i,\n        // and the number of unmatched\
    \ close brackets after i.\n        // a(i) will be < 0 if there are too many close\
    \ brackets.\n        // >>> val a = \"<<<>>>\".toCharArray\n        // >>> a.map\
    \ {c => if (c == '<') 1 else -1}\n        // res0: Array[Int] = Array(1, 2, 3,\
    \ -1, -2, -3)\n        var a = bArray.map {c => if (c == '<') 1 else -1}\n   \
    \     // >>> a.scanLeft(0)(_ + _)\n        // res1: Array[Int] = Array(0, 1, 3,\
    \ 6, 5, 3, 0)\n        a = a.scanLeft(0)(_ + _)\n        if (invalidBracketing(a))\
    \ return false\n        // If a(i) is negative, then the first unmatched close\
    \ bracket occurs to the right of\n        // the first unmatched open bracket.\n\
    \        // >>> a\n        // res2: Array[Int] = Array(0, 1, 3, 6, 5, 3, 0)\n\
    \        // >>> a.map {_ > 0}\n        // res3: Array[Boolean] = Array(true, true,\
    \ true, true, true, true, true)\n        // >>> a.map {_ > 0}.scanLeft(false)(_\
    \ || _)\n        // res4: Array[Boolean] = Array(false, true, true, true, true,\
    \ true, true)\n        // >>> a.map {_ > 0}.scanLeft(false)(_ || _).slice(1, a.length)\n\
    \        // res5: Array[Boolean] = Array(true, true, true, true, true, true)\n\
    \        // >>> a.map {_ > 0}.scanLeft(false)(_ ||", "      var l : Int = 0\n\
    \      for (i <- 0 until brackets.length) {\n        if (brackets(i) == '<') l\
    \ += 1\n        else l -= 1\n        if (l < 0) return false\n      }\n      return\
    \ l == 0", "        var count = 0\n        for (i <- 0 until brackets.length)\
    \ {\n            if (brackets(i) == '<') count += 1\n            else count -=\
    \ 1\n            if (count < 0) return false\n        }\n        return count\
    \ == 0", "        // stack for keeping track of opening brackets.\n        val\
    \ bracketStack = new Stack[Char]\n        for (c <- brackets) c match {\n    \
    \        case '<' => bracketStack.push(c)\n            case '>' => if (bracketStack.isEmpty)\
    \ return false else bracketStack.pop\n        }\n        // at the end of iteration,\
    \ the stack should be empty.\n        bracketStack.isEmpty", "        var bracketsStack\
    \ = Stack[Char]()\n        for (bracket <- brackets) {\n            if (bracket\
    \ == '<') bracketsStack.push(bracket)\n            else if (bracketsStack.size\
    \ > 0) bracketsStack.pop\n            else return false\n        }\n        bracketsStack.size\
    \ == 0", "        def aux(index : Int, count : Int) : Boolean = {\n          \
    \  if (index == brackets.length) count == 0\n            else if (brackets(index)\
    \ == '<') aux(index + 1, count + 1)\n            else if (count == 0) false\n\
    \            else aux(index + 1, count - 1)\n        }\n        aux(0, 0)", " \
    \       var openCount = 0\n        var closeCount = 0\n        var isCorrect =\
    \ true\n        for (i <- 0 until brackets.length) {\n            if (brackets(i)\
    \ == '<') {\n                openCount += 1\n            } else {\n          \
    \      closeCount += 1\n            }\n            if (closeCount > openCount)\
    \ {\n                isCorrect = false\n            }\n        }\n        if (openCount\
    \ != closeCount) {\n            isCorrect = false\n        }\n        isCorrect",
  "      if (brackets.length % 2 != 0) return false\n      var st = new Stack[Char]\n\
    \      for (b <- brackets) {\n        if (b == '<') st.push(b)\n        else {\n\
    \          if (st.isEmpty) return false\n          if (st.pop() != '<') return\
    \ false\n        }\n      }\n      return st.isEmpty", "        var left = 0\n\
    \        for (c <- brackets) {\n            if (c == '<') left += 1\n        \
    \    else if (c == '>') left -= 1\n            if (left < 0) return false\n  \
    \      }\n        return left == 0", "        var count = 0\n        for (i <-\
    \ 0 until brackets.length) {\n            if (brackets(i) == '<') {\n        \
    \        count += 1\n            } else {\n                count -= 1\n      \
    \      }\n            if (count < 0) {\n                return false\n       \
    \     }\n        }\n        return count == 0", "        var count = 0\n     \
    \   brackets.foreach {c =>\n            if (c == '<') count += 1\n           \
    \ else if (c == '>') count -= 1\n            if (count < 0) return false\n   \
    \     }\n        return count == 0", "        var count = 0\n        for (bracket\
    \ <- brackets) {\n            if (bracket == '<') {\n                count +=\
    \ 1\n            } else if (bracket == '>') {\n                count -= 1\n  \
    \          }\n            if (count < 0) {\n                return false\n   \
    \         }\n        }\n        return count == 0", "        var pos = 0\n   \
    \     for (b <- brackets) {\n            if (b == '<') pos += 1\n            else\
    \ pos -= 1\n            if (pos < 0) return false\n        }\n        return pos\
    \ == 0", "        var c = 0\n        for (i <- 0 until brackets.length) {\n  \
    \          if (brackets(i) == '<') {\n                c += 1\n            } else\
    \ {\n                c -= 1\n            }\n            if (c < 0) return false\n\
    \        }\n        c == 0", "        var count = 0\n        for (b <- brackets)\
    \ if (b == '<') count += 1 else count -= 1\n        return count == 0", "    \
    \    var count = 0\n        for (c <- brackets) {\n            if (c == '<') count\
    \ += 1\n            else if (c == '>') count -= 1\n            if (count < 0)\
    \ return false\n        }\n        return count == 0", "        val stack = new\
    \ Stack[Char]\n        for (c <- brackets) {\n            if (c == '<') {\n  \
    \              stack.push(c)\n            } else {\n                if (stack.size\
    \ == 0) {\n                    return false\n                }\n             \
    \   stack.pop\n            }\n        }\n        return stack.size == 0", "  \
    \      def correctBracketing(brackets : String, balance : Int) : Boolean = {\n\
    \            if (balance < 0) return false\n            if (brackets.isEmpty)\
    \ balance == 0\n            else if (brackets.charAt(0) == '<') correctBracketing(brackets.tail,\
    \ balance + 1)\n            else correctBracketing(brackets.tail, balance - 1)\n\
    \        }\n        correctBracketing(brackets, 0)", "        var stack = new\
    \ Stack[Char]\n        for (c <- brackets) {\n            if (c == '<') {\n  \
    \              stack.push(c)\n            } else {\n                if (stack.isEmpty)\
    \ return false\n                stack.pop\n            }\n        }\n        stack.isEmpty",
  "        @tailrec\n        def balance(brackets : List[Char], balance : Int) : Boolean\
    \ = {\n            brackets match {\n                case Nil => balance == 0\n\
    \                case x :: xs => if (x == '<') balance(xs, balance + 1) else if\
    \ (balance > 0) balance(xs, balance - 1) else false\n            }\n        }\n\
    \        balance(brackets.toList, 0)", "        val bracketStack = new Stack[String]()\n\
    \        for (char <- brackets) {\n            char match {\n                case\
    \ '<' => bracketStack.push(\"<\")\n                case '>' => if (bracketStack.isEmpty)\
    \ return false else bracketStack.pop()\n            }\n        }\n        return\
    \ bracketStack.isEmpty", "        var depth = 0\n        for (ch <- brackets)\
    \ {\n            if (ch == '<') depth += 1\n            else depth -= 1\n    \
    \        if (depth < 0) return false\n        }\n        depth == 0", "      \
    \  val stack = new Stack[Char]\n        for (i <- 0 until brackets.length) {\n\
    \            val bracket = brackets(i)\n            if (bracket == '<') stack.push(bracket)\n\
    \            else if (bracket == '>') if (stack.isEmpty) return false else stack.pop\n\
    \        }\n        return stack.isEmpty", "        var stack = new Stack[Char]\n\
    \        for (char <- brackets) {\n            if (char == '<') stack.push(char)\n\
    \            else if (char == '>') {\n                if (stack.size == 0) return\
    \ false\n                stack.pop\n            }\n        }\n        return stack.size\
    \ == 0", "        def solve(s : List[Char], count : Int) : Boolean = {\n     \
    \       if (count < 0) false\n            else s match {\n                case\
    \ Nil => count == 0\n                case h :: t => h match {\n              \
    \      case '<' => solve(t, count + 1)\n                    case '>' => solve(t,\
    \ count - 1)\n                }\n            }\n        }\n        solve(brackets.toList,\
    \ 0)", "      var stack = new Stack[Char]\n      for (ch <- brackets) {\n    \
    \    if (ch == '<') stack.push(ch)\n        else {\n          if (stack.isEmpty)\
    \ return false\n          stack.pop\n        }\n      }\n      stack.isEmpty",
  "        val stack = new Stack[Char]\n        for (i <- 0 until brackets.length)\
    \ {\n            if (brackets(i) == '<') stack.push('<')\n            else if\
    \ (stack.isEmpty) return false\n            else stack.pop\n        }\n      \
    \  return stack.isEmpty", "        if (brackets.contains(\"<>\")) correctBracketing(brackets.replace(\"\
    <>\", \"\"))\n        else brackets.isEmpty", "        val levels = new scala.collection.mutable.Stack[Int]\n\
    \        var insideLevel = 0\n        for (i <- 0 until brackets.length) {\n \
    \           if (brackets(i) == '<') {\n                insideLevel += 1\n    \
    \            levels.push(insideLevel)\n            } else {\n                if\
    \ (levels.isEmpty) {\n                    return false\n                }\n  \
    \              insideLevel = levels.pop\n            }\n        }\n        return\
    \ insideLevel == 0", "      val stack = new Stack[Char]\n      for (b <- brackets)\
    \ {\n        if (b == '<') stack.push(b)\n        else if (stack.isEmpty) return\
    \ false\n        else stack.pop\n      }\n      stack.isEmpty", "        var level\
    \ = 0\n        for (c <- brackets) {\n            if (c == '<') level += 1\n \
    \           else level -= 1\n            if (level < 0) return false\n       \
    \ }\n        return level == 0", "        var stack = new Stack[Char]()\n    \
    \    for (c <- brackets) {\n            if (c == '<') stack.push(c)\n        \
    \    else if (c == '>') {\n                if (stack.isEmpty) return false\n \
    \               stack.pop\n            }\n        }\n        return stack.isEmpty",
  "      def cb(brackets : String, c : Int) : Boolean = {\n        if (c < 0) false\n\
    \        else if (brackets.length == 0) c == 0\n        else if (brackets.head\
    \ == '<') cb(brackets.tail, c + 1)\n        else cb(brackets.tail, c - 1)\n  \
    \    }\n      cb(brackets, 0)", "        var count = 0\n        for (c <- brackets)\
    \ {\n            if (c == '<') count += 1\n            else if (c == '>') count\
    \ -= 1\n            if (count < 0) return false\n        }\n        return count\
    \ == 0", "        var balance = 0\n        for (i <- 0 until brackets.length)\
    \ {\n            if (brackets(i) == '<') balance += 1\n            else balance\
    \ -= 1\n            if (balance < 0) return false\n        }\n        return balance\
    \ == 0", "        var s : Stack[Char] = new Stack[Char]()\n        brackets.foreach(b\
    \ => {if (b == '<') s.push(b) else {if (s.isEmpty) return false else s.pop()}})\n\
    \        s.isEmpty", "        val b = brackets.toList.map(x => if (x == '<') 1\
    \ else -1)\n        var s = 0\n        for (e <- b) {\n            s += e\n  \
    \          if (s < 0) return false\n        }\n        s == 0", "        var stack\
    \ = new Stack[Char]\n        brackets.foreach(c => {\n            if (c == '<')\
    \ stack.push(c)\n            else if (c == '>') {\n                if (stack.isEmpty)\
    \ return false\n                else stack.pop\n            }\n        })\n  \
    \      return stack.isEmpty", "        def helper(brackets : String, open : Int)\
    \ : Boolean = {\n            if (brackets.length == 0) open == 0\n           \
    \ else if (brackets.charAt(0) == '<') helper(brackets.substring(1), open + 1)\n\
    \            else if (open > 0) helper(brackets.substring(1), open - 1)\n    \
    \        else false\n        }\n        helper(brackets, 0)", "        if (brackets.length\
    \ == 0) return true\n        val stack = new Stack[Char]\n        stack.push(brackets(0))\n\
    \        for (i <- 1 until brackets.length) {\n            if (brackets(i) ==\
    \ '<') stack.push('<')\n            else if (stack.size == 0) return false\n \
    \           else stack.pop\n        }\n        return stack.size == 0", "    \
    \    if (brackets.length % 2 == 1) {\n            return false\n        }\n  \
    \      var count = 0\n        for (c <- brackets) {\n            if (c == '<')\
    \ {\n                count += 1\n            } else {\n                count -=\
    \ 1\n            }\n            if (count < 0) {\n                return false\n\
    \            }\n        }\n        return count == 0", "        brackets.filter(c\
    \ => c == '<').size == brackets.filter(c => c == '>').size", "        // Do not\
    \ change this function.\n        var lBrackets = 0\n        for (b <- brackets)\
    \ {\n            if (b == '<') lBrackets += 1\n            else lBrackets -= 1\n\
    \            if (lBrackets < 0) return false\n        }\n        return lBrackets\
    \ == 0", "        val leftBrackets = brackets.count(_ == '<')\n        val rightBrackets\
    \ = brackets.count(_ == '>')\n        if (leftBrackets == rightBrackets) {\n \
    \           true\n        } else {\n            false\n        }", "        var\
    \ counter = 0\n        for (i <- 0 until brackets.length) {\n            if (brackets(i)\
    \ == '<') counter += 1\n            else counter -= 1\n            if (counter\
    \ < 0) return false\n        }\n        return counter == 0", "        var openBrackets\
    \ = new Stack[Char]()\n        for (c <- brackets) {\n            if (c == '<')\
    \ {\n                openBrackets.push(c)\n            } else {\n            \
    \    if (openBrackets.isEmpty) {\n                    return false\n         \
    \       } else {\n                    openBrackets.pop()\n                }\n\
    \            }\n        }\n        openBrackets.isEmpty"]
stop_tokens:
- "\n    }\n"
