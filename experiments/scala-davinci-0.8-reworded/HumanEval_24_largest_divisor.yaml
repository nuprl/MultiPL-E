name: HumanEval_24_largest_divisor
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // For a given number n, find the largest number that divides n evenly, smaller\
  \ than n\n    // >>> largestDivisor((15l))\n    // (5l)\n    def largestDivisor(n\
  \ : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestDivisor((3l))\
  \ == (1l));\n    assert(largestDivisor((7l)) == (1l));\n    assert(largestDivisor((10l))\
  \ == (5l));\n    assert(largestDivisor((100l)) == (50l));\n    assert(largestDivisor((49l))\
  \ == (7l));\n    }\n\n}\n"
completions: ["        val sqrt = sqrt(n)\n        var result = 1l\n        var i\
    \ = 2l\n        while (i <= sqrt) {\n            if (n % i == 0) {\n         \
    \       result = i\n            }\n            i += 1\n        }\n        result",
  "        val sqrtn = sqrt(n).toLong\n        (2l to sqrtn).find(n % _ == 0).getOrElse(1l)",
  "        var m = n / 2\n        while (m > 1) {\n            if (n % m == 0) {\n\
    \                return m\n            }\n            m -= 1\n        }\n    \
    \    return 1", "        (2l to (ceil(sqrt(n)).toLong)).foreach(i => if (n % i\
    \ == 0) return i)\n        1l", "        val r = Range(2, (sqrt(n) + 1).toInt)\n\
    \        r.find(x => n % x == 0).getOrElse(n).toLong", "        var (l, r) = (2l,\
    \ n - 1l)\n        while (l <= r) {\n            var m = (l + r) / 2\n       \
    \     if (n % m == 0) {\n                if (n % (m + 1) != 0) return m\n    \
    \            else l = m + 1\n            }\n            else r = m - 1\n     \
    \   }\n        return 1l", "        val sqrt = sqrt(n).toLong\n        (2l to\
    \ sqrt).filter(x => n % x == 0).last", "      if (n % 2 == 0) {\n        largestDivisor(n\
    \ / 2)\n      } else {\n        var i = 3l\n        while (i <= n / 2) {\n   \
    \       if (n % i == 0) {\n            return largestDivisor(n / i)\n        \
    \  }\n          i += 2\n        }\n        n\n      }", "        def checkDivisor(d\
    \ : Long) : Long = {\n            if (n % d == 0) d\n            else checkDivisor(d\
    \ - 1)\n        }\n        checkDivisor(floor(sqrt(n)).toLong)", "        var\
    \ maxDivisor = n / 2\n        var done = false\n        while (!done) {\n    \
    \        if (n % maxDivisor == 0) done = true\n            else maxDivisor -=\
    \ 1\n        }\n        maxDivisor", '        return List.range(2, ceil(sqrt(n)).toInt).filter(n
    % _ == 0).last', "        for (i <- 1l to sqrt(n).toLong) {\n            if (n\
    \ % i == 0) {\n                return largestDivisor(n / i)\n            }\n \
    \       }\n        return n", "        def factor(n : Long, i : Long) : Long =\
    \ {\n            if (i * i > n) n\n            else if (n % i == 0) n / i\n  \
    \          else factor(n, i + 1)\n        }\n        factor(n, 2)", "        var\
    \ maxDivisor = -1l\n        for (i <- 1l to n / 2) {\n            if (n % i ==\
    \ 0) maxDivisor = i\n        }\n        maxDivisor", "        val sqrtn = sqrt(n).toLong\n\
    \        val range = (2l to sqrtn).toStream\n        val divisors = range.filter(n\
    \ % _ == 0)\n        divisors.last", "        var max = 1l\n        var i = 2l\n\
    \        while (i <= n / 2) {\n            if (n % i == 0) max = i\n         \
    \   i += 1\n        }\n        max", "      var maxDivisor = 0l\n      for (i\
    \ <- 2l to sqrt(n).toLong) {\n        if (n % i == 0) maxDivisor = i\n      }\n\
    \      maxDivisor", "        val sqrtn = ceil(sqrt(n)).toLong\n        for (i\
    \ <- sqrtn to 2 by -1) {\n            if (n % i == 0) return i\n        }\n  \
    \      1", "        var sqrt = ceil(sqrt(n)).toLong\n        for (i <- 2l to sqrt)\
    \ {\n            if (n % i == 0) return n / i\n        }\n        return 1l",
  "        val root : Double = Math.sqrt(n)\n        for (i <- floor(root).toLong\
    \ to 2 by -1) {\n            if (n % i == 0) return i\n        }\n        return\
    \ 1", "        def checkDivisor(n : Long, k : Long) : Long = {\n            if\
    \ (k <= 1) return n\n            if (n % k == 0) return k\n            else return\
    \ checkDivisor(n, k - 1)\n        }\n        return checkDivisor(n, sqrt(n).toLong)",
  "        val range = 2 to sqrt(n).toInt\n        val divisors = range.toList.filter(n\
    \ % _ == 0)\n        if (divisors.isEmpty) 1 else divisors.last", "        for\
    \ (d <- Stream.range(2, math.sqrt(n).toInt + 1)) {\n            if (n % d == 0)\
    \ return n / d\n        }\n        1", "        if (n <= 1)\n            return\
    \ n\n        val sqrtN = sqrt(n).toLong\n        var largestDivisor : Long = 1\n\
    \        for (i <- 2l to sqrtN) {\n            if (n % i == 0)\n             \
    \   largestDivisor = i\n        }\n        return largestDivisor", "      if (n\
    \ == 1) return n\n      val sqrtN = ceil(sqrt(n)).toLong\n      for (i <- sqrtN\
    \ to 2 by -1) {\n        if (n % i == 0) {\n          return n / i\n        }\n\
    \      }\n      1", "        val sqrtn = sqrt(n).toLong\n        var d = sqrtn\n\
    \        while (d > 1) {\n            if (n % d == 0) return d\n            d\
    \ -= 1\n        }\n        1", "        for (i <- (n - 1) to 1 by -1) {\n    \
    \        if (n % i == 0) return i\n        }\n        return -1", "        for\
    \ (i <- Range(2, n.toInt).reverse) {\n            if (n % i == 0) return i\n \
    \       }\n        return 1", "        for (i <- (2l to sqrt(n).toLong).reverse)\
    \ {\n            if (n % i == 0) return i\n        }\n        1l", "        val\
    \ prime = Prime.getPrime(n)\n        val l = prime.size\n        for (i <- (l\
    \ - 1) to 0 by -1) {\n            if (n % prime(i) == 0) {\n                return\
    \ prime(i)\n            }\n        }\n        return 1", "        for (i <- 2l\
    \ to (n / 2l)) {\n            if (n % i == 0) {\n                return i\n  \
    \          }\n        }\n        0l", "        var maxFactor = -1l\n        val\
    \ sqrt = round(sqrt(n)).toLong\n        var factor = 2l\n        while (factor\
    \ <= sqrt) {\n            if (n % factor == 0) {\n                maxFactor =\
    \ factor\n            }\n            factor += 1\n        }\n        maxFactor",
  "        if (n == 1) return 1l\n        var divisor = floor(sqrt(n)).toLong\n  \
    \      while (divisor > 1) {\n            if (n % divisor == 0) return divisor\n\
    \            divisor -= 1\n        }\n        return 1l", "      val sqrtN = sqrt(n).toLong\n\
    \      for (i <- sqrtN to 1 by -1) {\n        if (n % i == 0) return i\n     \
    \ }\n      1", "      var div = 2l\n      while (n % div != 0) div += 1\n    \
    \  div", "        val limit = (sqrt(n) + 1).toLong\n        for (i <- 2l to limit)\
    \ {\n            if (n % i == 0) {\n                return i\n            }\n\
    \        }\n        return 1l", "        var k = n / 2\n        while (k > 1)\
    \ {\n            if (n % k == 0) return k\n            k -= 1\n        }\n   \
    \     return 1", "        for (i <- 1l to n / 2) if (n % i == 0) return n / i\n\
    \        return 1l", "      var maxDivisor = n - 1\n      while (maxDivisor >\
    \ 1) {\n        if (n % maxDivisor == 0) return maxDivisor\n        maxDivisor\
    \ -= 1\n      }\n      1", "        require(n > 0)\n        var cur = n / 2\n\
    \        while (cur > 0) {\n            if (n % cur == 0) {\n                return\
    \ cur\n            }\n            cur -= 1\n        }\n        return 1", "  \
    \      var result = n - 1\n        while (result > 1) {\n            if (n % result\
    \ == 0) return result\n            result -= 1\n        }\n        return 1",
  "        var largestDivisor = n - 1\n        while(n % largestDivisor != 0) {\n\
    \            largestDivisor -= 1\n        }\n        largestDivisor", "      \
    \  for (i <- n-1 to 2 by -1) if (n % i == 0) return i\n        return 1l", " \
    \       (1l to (sqrt(n).toLong)).foreach(i => {\n            if (n % i == 0 &&\
    \ i < n) return i\n        })\n        return 1l", "        // Since we are not\
    \ looking for 1, the upper bound is sqrt(n)\n        val upperBound = sqrt(n).toLong\n\
    \        // Since we do not want to find n itself, the lower bound is 2\n    \
    \    val lowerBound = 2l\n        // Only need to iterate to the floor of the\
    \ sqrt\n        (lowerBound to upperBound).map(x => if (n % x == 0) (x, n / x)\
    \ else (1l, 1l)).maxBy(_._1)._1", "        var ret = 1l\n        for (i <- 2l\
    \ to (n / 2l)) {\n            if (n % i == 0) ret = i\n        }\n        ret",
  "        var d = (sqrt(n)).toLong\n        while (n % d != 0) d -= 1\n        d",
  "        var x = n\n        var y = 2l\n        while (x % y != 0) {\n         \
    \   y += 1\n        }\n        return y", "        def rec(i : Long) : Long =\
    \ i match {\n            case 0 => 1\n            case _ => if (n % i == 0) i\
    \ else rec(i - 1)\n        }\n        rec(n / 2)", "        if (n % 2 == 0) {\n\
    \            val f = n / 2\n            if (f % 2 == 0) largestDivisor(f) else\
    \ f\n        } else {\n            var f = 3l\n            while (n % f != 0)\
    \ f += 2\n            if (f * f == n) f else largestDivisor(n / f)\n        }",
  "        // Given a number n and a range, find the largest number that divides n\
    \ evenly, within the range\n        def largestDivisorInRange(n : Long, a : Long,\
    \ b : Long) : Long = {\n            val candidates = (a to b).reverse.filter(i\
    \ => n % i == 0)\n            if (candidates.isEmpty) { -1 } else { candidates.head\
    \ }\n        }\n        largestDivisorInRange(n, 2, n - 1)", "        var largestDivisor\
    \ = n - 1\n        while (largestDivisor > 0) {\n            if (n % largestDivisor\
    \ == 0) return largestDivisor\n            largestDivisor -= 1\n        }\n  \
    \      throw new Exception()", "        def largestDivisor(n : Long, d : Long)\
    \ : Long = if (n % d == 0) d else largestDivisor(n, d - 1)\n        largestDivisor(n,\
    \ floor(sqrt(n)).toLong)", "      var largest = 1l\n      var i = 2l\n      while\
    \ (i <= n / 2) {\n        if (n % i == 0) {\n          largest = i\n        }\n\
    \        i += 1\n      }\n      largest", "        for (i <- 2L to n-1) if (n\
    \ % i == 0) return i\n        return 0", "        for (i <- n - 1 to 2 by -1)\
    \ {\n            if (n % i == 0) return i\n        }\n        return -1", "  \
    \      for (i <- 2l to n/2l) {\n            if (n % i == 0) return largestDivisor(n/i)\n\
    \        }\n        return n", '        return (2l to n / 2l).filter(n % _ ==
    0).toList.last', "        var largest = 0l\n        for (i <- 1l to sqrt(n).toLong)\
    \ {\n            if (n % i == 0) largest = i\n        }\n        return largest",
  "        val sqrt = math.sqrt(n).toLong\n        val nn = if (sqrt * sqrt == n)\
    \ sqrt - 1 else sqrt\n        val range = List.range(2, nn + 1)\n        range.foldLeft(1l)((acc,\
    \ i) => if (n % i == 0) n / i else acc)", "      val upperLimit = n\n      val\
    \ lowerLimit = 1\n      val maxDivisor = n\n      var biggestDivisor = maxDivisor\n\
    \      for (i <- (lowerLimit to upperLimit).reverse) {\n        if (n % i == 0)\
    \ {\n          if (i < maxDivisor) {\n            biggestDivisor = i\n       \
    \     return biggestDivisor\n          }\n        }\n      }\n      return biggestDivisor",
  "        var i = 2l\n        var v = n\n        while (i * i <= v) {\n         \
    \   if (v % i == 0) {\n                v /= i\n            } else {\n        \
    \        i += 1\n            }\n        }\n        v", "        val root = sqrt(n).toLong\n\
    \        for (i <- root to 2 by -1) {\n            if (n % i == 0) return i\n\
    \        }\n        return 1", '        (1l to (n / 2)).reverse.filter(n % _ ==
    0).head', "        var answer = -1l\n        for (i <- 2l to floor(sqrt(n)).toLong)\
    \ {\n            if (n % i == 0) {\n                answer = max(answer, i)\n\
    \            }\n        }\n        return answer", "        var f = n\n      \
    \  while (f > 0) {\n            if (n % f == 0) return f\n            f -= 1\n\
    \        }\n        return 1", "      def divisors(n : Long) : List[Long] = {\n\
    \        def divisorsHelper(i : Long, res : List[Long]) : List[Long] = {\n   \
    \       if (i > n) res\n          else if (n % i == 0) divisorsHelper(i + 1, i\
    \ :: res)\n          else divisorsHelper(i + 1, res)\n        }\n        divisorsHelper(1,\
    \ Nil)\n      }\n      divisors(n).max", "        for (i <- n-1 to 1 by -1) {\n\
    \            if (n % i == 0) return i\n        }\n        return 0", "       \
    \ require(n > 0, \"n must be greater than 0\")\n        if (n <= 3) return n -\
    \ 1\n        val max = sqrt(n)\n        var i = 2l\n        while (i <= max) {\n\
    \            if (n % i == 0) return n / i\n            i += 1\n        }\n   \
    \     return 1", "        var result = n - 1\n        while (result > 1) {\n \
    \           if (n % result == 0) return result\n            result -= 1\n    \
    \    }\n        throw new Error(\"No divisor found\")", "        var i = n - 1\n\
    \        while (i > 1) {\n            if (n % i == 0) {\n                return\
    \ i\n            }\n            i -= 1\n        }\n        return 1", "      \
    \  if (n == 1) 1\n        else {\n            val divisors = (2l to sqrt(n).toLong).filter(n\
    \ % _ == 0)\n            if (divisors.isEmpty) 1\n            else divisors.last\n\
    \        }", "        for (i <- n-1l to 1l by -1l) {\n            if (n % i ==\
    \ 0) return i\n        }\n        return 1l", "        val s = sqrt(n).toLong\n\
    \        for (i <- 2l to s) {\n            if (n % i == 0) return n / i\n    \
    \    }\n        return 1l", "        for (i <- 2 to sqrt(n).toInt) {\n       \
    \     if (n % i == 0) return largestDivisor(n / i)\n        }\n        n", " \
    \       def go(x : Long) : Long = {\n            if (n % x == 0) x\n         \
    \   else go(x - 1)\n        }\n        go(n - 1)", "        // >>> largestDivisor((15l))\n\
    \        // 3\n        // >>> largestDivisor((100l))\n        // 5\n        //\
    \ >>> largestDivisor((13l))\n        // 1\n        // >>> largestDivisor((0l))\n\
    \        // 0\n        // >>> largestDivisor((2l))\n        // 1\n        var\
    \ maxDivisor = 1l\n        for (i <- 2l to sqrt(n).toLong) {\n            if (n\
    \ % i == 0) maxDivisor = i\n        }\n        maxDivisor", "        var root\
    \ = sqrt(n).toLong\n        if (root * root == n) return root\n        else root\
    \ += 1\n        while (root > 1) {\n            if (n % root == 0) return root\n\
    \            root -= 1\n        }\n        1", "        for (i <- (1 to (n - 1).toInt).reverse)\
    \ if (n % i == 0) return i\n        1", "        var divisor = 2\n        while\
    \ (n % divisor != 0) divisor += 1\n        divisor", "        val limit = (sqrt(n)\
    \ + 1).toLong\n        for (i <- (limit, 1, -1)) {\n            if (n % i == 0)\
    \ return i\n        }\n        1", "        val sqrt = round(sqrt(n))\n      \
    \  for (i <- sqrt.toLong to 1 by -1) {\n            if (n % i == 0) return i\n\
    \        }\n        return 1", "        var i = 2l\n        while (i <= n / 2)\
    \ {\n            if (n % i == 0) return n / i\n            i += 1\n        }\n\
    \        return 1", "        val sqrt = sqrt(n)\n        for (i <- Stream.from(sqrt.toInt,\
    \ -1).takeWhile(_ > 1).map(_.toLong)) if (n % i == 0) return i\n        1", " \
    \     var m = n - 1\n      while (m > 1) {\n        if (n % m == 0) return m\n\
    \        m -= 1\n      }\n      1", "        (1l to n - 1l).foreach(i => if (n\
    \ % i == 0) return i)\n        return 1l", "        if (n % 2 == 0) 2l\n     \
    \   else {\n            for (i <- 3 to sqrt(n).toInt by 2) {\n               \
    \ if (n % i == 0) {\n                    return largestDivisor(n / i)\n      \
    \          }\n            }\n            return n\n        }", "        var factors\
    \ = HashSet[Long]()\n        for (i <- 1l to (n / 2)) {\n            if (n % i\
    \ == 0) factors += i\n        }\n        factors.max", "        val sqrt = sqrt(n).toLong\n\
    \        // Search all numbers between 2 and sqrt(n) inclusive\n        for (i\
    \ <- sqrt to 2 by -1) {\n            if (n % i == 0) {\n                return\
    \ i\n            }\n        }\n        -1", "        val factors = ListBuffer[Long]()\n\
    \        val sqrt = sqrt(n)\n        for (i <- 1l to sqrt.toLong) {\n        \
    \    if (n % i == 0) {\n                factors += i\n                factors\
    \ += n / i\n            }\n        }\n        factors.sorted.reverse.head", " \
    \       def ld(n : Long, i : Long) : Long = {\n            if (i * i > n) n\n\
    \            else if (n % i == 0) max(i, n / i)\n            else ld(n, i + 1)\n\
    \        }\n        ld(n, 2)", "      if (n % 2 == 0) {\n        largestDivisor(n\
    \ / 2)\n      } else {\n        var i = n / 2 - 1\n        while (i > 1) {\n \
    \         if (n % i == 0) return i\n          i -= 1\n        }\n        return\
    \ 1\n      }", "        for (i <- n - 1l to 2l by -1l) {\n            if (n %\
    \ i == 0) {\n                return i\n            }\n        }\n        1l",
  "        val sqrt = sqrt(n).toLong\n        for (i <- (2l to sqrt).reverse) {\n\
    \            if (n % i == 0) return i\n        }\n        1l", "        // >>>\
    \ sumOfFactors((15l))\n        // (6l)\n        def sumOfFactors(n : Long) : Long\
    \ = {\n            def sum(n : Long, a : Long) : Long = {\n                if\
    \ (a * a > n) n\n                else if (n % a == 0) {\n                    val\
    \ d = n / a\n                    if (d == a) a\n                    else d + a\n\
    \                }\n                else sum(n, a + 1)\n            }\n      \
    \      sum(n, 1) - n\n        }\n        var k = sumOfFactors(n)\n        while\
    \ (k != 1 && sumOfFactors(k) != n) k = sumOfFactors(k)\n        k", "        var\
    \ divisor = n / 2\n        while (divisor > 1) {\n            if (n % divisor\
    \ == 0) return divisor\n            divisor -= 1\n        }\n        return 1",
  "      for (i <- Range(2, n.toInt).reverse) {\n        if (n % i == 0) return i\n\
    \      }\n      0", "        var result = n - 1\n        while (result > 1) {\n\
    \            if (n % result == 0) return result\n            result -= 1\n   \
    \     }\n        return 1", "        var d = n / 2\n        while (d >= 1) {\n\
    \            if (n % d == 0) return d\n            d -= 1\n        }\n       \
    \ 1", "        val sqrtn = ceil(sqrt(n)).toLong\n        var d = sqrtn\n     \
    \   while(d > 1) {\n            if(n % d == 0) {\n                return d\n \
    \           }\n            d -= 1\n        }\n        d", "        val r = sqrt(n)\n\
    \        var res = 0l\n        for (i <- 1l to r.toLong) {\n            if (n\
    \ % i == 0) {\n                res = i\n            }\n        }\n        return\
    \ res", "        var i = 2l\n        while (i < n) {\n            if (n % i ==\
    \ 0) {\n                i += 1\n            } else {\n                return n\
    \ / i\n            }\n        }\n        return 1l", '        return (n / 2).toLong
    to (1).toLong by -1 find(n % _ == 0) get', "        val limit = floor(sqrt(n)).toLong\n\
    \        if (limit == 0)\n            return 1l\n        (1l to limit).filter(n\
    \ % _ == 0).last", "        if (n % 2 == 0)\n            n / 2\n        else {\n\
    \            var ret = 0l\n            var x = 3l\n            while (x < n) {\n\
    \                if (n % x == 0)\n                    ret = x\n              \
    \  x += 2\n            }\n            ret\n        }", "        var result = 1\n\
    \        var i = 2\n        while (i <= sqrt(n) && result == 1) {\n          \
    \  if (n % i == 0) result = n / i\n            i += 1\n        }\n        result",
  "      val root = sqrt(n)\n      val cand = (root to 1 by -1).find(n % _ == 0)\n\
    \      if (cand.isEmpty) 1 else cand.get", "        val sqrtn = sqrt(n).toLong\n\
    \        var i = 2l\n        while (i <= sqrtn) {\n            if (n % i == 0)\
    \ return n / i\n            i += 1\n        }\n        return 1l", "        for\
    \ (i <- 2 to floor(sqrt(n)).toInt) if (n % i == 0) return n / i\n        1", " \
    \     val b = (2 to round(sqrt(n)).toInt).find(n % _ == 0)\n      if (b == None)\
    \ 1 else b.get", "        var result = n\n        for (i <- 2l to sqrt(n).toLong)\
    \ {\n            if (n % i == 0) result = i\n        }\n        result", "   \
    \     if (n % 2 == 0) largestDivisor(n / 2)\n        else {\n            var i\
    \ = 3\n            while (i <= sqrt(n)) {\n                if (n % i == 0) return\
    \ largestDivisor(n / i)\n                i += 2\n            }\n            return\
    \ n\n        }", "        // I do this in two steps to avoid overflow\n      \
    \  var i = (floor(n / 2.0) + 1).toLong\n        while (n % i != 0) {\n       \
    \     i -= 1\n        }\n        i", "      for (i <- (2l to sqrt(n).toLong).reverse)\
    \ if (n % i == 0) return i\n      return 1", "        val sqrt = sqrt(n)\n   \
    \     val divisors = (1l to sqrt.toLong).map(x => if (n % x == 0) (n / x, x) else\
    \ (0l, 0l)).filter(x => x._1 != 0 && x._2 != 0)\n        divisors.maxBy(x => x._1)._1",
  "        var i = n / 2\n        while (i > 1) {\n            if (n % i == 0) return\
    \ i\n            i -= 1\n        }\n        1", "        var largest : Long =\
    \ 0\n        for (i <- 2 to n.toInt / 2) {\n            if (n % i == 0) largest\
    \ = i\n        }\n        return largest", "        if (n == 1) return n\n   \
    \     var i = n - 1\n        while (n % i != 0) i -= 1\n        return i", " \
    \       for (i <- n / 2 to 1 by -1) {\n            if (n % i == 0) return i\n\
    \        }\n        return 0", "        var num = n - 1\n        while(num > 0)\
    \ {\n            if(n % num == 0) return num\n            num -= 1\n        }\n\
    \        return 0", "        for (i <- 2l to sqrt(n).toLong) if (n % i == 0l)\
    \ return largestDivisor(n / i)\n        n", "        for (i <- Range(2, n.toInt)\
    \ if (n % i == 0)) {\n            val other = n / i\n            if (other * i\
    \ == n) return other\n        }\n        return 0", "        var max = n - 1\n\
    \        while (max > 1) {\n            if (n % max == 0) return max\n       \
    \     max -= 1\n        }\n        return 1", "        var half = n / 2l\n   \
    \     while (half > 0l) {\n            if (n % half == 0l) return half\n     \
    \       half -= 1l\n        }\n        return 1l", "        val sqrt = sqrt(n).toLong\n\
    \        for (i <- 2l to sqrt) if (n % i == 0) return n / i\n        return 1l",
  "      var maximum : Long = -1\n      for (i <- 2l to n) {\n        if (n % i ==\
    \ 0) {\n          maximum = i\n        }\n      }\n      return maximum", "  \
    \      val s = sqrt(n)\n        var i = s.toLong\n        while (i > 1) {\n  \
    \          if (n % i == 0) return i\n            i -= 1\n        }\n        1",
  "        var d = 2\n        while (n % d != 0) {\n            d += 1\n        }\n\
    \        return d", "        for (i <- ((n / 2L) to 1L by -1L)) {\n          \
    \  if (n % i == 0) return i\n        }\n        return 1L", "        // We start\
    \ from sqrt(n) and check downwards\n        for (i <- floor(sqrt(n)).toLong to\
    \ 1 by -1) {\n            if (n % i == 0) return i\n        }\n        return\
    \ 1", "        var limit = sqrt(n).toLong\n        var divisor = 2l\n        while\
    \ (divisor <= limit) {\n            if (n % divisor == 0) {\n                limit\
    \ = n / divisor\n                divisor += 1\n            }\n            else\
    \ divisor += 1\n        }\n        return (n / divisor)", "        def largestDivisorRec(n\
    \ : Long, i : Long) : Long = {\n            if (i * i > n) n\n            else\
    \ if (n % i == 0) n / i\n            else largestDivisorRec(n, i + 1)\n      \
    \  }\n        largestDivisorRec(n, 2)", "        var r = sqrt(n).toLong\n    \
    \    while (r > 1) {\n            if (n % r == 0) return r\n            r -= 1\n\
    \        }\n        1", "        for (i <- (2l to (sqrt(n).toLong)).reverse) {\n\
    \            if (n % i == 0) return i\n        }\n        return 1", '        if
    (n % 2 == 0) 2 else Stream.from(sqrt(n).toInt, -1).filter(d => n % d == 0).head',
  "        for (i <- 2l to n - 1) {\n            if (n % i == 0) return i\n      \
    \  }\n        return -1l", "        var m = n\n        while (m > 0) {\n     \
    \       if (n % m == 0) {\n                return m\n            }\n         \
    \   m -= 1\n        }\n        0", "        val candidates = (1l to (n / 2)).toList.reverse\n\
    \        val divisors = candidates.filter(x => (n % x) == 0)\n        val sorted\
    \ = divisors.sortWith(_ > _)\n        sorted.head", "        var largestDivisor\
    \ = 1l\n        for (i <- 2l to (n/2l)) {\n            if (n % i == 0) largestDivisor\
    \ = i\n        }\n        largestDivisor", "        var c = n / 2l\n        while\
    \ (c > 1) {\n            if (n % c == 0) return c\n            c -= 1\n      \
    \  }\n        1l", "        def recurse(largest : Long, current : Long) : Long\
    \ = {\n            if (current * current > n) largest\n            else if (n\
    \ % current == 0) recurse(current, current + 1)\n            else recurse(largest,\
    \ current + 1)\n        }\n        recurse(1, 2)", "        val s = math.sqrt(n).toLong\n\
    \        (2l to s).filter(n % _ == 0).max", "      val max = sqrt(n).toLong\n\
    \      var ans = 1\n      for (i <- 2l to max if (n % i == 0)) ans = i\n     \
    \ ans", "        val sqrt = sqrt(n).toLong\n        for (i <- 2 to sqrt) if (n\
    \ % i == 0) return n / i\n        1", "        var i = (n - 1)\n        while\
    \ (i > 1) {\n            if (n % i == 0) return i\n            i -= 1\n      \
    \  }\n        return 1", "        var divisor = n - 1\n        while (divisor\
    \ > 1) {\n            if (n % divisor == 0) return divisor\n            divisor\
    \ -= 1\n        }\n        1", '        if (n % 2 == 0) 2 else largestDivisorHelper(n,
    (n - 1) / 2)', "        var i = n - 1\n        while (i > 1) {\n            if\
    \ (n % i == 0) return i\n            i -= 1\n        }\n        return -1", " \
    \       val m = n / 2\n        (2l to m).filter(i => n % i == 0l).max", '      Range(2,
    n.toInt).find(n % _ == 0).getOrElse(1).toLong', "        (n - 1).to(1, -1).foreach(i\
    \ => {\n            if (n % i == 0) return i\n        })\n        return 0", " \
    \       if (n % 2 == 0) {\n            2l\n        } else {\n            for (i\
    \ <- 3l to (sqrt(n).toLong) by 2) {\n                if (n % i == 0) {\n     \
    \               return i\n                }\n            }\n            1l\n \
    \       }", "        val sqrt = sqrt(n).toLong\n        for (i <- (sqrt to 2 by\
    \ -1).toList) {\n            if (n % i == 0) return i\n        }\n        return\
    \ 1", "      for (i <- n-1 to 2 by -1) {\n        if (n % i == 0) return i\n \
    \     }\n      return 0", "        val lim = sqrt(n).toLong\n        for (i <-\
    \ (lim to 2 by -1)) {\n            if (n % i == 0) return i\n        }\n     \
    \   1", "        //println(\"n = \" + n)\n        (2l until n).toList.reverse.find(x\
    \ => n % x == 0).get", "        // Start from n - 1, see if n is divisible by\
    \ it\n        for (i <- n - 1 to 2 by -1) {\n            if (n % i == 0) {\n \
    \               return i\n            }\n        }\n        -1", "        def\
    \ recurse(i : Long) : Long = {\n            if (i == 0) throw new Exception(\"\
    No divisor found.\")\n            if (n % i == 0) i\n            else recurse(i\
    \ - 1)\n        }\n        recurse(n - 1)", "      val max = Math.sqrt(n).floor.toLong\n\
    \      for (i <- max to 2 by -1) {\n        if (n % i == 0) return i\n      }\n\
    \      return 1", "        var i = n\n        while(i > 1) {\n            if(n\
    \ % i == 0) return i\n            i -= 1\n        }\n        throw new Exception(\"\
    No divisor found?\")", "        val sqrt_n = sqrt(n).toLong\n        for (i <-\
    \ sqrt_n to 2 by -1) {\n            if (n % i == 0) return i\n        }\n    \
    \    1", "        for (i <- Range(2, (sqrt(n.toDouble).toInt) + 1)) {\n      \
    \      if (n % i == 0) {\n                if (n / i > i) return n / i\n      \
    \          else return i\n            }\n        }\n        return 1", "     \
    \   for (i <- n-1 to 1 by -1) if (n % i == 0) return i\n        1", "        for\
    \ (i <- 2l to n) {\n            if (n % i == 0) {\n                return i\n\
    \            }\n        }\n        return 1l", '        (2l until n).find(n %
    _ == 0).get', "        var i = n - 1\n        while (i > 1) {\n            if\
    \ (n % i == 0) {\n                return i\n            }\n            i -= 1\n\
    \        }\n        return 1", "        //val factors = (1l to n - 1l).filter(n\
    \ % _ == 0l)\n        //println(factors)\n        //val v = factors.last\n   \
    \     //println(v)\n        //v\n        //(2l to n - 1l).foldLeft(1l)((v, i)\
    \ => if (n % i == 0l) i else v)\n        (2l to math.sqrt(n).toLong).filter(n\
    \ % _ == 0l).last", "        // List of prime factors of n\n        // >>> primeFactors(15l)\n\
    \        // List(3l, 5l)\n        val ps = primeFactors(n)\n        // Return\
    \ largest prime factor that divides n evenly, smaller than n\n        // >>> largestDivisorByPrimeFactors(n,\
    \ ps)\n        // (5l)\n        largestDivisorByPrimeFactors(n, ps)", "      \
    \  def largestDivisor(n : Long, i : Long) : Long = {\n            if (i == n)\
    \ n\n            else if (n % i == 0) largestDivisor(n, i + 1)\n            else\
    \ largestDivisor(n, i + 1)\n        }\n        largestDivisor(n, 1)", "      \
    \  def largestDivisorR(testDivisor : Long) : Long = {\n            if (n % testDivisor\
    \ == 0) testDivisor\n            else largestDivisorR(testDivisor - 1)\n     \
    \   }\n        largestDivisorR(n - 1)", "        var i = sqrt(n).toLong\n    \
    \    while (i > 1) {\n            if (n % i == 0) return i\n            i -= 1\n\
    \        }\n        throw new RuntimeException", "        val candidates = (1l\
    \ until n/2 + 1)\n        val result = candidates.filter(x => n % x == 0).max\n\
    \        return result", "        var i = (n / 2).toLong\n        while (i > 0)\
    \ {\n            if (n % i == 0) return i\n            i -= 1\n        }\n   \
    \     return 1", "        for (i <- ((n - 1) to 2 by -1)) {\n            if (n\
    \ % i == 0) return i\n        }\n        return 1", "        val sqrt = sqrt(n).toLong\n\
    \        val primes = getPrimes(sqrt)\n        var largestDivisor = 1l\n     \
    \   primes.foreach(prime => {\n            if (n % prime == 0) {\n           \
    \     largestDivisor = prime\n            }\n        })\n        largestDivisor",
  "        for (i <- (1l until n).reverse) {\n            if (n % i == 0) return i\n\
    \        }\n        return 0", "        var i = 2l\n        while (i < n) {\n\
    \            if (n % i == 0) return n / i\n            i += 1\n        }\n   \
    \     return 1", "        var i = n - 1\n        while (i > 1) {\n           \
    \ if (n % i == 0) return i\n            i -= 1\n        }\n        return 1",
  "        val bound = round(sqrt(n))\n        val primes = getPrimes((bound + 1).toInt)\n\
    \        var acc = 0l\n        var i = 1\n        while (i < bound) {\n      \
    \      if (n % i == 0) {\n                acc = i\n            }\n           \
    \ i += 1\n        }\n        return acc", "        def factor(n : Long, f : Long)\
    \ : Long = {\n            if (n % f == 0) factor(n / f, f)\n            else f\n\
    \        }\n        factor(n, 2)", "        if (n % 2 == 0)\n            return\
    \ n / 2\n        val bound = floor(sqrt(n)).toLong\n        for (i <- bound to\
    \ 3 by -2) {\n            if (n % i == 0)\n                return i\n        }\n\
    \        1", "        for (i <- Range(2, (sqrt(n) + 1).toInt)) if (n % i == 0)\
    \ return n / i\n        throw new Exception(\"Could not find any divisor of \"\
    \ + n)", "        val root : Long = sqrt(n).toLong\n        val range = (2l until\
    \ root + 1l)\n        val divisors = range.filter(n % _ == 0l)\n        if (divisors.length\
    \ == 0)\n            return 1l\n        else\n            return divisors.last",
  "        var divisor = floor(sqrt(n)).toLong\n        while (n % divisor != 0 &&\
    \ divisor > 1) divisor -= 1\n        return divisor", "        for (i <- 2l to\
    \ sqrt(n).toLong) if (n % i == 0) return n / i\n        1l", "        // https://en.wikipedia.org/wiki/Prime_factor\n\
    \        // This will be an O(n^(1/2)) algorithm, so a long input\n        //\
    \ will be an O(n^2) algorithm\n        var i = 2l\n        while (i < sqrt(n))\
    \ {\n            if (n % i == 0) return n / i\n            i += 1\n        }\n\
    \        1l", "        val r = sqrt(n)\n        var i = 2l\n        var d = -1l\n\
    \        while (i <= r) {\n            if (n % i == 0) {\n                d =\
    \ i\n            }\n            i += 1\n        }\n        d", "        val last\
    \ = sqrt(n)\n        def find(d : Long) : Long = if (d < last) (if (n % d == 0)\
    \ find(d + 1) else find(d - 1)) else d\n        if (n % 2 == 0) find(n / 2) else\
    \ find((n - 1) / 2)", "        val sqrtN = sqrt(n).toLong\n        val allDivisors\
    \ = (2 to sqrtN).toList.map(i => {\n            (i, n % i)\n        }).filter(pair\
    \ => pair._2 == 0)\n        if (allDivisors.length > 0) {\n            allDivisors.last._1\n\
    \        } else {\n            1\n        }", "        var factors = new ListBuffer[Long]\n\
    \        var i = 1l\n        while (i <= sqrt(n)) {\n            if (n % i ==\
    \ 0) {\n                factors += i\n                factors += n / i\n     \
    \       }\n            i += 1\n        }\n        factors.sorted.last", "    \
    \    val limit = n / 2\n        var i = limit\n        while (i > 0) {\n     \
    \       if (n % i == 0) return i\n            i -= 1\n        }\n        throw\
    \ new Exception(\"Algorithm for calculating divisors failed\")", "        var\
    \ x = n\n        while (x > 1) {\n            if (n % x == 0) return x\n     \
    \       x -= 1\n        }\n        return -1", "        val sqrt = math.sqrt(n)\n\
    \        for (i <- (2l to sqrt.toLong).reverse) {\n            if (n % i == 0)\
    \ {\n                return n / i\n            }\n        }\n        return 1",
  "      def loop(i : Long) : Long = {\n        if (i == 0) throw new Exception(\"\
    Prime number encountered\")\n        else if (n % i == 0) i\n        else loop(i\
    \ - 1)\n      }\n      loop(n / 2)", "        var result = n - 1\n        while\
    \ (result > 0) {\n            if (n % result == 0) return result\n           \
    \ result -= 1\n        }\n        return 1", "        var x = 2l\n        while\
    \ (x <= sqrt(n)) {\n            if (n % x == 0) return n / x\n            x +=\
    \ 1\n        }\n        1l", "        var end = n - 1\n        for (i <- 2l to\
    \ end) {\n            if (n % i == 0) return i\n        }\n        return 1",
  "        var largest = 0l\n        for (i <- 1l to sqrt(n).toLong if (n % i == 0))\
    \ {\n            if (n / i != i) {\n                largest = if (n / i > largest)\
    \ n / i else largest\n            }\n            else {\n                largest\
    \ = if (i > largest) i else largest\n            }\n        }\n        largest",
  "        for (i <- n to 2 by -1) {\n            if (n % i == 0) return i\n     \
    \   }\n        return 0", "      (n / 2).toLong to 1 by -1 foreach { i => if (n\
    \ % i == 0) return i }\n      n"]
stop_tokens:
- "\n    }\n"
