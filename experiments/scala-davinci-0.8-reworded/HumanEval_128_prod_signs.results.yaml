language: scala
name: HumanEval_128_prod_signs
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else {\n            var prod : Long = 1\n            var\
    \ sum : Long = 0\n            for (i <- arr) {\n                var sign : Long\
    \ = i / abs(i)\n                if (sign == 0) sign = 1\n                prod\
    \ *= sign\n                sum += abs(i)\n            }\n            Some(sum\
    \ * prod)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuv4uz713.scala:30)\n\tat Problem.main(tmpuv4uz713.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Write your\
    \ code here.\n        // Return the actual answer.\n        var sign = 1\n   \
    \     var sum = 0\n        if (arr.isEmpty) {\n            return None\n     \
    \   }\n        for (i <- arr) {\n            if (i > 0) {\n                sign\
    \ *= 1\n            } else if (i < 0) {\n                sign *= -1\n        \
    \    } else {\n                sign *= 0\n            }\n            sum += abs(i).toInt\n\
    \        }\n        Some(sum * sign)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf91m8mbb.scala:36)\n\tat Problem.main(tmpf91m8mbb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        val s = arr.map(x => x.signum).reduce(_ * _)\n        return\
    \ Some(arr.map(abs(_)).reduce(_ + _) * s)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaisxdjqr.scala:21)\n\tat Problem.main(tmpaisxdjqr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Write your\
    \ code here\n        return None\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzqii7enr.scala:20)\n\tat Problem.main(tmpzqii7enr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var negatives = 0\n        var zeros = 0\n        var product\
    \ = 1l\n        var sum = 0l\n        for (i <- arr) {\n            if (i < 0)\
    \ negatives += 1\n            else if (i == 0) zeros += 1\n            sum +=\
    \ abs(i)\n            product *= signum(i)\n        }\n        if (negatives %\
    \ 2 == 0 || zeros != 0) product = abs(product)\n        Some(sum * product)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrugyhrg.scala:31)\n\tat Problem.main(tmpjrugyhrg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        None\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmub6smtc.scala:19)\n\tat Problem.main(tmpmub6smtc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var signs = 1\n        var magnitude = 0l\n     \
    \   for (n <- arr) {\n            if (n < 0) signs *= -1\n            magnitude\
    \ += abs(n)\n        }\n        Some(magnitude * signs)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2t3t71rd.scala:26)\n\tat Problem.main(tmp2t3t71rd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            var result = 1l.toLong\n\
    \            for (x <- arr) {\n                if (x < 0) {\n                \
    \    result *= -1\n                } else if (x > 0) {\n                    result\
    \ *= 1\n                } else {\n                    result *= 0\n          \
    \      }\n            }\n            var sum = 0l.toLong\n            for (x <-\
    \ arr) {\n                sum += abs(x)\n            }\n            Some(sum *\
    \ result)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppi3agpub.scala:37)\n\tat Problem.main(tmppi3agpub.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val arr2 = arr.filter(_\
    \ != 0)\n        if (arr2.isEmpty) None\n        else {\n            val n = arr2.size\n\
    \            val p = pow(2, n - 1).toLong\n            Some(arr2.map(a => abs(a)\
    \ * p).sum)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpacs4ctba.scala:25)\n\tat Problem.main(tmpacs4ctba.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var signs : List[Long] = Nil\n        var magnitudes\
    \ : List[Long] = Nil\n        for (n <- arr) {\n            signs = math.signum(n).toLong\
    \ :: signs\n            magnitudes = math.abs(n) :: magnitudes\n        }\n  \
    \      Some(magnitudes.foldLeft(1l)(_ * _) * signs.foldLeft(1l)(_ * _))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph1wwv0a3.scala:26)\n\tat Problem.main(tmph1wwv0a3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n    \tif (arr.length\
    \ == 0) return None\n    \tvar prodSign = 1\n    \tvar magSum = 0\n    \tfor (x\
    \ <- arr) {\n    \t\tif (x < 0) prodSign *= -1\n    \t\tmagSum += abs(x)\n   \
    \ \t}\n    \treturn Some(magSum * prodSign)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_yry9bc2.scala:21:15 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    \t\tmagSum += abs(x)\n\e[31m\e[31m   |\e[0m    \t\
    \t^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \t\tvalue += is not a member of Int - did\
    \ you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        val negs = arr.filter(_ < 0).length\n        val\
    \ sign = if (negs % 2 == 0) 1 else -1\n        val mags = arr.map(abs(_))\n  \
    \      val prod = mags.product\n        Some(sign * prod)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvtzrz1vo.scala:24)\n\tat Problem.main(tmpvtzrz1vo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else {\n            val p = arr.foldLeft(1l)((z, i) => z\
    \ * signum(i).toLong)\n            Some(arr.foldLeft(0l)((z, i) => z + abs(i))\
    \ * p)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd3j928i2.scala:23)\n\tat Problem.main(tmpd3j928i2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // the first\
    \ thing that comes to mind is to first filter the list\n        // by removing\
    \ the 0's, and then map it to -1, 1 to represent\n        // signs and then reduce\
    \ the product and sum of remaining elements\n        if (arr.length == 0) {\n\
    \            return None\n        }\n        Some(arr.filter(x => x != 0).map(x\
    \ => if (x > 0) 1 else -1).reduce(_ * _) * arr.filter(x => x != 0).map(x => abs(x)).reduce(_\
    \ + _))\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplb0q9d0b.scala:25)\n\tat Problem.main(tmplb0q9d0b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var sum = 0l\n        var product = 1l\n        for\
    \ (e <- arr) {\n            sum += abs(e)\n            if (e != 0) product *=\
    \ e / abs(e)\n        }\n        Some(sum * product)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqoxy09po.scala:26)\n\tat Problem.main(tmpqoxy09po.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var sum = 0l\n        var prod = 1l\n        for\
    \ (i <- arr) {\n            if (i > 0) sum += i else if (i < 0) {sum -= i; prod\
    \ *= -1}\n        }\n        Some(sum * prod)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkbul6i2e.scala:25)\n\tat Problem.main(tmpkbul6i2e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val list = arr.map(x\
    \ => x.toString.toLong)\n        if (list.size > 0) {\n          var product =\
    \ 1l\n          var sum = 0l\n          for (number <- list) {\n            if\
    \ (number > 0) {\n              product *= 1\n              sum += number\n  \
    \          } else if (number < 0) {\n              product *= -1\n           \
    \   sum += -number\n            } else if (number == 0) {\n              product\
    \ *= 0\n            }\n          }\n          Some(sum * product)\n        } else\
    \ {\n          None\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_fvzh6v3.scala:37)\n\tat Problem.main(tmp_fvzh6v3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979935
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var product = 1l\n        var sum = 0l\n        for\
    \ (i <- arr) {\n            sum += abs(i)\n            if (i > 0) product *= 1\n\
    \            else if (i < 0) product *= -1\n            else product *= 0\n  \
    \      }\n        return Some(sum * product)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwnrdtyrv.scala:28)\n\tat Problem.main(tmpwnrdtyrv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr match {\n\
    \            case Nil => None\n            case _ => {\n                val result\
    \ = arr.foldLeft(1l)((total, x) => total * signum(x).toLong)\n               \
    \ Some(result)\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2wx44zef.scala:25)\n\tat Problem.main(tmp2wx44zef.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val as = arr.toArray\n\
    \        if (as.length == 0) return None\n        var sign = 1l\n        for (i\
    \ <- 0 until as.length) {\n            if (as(i) < 0) {\n                sign\
    \ *= -1\n                as(i) *= -1\n            }\n            else if (as(i)\
    \ == 0) {\n                sign = 0\n                as(i) = 1\n            }\n\
    \        }\n        if (sign == 0) return Some(0)\n        return Some(as.product\
    \ * sign)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprnsbekmr.scala:33)\n\tat Problem.main(tmprnsbekmr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // your code\
    \ here\n        if (arr.isEmpty) None\n        else {\n            Some(\n   \
    \             arr.map(x => if (x == 0) 0 else if (x > 0) 1 else -1).product *\
    \ \n                arr.map(x => if (x < 0) -x else x).sum\n            )\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa5mm38h9.scala:26)\n\tat Problem.main(tmpa5mm38h9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var sgn = 1l\n        var tot = 0l\n        for (e\
    \ <- arr) {\n            val i = e.toInt\n            if (i == 0) return Some(0l)\n\
    \            else if (i < 0) sgn *= -1\n            tot += abs(i)\n        }\n\
    \        Some(tot * sgn)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyyiav7cn.scala:28)\n\tat Problem.main(tmpyyiav7cn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        def prodSigns(arr\
    \ : List[Long], res : Long) : Long = {\n            arr match {\n            \
    \    case List() => return res\n                case x :: xs => prodSigns(xs,\
    \ res * (x.signum * abs(x)))\n            }\n        }\n        if (arr.length\
    \ == 0) None else Some(prodSigns(arr, 1))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg4swsz3z.scala:25)\n\tat Problem.main(tmpg4swsz3z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979935
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n\t    if (arr.length\
    \ == 0) {\n\t\t    None\n\t    } else {\n\t\t    Some(arr.map(i => (i * i).toLong).sum\
    \ * arr.map(i => (if (i > 0) 1 else if (i < 0) -1 else 0)).product)\n\t    }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpaprciqe2.scala:18:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m\t    } \e[33melse\e[0m {\n\e[31m\e[31m   |\e[0m\t  \
    \  ^\e[0m\n\e[31m   |\e[0m   Incompatible combinations of tabs and spaces in indentation\
    \ prefixes.\n\e[31m   |\e[0m   Previous indent : 2 tabs, 4 spaces\n\e[31m   |\e\
    [0m   Latest indent   : 1 tab, 4 spaces\n\e[31m\e[31m-- Error: /tmp/tmpaprciqe2.scala:20:4\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m\t    }\n\
    \e[31m\e[31m   |\e[0m\t    ^\e[0m\n\e[31m   |\e[0m   Incompatible combinations\
    \ of tabs and spaces in indentation prefixes.\n\e[31m   |\e[0m   Previous indent\
    \ : 2 tabs, 4 spaces\n\e[31m   |\e[0m   Latest indent   : 1 tab, 4 spaces\n\e\
    [31m\e[31m-- Error: /tmp/tmpaprciqe2.scala:21:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab, 4 spaces\n\e[31m   |\e[0m   Latest indent\
    \   : 4 spaces\n3 errors found\n"
  stdout: ''
  timestamp: 1659979940
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n\t\treturn arr match\
    \ {\n\t\t\tcase Nil => None\n\t\t\tcase arr: List[Long] => {\n\t\t\t\tvar prod\
    \ = 1L\n\t\t\t\tvar sum = 0L\n\t\t\t\tarr.foreach(e => {\n\t\t\t\t\tprod *= signum(e)\n\
    \t\t\t\t\tsum += abs(e)\n\t\t\t\t})\n\t\t\t\tSome(sum * prod)\n\t\t\t}\n\t\t}\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpghv49pdz.scala:28:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 2 tabs\n\e[31m   |\e[0m   Latest indent   :\
    \ 4 spaces\n1 error found\n"
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var product :\
    \ Long = 1l\n        var sum = 0l\n        for (i <- arr) {\n            sum +=\
    \ abs(i)\n            product *= i.signum\n        }\n        if (arr.isEmpty)\
    \ None else Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyurccd1f.scala:25)\n\tat Problem.main(tmpyurccd1f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      if (arr.isEmpty)\
    \ None\n      else if (arr.forall(_ == 0)) Some(0)\n      else {\n        var\
    \ prod = 1\n        for (x <- arr) if (x != 0) prod *= x / abs(x)\n        Some(arr.map(x\
    \ => x * prod).sum)\n      }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppvapp3ip.scala:20:40 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mfor\e[0m (x <- arr) \e[33mif\e[0m (x !=\
    \ \e[31m0\e[0m) prod *= x / abs(x)\n\e[31m\e[31m   |\e[0m                    \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                  value *= is not\
    \ a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659979944
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val sgn = arr.map(BigInt(_)).map(BigInt(_)).map(x\
    \ => if (x == 0) 0 else x.signum).foldLeft(BigInt(1))(_ * _)\n        val abs\
    \ = arr.map(abs(_)).foldLeft(0l)(_ + _)\n        if (arr.length == 0) None else\
    \ Some(sgn.toLong * abs)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp63d7jc_e.scala:16:41 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36msgn\e[0m = arr.map(BigInt(_)).map(BigInt(_)).map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m x.signum).foldLeft(BigInt(\e\
    [31m1\e[0m))(_ * _)\n\e[31m\e[31m   |\e[0m                                   \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mapply\e[0m in \e[33mobject\e[0m \e[35mBigInt\e[0m with types\n\e[31m\
    \   |\e[0m (x: java.math.BigInteger): BigInt\n\e[31m   |\e[0m (x: String, radix:\
    \ Int): BigInt\n\e[31m   |\e[0m (x: String): BigInt\n\e[31m   |\e[0m (numbits:\
    \ Int, rnd: scala.util.Random): BigInt\n\e[31m   |\e[0m (bitlength: Int, certainty:\
    \ Int, rnd: scala.util.Random): BigInt\n\e[31m   |\e[0m (signum: Int, magnitude:\
    \ Array[Byte]): BigInt\n\e[31m   |\e[0m (x: Array[Byte]): BigInt\n\e[31m   |\e\
    [0m (l: Long): BigInt\n\e[31m   |\e[0m (i: Int): BigInt\n\e[31m   |\e[0mmatch\
    \ arguments ((_$2 : BigInt))\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp63d7jc_e.scala:16:82\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36msgn\e[0m = arr.map(BigInt(_)).map(BigInt(_)).map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m x.signum).foldLeft(BigInt(\e\
    [31m1\e[0m))(_ * _)\n\e[31m\e[31m   |\e[0m                                   \
    \                                             ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ signum is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Numeric.ByteIsIntegral.mkNumericOps\n\
    \e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e\
    [0m  import math.Numeric.CharIsIntegral.mkNumericOps\n\e[31m   |\e[0m  import\
    \ math.BigInt.javaBigInteger2bigInt\n\e[31m   |\e[0m  import math.Numeric.BigDecimalAsIfIntegral.mkNumericOps\n\
    \e[31m   |\e[0m  import math.Numeric.BigDecimalIsFractional.mkNumericOps\n\e[31m\
    \   |\e[0m  import math.Numeric.BigIntIsIntegral.mkNumericOps\n\e[31m   "
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sum = 0l\n\
    \        var prod = 1l\n        arr.foreach(e => {\n            sum += e.abs\n\
    \            prod *= e.signum\n        })\n        if (arr.isEmpty) None else\
    \ Some(sum * prod)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgnqb0w_7.scala:25)\n\tat Problem.main(tmpgnqb0w_7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else {\n            var prod = arr.map(x => if (x == 0)\
    \ 0 else signum(x).toLong).product\n            var sum = arr.map(x => if (x ==\
    \ 0) 0 else abs(x)).sum\n            Some(sum * prod)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf2m6m4iq.scala:24)\n\tat Problem.main(tmpf2m6m4iq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        def helper(acc:\
    \ Long, arr: List[Long]): Long = arr match {\n            case Nil => acc\n  \
    \          case 0l :: xs => helper(acc, xs)\n            case x :: xs => helper(acc\
    \ * x, xs)\n        }\n        if (arr.isEmpty) None\n        else Some(arr.map(abs(_)).sum\
    \ * helper(1, arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps_wunhmu.scala:25)\n\tat Problem.main(tmps_wunhmu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var p = 1l\n\
    \        var s = 0l\n        for (n <- arr) {\n            if (n == 0) p = 0\n\
    \            else if (n < 0) p *= -1\n            s += abs(n)\n        }\n   \
    \     if (arr.isEmpty) None\n        else Some(p * s)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa3_vql_p.scala:27)\n\tat Problem.main(tmpa3_vql_p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            val products = arr.map(x => if (x > 0) 1 else\
    \ if (x < 0) -1 else 0)\n            val magnitudes = arr.map(x => abs(x.toInt))\n\
    \            Some(magnitudes.zip(products).map(x => x._1 * x._2).sum)\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpygj_gl0n.scala:24)\n\tat Problem.main(tmpygj_gl0n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Write your\
    \ code here\n        None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp4v2s4p_.scala:20)\n\tat Problem.main(tmpp4v2s4p_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979944
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var sum = 0l\n        var product = 1l\n        for\
    \ (element <- arr) {\n            if (element > 0) sum += element\n          \
    \  else if (element < 0) {sum += -element; product *= -1}\n        }\n       \
    \ Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq342abn6.scala:26)\n\tat Problem.main(tmpq342abn6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            val res = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0).foldLeft(1)((product, sign) => product * sign)\n      \
    \      if (res < 0) Option(arr.map(abs(_)).foldLeft(1l)(_ * _))\n            else\
    \ Option(arr.map(abs(_)).foldLeft(1l)(_ * _) * res)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnpjm4dnn.scala:24)\n\tat Problem.main(tmpnpjm4dnn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Write your\
    \ solution here\n        val s = arr.map(abs(_))\n        val s2 = arr.map(x =>\
    \ if (x >= 0) 1 else if (x < 0) -1 else 0)\n        val p = s2.foldLeft(1l)(_\
    \ * _)\n        p match {\n            case 0 => None\n            case 1 => Some(s.sum)\n\
    \            case -1 => Some(-s.sum)\n            case _ => None\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq7nh3wi4.scala:28)\n\tat Problem.main(tmpq7nh3wi4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Your Code\
    \ Here\n        if (arr.length <= 0) None\n        else {\n            var prod\
    \ = 1l\n            var sum = 0l\n            for (x <- arr) {\n             \
    \   if (x == 0) prod *= 0\n                else if (x > 0) {\n               \
    \     prod *= 1\n                    sum += x\n                }\n           \
    \     else {\n                    prod *= -1\n                    sum += -x\n\
    \                }\n            }\n            Some(sum * prod)\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfh3qzx9v.scala:36)\n\tat Problem.main(tmpfh3qzx9v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var prod = 1l\n        var sum = 0l\n        for\
    \ (i <- arr) {\n            prod *= signum(i)\n            sum += abs(i)\n   \
    \     }\n        return Some(sum * prod)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpctyj9teb.scala:26)\n\tat Problem.main(tmpctyj9teb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var ans = 0l\n        for (num <- arr) {\n            if\
    \ (num == 0) ans = 0l\n            else if (num > 0) ans += num\n            else\
    \ ans -= num\n        }\n        Some(ans)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprrj_6p_2.scala:26)\n\tat Problem.main(tmprrj_6p_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        return arr match\
    \ {\n            case Nil => None\n            case x :: xs => Some(arr.map(x\
    \ => abs(x) * x.signum).sum)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1ydpfi5c.scala:22)\n\tat Problem.main(tmp1ydpfi5c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            var p = 1l\n            var s = 0l\n     \
    \       for (i <- arr) {\n                if (i > 0) p *= 1\n                else\
    \ if (i < 0) p *= -1\n                else p *= 0\n                s += abs(i)\n\
    \            }\n            Option(p * s)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpel7riqil.scala:30)\n\tat Problem.main(tmpel7riqil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) {\n            None\n        } else {\n            // Return the answer\n\
    \            var signs : ArrayBuffer[Int] = new ArrayBuffer[Int]()\n         \
    \   for (x <- arr) {\n                if (x == 0) {\n                    signs\
    \ += 0\n                } else if (x > 0) {\n                    signs += 1\n\
    \                } else {\n                    signs += -1\n                }\n\
    \            }\n            var sum = 0l\n            for (x <- arr) {\n     \
    \           sum += abs(x)\n            }\n            var prod = 1\n         \
    \   for (x <- signs) {\n                prod *= x\n            }\n           \
    \ Some(sum * prod)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn9dql9lo.scala:42)\n\tat Problem.main(tmpn9dql9lo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signNums\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magniNum\
    \ = arr.map(x => abs(x)).foldLeft(1l)(_ * _)\n        if (signNums.contains(0))\
    \ Some(0) else Some(signNums.foldLeft(1l)(_ * _) * magniNum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjok42yf3.scala:21)\n\tat Problem.main(tmpjok42yf3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Your code\
    \ goes here\n        return None\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxeomyxn5.scala:20)\n\tat Problem.main(tmpxeomyxn5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr match {\n\
    \            case Nil => None\n            case _ => Some(arr.map(abs(_)).sum\
    \ * arr.map(signum(_)).product)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph3zch6di.scala:22)\n\tat Problem.main(tmph3zch6di.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var p = 1l\n\
    \        for (a <- arr) {\n            p *= (if (a > 0) 1 else if (a < 0) -1 else\
    \ 0)\n        }\n        if (arr.length > 0) Some(arr.map(abs(_)).sum * p) else\
    \ None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpthci3k5k.scala:23)\n\tat Problem.main(tmpthci3k5k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979952
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var products\
    \ = ListBuffer[Long]()\n        if (arr.length == 0) {\n            return None\n\
    \        }\n        for (item <- arr) {\n            if (item == 0) {\n      \
    \          products += 1\n            } else if (item > 0) {\n               \
    \ products += 1\n            } else {\n                products += -1\n      \
    \      }\n        }\n        var product : Long = 1\n        for (item <- products)\
    \ {\n            product *= item\n        }\n        var total : Long = 0\n  \
    \      for (item <- arr) {\n            total += item.abs\n        }\n       \
    \ return Some(total * product)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxiwwn9c1.scala:40)\n\tat Problem.main(tmpxiwwn9c1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Use your solution\
    \ to solve this problem.\n        // Place your code here.\n        None\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuh0377js.scala:21)\n\tat Problem.main(tmpuh0377js.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979954
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n    \tif (arr.isEmpty)\
    \ None\n    \telse Some(arr.foldLeft(1l)((a, b) => {\n    \t\tval sign = if (b\
    \ > 0) 1l else if (b < 0) -1l else 0l\n    \t\ta * sign * abs(b)\n    \t}))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1775ojr_.scala:23)\n\tat Problem.main(tmp1775ojr_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979955
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var prod = 1l\n\
    \        var sum = 0l\n        for (e <- arr) {\n            prod *= signum(e).toLong\n\
    \            sum += abs(e)\n        }\n        sum * prod match {\n          \
    \  case 0 => None\n            case n => Some(n)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpytc1lydu.scala:28)\n\tat Problem.main(tmpytc1lydu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var prod = 1l.toLong\n\
    \        var sum = 0l.toLong\n        for (n <- arr) {\n            prod *= (if\
    \ (n > 0) 1 else if (n < 0) -1 else 0)\n            sum += abs(n)\n        }\n\
    \        if (arr.length == 0) None else Some(sum * prod)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp80zqtl6_.scala:25)\n\tat Problem.main(tmp80zqtl6_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.map(x => (if (x > 0) 1 else if (x < 0) -1 else 0)).product\n        val\
    \ sum = arr.map(x => abs(x)).sum\n        if (arr.isEmpty) None else Some(sum\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp34coyred.scala:21)\n\tat Problem.main(tmp34coyred.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            def prodSignsRec(arr : List[Long], acc : Long)\
    \ : Long = {\n                if (arr.isEmpty) acc\n                else {\n \
    \                   var x = arr.head\n                    if (x > 0) prodSignsRec(arr.tail,\
    \ acc * (x + 1) / 2)\n                    else if (x < 0) prodSignsRec(arr.tail,\
    \ acc * (x - 1) / 2)\n                    else prodSignsRec(arr.tail, acc * 0)\n\
    \                }\n            }\n            Some(prodSignsRec(arr, 1))\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpokx83875.scala:31)\n\tat Problem.main(tmpokx83875.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979955
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      val nums = arr.filter(_\
    \ != 0)\n      val signs = arr.filter(_ != 0).filter(_ < 0).length % 2\n     \
    \ val ans = if (signs == 0) 1 else -1\n      nums.length match {\n        case\
    \ 0 => None\n        case _ => Some(ans * nums.map(x => math.abs(x)).product)\n\
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph2lg8_a9.scala:25)\n\tat Problem.main(tmph2lg8_a9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            val signs = arr.map(x => if (x > 0) 1 else\
    \ if (x < 0) -1 else 0)\n            val magnitudes = arr.map(x => abs(x))\n \
    \           var signProduct = 1\n            for (sign <- signs) signProduct *=\
    \ sign\n            var magnitudeSum = 0\n            for (magnitude <- magnitudes)\
    \ magnitudeSum += magnitude\n            Some(signProduct * magnitudeSum)\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb3vo2vt0.scala:23:55 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mfor\e[0m (magnitude <- magnitudes)\
    \ magnitudeSum += magnitude\n\e[31m\e[31m   |\e[0m                           \
    \               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  value +=\
    \ is not a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659979955
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else {\n            val magnitudes = arr.map(x => abs(x))\n\
    \            val signProduct = arr.map(x => \n                if (x > 0) 1\n \
    \               else if (x < 0) -1\n                else 0\n            ).reduce(_\
    \ * _)\n            Some(magnitudes.reduce(_ + _) * signProduct)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzocgw2z4.scala:28)\n\tat Problem.main(tmpzocgw2z4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        val res = arr.foldLeft(1l.toLong, 0l.toLong)((b, a) =>\
    \ {\n            if (a == 0) (b._1, b._2)\n            else if (a > 0) (b._1 *\
    \ a, b._2 + a)\n            else (b._1 * a, b._2 - a)\n        })\n        return\
    \ Some(res._1 * res._2)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4ycb7ruh.scala:25)\n\tat Problem.main(tmp4ycb7ruh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var negCount = 0\n        for (i <- arr) if (i <\
    \ 0) negCount += 1\n        val prod = if (negCount % 2 == 0) 1 else -1\n    \
    \    var sum = 0\n        for (i <- arr) sum += abs(i.toInt)\n        Option(sum\
    \ * prod)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_d7s5yd_.scala:25)\n\tat Problem.main(tmp_d7s5yd_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            var ans = 1l.toLong\n            for (i <-\
    \ arr) {\n                if (i > 0) ans *= 1l.toLong\n                else if\
    \ (i < 0) ans *= -1l.toLong\n                else ans *= 0l.toLong\n         \
    \   }\n            if (ans == 0l.toLong) None\n            else {\n          \
    \      for (i <- arr) {\n                    if (i != 0) ans *= abs(i)\n     \
    \           }\n                Some(ans)\n            }\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb96v567o.scala:34)\n\tat Problem.main(tmpb96v567o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979957
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            var prod = 1l.toLong\n            for (n <-\
    \ arr) {\n                if (n == 0) prod = 0\n                else prod *= abs(n)\
    \ / n\n            }\n            Some(prod * arr.map(abs(_)).sum)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphqs44q7s.scala:27)\n\tat Problem.main(tmphqs44q7s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979957
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // your code\
    \ here\n        var l = arr.map(x => {\n          if (x > 0)\n            1\n\
    \          else if (x < 0)\n            -1\n          else\n            0\n  \
    \      })\n        if (l.isEmpty)\n          None\n        else\n          Some(l.reduce(_\
    \ * _) * arr.map(x => abs(x)).reduce(_ + _))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2frtlgwa.scala:31)\n\tat Problem.main(tmp2frtlgwa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        return Some(arr.map(x => abs(x)).foldLeft(1l)((a,\
    \ b) => a * b) *\n            arr.map(x => if (x == 0) 0 else if (x > 0) 1 else\
    \ -1).foldLeft(1l)((a, b) => a * b))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb37_gjp1.scala:21)\n\tat Problem.main(tmpb37_gjp1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sum = 0l\n\
    \        var prod = 1l\n        for (i <- arr) {\n            var n = 0\n    \
    \        if (i < 0) {\n                n = -1\n            } else if (i > 0) {\n\
    \                n = 1\n            }\n            sum += abs(i)\n           \
    \ prod *= n\n        }\n        if (sum == 0) {\n            return None\n   \
    \     }\n        return Some(sum * prod)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprpzbomfn.scala:34)\n\tat Problem.main(tmprpzbomfn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979957
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var negs = 0\n        var zeros = 0\n        for\
    \ (a <- arr) {\n            if (a == 0) zeros += 1\n            else if (a < 0)\
    \ negs += 1\n        }\n        if (zeros > 0) return Some(0)\n        var sign\
    \ = if (negs % 2 == 0) 1 else -1\n        var sum = 0.toLong\n        for (a <-\
    \ arr) sum += abs(a)\n        Some(sum * sign)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph49wkp46.scala:30)\n\tat Problem.main(tmph49wkp46.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979957
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.map(x => {\n            if (x == 0) 0\n            else if (x > 0) 1\n \
    \           else -1\n        }).product\n        val sum = arr.map(x => abs(x)).sum\n\
    \        if (product == 0) return Some(0)\n        return Some(sum * product)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzzxlu33d.scala:26)\n\tat Problem.main(tmpzzxlu33d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979957
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val list = arr.filter(_\
    \ != 0)\n        if (list.isEmpty) return None\n        val prod = list.map(sign(_)).reduce(_\
    \ * _)\n        val sum = list.map(abs(_)).reduce(_ + _)\n        Some(sum * prod)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1lswyi_7.scala:18:28 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mprod\e[0m = list.map(sign(_)).reduce(_\
    \ * _)\n\e[31m\e[31m   |\e[0m                            ^^^^\e[0m\n\e[31m   |\e\
    [0m                            Not found: sign\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp1lswyi_7.scala:18:46 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mprod\e[0m = list.map(sign(_)).reduce(_\
    \ * _)\n\e[31m\e[31m   |\e[0m                                            ^^^\e\
    [0m\n\e[31m   |\e[0mvalue * is not a member of Any, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmp1lswyi_7.scala:20:17 -----------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m        Some(sum * prod)\n\e[31m\e[31m   |\e[0m          \
    \   ^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e\
    [0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x:\
    \ Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\
    \e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e\
    [0mmatch arguments ((prod : Any))\n3 errors found\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var prod = 1l\n        var sum = 0l\n        for\
    \ (x <- arr) {\n            if (x < 0) prod *= -1\n            sum += abs(x)\n\
    \        }\n        Some(sum * prod)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfvonjwaz.scala:26)\n\tat Problem.main(tmpfvonjwaz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979957
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var product = 1\n        var magnitude = 0\n    \
    \    for (i <- arr) {\n            if (i == 0) product = 0\n            else if\
    \ (i < 0) product *= -1\n            magnitude += abs(i)\n        }\n        Some(magnitude\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp578so_hb.scala:22:22 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            magnitude += abs(i)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // TODO implement\
    \ this function\n        return null\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.Option.equals(Object)\"\
    \ because the return value of \"Problem$.prodSigns(scala.collection.immutable.List)\"\
    \ is null\n\tat Problem$.main(tmp8ativ722.scala:20)\n\tat Problem.main(tmp8ativ722.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else Some(arr.foldLeft(1l)((prod, curr) => prod * abs(curr)\
    \ * signum(curr)))\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo3c3nl9v.scala:20)\n\tat Problem.main(tmpo3c3nl9v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val result =\
    \ arr.map(math.abs(_)).product\n        val signs = arr.map(signum(_))\n     \
    \   if (signs.isEmpty) None\n        else Option(result * signs.product)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5wgbwctm.scala:22)\n\tat Problem.main(tmp5wgbwctm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979966
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var result : Long = 1\n        for (x <- arr) {\n\
    \            if (x == 0) result = 0\n            else if (x < 0) result *= -1\n\
    \        }\n        for (x <- arr) result *= abs(x)\n        Some(result)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyuflwh0.scala:26)\n\tat Problem.main(tmpuyuflwh0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var prod : Long = 1l.toLong\n        var sum : Long\
    \ = 0l.toLong\n        for (x <- arr) {\n            prod *= if (x < 0) -1 else\
    \ if (x > 0) 1 else 0\n            sum += x.abs\n        }\n        return Some(sum\
    \ * prod)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp2v5__qg9.scala:20:20 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            prod *= \e[33mif\e[0m (x < \e[31m0\e[0m)\
    \ -\e[31m1\e[0m \e[33melse\e[0m \e[33mif\e[0m (x > \e[31m0\e[0m) \e[31m1\e[0m\
    \ \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                    ^^\e\
    [0m\n\e[31m   |\e[0m                    expression expected but \e[31mif\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2v5__qg9.scala:20:17\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            prod *= \e[33mif\e\
    [0m (x < \e[31m0\e[0m) -\e[31m1\e[0m \e[33melse\e[0m \e[33mif\e[0m (x > \e[31m0\e\
    [0m) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of Long\
    \ - did you mean Long.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr match {\n\
    \            case Nil => None\n            case _ => Some(arr.map(x => scala.math.abs(x)\
    \ * signum(x)).sum)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmcyyg01f.scala:22)\n\tat Problem.main(tmpmcyyg01f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            Some(arr.map(x => if (x ==\
    \ 0) 0 else x / abs(x)).reduce(_ * _) * arr.map(x => abs(x)).reduce(_ + _))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo_rugkhx.scala:23)\n\tat Problem.main(tmpo_rugkhx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // your code\
    \ goes here.\n        return None\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqvke1vbn.scala:20)\n\tat Problem.main(tmpqvke1vbn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var res : Long\
    \ = 1l\n        var empty = true\n        for (num <- arr) {\n            if (num\
    \ != 0) {\n                empty = false\n                res *= signum(num)\n\
    \            }\n        }\n        if (empty) {\n            None\n        } else\
    \ {\n            Some(res)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg66_lip_.scala:31)\n\tat Problem.main(tmpg66_lip_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var sumMagnitude = 0\n        var prodSign = 1\n\
    \        for (n <- arr) {\n            sumMagnitude += abs(n.toInt)\n        \
    \    prodSign *= signum(n.toInt)\n        }\n        Some(sumMagnitude * prodSign)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbutysiu1.scala:26)\n\tat Problem.main(tmpbutysiu1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else {\n            var sum = 0l\n            for (a <-\
    \ arr) {\n                sum += (if (a > 0) 1 else if (a < 0) -1 else 0)\n  \
    \          }\n            var prod = 1l\n            for (a <- arr) {\n      \
    \          prod *= (if (a > 0) 1 else if (a < 0) -1 else 0)\n            }\n \
    \           Some(sum * prod)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuibyvntc.scala:30)\n\tat Problem.main(tmpuibyvntc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979968
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        val plus = arr.map(x => (abs(x), if (x > 0) 1 else if (x\
    \ < 0) -1 else 0)).reduce((a, b) => (a._1 + b._1, a._2 * b._2))\n        Some(plus._1\
    \ * plus._2)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz_fcs59i.scala:21)\n\tat Problem.main(tmpz_fcs59i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var m = 1\n \
    \       var p = 1\n        for (i <- arr) {\n            if (i > 0) p *= 1\n \
    \           else if (i < 0) p *= -1\n            else if (i == 0) m = 0\n    \
    \        m *= abs(i)\n        }\n        if (arr.length > 0) Some(m * p) else\
    \ None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptjfg5ijd.scala:22:14 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            m *= abs(i)\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of Int -\
    \ did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659979966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var prod = 1\n\
    \        var sum = 0\n        for (num <- arr) {\n            prod *= num / abs(num)\n\
    \            sum += abs(num)\n        }\n        if (sum == 0) return None\n \
    \       Some(sum * prod)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeyyt2kmo.scala:19:17 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            prod *= num / abs(num)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member\
    \ of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeyyt2kmo.scala:20:16\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            sum += abs(num)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var sum = 0l\n        var prod = 1l\n        for (i <-\
    \ arr) {\n            sum += abs(i)\n            prod *= i match {\n         \
    \       case 0 => 0\n                case _ => i / abs(i)\n            }\n   \
    \     }\n        return Some(sum * prod)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpkbtkheaf.scala:22:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mcase\e[0m \e[31m0\e[0m => \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m       \
    \    Values of types Int and Unit cannot be compared with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var s = 1l\n        var p = 1l\n        for (i <- arr)\
    \ {\n            if (i > 0) s += i\n            else if (i < 0) s -= i\n     \
    \       else p = 0\n            p *= signum(i)\n        }\n        return Some(s\
    \ * p)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7z7b85bq.scala:28)\n\tat Problem.main(tmp7z7b85bq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val prod = arr.map(x\
    \ => (if (x < 0) -1 else if (x > 0) 1 else 0)).reduce(_ * _)\n        if (prod\
    \ == 0) None else Some(arr.map(x => abs(x)).reduce(_ + _) * prod)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbstdsjdl.scala:20)\n\tat Problem.main(tmpbstdsjdl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979968
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        val signs = arr.map(x => if (x == 0) 0 else if (x > 0)\
    \ 1 else -1)\n        val magnitudes = arr.map(x => x.abs)\n        var total\
    \ = 1l\n        for (s <- signs) {\n            total *= s\n        }\n      \
    \  val magnitudeTotal = magnitudes.foldLeft(0l)((x, y) => x + y)\n        Some(magnitudeTotal\
    \ * total)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpctpdx66y.scala:27)\n\tat Problem.main(tmpctpdx66y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979968
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var product : Long = 1l\n        var sum : Long = 0l\n\
    \        for (i <- arr) {\n            product *= (if (i == 0) 1 else (if (i >\
    \ 0) 1 else -1))\n            sum += abs(i)\n        }\n        return Some(sum\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv0c9g88n.scala:26)\n\tat Problem.main(tmpv0c9g88n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val s = arr.size\n\
    \        if (s == 0) {\n            None\n        } else {\n            val sum\
    \ = arr.map(abs(_)).sum\n            val sign = if (arr.forall(_ > 0)) 1 else\
    \ if (arr.exists(_ < 0)) -1 else 0\n            Some(sum * sign)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxjamrhm6.scala:26)\n\tat Problem.main(tmpxjamrhm6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979968
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            var product = 1l\n            var sum = 0l\n\
    \            arr.foreach(x => {\n                if (x > 0) product *= 1\n   \
    \             else if (x < 0) product *= -1\n                else product *= 0\n\
    \                sum += abs(x)\n            })\n            Some(sum * product)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpis4146j6.scala:30)\n\tat Problem.main(tmpis4146j6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979968
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sum = 0l\n\
    \        var prod = 1l\n        for (n <- arr) {\n            val sign = if (n\
    \ < 0) -1 else if (n > 0) 1 else 0\n            sum += sign * n\n            prod\
    \ *= sign\n        }\n        if (arr.isEmpty) None else Some(sum * prod)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp57s29w8w.scala:26)\n\tat Problem.main(tmp57s29w8w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979968
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        val positiveSign = 1\n        val negativeSign = -1\n \
    \       val zeroSign = 0\n        var sumOfMagnitudes = 0.toLong\n        var\
    \ productOfSigns = 1.toLong\n        for (number <- arr) {\n            var sign\
    \ = (number / abs(number)).toInt\n            if (sign == 0) sign = zeroSign\n\
    \            productOfSigns *= sign\n            sumOfMagnitudes += abs(number)\n\
    \        }\n        return Some(sumOfMagnitudes * productOfSigns)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe5gig80d.scala:31)\n\tat Problem.main(tmpe5gig80d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var total : Long\
    \ = 1\n        var sum : Long = 0\n        for (i <- arr) {\n            val sign\
    \ = if (i < 0) -1 else if (i > 0) 1 else 0\n            sum += abs(i)\n      \
    \      total *= sign\n        }\n        sum * total\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdxb9rfdc.scala:23:8\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m        sum * total\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val l = arr.length\n\
    \        if (l == 0) return None\n        val negs = arr.count(_ < 0)\n      \
    \  val pos = arr.count(_ > 0)\n        val sum = arr.map(x => if (x == 0) 0 else\
    \ abs(x)).sum\n        val sgn = if (negs % 2 == 0) 1 else -1\n        Some(sum\
    \ * sgn)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp573u4dgu.scala:25)\n\tat Problem.main(tmp573u4dgu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        def prodSignsRec(arr\
    \ : List[Long], runningSign : Long, runningProduct : Long) : Long = {\n      \
    \      arr match {\n                case Nil => runningProduct\n             \
    \   case h :: t => if (h > 0) prodSignsRec(t, 1, runningProduct * runningSign)\n\
    \                               else if (h < 0) prodSignsRec(t, -1, runningProduct\
    \ * runningSign)\n                               else prodSignsRec(t, runningSign,\
    \ runningProduct)\n            }\n        }\n        if (arr.length == 0) None\n\
    \        else Some(prodSignsRec(arr, 1, 1))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzmueuae.scala:28)\n\tat Problem.main(tmpqzmueuae.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else {\n            var prod = 1\n            var sum =\
    \ 0\n            arr.foreach(x => {\n                if (x > 0) {\n          \
    \          prod *= 1\n                    sum += x\n                }\n      \
    \          else if (x < 0) {\n                    prod *= -1\n               \
    \     sum += (-x)\n                }\n                else {\n               \
    \     prod *= 0\n                }\n            })\n            Some(sum * prod)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpauquqnwj.scala:23:24 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    sum += x\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^\e[0m\n\e[31m   |\e[0m                  value += is\
    \ not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpauquqnwj.scala:27:24 ------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m                    sum += (-x)\n\e[31m\e[31m   |\e[0m               \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m                  value += is not a member of\
    \ Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979976
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        val signProduct = arr.map(x => if (x == 0) 0 else if (x\
    \ > 0) 1 else -1).product\n        val magnitudeSum = arr.map(x => abs(x)).sum\n\
    \        Some(signProduct * magnitudeSum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpumf2czhp.scala:22)\n\tat Problem.main(tmpumf2czhp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979978
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n    \tif (arr.isEmpty)\
    \ return None\n    \tvar product = 1l\n    \tvar sum = 0l\n    \tfor (x <- arr)\
    \ {\n    \t\tif (x > 0) product *= 1\n    \t\telse if (x < 0) product *= -1\n\
    \    \t\telse if (x == 0) product *= 0\n    \t\tsum += math.abs(x)\n    \t}\n\
    \    \tsum *= product\n    \treturn Some(sum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo4slbvec.scala:29)\n\tat Problem.main(tmpo4slbvec.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979978
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            var s = 1l\n            var m = 0l\n     \
    \       for (n <- arr) {\n                if (n > 0) s *= 1\n                else\
    \ if (n < 0) s *= -1\n                else {\n                    s = 0\n    \
    \                m = 0\n                }\n                m += abs(n)\n     \
    \       }\n            Some(s * m)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tvyag_p.scala:33)\n\tat Problem.main(tmp0tvyag_p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Your code\
    \ here.\n        if (arr.isEmpty) None\n        else {\n            val signs\
    \ = arr.map(x => if (x == 0) 0 else if (x > 0) 1 else -1)\n            val magnitudes\
    \ = arr.map(x => abs(x))\n            Some(magnitudes.foldLeft(1l)(_ * _) * signs.foldLeft(1l)(_\
    \ * _))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuktfzhfe.scala:25)\n\tat Problem.main(tmpuktfzhfe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var product = 1l\n        var sum = 0l\n        for\
    \ (x <- arr) {\n            if (x == 0) {\n                product = 0\n     \
    \           sum = 0\n            } else if (x < 0) {\n                product\
    \ *= -1\n                sum += abs(x)\n            } else {\n               \
    \ sum += x\n            }\n        }\n        return Some(sum * product)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptta8ievl.scala:33)\n\tat Problem.main(tmptta8ievl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979978
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        None\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmub6smtc.scala:19)\n\tat Problem.main(tmpmub6smtc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else Some(arr.map(abs(_)).sum * arr.map(_.signum).product)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa4m6kram.scala:20)\n\tat Problem.main(tmpa4m6kram.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n\tval arr2 = arr.filter(x\
    \ => x != 0l)\n\tif (arr2.length > 0) {\n\t    val l = arr2.map(x => if (x < 0)\
    \ -1 else 1).foldLeft(1)((x, y) => x * y)\n\t    val m = arr2.map(x => abs(x)).sum\n\
    \t    Some(l * m)\n\t} else {\n\t    None\n\t}\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmps2auzyl2.scala:24:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab\n\e[31m   |\e[0m   Latest indent   : 4\
    \ spaces\n1 error found\n"
  stdout: ''
  timestamp: 1659979974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Your code\
    \ here\n        var product = 1l\n        var sum = 0l\n        for (x <- arr)\
    \ {\n            if (x > 0) {\n                product *= 1\n                sum\
    \ += x\n            }\n            else if (x < 0) {\n                product\
    \ *= -1\n                sum += -x\n            }\n            else {\n      \
    \          product *= 0\n            }\n        }\n        if (arr.length == 0)\
    \ {\n            None\n        }\n        else {\n            Some(sum * product)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpifp6n6oy.scala:40)\n\tat Problem.main(tmpifp6n6oy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979978
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var prod : Long = 1\n        var sum : Long = 0\n\
    \        for (n <- arr) {\n            prod *= Math.signum(n).toLong\n       \
    \     sum += Math.abs(n)\n        }\n        return Some(sum * prod)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxd3t_v9w.scala:26)\n\tat Problem.main(tmpxd3t_v9w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ > 0) {\n            var signProd = 1l\n            var magSum = 0l\n       \
    \     for (i <- arr) {\n                if (i > 0) signProd *= 1\n           \
    \     else if (i < 0) signProd *= -1\n                else signProd *= 0\n   \
    \             magSum += i.abs\n            }\n            Some(magSum * signProd)\n\
    \        } else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp65oxiod7.scala:29)\n\tat Problem.main(tmp65oxiod7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ > 0) {\n        \tval zeros = arr.filter(_ == 0).length\n        \tval negatives\
    \ = arr.filter(_ < 0).length\n        \tval positives = arr.filter(_ > 0).length\n\
    \        \tval magnitude = arr.map(abs(_)).sum\n        \tval product = pow(0.5,\
    \ zeros) * pow(-0.5, negatives) * pow(1.5, positives)\n        \tSome(magnitude\
    \ * product)\n        } else {\n        \tNone\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpszymajyj.scala:22:13\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \tSome(magnitude * product)\n\
    \e[31m\e[31m   |\e[0m        \t     ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        \t     Found:    Double\n\e[31m   |\e[0m        \t     Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979978
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        val signs = arr.map {x =>\n            if (x > 0) 1\n \
    \           else if (x < 0) -1\n            else 0\n        }\n        val magnitudes\
    \ = arr.map {x => abs(x)}\n        val signProd = signs.reduceLeft(_ * _)\n  \
    \      val magnitudeSum = magnitudes.reduceLeft(_ + _)\n        Option(signProd\
    \ * magnitudeSum)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr24513lk.scala:28)\n\tat Problem.main(tmpr24513lk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else Some(arr.foldLeft(1l.toLong)((a, b) => if (b == 0)\
    \ a else a * signum(b).toLong))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd1qyrb_k.scala:20)\n\tat Problem.main(tmpd1qyrb_k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var ans : Long\
    \ = 1l\n        for (i <- arr) ans *= abs(i)\n        return Some(ans)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6f6ig44c.scala:21)\n\tat Problem.main(tmp6f6ig44c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // your code\
    \ here\n        null\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NullPointerException: Cannot invoke \"scala.Option.equals(Object)\"\
    \ because the return value of \"Problem$.prodSigns(scala.collection.immutable.List)\"\
    \ is null\n\tat Problem$.main(tmprvltc53t.scala:20)\n\tat Problem.main(tmprvltc53t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n    \tif (arr.isEmpty)\
    \ None\n    \telse Some(arr.map(x => if (x > 0) 1l else if (x < 0) -1l else 0l).reduce(_\
    \ * _) * arr.map(x => abs(x)).reduce(_ + _))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn9x0v2av.scala:20)\n\tat Problem.main(tmpn9x0v2av.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) {\n            None\n        } else {\n            var magnitudes = arr.map(x\
    \ => if (x < 0) -x else x)\n            var sum = magnitudes.sum\n           \
    \ var product = arr.map(x => if (x < 0) -1 else 1).product\n            Some(sum\
    \ * product)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcxuuwsjx.scala:26)\n\tat Problem.main(tmpcxuuwsjx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        val signs = arr.map(x => if (x > 0) 1 else if (x\
    \ < 0) -1 else 0)\n        val mags = arr.map(abs(_))\n        val signProduct\
    \ = signs.foldLeft(1)(_ * _)\n        Some(mags.foldLeft(0l)(_ + _) * signProduct)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiy0lsexg.scala:23)\n\tat Problem.main(tmpiy0lsexg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979978
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var prod = 1l\n\
    \        var sum = 0l\n        for (x <- arr) {\n            prod *= x / abs(x)\n\
    \            sum += abs(x)\n        }\n        return if (sum == 0) None else\
    \ Some(sum * prod)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpajaohyph.scala:25)\n\tat Problem.main(tmpajaohyph.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            var sum = 0l\n          \
    \  var product = 1l\n            arr.foreach(i => {\n                if (i ==\
    \ 0) product *= 0\n                else product *= signum(i)\n               \
    \ sum += abs(i)\n            })\n            Some(sum * product)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzwhrbymp.scala:30)\n\tat Problem.main(tmpzwhrbymp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var m = 1\n        var s = 1\n        for (i <- arr) {\n\
    \            m *= abs(i)\n            s *= if (i < 0) -1 else if (i > 0) 1 else\
    \ 0\n        }\n        Some(m * s)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpv_x4rl78.scala:21:17 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            s *= \e[33mif\e[0m (i < \e[31m0\e[0m) -\e\
    [31m1\e[0m \e[33melse\e[0m \e[33mif\e[0m (i > \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                 ^^\e[0m\n\e[31m   |\e\
    [0m                 expression expected but \e[31mif\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv_x4rl78.scala:20:14 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            m *= abs(i)\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of Int -\
    \ did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv_x4rl78.scala:21:14\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            s *= \e[33mif\e\
    [0m (i < \e[31m0\e[0m) -\e[31m1\e[0m \e[33melse\e[0m \e[33mif\e[0m (i > \e[31m0\e\
    [0m) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of Int - did\
    \ you mean Int.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659979985
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val ans = arr.foldLeft(Some(0l.toLong)\
    \ : Option[Long])((x, y) => {\n            if (x == None) None\n            else\
    \ {\n                if (y == 0) Some(x.get * 0)\n                else if (y >\
    \ 0) Some(x.get * 1)\n                else Some(x.get * -1)\n            }\n \
    \       })\n        if (ans == None) None\n        else {\n            var product\
    \ = 1l.toLong\n            for (x <- arr) {\n                if (x != 0) product\
    \ *= abs(x)\n            }\n            Some(product * ans.get)\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzi6hziky.scala:34)\n\tat Problem.main(tmpzi6hziky.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979987
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var s = 0l\n\
    \        var p = 1l\n        for (x <- arr) {\n            s += abs(x)\n     \
    \       if (x > 0) p *= 1\n            else if (x < 0) p *= -1\n        }\n  \
    \      if (arr.isEmpty) return None\n        return Some(s * p)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplmxhpqyk.scala:27)\n\tat Problem.main(tmplmxhpqyk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var prod = 1l\n        var sum = 0l\n        for (i <-\
    \ arr) {\n            prod *= if (i == 0) 1 else if (i > 0) 1 else -1\n      \
    \      sum += abs(i)\n        }\n        Some(sum * prod)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpizpqoyu6.scala:20:20 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            prod *= \e[33mif\e[0m (i == \e[31m0\e[0m)\
    \ \e[31m1\e[0m \e[33melse\e[0m \e[33mif\e[0m (i > \e[31m0\e[0m) \e[31m1\e[0m \e\
    [33melse\e[0m -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^\e[0m\n\
    \e[31m   |\e[0m                    expression expected but \e[31mif\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpizpqoyu6.scala:20:17\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            prod *= \e[33mif\e\
    [0m (i == \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e[33mif\e[0m (i > \e[31m0\e\
    [0m) \e[31m1\e[0m \e[33melse\e[0m -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of Long\
    \ - did you mean Long.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Another possible\
    \ solution:\n        // arr.map(_.signum).product * arr.map(abs(_)).sum\n    \
    \    // Also, it's possible to solve this problem in functional\n        // style,\
    \ which is more common in Scala.\n        if (arr.isEmpty) return None\n     \
    \   var sum = 0l\n        var prod = 1l\n        for (i <- arr) {\n          \
    \  sum += abs(i)\n            prod *= if (i > 0) 1 else if (i < 0) -1 else 0\n\
    \        }\n        Some(sum * prod)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3q8frkpd.scala:25:20 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            prod *= \e[33mif\e[0m (i > \e[31m0\e[0m)\
    \ \e[31m1\e[0m \e[33melse\e[0m \e[33mif\e[0m (i < \e[31m0\e[0m) -\e[31m1\e[0m\
    \ \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                    ^^\e\
    [0m\n\e[31m   |\e[0m                    expression expected but \e[31mif\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3q8frkpd.scala:25:17\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            prod *= \e[33mif\e\
    [0m (i > \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e[33mif\e[0m (i < \e[31m0\e\
    [0m) -\e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of Long\
    \ - did you mean Long.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979986
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        val signs = arr.map {\n            case x if x >\
    \ 0 => 1\n            case x if x < 0 => -1\n            case x if x == 0 => 0\n\
    \        }\n        val ret = arr.map {\n            case x if x > 0 => x\n  \
    \          case x if x < 0 => -x\n            case x if x == 0 => 0\n        }.sum\
    \ * signs.product\n        Some(ret)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphvbfaodp.scala:30)\n\tat Problem.main(tmphvbfaodp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else Some(arr.map(x => signum(x)).product * arr.map(x => abs(x)).sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpezsmziys.scala:20)\n\tat Problem.main(tmpezsmziys.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else {\n            val magnitudes = arr.map(a => abs(a))\n\
    \            val signs = arr.map(a => if (a > 0) 1 else if (a < 0) -1 else 0)\n\
    \            Some(magnitudes.sum * signs.product)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv55z5ejy.scala:24)\n\tat Problem.main(tmpv55z5ejy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        arr.foldLeft(1l.toLong, 0l.toLong) {case ((ps, ms), e)\
    \ => if (e < 0) (ps * -1, ms + abs(e)) else if (e > 0) (ps, ms + e) else (ps,\
    \ ms)} match {\n            case (p, m) => Some(p * m)\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaehbzkwh.scala:22)\n\tat Problem.main(tmpaehbzkwh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var p = 1l.toLong\n        var s = 0l.toLong\n        for\
    \ (i <- arr) {\n            if (i == 0) continue\n            if (i < 0) p *=\
    \ -1\n            s += abs(i)\n        }\n        Some(p * s)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqm8fy0xq.scala:20:24 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m (i == \e[31m0\e[0m) continue\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                      Not found: continue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979985
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Write your\
    \ code here\n        ???\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "scala.NotImplementedError: an implementation is missing\n\tat scala.Predef$.$qmark$qmark$qmark(Predef.scala:344)\n\
    \tat Problem$.prodSigns(tmptcyob47w.scala:17)\n\tat Problem$.main(tmptcyob47w.scala:20)\n\
    \tat Problem.main(tmptcyob47w.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      if (arr.length\
    \ == 0) return None\n      val ret = arr.map(abs(_)).reduceLeft((a, b) => a *\
    \ b) * arr.map(_.signum).reduceLeft((a, b) => a * b)\n      return Some(ret)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6xm4qzzq.scala:21)\n\tat Problem.main(tmp6xm4qzzq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var prod = 1l\n        var sum = 0l\n        for\
    \ (x <- arr) {\n            prod *= x.signum\n            sum += x.abs\n     \
    \   }\n        Some(sum * prod)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9quk08v3.scala:26)\n\tat Problem.main(tmp9quk08v3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979990
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) {\n            None\n        } else {\n            val prods = arr.map(x\
    \ => if (x > 0) 1 else if (x < 0) -1 else 0)\n            val magn = arr.map(x\
    \ => abs(x))\n            Option(magn.sum * prods.product)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3ba084n5.scala:25)\n\tat Problem.main(tmp3ba084n5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else {\n            val signs = arr.map(x => if (x == 0)\
    \ 0 else if (x > 0) 1 else -1)\n            val mags = arr.map(x => abs(x))\n\
    \            Some(mags.foldLeft(1l)(_ * _) * signs.foldLeft(1l)(_ * _))\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkwrccwcb.scala:24)\n\tat Problem.main(tmpkwrccwcb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val t = arr.map(x\
    \ => (abs(x), if (x > 0) 1 else if (x < 0) -1 else 0)).toArray\n        var product\
    \ = 1\n        var sum = 0\n        for (x <- t) {\n            product *= x._2\n\
    \            sum += x._1\n        }\n        if (product == 0) None else Some(sum\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgb7zartf.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += x._1\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int\
    \ - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // your code\
    \ here\n        var x : Long = 0\n        var y : Long = 1\n        if (arr.length\
    \ == 0) return None\n        for (i <- arr) {\n            if (i != 0) {\n   \
    \             x += abs(i)\n                y *= i / abs(i)\n            }\n  \
    \      }\n        Some(x * y)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps22n50de.scala:29)\n\tat Problem.main(tmps22n50de.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Your code\
    \ goes here.\n        val option : Option[Long] = Some(0)\n        return option\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppzduyfep.scala:21)\n\tat Problem.main(tmppzduyfep.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // your code\
    \ here\n        if (arr.isEmpty) None\n        else {\n            val a = arr.map(_.abs)\n\
    \            val b = arr.map(_.signum)\n            Some(a.product * b.product)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpty9m1lxp.scala:25)\n\tat Problem.main(tmpty9m1lxp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979990
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            var prod = arr.head\n            for (i <-\
    \ 1 until arr.length) {\n                if (arr(i) == 0l) prod = 0l\n       \
    \         else if (prod == 0l) prod = arr(i)\n                else if (prod >\
    \ 0) prod *= arr(i)\n                else if (prod < 0 && arr(i) > 0) prod *=\
    \ arr(i)\n                else if (prod < 0 && arr(i) < 0) prod *= arr(i)\n  \
    \          }\n            var mag = 0l\n            for (i <- 0 until arr.length)\
    \ {\n                if (arr(i) > 0) mag += arr(i)\n                else if (arr(i)\
    \ < 0) mag -= arr(i)\n            }\n            Some(mag * prod)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp84ihq39v.scala:35)\n\tat Problem.main(tmp84ihq39v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n\t    if (arr.isEmpty)\
    \ None\n\t    else {\n\t\t    val prod = arr.map(i => if (i < 0) -1 else if (i\
    \ > 0) 1 else 0).product\n\t\t    val sum = arr.map(i => abs(i)).sum\n\t\t   \
    \ Some(sum * prod)\n\t    }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmppv1unboy.scala:21:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m\t    }\n\e[31m\e[31m   |\e[0m\t    ^\e[0m\n\e[31m  \
    \ |\e[0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\
    \e[31m   |\e[0m   Previous indent : 2 tabs, 4 spaces\n\e[31m   |\e[0m   Latest\
    \ indent   : 1 tab, 4 spaces\n\e[31m\e[31m-- Error: /tmp/tmppv1unboy.scala:22:4\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m    }\n\
    \e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e[0m   Incompatible combinations of\
    \ tabs and spaces in indentation prefixes.\n\e[31m   |\e[0m   Previous indent\
    \ : 1 tab, 4 spaces\n\e[31m   |\e[0m   Latest indent   : 4 spaces\n2 errors found\n"
  stdout: ''
  timestamp: 1659979987
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Your code\
    \ goes here\n        var sums = 0l\n        var prod = 1l\n        for (a <- arr)\
    \ {\n            sums += a.abs\n            prod *= (if (a > 0) 1 else if (a <\
    \ 0) -1 else 0)\n        }\n        if (arr.length == 0) None else Some(sums *\
    \ prod)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjgs7c8ri.scala:26)\n\tat Problem.main(tmpjgs7c8ri.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var sign = 1\n        var sum = 0\n        for (a\
    \ <- arr) {\n            if (a == 0) {\n                sign = 0\n           \
    \     sum = 0\n            } else {\n                sum += a.abs\n          \
    \      sign *= a.signum\n            }\n        }\n        return Some(sum * sign)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz2lfinxz.scala:24:20 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                sum += a.abs\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not a\
    \ member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659979993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Your Code\
    \ Here\n        None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr6jxon0i.scala:20)\n\tat Problem.main(tmpr6jxon0i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979995
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) {\n            None\n        } else {\n            val signList = arr.map(x\
    \ => if (x == 0) 0 else if (x > 0) 1 else -1)\n            val prod = signList.product\n\
    \            val sum = arr.map(x => abs(x)).sum\n            Some(sum * prod)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcsls67ds.scala:26)\n\tat Problem.main(tmpcsls67ds.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            val n = arr.length\n            val s = sum(arr)\n\
    \            val p = product(arr)\n            Some(s * p)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqgdrsttb.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36ms\e[0m = sum(arr)\n\e\
    [31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m             \
    \       Not found: sum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqgdrsttb.scala:20:20\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m\
    \ \e[36mp\e[0m = product(arr)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: product\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) {\n            None\n        } else {\n            val prod = arr.map(el\
    \ => el.signum).product\n            val sum = arr.map(el => abs(el)).sum\n  \
    \          Some(sum * prod)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgxf8p6wv.scala:25)\n\tat Problem.main(tmpgxf8p6wv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979998
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var signs = 1\n        var magnitudes = 0\n        for\
    \ (n <- arr) {\n            if (n > 0) signs *= 1\n            else if (n < 0)\
    \ signs *= -1\n            else signs *= 0\n            magnitudes += abs(n.toInt)\n\
    \        }\n        Some(magnitudes * signs)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk5p7k7ad.scala:28)\n\tat Problem.main(tmpk5p7k7ad.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979998
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) {\n            None\n        } else {\n            var prod = 1l.toLong\n\
    \            var sum = 0l.toLong\n            for (x <- arr) {\n             \
    \   prod *= x.signum\n                sum += x.abs\n            }\n          \
    \  Some(sum * prod)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbyigzbbe.scala:29)\n\tat Problem.main(tmpbyigzbbe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Your Code\
    \ Here\n        if (arr.length == 0) return None\n        var nums = List[Int]()\n\
    \        for (num <- arr) {\n        \tif (num == 0) nums = nums :+ 0\n      \
    \  \telse if (num > 0) nums = nums :+ 1\n        \telse nums = nums :+ -1\n  \
    \      }\n        var prod = 1\n        for (num <- nums) {\n        \tprod *=\
    \ num\n        }\n        var sum = 0\n        for (num <- arr) {\n        \t\
    sum += abs(num)\n        }\n        return Some(sum * prod)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphr58x99p.scala:30:12 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \tsum += abs(num)\n\e[31m\e[31m   |\e[0m    \
    \    \t^^^^^^\e[0m\n\e[31m   |\e[0m        \tvalue += is not a member of Int -\
    \ did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659979997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var x = 1l\n        var s = 0l\n        for (i <-\
    \ arr) {\n            if (i > 0) x *= 1\n            else if (i < 0) x *= -1\n\
    \            else { x = 0; s += 1 }\n            s += abs(i)\n        }\n    \
    \    Some(s * x)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj8k66mge.scala:28)\n\tat Problem.main(tmpj8k66mge.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            val abs_arr = arr.map(abs(_))\n          \
    \  Some(abs_arr.product * arr.map(signum(_)).product)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp78qe3q0h.scala:23)\n\tat Problem.main(tmp78qe3q0h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        return Some(arr.foldLeft(1l)((x, y) => x * y))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc0344g4g.scala:20)\n\tat Problem.main(tmpc0344g4g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979999
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x > 0) 1 else if (x < 0) -1 else 0)\n        val magnitudes = arr.map(x\
    \ => abs(x))\n        if (magnitudes.isEmpty) None else Some(magnitudes.sum *\
    \ signs.product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiihnjngv.scala:21)\n\tat Problem.main(tmpiihnjngv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else {\n            Some(arr.foldLeft(1l.toLong)((sum, n)\
    \ => {\n                if (n < 0) -abs(n) + sum\n                else if (n >\
    \ 0) abs(n) + sum\n                else sum\n            }))\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnsms45ka.scala:26)\n\tat Problem.main(tmpnsms45ka.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var prod = 1\n        var sum = 0\n        for (x <- arr)\
    \ {\n            prod *= (if (x > 0) 1 else if (x < 0) -1 else 0)\n          \
    \  sum += abs(x.toInt)\n        }\n        return Some(sum * prod)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsgsvjryn.scala:26)\n\tat Problem.main(tmpsgsvjryn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val N = arr.length\n\
    \        if (N == 0) None\n        else {\n            var prod = 1l\n       \
    \     var sum = 0l\n            for (i <- 0 until N) {\n                val x\
    \ = arr(i)\n                if (x < 0) prod *= -1\n                else if (x\
    \ == 0) prod = 0\n                sum += abs(x)\n            }\n            Some(sum\
    \ * prod)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplkj_drlb.scala:31)\n\tat Problem.main(tmplkj_drlb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signArr =\
    \ arr.map(x => if (x == 0) 0 else if (x > 0) 1 else -1)\n        if (signArr.size\
    \ > 0) {\n            val res = signArr.foldLeft(1)((res, x) => res * x)\n   \
    \         val magnitudes = arr.map(x => if (x < 0) -x else x)\n            Some(magnitudes.foldLeft(0l)((res,\
    \ x) => res + x) * res)\n        } else {\n            None\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpykdootv1.scala:26)\n\tat Problem.main(tmpykdootv1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980001
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        return if (arr.isEmpty)\
    \ None else Some(arr.map(x => if (x == 0) 0 else if (x > 0) 1 else -1).product\
    \ * arr.map(x => abs(x)).sum)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpytw5wmyw.scala:19)\n\tat Problem.main(tmpytw5wmyw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980001
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var prod = 0l.toLong\n        var sum = 0l.toLong\n\
    \        for (x <- arr) {\n            prod *= if (x == 0) 0 else if (x > 0) 1\
    \ else -1\n            sum += abs(x)\n        }\n        return Some(sum * prod)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl86peelz.scala:20:20 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            prod *= \e[33mif\e[0m (x == \e[31m0\e[0m)\
    \ \e[31m0\e[0m \e[33melse\e[0m \e[33mif\e[0m (x > \e[31m0\e[0m) \e[31m1\e[0m \e\
    [33melse\e[0m -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^\e[0m\n\
    \e[31m   |\e[0m                    expression expected but \e[31mif\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl86peelz.scala:20:17\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            prod *= \e[33mif\e\
    [0m (x == \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m \e[33mif\e[0m (x > \e[31m0\e\
    [0m) \e[31m1\e[0m \e[33melse\e[0m -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of Long\
    \ - did you mean Long.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659979999
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else {\n            var temp = 1l\n            for (x <-\
    \ arr) {\n                if (x == 0) temp = 0\n                else if (x < 0)\
    \ temp *= -1\n            }\n            var sum = 0l\n            for (x <- arr)\
    \ {\n                if (x != 0) sum += abs(x)\n            }\n            Some(sum\
    \ * temp)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppgflgp9_.scala:31)\n\tat Problem.main(tmppgflgp9_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var ans = 1l.toLong\n        for (i <- arr) ans *= i\n\
    \        Some(ans)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoh2k4fgx.scala:22)\n\tat Problem.main(tmpoh2k4fgx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980001
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.product\n        product match {\n            case 0 => Some(0)\n      \
    \      case _ => Some(arr.map(abs(_)).sum * product)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgswwvd4d.scala:23)\n\tat Problem.main(tmpgswwvd4d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sgn_magnitude\
    \ = 0\n        for (i <- arr) {\n            val sign =\n                if (i\
    \ > 0) 1\n                else if (i < 0) -1\n                else 0\n       \
    \     val magnitude = abs(i)\n            sgn_magnitude += sign * magnitude\n\
    \        }\n        if (arr.length > 0) Some(sgn_magnitude)\n        else None\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcd_8382a.scala:23:26 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sgn_magnitude += sign * magnitude\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659980001
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr match {\n\
    \            case List() => None\n            case _ => {\n                var\
    \ sign = 1\n                var sum = 0\n                for (i <- arr) {\n  \
    \                  if (i > 0) {\n                        sign *= 1\n         \
    \               sum += i\n                    } else if (i < 0) {\n          \
    \              sign *= -1\n                        sum += -i\n               \
    \     } else {\n                        sign *= 0\n                    }\n   \
    \             }\n                Some(sum * sign)\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn12lgyde.scala:24:28 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                        sum += i\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^\e[0m\n\e[31m   |\e[0m                  value\
    \ += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpn12lgyde.scala:27:28 ------------------------\e[0m\e[0m\n\
    \e[31m27 |\e[0m                        sum += -i\n\e[31m\e[31m   |\e[0m      \
    \                  ^^^^^^\e[0m\n\e[31m   |\e[0m                  value += is not\
    \ a member of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659980002
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else Some(arr.map(x => x.abs).product * arr.filter(x =>\
    \ x != 0l).map(x => signum(x)).product)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvleyvk3m.scala:20)\n\tat Problem.main(tmpvleyvk3m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980004
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            var sum = 0l\n          \
    \  var prod = 1l\n            for (x <- arr) {\n                if (x == 0) sum\
    \ += 1\n                else if (x > 0) sum += x\n                else sum -=\
    \ x\n                prod *= scala.math.signum(x)\n            }\n           \
    \ Some(sum * prod)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg1vrv0cc.scala:31)\n\tat Problem.main(tmpg1vrv0cc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980005
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var p = 1l\n        var s = 0l\n        for (i <- arr)\
    \ {\n            if (i > 0) p *= 1\n            else if (i < 0) p *= -1\n    \
    \        s += abs(i)\n        }\n        return Some(p * s)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmbvxe04g.scala:27)\n\tat Problem.main(tmpmbvxe04g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980007
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // your code\
    \ here\n        None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0bbjgxa0.scala:20)\n\tat Problem.main(tmp0bbjgxa0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980008
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Your code\
    \ here\n        var mul = 1l\n        var sum = 0l\n        for (i <- arr) {\n\
    \            if (i == 0) {\n                return None\n            }\n     \
    \       else if (i > 0) {\n                mul *= 1\n                sum += i\n\
    \            }\n            else {\n                mul *= -1\n              \
    \  sum += (-i)\n            }\n        }\n        Some(mul * sum)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5zsy82ci.scala:35)\n\tat Problem.main(tmp5zsy82ci.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980009
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      if (arr.isEmpty)\
    \ None\n      else Some(arr.map(v => (abs(v) * (if (v == 0) 0 else signum(v)))).reduce(_\
    \ + _))\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9tk8irv_.scala:20)\n\tat Problem.main(tmp9tk8irv_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n\t\tvar prod = arr.foldLeft(1l)((acc,\
    \ x) => {\n\t\t\tif (x == 0) {\n\t\t\t\t0\n\t\t\t} else {\n\t\t\t\tif (x > 0)\
    \ acc * 1 else acc * -1\n\t\t\t}\n\t\t})\n\t\tvar smag = arr.foldLeft(0l)((acc,\
    \ x) => {\n\t\t\tif (x != 0) {\n\t\t\t\tacc + x.abs\n\t\t\t} else {\n\t\t\t\t\
    acc\n\t\t\t}\n\t\t})\n\t\tif (prod == 0) None else Some(smag * prod)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp_bu_m2n7.scala:31:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 2 tabs\n\e[31m   |\e[0m   Latest indent   :\
    \ 4 spaces\n1 error found\n"
  stdout: ''
  timestamp: 1659980005
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else {\n            var sum = 0l\n            var product\
    \ = 1l\n            for (i <- arr) {\n                if (i == 0) product *= 0\n\
    \                else {\n                    sum += abs(i)\n                 \
    \   product *= abs(i) / i\n                }\n            }\n            Some(sum\
    \ * product)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcwj0h6b1.scala:31)\n\tat Problem.main(tmpcwj0h6b1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980010
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            val signs = arr.map(x =>\
    \ if (x > 0) 1 else if (x < 0) -1 else 0)\n            val magnitudes = arr.map(x\
    \ => if (x > 0) x else if (x < 0) -x else 0)\n            Some(magnitudes.product\
    \ * signs.product)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2gvv3dw0.scala:25)\n\tat Problem.main(tmp2gvv3dw0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980010
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val res = if\
    \ (arr.isEmpty) {\n            None\n        } else {\n            val sum = arr.map(abs(_)).sum\n\
    \            val prod = arr.filter(_ != 0).map(signum(_)).product\n          \
    \  Some(sum * prod)\n        }\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphohkw7js.scala:26)\n\tat Problem.main(tmphohkw7js.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      // Fill-in here\n\
    \      None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprh4u5c7_.scala:20)\n\tat Problem.main(tmprh4u5c7_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980010
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var result : Long = 1\n        var ans : Long = 0\n   \
    \     for (x <- arr) {\n            if (x == 0) {\n                result = 0\n\
    \                ans = 0\n            } else if (x > 0) {\n                ans\
    \ += x\n            } else {\n                ans += (-x)\n                result\
    \ *= -1\n            }\n        }\n        if (result == 0) return Some(0)\n \
    \       return Some(ans * result)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpraez7wax.scala:34)\n\tat Problem.main(tmpraez7wax.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) {\n            None\n        } else {\n            var signProduct = 1l.toLong\n\
    \            var sumMagnitudes = 0l.toLong\n            for (i <- arr) {\n   \
    \             val sign = i match {\n                    case n if n < 0 => -1\n\
    \                    case n if n > 0 => 1\n                    case n if n ==\
    \ 0 => 0\n                }\n                signProduct *= sign\n           \
    \     sumMagnitudes += abs(i)\n            }\n            Some(sumMagnitudes *\
    \ signProduct)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo97y_7_c.scala:34)\n\tat Problem.main(tmpo97y_7_c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980012
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        var signProduct = 1l\n        var magnitudeSum =\
    \ 0l\n        for (x <- arr) {\n            val sign = if (x == 0) 0 else if (x\
    \ > 0) 1 else -1\n            signProduct *= sign\n            magnitudeSum +=\
    \ x.abs\n        }\n        return Some(signProduct * magnitudeSum)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw01v231p.scala:27)\n\tat Problem.main(tmpw01v231p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980012
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      if (arr.isEmpty)\
    \ return None\n      var sum = 0l\n      for (n <- arr) {\n        if (n < 0)\
    \ sum += -n\n        else if (n > 0) sum += n\n      }\n      var prod = 1l\n\
    \      for (n <- arr) {\n        if (n < 0) prod *= -1\n        else if (n > 0)\
    \ prod *= 1\n      }\n      sum * prod\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp49m6mtzi.scala:27:6\
    \ ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m      sum * prod\n\e[31m\e[31m\
    \   |\e[0m      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      Found:    Long\n\e[31m \
    \  |\e[0m      Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980011
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) {\n            None\n        } else {\n            var ans = 0l\n    \
    \        for (x <- arr) {\n                var y = x\n                if (y >\
    \ 0) {\n                    ans += y\n                } else if (y < 0) {\n  \
    \                  ans -= y\n                }\n            }\n            var\
    \ p = 1\n            for (x <- arr) {\n                var y = x\n           \
    \     if (y != 0) {\n                    p *= x / abs(x)\n                }\n\
    \            }\n            ans *= p\n            Some(ans)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0p94_qv1.scala:32:22 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    p *= x / abs(x)\n\e[31m\e[31m   |\e\
    [0m                    ^^^^\e[0m\n\e[31m   |\e[0m                  value *= is\
    \ not a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659980010
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        else {\n            val magnitudes = arr.map(abs(_))\n\
    \            val signs = arr.map(x => if (x == 0) 0 else if (x > 0) 1 else -1)\n\
    \            val magnitudeProduct = magnitudes.reduce(_ * _)\n            val\
    \ signProduct = signs.reduce(_ * _)\n            return Some(magnitudeProduct\
    \ * signProduct)\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvf2z4m61.scala:26)\n\tat Problem.main(tmpvf2z4m61.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            var sign = 0l\n            var mag = 0l\n\
    \            for (i <- arr) {\n                if (i < 0) sign -= 1\n        \
    \        else if (i > 0) sign += 1\n                mag += abs(i)\n          \
    \  }\n            if (sign == 0) Some(0)\n            else Some(sign * mag)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdls355nu.scala:30)\n\tat Problem.main(tmpdls355nu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980012
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else Some(arr.map(x => if (x == 0) 0 else x / abs(x.toDouble)).product\
    \ * arr.map(x => abs(x)).sum)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqr34pisv.scala:17:18\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m Some(arr.map(x\
    \ => \e[33mif\e[0m (x == \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m x / abs(x.toDouble)).product\
    \ * arr.map(x => abs(x)).sum)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Found:    Double\n\e[31m   |\e[0m      \
    \            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      if (arr.isEmpty)\
    \ None\n      else {\n        var prod = 1l\n        var sum = 0l\n        for\
    \ (i <- arr) {\n          prod *= i / abs(i)\n          sum += abs(i)\n      \
    \  }\n        Some(sum * prod)\n      }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz5y1ddx3.scala:28)\n\tat Problem.main(tmpz5y1ddx3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980013
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        val sign = arr.map(abs(_)).product\n        var prod\
    \ = 1l\n        for (i <- arr) {\n            i match {\n                case\
    \ x if x > 0 => prod *= 1\n                case x if x < 0 => prod *= -1\n   \
    \             case _ => prod *= 0\n            }\n        }\n        return Some(sign\
    \ * prod)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptp9cza2f.scala:29)\n\tat Problem.main(tmptp9cza2f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980012
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        val result = arr.map(a => if (a < 0) -1 else if (a > 0)\
    \ 1 else 0).foldLeft(1)((a, b) => a * b)\n        return Some(arr.map(a => if\
    \ (a == 0) 0 else if (a < 0) -a else a).sum * result)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvac59phd.scala:21)\n\tat Problem.main(tmpvac59phd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980013
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) None\n        else {\n            var prod = 1\n            var sum =\
    \ 0\n            for (e <- arr) {\n                sum += e.abs\n            \
    \    if (e > 0) prod *= 1\n                else if (e < 0) prod *= -1\n      \
    \          else prod *= 0\n            }\n            Some(sum * prod)\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprquwzz98.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                sum += e.abs\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not a\
    \ member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659980012
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            var prod = 1l\n         \
    \   var sum = 0l\n            for (i <- arr) {\n                if (i > 0) {\n\
    \                    prod *= 1\n                    sum += i\n               \
    \ } else if (i < 0) {\n                    prod *= -1\n                    sum\
    \ += -i\n                } else {\n                    sum += 0\n            \
    \    }\n            }\n            Option(sum * prod)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpngl_imvf.scala:36)\n\tat Problem.main(tmpngl_imvf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980015
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val sign = (x\
    \ : Long) => if (x == 0) 0 else if (x > 0) 1 else -1\n        val zeroCount =\
    \ arr.filter(_ == 0).length\n        if (zeroCount > 0) return Some(0)\n     \
    \   val list = arr.map(abs(_)).map(sign(_))\n        Some(list.product * list.sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp53oh_lm0.scala:23)\n\tat Problem.main(tmp53oh_lm0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        //if (arr.isEmpty)\
    \ return None\n        var sign = 1\n        var sum = 0\n        for (i <- arr)\
    \ {\n            if (i < 0) sign *= -1\n            sum += abs(i)\n        }\n\
    \        if (arr.isEmpty) None\n        else Some(sum * sign)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy02gfixv.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += abs(i)\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int\
    \ - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659980014
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) return None\n        val p = arr.map(e => if (e < 0) -1 else if (e > 0)\
    \ 1 else 0).product\n        val s = arr.map(e => abs(e)).sum\n        Some(p\
    \ * s)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv3d0xjl6.scala:22)\n\tat Problem.main(tmpv3d0xjl6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980017
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Implementation\
    \ here.\n        if (arr.isEmpty) return None\n        else {\n            val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n            val\
    \ magnitudes = arr.map(x => abs(x))\n            Some(magnitudes.foldLeft(1l)(_\
    \ * _) * signs.foldLeft(1l)(_ * _))\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp2whp30m.scala:25)\n\tat Problem.main(tmpp2whp30m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980017
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        var a = 1l\n        var x = 1l\n        for (i <- arr)\
    \ {\n            x *= i.abs\n            if (i != 0) a *= i.signum\n        }\n\
    \        Some(x * a)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdn3k96zd.scala:26)\n\tat Problem.main(tmpdn3k96zd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980017
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Write your\
    \ code here\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq0td3a4x.scala:15:53\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m    \e[33mdef\e[0m \e[36mprodSigns\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mOption\e[0m[\e\
    [35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m                                    \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \              Found:    Unit\n\e[31m   |\e[0m                               \
    \                   Required: Option[Long]\n\e[31m16 |\e[0m        \e[34m// Write\
    \ your code here\e[0m\n\e[31m17 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980016
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            val sumMagnitudes = arr.map(x\
    \ => x.abs).sum\n            val productSigns = arr.foldLeft(1l)((accum, x) =>\
    \ accum * (if (x < 0) -1 else if (x > 0) 1 else 0))\n            Some(sumMagnitudes\
    \ * productSigns)\n        }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp5bd7v6i.scala:25)\n\tat Problem.main(tmpp5bd7v6i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980018
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Good luck!\
    \ Add any helper functions you may need.\n        def mult(product : Long, list\
    \ : List[Long]) : Long = {\n            if (list.isEmpty) product\n          \
    \  else if (list.head > 0) mult(product, list.tail)\n            else if (list.head\
    \ < 0) mult(product * (-1), list.tail)\n            else mult(0, list.tail)\n\
    \        }\n        if (arr.isEmpty) None\n        else Some(arr.map(abs(_)).sum\
    \ * mult(1, arr))\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcn70khnj.scala:27)\n\tat Problem.main(tmpcn70khnj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980018
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Your Solution\
    \ Here\n        if (arr.isEmpty) None\n        else Some(arr.map(abs(_)).sum *\
    \ arr.map(signum(_)).product)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps5n3u5lt.scala:21)\n\tat Problem.main(tmps5n3u5lt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980018
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0) {\n            None\n        } else {\n            var sum = 0.toLong\n\
    \            var prod = 1.toLong\n            for (i <- arr) {\n             \
    \   sum += abs(i)\n                prod *= i.signum\n            }\n         \
    \   Some(sum * prod)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfci2mb9g.scala:29)\n\tat Problem.main(tmpfci2mb9g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980018
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            var sum = 0l\n          \
    \  var prod = 1l\n            for (i <- arr) {\n                if (i > 0) {\n\
    \                    sum += i\n                    prod *= 1\n               \
    \ } else if (i < 0) {\n                    sum += (-i)\n                    prod\
    \ *= (-1)\n                } else {\n                    sum += 0\n          \
    \          prod *= 0\n                }\n            }\n            Some(sum *\
    \ prod)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9r1s58dh.scala:37)\n\tat Problem.main(tmp9r1s58dh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980018
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var mul = 1\n\
    \        var sum = 0\n        for (x <- arr) {\n            if (x > 0) {\n   \
    \             mul *= 1\n                sum += x\n            } else if (x < 0)\
    \ {\n                mul *= -1\n                sum += -x\n            } else\
    \ {\n                mul *= 0\n            }\n        }\n        if (arr.length\
    \ > 0) {\n            return Some(mul * sum)\n        } else {\n            return\
    \ None\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprh80mbal.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                sum += x\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not a member\
    \ of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprh80mbal.scala:24:20\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                sum += -x\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \    value += is not a member of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659980017
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val arr2 = arr.map(x\
    \ => if (x > 0) 1 else if (x < 0) -1 else 0)\n        val prod = arr2.foldLeft(1)(_\
    \ * _)\n        if (prod == 0) return None\n        else {\n            val sum\
    \ = arr.foldLeft(0l)(_ + abs(_))\n            return Some(sum * prod)\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_7a9n7wq.scala:25)\n\tat Problem.main(tmp_7a9n7wq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980018
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val res = arr.foldLeft((1l,\
    \ 0l))((t, i) => if (i == 0) (0l, 0l) else (t._1 * i.signum, t._2 + i.abs))\n\
    \        if (res._1 == 0) None else Some(res._1 * res._2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpecuz9jyv.scala:20)\n\tat Problem.main(tmpecuz9jyv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980018
