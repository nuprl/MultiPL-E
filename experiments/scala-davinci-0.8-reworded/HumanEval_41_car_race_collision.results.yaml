language: scala
name: HumanEval_41_car_race_collision
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val m = n.toInt\n    \
    \    val a = (1 to m).toArray\n        val b = a.map(2 * _)\n        val c = (1\
    \ to m).toArray.map(i => (1 to m).toArray.map(j => (i + j).toLong))\n        val\
    \ d = c.map(a => a.map(2 * _))\n        //val e = (1 to m).toArray.map(i => (1\
    \ to m).toArray.map(j => (i + j).toLong))\n        //val f = e.map(a => a.map(2\
    \ * _))\n        val g = c.map(a => a.map(1 + _))\n        val h = g.map(a =>\
    \ a.map(2 * _))\n        //val i = e.map(a => a.map(1 + _))\n        //val j =\
    \ i.map(a => a.map(2 * _))\n        val k = (1 to m).toArray.map(i => (1 to m).toArray.map(j\
    \ => (i + j - 1).toLong))\n        val l = k.map(a => a.map(2 * _))\n        //val\
    \ m = (1 to n).toArray.map(i => (1 to n).toArray.map(j => (i + j - 1).toLong))\n\
    \        //val n = m.map(a => a.map(2 * _))\n        val o = c.map(a => a.map(i\
    \ => (1 to i).sum))\n        val p = o.map(a => a.map(2 * _))\n        //val q\
    \ = e.map(a => a.map(i => (1 to i).sum))\n        //val r = q.map(a => a.map(2\
    \ * _))\n        val s = k.map(a => a.map(i => (1 to i).sum))\n        val t =\
    \ s.map(a => a.map(2 * _))\n        //val u = m.map(a => a.map(i => (1 to i).sum))\n\
    \        //val v = u.map(a =>\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjblz60aq.scala:28:44\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mo\e\
    [0m = c.map(\e[36ma\e[0m => a.map(\e[36mi\e[0m => (\e[31m1\e[0m to i).sum))\n\e\
    [31m\e[31m   |\e[0m                                            ^\e[0m\n\e[31m\
    \   |\e[0m                                            Found:    (i : Long)\n\e\
    [31m   |\e[0m                                            Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjblz60aq.scala:32:44 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = k.map(\e[36ma\e\
    [0m => a.map(\e[36mi\e[0m => (\e[31m1\e[0m to i).sum))\n\e[31m\e[31m   |\e[0m\
    \                                            ^\e[0m\n\e[31m   |\e[0m         \
    \                                   Found:    (i : Long)\n\e[31m   |\e[0m    \
    \                                        Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpjblz60aq.scala:36:5 ---------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659821436
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's assume n cars\
    \ are driving left to right, and the others are driving right to left.\n     \
    \   // Let's assume the n cars driving left to right are indexed by i, and the\
    \ cars driving right to left\n        // are indexed by j.\n        // Car i moves\
    \ at speed i, and car j moves at speed j.\n        // Car i and car j collide\
    \ if i + j = n + 1.\n        // How many pairs (i, j) satisfy i + j = n + 1?\n\
    \        // This can be computed by the formula (n + 1) * n / 2.\n        val\
    \ result = (n + 1) * n / 2\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_73h8126.scala:24)\n\tat Problem.main(tmp_73h8126.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val leftToRight = Array.fill(n.toInt)(0)\n\
    \        val rightToLeft = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ {\n            leftToRight(i) = i + 1\n            rightToLeft(i) = n - i\n\
    \        }\n        var res = 0L\n        for (i <- 0 until n.toInt) {\n     \
    \       for (j <- 0 until n.toInt) {\n                if (leftToRight(i) == rightToLeft(j))\
    \ res += 1\n            }\n        }\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8pyc3fkk.scala:17:29\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            rightToLeft(i) =\
    \ n - i\n\e[31m\e[31m   |\e[0m                             ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Found:    Long\n\e[31m   |\e[0m       \
    \                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // assume n is positive\n\
    \        // assume n is small enough so that we do not have to worry about arithmetic\
    \ overflow\n        val n2 = (n * n).toLong\n        val factor = 4 * n2 - 2 *\
    \ n + 1\n        val sum = (1 to n.toInt).map(i => {\n            val diff = n\
    \ - i\n            diff * (n2 - (i * i))\n        }).sum\n        factor * sum\
    \ / 24\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa_x1z7eq.scala:24)\n\tat Problem.main(tmpa_x1z7eq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821436
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Create a max heap of\
    \ the positions of the cars moving left to right.\n        // Create a min heap\
    \ of the positions of the cars moving right to left.\n        // Keep removing\
    \ the maximum number from the left heap and the minimum number\n        // from\
    \ the right heap, and calculate their distances.  If the distances are\n     \
    \   // the same, then we found a collision.  Keep doing this until we remove all\n\
    \        // elements from the heaps.\n        var l = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        var r = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for\
    \ (i <- 1 to n.toInt) {\n            l.+=(i)\n            r.+=(i)\n        }\n\
    \        var ans = 0L\n        while (!l.isEmpty && !r.isEmpty) {\n          \
    \  val lx = l.dequeue\n            val rx = r.dequeue\n            if (lx == rx)\
    \ ans += 1\n        }\n        ans\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2cri64ig.scala:34)\n\tat Problem.main(tmp2cri64ig.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821436
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var collision = 0L\n \
    \       for (i <- 1L to n) {\n            if (n % i == 0) {\n                collision\
    \ += i - 1\n            }\n        }\n        collision\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8g16870v.scala:22)\n\tat Problem.main(tmp8g16870v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821436
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        /*\n        if (n <= 2)\
    \ return 0\n        val speed = n.toLong\n        val leftToRightDistances = List.fill(n.toInt)(speed)\n\
    \        val rightToLeftDistances = List.fill(n.toInt)(speed)\n        val t =\
    \ leftToRightDistances.zip(rightToLeftDistances).map(x => {\n            val leftDist\
    \ = x._1\n            val rightDist = x._2\n            min(leftDist, rightDist)\n\
    \        }).max\n        val x = leftToRightDistances.map(x => x - t).count(x\
    \ => x == 0)\n        val y = rightToLeftDistances.map(x => x - t).count(x =>\
    \ x == 0)\n        x + y\n        */\n        val speed = n.toLong\n        val\
    \ t = n\n        val x = n - t\n        if (x == 0) return n\n        val y =\
    \ n - t\n        if (y == 0) return n\n        2 * n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa_yitqbf.scala:36)\n\tat Problem.main(tmpa_yitqbf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // perform an n log n\
    \ solution by sorting.\n        val cars = new Array[Long](2 * n.toInt)\n    \
    \    for (i <- 0 until n.toInt) {\n            cars(i) = i.toLong + 1\n      \
    \      cars(i + n.toInt) = -(i.toLong + 1)\n        }\n        cars.sortWith((a,\
    \ b) => abs(a) < abs(b))\n        var answer = 0L\n        var carIndex = 0\n\
    \        while (carIndex < 2 * n.toInt) {\n            if (cars(carIndex) > 0)\
    \ {\n                var car = cars(carIndex)\n                while (carIndex\
    \ < 2 * n.toInt && cars(carIndex) == car) {\n                    carIndex += 1\n\
    \                }\n                answer += (carIndex - car).toLong\n      \
    \      } else {\n                carIndex += 1\n            }\n        }\n   \
    \     answer\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpap7xhyn6.scala:36)\n\tat Problem.main(tmpap7xhyn6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821436
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        /*\n        // greedy\
    \ brute force algorithm from the left to right, runs in O(n^2).\n        // assumes\
    \ that each car speed is a positive integer.\n        val map = HashMap[Long,\
    \ Long]()\n        for (i <- 1 to n.toInt) {\n            val speed = i\n    \
    \        var t = i\n            var collisions = 0\n            while (t <= n)\
    \ {\n                if (map.contains(t)) {\n                    collisions +=\
    \ map(t)\n                }\n                t += speed\n            }\n     \
    \       map(speed) = collisions\n        }\n        map.values.sum\n        */\n\
    \        /*\n        // below is the solution posted on project euler discussion.\n\
    \        // i don't know why the average function below works.\n        // if\
    \ we choose i = 1, 2, 3, ..., n and j = 1, 2, 3, ..., n,\n        // then i can\
    \ hit j when i < j and they have the same speed.\n        // Thus, we can choose\
    \ i from 1 to n, and calculate how many j can be hit by i.\n        // that's\
    \ the below solution. \n        def average(a : Long, b : Long) : Long = (a +\
    \ b) / 2\n        var result = 0L\n        for (i <- 1 to n.toInt) {\n       \
    \     val speed = i\n            result += (average(1, n) - average(n + 1 - i,\
    \ i)) * speed\n        }\n        result\n        */\n        // The above solution\
    \ assumes that the speed is an integer.\n        // The solution below does not\
    \ make this assumption.\n        // i can hit j when i < j and they have the same\
    \ speed.\n        // it's easier to calculate how many cars can be hit by car\
    \ i.\n        // when car i move from t = 0 to t = n, how many j are hit by i?\n\
    \        // car i is hit by j if and only if car j is traveling at the same speed.\n\
    \        // so, how many cars are driving left to right at the same speed?\n \
    \       // we can represent the trajectory of car i as a function f(t) = speed\
    \ * t.\n        // if the speed is an integer, we can represent the trajectory\
    \ by g(t) = floor\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe9bgp_4k.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m/*\n\e[31m14 |\e[0m        // greedy brute force algorithm from the left to\
    \ right, runs in O(n^2).\n\e[31m15 |\e[0m        // assumes that each car speed\
    \ is a positive integer.\n\e[31m16 |\e[0m        val map = HashMap[Long, Long]()\n\
    \e[31m17 |\e[0m        for (i <- 1 to n.toInt) {\n\e[31m18 |\e[0m            val\
    \ speed = i\n\e[31m19 |\e[0m            var t = i\n\e[31m20 |\e[0m           \
    \ var collisions = 0\n\e[31m21 |\e[0m            while (t <= n) {\n\e[31m22 |\e\
    [0m                if (map.contains(t)) {\n\e[31m23 |\e[0m                   \
    \ collisions += map(t)\n\e[31m24 |\e[0m                }\n\e[31m25 |\e[0m    \
    \            t += speed\n\e[31m26 |\e[0m            }\n\e[31m27 |\e[0m       \
    \     map(speed) = collisions\n\e[31m28 |\e[0m        }\n\e[31m29 |\e[0m     \
    \   map.values.sum\n\e[31m30 |\e[0m        */\e[0m\n\e[31m31 |\e[0m        \e\
    [34m/*\n\e[31m32 |\e[0m        // below is the solution posted on project euler\
    \ discussion.\n\e[31m33 |\e[0m        // i don't know why the average function\
    \ below works.\n\e[31m34 |\e[0m        // if we choose i = 1, 2, 3, ..., n and\
    \ j = 1, 2, 3, ..., n,\n\e[31m35 |\e[0m        // then i can hit j when i < j\
    \ and they have the same speed.\n\e[31m36 |\e[0m        // Thus, we can choose\
    \ i from 1 to n, and calculate how many j can be hit by i.\n\e[31m37 |\e[0m  \
    \      // that's the below solution. \n\e[31m38 |\e[0m        def average(a :\
    \ Long, b : Long) : Long = (a + b) / 2\n\e[31m39 |\e[0m        var result = 0L\n\
    \e[31m40 |\e[0m        for (i <- 1 to n.toInt) {\n\e[31m41 |\e[0m            val\
    \ speed = i\n\e[31m42 |\e[0m            result += (average(1, n) - average(n +\
    \ 1 - i, i)) * speed\n\e[31m43 |\e[0m        }\n\e[31m44 |\e[0m        result\n\
    \e["
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Given 2 cars that are\
    \ moving at speeds v1 and v2, and v1 <= v2,\n        // the absolute value of\
    \ their relative velocity is v2 - v1.  (Note\n        // that if v1 > v2, then\
    \ their relative velocity is -(v1 - v2) which is\n        // the same as v2 -\
    \ v1.)\n        // Given that there are n cars moving in each direction, there\
    \ are (n*(n-1))/2\n        // combinations of pairs of cars.\n        // Consider\
    \ a pair of cars that are moving in opposite directions.  Suppose\n        //\
    \ the relative velocity of one is v, and the other is -v.  If v is even,\n   \
    \     // then the cars collide at the time steps when their relative velocity\
    \ is\n        // positive.  If v is odd, then there are two different cases. \
    \ (1) if v = 1,\n        // then the cars collide at the time steps when their\
    \ relative velocity is\n        // positive;  (2) if v >= 3, then the cars do\
    \ not collide.\n        // Therefore, the number of collisions is the sum of the\
    \ absolute value of all\n        // pairs of relative velocities.\n        //\n\
    \        // Note that each pair of cars collide exactly once, except pairs of\
    \ cars with\n        // relative velocity 0.  If we sum up the absolute value\
    \ of all pairs of\n        // relative velocities, we double-count the pairs of\
    \ cars with relative velocity 0.\n        // Therefore, we have to subtract (n*(n-1)/2).\n\
    \        //\n        // Note that the sum of all relative velocities is always\
    \ 0.  Therefore, the\n        // sum of the absolute value of all relative velocities\
    \ is always 0.  Therefore,\n        // we have to subtract (n*(n-1)/2) once more.\n\
    \        //\n        // Therefore, the number of collisions is\n        // (sum\
    \ of the absolute value of all pairs of relative velocities) - (n*(n-1)/2) - (n*(n-1)/2)\n\
    \        // = (sum of the absolute value of all pairs of relative velocities)\
    \ - (n*(n-1))\n        // = (sum of the absolute value of all pairs of relative\
    \ velocities) -\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb13hncvt.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Given 2 cars that are moving at speeds v1 and v2, and v1 <= v2,\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// the absolute value of their relative velocity is\
    \ v2 - v1.  (Note\e[0m\n\e[31m15 |\e[0m        \e[34m// that if v1 > v2, then\
    \ their relative velocity is -(v1 - v2) which is\e[0m\n\e[31m16 |\e[0m       \
    \ \e[34m// the same as v2 - v1.)\e[0m\n\e[31m17 |\e[0m        \e[34m// Given that\
    \ there are n cars moving in each direction, there are (n*(n-1))/2\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// combinations of pairs of cars.\e[0m\n\e[31m19 |\e[0m\
    \        \e[34m// Consider a pair of cars that are moving in opposite directions.\
    \  Suppose\e[0m\n\e[31m20 |\e[0m        \e[34m// the relative velocity of one\
    \ is v, and the other is -v.  If v is even,\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ then the cars collide at the time steps when their relative velocity is\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// positive.  If v is odd, then there are two different\
    \ cases.  (1) if v = 1,\e[0m\n\e[31m23 |\e[0m        \e[34m// then the cars collide\
    \ at the time steps when their relative velocity is\e[0m\n\e[31m24 |\e[0m    \
    \    \e[34m// positive;  (2) if v >= 3, then the cars do not collide.\e[0m\n\e\
    [31m25 |\e[0m        \e[34m// Therefore, the number of collisions is the sum of\
    \ the absolute value of all\e[0m\n\e[31m26 |\e[0m        \e[34m// pairs of relative\
    \ velocities.\e[0m\n\e[31m27 |\e[0m        \e[34m//\e[0m\n\e[31m28 |\e[0m    \
    \    \e[34m// Note that each pair of cars collide exactly once, except pairs of\
    \ cars with\e[0m\n\e[31m29 |\e[0m        \e[34m// relative velocity 0.  If we\
    \ sum up the absolute value of all pairs of\e[0m\n\e[31m30 |\e[0m        \e[34m//\
    \ relative velocities, we double-count the pair"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a greedy problem\
    \ that can be solved with a priority queue.\n        // Assume the cars are numbered\
    \ from 1 to n in both directions.\n        // Define class Car which contains\
    \ the car number and its x-position (i.e. left/right distance\n        // from\
    \ the starting point).  Define a priority queue, sorted by the x-position of the\
    \ car.\n        // Initially, add all n cars from both directions, starting with\
    \ car 1, then car 2, ... , then car n.\n        // Then, whenever a car A collides\
    \ with a car B, remove the car with the smaller number (to avoid double counting).\n\
    \        // Repeat this until the queue is empty.\n        val q = new PriorityQueue[Car]()(new\
    \ CarOrdering())\n        for (i <- 1 to n.toInt) {\n            q.enqueue(new\
    \ Car(i, i))\n            q.enqueue(new Car(i, -i))\n        }\n        var count\
    \ = 0\n        while (!q.isEmpty) {\n            val curr = q.dequeue\n      \
    \      val next = q.dequeue\n            if (curr.num > next.num) q.enqueue(curr)\n\
    \            else if (curr.num < next.num) q.enqueue(next)\n            else count\
    \ += 1\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa2jccpif.scala:20:34 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = \e[33mnew\e[0m\
    \ \e[35mPriorityQueue\e[0m[\e[35mCar\e[0m]()(\e[33mnew\e[0m \e[35mCarOrdering\e\
    [0m())\n\e[31m\e[31m   |\e[0m                                  ^^^\e[0m\n\e[31m\
    \   |\e[0m                                  Not found: type Car\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa2jccpif.scala:20:45 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = \e[33mnew\e[0m\
    \ \e[35mPriorityQueue\e[0m[\e[35mCar\e[0m]()(\e[33mnew\e[0m \e[35mCarOrdering\e\
    [0m())\n\e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Not found: type\
    \ CarOrdering\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa2jccpif.scala:22:26\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            q.enqueue(\e\
    [33mnew\e[0m \e[35mCar\e[0m(i, i))\n\e[31m\e[31m   |\e[0m                    \
    \      ^^^\e[0m\n\e[31m   |\e[0m                          Not found: type Car\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa2jccpif.scala:23:26\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            q.enqueue(\e\
    [33mnew\e[0m \e[35mCar\e[0m(i, -i))\n\e[31m\e[31m   |\e[0m                   \
    \       ^^^\e[0m\n\e[31m   |\e[0m                          Not found: type Car\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        return 2 * n - 1\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ilv751_.scala:16)\n\tat Problem.main(tmp5ilv751_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is that the\
    \ number of collisions is just n * n\n        // However, n * n is too big for\
    \ a long value to hold, so \n        // we need to use BigInts instead.\n    \
    \    BigInt(n) * BigInt(n)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l)) ==\
    \ (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprta_ayzj.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        BigInt(n) * BigInt(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    BigInt\n\e[31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        if (n == 0) return 0\n\
    \        val primes = Primes.sieve(n).reverse\n        val sqrt = sqrt(n.toDouble).toLong\n\
    \        val exponents = Array.fill(primes.length)(0L)\n        for (i <- 1 to\
    \ primes.length - 1) {\n            var j = 1\n            var x = pow(primes(i).toDouble,\
    \ j).toLong\n            while (x <= sqrt) {\n                exponents(i) +=\
    \ 1\n                j += 1\n                x = pow(primes(i).toDouble, j).toLong\n\
    \            }\n        }\n        val result = (for (i <- 1 to primes.length\
    \ - 1) yield primes(i) * exponents(i)).sum\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3k4pex6i.scala:14:21 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = Primes.sieve(n).reverse\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \              Not found: Primes\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp3k4pex6i.scala:15:19 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(n.toDouble).toLong\n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   Recursive\
    \ \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmp3k4pex6i.scala:26:91 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = (\e[33mfor\e\
    [0m (i <- \e[31m1\e[0m to primes.length - \e[31m1\e[0m) \e[33myield\e[0m primes(i)\
    \ * exponents(i)).sum\n\e[31m\e[31m   |\e[0m                                 \
    \                                                          ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mFloatIsFractional\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mCharIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter\
    \ num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // simulation\n      \
    \  val leftToRightCars = (1 to n.toInt).map(i => new Car(i)).toList\n        val\
    \ rightToLeftCars = (1 to n.toInt).map(i => new Car(i)).toList\n        val road\
    \ = new Road(leftToRightCars, rightToLeftCars)\n        val simulation = new Simulation(road)\n\
    \        simulation.run\n        simulation.collisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0lhxcmbp.scala:14:58 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mleftToRightCars\e[0m = (\e\
    [31m1\e[0m to n.toInt).map(\e[36mi\e[0m => \e[33mnew\e[0m \e[35mCar\e[0m(i)).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^^^\e[0m\n\e[31m   |\e[0m                                                 \
    \    Not found: type Car\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp0lhxcmbp.scala:15:58 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mrightToLeftCars\e[0m = (\e[31m1\e[0m to n.toInt).map(\e\
    [36mi\e[0m => \e[33mnew\e[0m \e[35mCar\e[0m(i)).toList\n\e[31m\e[31m   |\e[0m\
    \                                                          ^^^\e[0m\n\e[31m  \
    \ |\e[0m                                                     Not found: type Car\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0lhxcmbp.scala:16:23\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mroad\e[0m = \e[33mnew\e[0m \e[35mRoad\e[0m(leftToRightCars, rightToLeftCars)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                Not found: type Road\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp0lhxcmbp.scala:17:29 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msimulation\e[0m = \e[33mnew\e\
    [0m \e[35mSimulation\e[0m(road)\n\e[31m\e[31m   |\e[0m                       \
    \      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ type Simulation\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is that we\
    \ can assume the cars are moving at unit speed;\n        // for each left-to-right\
    \ car, we determine the point at which it collides with\n        // a right-to-left\
    \ car.  We then sort the resulting set of points, and we can\n        // determine\
    \ the number of collisions as the number of consecutive pairs of points.\n   \
    \     // In terms of algorithm, we can do this in linear time using a hash map.\n\
    \        // For each right-to-left car, we put it into the hash map.  For each\
    \ left-to-right\n        // car, we check whether there is a right-to-left car\
    \ that is positioned to the left\n        // of the current left-to-right car;\
    \ if there is, the two will eventually collide.\n        // We then move the left-to-right\
    \ car to the right of the right-to-left car, and\n        // we repeat the check.\
    \  Eventually, the left-to-right car will have passed all\n        // cars that\
    \ have previously been checked.  We then remove it from the hash map\n       \
    \ // to avoid checking it later.\n        val cars = HashMap[Long, Long]()\n \
    \       val points = HashMap[Long, Long]()\n        for (i <- n until n + n) cars(i)\
    \ = i - n\n        for (i <- n until n + n) {\n            var j = i\n       \
    \     var prev = -1L\n            while (true) {\n                if (cars.contains(j))\
    \ {\n                    val diff = prev - cars(j)\n                    if (points.contains(diff))\
    \ points(diff) += 1\n                    else points(diff) = 1\n             \
    \       prev = cars(j)\n                    cars.remove(j)\n                }\n\
    \                else if (cars.contains(j + 1)) {\n                    val diff\
    \ = prev - cars(j + 1)\n                    if (points.contains(diff)) points(diff)\
    \ += 1\n                    else points(diff) = 1\n                    prev =\
    \ cars(j + 1)\n                    cars.remove(j + 1)\n                }\n   \
    \             else break\n                j += 1\n            }\n        }\n \
    \       // now we check whether any two consecutive points, if they exist, differ\
    \ by 1\n       \n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5nhb5b75.scala:46:21 ------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                \e[33melse\e[0m break\n\e[31m\e[31m \
    \  |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Assume cars are indexed\
    \ left to right from 0 to n-1, and right to left from n to 2n-1\n        // If\
    \ all cars move at the same speed, then the collision index is the car's index\n\
    \        // If cars start at distance d, then the time each car takes to reach\
    \ collision point is t\n        // = d / speed\n        // The car's speed is\
    \ then d / t.\n        // To represent this, we can have a function f(x) = d /\
    \ x\n        // Now, the car's speed can be represented as a function, g(i) =\
    \ f(t + i)\n        // where i is the car's index and t is the time taken for\
    \ all cars to reach collision point\n        val f = new Function[Long, Long]\
    \ {\n            def apply(x : Long) = 1000000000 / x\n        }\n        // car\
    \ 0 moves left to right with speed g(0) = f(t)\n        // car 1 moves left to\
    \ right with speed g(1) = f(t + 1)\n        // car n-1 moves left to right with\
    \ speed g(n-1) = f(t + n - 1)\n        // car n moves right to left with speed\
    \ g(n) = f(t)\n        // car n+1 moves right to left with speed g(n+1) = f(t\
    \ + 1)\n        // car 2n-1 moves right to left with speed g(2n-1) = f(t + n -\
    \ 1)\n        // The net result is that the car's speed is represented by the\
    \ function\n        // g(x) = f(t + abs(x - n))\n        val g = new Function[Long,\
    \ Long] {\n            def apply(x : Long) = f(abs(x - n))\n        }\n      \
    \  // To determine the collision index, we want the indexes where g(x) = g(x -\
    \ 1)\n        // For example, consider g(x) = 1 / x\n        // Then, g(x) = g(x\
    \ - 1) is satisfied at x = 3\n        // To find a solution to this, we can make\
    \ use of the intermediate value theorem\n        // Let f(x) = g(x) - g(x - 1)\n\
    \        // We\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2a2z_284.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The intuition of this\
    \ problem is as follows.  Car i is going to collide with car j\n        // if\
    \ and only if car i reaches a point x to the right of car j, and car j reaches\n\
    \        // a point x to the left of car i.  Now, a car can reach point x to the\
    \ right of\n        // car j as soon as t minutes have passed since the start\
    \ of the race, where x\n        // is t times the speed of car i.  By the same\
    \ token, car j will reach point x\n        // to the left of car i as soon as\
    \ s minutes have passed, where x is s times the\n        // speed of car j.\n\
    \        // So we have the following condition for the existence of a collision:\n\
    \        // t * speed(i) = s * speed(j)\n        // Now, since speed(i) != speed(j),\
    \ we can take speed(i) as the independent variable.\n        // We can then take\
    \ s = t * speed(i) / speed(j).  This means that as soon as t minutes\n       \
    \ // have passed since the start of the race, car i reaches a point that's s *\
    \ speed(j)\n        // away from the starting point, which is the place where\
    \ car j is.\n        // Note that we can assume that s * speed(j) = t * speed(i),\
    \ where s, t are integers.\n        // We can then take s = speed(i) * k / gcd(speed(i),\
    \ speed(j)), where k is an integer.\n        // This gives us the following equation:\n\
    \        // t * speed(i) = speed(i) * k / gcd(speed(i), speed(j)) * speed(j)\n\
    \        // Now, let x = gcd(speed(i), speed(j)).  We then have t * speed(i) =\
    \ k * speed(j) / x.\n        // This means that as soon as t minutes have passed\
    \ since the start of the race,\n        // car i is at point k * speed(j) / x,\
    \ which is precisely where car j is.\n        // The trick is to loop through\
    \ all the values of t = 1 to k = speed(i) * speed(j) / x\n        // and check\
    \ whether t * speed(i) = k\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l)) ==\
    \ (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2sqwe5kk.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The intuition of this problem is as follows.  Car i is going to collide\
    \ with car j\e[0m\n\e[31m14 |\e[0m        \e[34m// if and only if car i reaches\
    \ a point x to the right of car j, and car j reaches\e[0m\n\e[31m15 |\e[0m   \
    \     \e[34m// a point x to the left of car i.  Now, a car can reach point x to\
    \ the right of\e[0m\n\e[31m16 |\e[0m        \e[34m// car j as soon as t minutes\
    \ have passed since the start of the race, where x\e[0m\n\e[31m17 |\e[0m     \
    \   \e[34m// is t times the speed of car i.  By the same token, car j will reach\
    \ point x\e[0m\n\e[31m18 |\e[0m        \e[34m// to the left of car i as soon as\
    \ s minutes have passed, where x is s times the\e[0m\n\e[31m19 |\e[0m        \e\
    [34m// speed of car j.\e[0m\n\e[31m20 |\e[0m        \e[34m// So we have the following\
    \ condition for the existence of a collision:\e[0m\n\e[31m21 |\e[0m        \e\
    [34m// t * speed(i) = s * speed(j)\e[0m\n\e[31m22 |\e[0m        \e[34m// Now,\
    \ since speed(i) != speed(j), we can take speed(i) as the independent variable.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// We can then take s = t * speed(i) / speed(j).\
    \  This means that as soon as t minutes\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ have passed since the start of the race, car i reaches a point that's s * speed(j)\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// away from the starting point, which is the\
    \ place where car j is.\e[0m\n\e[31m26 |\e[0m        \e[34m// Note that we can\
    \ assume that s * speed(j) = t * speed(i), where s, t are integers.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// We can then take s = speed(i) * k / gcd(speed(i), speed(j)),\
    \ where k is an integer.\e[0m\n\e[31m28 |\e[0m        \e[34m// This gives us the\
    \ following equation:\e[0m\n\e"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var numCollisions = 0L\n\
    \        var carsLeftToRight = new PriorityQueue[(Long, Long)]()\n        var\
    \ carsRightToLeft = new PriorityQueue[(Long, Long)]()\n        for (i <- 1 to\
    \ n.toInt) {\n            carsLeftToRight.enqueue((i, i))\n            carsRightToLeft.enqueue((-i,\
    \ -i))\n        }\n        var done = false\n        while (!done) {\n       \
    \     val (x, i) = carsLeftToRight.dequeue\n            val (y, j) = carsRightToLeft.dequeue\n\
    \            if (x < -y) {\n                carsLeftToRight.enqueue((x, i))\n\
    \                carsRightToLeft.enqueue((y, j))\n                done = true\n\
    \            } else {\n                numCollisions += 1\n                if\
    \ (i == n) {\n                    done = true\n                } else {\n    \
    \                carsLeftToRight.enqueue((x + 1, i + 1))\n                   \
    \ carsRightToLeft.enqueue((y, j))\n                }\n            }\n        }\n\
    \        numCollisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp51hvej8s.scala:41)\n\tat Problem.main(tmp51hvej8s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821436
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // take the n cars going\
    \ left to right, and sort them by their speed\n        // take the n cars going\
    \ right to left, and sort them by their speed\n        // observe that if two\
    \ cars collide, they must be at the same speed\n        // since there are no\
    \ deceleration, neither car can slow down.\n        // if there are c cars going\
    \ left to right, and c cars going right to left\n        // with equal speed,\
    \ then there will be c^2 collisions.\n        // So we just need to count the\
    \ number of pairs of equal speeds.\n        // now, the number of cars with speed\
    \ 1, 2, 3, 4, 5, ... is n + n/2 + n/3 + n/4 + n/5 + ...\n        // This is a\
    \ geometric series, so we can sum it up using \n        // http://en.wikipedia.org/wiki/Geometric_series#Summation_of_a_geometric_series\n\
    \        var total = 0.0\n        for (i <- 1 to n.toInt) {\n            val nInGroup\
    \ = n / i\n            val nOfGroups = i\n            total += nInGroup * nOfGroups\
    \ * nInGroup\n        }\n        total.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjflvnip7.scala:32)\n\tat Problem.main(tmpjflvnip7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821435
