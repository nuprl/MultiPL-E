language: scala
name: HumanEval_41_car_race_collision
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val m = n.toInt\n    \
    \    val a = (1 to m).toArray\n        val b = a.map(2 * _)\n        val c = (1\
    \ to m).toArray.map(i => (1 to m).toArray.map(j => (i + j).toLong))\n        val\
    \ d = c.map(a => a.map(2 * _))\n        //val e = (1 to m).toArray.map(i => (1\
    \ to m).toArray.map(j => (i + j).toLong))\n        //val f = e.map(a => a.map(2\
    \ * _))\n        val g = c.map(a => a.map(1 + _))\n        val h = g.map(a =>\
    \ a.map(2 * _))\n        //val i = e.map(a => a.map(1 + _))\n        //val j =\
    \ i.map(a => a.map(2 * _))\n        val k = (1 to m).toArray.map(i => (1 to m).toArray.map(j\
    \ => (i + j - 1).toLong))\n        val l = k.map(a => a.map(2 * _))\n        //val\
    \ m = (1 to n).toArray.map(i => (1 to n).toArray.map(j => (i + j - 1).toLong))\n\
    \        //val n = m.map(a => a.map(2 * _))\n        val o = c.map(a => a.map(i\
    \ => (1 to i).sum))\n        val p = o.map(a => a.map(2 * _))\n        //val q\
    \ = e.map(a => a.map(i => (1 to i).sum))\n        //val r = q.map(a => a.map(2\
    \ * _))\n        val s = k.map(a => a.map(i => (1 to i).sum))\n        val t =\
    \ s.map(a => a.map(2 * _))\n        //val u = m.map(a => a.map(i => (1 to i).sum))\n\
    \        //val v = u.map(a =>\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjblz60aq.scala:28:44\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mo\e\
    [0m = c.map(\e[36ma\e[0m => a.map(\e[36mi\e[0m => (\e[31m1\e[0m to i).sum))\n\e\
    [31m\e[31m   |\e[0m                                            ^\e[0m\n\e[31m\
    \   |\e[0m                                            Found:    (i : Long)\n\e\
    [31m   |\e[0m                                            Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjblz60aq.scala:32:44 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = k.map(\e[36ma\e\
    [0m => a.map(\e[36mi\e[0m => (\e[31m1\e[0m to i).sum))\n\e[31m\e[31m   |\e[0m\
    \                                            ^\e[0m\n\e[31m   |\e[0m         \
    \                                   Found:    (i : Long)\n\e[31m   |\e[0m    \
    \                                        Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpjblz60aq.scala:36:5 ---------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659821436
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's assume n cars\
    \ are driving left to right, and the others are driving right to left.\n     \
    \   // Let's assume the n cars driving left to right are indexed by i, and the\
    \ cars driving right to left\n        // are indexed by j.\n        // Car i moves\
    \ at speed i, and car j moves at speed j.\n        // Car i and car j collide\
    \ if i + j = n + 1.\n        // How many pairs (i, j) satisfy i + j = n + 1?\n\
    \        // This can be computed by the formula (n + 1) * n / 2.\n        val\
    \ result = (n + 1) * n / 2\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_73h8126.scala:24)\n\tat Problem.main(tmp_73h8126.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val leftToRight = Array.fill(n.toInt)(0)\n\
    \        val rightToLeft = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ {\n            leftToRight(i) = i + 1\n            rightToLeft(i) = n - i\n\
    \        }\n        var res = 0L\n        for (i <- 0 until n.toInt) {\n     \
    \       for (j <- 0 until n.toInt) {\n                if (leftToRight(i) == rightToLeft(j))\
    \ res += 1\n            }\n        }\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8pyc3fkk.scala:17:29\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            rightToLeft(i) =\
    \ n - i\n\e[31m\e[31m   |\e[0m                             ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Found:    Long\n\e[31m   |\e[0m       \
    \                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // assume n is positive\n\
    \        // assume n is small enough so that we do not have to worry about arithmetic\
    \ overflow\n        val n2 = (n * n).toLong\n        val factor = 4 * n2 - 2 *\
    \ n + 1\n        val sum = (1 to n.toInt).map(i => {\n            val diff = n\
    \ - i\n            diff * (n2 - (i * i))\n        }).sum\n        factor * sum\
    \ / 24\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa_x1z7eq.scala:24)\n\tat Problem.main(tmpa_x1z7eq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821436
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Create a max heap of\
    \ the positions of the cars moving left to right.\n        // Create a min heap\
    \ of the positions of the cars moving right to left.\n        // Keep removing\
    \ the maximum number from the left heap and the minimum number\n        // from\
    \ the right heap, and calculate their distances.  If the distances are\n     \
    \   // the same, then we found a collision.  Keep doing this until we remove all\n\
    \        // elements from the heaps.\n        var l = new PriorityQueue[Long]()(Ordering.Long.reverse)\n\
    \        var r = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for\
    \ (i <- 1 to n.toInt) {\n            l.+=(i)\n            r.+=(i)\n        }\n\
    \        var ans = 0L\n        while (!l.isEmpty && !r.isEmpty) {\n          \
    \  val lx = l.dequeue\n            val rx = r.dequeue\n            if (lx == rx)\
    \ ans += 1\n        }\n        ans\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2cri64ig.scala:34)\n\tat Problem.main(tmp2cri64ig.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821436
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var collision = 0L\n \
    \       for (i <- 1L to n) {\n            if (n % i == 0) {\n                collision\
    \ += i - 1\n            }\n        }\n        collision\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8g16870v.scala:22)\n\tat Problem.main(tmp8g16870v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821436
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        /*\n        if (n <= 2)\
    \ return 0\n        val speed = n.toLong\n        val leftToRightDistances = List.fill(n.toInt)(speed)\n\
    \        val rightToLeftDistances = List.fill(n.toInt)(speed)\n        val t =\
    \ leftToRightDistances.zip(rightToLeftDistances).map(x => {\n            val leftDist\
    \ = x._1\n            val rightDist = x._2\n            min(leftDist, rightDist)\n\
    \        }).max\n        val x = leftToRightDistances.map(x => x - t).count(x\
    \ => x == 0)\n        val y = rightToLeftDistances.map(x => x - t).count(x =>\
    \ x == 0)\n        x + y\n        */\n        val speed = n.toLong\n        val\
    \ t = n\n        val x = n - t\n        if (x == 0) return n\n        val y =\
    \ n - t\n        if (y == 0) return n\n        2 * n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa_yitqbf.scala:36)\n\tat Problem.main(tmpa_yitqbf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // perform an n log n\
    \ solution by sorting.\n        val cars = new Array[Long](2 * n.toInt)\n    \
    \    for (i <- 0 until n.toInt) {\n            cars(i) = i.toLong + 1\n      \
    \      cars(i + n.toInt) = -(i.toLong + 1)\n        }\n        cars.sortWith((a,\
    \ b) => abs(a) < abs(b))\n        var answer = 0L\n        var carIndex = 0\n\
    \        while (carIndex < 2 * n.toInt) {\n            if (cars(carIndex) > 0)\
    \ {\n                var car = cars(carIndex)\n                while (carIndex\
    \ < 2 * n.toInt && cars(carIndex) == car) {\n                    carIndex += 1\n\
    \                }\n                answer += (carIndex - car).toLong\n      \
    \      } else {\n                carIndex += 1\n            }\n        }\n   \
    \     answer\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpap7xhyn6.scala:36)\n\tat Problem.main(tmpap7xhyn6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821436
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        /*\n        // greedy\
    \ brute force algorithm from the left to right, runs in O(n^2).\n        // assumes\
    \ that each car speed is a positive integer.\n        val map = HashMap[Long,\
    \ Long]()\n        for (i <- 1 to n.toInt) {\n            val speed = i\n    \
    \        var t = i\n            var collisions = 0\n            while (t <= n)\
    \ {\n                if (map.contains(t)) {\n                    collisions +=\
    \ map(t)\n                }\n                t += speed\n            }\n     \
    \       map(speed) = collisions\n        }\n        map.values.sum\n        */\n\
    \        /*\n        // below is the solution posted on project euler discussion.\n\
    \        // i don't know why the average function below works.\n        // if\
    \ we choose i = 1, 2, 3, ..., n and j = 1, 2, 3, ..., n,\n        // then i can\
    \ hit j when i < j and they have the same speed.\n        // Thus, we can choose\
    \ i from 1 to n, and calculate how many j can be hit by i.\n        // that's\
    \ the below solution. \n        def average(a : Long, b : Long) : Long = (a +\
    \ b) / 2\n        var result = 0L\n        for (i <- 1 to n.toInt) {\n       \
    \     val speed = i\n            result += (average(1, n) - average(n + 1 - i,\
    \ i)) * speed\n        }\n        result\n        */\n        // The above solution\
    \ assumes that the speed is an integer.\n        // The solution below does not\
    \ make this assumption.\n        // i can hit j when i < j and they have the same\
    \ speed.\n        // it's easier to calculate how many cars can be hit by car\
    \ i.\n        // when car i move from t = 0 to t = n, how many j are hit by i?\n\
    \        // car i is hit by j if and only if car j is traveling at the same speed.\n\
    \        // so, how many cars are driving left to right at the same speed?\n \
    \       // we can represent the trajectory of car i as a function f(t) = speed\
    \ * t.\n        // if the speed is an integer, we can represent the trajectory\
    \ by g(t) = floor\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe9bgp_4k.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m/*\n\e[31m14 |\e[0m        // greedy brute force algorithm from the left to\
    \ right, runs in O(n^2).\n\e[31m15 |\e[0m        // assumes that each car speed\
    \ is a positive integer.\n\e[31m16 |\e[0m        val map = HashMap[Long, Long]()\n\
    \e[31m17 |\e[0m        for (i <- 1 to n.toInt) {\n\e[31m18 |\e[0m            val\
    \ speed = i\n\e[31m19 |\e[0m            var t = i\n\e[31m20 |\e[0m           \
    \ var collisions = 0\n\e[31m21 |\e[0m            while (t <= n) {\n\e[31m22 |\e\
    [0m                if (map.contains(t)) {\n\e[31m23 |\e[0m                   \
    \ collisions += map(t)\n\e[31m24 |\e[0m                }\n\e[31m25 |\e[0m    \
    \            t += speed\n\e[31m26 |\e[0m            }\n\e[31m27 |\e[0m       \
    \     map(speed) = collisions\n\e[31m28 |\e[0m        }\n\e[31m29 |\e[0m     \
    \   map.values.sum\n\e[31m30 |\e[0m        */\e[0m\n\e[31m31 |\e[0m        \e\
    [34m/*\n\e[31m32 |\e[0m        // below is the solution posted on project euler\
    \ discussion.\n\e[31m33 |\e[0m        // i don't know why the average function\
    \ below works.\n\e[31m34 |\e[0m        // if we choose i = 1, 2, 3, ..., n and\
    \ j = 1, 2, 3, ..., n,\n\e[31m35 |\e[0m        // then i can hit j when i < j\
    \ and they have the same speed.\n\e[31m36 |\e[0m        // Thus, we can choose\
    \ i from 1 to n, and calculate how many j can be hit by i.\n\e[31m37 |\e[0m  \
    \      // that's the below solution. \n\e[31m38 |\e[0m        def average(a :\
    \ Long, b : Long) : Long = (a + b) / 2\n\e[31m39 |\e[0m        var result = 0L\n\
    \e[31m40 |\e[0m        for (i <- 1 to n.toInt) {\n\e[31m41 |\e[0m            val\
    \ speed = i\n\e[31m42 |\e[0m            result += (average(1, n) - average(n +\
    \ 1 - i, i)) * speed\n\e[31m43 |\e[0m        }\n\e[31m44 |\e[0m        result\n\
    \e["
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Given 2 cars that are\
    \ moving at speeds v1 and v2, and v1 <= v2,\n        // the absolute value of\
    \ their relative velocity is v2 - v1.  (Note\n        // that if v1 > v2, then\
    \ their relative velocity is -(v1 - v2) which is\n        // the same as v2 -\
    \ v1.)\n        // Given that there are n cars moving in each direction, there\
    \ are (n*(n-1))/2\n        // combinations of pairs of cars.\n        // Consider\
    \ a pair of cars that are moving in opposite directions.  Suppose\n        //\
    \ the relative velocity of one is v, and the other is -v.  If v is even,\n   \
    \     // then the cars collide at the time steps when their relative velocity\
    \ is\n        // positive.  If v is odd, then there are two different cases. \
    \ (1) if v = 1,\n        // then the cars collide at the time steps when their\
    \ relative velocity is\n        // positive;  (2) if v >= 3, then the cars do\
    \ not collide.\n        // Therefore, the number of collisions is the sum of the\
    \ absolute value of all\n        // pairs of relative velocities.\n        //\n\
    \        // Note that each pair of cars collide exactly once, except pairs of\
    \ cars with\n        // relative velocity 0.  If we sum up the absolute value\
    \ of all pairs of\n        // relative velocities, we double-count the pairs of\
    \ cars with relative velocity 0.\n        // Therefore, we have to subtract (n*(n-1)/2).\n\
    \        //\n        // Note that the sum of all relative velocities is always\
    \ 0.  Therefore, the\n        // sum of the absolute value of all relative velocities\
    \ is always 0.  Therefore,\n        // we have to subtract (n*(n-1)/2) once more.\n\
    \        //\n        // Therefore, the number of collisions is\n        // (sum\
    \ of the absolute value of all pairs of relative velocities) - (n*(n-1)/2) - (n*(n-1)/2)\n\
    \        // = (sum of the absolute value of all pairs of relative velocities)\
    \ - (n*(n-1))\n        // = (sum of the absolute value of all pairs of relative\
    \ velocities) -\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb13hncvt.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Given 2 cars that are moving at speeds v1 and v2, and v1 <= v2,\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// the absolute value of their relative velocity is\
    \ v2 - v1.  (Note\e[0m\n\e[31m15 |\e[0m        \e[34m// that if v1 > v2, then\
    \ their relative velocity is -(v1 - v2) which is\e[0m\n\e[31m16 |\e[0m       \
    \ \e[34m// the same as v2 - v1.)\e[0m\n\e[31m17 |\e[0m        \e[34m// Given that\
    \ there are n cars moving in each direction, there are (n*(n-1))/2\e[0m\n\e[31m18\
    \ |\e[0m        \e[34m// combinations of pairs of cars.\e[0m\n\e[31m19 |\e[0m\
    \        \e[34m// Consider a pair of cars that are moving in opposite directions.\
    \  Suppose\e[0m\n\e[31m20 |\e[0m        \e[34m// the relative velocity of one\
    \ is v, and the other is -v.  If v is even,\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ then the cars collide at the time steps when their relative velocity is\e[0m\n\
    \e[31m22 |\e[0m        \e[34m// positive.  If v is odd, then there are two different\
    \ cases.  (1) if v = 1,\e[0m\n\e[31m23 |\e[0m        \e[34m// then the cars collide\
    \ at the time steps when their relative velocity is\e[0m\n\e[31m24 |\e[0m    \
    \    \e[34m// positive;  (2) if v >= 3, then the cars do not collide.\e[0m\n\e\
    [31m25 |\e[0m        \e[34m// Therefore, the number of collisions is the sum of\
    \ the absolute value of all\e[0m\n\e[31m26 |\e[0m        \e[34m// pairs of relative\
    \ velocities.\e[0m\n\e[31m27 |\e[0m        \e[34m//\e[0m\n\e[31m28 |\e[0m    \
    \    \e[34m// Note that each pair of cars collide exactly once, except pairs of\
    \ cars with\e[0m\n\e[31m29 |\e[0m        \e[34m// relative velocity 0.  If we\
    \ sum up the absolute value of all pairs of\e[0m\n\e[31m30 |\e[0m        \e[34m//\
    \ relative velocities, we double-count the pair"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a greedy problem\
    \ that can be solved with a priority queue.\n        // Assume the cars are numbered\
    \ from 1 to n in both directions.\n        // Define class Car which contains\
    \ the car number and its x-position (i.e. left/right distance\n        // from\
    \ the starting point).  Define a priority queue, sorted by the x-position of the\
    \ car.\n        // Initially, add all n cars from both directions, starting with\
    \ car 1, then car 2, ... , then car n.\n        // Then, whenever a car A collides\
    \ with a car B, remove the car with the smaller number (to avoid double counting).\n\
    \        // Repeat this until the queue is empty.\n        val q = new PriorityQueue[Car]()(new\
    \ CarOrdering())\n        for (i <- 1 to n.toInt) {\n            q.enqueue(new\
    \ Car(i, i))\n            q.enqueue(new Car(i, -i))\n        }\n        var count\
    \ = 0\n        while (!q.isEmpty) {\n            val curr = q.dequeue\n      \
    \      val next = q.dequeue\n            if (curr.num > next.num) q.enqueue(curr)\n\
    \            else if (curr.num < next.num) q.enqueue(next)\n            else count\
    \ += 1\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa2jccpif.scala:20:34 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = \e[33mnew\e[0m\
    \ \e[35mPriorityQueue\e[0m[\e[35mCar\e[0m]()(\e[33mnew\e[0m \e[35mCarOrdering\e\
    [0m())\n\e[31m\e[31m   |\e[0m                                  ^^^\e[0m\n\e[31m\
    \   |\e[0m                                  Not found: type Car\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa2jccpif.scala:20:45 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = \e[33mnew\e[0m\
    \ \e[35mPriorityQueue\e[0m[\e[35mCar\e[0m]()(\e[33mnew\e[0m \e[35mCarOrdering\e\
    [0m())\n\e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Not found: type\
    \ CarOrdering\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa2jccpif.scala:22:26\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            q.enqueue(\e\
    [33mnew\e[0m \e[35mCar\e[0m(i, i))\n\e[31m\e[31m   |\e[0m                    \
    \      ^^^\e[0m\n\e[31m   |\e[0m                          Not found: type Car\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa2jccpif.scala:23:26\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            q.enqueue(\e\
    [33mnew\e[0m \e[35mCar\e[0m(i, -i))\n\e[31m\e[31m   |\e[0m                   \
    \       ^^^\e[0m\n\e[31m   |\e[0m                          Not found: type Car\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        return 2 * n - 1\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ilv751_.scala:16)\n\tat Problem.main(tmp5ilv751_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is that the\
    \ number of collisions is just n * n\n        // However, n * n is too big for\
    \ a long value to hold, so \n        // we need to use BigInts instead.\n    \
    \    BigInt(n) * BigInt(n)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l)) ==\
    \ (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprta_ayzj.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        BigInt(n) * BigInt(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    BigInt\n\e[31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        if (n == 0) return 0\n\
    \        val primes = Primes.sieve(n).reverse\n        val sqrt = sqrt(n.toDouble).toLong\n\
    \        val exponents = Array.fill(primes.length)(0L)\n        for (i <- 1 to\
    \ primes.length - 1) {\n            var j = 1\n            var x = pow(primes(i).toDouble,\
    \ j).toLong\n            while (x <= sqrt) {\n                exponents(i) +=\
    \ 1\n                j += 1\n                x = pow(primes(i).toDouble, j).toLong\n\
    \            }\n        }\n        val result = (for (i <- 1 to primes.length\
    \ - 1) yield primes(i) * exponents(i)).sum\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3k4pex6i.scala:14:21 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = Primes.sieve(n).reverse\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \              Not found: Primes\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp3k4pex6i.scala:15:19 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(n.toDouble).toLong\n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   Recursive\
    \ \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmp3k4pex6i.scala:26:91 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = (\e[33mfor\e\
    [0m (i <- \e[31m1\e[0m to primes.length - \e[31m1\e[0m) \e[33myield\e[0m primes(i)\
    \ * exponents(i)).sum\n\e[31m\e[31m   |\e[0m                                 \
    \                                                          ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mFloatIsFractional\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mCharIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter\
    \ num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // simulation\n      \
    \  val leftToRightCars = (1 to n.toInt).map(i => new Car(i)).toList\n        val\
    \ rightToLeftCars = (1 to n.toInt).map(i => new Car(i)).toList\n        val road\
    \ = new Road(leftToRightCars, rightToLeftCars)\n        val simulation = new Simulation(road)\n\
    \        simulation.run\n        simulation.collisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0lhxcmbp.scala:14:58 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mleftToRightCars\e[0m = (\e\
    [31m1\e[0m to n.toInt).map(\e[36mi\e[0m => \e[33mnew\e[0m \e[35mCar\e[0m(i)).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^^^\e[0m\n\e[31m   |\e[0m                                                 \
    \    Not found: type Car\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp0lhxcmbp.scala:15:58 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mrightToLeftCars\e[0m = (\e[31m1\e[0m to n.toInt).map(\e\
    [36mi\e[0m => \e[33mnew\e[0m \e[35mCar\e[0m(i)).toList\n\e[31m\e[31m   |\e[0m\
    \                                                          ^^^\e[0m\n\e[31m  \
    \ |\e[0m                                                     Not found: type Car\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0lhxcmbp.scala:16:23\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mroad\e[0m = \e[33mnew\e[0m \e[35mRoad\e[0m(leftToRightCars, rightToLeftCars)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                Not found: type Road\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp0lhxcmbp.scala:17:29 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msimulation\e[0m = \e[33mnew\e\
    [0m \e[35mSimulation\e[0m(road)\n\e[31m\e[31m   |\e[0m                       \
    \      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ type Simulation\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is that we\
    \ can assume the cars are moving at unit speed;\n        // for each left-to-right\
    \ car, we determine the point at which it collides with\n        // a right-to-left\
    \ car.  We then sort the resulting set of points, and we can\n        // determine\
    \ the number of collisions as the number of consecutive pairs of points.\n   \
    \     // In terms of algorithm, we can do this in linear time using a hash map.\n\
    \        // For each right-to-left car, we put it into the hash map.  For each\
    \ left-to-right\n        // car, we check whether there is a right-to-left car\
    \ that is positioned to the left\n        // of the current left-to-right car;\
    \ if there is, the two will eventually collide.\n        // We then move the left-to-right\
    \ car to the right of the right-to-left car, and\n        // we repeat the check.\
    \  Eventually, the left-to-right car will have passed all\n        // cars that\
    \ have previously been checked.  We then remove it from the hash map\n       \
    \ // to avoid checking it later.\n        val cars = HashMap[Long, Long]()\n \
    \       val points = HashMap[Long, Long]()\n        for (i <- n until n + n) cars(i)\
    \ = i - n\n        for (i <- n until n + n) {\n            var j = i\n       \
    \     var prev = -1L\n            while (true) {\n                if (cars.contains(j))\
    \ {\n                    val diff = prev - cars(j)\n                    if (points.contains(diff))\
    \ points(diff) += 1\n                    else points(diff) = 1\n             \
    \       prev = cars(j)\n                    cars.remove(j)\n                }\n\
    \                else if (cars.contains(j + 1)) {\n                    val diff\
    \ = prev - cars(j + 1)\n                    if (points.contains(diff)) points(diff)\
    \ += 1\n                    else points(diff) = 1\n                    prev =\
    \ cars(j + 1)\n                    cars.remove(j + 1)\n                }\n   \
    \             else break\n                j += 1\n            }\n        }\n \
    \       // now we check whether any two consecutive points, if they exist, differ\
    \ by 1\n       \n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5nhb5b75.scala:46:21 ------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                \e[33melse\e[0m break\n\e[31m\e[31m \
    \  |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Assume cars are indexed\
    \ left to right from 0 to n-1, and right to left from n to 2n-1\n        // If\
    \ all cars move at the same speed, then the collision index is the car's index\n\
    \        // If cars start at distance d, then the time each car takes to reach\
    \ collision point is t\n        // = d / speed\n        // The car's speed is\
    \ then d / t.\n        // To represent this, we can have a function f(x) = d /\
    \ x\n        // Now, the car's speed can be represented as a function, g(i) =\
    \ f(t + i)\n        // where i is the car's index and t is the time taken for\
    \ all cars to reach collision point\n        val f = new Function[Long, Long]\
    \ {\n            def apply(x : Long) = 1000000000 / x\n        }\n        // car\
    \ 0 moves left to right with speed g(0) = f(t)\n        // car 1 moves left to\
    \ right with speed g(1) = f(t + 1)\n        // car n-1 moves left to right with\
    \ speed g(n-1) = f(t + n - 1)\n        // car n moves right to left with speed\
    \ g(n) = f(t)\n        // car n+1 moves right to left with speed g(n+1) = f(t\
    \ + 1)\n        // car 2n-1 moves right to left with speed g(2n-1) = f(t + n -\
    \ 1)\n        // The net result is that the car's speed is represented by the\
    \ function\n        // g(x) = f(t + abs(x - n))\n        val g = new Function[Long,\
    \ Long] {\n            def apply(x : Long) = f(abs(x - n))\n        }\n      \
    \  // To determine the collision index, we want the indexes where g(x) = g(x -\
    \ 1)\n        // For example, consider g(x) = 1 / x\n        // Then, g(x) = g(x\
    \ - 1) is satisfied at x = 3\n        // To find a solution to this, we can make\
    \ use of the intermediate value theorem\n        // Let f(x) = g(x) - g(x - 1)\n\
    \        // We\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2a2z_284.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The intuition of this\
    \ problem is as follows.  Car i is going to collide with car j\n        // if\
    \ and only if car i reaches a point x to the right of car j, and car j reaches\n\
    \        // a point x to the left of car i.  Now, a car can reach point x to the\
    \ right of\n        // car j as soon as t minutes have passed since the start\
    \ of the race, where x\n        // is t times the speed of car i.  By the same\
    \ token, car j will reach point x\n        // to the left of car i as soon as\
    \ s minutes have passed, where x is s times the\n        // speed of car j.\n\
    \        // So we have the following condition for the existence of a collision:\n\
    \        // t * speed(i) = s * speed(j)\n        // Now, since speed(i) != speed(j),\
    \ we can take speed(i) as the independent variable.\n        // We can then take\
    \ s = t * speed(i) / speed(j).  This means that as soon as t minutes\n       \
    \ // have passed since the start of the race, car i reaches a point that's s *\
    \ speed(j)\n        // away from the starting point, which is the place where\
    \ car j is.\n        // Note that we can assume that s * speed(j) = t * speed(i),\
    \ where s, t are integers.\n        // We can then take s = speed(i) * k / gcd(speed(i),\
    \ speed(j)), where k is an integer.\n        // This gives us the following equation:\n\
    \        // t * speed(i) = speed(i) * k / gcd(speed(i), speed(j)) * speed(j)\n\
    \        // Now, let x = gcd(speed(i), speed(j)).  We then have t * speed(i) =\
    \ k * speed(j) / x.\n        // This means that as soon as t minutes have passed\
    \ since the start of the race,\n        // car i is at point k * speed(j) / x,\
    \ which is precisely where car j is.\n        // The trick is to loop through\
    \ all the values of t = 1 to k = speed(i) * speed(j) / x\n        // and check\
    \ whether t * speed(i) = k\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l)) ==\
    \ (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2sqwe5kk.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The intuition of this problem is as follows.  Car i is going to collide\
    \ with car j\e[0m\n\e[31m14 |\e[0m        \e[34m// if and only if car i reaches\
    \ a point x to the right of car j, and car j reaches\e[0m\n\e[31m15 |\e[0m   \
    \     \e[34m// a point x to the left of car i.  Now, a car can reach point x to\
    \ the right of\e[0m\n\e[31m16 |\e[0m        \e[34m// car j as soon as t minutes\
    \ have passed since the start of the race, where x\e[0m\n\e[31m17 |\e[0m     \
    \   \e[34m// is t times the speed of car i.  By the same token, car j will reach\
    \ point x\e[0m\n\e[31m18 |\e[0m        \e[34m// to the left of car i as soon as\
    \ s minutes have passed, where x is s times the\e[0m\n\e[31m19 |\e[0m        \e\
    [34m// speed of car j.\e[0m\n\e[31m20 |\e[0m        \e[34m// So we have the following\
    \ condition for the existence of a collision:\e[0m\n\e[31m21 |\e[0m        \e\
    [34m// t * speed(i) = s * speed(j)\e[0m\n\e[31m22 |\e[0m        \e[34m// Now,\
    \ since speed(i) != speed(j), we can take speed(i) as the independent variable.\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// We can then take s = t * speed(i) / speed(j).\
    \  This means that as soon as t minutes\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ have passed since the start of the race, car i reaches a point that's s * speed(j)\e\
    [0m\n\e[31m25 |\e[0m        \e[34m// away from the starting point, which is the\
    \ place where car j is.\e[0m\n\e[31m26 |\e[0m        \e[34m// Note that we can\
    \ assume that s * speed(j) = t * speed(i), where s, t are integers.\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// We can then take s = speed(i) * k / gcd(speed(i), speed(j)),\
    \ where k is an integer.\e[0m\n\e[31m28 |\e[0m        \e[34m// This gives us the\
    \ following equation:\e[0m\n\e"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var numCollisions = 0L\n\
    \        var carsLeftToRight = new PriorityQueue[(Long, Long)]()\n        var\
    \ carsRightToLeft = new PriorityQueue[(Long, Long)]()\n        for (i <- 1 to\
    \ n.toInt) {\n            carsLeftToRight.enqueue((i, i))\n            carsRightToLeft.enqueue((-i,\
    \ -i))\n        }\n        var done = false\n        while (!done) {\n       \
    \     val (x, i) = carsLeftToRight.dequeue\n            val (y, j) = carsRightToLeft.dequeue\n\
    \            if (x < -y) {\n                carsLeftToRight.enqueue((x, i))\n\
    \                carsRightToLeft.enqueue((y, j))\n                done = true\n\
    \            } else {\n                numCollisions += 1\n                if\
    \ (i == n) {\n                    done = true\n                } else {\n    \
    \                carsLeftToRight.enqueue((x + 1, i + 1))\n                   \
    \ carsRightToLeft.enqueue((y, j))\n                }\n            }\n        }\n\
    \        numCollisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp51hvej8s.scala:41)\n\tat Problem.main(tmp51hvej8s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821436
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // take the n cars going\
    \ left to right, and sort them by their speed\n        // take the n cars going\
    \ right to left, and sort them by their speed\n        // observe that if two\
    \ cars collide, they must be at the same speed\n        // since there are no\
    \ deceleration, neither car can slow down.\n        // if there are c cars going\
    \ left to right, and c cars going right to left\n        // with equal speed,\
    \ then there will be c^2 collisions.\n        // So we just need to count the\
    \ number of pairs of equal speeds.\n        // now, the number of cars with speed\
    \ 1, 2, 3, 4, 5, ... is n + n/2 + n/3 + n/4 + n/5 + ...\n        // This is a\
    \ geometric series, so we can sum it up using \n        // http://en.wikipedia.org/wiki/Geometric_series#Summation_of_a_geometric_series\n\
    \        var total = 0.0\n        for (i <- 1 to n.toInt) {\n            val nInGroup\
    \ = n / i\n            val nOfGroups = i\n            total += nInGroup * nOfGroups\
    \ * nInGroup\n        }\n        total.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjflvnip7.scala:32)\n\tat Problem.main(tmpjflvnip7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Write your code here\n\
    \        val min = -1000000000\n        val max = 1000000000\n        var p =\
    \ List[Int]()\n        var q = List[Int]()\n        var l = List[Int]()\n    \
    \    for (i <- min to max) {\n            p ::= i\n            q ::= i\n     \
    \       l ::= i\n        }\n        var collisions = 0\n        var s = 0\n  \
    \      for (i <- (p.length - 1) to 0 by -1) {\n            var found = false\n\
    \            var index = -1\n            var j = 0\n            while (j < l.length\
    \ && !found) {\n                if (l(j) == q(i)) {\n                    found\
    \ = true\n                    index = j\n                }\n                j\
    \ += 1\n            }\n            if (found) {\n                l.remove(index)\n\
    \                collisions += p.length - i - 1\n            }\n        }\n  \
    \      collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2sc2busd.scala:38:18 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                l.remove(index)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove is not a member of\
    \ List[Int] - did you mean List[Int].reduce?\n1 error found\n"
  stdout: ''
  timestamp: 1660012823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val positions = new Array[Long](n.toInt)\n\
    \        val cars = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            positions(i) = i\n            cars(i) = i\n        }\n      \
    \  var result = 0L\n        for (i <- 0 until n.toInt) {\n            val pos\
    \ = positions(i)\n            val car = cars(i)\n            val dist = abs(car\
    \ - pos)\n            var pos2 = n - pos - 1\n            val car2 = n - car -\
    \ 1\n            val dist2 = abs(car2 - pos2)\n            if (dist > dist2) {\n\
    \                var steps = 0\n                while (dist > dist2) {\n     \
    \               pos2 += 1\n                    steps += 1\n                  \
    \  dist2 = abs(car2 - pos2)\n                }\n                if (dist == dist2)\
    \ {\n                    result += steps\n                }\n            }\n \
    \       }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpfiei3_os.scala:32:26 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    dist2 = abs(car2 - pos2)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Reassignment to val dist2\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660012821
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // fill in the rest of\
    \ this code.\n        // your code must be fast enough to pass tests in 2 seconds\
    \ when n=100,000,000\n        var left = 0L\n        var right = 0L\n        for\
    \ (c <- 0L until n) {\n            left += c\n            right += n - c - 1\n\
    \        }\n        if (left > right) left - right else right - left\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpapgets91.scala:24)\n\tat Problem.main(tmpapgets91.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n\tvar a = new Array[Long]((n+1).toInt)\n\
    \tfor (i <- 1 to n.toInt) {\n\t    a(i) = n - i\n\t}\n\tprintln(a.mkString(\"\
    \ \"))\n\tvar count = 0L\n\tfor (i <- 1 to n.toInt) {\n\t    for (j <- 1 to i)\
    \ {\n\t\tif (a(j) == a(i)) count += 1\n\t    }\n\t}\n\tcount\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6ztjn2kp.scala:22:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m\t    }\n\e[31m\e[31m   |\e[0m\t    ^\e[0m\n\e[31m  \
    \ |\e[0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\
    \e[31m   |\e[0m   Previous indent : 2 tabs\n\e[31m   |\e[0m   Latest indent  \
    \ : 1 tab, 4 spaces\n\e[31m\e[31m-- Error: /tmp/tmp6ztjn2kp.scala:25:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab\n\e[31m   |\e[0m   Latest indent   : 4\
    \ spaces\n2 errors found\n"
  stdout: ''
  timestamp: 1660012822
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var n2 = n / 2;\n    \
    \    if (n % 2 == 1) n2 += 1;\n        n * n2 - n2 * n2;\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5hwq7dmp.scala:18)\n\tat Problem.main(tmp5hwq7dmp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012824
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val multiples = ArrayBuffer[Long]()\n\
    \        for (i <- 1 to sqrt(n).toInt) {\n            if (n % i == 0) {\n    \
    \            multiples += i\n                if (i != 1) multiples += n / i\n\
    \            }\n        }\n        val xs = multiples.toArray\n        xs.sorted\n\
    \        var result = 0L\n        for (x <- xs) {\n            val c = n / x\n\
    \            result += x * c * (c - 1) / 2\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0ql607jb.scala:30)\n\tat Problem.main(tmp0ql607jb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012825
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // imagine a single direction\
    \ where cars can move either left or right\n        // then, count the number\
    \ of crossings.\n        // There are exactly n crossings\n        n * (n - 1)\
    \ / 2\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl7c62ohs.scala:19)\n\tat Problem.main(tmpl7c62ohs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012824
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // calculating the number\
    \ of collisons is the same as calculating the number of\n        // inversions\
    \ for an array of size n. \n        // For example,\n        // {0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9}\n        // has 0 inversions\n        // {3, 1, 4, 0, 2, 5, 6,\
    \ 8, 7, 9}\n        // has 2 inversions (3, 1), (3, 2)\n        // {7, 6, 5, 4,\
    \ 3, 2, 1, 0, 9, 8}\n        // has 45 inversions\n        // n inversions is\
    \ n(n - 1) / 2\n        // the total number of inversions is n(n - 1) / 2\n  \
    \      // the number of collisions is n(n - 1) / 2 - k\n        // where k is\
    \ the number of inversions from one set of cars\n        val k = Array.ofDim[Long](n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            k(i) = math.abs(i - (n.toInt\
    \ - 1 - i))\n        }\n        n * (n - 1) / 2 - k.sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3121r6nk.scala:33)\n\tat Problem.main(tmp3121r6nk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012825
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let us call the set\
    \ of cars that are moving left to right as \"a\" and the other set as \"b\".\n\
    \        // First, let us prove that, if we label the cars in set \"a\" as 1,\
    \ 2, 3, ..., n, and \n        // label the cars in set \"b\" as 1, 2, 3, ...,\
    \ n, then, within each set, the cars that\n        // collide must be labeled\
    \ in the same way.  As a result, the number of collisions is equal\n        //\
    \ to the number of ways to choose 2 cars that collide, which is nC2.\n       \
    \ // Proof:\n        // The number of pairs of cars that collide are determined\
    \ by the number of cars that\n        // are in the middle;  for example, if the\
    \ cars that are in the middle are the first k cars,\n        // then k pairs of\
    \ cars collide (the kth pair of cars that collide are the cars that are labeled\
    \ k\n        // in each set).\n        // Now, imagine the case when there are\
    \ no cars in the middle.  In that case, there are no collisions.\n        // Then,\
    \ let us assume that a single car is put in the middle (with no other cars in\
    \ the middle).\n        // Then, a single pair of cars collide.  Now, assume that\
    \ there are already k cars in the middle.\n        // Let us add a new car (call\
    \ it car #k+1) in the middle.  Then, the new car collides with the cars\n    \
    \    // labeled k+1 in each set.  Hence, the number of collisions increase by\
    \ 1.\n        // Now, assume that there are no collisions.  Then, let us put a\
    \ single car in the middle,\n        // and notice that this does not create any\
    \ collisions.  So, we can put cars in the middle one at a time\n        // and\
    \ the number of collisions will not change.\n        // As a result, the number\
    \ of collisions is equal to the number of cars in the middle.\n        // It is\
    \ easy to see that this number is equal to nC2.\n        n * (n - 1) / 2\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6cw8oelg.scala:36)\n\tat Problem.main(tmp6cw8oelg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012824
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        return 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrtrxub1.scala:16)\n\tat Problem.main(tmpjrtrxub1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // ith car:  start at\
    \ -i from left to right, speed = i\n        // nth car:  start at -n from right\
    \ to left, speed = n\n        // These cars will collide if (n - i)^2 - (n - i)\
    \ - i^2 + i = 0.\n        // This is a quadratic equation.  A \"quadratic\" equation\
    \ is a second-degree\n        // polynomial equation, meaning the term in x^2\
    \ is the highest power of x\n        // in the equation.\n        // The quadratic\
    \ formula is -b +/- sqrt(b^2 - 4ac) / 2a, where a, b, c are\n        // coefficients\
    \ in the equation ax^2 + bx + c = 0.\n        // Here a = -1, b = 1, c = -1. \
    \ So the quadratic formula for these coefficients\n        // gives -1 +/- sqrt(1\
    \ - 4(-1)(-1)) / 2(-1).  This simplifies to -1 +/- sqrt(5) / 2.\n        // So\
    \ the values where n - i = 0 are -1 + sqrt(5) / 2 and -1 - sqrt(5) / 2.\n    \
    \    // These solve to i = 3 and i = 1.\n        // So there are 3 collisions.\n\
    \        // The quadratic formula gives the solutions to the equation:  ax^2 +\
    \ bx + c = 0.\n        // So, to find the number of collisions, we need to find\
    \ how many values x\n        // satisfy ax^2 + bx + c = 0.\n        // The number\
    \ of solutions is 0 if b^2 - 4ac < 0; 1 if b^2 - 4ac = 0;\n        // 2 if b^2\
    \ - 4ac > 0.\n        // a = -1, b = 1, c = -1\n        // So b^2 - 4ac = 1 -\
    \ 4(-1)(-1) = 1 + 4 = 5.\n        // So there are 2 solutions.\n        // The\
    \ number of collisions is the number of solutions to the equation:\n        //\
    \ (n - i)^2 - (n - i) - i^2 + i = 0\n        // This equation can be rewritten\
    \ as:\n        // i^\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjfno22ys.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// ith car:  start at -i from left to right, speed = i\e[0m\n\e[31m14 |\e\
    [0m        \e[34m// nth car:  start at -n from right to left, speed = n\e[0m\n\
    \e[31m15 |\e[0m        \e[34m// These cars will collide if (n - i)^2 - (n - i)\
    \ - i^2 + i = 0.\e[0m\n\e[31m16 |\e[0m        \e[34m// This is a quadratic equation.\
    \  A \"quadratic\" equation is a second-degree\e[0m\n\e[31m17 |\e[0m        \e\
    [34m// polynomial equation, meaning the term in x^2 is the highest power of x\e\
    [0m\n\e[31m18 |\e[0m        \e[34m// in the equation.\e[0m\n\e[31m19 |\e[0m  \
    \      \e[34m// The quadratic formula is -b +/- sqrt(b^2 - 4ac) / 2a, where a,\
    \ b, c are\e[0m\n\e[31m20 |\e[0m        \e[34m// coefficients in the equation\
    \ ax^2 + bx + c = 0.\e[0m\n\e[31m21 |\e[0m        \e[34m// Here a = -1, b = 1,\
    \ c = -1.  So the quadratic formula for these coefficients\e[0m\n\e[31m22 |\e\
    [0m        \e[34m// gives -1 +/- sqrt(1 - 4(-1)(-1)) / 2(-1).  This simplifies\
    \ to -1 +/- sqrt(5) / 2.\e[0m\n\e[31m23 |\e[0m        \e[34m// So the values where\
    \ n - i = 0 are -1 + sqrt(5) / 2 and -1 - sqrt(5) / 2.\e[0m\n\e[31m24 |\e[0m \
    \       \e[34m// These solve to i = 3 and i = 1.\e[0m\n\e[31m25 |\e[0m       \
    \ \e[34m// So there are 3 collisions.\e[0m\n\e[31m26 |\e[0m        \e[34m// The\
    \ quadratic formula gives the solutions to the equation:  ax^2 + bx + c = 0.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// So, to find the number of collisions, we\
    \ need to find how many values x\e[0m\n\e[31m28 |\e[0m        \e[34m// satisfy\
    \ ax^2 + bx + c = 0.\e[0m\n\e[31m29 |\e[0m        \e[34m// The number of solutions\
    \ is 0 if b^2 - 4ac < 0; 1 if b^2 - 4ac = 0;\e[0m\n\e[31m30 |\e[0m        \e[34m//\
    \ 2 if b^2 - 4ac > 0.\e[0m\n\e[31m31 |\e[0m        \e[34m// a = -1,"
  stdout: ''
  timestamp: 1660012823
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let A be the number\
    \ of times an odd numbered car in the first direction hits\n        // an even\
    \ numbered car in the other direction.  Let B be the number of times\n       \
    \ // an even numbered car in the first direction hits an odd numbered car in the\n\
    \        // other direction.\n        // A + B is the total number of collisions.\n\
    \        // This is because each collision is counted twice, once in A and once\
    \ in B.\n        // Thus, A = B = (A + B) / 2, and thus A + B = 2 * A = 2 * B.\n\
    \        // We will calculate A (and thus B) in this problem.\n        // Note\
    \ that odd numbers are in one-to-one correspondence with the even numbers.\n \
    \       // This is because for any even number x, there is a unique odd number\
    \ x - 1,\n        // and vice versa.\n        // Therefore, it suffices to calculate\
    \ the number of times a number of one parity hits\n        // another number of\
    \ the other parity.\n        // Let m = n / 2.  Then the number of hits is sum_{i\
    \ = 1}^m i.\n        // This is because there are m numbers that are of one parity,\
    \ and each one of them\n        // hits a unique number of the other parity.\n\
    \        // Thus, the sum of the number of times a number of one parity hits a\
    \ number of the other\n        // parity is 2 * sum_{i = 1}^m i = 2 * m * (m +\
    \ 1) / 2 = n * (n + 1) / 2.\n        n * (n + 1) / 2\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe4emc304.scala:34)\n\tat Problem.main(tmpe4emc304.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012824
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val leftToRight = Array.fill(n.toInt)(0)\n\
    \        val rightToLeft = Array.fill(n.toInt)(0)\n        // Fill the leftToRight\
    \ array\n        for (i <- 0 until n.toInt) leftToRight(i) = (2 * n - i).toInt\n\
    \        // Fill the rightToLeft array\n        for (i <- 0 until n.toInt) rightToLeft(i)\
    \ = (2 * n - leftToRight(i) + 1).toInt\n        // Now that we have filled two\
    \ arrays, we need to get their cartesian product\n        // and iterate over\
    \ that.\n        var collisionCounter = 0\n        for (i <- 0 until n.toInt)\
    \ {\n            for (j <- 0 until n.toInt) {\n                if (leftToRight(i)\
    \ == rightToLeft(j)) collisionCounter += 1\n            }\n        }\n       \
    \ return collisionCounter\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps0jxh55z.scala:30)\n\tat Problem.main(tmps0jxh55z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012825
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val listL = for (i <-\
    \ 1L to n) yield i\n        val listR = listL.reverse\n        val mapL = listL.zip(listR).toMap\n\
    \        val mapR = listR.zip(listL).toMap\n        val map = mapL ++ mapR\n \
    \       map.values.toList.distinct.length\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvp5aer6x.scala:21)\n\tat Problem.main(tmpvp5aer6x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012825
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // So the trick is to\
    \ transform it into a problem of finding an increasing subsequence\n        //\
    \ of length n in a random sequence of n numbers.\n        // In this way, the\
    \ cars driving left to right are the increasing subsequence.\n        // The number\
    \ of collisions are thus the number of cars driving right to left.\n        //\
    \ An increasing subsequence is a subsequence of a given sequence such that all\
    \ elements of the subsequence are sorted in increasing order.\n        def randomShuffle(n:\
    \ Long) : List[Int] = {\n            def randomShuffleRec(n: Long, result: List[Int])\
    \ : List[Int] = {\n                if (n == 0) result\n                else {\n\
    \                    val rand = new scala.util.Random\n                    val\
    \ randIndex = rand.nextInt(result.length)\n                    randomShuffleRec(n\
    \ - 1, result.take(randIndex) ::: result.takeRight(result.length - randIndex -\
    \ 1) ::: List(result(randIndex)))\n                }\n            }\n        \
    \    randomShuffleRec(n, (1 to n.toInt).toList)\n        }\n        // This is\
    \ the algorithm to find the length of the longest increasing subsequence of a\
    \ given sequence\n        // We can use this to find the number of collissions\n\
    \        def longestIncSubsequence(seq: List[Int]) : Int = {\n            if (seq.length\
    \ == 0) 0\n            else {\n                val lengths = new Array[Int](seq.length)\n\
    \                lengths(0) = 1\n                var longest = 1\n           \
    \     for (i <- 1 until seq.length) {\n                    var length = 1\n  \
    \                  for (j <- 0 until i) if (seq(j) < seq(i)) length = max(length,\
    \ lengths(j) + 1)\n                    lengths(i) = length\n                 \
    \   longest = max(longest, length)\n                }\n                longest\n\
    \            }\n        }\n        longestIncSubsequence(randomShuffle(n))\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpksecjdo5.scala:49)\n\tat Problem.main(tmpksecjdo5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012825
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // this is a O(n^2) algorithm.\
    \  Can you come up with a better one?\n        var count = 0L\n        for (i\
    \ <- 1L to n) {\n            for (j <- 1L to n) {\n                if (i == j)\
    \ {\n                    count += 1\n                }\n            }\n      \
    \  }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo2ixsvze.scala:25)\n\tat Problem.main(tmpo2ixsvze.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012824
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var collisions = 0L\n\
    \        var left = ArrayBuffer[Long]()\n        var right = ArrayBuffer[Long]()\n\
    \        // left car to right car collision is when left(i) == right(j)\n    \
    \    // left(i) < right(j) is when left(i) < right(j)\n        // left(i) > right(j)\
    \ is when left(i) > right(j)\n        // left(i) < right(j) is when left(i) <\
    \ right(j)\n        // left(i) < right(j) is when left(i) < right(j)\n       \
    \ // left(i) < right(j) is when left(i) < right(j)\n        // left(i) < right(j)\
    \ is when left(i) < right(j)\n        for (i <- 0L until n) {\n            left\
    \ += i\n            right += (n * 2) - i\n        }\n        for (x <- left) for\
    \ (y <- right) if (x == y) collisions += 1\n        collisions\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph5veyuia.scala:31)\n\tat Problem.main(tmph5veyuia.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012825
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // slow: O(n^2)\n    \
    \    // x0 is the left-most car driving right-to-left\n        // x1 is the right-most\
    \ car driving left-to-right\n        // note that x0 < x1\n        // car i's\
    \ coordinate is (xi, xi + 1)\n        // Car i is driven to the right if it is\
    \ before x0, and to the left if it is after x1\n        // Solution:\n       \
    \ //  Go from left to right; if you find a car before x0, make it a right-to-left\
    \ car\n        //  Go from right to left; if you find a car after x1, make it\
    \ a left-to-right car\n        //  continue until you can't swap any more cars.\n\
    \        //  this is equivalent to finding the index of smallest right-to-left\
    \ car and the index of\n        //  the biggest left-to-right car\n        //\
    \  output the sum of their indices\n        val a = new Array[Boolean](n.toInt)\n\
    \        var i = 0\n        while (i < n) {\n            a(i) = false\n      \
    \      i += 1\n        }\n        var x0 = 0\n        var x1 = n - 1\n       \
    \ // swap cars until there is no more swap\n        while (true) {\n         \
    \   var swaped = false\n            i = 0\n            while (i < x0) {\n    \
    \            if (!a(i)) {\n                    a(i) = true\n                 \
    \   x0 = i\n                    swaped = true\n                }\n           \
    \     i += 1\n            }\n            i = n.toInt - 1\n            while (i\
    \ > x1) {\n                if (a(i)) {\n                    a(i) = false\n   \
    \                 x1 = i\n                    swaped = true\n                }\n\
    \                i -= 1\n            }\n            if (!swaped) return (x0 +\
    \ 1) * x0 / 2 + (n - x1) * (n - x1 - 1) / 2\n        }\n        0\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1jh22he0.scala:60)\n\tat Problem.main(tmp1jh22he0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Generate the list of\
    \ n car speeds of the right to left cars\n        // This generation consists\
    \ of n steps, each step taking constant time.\n        // The generation takes\
    \ O(n) time.\n        val left = for (i <- 1 to n.toInt) yield scala.util.Random.nextInt(n.toInt)\n\
    \        // Generate the list of n car speeds of the left to right cars\n    \
    \    // This generation consists of n steps, each step taking constant time.\n\
    \        // The generation takes O(n) time.\n        val right = for (i <- 1 to\
    \ n.toInt) yield scala.util.Random.nextInt(n.toInt)\n        // Sort the left\
    \ to right cars by their speed.\n        // This sorting takes O(n * log(n)) time\n\
    \        val sortedLeft = left.sortWith(_ < _)\n        // Sort the right to left\
    \ cars by their speed.\n        // This sorting takes O(n * log(n)) time\n   \
    \     val sortedRight = right.sortWith(_ < _)\n        // The cars don't collide\
    \ if they have the same speed.\n        // So we should consider only cars with\
    \ distinct speeds.\n        // Left to right cars:\n        // i) Remove duplicates\
    \ - O(n) time\n        // ii) Filter out cars with duplicate speeds - O(n) time\n\
    \        // Total - O(n) time\n        val leftDistinct = sortedLeft.distinct.filter\
    \ { case (x) => sortedLeft.count(_ == x) == 1 }\n        // Right to left cars:\n\
    \        // i) Remove duplicates - O(n) time\n        // ii) Filter out cars with\
    \ duplicate speeds - O(n) time\n        // Total - O(n) time\n        val rightDistinct\
    \ = sortedRight.distinct.filter { case (x) => sortedRight.count(_ == x) == 1 }\n\
    \        // For each pair of left to right car c1 and right to left car c2,\n\
    \        // we compute the time at which they collide.  For each such collision,\n\
    \        // we output if this time is the earliest time at which some other\n\
    \        // cars collide.  If it is, then we count it as a collision.\n      \
    \  // If not, then we don't count it\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp75m98s8t.scala:44:5\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660012824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var running_right = 0\n\
    \        var running_left = 0\n        var index = 0\n        var numCollisions\
    \ = 0\n        var collisionMapping = new Array[Long](n.toInt)\n        for (index\
    \ <- 1 to n.toInt) {\n            var pos = index\n            var s = 0\n   \
    \         for (s <- 1 to 100) {\n                pos = (pos * (pos + 1) / 2) %\
    \ n.toInt\n            }\n            if (pos == 0) {\n                running_right\
    \ += 1\n            }\n            else {\n                running_left += 1\n\
    \                collisionMapping(pos - 1) += 1\n            }\n        }\n  \
    \      for (index <- 0 to n.toInt - 1) {\n            if (collisionMapping(index)\
    \ > 0) {\n                numCollisions += (collisionMapping(index) * running_right)\n\
    \            }\n        }\n        return numCollisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc9pjerx6.scala:34:30 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                numCollisions += (collisionMapping(index)\
    \ * running_right)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                value += is not a member of Int - did you mean\
    \ Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660012824
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val factorials = new Array[Long](n.toInt\
    \ + 1)\n        factorials(0) = 1\n        for (i <- 1 to n.toInt) factorials(i)\
    \ = factorials(i - 1) * i\n        factorials(n.toInt) / (factorials(n.toInt /\
    \ 2) * factorials(n.toInt / 2))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3ra9ys9c.scala:19)\n\tat Problem.main(tmp3ra9ys9c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012824
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n      var left = Array.ofDim[Int](n.toInt)\n\
    \      var right = Array.ofDim[Int](n.toInt)\n      var collisions = 0\n     \
    \ var i = 0\n      while (i < n) {\n        left(i.toInt) = i.toInt + 1\n    \
    \    right(i.toInt) = n.toInt - i\n        i += 1\n      }\n      var j = 0\n\
    \      while (j < n) {\n        var k = 0\n        while (k < n) {\n         \
    \ if (left(j) == right(k)) collisions += 1\n          k += 1\n        }\n    \
    \    j += 1\n      }\n      collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_2afwm2c.scala:34)\n\tat Problem.main(tmp_2afwm2c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012824
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var result = 0L\n    \
    \    var sum = 0L\n        for (i <- 1 to n.toInt) {\n            sum += i\n \
    \           result += sum\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwmq1pj2t.scala:23)\n\tat Problem.main(tmpwmq1pj2t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012825
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // your code here\n  \
    \      0\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpssg78i2d.scala:17)\n\tat Problem.main(tmpssg78i2d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012830
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var ret = 0L\n       \
    \ // Brute force, but it works.\n        for (i <- 1L to n) ret += i * (n - i\
    \ + 1)\n        ret\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsdvdsufm.scala:20)\n\tat Problem.main(tmpsdvdsufm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // how many collisions\
    \ occur if there are c1 cars driving left to right and c2 cars driving right to\
    \ left\n        def carRaceCollision(c1 : Long, c2 : Long) : Long = {\n      \
    \      if (c1 == 0 || c2 == 0) 0\n            else if (c1 == 1 && c2 == 1) 1\n\
    \            else if (c1 >= 2) (c1 - 1) * carRaceCollision(c1 - 1, c2) + carRaceCollision(c1\
    \ - 1, c2 + 1)\n            else carRaceCollision(c2, c1)\n        }\n       \
    \ carRaceCollision(n, n)\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\
    \tat Problem$.carRaceCollision$1(tmp87ey60_1.scala:17)\n\tat Problem$.carRaceCollision$1(tmp87ey60_1.scal"
  stdout: ''
  timestamp: 1660012832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n    \tval list = List.range(1,\
    \ n.toInt + 1)\n    \tlist.map(BigInt(_)).product\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgkjb2k7s.scala:14:8\
    \ ---------------------\e[0m\e[0m\n\e[31m14 |\e[0m    \tlist.map(BigInt(_)).product\n\
    \e[31m\e[31m   |\e[0m    \t^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \   \tFound:    BigInt\n\e[31m   |\e[0m    \tRequired: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660012832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n      // We assume here that the\
    \ n cars driving left to right are of the form i where i is a positive integer.\n\
    \      // All i are distinct.\n      // Similarly, we assume that the n cars driving\
    \ right to left are of the form -i.\n      // All -i are distinct.\n      // The\
    \ i's and -i's are randomly assigned to the cars.\n      // We want to compute\
    \ the probability that at most one collision happens.\n      // The random permutation\
    \ of the cars is not uniformly random.  However, we assume that it is.\n     \
    \ // This is because the uniform random generator is too slow.\n      // The formula\
    \ is: (1 / (i!)) * (1 / (-i)!) * (n! / (n - 2)!)\n      // An important point\
    \ here is that we assume n >= 2.\n      if (n < 2) return 0\n      val nf = (1\
    \ to n.toInt).product\n      val collisionCount = (2 to n.toInt).map(i => {\n\
    \        val nDividedByi = nf / (1 to i).product\n        val nMinusiFactorial\
    \ = (1 to (n - i).toInt).product\n        val nDividedBy2 = nf / (1 to 2).product\n\
    \        val nMinus2Factorial = (1 to (n - 2).toInt).product\n        nDividedByi\
    \ * nMinusiFactorial * nDividedBy2 * nMinus2Factorial\n      }).sum\n      //\
    \ After a collision, n - 2 cars remain in the track and they move away from each\
    \ other.\n      // We want to determine whether there is another collision.\n\
    \      // The probability that there is another collision is (1 / (n - 2)!) ^\
    \ 2.\n      // This is because the cars are moving in the same speed and in the\
    \ same straight line.\n      // Therefore, the second collision happens at the\
    \ same place as the first collision.\n      // If two cars collide, it is very\
    \ likely that there will be another collision.\n      // Therefore, in the case\
    \ of 2 or more collisions, we will assume that there are an infinite number of\
    \ collisions.\n      if (collisionCount == 0) 0\n      else if (collisionCount\
    \ > 1) Long.MaxValue\n      else\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpf3ba50nj.scala:41:10 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m      \e[33melse\e[0m\n\e[31m\e[31m   |\e[0m        \
    \  ^\e[0m\n\e[31m   |\e[0m          expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660012830
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Assume that the cars\
    \ are labelled 0..n-1 and n..2n-1.\n        // Assume that the left-to-right cars\
    \ are sorted in increasing order, and the right-to-left\n        // cars are sorted\
    \ in decreasing order, with all cars starting out at the same position.\n    \
    \    // The collisions occur precisely when the left-to-right cars take the place\
    \ of the right-to-left cars.\n        // There are n of them.\n        n\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmvccldo4.scala:21)\n\tat Problem.main(tmpmvccldo4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012832
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Note that two cars\
    \ that are going in the same direction will never collide.\n        // Thus, there\
    \ are exactly 2 * n * (n - 1) ways that two cars can collide.\n        // Let's\
    \ compute the probability that a car moving left to right will collide\n     \
    \   // with a car moving right to left.\n        // Let's fix a car moving left\
    \ to right.\n        // Conditioned on this car moving left to right, the probability\
    \ that the collision\n        // between this car and the car moving right to\
    \ left happens is 1 / (2 * n - 1)\n        // (because there are 2 * n - 1 cars\
    \ going in that direction).\n        // Since each car moving left to right is\
    \ equally likely to collide with any other\n        // car moving right to left,\
    \ the expected number of collisions is:\n        // 2 * n * (n - 1) * 1 / (2 *\
    \ n - 1)\n        // = n * (n - 1) / (n - 1)\n        // = n\n        n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp65g3ibbo.scala:29)\n\tat Problem.main(tmp65g3ibbo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n\tdef gcd(a : Long, b : Long)\
    \ : Long = {\n\t    if (b == 0) a else gcd(b, a % b)\n\t}\n\tdef lcm(a : Long,\
    \ b : Long) : Long = {\n\t    a * b / gcd(a, b)\n\t}\n\tval m = n / 2\n\t(m -\
    \ 1) * m * lcm(n, n - 2) / 2\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpipkbk222.scala:21:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab\n\e[31m   |\e[0m   Latest indent   : 4\
    \ spaces\n1 error found\n"
  stdout: ''
  timestamp: 1660012829
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val pairs = ListBuffer[(Int,\
    \ Int)]()\n        for (i <- 0 until n.toInt) pairs += ((i, i))\n        var count\
    \ = 0\n        for (i <- 0 until n.toInt) {\n            var j = 0\n         \
    \   while (j < n.toInt) {\n                if (pairs(i)._1 > pairs(j)._2) count\
    \ += 1\n                j += 1\n            }\n        }\n        count\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprcrvzlhu.scala:26)\n\tat Problem.main(tmprcrvzlhu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Using pigeonhole principle.\n\
    \        var collisions = 0L\n        var carMovedSoFar = 0L\n        while (carMovedSoFar\
    \ < n) {\n            carMovedSoFar += 1\n            if (carMovedSoFar % n ==\
    \ 0) collisions += 1\n        }\n        collisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3757rs4g.scala:23)\n\tat Problem.main(tmp3757rs4g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        def car(x : Long, s :\
    \ Int) = (x, s)\n        // TODO:  This is an inefficient solution.  In an actual\
    \ interview you would be\n        // expected to come up with a solution that's\
    \ a lot more efficient.\n        val cars : Array[(Long, Int)] = new Array[(Long,\
    \ Int)](2 * n.toInt)\n        for (i <- 0 until n.toInt) {\n            cars(i)\
    \ = car(i.toLong, 1)\n            cars(i + n.toInt) = car(i.toLong, -1)\n    \
    \    }\n        cars.sortBy(e => e._1)\n        var collisions = 0\n        var\
    \ currentTime = 0L\n        var i = 0\n        while (i < 2 * n.toInt) {\n   \
    \         val numCarsLeft = 2 * n.toInt - i\n            //println(i)\n      \
    \      val (x, speed) = cars(i)\n            val currentTime2 = x / abs(speed).toLong\n\
    \            //println(\"currentTime = \" + currentTime)\n            //println(\"\
    currentTime2 = \" + currentTime2)\n            val del = currentTime2 - currentTime\n\
    \            //println(\"del = \" + del)\n            if (del > 0) {\n       \
    \         val del2 = del * speed\n                //println(\"del2 = \" + del2)\n\
    \                collisions += (numCarsLeft * (numCarsLeft - 1) / 2) * del2\n\
    \                currentTime = currentTime2\n            }\n            i += 1\n\
    \        }\n        collisions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeblj94np.scala:37:27 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                collisions += (numCarsLeft * (numCarsLeft\
    \ - \e[31m1\e[0m) / \e[31m2\e[0m) * del2\n\e[31m\e[31m   |\e[0m              \
    \  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not a member\
    \ of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660012834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We first deal with\
    \ the case where n is odd.\n        // Suppose n is odd.  Then n = 2k + 1 for\
    \ some k.\n        // Imagine a 2D plane with the y-axis as the line of cars traveling\
    \ right to left,\n        // and the x-axis as the line of cars traveling left\
    \ to right.\n        // The cars traveling right to left are evenly spread apart\
    \ at distance 1, starting\n        // from y = 0.  The cars traveling left to\
    \ right are spread apart at distance 1,\n        // starting from x = 0.\n   \
    \     // The i-th car traveling right to left has initial coordinates (0, i).\n\
    \        // The i-th car traveling left to right has initial coordinates (i, 0).\n\
    \        // In 1 second, each car travels distance 2.\n        // At time t, the\
    \ i-th car traveling right to left is at location (0, 2it).\n        // The i-th\
    \ car traveling left to right is at location (2it, 0).\n        // We say that\
    \ the car traveling right to left is \"active\" at time t if it hasn't\n     \
    \   // been caught by a car traveling left to right;  the car traveling left to\
    \ right\n        // is \"active\" at time t if it hasn't been caught by a car\
    \ traveling right to left.\n        // At time t, the i-th car traveling right\
    \ to left is active if and only if\n        // 2it is not divisible by 2k + 1,\
    \ or equivalently if and only if 2it is even.\n        // At time t, the i-th\
    \ car traveling left to right is active if and only if\n        // 2it is not\
    \ divisible by 2k + 1, or equivalently if and only if 2it is even.\n        //\
    \ We say that a car traveling right to left \"collides\" at time t if it collides\n\
    \        // with a car traveling left to right at time t.\n        // At time\
    \ t, a car traveling right to left collides if and only if 2it is even.\n    \
    \    // At time t, a car traveling left to right collides if and only if 2it is\
    \ even.\n        // We want to compute the number of collisions for all cars traveling\
    \ right to left\n        // and all cars traveling left to right.\n        //\
    \ A car traveling right to left coll\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxhjy_quu.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We first deal with the case where n is odd.\e[0m\n\e[31m14 |\e[0m     \
    \   \e[34m// Suppose n is odd.  Then n = 2k + 1 for some k.\e[0m\n\e[31m15 |\e\
    [0m        \e[34m// Imagine a 2D plane with the y-axis as the line of cars traveling\
    \ right to left,\e[0m\n\e[31m16 |\e[0m        \e[34m// and the x-axis as the line\
    \ of cars traveling left to right.\e[0m\n\e[31m17 |\e[0m        \e[34m// The cars\
    \ traveling right to left are evenly spread apart at distance 1, starting\e[0m\n\
    \e[31m18 |\e[0m        \e[34m// from y = 0.  The cars traveling left to right\
    \ are spread apart at distance 1,\e[0m\n\e[31m19 |\e[0m        \e[34m// starting\
    \ from x = 0.\e[0m\n\e[31m20 |\e[0m        \e[34m// The i-th car traveling right\
    \ to left has initial coordinates (0, i).\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ The i-th car traveling left to right has initial coordinates (i, 0).\e[0m\n\e\
    [31m22 |\e[0m        \e[34m// In 1 second, each car travels distance 2.\e[0m\n\
    \e[31m23 |\e[0m        \e[34m// At time t, the i-th car traveling right to left\
    \ is at location (0, 2it).\e[0m\n\e[31m24 |\e[0m        \e[34m// The i-th car\
    \ traveling left to right is at location (2it, 0).\e[0m\n\e[31m25 |\e[0m     \
    \   \e[34m// We say that the car traveling right to left is \"active\" at time\
    \ t if it hasn't\e[0m\n\e[31m26 |\e[0m        \e[34m// been caught by a car traveling\
    \ left to right;  the car traveling left to right\e[0m\n\e[31m27 |\e[0m      \
    \  \e[34m// is \"active\" at time t if it hasn't been caught by a car traveling\
    \ right to left.\e[0m\n\e[31m28 |\e[0m        \e[34m// At time t, the i-th car\
    \ traveling right to left is active if and only if\e[0m\n\e[31m29 |\e[0m     \
    \   \e[34m// 2it is not divisible by 2k + 1, or equ"
  stdout: ''
  timestamp: 1660012833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We can do this using\
    \ a sweep line algorithm.\n        // Each car is a point (x, y) such that y denotes\
    \ the direction of motion.\n        // Note that if x1 < x2 and y1 < y2, then\
    \ the car at (x1, y1) collides with\n        // the car at (x2, y2).  Also, we\
    \ can use the line y = x and the line y = -x\n        // to chop up the plane.\n\
    \        // If we do that, we get 4 quadrants, Q1, Q2, Q3, Q4, where Q1 = {(x,\
    \ y) : y > x and y > -x}\n        // The cars in Q1 and Q3 never collide, so we\
    \ only need to find the number of collisions\n        // in Q2 and Q4.\n     \
    \   // The number of collisions in Q2 and Q4 is the same and equal to half the\
    \ number of\n        // collisions in Q2.  So we only need to find the number\
    \ of collisions in Q2.\n        // This can be done by sorting the points by x\
    \ coordinate and then sweeping\n        // from left to right.  So for each point,\
    \ we sweep from that point to the right.\n        // Each new point that we scan\
    \ adds one more collision.\n        // Let's denote the first cars by (x1, y1),\
    \ ..., (xn, yn) and the second cars by\n        // (w1, z1), ..., (wn, zn).  Note\
    \ that zi = -yi, so we only need to compute the following.\n        // val a =\
    \ (1 to n).map(i => (xi, yi)).sortBy(_._1)\n        // val b = (1 to n).map(i\
    \ => (wi, zi)).sortBy(_._1)\n        // Note that the cars only collide if yi\
    \ < zi, i.e. if yi < -yi.  So we only need to\n        // figure out how many\
    \ cars have yi < -yi.\n        // This can be done by first computing a new point\
    \ (xi, -yi) for each (xi, yi).\n        // We then sort this set of points by\
    \ x coordinate.  Given a point (xi, -yi),\n        // all the\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvuqwdtrk.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// We can do this using a sweep line algorithm.\e[0m\n\e[31m14 |\e[0m    \
    \    \e[34m// Each car is a point (x, y) such that y denotes the direction of\
    \ motion.\e[0m\n\e[31m15 |\e[0m        \e[34m// Note that if x1 < x2 and y1 <\
    \ y2, then the car at (x1, y1) collides with\e[0m\n\e[31m16 |\e[0m        \e[34m//\
    \ the car at (x2, y2).  Also, we can use the line y = x and the line y = -x\e\
    [0m\n\e[31m17 |\e[0m        \e[34m// to chop up the plane.\e[0m\n\e[31m18 |\e\
    [0m        \e[34m// If we do that, we get 4 quadrants, Q1, Q2, Q3, Q4, where Q1\
    \ = {(x, y) : y > x and y > -x}\e[0m\n\e[31m19 |\e[0m        \e[34m// The cars\
    \ in Q1 and Q3 never collide, so we only need to find the number of collisions\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// in Q2 and Q4.\e[0m\n\e[31m21 |\e[0m     \
    \   \e[34m// The number of collisions in Q2 and Q4 is the same and equal to half\
    \ the number of\e[0m\n\e[31m22 |\e[0m        \e[34m// collisions in Q2.  So we\
    \ only need to find the number of collisions in Q2.\e[0m\n\e[31m23 |\e[0m    \
    \    \e[34m// This can be done by sorting the points by x coordinate and then\
    \ sweeping\e[0m\n\e[31m24 |\e[0m        \e[34m// from left to right.  So for each\
    \ point, we sweep from that point to the right.\e[0m\n\e[31m25 |\e[0m        \e\
    [34m// Each new point that we scan adds one more collision.\e[0m\n\e[31m26 |\e\
    [0m        \e[34m// Let's denote the first cars by (x1, y1), ..., (xn, yn) and\
    \ the second cars by\e[0m\n\e[31m27 |\e[0m        \e[34m// (w1, z1), ..., (wn,\
    \ zn).  Note that zi = -yi, so we only need to compute the following.\e[0m\n\e\
    [31m28 |\e[0m        \e[34m// val a = (1 to n).map(i => (xi, yi)).sortBy(_._1)\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// val b = (1 to n).map(i "
  stdout: ''
  timestamp: 1660012833
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        0\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppv1mg_kz.scala:16)\n\tat Problem.main(tmppv1mg_kz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012833
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Subtask 1:  Prove this\
    \ has at least n^2 / 3 + 1 collisions.\n        // Subtask 2:  Prove this has\
    \ at most n^2 collisions.\n        // Subtask 3:  Find a way to compute this in\
    \ O(n^2) time.\n        0\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8hbcsb_4.scala:19)\n\tat Problem.main(tmp8hbcsb_4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012833
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val lSet = ArrayBuffer[Long]()\n\
    \        val rSet = ArrayBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n \
    \           val num = (random * 1000000000).toLong\n            val rand = random\n\
    \            if (rand < 0.5) {\n                lSet += num\n            } else\
    \ {\n                rSet += num\n            }\n        }\n        lSet.sorted.zip(rSet.sorted).filter(p\
    \ => p._1 == p._2).size\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpef1dbwzo.scala:27)\n\tat Problem.main(tmpef1dbwzo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012835
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        //assert(n > 0)\n    \
    \    // brute force solution\n        var collisions = 0\n        for (l <- 1\
    \ to n.toInt) {\n            for (r <- 1 to n.toInt) {\n                collisions\
    \ += 1\n            }\n        }\n        collisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012835
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        def f(n : Long) : Long\
    \ = {\n            if (n == 0) 0\n            else if (n == 1) 0\n           \
    \ else if (n == 2) 1\n            else f(n - 1) + (n - 1)\n        }\n       \
    \ f(n)\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpedbb64g_.scala:22)\n\tat Problem.main(tmpedbb64g_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        /*\n        Right:\n \
    \       -1, -2, -3, -4, ..., -n\n        Left:\n        1, 2, 3, 4, ..., n\n \
    \       Left-right:\n        1, 2, 3, 4, ..., n, -1, -2, -3, -4, ..., -n\n   \
    \     The cars driving left to right are at positions 1, 2, 3, 4, ..., n, respectively,\n\
    \        and the cars driving right to left are at positions -1, -2, -3, -4, ...,\
    \ -n, respectively.\n        When two cars collide, the one on the left will pass\
    \ the one on the right.\n        Therefore, the answer is the number of places\
    \ where the left-right set of cars\n        is not sorted.\n        */\n     \
    \   var count = 0L\n        var pos = 1L\n        var neg = -1L\n        while\
    \ (pos <= n && neg >= -n) {\n            if (pos == neg) {\n                count\
    \ += n - pos + 1\n                pos += 1\n                neg -= 1\n       \
    \     } else if (pos < neg) {\n                pos += 1\n            } else {\n\
    \                neg -= 1\n            }\n        }\n        count\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdi6v_1ag.scala:43)\n\tat Problem.main(tmpdi6v_1ag.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012835
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The number of collisions\
    \ between two cars is the product of the number of\n        // cars on each side.\
    \  This is because if you have a fixed number of cars in one direction,\n    \
    \    // then if you have n cars in the other direction, there are exactly n collisions.\n\
    \        // As a result, we can model this as a binomial coefficient.\n      \
    \  n * n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var counter = 0;\n   \
    \     var cars = new HashMap[Long, Long]();\n        // For each car moving left\
    \ to right, we store its position in cars.\n        for (i <- 1 to n.toInt) {\n\
    \            var p = (i.toLong*i.toLong) % n;\n            // If a car moving\
    \ right to left passes through the position of a car moving left to right,\n \
    \           // there will be a collision\n            if (cars.contains(p)) {\n\
    \                counter += cars(p);\n            }\n            // Update cars\
    \ to keep track of the number of cars moving left to right at each position\n\
    \            if (cars.contains(p)) {\n                cars(p) += 1;\n        \
    \    } else {\n                cars(p) = 1;\n            }\n        }\n      \
    \  counter;\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphx0fzyjn.scala:21:24 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                counter += cars(p);\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value += is\
    \ not a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660012834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // x-position of the nth\
    \ car that's moving left to right\n        def x_i(i : Long) : Long = i\n    \
    \    // x-position of the nth car that's moving right to left\n        def y_i(i\
    \ : Long) : Long = -i\n        val x = (1L to n).map(x_i).toList\n        val\
    \ y = (1L to n).map(y_i).toList\n        var t = 0L\n        var p = 0L\n    \
    \    for (xi <- x) {\n            var j = p\n            var c = false\n     \
    \       for (yi <- y.slice(p, n.toInt)) {\n                if (c) return t\n \
    \               if (xi == yi) {\n                    t += 1\n                \
    \    c = true\n                }\n                else j += 1\n            }\n\
    \            p = j\n        }\n        return t\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp10tihi53.scala:24:31\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mfor\e[0m (yi\
    \ <- y.slice(p, n.toInt)) {\n\e[31m\e[31m   |\e[0m                           \
    \    ^\e[0m\n\e[31m   |\e[0m                               Found:    (p : Long)\n\
    \e[31m   |\e[0m                               Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660012834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // treat the cars that\
    \ are driving left to right as if they're driving from 0 to n.\n        // treat\
    \ the cars that are driving right to left as if they're driving from n to 0.\n\
    \        // the position of the ith left-to-right car at time t is i + t.\n  \
    \      // the position of the ith right-to-left car at time t is n - i - t.\n\
    \        // if the positions of two cars ever become equal, it's a collision.\n\
    \        // two positions are equal iff\n        // i + t = n - j - t\n      \
    \  // i - j = n - 2t\n        // and 0 <= t <= n.\n        // we want to find\
    \ the number of times i and j satisfy i - j = n - 2t.\n        // the total number\
    \ of times i - j is equal to k is given by\n        // 1 + 2 + ... + (n - 1).\n\
    \        // find the number of times k = n - 2t.\n        val sum = (n - 1) *\
    \ n / 2\n        // number of t such that n - 2t >= 0 is given by floor(n / 2).\n\
    \        val times = n / 2\n        // sum of 1 + 2 + ... + (n - 1) is given by\
    \ n * (n - 1) / 2\n        val sum2 = times * (n - 1)\n        sum - sum2\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb__c5cpv.scala:34)\n\tat Problem.main(tmpb__c5cpv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val collides = Array.fill(2\
    \ * n.toInt)(false)\n        for (i <- 1 to n.toInt) {\n            val loc =\
    \ i * i * i - 1\n            collides(loc) = true\n        }\n        collides.zipWithIndex.filter(_._1).map(_._2\
    \ - n.toInt).map(abs).sum\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 7 out of bounds for length\
    \ 4\n\tat Problem$.carRaceCollision$$anonfun$1(tmp6wic3omy.scala:16)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.carRaceCollision(tmp6wic3omy.scala:17)\n\
    \tat Problem$.main(tmp6wic3omy.scala:21)\n\tat Problem.main(tmp6wic3omy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012843
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // So the ith car from\
    \ the left is at the distance i from the origin.\n        // The car starts at\
    \ time 0, reaches the origin at time 1, and reaches\n        // the point at distance\
    \ (2 * n - i) at time 2.  So the car\n        // spends time 1 at distance i and\
    \ time 1 at distance (2 * n - i).\n        // The car is moving right to left\
    \ when the time is in the range\n        // [i/(2 * n), (2 * n - i)/(2 * n)].\n\
    \        // So the time that the car will collide with the car\n        // at\
    \ distance (2 * n - i) is min(i/(2 * n), (2 * n - i)/(2 * n))\n        // this\
    \ is the same as i / (2 * n).\n        return (1 to 2 * n.toInt).map(i => i.toLong\
    \ / (2 * n)).sum\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3vimic7c.scala:25)\n\tat Problem.main(tmp3vimic7c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        if (n == 0) { 0 }\n  \
    \      else {\n            val input = Console.readLine().split(\" \").map(_.toLong)\n\
    \            input.groupBy(_ => _).mapValues(_.size).filter(_._2 >= 2).map(_._2\
    \ - 1).sum\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6qp8lskh.scala:15:32 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e[36minput\e[0m = Console.readLine().split(\e\
    [31m\" \"\e[0m).map(_.toLong)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        value readLine is not a member of\
    \ object Console\n1 error found\n"
  stdout: ''
  timestamp: 1660012839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n\tval comb = 1L + 10*(10-1)/2\n\
    \tval comb3 = comb*comb*comb\n\tif (n < 10) 0L\n\telse 1L*comb3*(n - 10) + carRaceCollision(n\
    \ - comb3)\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpupoyp_ms.scala:17:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab\n\e[31m   |\e[0m   Latest indent   : 4\
    \ spaces\n1 error found\n"
  stdout: ''
  timestamp: 1660012838
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n\t// Suppose we're dealing with\
    \ only left to right cars.  An interval of length l\n\t// starts at left point\
    \ a and ends at right point b = a + l.\n\t// We're interested in the set of intervals\
    \ that are contained within another\n\t// interval.  Any two cars within this\
    \ set will collide.\n\t// Consider all of the possible values of a.  The number\
    \ of such intervals of length\n\t// l containing a is n - l + 1.  Thus the number\
    \ of such contained intervals of length\n\t// l is (n - l + 1) + (n - l + 1) +\
    \ ... + (n - l + 1) = (n - l + 1)^2.\n\t// The total number of contained intervals\
    \ is simply the sum from l = 1 to n.\n\tvar total : Long = 0\n\tfor (l <- 1 to\
    \ n.toInt) {\n\t    total += (n - l + 1) * (n - l + 1)\n\t}\n\t// For each interval,\
    \ we've counted two collisions.  So we divide by 2.\n\treturn total / 2\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmprwsuk8ao.scala:27:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab\n\e[31m   |\e[0m   Latest indent   : 4\
    \ spaces\n1 error found\n"
  stdout: ''
  timestamp: 1660012839
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        return 0\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxo8cnwbv.scala:16)\n\tat Problem.main(tmpxo8cnwbv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // car race collision\
    \ is a very special case of two-sets-intersection problem\n        // in which\
    \ the two sets are sorted.  The two sets are {x1, x2, ..., xn} and\n        //\
    \ {xn, xn-1, ..., x1}.  When we run a merge algorithm of the two sorted lists,\n\
    \        // we can count the collisions in the same time because when a car xi\
    \ is inserted\n        // in the merge output, it collides with all existing cars\
    \ in the output that are\n        // in the right of xi.\n        val (a, b) =\
    \ (0L to n, n to 0 by -1)\n        val xs = ((0L to n) zip (n to 0 by -1)).toList\n\
    \        val (carA, carB) = (0L to n, n to 0 by -1)\n        val c = carA.zip(carB).toList\n\
    \        val (xs1, xs2) = c.splitAt(c.length / 2)\n        val (car1, car2) =\
    \ (0L to n, n to 0 by -1)\n        val c1 = car1.zip(car2).toList\n        val\
    \ (y1, y2) = c1.splitAt(c1.length / 2)\n        val x = y1.map(t => t._1 - t._2)\n\
    \        val xx = y2.map(t => t._1 - t._2)\n        def k(xs : List[Long]) : List[Long]\
    \ = {\n            if (xs.length == 1) xs\n            else {\n              \
    \  val ys = k(xs.splitAt(xs.length / 2)._1)\n                val zs = k(xs.splitAt(xs.length\
    \ / 2)._2)\n                List.concat(ys, zs)\n            }\n        }\n  \
    \      val z = k(x).zip(k(xx))\n        def solve(xs : List[(Long, Long)]) : Long\
    \ = {\n            if (xs.length == 1) 0\n            else {\n               \
    \ val (a, b) = xs.splitAt(xs.length / 2)\n                solve(a) +\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpswg4irz_.scala:42:26 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                solve(a) +\n\e[31m\e[31m   |\e[0m   \
    \                       ^\e[0m\n\e[31m   |\e[0m                          expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpswg4irz_.scala:53:0 ----------------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpswg4irz_.scala:52:1 ---------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpswg4irz_.scala:44:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m44 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660012842
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val a = new Array[Long](2\
    \ * n.toInt)\n        val rand = new scala.util.Random(0)\n        for (i <- 0\
    \ until n.toInt) {\n            val x = rand.nextInt(a.length)\n            val\
    \ y = rand.nextInt(a.length)\n            val temp = a(x)\n            a(x) =\
    \ a(y)\n            a(y) = temp\n        }\n        val b = new Array[Long](2\
    \ * n.toInt)\n        for (i <- 0 until n.toInt) {\n            b(i) = a(i)\n\
    \            b(i + n.toInt) = a(i)\n        }\n        val c = new Array[Long](2\
    \ * n.toInt)\n        val d = new Array[Long](2 * n.toInt)\n        b.copyToArray(c)\n\
    \        b.copyToArray(d)\n        c.sortWith(_ < _)\n        d.sortWith(_ > _)\n\
    \        var ans = 0L\n        for (i <- 0 until 2 * n.toInt) {\n            val\
    \ idx1 = c.indexOf(b(i))\n            val idx2 = d.indexOf(b(i))\n           \
    \ ans += idx1 - i\n            ans += idx2 - i\n        }\n        ans\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf0nlzadr.scala:43)\n\tat Problem.main(tmpf0nlzadr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012844
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        if (n <= 1) return 0\n\
    \        val m = n / 2\n        val l = List.range(1, m.toInt + 1)\n        val\
    \ r = List.range(-m.toInt, 0)\n        val s = l.toSet ++ r.toSet\n        val\
    \ x = s.map(x => abs(x)).sum\n        x * 2 - n * (n - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu5w_zkpv.scala:22)\n\tat Problem.main(tmpu5w_zkpv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012845
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var collisions = 0L\n\
    \        var left = ArrayBuffer[Int]()\n        var right = ArrayBuffer[Int]()\n\
    \        for (i <- 1 to n.toInt) {\n            left += i\n            right +=\
    \ i\n        }\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to\
    \ n.toInt) {\n                if (left(i - 1) == right(j - 1)) collisions += 1\n\
    \            }\n        }\n        return collisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8he2ix_8.scala:28)\n\tat Problem.main(tmp8he2ix_8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This problem can be\
    \ solved using a sieve of Eratosthenes.\n        // The order in which cars meet\
    \ is determined by their speed,\n        // so one can sort the cars by speed.\n\
    \        // Let's use index i to represent the i-th fastest car.\n        // Now,\
    \ let's define an infinite list, where the i-th element in this list is\n    \
    \    // equal to the i-th car.\n        val carList = List.range(1, n + 1)\n \
    \       // Now, we can use the sieve of Eratosthenes to find the number of collisions.\n\
    \        carList.foldLeft(0) {\n            case (collisions, car) =>\n      \
    \          collisions + car - (carList.indexOf(car) + 1)\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpui4n1cvd.scala:19:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mcarList\e[0m = List.range(\e\
    [31m1\e[0m, n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                         \
    \                 ^\e[0m\n\e[31m   |\e[0m                                No implicit\
    \ Ordering defined for AnyVal.\n1 error found\n"
  stdout: ''
  timestamp: 1660012842
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n      return floor(sqrt(n)).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfg04obun.scala:16)\n\tat Problem.main(tmpfg04obun.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012844
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Each car is represented\
    \ by a number.\n        // There are n cars moving left to right, and n cars moving\
    \ right to left.\n        // These are indexed 0 to n-1, and n to 2n-1, respectively.\n\
    \        // For example, if there are 4 cars on the road and car 1 moving right\
    \ to left\n        // collides with car 3 moving left to right, we say that there\
    \ was a collision\n        // at index 3.\n        val collisions = HashMap[Long,\
    \ Long]()\n        // Positions of cars moving left to right are held in the following\
    \ array\n        val cars : Array[Long] = new Array[Long](n.toInt)\n        for\
    \ (i <- 0 until n.toInt) cars(i) = i + 1\n        // We will use this array to\
    \ compare pairs of cars moving left to right\n        // and pairs of cars moving\
    \ right to left\n        val cars2 : Array[Long] = new Array[Long](n.toInt)\n\
    \        for (i <- 0 until n.toInt) cars2(i) = i + 1\n        for (i <- 0 until\
    \ n.toInt) {\n            for (j <- 0 until n.toInt) {\n                val idx\
    \ = min(cars(i), cars2(j))\n                if (collisions.contains(idx)) collisions(idx)\
    \ += 1\n                else collisions(idx) = 1\n            }\n        }\n \
    \       // Now, process cars moving right to left\n        for (i <- 0 until n.toInt)\
    \ cars(i) = i + n + 1\n        for (i <- 0 until n.toInt) {\n            for (j\
    \ <- 0 until n.toInt) {\n                val idx = min(cars(i), cars2(j))\n  \
    \              if (collisions.contains(idx)) collisions(idx) += 1\n          \
    \      else collisions(idx) = 1\n            }\n        }\n        var count =\
    \ 0L\n        for (i <- collisions.keys) {\n            count += collisions(i)\
    \ * (collisions(i) - 1) / 2\n        }\n        count\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwvn_m6q3.scala:50)\n\tat Problem.main(tmpwvn_m6q3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012845
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // the idea is to treat\
    \ each car as a point on the number line, instead of treating it as\n        //\
    \ a rectangle.  Then, we just need to count the number of collisions between the\
    \ two sets of\n        // points.\n        // The first set of points consists\
    \ of the points 1, 2, 3, ..., n, and the other set consists of\n        // the\
    \ points -1, -2, -3, ..., -n.\n        // If a collision between the two sets\
    \ of points occurs, we must have\n        //    x1 < x2, x1 > -x2, where x1 is\
    \ a point from the first set, and x2 is a point from the second set.\n       \
    \ // or\n        //    x1 > x2, x1 < -x2.\n        // For each point x1 in the\
    \ first set, the number of points x2 in the second set that satisfy\n        //\
    \    x1 < x2, x1 > -x2\n        // is\n        //    x1 + x2 - 1, where -n <=\
    \ x2 <= n.\n        // For each point x1 in the first set, the number of points\
    \ x2 in the second set that satisfy\n        //    x1 > x2, x1 < -x2\n       \
    \ // is\n        //    x2 - x1 - 1, where -n <= x2 <= n.\n        // Therefore,\
    \ the total number of collisions between the two sets of points is\n        //\
    \    sum_i{(i + n) - 1} + sum_i{(n - i) - 1}\n        //    = 2 * sum_i{n - 1}\
    \ - sum_i{i} - sum_i{i}\n        //    = n * n - n - n * (n + 1) / 2 - n * (n\
    \ + 1) / 2\n        //    = n * n - 2 * n * (n + 1) / 2\n        //    = n * n\
    \ - n * (n + 1)\n        //    = n * (n - 1)\n        n * (n - 1)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6comoj49.scala:40)\n\tat Problem.main(tmp6comoj49.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012843
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var acc = 0L\n       \
    \ var i = 0L\n        while (i < n) {\n            acc += i\n            i +=\
    \ 1\n        }\n        acc\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzceji8jl.scala:22)\n\tat Problem.main(tmpzceji8jl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val s = new Sieve(n)\n\
    \        // suppose the cars are labeled from 1 to n.\n        // suppose you\
    \ see the collision in the perspective of an observer standing\n        // right\
    \ between the two cars.  Then the number of collisions corresponds to the number\n\
    \        // of cars on the left whose number is a divisor of the car on the right.\n\
    \        // an example:  suppose n = 10.  In this case, car 1 has 8 divisors on\
    \ the left;\n        // car 2 has 4; car 3 has 6; car 4 has 2; car 5 has 0; car\
    \ 6 has 4; car 7 has 6;\n        // car 8 has 2; car 9 has 4; car 10 has 8.  So\
    \ the total number of collisions is\n        // 8 + 4 + 6 + 2 + 0 + 4 + 6 + 2\
    \ + 4 + 8 = 48.\n        // Notice that car 5 does not have any collisions; this\
    \ corresponds to the fact that \n        // car 5 is prime.\n        // Also notice\
    \ that for every car, there's a car on the left that's a divisor of the\n    \
    \    // given car; the result is that the total number of collisions is n * n\
    \ / 2.\n        // in other words, this is basically a problem of counting the\
    \ number of prime numbers\n        // less than n.\n        // specifically, it's\
    \ not hard to see that if the cars are labeled from 1 to n, then\n        // the\
    \ car on the right with label i has (i - 1) / 2 collisions if i is even and \n\
    \        // i / 2 collisions if i is odd.  The result is that the number of collisions\
    \ is the\n        // number of even numbers less than n.\n        // the number\
    \ of even numbers less than n is just n / 2.\n        // so the total number of\
    \ collisions is n * n / 4.\n        // alternatively, the number of even numbers\
    \ less than n is n / 2 if n is even and\n        // (n - 1) / 2 if n is odd. \
    \ This means that the number of collisions is n * n / 4\n        // if n is even\
    \ and (n - 1) * (n - 1) / 4 if n is odd.\n        val sieve = s.sieve\n      \
    \  if (n % 2 == 0) {\n            n * n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv581fy2z.scala:50:0 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv581fy2z.scala:13:20\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36ms\e[0m = \e[33mnew\e[0m \e[35mSieve\e[0m(n)\n\e[31m\e[31m   |\e[0m       \
    \             ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: type Sieve\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv581fy2z.scala:49:1\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpv581fy2z.scala:41:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m41 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660012844
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var x = 0L\n        for\
    \ (i <- 1L to n) {\n            for (j <- 1L to n) {\n                if (i *\
    \ j <= n) {\n                    x += 1\n                }\n            }\n  \
    \      }\n        return x\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l)) ==\
    \ (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_9jnav88.scala:24)\n\tat Problem.main(tmp_9jnav88.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012845
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This function returns\
    \ the number of collisions for each set of cars.\n        // Cars are indexed\
    \ left to right starting from 0.\n        // If a car whose index is i is moving\
    \ from left to right,\n        // then the k-th car going from right to left will\
    \ collide with this car\n        // if k + i = n - 1.\n        // Since i = 0,\
    \ 1, ..., n - 1, if i + k = n - 1,\n        // then k = n - 1 - i.\n        //\
    \ since k = 0, 1, ..., n - 1, the possible k's are n - 1 - i, n - 2 - i, ...,\
    \ 0.\n        // If n - 1 - i is not non-negative, then there are no collisions\
    \ involving i.\n        // Otherwise, there are n - 1 - i + 1 = n - i collisions.\n\
    \        // Therefore, the total number of collisions involving the i-th car is\
    \ n - i,\n        // if n - i is non-negative.\n        // However, there are\
    \ two sets of cars, and each set gives n - i collisions.\n        // Therefore,\
    \ the total number of collisions is n * n - i - i = n^2 - 2 * i.\n        // If\
    \ n - i is negative, then this equals 0.\n        // Therefore, the total number\
    \ of collisions is n^2 - 2 * i, if n - i is non-negative.\n        // Since i\
    \ = 0, 1, ..., n - 1, the sum of the number of collisions for all cars is\n  \
    \      // (n - 0) + (n - 1) + ... + (n - (n - 1)) = (n - 0) + (n - 1) + ... +\
    \ 1.\n        // Using the formula (n * (n + 1)) / 2, this is n * (n + 1) / 2.\n\
    \        n * (n + 1) / 2\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcolln8yf.scala:35)\n\tat Problem.main(tmpcolln8yf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the cars\
    \ move 1 km per second.  So the left-to-right cars start out\n        // with\
    \ initial positions ranging from -1000000000 to -1;\n        // The right-to-left\
    \ cars start out with initial positions ranging from +1 to +1000000000\n     \
    \   // We want to find the number of pairs of cars that collide.  But there are\
    \ several restrictions\n        // 1.  A left-to-right car collides with a right-to-left\
    \ car if and only if the left-to-right car\n        // is at a smaller coordinate\
    \ than the right-to-left car.\n        // 2.  A left-to-right car does not collide\
    \ with another left-to-right car\n        // 3.  A right-to-left car does not\
    \ collide with another right-to-left car\n        // So the problem reduces to\
    \ the following.  If the initial positions of the left-to-right cars\n       \
    \ // are -x, -x+1, -x+2, ..., -1, and the initial positions of the right-to-left\
    \ cars are\n        // y, y+1, y+2, ..., 1000000000, how many such pairs of cars\
    \ are there that are within 1 km of each other?\n        // It is convenient to\
    \ think of the left-to-right cars as the points on a line, each lying 1 km apart.\n\
    \        // Similarly, the right-to-left cars can be thought of as the points\
    \ on a line, each lying 1 km apart.\n        // So the problem reduces to this.\
    \  If the points on a line are -x, -x+1, -x+2, ..., -1, and the points\n     \
    \   // on another line are y, y+1, y+2, ..., 1000000000, how many pairs of points\
    \ are within 1 km of each other?\n        // But this is just a discrete calculus\
    \ problem.  The intersection of the first line with the second line\n        //\
    \ is a rectangle of width 1 km, whose height is the length of the first line.\
    \  The length of the first line\n        // is x - (-x) = 2x.  So the intersection\
    \ has area 2x.  If x = 0, the two lines intersect only at the origin.\n      \
    \  // So the number of pairs of points that are\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphrx9slh1.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say the cars move 1 km per second.  So the left-to-right cars start\
    \ out\e[0m\n\e[31m14 |\e[0m        \e[34m// with initial positions ranging from\
    \ -1000000000 to -1;\e[0m\n\e[31m15 |\e[0m        \e[34m// The right-to-left cars\
    \ start out with initial positions ranging from +1 to +1000000000\e[0m\n\e[31m16\
    \ |\e[0m        \e[34m// We want to find the number of pairs of cars that collide.\
    \  But there are several restrictions\e[0m\n\e[31m17 |\e[0m        \e[34m// 1.\
    \  A left-to-right car collides with a right-to-left car if and only if the left-to-right\
    \ car\e[0m\n\e[31m18 |\e[0m        \e[34m// is at a smaller coordinate than the\
    \ right-to-left car.\e[0m\n\e[31m19 |\e[0m        \e[34m// 2.  A left-to-right\
    \ car does not collide with another left-to-right car\e[0m\n\e[31m20 |\e[0m  \
    \      \e[34m// 3.  A right-to-left car does not collide with another right-to-left\
    \ car\e[0m\n\e[31m21 |\e[0m        \e[34m// So the problem reduces to the following.\
    \  If the initial positions of the left-to-right cars\e[0m\n\e[31m22 |\e[0m  \
    \      \e[34m// are -x, -x+1, -x+2, ..., -1, and the initial positions of the\
    \ right-to-left cars are\e[0m\n\e[31m23 |\e[0m        \e[34m// y, y+1, y+2, ...,\
    \ 1000000000, how many such pairs of cars are there that are within 1 km of each\
    \ other?\e[0m\n\e[31m24 |\e[0m        \e[34m// It is convenient to think of the\
    \ left-to-right cars as the points on a line, each lying 1 km apart.\e[0m\n\e\
    [31m25 |\e[0m        \e[34m// Similarly, the right-to-left cars can be thought\
    \ of as the points on a line, each lying 1 km apart.\e[0m\n\e[31m26 |\e[0m   \
    \     \e[34m// So the problem reduces to this.  If the points on a line are -x,\
    \ -x+1, -x+2, ..., -1,"
  stdout: ''
  timestamp: 1660012844
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val leftToRight = (1L\
    \ to n).map(x => (x, x)).toArray\n        val rightToLeft = (1L to n).map(x =>\
    \ (n+1-x, x)).toArray\n        leftToRight.map(x => x._1).sorted.zip(leftToRight.map(x\
    \ => x._2).sorted).zip(rightToLeft.map(x => x._1).sorted.zip(rightToLeft.map(x\
    \ => x._2).sorted)).map(x => x._1._1 - x._2._1).map(x => if (x < 0) 1 else 0).sum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx6iya_wn.scala:18)\n\tat Problem.main(tmpx6iya_wn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val carsLeftToRight =\
    \ List.range(1, n + 1)\n        val carsRightToLeft = List.range(1, n + 1).reverse\n\
    \        val carsLeftToRightFirstCollision : List[Long] = carsLeftToRight.map(_\
    \ * 2 - 1)\n        val carsRightToLeftFirstCollision : List[Long] = carsRightToLeft.map(_\
    \ * 2 - 1)\n        val carsLeftToRightInBetweenCollision : List[Long] = List.range(1,\
    \ n).map(_ * 2)\n        val carsRightToLeftInBetweenCollision : List[Long] =\
    \ List.range(1, n).map(_ * 2)\n        val carsLeftToRightCollision = carsLeftToRightFirstCollision\
    \ ::: carsLeftToRightInBetweenCollision\n        val carsRightToLeftCollision\
    \ = carsRightToLeftFirstCollision ::: carsRightToLeftInBetweenCollision\n    \
    \    // Cars on the left only collide with cars on the right that have a\n   \
    \     // longer index.  As a result, the number of collisions is the sum of the\n\
    \        // minimum of the two lists, with the restriction that the car on the\
    \ right\n        // has a larger index than the car on the left.\n        carsLeftToRightCollision.zip(carsRightToLeftCollision).map(x\
    \ => min(x._1, x._2)).sum\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwd_xbx_5.scala:13:50 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mcarsLeftToRight\e[0m = List.range(\e\
    [31m1\e[0m, n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                         \
    \                         ^\e[0m\n\e[31m   |\e[0m                            \
    \    No implicit Ordering defined for AnyVal.\n\e[31m\e[31m-- Error: /tmp/tmpwd_xbx_5.scala:14:50\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m14 |\e[0m       \
    \ \e[33mval\e[0m \e[36mcarsRightToLeft\e[0m = List.range(\e[31m1\e[0m, n + \e\
    [31m1\e[0m).reverse\n\e[31m\e[31m   |\e[0m                                   \
    \               ^\e[0m\n\e[31m   |\e[0m                                No implicit\
    \ Ordering defined for AnyVal.\n\e[31m\e[31m-- Error: /tmp/tmpwd_xbx_5.scala:17:77\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m       \
    \ \e[33mval\e[0m \e[36mcarsLeftToRightInBetweenCollision\e[0m : \e[35mList\e[0m[\e\
    [35mLong\e[0m] = List.range(\e[31m1\e[0m, n).map(_ * \e[31m2\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \          ^\e[0m\n\e[31m   |\e[0m                                No implicit\
    \ Ordering defined for AnyVal.\n\e[31m\e[31m-- Error: /tmp/tmpwd_xbx_5.scala:18:77\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0m       \
    \ \e[33mval\e[0m \e[36mcarsRightToLeftInBetweenCollision\e[0m : \e[35mList\e[0m[\e\
    [35mLong\e[0m] = List.range(\e[31m1\e[0m, n).map(_ * \e[31m2\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \          ^\e[0m\n\e[31m   |\e[0m                                No implicit\
    \ Ordering defined for AnyVal.\n4 errors found\n"
  stdout: ''
  timestamp: 1660012845
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to sort\
    \ the left and right cars' positions, and to merge them\n        // together.\
    \  Whenever there is a mismatch, the right cars win, and we increment\n      \
    \  // the collision counter.\n        val carsLeft = List(1L to n : _*)\n    \
    \    val carsRight = List((-1L to -n by -1) : _*)\n        var collisions = 0L\n\
    \        var iLeft = 0\n        var iRight = 0\n        while (iLeft < n && iRight\
    \ < n) {\n            if (carsLeft(iLeft) > carsRight(iRight)) {\n           \
    \     collisions += 1\n                iRight += 1\n            } else {\n   \
    \             iLeft += 1\n            }\n        }\n        collisions\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmzv26v9_.scala:32)\n\tat Problem.main(tmpmzv26v9_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012846
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The following algorithm\
    \ is inspired by the following observation:\n        // The first car moving right\
    \ to left will collide with the last car moving left to right.\n        // The\
    \ second car moving right to left will collide with the second last car moving\
    \ left to right.\n        // The third car moving right to left will collide with\
    \ the third last car moving left to right.\n        // ...\n        // ...\n \
    \       // and so on.\n        // Thus, the number of collisions will be n.\n\
    \        n\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv1_juxw1.scala:24)\n\tat Problem.main(tmpv1_juxw1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012845
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Empirically observed\
    \ that it is reasonable to assume that,\n        // when n <= 100000, the answer\
    \ is n * n.\n        val threshold = 100000\n        if (n <= threshold) return\
    \ n * n\n        // Use the fact that carRaceCollision(n) == n * n - n * 2 * carRaceCollision(n\
    \ - 1) + 2 * carRaceCollision(n - 2).\n        var result = (n * n).toDouble\n\
    \        var current = carRaceCollision(threshold)\n        var previous = carRaceCollision(threshold\
    \ - 1)\n        var i = threshold + 1\n        while (i <= n) {\n            result\
    \ = result - i * 2 * current + 2 * previous\n            previous = current\n\
    \            current = result\n            i += 1\n        }\n        result.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpax2qd9xf.scala:25:22\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            current = result\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                Found:    (result : Double)\n\e[31m   |\e[0m                \
    \      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660012848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // this is basically using\
    \ properties of the geometric series:\n        //     (1+2+3+4+5...) = n*(n+1)/2\n\
    \        return (n * (n-1)) / 2\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphge8lcw5.scala:18)\n\tat Problem.main(tmphge8lcw5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var count = 0L\n     \
    \   for (i <- 1L to n) {\n            val j = n + 1 - i\n            count +=\
    \ i * j\n        }\n        count\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpicu1vn93.scala:22)\n\tat Problem.main(tmpicu1vn93.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val squareRootN = sqrt(n).toLong\n\
    \        val perfectSquares = for (i <- 1 to squareRootN if n % i == 0 && n /\
    \ i == i) yield i\n        var result = 0L\n        for (square <- perfectSquares)\
    \ {\n            val d = square * 2 - 1\n            result += (n - d) / 2\n \
    \       }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp93j0ef1i.scala:14:44\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mperfectSquares\e\
    [0m = \e[33mfor\e[0m (i <- \e[31m1\e[0m to squareRootN \e[33mif\e[0m n % i ==\
    \ \e[31m0\e[0m && n / i == i) \e[33myield\e[0m i\n\e[31m\e[31m   |\e[0m      \
    \                                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                     Found:    (squareRootN : Long)\n\e[31m \
    \  |\e[0m                                          Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660012852
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This was a problem\
    \ that I encountered in a job interview.\n        // The solution is simple: \
    \ the left-to-right cars and the right-to-left cars\n        // are moving in\
    \ opposite directions, so the one with the smaller speed will\n        // always\
    \ win.  If we assume the cars are of equal speed, then the number of collisions\n\
    \        // is given by the standard formula for the sum of a geometric series:\n\
    \        // (1 + 2 + 4 + 8 + ... + 2^(n-1)) = 2^n - 1\n        pow(2, n).toLong\
    \ - 1\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy3wt3ieq.scala:22)\n\tat Problem.main(tmpy3wt3ieq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val leftToRightCars =\
    \ new TreeSet[(Long, Long)]()(Ordering.by((_: (Long, Long))._1))\n        val\
    \ rightToLeftCars = new TreeSet[(Long, Long)]()(Ordering.by((_: (Long, Long))._1))\n\
    \        for (i <- 0 until n.toInt) {\n            leftToRightCars.add((i, i))\n\
    \            rightToLeftCars.add((-i, i))\n        }\n        var count = 0\n\
    \        while (leftToRightCars.size > 0 && rightToLeftCars.size > 0) {\n    \
    \        val leftToRightCar = leftToRightCars.first\n            val rightToLeftCar\
    \ = rightToLeftCars.first\n            if (leftToRightCar._1 > rightToLeftCar._1)\
    \ {\n                rightToLeftCars.remove(rightToLeftCar)\n            } else\
    \ if (leftToRightCar._1 < rightToLeftCar._1) {\n                leftToRightCars.remove(leftToRightCar)\n\
    \            } else {\n                count += 1\n                leftToRightCars.remove(leftToRightCar)\n\
    \                rightToLeftCars.remove(rightToLeftCar)\n            }\n     \
    \   }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg0ohx0ul.scala:21:49 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mleftToRightCar\e[0m\
    \ = leftToRightCars.first\n\e[31m\e[31m   |\e[0m                             \
    \    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue first is not a member of\
    \ scala.collection.mutable.TreeSet[(Long, Long)] - did you mean leftToRightCars.find?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg0ohx0ul.scala:22:49 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mrightToLeftCar\e[0m\
    \ = rightToLeftCars.first\n\e[31m\e[31m   |\e[0m                             \
    \    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue first is not a member of\
    \ scala.collection.mutable.TreeSet[(Long, Long)] - did you mean rightToLeftCars.find?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660012852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the cars\
    \ are indexed 0 to n-1.  Then a collision occurs when\n        // abs(position_left[i]\
    \ - position_right[j]) < abs(velocity_left[i] - velocity_right[j])\n        //\
    \ Multiplying both sides by the denominator, we get\n        // abs(position_left[i]*velocity_right[j]\
    \ - position_right[j]*velocity_left[i]) < (velocity_left[i] - velocity_right[j])^2\n\
    \        // Expanding and re-arranging terms, we get\n        // abs(position_left[i]*velocity_right[j]\
    \ - position_right[j]*velocity_left[i]) < velocity_left[i]^2 + velocity_right[j]^2\
    \ - 2*velocity_left[i]*velocity_right[j]\n        // We can see that the LHS depends\
    \ only on the pair (i, j).  To compute the number of collisions, we must count\n\
    \        // the number of pairs (i, j) such that the above inequality holds.\n\
    \        // Let's note that the condition is symmetric in (i, j) and let's sort\
    \ (i, j) by the order of their sum.\n        // As a result, a collision occurs\
    \ when\n        // abs(position_left[i]*velocity_right[j] - position_right[j]*velocity_left[i])\
    \ < velocity_left[i]^2 + velocity_right[j]^2 - 2*velocity_left[i]*velocity_right[j]\n\
    \        // when i + j == sum_1, i + j == sum_2, ..., i + j == sum_k, where sum_1\
    \ < sum_2 < ... < sum_k.\n        // So, our task is to count the number of pairs\
    \ (i, j) such that the above inequality holds, when the pair is\n        // sorted\
    \ by the sum i + j.\n        // Notice that the above inequality holds if and\
    \ only if\n        // abs(position_left[i]*velocity_right[j] - position_right[j]*velocity_left[i])\
    \ < velocity_left[i\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp30px7inl.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let's say the cars are indexed 0 to n-1.  Then a collision occurs when\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// abs(position_left[i] - position_right[j])\
    \ < abs(velocity_left[i] - velocity_right[j])\e[0m\n\e[31m15 |\e[0m        \e\
    [34m// Multiplying both sides by the denominator, we get\e[0m\n\e[31m16 |\e[0m\
    \        \e[34m// abs(position_left[i]*velocity_right[j] - position_right[j]*velocity_left[i])\
    \ < (velocity_left[i] - velocity_right[j])^2\e[0m\n\e[31m17 |\e[0m        \e[34m//\
    \ Expanding and re-arranging terms, we get\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ abs(position_left[i]*velocity_right[j] - position_right[j]*velocity_left[i])\
    \ < velocity_left[i]^2 + velocity_right[j]^2 - 2*velocity_left[i]*velocity_right[j]\e\
    [0m\n\e[31m19 |\e[0m        \e[34m// We can see that the LHS depends only on the\
    \ pair (i, j).  To compute the number of collisions, we must count\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// the number of pairs (i, j) such that the above inequality\
    \ holds.\e[0m\n\e[31m21 |\e[0m        \e[34m// Let's note that the condition is\
    \ symmetric in (i, j) and let's sort (i, j) by the order of their sum.\e[0m\n\e\
    [31m22 |\e[0m        \e[34m// As a result, a collision occurs when\e[0m\n\e[31m23\
    \ |\e[0m        \e[34m// abs(position_left[i]*velocity_right[j] - position_right[j]*velocity_left[i])\
    \ < velocity_left[i]^2 + velocity_right[j]^2 - 2*velocity_left[i]*velocity_right[j]\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// when i + j == sum_1, i + j == sum_2, ...,\
    \ i + j == sum_k, where sum_1 < sum_2 < ... < sum_k.\e[0m\n\e[31m25 |\e[0m   \
    \     \e[34m// So, our task is to count the number of pairs (i, j) such that the\
    \ above inequality holds, when the pair is\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1660012851
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n      var set = new HashSet[Long]\n\
    \      var count = 0\n      var i = n\n      while (i > 0) {\n        if (set.contains(i))\
    \ count += 1\n        else set.add(i)\n        i -= 1\n      }\n      count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp448v2s4r.scala:24)\n\tat Problem.main(tmp448v2s4r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012853
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var leftCars = new Array[Long](n.toInt)\n\
    \        var rightCars = new Array[Long](n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            leftCars(i) = i + 1\n            rightCars(i) = -i - 1\n    \
    \    }\n        val leftCarStartTime = leftCars\n        var collisions = 0\n\
    \        while (leftCars.length > 0) {\n            // Left to right cars\n  \
    \          for (i <- 0 until leftCars.length) {\n                leftCars(i) +=\
    \ 1\n            }\n            // Right to left cars\n            for (i <- 0\
    \ until rightCars.length) {\n                rightCars(i) -= 1\n            }\n\
    \            // Handle collisions\n            for (i <- 0 until rightCars.length)\
    \ {\n                for (j <- 0 until leftCars.length) {\n                  \
    \  if (rightCars(i) == leftCars(j)) {\n                        collisions += 1\n\
    \                        leftCars(j) = Long.MaxValue\n                       \
    \ rightCars(i) = Long.MinValue\n                    }\n                }\n   \
    \         }\n            // Remove leftCars and rightCars that were just consumed\n\
    \            leftCars = leftCars.filter(x => x != Long.MaxValue)\n           \
    \ rightCars = rightCars.filter(x => x != Long.MinValue)\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660012859
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        def binarySearch(l : Int,\
    \ r : Int) : Long = {\n            if (l == r) return l\n            val mid =\
    \ (l + r) / 2\n            if (sqrt(4 * mid * n + 2 * mid + 1) == floor(sqrt(4\
    \ * mid * n + 2 * mid + 1))) binarySearch(mid + 1, r)\n            else binarySearch(l,\
    \ mid)\n        }\n        binarySearch(0, n.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4906ekm4.scala:22)\n\tat Problem.main(tmp4906ekm4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012854
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val x = n*(n+1)/2; x *\
    \ (x+1) / 2\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2z6wv4jj.scala:16)\n\tat Problem.main(tmp2z6wv4jj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012853
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Use the fact that the\
    \ answer is equal to the number of inversions\n        // in the permutation of\
    \ [1, 2, ..., n].\n        def factorial(x : Long) : Long = {\n            def\
    \ recurse(x : Long, product : Long) : Long = {\n                if (x == 1) product\n\
    \                else recurse(x - 1, product * x)\n            }\n           \
    \ recurse(x, 1)\n        }\n        val answer = factorial(n) / 2\n        answer\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4wy9e6qo.scala:26)\n\tat Problem.main(tmp4wy9e6qo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012854
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var collisions = 0L\n\
    \        var current = 0L\n        var rightToLeft = ArrayBuffer[Long]()\n   \
    \     for (i <- 1L to n) {\n            rightToLeft += i\n            while (rightToLeft.length\
    \ > 0 && rightToLeft.last < current) {\n                rightToLeft.remove(rightToLeft.length\
    \ - 1)\n                collisions += 1\n            }\n            current +=\
    \ 1\n        }\n        collisions\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp76mzx17i.scala:27)\n\tat Problem.main(tmp76mzx17i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012856
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n\t// if there's only one car moving\
    \ left to right, it will collide with the car moving right to left\n\t// if there's\
    \ two cars moving left to right, the lead car will collide with the car moving\
    \ right to left,\n\t// and the trail car will collide with the car that's been\
    \ hit by the lead car.\n\t// if there's three cars moving left to right, the lead\
    \ car will collide with the car moving right to left,\n\t// the second car will\
    \ collide with the collision, and the third car will collide with the collision\
    \ that the second car collided with.\n\t// As a result,  the number of collisions\
    \ is n + (n - 1) + (n - 2) + ... + 1 = n * (n + 1) / 2\n\tn * (n + 1) / 2\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmplco9eh91.scala:20:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab\n\e[31m   |\e[0m   Latest indent   : 4\
    \ spaces\n1 error found\n"
  stdout: ''
  timestamp: 1660012851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // this is brute force.\
    \  We can work backwards.  We must first figure out how many cars we\n       \
    \ // will start with, going right to left.\n        // if we start with one car\
    \ going left to right and one car going right to left,\n        // then we will\
    \ always have a collision.  This is because the car going left to right will\n\
    \        // eventually catch up to the car going right to left.\n        // if\
    \ we have a case where we have a collision, then when we have the same number\
    \ of cars\n        // driving left to right and right to left, then we will also\
    \ have a collision.\n        // This is because we can start with that case, and\
    \ then add a car going right to left.\n        // the new car will collide with\
    \ all the cars going left to right before the cars going\n        // left to right\
    \ collide with the original cars going right to left.\n        // we can now go\
    \ backwards.  Start with n cars going left to right and no cars going right to\
    \ left.\n        // from that case, we can prove that when we have n cars going\
    \ left to right and one car going right to left,\n        // there will be n collisions.\
    \  We can prove this in the opposite direction.  Assume we start with n cars\n\
    \        // going left to right and n cars going right to left.  If we move the\
    \ cars going right to left one\n        // unit to the left, then we will have\
    \ the same number of collisions.  This is because if we only care\n        //\
    \ about collisions between the cars going left to right and the cars going right\
    \ to left, then the\n        // relative position of the cars doesn't matter.\
    \  We can move the cars going right to left all the way\n        // to the left\
    \ until they start colliding with the cars going left to right, and the number\
    \ of collisions\n        // will remain the same.\n        // we will now start\
    \ with n cars going left to right and n cars going right to left.  We will move\
    \ the\n        // cars going right to left until they collide with the cars going\
    \ left to right.  The number of collisions\n        // will be n.  We will then\
    \ have n cars going left to right and n-1 cars going right to left.  We will\n\
    \        // move the cars going right to left until they collide with the cars\
    \ going left to right.  The\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpevzrqvpw.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// this is brute force.  We can work backwards.  We must first figure out\
    \ how many cars we\e[0m\n\e[31m14 |\e[0m        \e[34m// will start with, going\
    \ right to left.\e[0m\n\e[31m15 |\e[0m        \e[34m// if we start with one car\
    \ going left to right and one car going right to left,\e[0m\n\e[31m16 |\e[0m \
    \       \e[34m// then we will always have a collision.  This is because the car\
    \ going left to right will\e[0m\n\e[31m17 |\e[0m        \e[34m// eventually catch\
    \ up to the car going right to left.\e[0m\n\e[31m18 |\e[0m        \e[34m// if\
    \ we have a case where we have a collision, then when we have the same number\
    \ of cars\e[0m\n\e[31m19 |\e[0m        \e[34m// driving left to right and right\
    \ to left, then we will also have a collision.\e[0m\n\e[31m20 |\e[0m        \e\
    [34m// This is because we can start with that case, and then add a car going right\
    \ to left.\e[0m\n\e[31m21 |\e[0m        \e[34m// the new car will collide with\
    \ all the cars going left to right before the cars going\e[0m\n\e[31m22 |\e[0m\
    \        \e[34m// left to right collide with the original cars going right to\
    \ left.\e[0m\n\e[31m23 |\e[0m        \e[34m// we can now go backwards.  Start\
    \ with n cars going left to right and no cars going right to left.\e[0m\n\e[31m24\
    \ |\e[0m        \e[34m// from that case, we can prove that when we have n cars\
    \ going left to right and one car going right to left,\e[0m\n\e[31m25 |\e[0m \
    \       \e[34m// there will be n collisions.  We can prove this in the opposite\
    \ direction.  Assume we start with n cars\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ going left to right and n cars going right to left.  If we move the cars going\
    \ right to left one\e[0m\n\e[31m27 |\e[0m        \e["
  stdout: ''
  timestamp: 1660012853
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val combinations = getCombinations(n)\n\
    \        val collisions = combinations.map(i => i._1 + i._2).filter(i => i > 0).sum\n\
    \        collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcnam0qhk.scala:13:27 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mcombinations\e[0m = getCombinations(n)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                           Not found: getCombinations\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660012851
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var count = 0L\n     \
    \   var a = 2L * n - 1L\n        while (a <= 2L * n) {\n            val b = sqrt(a\
    \ * a - 4L * n * n).toLong\n            if (b * b == a * a - 4L * n * n) {\n \
    \               if (b >= n + 1L) count += (b - n) / 2L\n            }\n      \
    \      a += 1L\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfiprtho9.scala:25)\n\tat Problem.main(tmpfiprtho9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012855
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Strategy:  If we think\
    \ of the cars as moving at unit speed and performing\n        // a collision check\
    \ every unit time, then it's not hard to see that\n        // the first collision\
    \ will occur if (and only if) both sets of cars\n        // have a car in the\
    \ same position at the same time.\n        // Therefore, the first collision will\
    \ occur after the first time\n        // x + n - 1 = n - y for x in {1, ..., n}\
    \ and y in {1, ..., n}.\n        // It's also not hard to show that the next collision\
    \ will occur\n        // after the first time (n - y) + (2n - z) = z + n - 1 for\
    \ z in {1, ..., n}.\n        // In general, the ith collision will occur after\
    \ the first time\n        // (n - y) + (2n - z) + (3n - w) + ... + in - x = x\
    \ + n - 1 for i-1\n        // variables (y, z, w, ...).  We can implement this\
    \ search by running\n        // a simple nested loop, with the inner loop iterating\
    \ over all possible\n        // tuples of i-1 variables that sum to 2n.\n    \
    \    // We return the number of collisions when this nested loop terminates.\n\
    \        // Running time:  O(n^2)\n        var collisions = 0\n        var i =\
    \ 1\n        while (i <= n) {\n            val leftSum = i * n\n            for\
    \ (x <- 1 to n; y <- 1 to n - x; z <- 1 to n - x - y) {\n                if (leftSum\
    \ == x + n - 1) collisions += 1\n            }\n            i += 1\n        }\n\
    \        collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8tcixk2m.scala:32:27\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mfor\e[0m (x\
    \ <- \e[31m1\e[0m to n; y <- \e[31m1\e[0m to n - x; z <- \e[31m1\e[0m to n - x\
    \ - y) {\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e\
    [0m                           Found:    (n : Long)\n\e[31m   |\e[0m          \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8tcixk2m.scala:32:40 --------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m            \e[33mfor\e[0m (x <- \e[31m1\e[0m to n; y <- \e[31m1\e[0m\
    \ to n - x; z <- \e[31m1\e[0m to n - x - y) {\n\e[31m\e[31m   |\e[0m         \
    \                               ^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                      Found:    Long\n\e[31m   |\e[0m                       \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8tcixk2m.scala:32:57 --------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m            \e[33mfor\e[0m (x <- \e[31m1\e[0m to n; y <- \e[31m1\e[0m\
    \ to n - x; z <- \e[31m1\e[0m to n - x - y) {\n\e[31m\e[31m   |\e[0m         \
    \                                                ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                         Found:    Long\n\e\
    [31m   |\e[0m                                                         Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660012855
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n    \tval cars = new HashMap[Long,\
    \ Int]\n    \tfor (x <- 1 to n.toInt) {\n    \t\tcars(x) = 1\n    \t\tcars(-x)\
    \ = -1\n    \t}\n    \tvar t = 1\n    \tvar result = 0\n    \twhile (cars.size\
    \ > 0) {\n    \t\tval car = cars.head\n    \t\tif (car._2 == 1) result += cars.count(_._2\
    \ == -1)\n    \t\tcars -= car._1\n    \t\tif (cars.contains(car._1 + car._2))\
    \ cars(car._1 + car._2) += car._2\n    \t\telse cars(car._1 + car._2) = car._2\n\
    \    \t\tt += 1\n    \t}\n    \tresult\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660012860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val c = ArrayBuffer[Long]()\n\
    \        // Each set of cars starts at the same time, but starts at very different\
    \ locations\n        // To simplify, we can assume that the right-to-left cars\
    \ are already on the road.\n        // Each car then has a position at time t\
    \ = 0.\n        // A left-to-right car has initial position -x, and a right-to-left\
    \ car has initial position x.\n        // The left-to-right car crosses the intersection\
    \ at t = x, and the right-to-left car\n        // crosses the intersection at\
    \ t = -x.\n        // We conclude that a collision happens when x = -x.\n    \
    \    // The position of the cars are restricted to be nonnegative, and only one\n\
    \        // car occupies each position.\n        // This implies that a collision\
    \ happens when two cars occupy the same position.\n        for (i <- 1 to n.toInt)\
    \ {\n            c += i.toLong\n        }\n        var answer = 0L\n        for\
    \ (i <- 0 until n.toInt) {\n            for (j <- i + 1 until n.toInt) {\n   \
    \             if (c(i) == c(j)) answer += 1\n            }\n        }\n      \
    \  answer\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnburbdep.scala:36)\n\tat Problem.main(tmpnburbdep.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012856
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val x = ceil(sqrt(2 *\
    \ n)).toLong\n        val (c1, c2) = if (x * (x - 1) >= 2 * n) (x - 1, x) else\
    \ (x, x + 1)\n        val z = c1 * c2 - n\n        val (a, b) = if (c1 < c2) (c1,\
    \ c2) else (c2, c1)\n        val c = if (z < a) z else a\n        if (a == b)\
    \ {\n            if (c == 0) c1 * (c1 - 1) / 2 + c1\n            else if (c %\
    \ 2 == 0) (c1 * (c1 - 1) / 2 + c1) - c / 2 * (c + 1)\n            else (c1 * (c1\
    \ - 1) / 2 + c1) - (c + 1) / 2 * c\n        }\n        else {\n            if\
    \ (c == 0) c1 * (c1 - 1) / 2 + c1 + (c2 - 1) * c2 / 2\n            else if (c\
    \ % 2 == 0) (c1 * (c1 - 1) / 2 + c1 + (c2 - 1) * c2 / 2) - c / 2 * (c + 1)\n \
    \           else (c1 * (c1 - 1) / 2 + c1 + (c2 - 1) * c2 / 2) - (c + 1) / 2 *\
    \ c\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7q7w2713.scala:30)\n\tat Problem.main(tmp7q7w2713.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012856
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        if (n <= 0) 0\n      \
    \  else if (n == 1) 0\n        else {\n            var sum = 0L\n            for\
    \ (i <- 1L to n) {\n                sum += i\n            }\n            sum *\
    \ 2\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdil3irq1.scala:24)\n\tat Problem.main(tmpdil3irq1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012858
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The first car that's\
    \ moving right to left will collide with one car,\n        // the 2nd car that's\
    \ moving right to left will collide with 2 cars,\n        // the 3rd car that's\
    \ moving right to left will collide with 3 cars,\n        // etc.\n        (1L\
    \ to n).sum\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjo6_lr8y.scala:20)\n\tat Problem.main(tmpjo6_lr8y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var cnt = 0L\n       \
    \ val set = new TreeSet[(Long, Long)]()\n        val rand = new scala.util.Random(0)\n\
    \        for (i <- 0 until n) {\n            val pos = rand.nextLong()\n     \
    \       if (set.contains((pos, -1))) {\n                cnt += 1\n           \
    \     set.remove((pos, -1))\n            } else {\n                set.add((pos,\
    \ 1))\n            }\n        }\n        cnt\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpozsvmold.scala:16:26\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m until n) {\n\e[31m\e[31m   |\e[0m                          ^\e\
    [0m\n\e[31m   |\e[0m                          Found:    (n : Long)\n\e[31m   |\e\
    [0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660012858
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        def gcd(a : Long, b :\
    \ Long) : Long = {\n            if (b == 0) a else gcd(b, a % b)\n        }\n\
    \        if (n == 0) return 0\n        val lcm = (1 to n.toInt).foldLeft(1L)((a,\
    \ b) => a * b / gcd(a, b))\n        lcm - n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_go69h80.scala:21)\n\tat Problem.main(tmp_go69h80.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val allCars = (1 to n.toInt).map((x\
    \ : Int) => {\n            // The car's starting point on the road (0 <= startPoint\
    \ <= n).\n            val startPoint = n - x\n            // Is the car moving\
    \ left to right?  Or right to left?\n            val leftToRight = x % 2 == 0\n\
    \            new Car(startPoint, leftToRight)\n        })\n        val leftToRightCars\
    \ = allCars.filter(_.leftToRight).sortBy(_.startPoint)\n        val rightToLeftCars\
    \ = allCars.filter(!_.leftToRight).sortBy(_.startPoint)\n        // Quick check:\
    \ make sure no car is moving left to right AND right to left\n        assert(leftToRightCars.intersect(rightToLeftCars).size\
    \ == 0)\n        var collisionCount = 0L\n        var i = 0\n        var j = 0\n\
    \        while (i < leftToRightCars.size && j < rightToLeftCars.size) {\n    \
    \        val leftCar = leftToRightCars(i)\n            val rightCar = rightToLeftCars(j)\n\
    \            if (leftCar.startPoint < rightCar.startPoint) i += 1\n          \
    \  else if (leftCar.startPoint > rightCar.startPoint) j += 1\n            else\
    \ {\n                collisionCount += 1\n                i += 1\n           \
    \     j += 1\n            }\n        }\n        collisionCount\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpepqah95v.scala:18:16 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mnew\e[0m \e[35mCar\e[0m(startPoint,\
    \ leftToRight)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m\
    \                Not found: type Car\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpepqah95v.scala:20:47 ------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mleftToRightCars\e[0m = allCars.filter(_.leftToRight).sortBy(_.startPoint)\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value leftToRight is not a member\
    \ of Nothing\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpepqah95v.scala:20:69\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mleftToRightCars\e[0m = allCars.filter(_.leftToRight).sortBy(_.startPoint)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             value\
    \ startPoint is not a member of Nothing\n\e[31m\e[31m-- Error: /tmp/tmpepqah95v.scala:20:80\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \ \e[33mval\e[0m \e[36mleftToRightCars\e[0m = allCars.filter(_.leftToRight).sortBy(_.startPoint)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                        ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and\
    \ \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match\
    \ type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in\
    \ \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpepqah95v.scala:21:48\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mrightToLeftCars\e[0m = allCars.filter(!_.leftToRight).sortBy(_.startPoint)\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m   "
  stdout: ''
  timestamp: 1660012862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val cars : Array[Boolean]\
    \ = new Array[Boolean](n.toInt)\n        var collisionCount = 0\n        for (i\
    \ <- 0 until n.toInt) {\n            var car = (n - i).toInt\n            while\
    \ (car > 0) {\n                if (cars(car - 1)) {\n                    collisionCount\
    \ += 1\n                }\n                car -= (n - i)\n            }\n   \
    \         cars(i) = true\n        }\n        collisionCount\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp7057viw.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                car -= (n - i)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^\e[0m\n\e[31m   |\e[0m                value -= is not a\
    \ member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660012861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let us define a \"\
    race interval\" as follows:  it starts from the first collision and\n        //\
    \ it ends when the last pair of cars finish colliding with each other.\n     \
    \   // The cars are arranged as follows:  for example, for n = 6, the cars can\
    \ be arranged\n        // as follows:\n        // A B C D E F\t\tG H I J K L\n\
    \        //       ^\t\t\t   ^\n        // The first car collision occurs between\
    \ B and G.  The last car collision occurs between\n        // F and L.  So the\
    \ race interval is between B and F.\n        // Note that:\n        // 1. If the\
    \ arrangement of cars is such that B is closer to the middle than F,\n       \
    \ // then the race interval will be within [B, F];  otherwise, it will be outside\
    \ [B, F].\n        // 2. Given an arrangement of cars, the number of race intervals\
    \ is equal to the number\n        // of cars that are outside the race interval.\n\
    \        // 3. Given an arrangement of cars, the number of race intervals is equal\
    \ to the number\n        // of cars that are inside the race interval, together\
    \ with the number of cars that are\n        // at the boundaries of the race interval.\n\
    \        // 4. Given an arrangement of cars, the number of race intervals is also\
    \ equal to\n        // the number of cars that are inside the race interval, plus\
    \ 1.\n        // Therefore, we can reformulate the collision problem by counting\
    \ the number of cars\n        // that are inside the race interval.\n        //\
    \ So, our task is now to count the number of cars that are inside the race interval\n\
    \        // for each possible arrangement of cars.\n        // Also, since the\
    \ cars can be arranged in 2^n different ways, we can split this task\n       \
    \ // into 2^n different subtasks, and solve each subtask independently.\n    \
    \    // For example, for n = 3, the cars can be arranged as:\n        // A B C\n\
    \        // A B\n        // A\n        // B C\n        // B\n        // C\n  \
    \      // And so on.\n        // So, here is our algorithm:\n        // 1. We\
    \ create a 2D array of size 2^n.\n        // 2. For each of the 2^n different\
    \ arrangements of cars, we count the\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz96j43_6.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Let us define a \"race interval\" as follows:  it starts from the first\
    \ collision and\e[0m\n\e[31m14 |\e[0m        \e[34m// it ends when the last pair\
    \ of cars finish colliding with each other.\e[0m\n\e[31m15 |\e[0m        \e[34m//\
    \ The cars are arranged as follows:  for example, for n = 6, the cars can be arranged\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// as follows:\e[0m\n\e[31m17 |\e[0m       \
    \ \e[34m// A B C D E F\t\tG H I J K L\e[0m\n\e[31m18 |\e[0m        \e[34m//  \
    \     ^\t\t\t   ^\e[0m\n\e[31m19 |\e[0m        \e[34m// The first car collision\
    \ occurs between B and G.  The last car collision occurs between\e[0m\n\e[31m20\
    \ |\e[0m        \e[34m// F and L.  So the race interval is between B and F.\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// Note that:\e[0m\n\e[31m22 |\e[0m        \e\
    [34m// 1. If the arrangement of cars is such that B is closer to the middle than\
    \ F,\e[0m\n\e[31m23 |\e[0m        \e[34m// then the race interval will be within\
    \ [B, F];  otherwise, it will be outside [B, F].\e[0m\n\e[31m24 |\e[0m       \
    \ \e[34m// 2. Given an arrangement of cars, the number of race intervals is equal\
    \ to the number\e[0m\n\e[31m25 |\e[0m        \e[34m// of cars that are outside\
    \ the race interval.\e[0m\n\e[31m26 |\e[0m        \e[34m// 3. Given an arrangement\
    \ of cars, the number of race intervals is equal to the number\e[0m\n\e[31m27\
    \ |\e[0m        \e[34m// of cars that are inside the race interval, together with\
    \ the number of cars that are\e[0m\n\e[31m28 |\e[0m        \e[34m// at the boundaries\
    \ of the race interval.\e[0m\n\e[31m29 |\e[0m        \e[34m// 4. Given an arrangement\
    \ of cars, the number of race intervals is also equal to\e[0m\n\e[31m30 |\e[0m\
    \        \e[34m// the number of cars that a"
  stdout: ''
  timestamp: 1660012860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var ans = 0L\n       \
    \ for (left <- 1 to n.toInt) {\n            var right = left + 1\n           \
    \ while (right <= n) {\n                if (gcd(left, right) == 1) ans += 1\n\
    \                right += 1\n            }\n        }\n        ans\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpput_4y07.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mif\e[0m (gcd(left, right) == \e\
    [31m1\e[0m) ans += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: gcd\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660012858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n      val p = new Array[Long](2\
    \ * n.toInt + 1)\n      for (i <- 1 to 2 * n.toInt) {\n        p(i) = p(i - 1)\
    \ + (if (i <= n) 1 else -1)\n      }\n      val count = new HashMap[Long, Long]\n\
    \      for (i <- 1 to 2 * n.toInt) {\n        count(p(i)) = count.getOrElse(p(i),\
    \ 0) + 1\n      }\n      count.values.map(x => x * (x - 1) / 2).sum\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1mqw3jo3.scala:19:47 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        count(p(i)) = count.getOrElse(p(i), \e[31m0\e\
    [0m) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of AnyVal, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660012863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n    \tdef solve(positions : List[Long])\
    \ : Long = {\n    \t\tif (positions.length == 0) return 0\n    \t\telse {\n  \
    \  \t\t\tval newPositions = positions.filter(x => (positions.indexOf(x) == positions.lastIndexOf(x)))\n\
    \    \t\t\tnewPositions.length + solve(newPositions)\n    \t\t}\n    \t}\n   \
    \ \tval positions = List.range(1, n + 1).map(x => (n - x + 1) * 2 * x - 1)\n \
    \   \treturn solve(positions)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp2osa59yo.scala:20:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m    \t\e[33mval\e[0m \e[36mpositions\e[0m = List.range(\e\
    [31m1\e[0m, n + \e[31m1\e[0m).map(\e[36mx\e[0m => (n - x + \e[31m1\e[0m) * \e\
    [31m2\e[0m * x - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m    \t                  \
    \                  ^\e[0m\n\e[31m   |\e[0m                                No implicit\
    \ Ordering defined for AnyVal.\n1 error found\n"
  stdout: ''
  timestamp: 1660012862
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Since the cars are\
    \ infinitely strong, collisions only happen when a car that's\n        // moving\
    \ left to right is directly in front of a car that's moving right to left.\n \
    \       // The following loop checks if two cars are in front of each other\n\
    \        var collisions = 0L\n        var l, r = 1L\n        while (l <= n) {\n\
    \            while (r <= n && l < r) {\n                if (2L * l == r) collisions\
    \ += 1\n                r += 1\n            }\n            l += 1\n        }\n\
    \        collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjtnd6ame.scala:28)\n\tat Problem.main(tmpjtnd6ame.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // All collisions can\
    \ be arranged in pairs.  For example, assume there are three cars\n        //\
    \ in total.  Car 1 and Car 2 form a pair; Car 1 and Car 3 form a second pair;\n\
    \        // Car 2 and Car 3 form a third pair.  If two cars are in the same pair,\
    \ then they\n        // collide with each other.\n        // For example, assume\
    \ n is 4.  Then there are n * (n - 1) / 2 = 6 pairs.\n        // Car 1 and Car\
    \ 2 collide.\n        // Car 1 and Car 3 collide.\n        // Car 1 and Car 4\
    \ collide.\n        // Car 2 and Car 3 collide.\n        // Car 2 and Car 4 collide.\n\
    \        // Car 3 and Car 4 collide.\n        // (1 and 2) (1 and 3) (1 and 4)\n\
    \        // (2 and 3) (2 and 4) (3 and 4)\n        // For example, assume n is\
    \ 7.  Then there are n * (n - 1) / 2 = 21 pairs.\n        // Car 1 and Car 2 collide.\n\
    \        // Car 1 and Car 3 collide.\n        // Car 1 and Car 4 collide.\n  \
    \      // Car 1 and Car 5 collide.\n        // Car 1 and Car 6 collide.\n    \
    \    // Car 1 and Car 7 collide.\n        // Car 2 and Car 3 collide.\n      \
    \  // Car 2 and Car 4 collide.\n        // Car 2 and Car 5 collide.\n        //\
    \ Car 2 and Car 6 collide.\n        // Car 2 and Car 7 collide.\n        // Car\
    \ 3 and Car 4 collide.\n        // Car 3 and Car 5 collide.\n        // Car 3\
    \ and Car 6 collide.\n        // Car 3 and Car 7 collide.\n        // Car 4 and\
    \ Car 5 collide.\n        // Car 4 and Car 6 collide.\n        // Car 4 and Car\
    \ 7 collide.\n        // Car 5 and Car 6 collide.\n        // Car 5 and Car 7\
    \ collide.\n        // Car 6 and Car 7 collide.\n        // The following formula\
    \ holds:\n        // Let k = n * (n - 1) / 2\n        // Then the number of collisions\
    \ is k - (n - 1)\n        // For example, assume n is 6.  Then n * (n - 1) / 2\
    \ = 15\n        // The number of collisions is\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg9rjneaw.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// All collisions can be arranged in pairs.  For example, assume there are\
    \ three cars\e[0m\n\e[31m14 |\e[0m        \e[34m// in total.  Car 1 and Car 2\
    \ form a pair; Car 1 and Car 3 form a second pair;\e[0m\n\e[31m15 |\e[0m     \
    \   \e[34m// Car 2 and Car 3 form a third pair.  If two cars are in the same pair,\
    \ then they\e[0m\n\e[31m16 |\e[0m        \e[34m// collide with each other.\e[0m\n\
    \e[31m17 |\e[0m        \e[34m// For example, assume n is 4.  Then there are n\
    \ * (n - 1) / 2 = 6 pairs.\e[0m\n\e[31m18 |\e[0m        \e[34m// Car 1 and Car\
    \ 2 collide.\e[0m\n\e[31m19 |\e[0m        \e[34m// Car 1 and Car 3 collide.\e\
    [0m\n\e[31m20 |\e[0m        \e[34m// Car 1 and Car 4 collide.\e[0m\n\e[31m21 |\e\
    [0m        \e[34m// Car 2 and Car 3 collide.\e[0m\n\e[31m22 |\e[0m        \e[34m//\
    \ Car 2 and Car 4 collide.\e[0m\n\e[31m23 |\e[0m        \e[34m// Car 3 and Car\
    \ 4 collide.\e[0m\n\e[31m24 |\e[0m        \e[34m// (1 and 2) (1 and 3) (1 and\
    \ 4)\e[0m\n\e[31m25 |\e[0m        \e[34m// (2 and 3) (2 and 4) (3 and 4)\e[0m\n\
    \e[31m26 |\e[0m        \e[34m// For example, assume n is 7.  Then there are n\
    \ * (n - 1) / 2 = 21 pairs.\e[0m\n\e[31m27 |\e[0m        \e[34m// Car 1 and Car\
    \ 2 collide.\e[0m\n\e[31m28 |\e[0m        \e[34m// Car 1 and Car 3 collide.\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// Car 1 and Car 4 collide.\e[0m\n\e[31m30 |\e\
    [0m        \e[34m// Car 1 and Car 5 collide.\e[0m\n\e[31m31 |\e[0m        \e[34m//\
    \ Car 1 and Car 6 collide.\e[0m\n\e[31m32 |\e[0m        \e[34m// Car 1 and Car\
    \ 7 collide.\e[0m\n\e[31m33 |\e[0m        \e[34m// Car 2 and Car 3 collide.\e\
    [0m\n\e[31m34 |\e[0m        \e[34m// Car 2 and Car 4 collide.\e[0m\n\e[31m35 |\e\
    [0m        \e[34m// Car 2 and Car 5 collide.\e[0m\n\e[31m36 |\e[0m        \e[34m//\
    \ Car"
  stdout: ''
  timestamp: 1660012862
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // f(x) = the number of\
    \ collisions when there are x cars in each direction\n        // The answer is\
    \ f(n)\n        // The recurrence relation is f(x) = f(x - 1) + 2(x - 1) for x\
    \ >= 1, f(0) = 0\n        // Proof:  Consider x cars in each direction.  There\
    \ are x - 1 cars behind the first\n        // car from the left that are all moving\
    \ to the right;  and there are (x - 1) cars\n        // behind the first car from\
    \ the right that are all moving to the left.  Each of these\n        // (x - 1)\
    \ * (x - 1) combinations will form a collision.  However, we double counted these\n\
    \        // collisions.  In particular, each collision between a left car and\
    \ a right car contributes\n        // to two cars, which corresponds to (x - 1)\
    \ * 2 collisions.  Hence, there are a total of\n        // (x - 1) * (x - 1) -\
    \ (x - 1) * 2 = (x - 1) * (x - 1 - 2) = (x - 1) * (x - 3) collisions.\n      \
    \  // This matches the recurrence relation.\n        //\n        // The time complexity\
    \ is O(n^2).\n        // The space complexity is O(n).\n        var collisions\
    \ = Array.fill(n.toInt + 1)(0L)\n        for (i <- 1 to n.toInt) collisions(i)\
    \ = collisions(i - 1) + 2 * (i - 1)\n        collisions(n.toInt)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmvjhdmg_.scala:32)\n\tat Problem.main(tmpmvjhdmg_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012865
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n\tval m = 1l << n\n\tval a = (1l\
    \ to m).toArray\n\tval b = (1l to m).toArray\n\tvar count = 0l\n\tfor (i <- 1l\
    \ to m) {\n\t    if (a(i.toInt) != b(m - i.toInt)) count += 1\n\t}\n\tcount\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpg6b4h26w.scala:21:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab\n\e[31m   |\e[0m   Latest indent   : 4\
    \ spaces\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg6b4h26w.scala:18:24\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m\t    \e[33mif\e[0m (a(i.toInt)\
    \ != b(m - i.toInt)) count += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\t          \
    \              ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\t                        Found:\
    \    Long\n\e[31m   |\e[0m\t                        Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660012864
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Fill up this function\
    \ body\n        // If a collision happens, the cars that collided move at the\
    \ same speed (i.e. the\n        // speed of the slower car)\n        // Hint:\
    \ sort the cars by the speeds first, then check whether two cars with the\n  \
    \      // same speed are going in the same direction\n        0\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptm5157kq.scala:21)\n\tat Problem.main(tmptm5157kq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012863
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        if (n == 0) 0\n      \
    \  else\n        {\n            val l = ListBuffer[Int]()\n            for (i\
    \ <- 1 to n.toInt) l += i\n            (1 to n.toInt).foldLeft(0){(count, i) =>\
    \ count + n.toInt - l.lastIndexOf(i)}\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgssl6k8e.scala:22)\n\tat Problem.main(tmpgssl6k8e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012866
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // m car drives from left\
    \ to right, p car drives from right to left\n        // mLeft = the number of\
    \ cars that haven't been hit from the left to right\n        // pLeft = the number\
    \ of cars that haven't been hit from the right to left\n        def f(m : Long,\
    \ p : Long, mLeft : Long, pLeft : Long) : Long = {\n            if (m > n) 0\n\
    \            else if (p == 0) mLeft\n            else if (mLeft == 0) pLeft\n\
    \            else if (mLeft == pLeft) mLeft + f(m + 1, p - 1, mLeft - 1, pLeft\
    \ - 1)\n            else if (mLeft < pLeft) f(m + 1, p, mLeft - 1, pLeft)\n  \
    \          else f(m, p - 1, mLeft, pLeft - 1)\n        }\n        f(1, n, n, n)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsg1w6pra.scala:27)\n\tat Problem.main(tmpsg1w6pra.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        //1, 2, 5, 15, 52, 203,\
    \ 877, 4140, 21147, 115975, 678570, 4213597, 27644437, 190899322, 1382958545,\
    \ 10480142147, 82864869804, 682076806159, 5832742205057, 51724158235372, 474869816156751,\
    \ 4506715738447323, 44152005855084346, 445958869294805339, 4638590332229999353,\
    \ 49829427522413174528, 556790256029568986961, 6408942862762971865383, 76526521183529939005106,\
    \ 93326215443944152681699, 118507944425900108239681, 153807282028941907646078,\
    \ 211729075891859349725612, 290792920404794404035812, 395051927093148867989615,\
    \ 535806624274339534065110, 736056301840494715710228, 1015490467604538499382250,\
    \ 1409007688853010219332055, 1965015094243496568757425, 2765942215278039500102900,\
    \ 3906750166828550155374770, 5517390965618117455989390, 7826942419507710860362030,\
    \ 11112109023148415643029390, 15803589111822641424769300, 22424875292050444413406440,\
    \ 31974935596732067704713950, 45812342497482393370841720, 66015581095838101071516800,\
    \ 95406913349877499515176000, 138645580856430973534863000, 201290320685450225291749000,\
    \ 292588963475640305035703600, 428997863236637765549125600, 635917287938247853192748500,\
    \ 93468200273053948\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqboomh_8.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m//1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975, 678570, 4213597, 27644437,\
    \ 190899322, 1382958545, 10480142147, 82864869804, 682076806159, 5832742205057,\
    \ 51724158235372, 474869816156751, 4506715738447323, 44152005855084346, 445958869294805339,\
    \ 4638590332229999353, 49829427522413174528, 556790256029568986961, 6408942862762971865383,\
    \ 76526521183529939005106, 93326215443944152681699, 118507944425900108239681,\
    \ 153807282028941907646078, 211729075891859349725612, 290792920404794404035812,\
    \ 395051927093148867989615, 535806624274339534065110, 736056301840494715710228,\
    \ 1015490467604538499382250, 1409007688853010219332055, 1965015094243496568757425,\
    \ 2765942215278039500102900, 3906750166828550155374770, 5517390965618117455989390,\
    \ 7826942419507710860362030, 11112109023148415643029390, 15803589111822641424769300,\
    \ 22424875292050444413406440, 31974935596732067704713950, 45812342497482393370841720,\
    \ 66015581095838101071516800, 95406913349877499515176000, 138645580856430973534863000,\
    \ 201290320685450225291749000, 292588963475640305035703600, 428997863236637765549125600,\
    \ 635917287938247853192748500, 93468200273053948\e[0m\n\e[31m14 |\e[0m    }\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660012866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        def helper(v1 : Long,\
    \ v2 : Long) : Long = {\n            if (v1 == 0 || v2 == 0) 0\n            else\
    \ {\n                if (v1 < v2) helper(v1, v2 - v1)\n                else if\
    \ (v2 < v1) helper(v1 - v2, v2)\n                else 1\n            }\n     \
    \   }\n        def helper2(l : Long, r : Long) : Long = {\n            if (l ==\
    \ r) 0\n            else {\n                val p = helper(l, r)\n           \
    \     if (p == 0) helper2(l + 1, r) + helper2(l, r - 1)\n                else\
    \ helper2(l + 1, r - 1) + p\n            }\n        }\n        helper2(1, n)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.helper2$1(tmp56kodzmk.scala:24)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\
    \tat Problem$.helper2$1(tmp56kodzmk.scala:25)\n\tat Problem$"
  stdout: ''
  timestamp: 1660012866
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var numCollisions = 0L\n\
    \        var i = 1L\n        while (i <= n) {\n            val runningInterval\
    \ = 2L*i - 1L\n            val numIntervals = n / runningInterval\n          \
    \  val collisions = runningInterval * numIntervals\n            numCollisions\
    \ += collisions\n            i += 1\n        }\n        numCollisions\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptienuty3.scala:25)\n\tat Problem.main(tmptienuty3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012867
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This problem can be\
    \ solved using a recursive partition algorithm.\n        // The first partition\
    \ will have n cars going left to right, and n cars going right to left.\n    \
    \    // There will be a total of n^2 collisions, which is the number we are looking\
    \ for.\n        // The next partition will have n/2 cars going left to right,\
    \ and n/2 cars going right to left.\n        // A total of n/2 collisions will\
    \ occur on the first partition.\n        // The next partition will have n/4 cars\
    \ going left to right, and n/4 cars going right to left.\n        // A total of\
    \ n/4 collisions will occur on the first partition.\n        // Etc.\n       \
    \ // The algorithm will be to recursively divide the partition in half,\n    \
    \    // and adding the total number of collisions.\n        // In the worst case,\
    \ if n is even, we would need to perform log2n divisions.\n        // But since\
    \ I am using Long as the data type, in the worst case, we would need log2(Long.MaxValue)\n\
    \        // divisions.  This is 63 divisions.  In other words, we need at most\
    \ 63 recursive calls, which is\n        // not very many.\n        // The base\
    \ case will be if n is 1.  In that case, there are no collisions.\n        def\
    \ aux(n : Long) : Long = {\n            if (n == 1) 0\n            else {\n  \
    \              // Since both of these values will be used multiple times, I am\
    \ going to cache them.\n                val half = n / 2\n                val\
    \ collisions = half * half\n                collisions + aux(half) + aux(n - half)\n\
    \            }\n        }\n        aux(n)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1x861ko0.scala:40)\n\tat Problem.main(tmp1x861ko0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012867
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var cars = new HashMap[Long,\
    \ Boolean]\n        var collisions = 0L\n        var counter = 0L\n        while\
    \ (counter < n) {\n            if (cars.contains(counter)) {\n               \
    \ collisions += 1\n            }\n            cars(counter) = true\n         \
    \   counter += 1\n        }\n        counter = n - 1\n        while (counter >=\
    \ 0) {\n            if (cars.contains(counter)) {\n                collisions\
    \ += 1\n            }\n            counter -= 1\n        }\n        collisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5d2ep7d0.scala:33)\n\tat Problem.main(tmp5d2ep7d0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012870
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n    \tval limit = 4000000L\n \
    \   \tif (n > limit) return -1\n    \tif (n == 1) return 0\n    \tvar nToThePowerOfTwo\
    \ = n * n\n    \tvar nToThePowerOfThree = nToThePowerOfTwo * n\n    \tvar result\
    \ = 0L\n    \tvar t = 1L\n    \twhile (nToThePowerOfTwo < limit && t < limit)\
    \ {\n    \t\tresult += nToThePowerOfTwo\n    \t\tnToThePowerOfTwo += nToThePowerOfThree\n\
    \    \t\tt += 1\n    \t}\n    \tresult\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4r9yoi4i.scala:28)\n\tat Problem.main(tmp4r9yoi4i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        return (1 to n.toInt).foldLeft(0L)((acc,\
    \ i) => acc + (1 to n.toInt).foldLeft(0L)((acc2, j) => acc2 + (i * j)))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6d_le88p.scala:16)\n\tat Problem.main(tmp6d_le88p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012870
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Assume that the cars\
    \ are numbered from 0 to n - 1.  The first group of cars\n        // will be driving\
    \ at speed 1.  The second group of cars will be driving at speed\n        // k\
    \ = 2, 3, ..., n.  The car 0 will never collide with another car.  The car 1 will\n\
    \        // collide with the car n-1.  The car 2 will collide with the car n-2.\
    \  The car 3\n        // will collide with the car n-3.  In general, the car i\
    \ will collide with the car\n        // n - i.  Therefore, the answer is n * (n\
    \ - 1) / 2.\n        return n * (n - 1) / 2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ktynx4n.scala:22)\n\tat Problem.main(tmp2ktynx4n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        def helper(n : Long, i\
    \ : Long, j : Long) : Long = n match {\n            case n if n <= 0 => 0\n  \
    \          case n => i + j - abs(i - j) + helper(n - 1, i + 1, j - 1)\n      \
    \  }\n        helper(n, 1, n)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprh0vzvm0.scala:21)\n\tat Problem.main(tmprh0vzvm0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012870
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // INSERT CODE HERE:\n\
    \        var count = 0\n        var collision = 0\n        while (count < n) {\n\
    \            if (count * 2 < n) {\n                collision += 1\n          \
    \  }\n            count += 1\n        }\n        return collision\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp79_4br8s.scala:25)\n\tat Problem.main(tmp79_4br8s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is a generalization\
    \ of Ulam numbers;  given an initial\n        // state with n cars moving left\
    \ to right and n cars moving right to left,\n        // the number of possible\
    \ ways to collide the cars is given by Ulam numbers.\n        // Given the initial\
    \ state, to reduce it to the initial state\n        // of the Ulam sequence (1,\
    \ 2), we count the number of cars moving left to right,\n        // and the number\
    \ of cars moving right to left.  We can do this by looking at\n        // the\
    \ parity of n in its binary expansion.  If it ends in a zero, there is\n     \
    \   // an even number of cars moving left to right.  If it ends in a one, there\
    \ is\n        // an odd number of cars moving left to right.  Similarly, we can\
    \ count the\n        // parity of the number of cars moving right to left.  We\
    \ then subtract one\n        // from the number of cars moving right to left.\
    \  This yields a new number.\n        // We keep doing this until we reach the\
    \ Ulam sequence (1, 2).\n        var numberOfSteps = 0\n        while (n > 2)\
    \ {\n            var t = n\n            var parityOfNumberOfCarsMovingLeftToRight\
    \ = 1\n            var parityOfNumberOfCarsMovingRightToLeft = 1\n           \
    \ while (t != 0) {\n                if (t % 2 == 0) parityOfNumberOfCarsMovingLeftToRight\
    \ ^= 1\n                else parityOfNumberOfCarsMovingRightToLeft ^= 1\n    \
    \            t /= 2\n            }\n            if (parityOfNumberOfCarsMovingRightToLeft\
    \ == 0) n -= 1\n            else n += 1\n            numberOfSteps += 1\n    \
    \    }\n        return UlamNumber.get(numberOfSteps + 1, numberOfSteps + 2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd4fvf0gj.scala:35:62 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mif\e[0m (parityOfNumberOfCarsMovingRightToLeft\
    \ == \e[31m0\e[0m) n -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                  \
    \                                          ^^^^\e[0m\n\e[31m   |\e[0m        \
    \           value -= is not a member of Long - did you mean n.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpd4fvf0gj.scala:36:19 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33melse\e[0m n += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                 ^^^^\e[0m\n\e[31m   |\e[0m                 value\
    \ += is not a member of Long - did you mean n.!=?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpd4fvf0gj.scala:39:15 ------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mreturn\e[0m UlamNumber.get(numberOfSteps + \e[31m1\e[0m,\
    \ numberOfSteps + \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Not found: UlamNumber\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660012870
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n\tvar leftRight = ArrayBuffer[Long]()\n\
    \tvar rightLeft = ArrayBuffer[Long]()\n\tfor (i <- 1 to n.toInt) {\n\t    leftRight\
    \ += (i * 10)\n\t    rightLeft += (i * -10)\n\t}\n\tvar currIndex = 0\n\tvar result\
    \ = 0\n\tfor (left <- leftRight) {\n\t    for (i <- currIndex until rightLeft.length)\
    \ {\n\t\tif (left + rightLeft(i) == 0) {\n\t\t    result += 1\n\t\t    currIndex\
    \ = i + 1\n\t\t    break\n\t\t}\n\t    }\n\t}\n\tresult\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpalfrg1s8.scala:28:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m\t    }\n\e[31m\e[31m   |\e[0m\t    ^\e[0m\n\e[31m  \
    \ |\e[0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\
    \e[31m   |\e[0m   Previous indent : 2 tabs\n\e[31m   |\e[0m   Latest indent  \
    \ : 1 tab, 4 spaces\n\e[31m\e[31m-- Error: /tmp/tmpalfrg1s8.scala:31:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab\n\e[31m   |\e[0m   Latest indent   : 4\
    \ spaces\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpalfrg1s8.scala:26:4 -------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m\t\t    break\n\e[31m\e[31m   |\e[0m\t\t    ^^^^^\e[0m\n\
    \e[31m   |\e[0m\t\t    Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660012868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n\tval d = 1E8.toLong\n\tval m\
    \ = 1E9.toLong\n\tvar ans = 0L\n\tfor (i <- 1L to n) {\n\t    val j = (m - (i\
    \ * d) + (d / 2)) / d\n\t    if (j > 0 && j <= n) {\n\t\tif (i == j) ans += 1\n\
    \t\telse ans += 2\n\t    }\n\t}\n\tans\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpbnkoes7_.scala:21:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m\t    }\n\e[31m\e[31m   |\e[0m\t    ^\e[0m\n\e[31m  \
    \ |\e[0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\
    \e[31m   |\e[0m   Previous indent : 2 tabs\n\e[31m   |\e[0m   Latest indent  \
    \ : 1 tab, 4 spaces\n\e[31m\e[31m-- Error: /tmp/tmpbnkoes7_.scala:24:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab\n\e[31m   |\e[0m   Latest indent   : 4\
    \ spaces\n2 errors found\n"
  stdout: ''
  timestamp: 1660012868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var collisions = 0L\n\
    \        // left to right positions\n        val pos = Array.fill(n.toInt)(-1)\n\
    \        // positions of cars driving left to right\n        for (i <- 0 until\
    \ n.toInt) {\n            pos(i) = i * 2 * n\n        }\n        // positions\
    \ of cars driving right to left\n        for (i <- 0 until n.toInt) {\n      \
    \      // iterate through cars driving left to right\n            for (j <- 0\
    \ until n.toInt) {\n                if (pos(j) + i + 1 == pos(i)) collisions +=\
    \ 1\n            }\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzu94w2vj.scala:18:21\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            pos(i) = i * \e[31m2\e\
    [0m * n\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                     Found:    Long\n\e[31m   |\e[0m                     Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660012872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var collisions = 0L\n\
    \        var i = 1L\n        while (i <= n) {\n            collisions += i * i\n\
    \            i += 1\n        }\n        collisions\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjcpuqmcq.scala:22)\n\tat Problem.main(tmpjcpuqmcq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // INSERT CODE HERE\n\
    \        n * (n-1)\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeeolva6m.scala:17)\n\tat Problem.main(tmpeeolva6m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // left-to-right cars\
    \ will have increasing positions starting from 0\n        // right-to-left cars\
    \ will have decreasing positions starting from 0\n        // first pass: count\
    \ collisions where one left-to-right car hits at least one right-to-left car\n\
    \        // second pass: remove collisions that are counted more than once\n \
    \       val collisions = new HashMap[Long, Int]\n        for (leftToRightCar <-\
    \ 0 to n - 1) {\n            val rightToLeftCar = n - 1 - leftToRightCar\n   \
    \         val collisionPosition = leftToRightCar + rightToLeftCar\n          \
    \  collisions(collisionPosition) = collisions.getOrElse(collisionPosition, 0)\
    \ + 1\n        }\n        var result = 0L\n        collisions.foreach {case (position,\
    \ numberOfCollisions) => result += numberOfCollisions - 1}\n        result\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa5qhzvt7.scala:18:36\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mfor\e[0m (leftToRightCar\
    \ <- \e[31m0\e[0m to n - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m              \
    \                      ^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \         Found:    Long\n\e[31m   |\e[0m                                    Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660012872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n\t// first, let's define a type\
    \ class to represent a car.\n\tcase class Car(start : Int, end : Int)\n\t// Next,\
    \ let's find a way to simulate the race.\n\tval leftToRightCars = (0 until n.toInt).map(i\
    \ => Car(i, n.toInt)).toList\n\tval rightToLeftCars = (0 until n.toInt).map(i\
    \ => Car(n.toInt, i)).toList\n\t// Let's collide these cars.\n\tval collisions\
    \ = for (car1 <- leftToRightCars; car2 <- rightToLeftCars; if (car1.start < car2.start\
    \ && car1.end > car2.end)) yield (car1, car2)\n\tcollisions.length\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpec40km72.scala:21:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab\n\e[31m   |\e[0m   Latest indent   : 4\
    \ spaces\n1 error found\n"
  stdout: ''
  timestamp: 1660012870
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Every car moving left\
    \ to right can hit (n - 1) cars moving right to left.\n        // However, each\
    \ car moving right to left can only hit at most one car moving left to right.\n\
    \        // Every car moving right to left therefore can hit only (n - 1) cars\
    \ moving left to right.\n        // Since the two groups of cars have the same\
    \ number of cars, the number of collisions is simply\n        // n * (n - 1) +\
    \ n * (n - 1) = 2 * n * (n - 1).\n        2 * n * (n - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9dgk9i4n.scala:22)\n\tat Problem.main(tmp9dgk9i4n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012873
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Think of car i in set\
    \ 1 as a vector from point (-i, 0) to point (i, 0).\n        // Think of car i\
    \ in set 2 as a vector from point (i, 0) to point (-i, 0).\n        // Any collision\
    \ of the two cars corresponds to their intersection point.\n        // Any two\
    \ cars will intersect only if the following two conditions are met:\n        //\
    \ 1. The two lines are on the same line (i.e. parallel)\n        // 2. The line\
    \ segment of one car is completely inside the line segment of the other.\n   \
    \     // These two conditions are equivalent to, if line 1 is defined by points\
    \ p1 and q1\n        // and line 2 is defined by points p2 and q2, then:\n   \
    \     // 1. q1.x - p1.x = q2.x - p2.x (i.e. the lines are parallel)\n        //\
    \ 2. p1.x <= p2.x <= q1.x\n        //\n        // If a car in set 1 collides with\
    \ a car in set 2, then we can find the smallest\n        // i such that the car\
    \ in set 1 collides with car i in set 2.  We do this by doing\n        // binary\
    \ search on i.  The two conditions above are equivalent to q1.x - p1.x = i\n \
    \       // and p1.x - i <= 0.  Therefore the two conditions are equivalent to\n\
    \        // -i <= p1.x <= q1.x - i.  If q1.x - p1.x = i, then we can binary search\
    \ on p1.x.\n        // Let i = 2^a * b.  Then 2^a <= p1.x <= q1.x - 2^a.  This\
    \ can be done recursively.\n        // With this, we can find the smallest i such\
    \ that the car in set 1 collides with\n        // car i in set 2.  Then, car 2\
    \ in set 1 will collide with car 2 in set 2 and so on.\n        // Therefore the\
    \ total number of collisions is the smallest i such that the car in\n        //\
    \ set 1 collides with car i in set 2.\n        def bsearch(a : Long, b : Long)\
    \ : Long = {\n            if (b <=\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8r7ycaci.scala:35:20 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mif\e[0m (b <=\n\e[31m\e[31m   |\e[0m\
    \                    ^\e[0m\n\e[31m   |\e[0m                    expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp8r7ycaci.scala:46:0 ----------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8r7ycaci.scala:45:1 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmp8r7ycaci.scala:37:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m37 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660012875
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // find the x value where\
    \ the left-to-right cars collide\n        def xPoint(i : Long) : Long = n - i\n\
    \        // find the y value where the left-to-right cars collide\n        def\
    \ yPoint(i : Long) : Long = n - i\n        // find the x value where the right-to-left\
    \ cars collide\n        def zPoint(i : Long) : Long = i\n        // find the y\
    \ value where the right-to-left cars collide\n        def wPoint(i : Long) : Long\
    \ = n - i\n        (1 to n.toInt).map(i => {\n            val y = yPoint(i)\n\
    \            val w = wPoint(i)\n            val yi = (1 to y.toInt).map(j => {\n\
    \                val z = zPoint(j)\n                z\n            }).sum\n  \
    \          val wi = (1 to w.toInt).map(j => {\n                val x = xPoint(j)\n\
    \                x\n            }).sum\n            yi + wi\n        }).sum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpobyk8_3u.scala:36)\n\tat Problem.main(tmpobyk8_3u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012877
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        def carRaceCollision(n\
    \ : Long, i : Long, j : Long) : Long = {\n            if (i < j) 0\n         \
    \   else if (i == j) 0\n            else if (i == j + 1) 1\n            else carRaceCollision(n,\
    \ i, j + 1) + carRaceCollision(n, i - 1, j)\n        }\n        carRaceCollision(n,\
    \ n, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwca21qtl.scala:22)\n\tat Problem.main(tmpwca21qtl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012876
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        0\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppv1mg_kz.scala:16)\n\tat Problem.main(tmppv1mg_kz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The key insight is\
    \ that the two cars do not collide iff either both start at the same\n       \
    \ // position or the sum of their starting positions is an odd number.  Thus,\
    \ a collision\n        // occurs iff the sum of their starting positions is an\
    \ even number.\n        // Let's say the cars on the left are x_1, x_2, ..., x_n\
    \ and the cars on the right are y_1, y_2, ..., y_n.\n        // All the cars are\
    \ moving at the same speed.  Let's say x_1 moves at speed a and y_1 moves at speed\
    \ b.\n        // Without loss of generality, let a < b.  Then\n        // x_1\
    \ < x_2 < ... < x_n, b - a < y_1 < b - a + 1, b - a + 1 < y_2 < b - a + 2, ...\n\
    \        // Collision between x_1 and y_n occurs iff a + b + 1 is even;\n    \
    \    // Collision between x_1 and y_n-1 occurs iff a + b + 2 is even;\n      \
    \  // Collision between x_1 and y_n-2 occurs iff a + b + 3 is even;\n        //\
    \ ...\n        // Collision between x_1 and y_1 occurs iff a + b + n is even;\n\
    \        // Collision between x_2 and y_n occurs iff a + b + 2 is even;\n    \
    \    // Collision between x_2 and y_n-1 occurs iff a + b + 3 is even;\n      \
    \  // ...\n        // Collision between x_2 and y_2 occurs iff a + b + n + 1 is\
    \ even;\n        // ...\n        // Collision between x_n and y_1 occurs iff a\
    \ + b + 2n - 1 is even;\n        // There are n(n + 1) such pairs of cars.  Therefore,\
    \ the number of collisions is\n        // n(n + 1) / 2 - number of ways to choose\
    \ a and b such that a + b + 1, a + b + 2, ..., a + b + 2n - 1 are odd.\n     \
    \   //\n        // For example, let n = 5.  We want to determine the number of\
    \ ways\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4zfnzbku.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The key insight is that the two cars do not collide iff either both start\
    \ at the same\e[0m\n\e[31m14 |\e[0m        \e[34m// position or the sum of their\
    \ starting positions is an odd number.  Thus, a collision\e[0m\n\e[31m15 |\e[0m\
    \        \e[34m// occurs iff the sum of their starting positions is an even number.\e\
    [0m\n\e[31m16 |\e[0m        \e[34m// Let's say the cars on the left are x_1, x_2,\
    \ ..., x_n and the cars on the right are y_1, y_2, ..., y_n.\e[0m\n\e[31m17 |\e\
    [0m        \e[34m// All the cars are moving at the same speed.  Let's say x_1\
    \ moves at speed a and y_1 moves at speed b.\e[0m\n\e[31m18 |\e[0m        \e[34m//\
    \ Without loss of generality, let a < b.  Then\e[0m\n\e[31m19 |\e[0m        \e\
    [34m// x_1 < x_2 < ... < x_n, b - a < y_1 < b - a + 1, b - a + 1 < y_2 < b - a\
    \ + 2, ...\e[0m\n\e[31m20 |\e[0m        \e[34m// Collision between x_1 and y_n\
    \ occurs iff a + b + 1 is even;\e[0m\n\e[31m21 |\e[0m        \e[34m// Collision\
    \ between x_1 and y_n-1 occurs iff a + b + 2 is even;\e[0m\n\e[31m22 |\e[0m  \
    \      \e[34m// Collision between x_1 and y_n-2 occurs iff a + b + 3 is even;\e\
    [0m\n\e[31m23 |\e[0m        \e[34m// ...\e[0m\n\e[31m24 |\e[0m        \e[34m//\
    \ Collision between x_1 and y_1 occurs iff a + b + n is even;\e[0m\n\e[31m25 |\e\
    [0m        \e[34m// Collision between x_2 and y_n occurs iff a + b + 2 is even;\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// Collision between x_2 and y_n-1 occurs iff\
    \ a + b + 3 is even;\e[0m\n\e[31m27 |\e[0m        \e[34m// ...\e[0m\n\e[31m28\
    \ |\e[0m        \e[34m// Collision between x_2 and y_2 occurs iff a + b + n +\
    \ 1 is even;\e[0m\n\e[31m29 |\e[0m        \e[34m// ...\e[0m\n\e[31m30 |\e[0m \
    \       \e[34m// Collision between x_n and y_1 occ"
  stdout: ''
  timestamp: 1660012876
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var occupied = Set[Long]()\n\
    \        var count = 0L\n        for (i <- 1L to n) {\n            if (occupied.contains(i))\
    \ count += 1\n            occupied += n + 1 - i\n        }\n        count\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_634vknp.scala:22)\n\tat Problem.main(tmp_634vknp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012878
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This problem is not\
    \ unlike choosing pairs in a combinatorial question.\n        // The difference\
    \ is, we want to include a restriction on the pairs so they\n        // do not\
    \ overlap.\n        // Consider the formula:\n        // (n * (n-1))/2 - n^2\n\
    \        // which generates the sequence:\n        // 0, -1, -3, -6, -10, -15,\
    \ -21, -28, -36, -45, -55, -66, -78, -91, -105, -120, -136, -153, -171, -190\n\
    \        // This is the sequence of collisions, starting from n = 1.\n       \
    \ // For a proof of this formula, see this link:\n        // https://brilliant.org/discussions/thread/collision-numbers/\n\
    \        // ^ This link is provided by https://projecteuler.net/problem=621\n\
    \        return (n * (n-1))/2 - n*n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu554cfk5.scala:27)\n\tat Problem.main(tmpu554cfk5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012877
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        if (n == 0) return 0\n\
    \        var i = 1\n        var count = 0\n        while (i <= n) {\n        \
    \    if (n % i == 0) count += 1\n            i += 1\n        }\n        return\
    \ n * count / 2\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm67id75b.scala:23)\n\tat Problem.main(tmpm67id75b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012877
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        def gcd(a : Long, b :\
    \ Long) : Long = {\n            if (b == 0) a else gcd(b, a % b)\n        }\n\
    \        val n2 = n * n\n        val d : Long = (1 to n.toInt).foldLeft(0L) {\n\
    \            case (acc, i) => acc + gcd(i, n)\n        }\n        n2 - d\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3v30vfan.scala:23)\n\tat Problem.main(tmp3v30vfan.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This is the number\
    \ of numbers in the range [1, n] that are coprime with n.\n        // See http://en.wikipedia.org/wiki/Euler's_totient_function#Euler.27s_product_formula\n\
    \        // for details.\n        val phi = (2 to n.toInt).filter(e => BigInt(e).gcd(n)\
    \ == 1).length.toLong\n        val result = n * (n - 1) - phi\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp24n56cob.scala:21)\n\tat Problem.main(tmp24n56cob.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n    \tval collision = (1 to n.toInt).combinations(2).toList.map(x\
    \ => x(0) * (n - x(1) + 1)).sum\n    \tcollision\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7f_wf2vn.scala:17)\n\tat Problem.main(tmp7f_wf2vn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var count = 0L\n     \
    \   for (i <- 1L to n)\n            count += 2 * i - 1\n        count\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var a = new Array[Long](n.toInt)\n\
    \        for (i <- 0 until n.toInt) {\n            a(i) = n - 1 - i\n        }\n\
    \        a.foreach(i => println(i))\n        var sum = 0L\n        for (i <- 0\
    \ until n.toInt) {\n            if (i == 0) sum += 2 * a(i) * (n - 1)\n      \
    \      else sum += 2 * a(i) * (n - 1 - i)\n        }\n        return sum\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5byq1pxe.scala:26)\n\tat Problem.main(tmp5byq1pxe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: '1

    0

    '
  timestamp: 1660012881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // First car goes from\
    \ A to B with speed 1\n        // Second car goes from B to A with speed 2\n \
    \       // Third car goes from A to B with speed 3\n        // ...\n        //\
    \ nth car goes from B to A with speed n\n        // The point B is at position\
    \ 0.  Position A is to the left of B.\n        // Now calculate the time at which\
    \ the first n cars meet.\n        var carIndex = 1\n        var time = 0.0\n \
    \       var carToMeet = 0\n        while (carIndex <= n) {\n            val position\
    \ = carIndex - carIndex * time\n            if (position >= 0) {\n           \
    \     carToMeet += 1\n                if (carToMeet == n) return carIndex - 1\n\
    \            }\n            carIndex += 1\n            time += 1 / carIndex.toDouble\n\
    \        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcrkxgddw.scala:35)\n\tat Problem.main(tmpcrkxgddw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val l : Array[Long] =\
    \ Array.fill(100000)(0)\n        var c = 1\n        var i = 0\n        while (i\
    \ < n) {\n            c += i + 1\n            val t = l(i)\n            l(i) =\
    \ c\n            c += t\n            i += 1\n        }\n        c - n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4cng02vy.scala:20:14 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            c += t\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int - did\
    \ you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660012880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var result = 0L\n    \
    \    for (i <- 2 to n.toInt) {\n            result += 2 * factorial(n.toInt) /\
    \ (factorial(i) * factorial(n.toInt - i))\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7shar40g.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            result += \e[31m2\e[0m * factorial(n.toInt)\
    \ / (factorial(i) * factorial(n.toInt - i))\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Long\
    \ - did you mean Long.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7shar40g.scala:15:26\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            result += \e\
    [31m2\e[0m * factorial(n.toInt) / (factorial(i) * factorial(n.toInt - i))\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Not found: factorial\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660012881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var i = 0L\n        var\
    \ ans = 0L\n        while (i < n) {\n            var j = 0L\n            while\
    \ (j < n) {\n                if (i + j == n - 1) ans += 1\n                j +=\
    \ 1\n            }\n            i += 1\n        }\n        ans\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpywmyjivj.scala:26)\n\tat Problem.main(tmpywmyjivj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012881
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // speed(i) is the speed\
    \ of the ith car that is driving left to right\n        // lane(i) is the lane\
    \ (0-indexed) that the ith car that is driving left to right is currently in\n\
    \        // lane(i) is the lane (0-indexed) that the ith car that is driving right\
    \ to left is currently in\n        // we assume that (1 to n).toList.forall(i\
    \ => lane(i) == 0)\n        def speed(i : Long) : Double = i.toDouble\n      \
    \  def lane(i : Long) : Long = {\n            if (i <= (n + 1) / 2) i - 1\n  \
    \          else n - i\n        }\n        def time = {\n            def f(i :\
    \ Long) : Double = i.toDouble / speed(i)\n            f(1) + (2 to n).map(f).max\n\
    \        }\n        // this is the heart of the algorithm.  we examine all the\
    \ cars at the same time\n        // and see if a collision occurs.\n        def\
    \ solve : Long = {\n            val map = new HashMap[Long, Long]\n          \
    \  for (i <- 1 to n.toInt) {\n                val x = (n - i).toLong\n       \
    \         val y = lane(x)\n                if (map.contains(y)) map.put(y, map(y)\
    \ + 1)\n                else map.put(y, 1)\n            }\n            val x =\
    \ (n + 1) / 2\n            val y = lane(x)\n            if (map.contains(y)) map(y)\
    \ else 0\n        }\n        solve\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7u1jhcob.scala:24:25\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            f(\e[31m1\e[0m) +\
    \ (\e[31m2\e[0m to n).map(f).max\n\e[31m\e[31m   |\e[0m                      \
    \   ^\e[0m\n\e[31m   |\e[0m                         Found:    (n : Long)\n\e[31m\
    \   |\e[0m                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp7u1jhcob.scala:24:32 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            f(\e[31m1\e[0m) + (\e[31m2\e[0m to n).map(f).max\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \                               Found:    \e[1m\e[31mLong\e[0m => Double\n\e[31m\
    \   |\e[0m                                Required: \e[1m\e[32mInt\e[0m => Double\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660012882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to first\
    \ note that we have n cars moving in the same speed, so\n        // they'll reach\
    \ the same destination at the same time.  For each of the n cars,\n        //\
    \ we need to determine how many cars on the opposing side do they collide.\n \
    \       // Now, we make an observation:  if there are n cars moving in the same\
    \ speed,\n        // it's easy to see that the set of them can be sorted by their\
    \ starting positions\n        // without loss of generality.  Since this is symmetric,\
    \ we can also assume that\n        // the starting position of the cars moving\
    \ on the opposite direction can also be\n        // sorted.  This means we can\
    \ arbitrarily assume that the first car moving left to right\n        // starts\
    \ at position 0, and the first car moving right to left starts at position x,\
    \ for\n        // some x (x is not a distance, but an index).  Now the ith car\
    \ moving left to right\n        // has position i, and the ith car moving right\
    \ to left has position x - i.  We now have\n        // two series of numbers.\
    \  The ith number of the first series is i.  The ith number of\n        // the\
    \ second series is x - i.  We can see that this is a geometric progression with\n\
    \        // ratio 1/2.  For example, let's say x = 10 and n = 3.  Then we get\n\
    \        // left to right: 0, 1, 2\n        // right to left: 10, 9, 8\n     \
    \   // The point is, this means we can find the number of opposing cars that the\
    \ ith car\n        // of one side collides against easily: we just need to find\
    \ how many elements of the\n        // other series are less than or equal to\
    \ the ith element of this series.  But, this is\n        // just the position\
    \ of the ith element in a geometric progression with ratio 1/2!\n        // Thus,\
    \ the total number of collisions is the sum of the positions of all the elements\n\
    \        // in the series.  Now, if you're familiar with the sum of a geometric\
    \ progression,\n        // this sum is\n        // x * (n + 1) / 2 - n * (n +\
    \ 1) / 4\n        // However, x is not given.  We can get rid of x by noting that\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp719r73wi.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// The idea is to first note that we have n cars moving in the same speed,\
    \ so\e[0m\n\e[31m14 |\e[0m        \e[34m// they'll reach the same destination\
    \ at the same time.  For each of the n cars,\e[0m\n\e[31m15 |\e[0m        \e[34m//\
    \ we need to determine how many cars on the opposing side do they collide.\e[0m\n\
    \e[31m16 |\e[0m        \e[34m// Now, we make an observation:  if there are n cars\
    \ moving in the same speed,\e[0m\n\e[31m17 |\e[0m        \e[34m// it's easy to\
    \ see that the set of them can be sorted by their starting positions\e[0m\n\e\
    [31m18 |\e[0m        \e[34m// without loss of generality.  Since this is symmetric,\
    \ we can also assume that\e[0m\n\e[31m19 |\e[0m        \e[34m// the starting position\
    \ of the cars moving on the opposite direction can also be\e[0m\n\e[31m20 |\e\
    [0m        \e[34m// sorted.  This means we can arbitrarily assume that the first\
    \ car moving left to right\e[0m\n\e[31m21 |\e[0m        \e[34m// starts at position\
    \ 0, and the first car moving right to left starts at position x, for\e[0m\n\e\
    [31m22 |\e[0m        \e[34m// some x (x is not a distance, but an index).  Now\
    \ the ith car moving left to right\e[0m\n\e[31m23 |\e[0m        \e[34m// has position\
    \ i, and the ith car moving right to left has position x - i.  We now have\e[0m\n\
    \e[31m24 |\e[0m        \e[34m// two series of numbers.  The ith number of the\
    \ first series is i.  The ith number of\e[0m\n\e[31m25 |\e[0m        \e[34m//\
    \ the second series is x - i.  We can see that this is a geometric progression\
    \ with\e[0m\n\e[31m26 |\e[0m        \e[34m// ratio 1/2.  For example, let's say\
    \ x = 10 and n = 3.  Then we get\e[0m\n\e[31m27 |\e[0m        \e[34m// left to\
    \ right: 0, 1, 2\e[0m\n\e[3"
  stdout: ''
  timestamp: 1660012881
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n\tdef coll(i : Long, j : Long)\
    \ : Long = {\n\t    if (i > j) 0\n\t    else if (i == j) coll(i + 1, j - 1)\n\t\
    \    else if (i < j) {\n\t\t2 * (i - 1) + coll(i + 1, j - 1)\n\t    }\n\t    else\
    \ throw new Exception(\"never get here\")\n\t}\n\tcoll(1, n)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpbctynsah.scala:18:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m\t    }\n\e[31m\e[31m   |\e[0m\t    ^\e[0m\n\e[31m  \
    \ |\e[0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\
    \e[31m   |\e[0m   Previous indent : 2 tabs\n\e[31m   |\e[0m   Latest indent  \
    \ : 1 tab, 4 spaces\n\e[31m\e[31m-- Error: /tmp/tmpbctynsah.scala:22:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab\n\e[31m   |\e[0m   Latest indent   : 4\
    \ spaces\n2 errors found\n"
  stdout: ''
  timestamp: 1660012878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n      var path  = (1 to n.toInt).map(x\
    \ => new Car(\"r\", n-x+1)).toList\n      var path2 = (1 to n.toInt).map(x =>\
    \ new Car(\"l\", x)).toList\n      var res = 0\n      while(path2.length > 0)\
    \ {\n        var start = path2.head\n        path = path.filter(_.distance !=\
    \ start.distance)\n        path2 = path2.tail\n        if(path.length > 0) {\n\
    \          val dist = path.filter(_.distance < start.distance).length\n      \
    \    res += dist\n        }\n      }\n      return res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk894owfj.scala:13:46 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m      \e[33mvar\e[0m \e[36mpath\e[0m  = (\e[31m1\e[0m\
    \ to n.toInt).map(\e[36mx\e[0m => \e[33mnew\e[0m \e[35mCar\e[0m(\e[31m\"r\"\e\
    [0m, n-x+\e[31m1\e[0m)).toList\n\e[31m\e[31m   |\e[0m                        \
    \                      ^^^\e[0m\n\e[31m   |\e[0m                             \
    \                 Not found: type Car\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpk894owfj.scala:14:46 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m      \e[33mvar\e[0m \e[36mpath2\e[0m = (\e[31m1\e[0m to n.toInt).map(\e\
    [36mx\e[0m => \e[33mnew\e[0m \e[35mCar\e[0m(\e[31m\"l\"\e[0m, x)).toList\n\e[31m\e\
    [31m   |\e[0m                                              ^^^\e[0m\n\e[31m  \
    \ |\e[0m                                              Not found: type Car\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk894owfj.scala:18:29\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        path = path.filter(_.distance\
    \ != start.distance)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value distance is not a member\
    \ of Nothing\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk894owfj.scala:21:35\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m          \e[33mval\e[0m\
    \ \e[36mdist\e[0m = path.filter(_.distance < start.distance).length\n\e[31m\e\
    [31m   |\e[0m                                 ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                               value distance is not a member of Nothing\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660012883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val r = new Random\n \
    \       // randomly generate the speed of all cars\n        val carSpeeds = Array.fill(n.toInt)(r.nextInt(2\
    \ * n.toInt))\n        println(carSpeeds.mkString(\" \"))\n        // a car is\
    \ moving left to right if it's speed is positive, right to left if it's speed\
    \ is negative\n        val leftToRightCars = carSpeeds.filter(_ > 0)\n       \
    \ val rightToLeftCars = carSpeeds.filter(_ < 0)\n        // sort the arrays by\
    \ speeds\n        scala.util.Sorting.quickSort(leftToRightCars)\n        scala.util.Sorting.quickSort(rightToLeftCars)\n\
    \        var collisions = 0\n        var i = 0\n        var j = 0\n        //\
    \ one pointer moves from left to right, the other moves from right to left\n \
    \       // whenever their speeds are the same, the cars collide\n        while\
    \ (i < leftToRightCars.length && j < rightToLeftCars.length) {\n            if\
    \ (leftToRightCars(i) == -rightToLeftCars(j)) {\n                collisions +=\
    \ 1\n                i += 1\n                j += 1\n            } else if (leftToRightCars(i)\
    \ > -rightToLeftCars(j)) {\n                j += 1\n            } else i += 1\n\
    \        }\n        collisions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxposnu6z.scala:13:20 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m\
    \ \e[35mRandom\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: type Random\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpxposnu6z.scala:15:67 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mcarSpeeds\e[0m = Array.fill(n.toInt)(r.nextInt(\e\
    [31m2\e[0m * n.toInt))\n\e[31m\e[31m   |\e[0m                                \
    \                                   ^\e[0m\n\e[31m   |\e[0m                  \
    \                        No ClassTag available for T\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m                                          where:    T is a type variable\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660012883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // If we number the cars\
    \ from 1 to n and let R(i) be the position of the i'th car\n        // driving\
    \ right to left and L(i) be the position of the i'th car driving left to right,\n\
    \        // then collisions happen only when R(i) == L(j).\n        // To speed\
    \ up computation, we divide by n and let R(i) be the position of the i'th car\n\
    \        // driving right to left and L(i) be the position of the i'th car driving\
    \ left to right,\n        // where i, j range from 0 to n-1.\n        //\n   \
    \     // Define E(i) = (R(i) - L(i)).  Note that the i'th car and the j'th car\
    \ collide if and only if\n        // E(i) == E(j) and i != j.\n        // To compute\
    \ the number of collisions, note that\n        // E(i) = R(i) - L(i) = (i+1)/n\
    \ - (n-i)/n\n        // E(i) = 2*i/n + 1/n - n/n\n        // E(i) = 2*i/n + 1/n\
    \ - 1\n        // E(i) = 2*i/n + 1/n - 1\n        // E(i) = 2*i/n + (1-1)/n\n\
    \        // E(i) = 2*i/n + 0\n        // E(i) = 2*i/n\n        // This means that\
    \ E(i) = 2*i/n and E(j) = 2*j/n for i != j.\n        // Hence, there are n*(n-1)/2\
    \ collisions in this problem.\n        val collisions = n * (n - 1) / 2\n    \
    \    collisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa3810nty.scala:36)\n\tat Problem.main(tmpa3810nty.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val pq = new PriorityQueue[Int]()(Ordering.Int.reverse)\n\
    \        var count = 0\n        for (i <- 1 to n.toInt) {\n            while (!pq.isEmpty\
    \ && pq.dequeue < i) count += 1\n            pq.enqueue(i + n.toInt)\n       \
    \ }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8512uupv.scala:22)\n\tat Problem.main(tmp8512uupv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012884
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        n * (n - 1) / 2\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8356y_m4.scala:16)\n\tat Problem.main(tmp8356y_m4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var collisions = 0L\n\
    \        val c = new Array[(Long, Long)](n.toInt)\n        for (i <- 0 until n.toInt)\
    \ {\n            c(i) = (i, n - i - 1)\n        }\n        for (i <- 0 until n.toInt)\
    \ {\n            for (j <- i + 1 until n.toInt) {\n                val (a, b)\
    \ = c(i)\n                val (c, d) = c(j)\n                if (a > c && b <\
    \ d) collisions += 1\n                if (c > a && d < b) collisions += 1\n  \
    \          }\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpunphep6i.scala:21:29 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mval\e[0m (c, d) = c(j)\n\e[31m\e\
    [31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m            \
    \                 Recursive \e[33mvalue\e[0m \e[35mc\e[0m needs type\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpunphep6i.scala:21:24 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mval\e[0m (c, d) = c(j)\n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       Recursive \e[33mvalue\e[0m \e[35m$2$\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpunphep6i.scala:21:26 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mval\e[0m (c, d) = c(j)\n\e[31m\e\
    [31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m               \
    \           Recursive \e[33mvalue\e[0m \e[35mc\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E050] Type Error: /tmp/tmpunphep6i.scala:20:29 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mval\e[0m (a, b) = c(i)\n\e[31m\e\
    [31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m            \
    \                 \e[33mvalue\e[0m \e[35mc\e[0m does not take parameters\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpunphep6i.scala:20:21 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mval\e[0m (a, b) = c(i)\n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpunphep6i.scala:20:24 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mval\e[0m (a, b)"
  stdout: ''
  timestamp: 1660012887
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        def draw(height : Long,\
    \ nodes : List[(Long, Long)]) : Unit = {\n            val minX = nodes.minBy(_._1)._1\n\
    \            val maxX = nodes.maxBy(_._1)._1\n            val minY = nodes.minBy(_._2)._2\n\
    \            val maxY = nodes.maxBy(_._2)._2\n            for (y <- maxY to minY\
    \ by -1) {\n                for (x <- minX to maxX) {\n                    if\
    \ (nodes.exists(coord => coord._1 == x && coord._2 == y)) print(\"X\")\n     \
    \               else print(\".\")\n                }\n                println()\n\
    \            }\n        }\n        val minCoord = -(n - 1)\n        val maxCoord\
    \ = n - 1\n        val uniqueTuples = minCoord.to(maxCoord).flatMap(x => minCoord.to(maxCoord).map(y\
    \ => (x, y))).toList\n        val permutations = uniqueTuples.combinations(n.toInt).toList\n\
    \        permutations.foreach(permutation => {\n            val leftCarCoords\
    \ = permutation.map(coord => (coord._1, coord._2)).sortBy(_._1)\n            val\
    \ rightCarCoords = permutation.map(coord => (coord._1, -coord._2)).sortBy(_._1)\n\
    \            val collidingPairs = leftCarCoords.intersect(rightCarCoords)\n  \
    \          //println(leftCarCoords)\n            //println(rightCarCoords)\n \
    \           //println(collidingPairs)\n            //println()\n            //draw(n,\
    \ leftCarCoords ++ rightCarCoords)\n        })\n        //println(permutations.length)\n\
    \        0\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsae1l7r0.scala:44)\n\tat Problem.main(tmpsae1l7r0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // On each collision,\
    \ a left-to-right car can collide with a right-to-left car in [1, 2n - 1] ways,\n\
    \        // where n is the number of cars on each side.\n        // This is because\
    \ there's n cars on each side, and the car that's on the leftmost can only collide\n\
    \        // with the car that's on the rightmost.  Similarly, the car that's in\
    \ second place from the left can\n        // only collide with the car that's\
    \ in second place from the right.  And so on.\n        // The total number of\
    \ collisions is the sum from 1 to 2n - 1 of these numbers, which is\n        //\
    \ n * 2n - n, which equals n^2\n        n * n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012887
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // speed : number of cars\
    \ that move at that speed\n        val leftToRight = new HashMap[Int, Long]\n\
    \        val rightToLeft = new HashMap[Int, Long]\n        for (i <- 1 to n.toInt)\
    \ {\n            if (i % 2 == 0) {\n                val x = leftToRight.getOrElse(i,\
    \ 0L)\n                leftToRight.put(i, x + 1)\n            } else {\n     \
    \           val x = rightToLeft.getOrElse(i, 0L)\n                rightToLeft.put(i,\
    \ x + 1)\n            }\n        }\n        // For each speed, there are n / speed\
    \ cars.\n        var result = 0L\n        for (i <- 1 to n.toInt) {\n        \
    \    val left = leftToRight.getOrElse(i, 0L)\n            val right = rightToLeft.getOrElse(i,\
    \ 0L)\n            result += left * right\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwvy0blb_.scala:35)\n\tat Problem.main(tmpwvy0blb_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // map[key,value] is a\
    \ hashmap type in Scala which can be accessed by map[key] and\n        // also\
    \ has a getOrElse method which takes a default value.  The default value will\n\
    \        // be used if map[key] is not in the map.\n        // The format of the\
    \ map is map[car velocity, number of cars with this velocity]\n        var mapLeftToRight\
    \ = Map[Long, Long]()\n        var mapRightToLeft = Map[Long, Long]()\n      \
    \  // This function is used to add a car to the map.\n        def addCar(map :\
    \ Map[Long, Long], v : Long) {\n            map(v) = map.getOrElse(v, 0) + 1\n\
    \        }\n        // This function is used to add a car to the map and return\
    \ the number of collisions.\n        def addCarCollision(map : Map[Long, Long],\
    \ v : Long) : Long = {\n            // The collisions of a car depend on the number\
    \ of cars of equal or greater speed.\n            val collisions = map.getOrElse(v,\
    \ 0)\n            map(v) = map.getOrElse(v, 0) + 1\n            collisions\n \
    \       }\n        // This function is used to remove a car from the map.\n  \
    \      def removeCar(map : Map[Long, Long], v : Long) {\n            val n = map(v)\n\
    \            if (n == 1) map.remove(v)\n            else map(v) = n - 1\n    \
    \    }\n        // This loop adds cars to the left to right map while removing\
    \ cars from the right to left map.\n        // It computes the number of collisions.\n\
    \        // The loop takes O(sqrt(n)) time.\n        // We do not need to loop\
    \ over the entire car velocity range because the number of cars\n        // with\
    \ the same velocity is at most sqrt(n).\n        for (i <- 0L until sqrt(n).toLong)\
    \ {\n            val v = n - i * i\n            val collisions = addCarCollision(mapLeftToRight,\
    \ v)\n            removeCar(mapRightToLeft, v)\n            // collisions is the\
    \ number of collisions of this car\n            // Add to the total number of\
    \ collisions\n            println\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9u5hjn9m.scala:20:52 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mdef\e[0m \e[36maddCar\e[0m(\e[36mmap\e\
    [0m : \e[35mMap\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m], \e[36mv\e[0m : \e[35mLong\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                                                \
    \    ^\e[0m\n\e[31m   |\e[0m                                             '=' expected,\
    \ but '{' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9u5hjn9m.scala:31:55\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mdef\e[0m\
    \ \e[36mremoveCar\e[0m(\e[36mmap\e[0m : \e[35mMap\e[0m[\e[35mLong\e[0m, \e[35mLong\e\
    [0m], \e[36mv\e[0m : \e[35mLong\e[0m) {\n\e[31m\e[31m   |\e[0m               \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                                '=' expected, but '{' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmp9u5hjn9m.scala:58:0 ----------------------------\e[0m\e\
    [0m\n\e[31m58 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9u5hjn9m.scala:27:41\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            map(v) = map.getOrElse(v,\
    \ \e[31m0\e[0m) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of AnyVal, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp9u5hjn9m.scala:28:12 --------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            collisions\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    (collisions : AnyVal)\n\e[31m   |\e\
    [0m            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Er"
  stdout: ''
  timestamp: 1660012890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The answer is n*(n-1)/2\n\
    \        n*(n-1)/2\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxergpkcr.scala:17)\n\tat Problem.main(tmpxergpkcr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's assume that the\
    \ cars move at the same speed of 1 meter per second.\n        // We'll locate\
    \ each car by its position, which means that it's a point on the real number line.\n\
    \        // Let's assume that the left-to-right cars are in the set L and the\
    \ right-to-left cars are in\n        // the set R.  Suppose that the right-to-left\
    \ cars have positions r1, r2, r3, ..., rn.\n        // Let's sort these positions\
    \ in ascending order; we get r1 <= r2 <= r3 <= ... <= rn.\n        // Then we\
    \ have:\n        // n - 1 collisions among the right-to-left cars\n        //\
    \ n - 1 collisions among the left-to-right cars\n        // n choose 2 collisions\
    \ among the cars (each pair of cars contributes to one collision)\n        //\
    \ In total, we have 2n - 1 collisions, which is the same as (n choose 2) + n -\
    \ 1.\n        if (n == 0) {\n            return 0\n        }\n        return (n\
    \ * (n - 1)) / 2 + n - 1\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa8qvrfmb.scala:29)\n\tat Problem.main(tmpa8qvrfmb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var leftToRight = new\
    \ Array[Long](n.toInt)\n        var rightToLeft = new Array[Long](n.toInt)\n \
    \       for (i <- 0 until n.toInt) {\n            leftToRight(i) = i\n       \
    \     rightToLeft(i) = n - i - 1\n        }\n        leftToRight = leftToRight.sorted\n\
    \        rightToLeft = rightToLeft.sorted\n        var collisions = 0\n      \
    \  var i = 0\n        var j = 0\n        while (i < n.toInt && j < n.toInt) {\n\
    \            if (leftToRight(i) < rightToLeft(j)) {\n                collisions\
    \ += j\n                i += 1\n            } else {\n                j += 1\n\
    \            }\n        }\n        collisions\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps3fijueq.scala:35)\n\tat Problem.main(tmps3fijueq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        n * (n - 1) / 2\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8356y_m4.scala:16)\n\tat Problem.main(tmp8356y_m4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // This problem can be\
    \ solve by mapping the problem to a function with\n        // a special property.\
    \  Let f(x) be the function that maps x to the number\n        // of collisions\
    \ that occur when x cars are driving left to right and x cars\n        // are\
    \ driving right to left.  Let D be the domain of f.  Note that f is \n       \
    \ // symmetric around the origin.  Thus, f(x) = f(-x).  Moreover, f(x) = f(y)\n\
    \        // when x and y differ by n.  These two properties leads to the formula:\n\
    \        // f(x) = min(x, -x)\n        // as x ranges from 0 to n - 1.\n     \
    \   return n * (n - 1) / 2;\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvknv7jei.scala:24)\n\tat Problem.main(tmpvknv7jei.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        if (n < 0) {\n       \
    \     return 0\n        }\n        val r = n * (n - 1) / 2\n        r\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvp5b60kt.scala:20)\n\tat Problem.main(tmpvp5b60kt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val leftRight = Array.fill(n.toInt)(0)\n\
    \        val rightLeft = Array.fill(n.toInt)(0)\n        for (i <- 0 until n.toInt)\
    \ {\n            leftRight(i) = scala.io.StdIn.readInt\n            rightLeft(i)\
    \ = scala.io.StdIn.readInt\n        }\n        var collisions = 0L\n        for\
    \ (i <- 0 until n.toInt) {\n            for (j <- 0 until n.toInt) {\n       \
    \         if (leftRight(i) < rightLeft(j)) collisions += 1\n            }\n  \
    \      }\n        collisions\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.io.EOFException: Console has reached end of input\n\tat scala.io.StdIn.readInt(StdIn.scala:120)\n\
    \tat scala.io.StdIn.readInt$(StdIn.scala:117)\n\tat scala.io.StdIn$.readInt(StdIn.scala:241)\n\
    \tat Problem$.carRaceCollision$$anonfun$1(tmp9zzp696c.scala:16)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.carRaceCollision(tmp9zzp696c.scala:18)\n\
    \tat Problem$.main(tmp9zzp696c.scala:28)\n\tat Problem.main(tmp9zzp696c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        def gcd(a : Long, b :\
    \ Long) : Long = {\n            if (b == 0) a else gcd(b, a % b)\n        }\n\
    \        val pos = (0L until n).map(x => x + 1).map(x => (x, x)).toArray\n   \
    \     val neg = (0L until n).map(x => -x - 1).map(x => (x, x)).toArray\n     \
    \   // process in sweeps\n        def processSweep(sorted : Array[(Long, Long)])\
    \ : Long = {\n            // sort by distance\n            val processed = ArrayBuffer[(Long,\
    \ Long)]()\n            for (i <- 0 until sorted.length) {\n                var\
    \ found = false\n                for (j <- 0 until processed.length) {\n     \
    \               val (x, y) = processed(j)\n                    if (x <= sorted(i)._1\
    \ && sorted(i)._1 <= y) {\n                        found = true\n            \
    \            processed(j) = (x, sorted(i)._2)\n                    }\n       \
    \         }\n                if (!found) processed += ((sorted(i)._1, sorted(i)._2))\n\
    \            }\n            // sort by start\n            val sorted2 = processed.sortBy(x\
    \ => x._1)\n            val result = ArrayBuffer[(Long, Long)]()\n           \
    \ var current : (Long, Long) = null\n            for (i <- 0 until sorted2.length)\
    \ {\n                if (current == null) current = sorted2(i)\n             \
    \   else {\n                    if (current._2 >= sorted2(i)._1) {\n         \
    \               current = (current._1, max(current._2, sorted2(i)._2))\n     \
    \               } else {\n                        result += current\n        \
    \                current = sorted2(i)\n                    }\n               \
    \ }\n            }\n            if (current != null) result += current\n     \
    \       // sort by start\n            result.sortBy(x => x._1).map(x => x._2 -\
    \ x._1 + 1).sum\n        }\n        // sort by sign\n        val sorted = (pos\
    \ ++ neg).sortBy(x => x._1)\n        // first sweep\n        var (j, k) = (0,\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9me1dj86.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9me1dj86.scala:56:5 ---------------------\e[0m\e[0m\n\e[31m56 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660012892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the starting\
    \ point of a left to right car is p.\n        // The starting point of the corresponding\
    \ right to left car is -p.\n        // The point of collision is when p+t=1/(p-t)\n\
    \        // Quadratic formula shows that t is the positive square root of (1+1/p^2)\n\
    \        // So the total time that it takes for the collision is (1+1/p^2)^(1/2)\n\
    \        // The number of cars that can collide is the number of p's such that\n\
    \        // (1+1/p^2)^(1/2) < p\n        // Since (1+1/p^2)^(1/2) < 1+1/(2p^2),\
    \ we have\n        // (1+1/p^2)^(1/2) < p  iff  1+1/(2p^2) < p  iff  1/p^2 < 1/(2p^2)\
    \  iff  1 < 2\n        // So the answer is n-1.\n        n - 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpigt38yhb.scala:26)\n\tat Problem.main(tmpigt38yhb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val max = 2 * n * n\n\
    \        val mod = 1000000007\n        var sum = 0L\n        for (i <- 1 to max.toInt)\
    \ {\n            val first = (i - 1) / n\n            val second = i % n\n   \
    \         if (first == second) {\n                sum += 1\n            }\n  \
    \      }\n        sum % mod\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg93i_4v4.scala:26)\n\tat Problem.main(tmpg93i_4v4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n\tval positions = HashMap[Long,\
    \ Long]()\n\tfor (i <- 0 to n.toInt - 1) {\n\t    val left = (i * -1) + 1\n\t\
    \    positions(left) = positions.getOrElse(left, 0) + 1\n\t    val right = i +\
    \ 1\n\t    positions(right) = positions.getOrElse(right, 0) + 1\n\t}\n\tpositions.values.foldLeft(0)((total,\
    \ current) => total + (current - 1) * current / 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5i8bklrm.scala:21:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m   Incompatible combinations of tabs and spaces in indentation prefixes.\n\e\
    [31m   |\e[0m   Previous indent : 1 tab\n\e[31m   |\e[0m   Latest indent   : 4\
    \ spaces\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5i8bklrm.scala:16:51\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m\t    positions(left) = positions.getOrElse(left,\
    \ \e[31m0\e[0m) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\t                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of AnyVal, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp5i8bklrm.scala:18:53 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m\t    positions(right) = positions.getOrElse(right, \e[31m0\e\
    [0m) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\t                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of AnyVal, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp5i8bklrm.scala:20:49 --------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m\tpositions.values.foldLeft(\e[31m0\e[0m)((\e[36mtotal\e[0m,\
    \ \e[36mcurrent\e[0m) => total + (current - \e[31m1\e[0m) * current / \e[31m2\e\
    [0m)\n\e[31m\e[31m   |\e[0m\t                                                \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1660012892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var collisions = 0\n \
    \       for (x <- 1 to n) {\n            var collision = false\n            for\
    \ (y <- 1 to n) {\n                if (x > y) {\n                    if (x % y\
    \ == 0) {\n                        collision = true\n                    }\n \
    \               }\n            }\n            if (collision) collisions += 1\n\
    \        }\n        collisions\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5_f5scgd.scala:14:23\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mfor\e[0m (x <-\
    \ \e[31m1\e[0m to n) {\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\e\
    [31m   |\e[0m                       Found:    (n : Long)\n\e[31m   |\e[0m    \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp5_f5scgd.scala:16:27 --------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m            \e[33mfor\e[0m (y <- \e[31m1\e[0m to n) {\n\e[31m\e[31m  \
    \ |\e[0m                           ^\e[0m\n\e[31m   |\e[0m                   \
    \        Found:    (n : Long)\n\e[31m   |\e[0m                           Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660012892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Realize that two cars\
    \ collide if and only if at some point in time the\n        // car on the left\
    \ is at the same location as the car on the right.\n        // The cars are moving\
    \ at constant speed and the road is straight, so the\n        // location of a\
    \ given car at any point in time is a linear function of time.\n        // Here\
    \ we assume that the cars are numbered 0 to n-1, where the left-to-right\n   \
    \     // cars are numbered 0 to n/2-1 and the right-to-left cars are numbered\
    \ n/2 to n-1.\n        // The number of collisions is then the number of pairs\
    \ of indices i < j\n        // such that the linear functions describing the location\
    \ of the ith car and\n        // the jth car are equal at some point in time.\n\
    \        // We show a proof of this for the case where n is even; the odd case\
    \ is similar.\n        // One linear function is given by f(t) = a*t+b, the other\
    \ linear function is\n        // given by g(t) = c*t+d.\n        // The two cars\
    \ collide if and only if there exists a value t >= 0 such that\n        // f(t)\
    \ = g(t).  Since f(t) = a*t+b and g(t) = c*t+d, there exists a value t >= 0\n\
    \        // such that a*t+b = c*t+d, if and only if a*t - c*t = d - b,\n     \
    \   // which happens if and only if a-c != 0 and t = (d-b)/(a-c).\n        //\
    \ We have shown that i and j collide if and only if a-c != 0 and\n        // t\
    \ = (d-b)/(a-c) is a nonnegative real number.\n        // Now we show that a-c\
    \ != 0 if and only if i < j.\n        // Since 0 <= i < n/2, it follows that car\
    \ i is going left to right and\n        // car j is going right to left.  Therefore,\
    \ a-c < 0.\n        // On the other hand, since i < j, it follows that a-c < 0\
    \ if and only if i < j.\n        // Therefore, i and j collide\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n\
    \    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd45o5tkx.scala:12:44\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcarRaceCollision\e\
    [0m(\e[36mn\e[0m : \e[35mLong\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    Unit\n\e[31m   |\e[0m        \
    \                                    Required: Long\n\e[31m13 |\e[0m        \e\
    [34m// Realize that two cars collide if and only if at some point in time the\e\
    [0m\n\e[31m14 |\e[0m        \e[34m// car on the left is at the same location as\
    \ the car on the right.\e[0m\n\e[31m15 |\e[0m        \e[34m// The cars are moving\
    \ at constant speed and the road is straight, so the\e[0m\n\e[31m16 |\e[0m   \
    \     \e[34m// location of a given car at any point in time is a linear function\
    \ of time.\e[0m\n\e[31m17 |\e[0m        \e[34m// Here we assume that the cars\
    \ are numbered 0 to n-1, where the left-to-right\e[0m\n\e[31m18 |\e[0m       \
    \ \e[34m// cars are numbered 0 to n/2-1 and the right-to-left cars are numbered\
    \ n/2 to n-1.\e[0m\n\e[31m19 |\e[0m        \e[34m// The number of collisions is\
    \ then the number of pairs of indices i < j\e[0m\n\e[31m20 |\e[0m        \e[34m//\
    \ such that the linear functions describing the location of the ith car and\e\
    [0m\n\e[31m21 |\e[0m        \e[34m// the jth car are equal at some point in time.\e\
    [0m\n\e[31m22 |\e[0m        \e[34m// We show a proof of this for the case where\
    \ n is even; the odd case is similar.\e[0m\n\e[31m23 |\e[0m        \e[34m// One\
    \ linear function is given by f(t) = a*t+b, the other linear function is\e[0m\n\
    \e[31m24 |\e[0m        \e[34m// given by g(t) = c*t+d.\e[0m\n\e[31m25 |\e[0m \
    \       \e[34m// The two cars collide if and only if there exists a value t >=\
    \ 0 such that\e[0m\n\e[31m26 |\e[0m        \e[34m// f(t) = g(t).  Since f(t) =\
    \ a*t+b and g(t) = c*t+d, there exists a value t >= 0\e[0m\n\e[31m27 |\e[0m  \
    \      \e[34m// such that a*t+b = c*t+d, if and only if a*t - c*t = d - b,\e[0m\n\
    \e[31m28 |\e[0m        \e[34m// which happens if and only if a-c != 0 and t =\
    \ (d-b)/(a-c).\e[0m\n\e[31m29 |\e[0m        \e[34m// "
  stdout: ''
  timestamp: 1660012892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var collisions = 0L\n\
    \        // If a car at position i on the left is hit by a car at position j on\
    \ the right,\n        // then the car at position i on the left will have a distance\
    \ to the car at position j\n        // on the right of i + j.\n        // We can\
    \ treat this distance as a \"starting position\" of the car at position i on the\
    \ left,\n        // and the car at position j on the right as a \"starting position\"\
    \ of the car at position j on the right.\n        // Suppose the \"starting position\"\
    \ of the car at position i on the left is x, and the\n        // \"starting position\"\
    \ of the car at position j on the right is y.\n        // Then the times taken\
    \ for them to meet would be (x + y) / (i + j).\n        // The time taken for\
    \ two cars to meet would be the lowest amongst all the \"starting positions\"\
    \ of all the cars\n        // on the left, and all the \"starting positions\"\
    \ of all the cars on the right.\n        // If the \"starting position\" of the\
    \ car at position i on the left is x, and the\n        // \"starting position\"\
    \ of the car at position j on the right is y, then the time taken\n        //\
    \ for them to meet is (x + y) / (i + j).\n        // If the time taken is t, then\
    \ the distance of the car at position i on the left is i * t,\n        // and\
    \ the distance of the car at position j on the right is j * t.\n        // This\
    \ means that the distance of the car at position i on the left minus the distance\
    \ of the car at position j on the right\n        // is (i * t - j * t) = (i -\
    \ j) * t.\n        // We want to find two cars with the lowest collision time\
    \ t.  So we can instead try to find\n        // two cars with the smallest (i\
    \ - j) * t = x + y.\n        // We can use a standard algorithm for finding the\
    \ smallest element of a set of numbers.\n        // The numbers are the \"starting\
    \ positions\" of the cars.\n        // The algorithm is like this:\n        //\
    \ Start with two indices, one for the left cars and one for the right cars.\n\
    \        // If the number indicated by the left index\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd1sw8_8e.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660012892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        val cars = ArrayBuffer.fill(n.toInt)(0)\n\
    \        for (i <- 0 until n.toInt) cars(i) = i\n        cars.toArray.groupBy(x\
    \ => x).map(_._2.length).filter(_ > 1).map(_ - 1).sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw4rmf0wf.scala:18)\n\tat Problem.main(tmpw4rmf0wf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012893
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let's say the speed\
    \ of a car is x.  Then there is a collision\n        // at point n/x.  Therefore,\
    \ there are n(n-1)/2 such points.\n        // If we let x go from 1 to n, then\
    \ we get the desired result.\n        // The sum of 1 to n is n(n+1)/2.  Therefore,\
    \ we divide by 2.\n        return n * (n-1) / 2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmd49x2s5.scala:20)\n\tat Problem.main(tmpmd49x2s5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The \"standard\" solution\
    \ is to sort the n cars that are moving left to right\n        // by their starting\
    \ position, and then do a linear scan to count the number of\n        // collisions.\
    \  This takes O(n lg n) time and O(n) space.\n        //\n        // Instead,\
    \ we can use the O(n lg n) time algorithm to merge-sort only the\n        // cars\
    \ that are moving right to left.  We can then scan the two sorted arrays\n   \
    \     // side by side in O(n) time and output the number of collisions.\n    \
    \    val n1 = n;\n        val n2 = n;\n        var a = new Array[Long](n1.toInt);\n\
    \        var b = new Array[Long](n2.toInt);\n        for (i <- 0 until n1.toInt)\
    \ {\n            a(i) = 1 + i;\n        }\n        for (i <- 0 until n2.toInt)\
    \ {\n            b(i) = n1 + n2 - i;\n        }\n        println(a.mkString(\"\
    \ \"));\n        println(b.mkString(\" \"));\n        val c = MergeSort.mergeSort(b);\n\
    \        println(c.mkString(\" \"));\n        var i = 0;\n        var j = 0;\n\
    \        var count = 0;\n        while (i < n1 && j < n2) {\n            if (a(i)\
    \ < c(j)) {\n                i += 1;\n            } else {\n                count\
    \ += 1;\n                j += 1;\n            }\n        }\n        count;\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5kzu9tk6.scala:32:16 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mc\e[0m = MergeSort.mergeSort(b);\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \       Not found: MergeSort\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660012891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Given 2n cars.  There\
    \ are n collisions if every car on the left goes at a slower\n        // speed\
    \ than every car on the right; there are 0 collisions if every car on the left\n\
    \        // goes at a faster speed than every car on the right.  There are 0 collisions\
    \ if every\n        // car on the left goes at the same speed as every car on\
    \ the right.  And there are\n        // n(n-1)/2 collisions if the n cars on the\
    \ left go at n distinct speeds, and the n cars\n        // on the right go at\
    \ n distinct speeds.\n        // (Note: it's possible to have the same speed but\
    \ different cars on the left and the right.\n        // This can result in less\
    \ than n(n-1)/2 collisions)\n        // For example, there are 2 cars:\n     \
    \   //   A left car with speed 2\n        //   A right car with speed 1\n    \
    \    // A left car with speed 1\n        // A right car with speed 2\n       \
    \ // There are 1 + 1 = 2 collisions.\n        // However, if the two cars swap\
    \ places, there are 0 collisions.\n        // A left car with speed 1\n      \
    \  // A right car with speed 2\n        // A left car with speed 2\n        //\
    \ A right car with speed 1\n        val nLeft = n\n        val nRight = n\n  \
    \      val nPairs = nLeft * nRight\n        val nDup = (1 to nLeft.toInt).map(a\
    \ =>\n            (1 to nRight.toInt).map(b =>\n                if (a == b) 1\
    \ else 0).sum).sum\n        val nUnique = nPairs - nDup\n        nUnique / 2\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpijr3abwe.scala:42)\n\tat Problem.main(tmpijr3abwe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012894
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // Let the ith car in\
    \ the left to right group be at coordinate i - 1.\n        // Let the ith car\
    \ in the right to left group be at coordinate 2n - i.\n        // If a car at\
    \ coordinate i collides with a car at coordinate j,\n        // then we know that\
    \ i - j > 0.  Letting m = i - j, the ith car in the left to right\n        //\
    \ group collides with the mth car in the right to left group.\n        // We repeat\
    \ this process for all cars in the left to right group;\n        // the total\
    \ number of collisions is equal to the number of collisions\n        // for the\
    \ ith car in the left to right group for all i.\n        // The collision of ith\
    \ car in the left to right group with the mth car in the right to left group is\n\
    \        // equal to the number of cars from the mth car to the (2n - i)th car\
    \ in the right to left group.\n        // There are (2n - i - m + 1) = (2n - i\
    \ - (i - j) + 1) = (2n - 2i + j + 1) cars in the right to left group\n       \
    \ // from the (i - j)th car to the (2n - i)th car.\n        // Therefore, the\
    \ total number of collisions is equal to\n        // the sum of (2n - 2i + j +\
    \ 1) for all i from 1 to n, and all j from 1 to i - 1.\n        val totalCollisions\
    \ = (1 to n.toInt).map(i => (1 to i - 1).map(j => 2 * n - 2 * i + j + 1).sum).sum\n\
    \        totalCollisions\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbs9eus3g.scala:31)\n\tat Problem.main(tmpbs9eus3g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012894
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var count = 0L\n     \
    \   for (i <- 1L to n) {\n            count += (i - 1) * 2\n        }\n      \
    \  count\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkprepqci.scala:20)\n\tat Problem.main(tmpkprepqci.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        def go(i : Long, j : Long,\
    \ count : Long) : Long = {\n            if (i == n) count\n            else {\n\
    \                val collision = if (j < n) n - j - 1 else n - j\n           \
    \     go(i + 1, j + 1, count + collision)\n            }\n        }\n        go(0,\
    \ 0, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn5b6di1s.scala:23)\n\tat Problem.main(tmpn5b6di1s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012894
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // The idea is to consider\
    \ all the cars moving from left to right, and\n        // all the cars moving\
    \ from right to left as a single set of cars moving\n        // both ways on a\
    \ single infinitely long line.\n        // The number of collisions can then be\
    \ thought of as a question of\n        // counting number of pairs of cars which\
    \ are moving in opposite directions\n        // and have the same speed.\n   \
    \     // We will solve this problem using brute force.\n        var cnt = 0L\n\
    \        for (i <- 1L to n) {\n            // Let i be the speed of a car that's\
    \ moving left to right\n            // At each point in time, this car will be\
    \ at position x = i * t\n            // Therefore, it will collide with a car\
    \ that's moving right to left\n            // if and only if its position x is\
    \ equal to j * t, where j is the speed\n            // of that car.  It is easy\
    \ to verify that the solution to this equation\n            // is t = n / (i +\
    \ j).  Therefore, we will take all the values of j from\n            // 1 to n,\
    \ and compute t for each pair of i and j.  If t is an integer,\n            //\
    \ then we have a collision.\n            for (j <- 1L to n) {\n              \
    \  val t = n / (i + j)\n                if (t * (i + j) == n) cnt += 1\n     \
    \       }\n        }\n        cnt\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjlj0i62g.scala:38)\n\tat Problem.main(tmpjlj0i62g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        // We shall call a right-to-left\
    \ car a \"negative car\", and a left-to-right car a \"positive car\".\n      \
    \  // To determine the number of collisions, it is equivalent to count the number\
    \ of \"negative cars\"\n        // between two consecutive \"positive cars\".\n\
    \        // In other words, we can sort the n negative cars and n positive cars\
    \ by their initial positions,\n        // and for each positive car, we can compute\
    \ the number of negative cars in its left and right;\n        // then the number\
    \ of collisions is just the total of these numbers.\n        // To do so, we can\
    \ use an interval tree or segment tree; however, a simple stack implementation\
    \ is also effective.\n        // First, we sort the cars by their initial positions:\n\
    \        val cars = ArrayBuffer.empty[Long]\n        for (i <- 0L until n) cars\
    \ += i\n        val negativeCars = cars.sortWith(_ > _)\n        val positiveCars\
    \ = cars.sortWith(_ < _)\n        var numCollisions = 0L\n        val st = Stack.empty[Long]\n\
    \        for (car <- positiveCars) {\n            while (!st.isEmpty && st.top\
    \ < car) {\n                numCollisions += 1\n                st.pop\n     \
    \       }\n            st.push(car)\n        }\n        return numCollisions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
    \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
    \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
    \ == (100l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3ggp2ftj.scala:37)\n\tat Problem.main(tmp3ggp2ftj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660012895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
    \    // n cars are driving left to right;  simultaneously, a different set of\
    \ n cars\n    // are driving right to left.   The two sets of cars start out being\
    \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
    \ are said to collide\n    // when a car that's moving left to right hits a car\
    \ that's moving right to left.\n    // However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    // in their trajectory as\
    \ if they did not collide.\n    // This function outputs the number of such collisions.\n\
    \    def carRaceCollision(n : Long) : Long = {\n        var ans = 0L\n       \
    \ for (i <- 1L to n) {\n            for (j <- 1L to n) {\n                if (gcd(i,\
    \ j) == 1) ans += 1\n            }\n        }\n        ans\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(carRaceCollision((2l)) == (4l));\n    assert(carRaceCollision((3l))\
    \ == (9l));\n    assert(carRaceCollision((4l)) == (16l));\n    assert(carRaceCollision((8l))\
    \ == (64l));\n    assert(carRaceCollision((10l)) == (100l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm1thfpzl.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                \e[33mif\e[0m (gcd(i, j) == \e[31m1\e\
    [0m) ans += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: gcd\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660012894
